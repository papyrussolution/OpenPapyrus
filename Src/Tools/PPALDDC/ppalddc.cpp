
/*  A Bison parser, made from ppalddc.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	T_TDBL	258
#define	T_TLONG	259
#define	T_TSTR	260
#define	T_TDEC	261
#define	T_TMON	262
#define	T_TINT	263
#define	T_TINT16	264
#define	T_TDATE	265
#define	T_TTIME	266
#define	T_TFLOAT	267
#define	T_TLINK	268
#define	T_TKEY	269
#define	T_ORDER	270
#define	T_ARRAY_LONG	271
#define	T_ARRAY_DBL	272
#define	T_COUNTER	273
#define	T_DATA	274
#define	T_FILTER	275
#define	T_ITER	276
#define	T_LBR	277
#define	T_RBR	278
#define	T_DECLARE	279
#define	T_EQ	280
#define	T_IF	281
#define	T_LEFT	282
#define	T_MIDL	283
#define	T_RIGHT	284
#define	T_WRAP	285
#define	T_FORMATPERIOD	286
#define	T_PRINTABLEBARCODE	287
#define	T_SQRT	288
#define	TS_MONEY	289
#define	TS_DATE	290
#define	TWS_DATE	291
#define	TS_NUMBER	292
#define	T_MKSTR	293
#define	T_ROUND	294
#define	T_TRUNC	295
#define	T_ABS	296
#define	T_CODEGEN	297
#define	T_NODESTRUCTORMETHOD	298
#define	T_NODESTROYMETHOD	299
#define	T_IDENT	300
#define	T_STR	301
#define	T_FMT	302
#define	T_INTEGER	303
#define	T_VALUE	304
#define	T_LOG_OR	305
#define	T_LOG_AND	306
#define	T_EQUL	307
#define	T_NOTEQUL	308
#define	T_GREAT	309
#define	T_LESS_EQ	310
#define	T_GREAT_EQ	311
#define	T_LESS	312
#define	T_BIT_OR	313
#define	T_BIT_XOR	314
#define	T_BIT_AND	315
#define	IFXS	316
#define	IFX	317
#define	T_ELSE	318
#define	TO_DBL	319
#define	TO_INT	320
#define	TO_STR	321
#define	T_LEN	322
#define	UPLUS	323
#define	UMINUS	324
#define	T_BIT_NOT	325

#line 6 "ppalddc.y"

//#include <stdlib.h>
//#include <fcntl.h>
//#include <sys\stat.h>
//#include <string.h>
//#include <memory.h>
#include <slib.h>
#include "ppalddc.h"

// Prototypes
static void SetupVarDef(const char * pName, long typ);
static NodeType GetNodeType1(long opType, NodeType & arg1);
static NodeType GetNodeType2(long opType, NodeType & arg1, NodeType & arg2);
static NodeType GetNodeType3(long opType, NodeType & arg1, NodeType & arg2, NodeType & arg3);

VARDEFS  * VarDefs = 0;
ITERDEFS * IterDefs = 0;
DATADEFS * DataDefs = 0;
ORDERDEFS * OrderDefs = 0;
long ary_type = 0;

extern FILE * yyin;

char in_file_name[MAXPATH];
char h_file_name[MAXPATH];
char cpp_file_name[MAXPATH];
char hflt_file_name[MAXPATH];
char cppflt_file_name[MAXPATH];
char bin_file_name[MAXPATH];
long have_key  = 0;
long have_iter = 0;
long cur_iter  = 0;
long link_var  = 0;
long node_offset = 0;
long ext_cnt   = 0;
long IsOrder   = 0;
FormatSpec fspec;

typedef struct {
	void * yyin_buf;
	char fname[_MAX_PATH];
	long yyin_line;
} YYIN_STR;

extern long yyin_cnt;
extern YYIN_STR * yyin_struct;

NodeType args[10];
FILE * nodefile;

void yyerror(char * str)
{
	if(yyin_cnt)
		printf("Error %s(%d): %s\n", yyin_struct[yyin_cnt-1].fname, yyline, str);
	else
		printf("Error (%d): %s\n", yyline, str);
	exit(-1);
}

void yyerr_invparam(char * pFuncName)
{
	char msg_buf[256];
	sprintf(msg_buf, "Invalid parameters in function %s", pFuncName);
	yyerror(msg_buf);
}

static void CopyIt(char *dst, const char *src, unsigned maxlen)
{
	if(dst)
		if(strlen(src) >= maxlen) {
			strncpy(dst, src, maxlen);
			dst[maxlen] = 0;
		}
		else
			strcpy(dst, src);
}

static int DotFound(char * pB)
{
	if(*(pB-1) == '.')
		pB--;
	switch(*--pB) {
		case ':'  :
			if(*(pB-2) != '\0')
				break;
		case '/'  :
		case '\\' :
		case '\0' :
			return 1;
	}
	return 0;
}

void fnmerge(register char *pathP, const char *driveP, const char *dirP, const char *nameP, const char *extP)
{
	_makepath(pathP,driveP,dirP,nameP,extP);
}

int _fnsplit(const char *pathP, char *driveP, char *dirP, char *nameP, char *extP)
{
	register char *pB;
	register int Wrk;
	int Ret;

	char buf[ MAXPATH+2 ];
	/*
		Set all string to default value zero
	*/
	Ret = 0;
	if(driveP)
		*driveP = 0;
	if(dirP)
		*dirP = 0;
	if(nameP)
		*nameP = 0;
	if(extP)
		*extP = 0;
	/*
		Copy filename into template up to MAXPATH characters
	*/
	pB = buf;
	while (*pathP == ' ')
		pathP++;
	if((Wrk = strlen(pathP)) > MAXPATH)
		Wrk = MAXPATH;
	*pB++ = 0;
	strncpy(pB, pathP, Wrk);
	*(pB += Wrk) = 0;
	/*
		Split the filename and fill corresponding nonzero pointers
	*/
	Wrk = 0;
	for(; ; ) {
		switch (*--pB) {
		case '.'  :
			if(!Wrk && (*(pB+1) == '\0'))
				Wrk = DotFound(pB);
			if((!Wrk) && ((Ret & FNF_EXTENSION) == 0)) {
				Ret |= EXTENSION;
				CopyIt(extP, pB, MAXEXT - 1);
				*pB = 0;
			}
			continue;
		case ':'  :
			if(pB != &buf[2])
				continue;
		case '\0' :
			if(Wrk) {
				if(*++pB)
					Ret |= FNF_DIRECTORY;
				CopyIt(dirP, pB, MAXDIR - 1);
				*pB-- = 0;
				break;
			}
		case '/'  :
		case '\\' :
			if(!Wrk) {
				Wrk++;
				if(*++pB)
					Ret |= FNF_FILENAME;
				CopyIt(nameP, pB, MAXFILE - 1);
				*pB-- = 0;
				if(*pB == 0 || (*pB == ':' && pB == &buf[2]))
					break;
			}
			continue;
		case '*'  :
		case '?'  :
			if(!Wrk)
				Ret |= FNF_WILDCARDS;
		default :
			continue;
		}
		break;
	}
	if(*pB == ':') {
		if(buf[1])
			Ret |= FNF_DRIVE;
		CopyIt(driveP, &buf[1], MAXDRIVE - 1);
	}
	return Ret;
}


#line 192 "ppalddc.y"
typedef union {
	long   lval;
	double dval;
	char * sval;
	NodeType nType;
} YYSTYPE;
#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		272
#define	YYFLAG		-32768
#define	YYNTBASE	85

#define YYTRANSLATE(x) ((unsigned)(x) <= 325 ? yytranslate[x] : 116)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,    81,
    82,    64,    62,    84,    63,    66,    65,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    77,    80,     2,
     2,     2,    50,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    78,     2,    79,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,    83,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    67,    68,    69,    70,    71,
    72,    73,    74,    75,    76
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     4,    11,    16,    19,    22,    23,    26,    28,
    31,    32,    35,    37,    39,    42,    43,    50,    55,    58,
    61,    64,    67,    70,    73,    76,    79,    82,    85,    88,
    91,    94,    97,    98,   102,   108,   109,   111,   112,   114,
   116,   117,   125,   127,   129,   130,   138,   140,   142,   144,
   146,   150,   156,   162,   170,   173,   176,   179,   182,   187,
   192,   199,   206,   209,   212,   219,   228,   235,   242,   249,
   256,   263,   270,   279,   286,   293,   300,   307,   312,   316,
   320,   324,   328,   332,   336,   340,   344,   348,   352,   356,
   360,   364,   368,   372,   374,   376,   380,   382,   388,   389,
   390,   396,   398,   402,   404,   407,   409
};

static const short yyrhs[] = {    -1,
    85,    86,     0,    88,    89,    22,    90,    93,    92,     0,
    87,    22,    93,    92,     0,    20,    45,     0,    19,    45,
     0,     0,    77,    45,     0,    91,     0,    90,    91,     0,
     0,    24,    46,     0,    23,     0,    94,     0,    93,    94,
     0,     0,    97,    95,    98,    99,   100,   101,     0,    96,
    99,   100,   101,     0,    16,    45,     0,    17,    45,     0,
     8,    45,     0,    14,    45,     0,     4,    45,     0,     3,
    45,     0,     5,    45,     0,     6,    45,     0,     7,    45,
     0,     9,    45,     0,    10,    45,     0,    11,    45,     0,
    12,    45,     0,    18,    45,     0,     0,    78,    48,    79,
     0,    78,    48,    66,    48,    79,     0,     0,    45,     0,
     0,    47,     0,    80,     0,     0,    13,    45,   102,   103,
    99,   100,   104,     0,    45,     0,    80,     0,     0,   106,
    25,   107,   105,    99,   100,    80,     0,    45,     0,    49,
     0,    48,     0,    46,     0,    81,   107,    82,     0,   107,
    50,   107,    77,   107,     0,    26,    81,   107,    82,   107,
     0,    26,    81,   107,    82,   107,    69,   107,     0,    83,
   107,     0,    63,   107,     0,    62,   107,     0,    73,   107,
     0,    33,    81,   107,    82,     0,   107,    78,   107,    79,
     0,    39,    81,   107,    84,   107,    82,     0,    40,    81,
   107,    84,   107,    82,     0,    70,   107,     0,    71,   107,
     0,    34,    81,   107,    84,    48,    82,     0,    34,    81,
   107,    84,    48,    84,    48,    82,     0,    35,    81,   107,
    84,    48,    82,     0,    36,    81,   107,    84,    48,    82,
     0,    37,    81,   107,    84,    48,    82,     0,    38,    81,
    48,    84,    48,    82,     0,    27,    81,   107,    84,   107,
    82,     0,    29,    81,   107,    84,   107,    82,     0,    28,
    81,   107,    84,   107,    84,   107,    82,     0,    30,    81,
   107,    84,   107,    82,     0,    72,    81,   107,    84,    47,
    82,     0,    31,    81,   107,    84,   107,    82,     0,    32,
    81,   107,    84,   107,    82,     0,    41,    81,   107,    82,
     0,   107,    53,   107,     0,   107,    54,   107,     0,   107,
    58,   107,     0,   107,    56,   107,     0,   107,    55,   107,
     0,   107,    57,   107,     0,   107,    51,   107,     0,   107,
    52,   107,     0,   107,    59,   107,     0,   107,    60,   107,
     0,   107,    61,   107,     0,   107,    62,   107,     0,   107,
    63,   107,     0,   107,    64,   107,     0,   107,    65,   107,
     0,   108,     0,    45,     0,   108,    66,   109,     0,    45,
     0,   114,    22,   110,    93,   115,     0,     0,     0,    15,
   111,    22,   112,    23,     0,   113,     0,   112,    84,   113,
     0,    45,     0,    21,    45,     0,    21,     0,    23,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   276,   277,   279,   280,   282,   295,   308,   313,   320,   320,
   324,   326,   338,   343,   343,   345,   349,   350,   352,   355,
   360,   363,   376,   379,   382,   385,   388,   391,   394,   397,
   400,   403,   412,   418,   428,   435,   438,   444,   447,   452,
   460,   463,   472,   481,   483,   488,   495,   504,   511,   518,
   527,   528,   529,   530,   531,   532,   533,   534,   535,   553,
   575,   587,   599,   607,   615,   626,   637,   648,   659,   670,
   672,   678,   684,   689,   695,   713,   719,   725,   734,   735,
   736,   737,   738,   739,   740,   741,   742,   743,   744,   745,
   746,   747,   748,   749,   751,   763,   773,   789,   791,   793,
   802,   807,   807,   809,   817,   836,   851
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","T_TDBL",
"T_TLONG","T_TSTR","T_TDEC","T_TMON","T_TINT","T_TINT16","T_TDATE","T_TTIME",
"T_TFLOAT","T_TLINK","T_TKEY","T_ORDER","T_ARRAY_LONG","T_ARRAY_DBL","T_COUNTER",
"T_DATA","T_FILTER","T_ITER","T_LBR","T_RBR","T_DECLARE","T_EQ","T_IF","T_LEFT",
"T_MIDL","T_RIGHT","T_WRAP","T_FORMATPERIOD","T_PRINTABLEBARCODE","T_SQRT","TS_MONEY",
"TS_DATE","TWS_DATE","TS_NUMBER","T_MKSTR","T_ROUND","T_TRUNC","T_ABS","T_CODEGEN",
"T_NODESTRUCTORMETHOD","T_NODESTROYMETHOD","T_IDENT","T_STR","T_FMT","T_INTEGER",
"T_VALUE","'?'","T_LOG_OR","T_LOG_AND","T_EQUL","T_NOTEQUL","T_GREAT","T_LESS_EQ",
"T_GREAT_EQ","T_LESS","T_BIT_OR","T_BIT_XOR","T_BIT_AND","'+'","'-'","'*'","'/'",
"'.'","IFXS","IFX","T_ELSE","TO_DBL","TO_INT","TO_STR","T_LEN","UPLUS","UMINUS",
"T_BIT_NOT","':'","'['","']'","';'","'('","')'","'~'","','","descr_list","descr_struct",
"filt_head","list_head","parent_str","declare_list","declare_statement","list_tail",
"list_body","s_field","@1","s_array","s_type","dim","alias","format","sf_tail",
"@2","lf_tail","lf_post_tail","@3","exf_head","expr","chain_ident","chain_tail",
"order_body","@4","order_list","order_field","if_head","if_tail", NULL
};
#endif

static const short yyr1[] = {     0,
    85,    85,    86,    86,    87,    88,    89,    89,    90,    90,
    91,    91,    92,    93,    93,    95,    94,    94,    96,    96,
    97,    97,    97,    97,    97,    97,    97,    97,    97,    97,
    97,    97,    98,    98,    98,    99,    99,   100,   100,   101,
   102,    94,   103,   104,   105,    94,   106,   107,   107,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   107,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   107,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   107,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   107,   107,
   107,   107,   107,   107,   108,   108,   109,    94,   110,   111,
   110,   112,   112,   113,   114,   114,   115
};

static const short yyr2[] = {     0,
     0,     2,     6,     4,     2,     2,     0,     2,     1,     2,
     0,     2,     1,     1,     2,     0,     6,     4,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     0,     3,     5,     0,     1,     0,     1,     1,
     0,     7,     1,     1,     0,     7,     1,     1,     1,     1,
     3,     5,     5,     7,     2,     2,     2,     2,     4,     4,
     6,     6,     2,     2,     6,     8,     6,     6,     6,     6,
     6,     6,     8,     6,     6,     6,     6,     4,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     1,     1,     3,     1,     5,     0,     0,
     5,     1,     3,     1,     2,     1,     1
};

static const short yydefact[] = {     1,
     0,     0,     0,     2,     0,     7,     6,     5,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   106,    47,     0,    14,
    36,    16,     0,     0,     8,    11,    24,    23,    25,    26,
    27,    21,    28,    29,    30,    31,    41,    22,    19,    20,
    32,   105,    13,     4,    15,    37,    38,    33,     0,    99,
     0,     0,     9,     0,    39,     0,     0,    36,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    95,    50,    49,    48,     0,     0,
     0,     0,     0,     0,     0,     0,    45,    94,   100,     0,
    12,    10,     0,    43,    36,    40,    18,     0,    38,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    57,    56,    63,    64,     0,
    58,     0,    55,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    36,     0,     0,     0,     3,    38,     0,    34,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    51,     0,    85,    86,
    79,    80,    83,    82,    84,    81,    87,    88,    89,    90,
    91,    92,    93,     0,    38,    97,    96,     0,   107,    98,
     0,     0,    17,     0,     0,     0,     0,     0,     0,     0,
    59,     0,     0,     0,     0,     0,     0,     0,    78,     0,
     0,    60,     0,   104,     0,   102,    44,    42,    35,    53,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    52,    46,   101,     0,     0,    71,
     0,    72,    74,    76,    77,    65,     0,    67,    68,    69,
    70,    61,    62,    75,   103,    54,     0,     0,    73,    66,
     0,     0
};

static const short yydefgoto[] = {     1,
     4,     5,     6,    11,    62,    63,    54,    29,    30,    58,
    31,    32,    68,    57,    66,   107,    64,   105,   228,   151,
    33,    97,    98,   197,   100,   153,   225,   226,    34,   200
};

static const short yypact[] = {-32768,
    44,   -35,   -33,-32768,    -9,   -63,-32768,-32768,   233,    -7,
    18,    -3,    -2,    27,    28,    29,    32,    33,    36,    51,
    55,    58,    67,    78,    80,    85,    86,-32768,    81,-32768,
   105,-32768,   126,   130,-32768,   131,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,   111,    83,   108,   144,
   117,   189,-32768,   127,-32768,    93,   128,   105,    94,    96,
   102,   103,   106,   107,   109,   123,   133,   146,   150,   151,
   167,   171,   172,   174,-32768,-32768,-32768,-32768,   108,   108,
   108,   108,   175,   108,   108,   108,  1153,   119,-32768,   233,
-32768,-32768,    81,-32768,   105,-32768,-32768,     0,   111,   108,
   108,   108,   108,   108,   108,   108,   108,   108,   108,   108,
   108,   138,   108,   108,   108,   134,   134,   134,   134,   108,
   134,   698,   134,   108,   108,   108,   108,   108,   108,   108,
   108,   108,   108,   108,   108,   108,   108,   108,   108,   108,
   105,   129,   186,   212,-32768,   111,   161,-32768,    93,   731,
   208,   243,   278,   313,   348,   383,   764,   418,   453,   488,
   523,   190,   558,   593,   797,   628,-32768,  1124,  1180,  1206,
  1217,  1217,    46,    46,    46,    46,   104,   -45,     5,    49,
    49,   134,   134,  1094,   111,-32768,-32768,   166,-32768,-32768,
   195,   197,-32768,   108,   108,   108,   108,   108,   108,   108,
-32768,   229,   231,   232,   234,   235,   108,   108,-32768,   237,
   108,-32768,   201,-32768,   -19,-32768,-32768,-32768,-32768,     2,
   830,   663,   863,   896,   929,   962,   -73,   203,   205,   206,
   207,   995,  1028,   209,   134,-32768,-32768,   166,   108,-32768,
   108,-32768,-32768,-32768,-32768,-32768,   242,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,   134,  1061,   227,-32768,-32768,
   310,-32768
};

static const short yypgoto[] = {-32768,
-32768,-32768,-32768,-32768,-32768,   249,   210,   -25,   -21,-32768,
-32768,-32768,-32768,   -29,   -94,   153,-32768,-32768,-32768,-32768,
-32768,   -89,-32768,-32768,-32768,-32768,-32768,    66,-32768,-32768
};


#define	YYLAST		1295


static const short yytable[] = {   126,
   127,   128,   129,   247,   131,   132,   133,    55,   256,     7,
   257,     8,     9,    10,   159,   145,   146,   147,   148,   149,
   160,   161,   162,   163,   164,   165,   166,   167,   168,   169,
   170,   171,   150,   173,   174,   175,   103,    35,   109,    36,
   176,    37,    38,   271,   178,   179,   180,   181,   182,   183,
   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,
   194,   201,     2,     3,   248,   157,   146,   147,   148,   149,
   249,    39,    40,    41,   154,   156,    42,    43,   158,   150,
    44,    55,   150,    12,    13,    14,    15,    16,    17,    18,
    19,    20,    21,    22,    23,    45,    24,    25,    26,    46,
   223,    27,    47,    53,   143,   144,   145,   146,   147,   148,
   149,    48,   148,   149,   230,   231,   232,   233,   234,   235,
   236,   195,    49,   150,    50,    28,   150,   242,   243,    51,
    52,   245,    55,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    56,
    59,    60,    85,    86,    61,    87,    88,    65,    99,   266,
    67,   267,   101,   144,   145,   146,   147,   148,   149,    89,
    90,   104,   106,   196,   110,   108,   111,    91,    92,    93,
    94,   150,   112,   113,   152,   172,   114,   115,    95,   116,
    96,    12,    13,    14,    15,    16,    17,    18,    19,    20,
    21,    22,    23,   117,    24,    25,    26,   198,   202,    27,
   224,   150,    61,   118,    12,    13,    14,    15,    16,    17,
    18,    19,    20,    21,    22,    23,   119,    24,    25,    26,
   120,   121,    27,    28,   199,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,   122,    24,    25,
    26,   123,   124,    27,   125,   130,    28,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,   216,   227,   229,   237,    28,   238,   239,
   246,   240,   241,   244,   258,   150,   259,   260,   261,   268,
   264,   205,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,   270,   272,
   102,   203,   155,   265,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   206,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   207,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   208,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   209,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   210,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   212,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   213,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   214,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   215,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   217,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   218,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,     0,
     0,   220,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,     0,     0,   251,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,   177,
   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,
   144,   145,   146,   147,   148,   149,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   150,     0,
     0,     0,   204,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   148,   149,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   150,     0,     0,     0,   211,   134,   135,   136,   137,
   138,   139,   140,   141,   142,   143,   144,   145,   146,   147,
   148,   149,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   150,     0,     0,     0,   219,   134,
   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,
   145,   146,   147,   148,   149,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   150,     0,     0,
     0,   250,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,     0,     0,     0,   252,   134,   135,   136,   137,   138,
   139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
   149,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   150,     0,     0,     0,   253,   134,   135,
   136,   137,   138,   139,   140,   141,   142,   143,   144,   145,
   146,   147,   148,   149,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   150,     0,     0,     0,
   254,   134,   135,   136,   137,   138,   139,   140,   141,   142,
   143,   144,   145,   146,   147,   148,   149,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   150,
     0,     0,     0,   255,   134,   135,   136,   137,   138,   139,
   140,   141,   142,   143,   144,   145,   146,   147,   148,   149,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   150,     0,     0,     0,   262,   134,   135,   136,
   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,
   147,   148,   149,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   150,     0,     0,     0,   263,
   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,
   144,   145,   146,   147,   148,   149,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   150,     0,
     0,     0,   269,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   148,   149,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   150,   222,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   148,   149,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   221,   150,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   150,   136,   137,   138,   139,   140,   141,   142,   143,   144,
   145,   146,   147,   148,   149,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   150,   137,   138,
   139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
   149,   139,   140,   141,   142,   143,   144,   145,   146,   147,
   148,   149,     0,   150,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   150
};

static const short yycheck[] = {    89,
    90,    91,    92,    23,    94,    95,    96,    29,    82,    45,
    84,    45,    22,    77,   109,    61,    62,    63,    64,    65,
   110,   111,   112,   113,   114,   115,   116,   117,   118,   119,
   120,   121,    78,   123,   124,   125,    62,    45,    68,    22,
   130,    45,    45,     0,   134,   135,   136,   137,   138,   139,
   140,   141,   142,   143,   144,   145,   146,   147,   148,   149,
   150,   156,    19,    20,    84,    66,    62,    63,    64,    65,
    69,    45,    45,    45,   100,   105,    45,    45,    79,    78,
    45,   103,    78,     3,     4,     5,     6,     7,     8,     9,
    10,    11,    12,    13,    14,    45,    16,    17,    18,    45,
   195,    21,    45,    23,    59,    60,    61,    62,    63,    64,
    65,    45,    64,    65,   204,   205,   206,   207,   208,   209,
   210,   151,    45,    78,    45,    45,    78,   217,   218,    45,
    45,   221,   154,    26,    27,    28,    29,    30,    31,    32,
    33,    34,    35,    36,    37,    38,    39,    40,    41,    45,
    25,    22,    45,    46,    24,    48,    49,    47,    15,   249,
    78,   251,    46,    60,    61,    62,    63,    64,    65,    62,
    63,    45,    80,    45,    81,    48,    81,    70,    71,    72,
    73,    78,    81,    81,    66,    48,    81,    81,    81,    81,
    83,     3,     4,     5,     6,     7,     8,     9,    10,    11,
    12,    13,    14,    81,    16,    17,    18,    22,    48,    21,
    45,    78,    24,    81,     3,     4,     5,     6,     7,     8,
     9,    10,    11,    12,    13,    14,    81,    16,    17,    18,
    81,    81,    21,    45,    23,     3,     4,     5,     6,     7,
     8,     9,    10,    11,    12,    13,    14,    81,    16,    17,
    18,    81,    81,    21,    81,    81,    45,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    84,    80,    79,    48,    45,    48,    48,
    80,    48,    48,    47,    82,    78,    82,    82,    82,    48,
    82,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    82,     0,
    62,   159,   103,   248,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    -1,
    -1,    84,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    -1,    -1,    84,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    82,
    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,
    60,    61,    62,    63,    64,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,
    -1,    -1,    82,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63,    64,    65,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    78,    -1,    -1,    -1,    82,    50,    51,    52,    53,
    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    82,    50,
    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,
    -1,    82,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    -1,    -1,    -1,    82,    50,    51,    52,    53,    54,
    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    78,    -1,    -1,    -1,    82,    50,    51,
    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,
    62,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,
    82,    50,    51,    52,    53,    54,    55,    56,    57,    58,
    59,    60,    61,    62,    63,    64,    65,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,
    -1,    -1,    -1,    82,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    78,    -1,    -1,    -1,    82,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    78,    -1,    -1,    -1,    82,
    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,
    60,    61,    62,    63,    64,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    -1,
    -1,    -1,    82,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63,    64,    65,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    78,    79,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63,    64,    65,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    77,    78,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    78,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    53,    54,
    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
    65,    55,    56,    57,    58,    59,    60,    61,    62,    63,
    64,    65,    -1,    78,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    78
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/mingw32/share/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#ifdef _MSC_VER
#include <malloc.h>
#else /* not Visual C++ */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not Visual C++ */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)
#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        return(0)
#define YYABORT         return(1)
#define YYERROR         goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)

#ifdef MSG_ENUM

#define YYBACKUP(token, value) \
do                                                              \
  if (yychar == YYEMPTY && yylen == 1)                          \
    { yychar = (token), yylval = (value);                       \
      yychar1 = YYTRANSLATE (yychar);                           \
      YYPOPSTACK;                                               \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    { yyerror (msgYaccBackup); YYERROR; }      \
while (0)

#else

#define YYBACKUP(token, value) \
do                                                              \
  if (yychar == YYEMPTY && yylen == 1)                          \
    { yychar = (token), yylval = (value);                       \
      yychar1 = YYTRANSLATE (yychar);                           \
      YYPOPSTACK;                                               \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    { yyerror ("syntax error: cannot back up"); YYERROR; }      \
while (0)

#endif

#define YYTERROR        1
#define YYERRCODE       256

#ifndef YYPURE
#define YYLEX           yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX           yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX           yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX           yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX           yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int     yychar;                 /*  the lookahead symbol                */
YYSTYPE yylval;                 /*  the semantic value of the           */
                                /*  lookahead symbol                    */

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;                 /*  location data for the lookahead     */
                                /*  symbol                              */
#endif

int yynerrs;                    /*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;                    /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1                /* GNU C and GNU C++ define this.  */
#define __yy_memcpy(TO,FROM,COUNT)      __builtin_memcpy(TO,FROM,COUNT)
#else                           /* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *to, char *from, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/mingw32/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

int
yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;      /*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;              /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];     /*  the state stack                     */
  YYSTYPE yyvsa[YYINITDEPTH];   /*  the semantic value stack            */

  short *yyss = yyssa;          /*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;        /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];   /*  the location stack                  */
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;                /*  the variable used to return         */
                                /*  semantic values from the action     */
                                /*  routines                            */

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;             /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
         the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
         but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
                 &yyss1, size * sizeof (*yyssp),
                 &yyvs1, size * sizeof (*yyvsp),
                 &yyls1, size * sizeof (*yylsp),
                 &yystacksize);
#else
      yyoverflow("parser stack overflow",
                 &yyss1, size * sizeof (*yyssp),
                 &yyvs1, size * sizeof (*yyvsp),
                 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
        {
          #ifdef MSG_ENUM
              yyerror(msgYaccStack);
          #else
              yyerror("parser stack overflow");
          #endif
          return 2;
        }
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
        yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
        fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
        YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
        fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)              /* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;           /* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
        fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
        {
          fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
          /* Give the individual parser a way to print the precise meaning
             of a token, for further debugging info.  */
#ifdef YYPRINT
          YYPRINT (stderr, yychar, yylval);
#endif
          fprintf (stderr, ")\n");
        }
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
               yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
        fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 5:
#line 283 "ppalddc.y"
{
	if(strlen(yyvsp[0].sval) > 14)
		yyerror("Identifier too long. It mast be less or equal than 14 character");
	iter = 0; DataRedef(yyvsp[0].sval, 2);
	have_key = 0;
	have_iter = 0;
	STRNSCPY(DataDefs[datacnt].Name, yyvsp[0].sval);
	DataDefs[datacnt].TypeId = 2;
	DataDefs[datacnt].HasParent = 0;
	DataDefs[datacnt].ParentId = datacnt+1;
;
    break;}
case 6:
#line 296 "ppalddc.y"
{
	if(strlen(yyvsp[0].sval) > 14)
		yyerror("Identifier too long. It mast be less or equal than 14 character");
	iter = 0;
	DataRedef(yyvsp[0].sval, 1);
	have_key = 0;
	have_iter = 0;
	STRNSCPY(DataDefs[datacnt].Name, yyvsp[0].sval);
	DataDefs[datacnt].TypeId = 1;
	DataDefs[datacnt].DeclareFlags = 0;
;
    break;}
case 7:
#line 309 "ppalddc.y"
{
	DataDefs[datacnt].HasParent = 0;
	DataDefs[datacnt].ParentId = datacnt+1;
	DataDefs[datacnt].ParentName[0] = 0;
;
    break;}
case 8:
#line 314 "ppalddc.y"
{
	DataDefs[datacnt].HasParent = 1;
	DataDefs[datacnt].ParentId = DataDefs[GetDataID(yyvsp[0].sval, 0)-1].ParentId;
	STRNSCPY(DataDefs[datacnt].ParentName, yyvsp[0].sval);
;
    break;}
case 10:
#line 321 "ppalddc.y"
{
;
    break;}
case 11:
#line 325 "ppalddc.y"
{
;
    break;}
case 12:
#line 327 "ppalddc.y"
{
	if(strcmp(yyvsp[0].sval, "Destroy") == 0)
		DataDefs[datacnt].DeclareFlags |= DATADECLF_DESTROY;
	else if(strcmp(yyvsp[0].sval, "DOSSTUB") == 0)
		DataDefs[datacnt].DeclareFlags |= DATADECLF_DOSSTUB;
	else {
		char msgbuf[256];
		sprintf(msgbuf, "Invalid decalre statement \"%s\"", yyvsp[0].sval);
	}
;
    break;}
case 13:
#line 339 "ppalddc.y"
{
	datacnt++;
;
    break;}
case 16:
#line 346 "ppalddc.y"
{
	if(DataDefs[datacnt].HasParent)
		yyerror("Could have only <id>=<expr>;");
;
    break;}
case 19:
#line 353 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_INT | 0x80, 4));
;
    break;}
case 20:
#line 356 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_FLOAT | 0x80, 8));
;
    break;}
case 21:
#line 361 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_INT, 4));
;
    break;}
case 22:
#line 364 "ppalddc.y"
{
	if(DataDefs[datacnt].TypeId == 2)
		yyerror("Could not place 'key' in SFilter");
	if(iter)
		yyerror("Could not place 'key' in iterator");
	if(DataDefs[datacnt].HasParent)
		yyerror("Could not place 'key' in derived struct");
	if(have_iter)
		yyerror("Could not place 'key' in struct with iteration");
	have_key = 1;
	VarDefs[varcnt].rel = -1;
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_INT, 4));
;
    break;}
case 23:
#line 377 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_INT, 4));
;
    break;}
case 24:
#line 380 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_FLOAT, 8));
;
    break;}
case 25:
#line 383 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, T_TSTR);
;
    break;}
case 26:
#line 386 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, T_TDEC);
;
    break;}
case 27:
#line 389 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, T_TMON);
;
    break;}
case 28:
#line 392 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_INT, 2));
;
    break;}
case 29:
#line 395 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_DATE, sizeof(LDATE)));
;
    break;}
case 30:
#line 398 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_TIME, sizeof(LTIME)));
;
    break;}
case 31:
#line 401 "ppalddc.y"
{
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_FLOAT, 4));
;
    break;}
case 32:
#line 404 "ppalddc.y"
{
	if(DataDefs[datacnt].TypeId == 2)
		yyerror("Could not place 'autoinc' in SFilter");
	if(!iter)
		yyerror("Could not place 'autoinc' out of iterator");
	SetupVarDef(yyvsp[0].sval, MKSTYPE(S_AUTOINC, 4));
;
    break;}
case 33:
#line 413 "ppalddc.y"
{
	if(VarDefs[varcnt].type == T_TDEC || VarDefs[varcnt].type == T_TSTR)
		yyerror("Must be indexed.");
	if(VarDefs[varcnt].type == T_TMON)
		VarDefs[varcnt].type = MKSTYPED(S_DEC, 8, 2);
;
    break;}
case 34:
#line 419 "ppalddc.y"
{
	if(VarDefs[varcnt].type == T_TDEC || VarDefs[varcnt].type == T_TMON)
		VarDefs[varcnt].type = MKSTYPED(S_DEC, yyvsp[-1].lval, 2);
	else if(VarDefs[varcnt].type == T_TSTR)
		VarDefs[varcnt].type = MKSTYPE(S_ZSTRING, yyvsp[-1].lval);
	else {
		printf("VarDefs[varcnt].type = %08lx\n", VarDefs[varcnt].type);
		yyerror("Could not be indexed.");
	}
;
    break;}
case 35:
#line 429 "ppalddc.y"
{
	if(VarDefs[varcnt].type != T_TDEC && VarDefs[varcnt].type != T_TMON)
		yyerror("Could not be indexed.");
	VarDefs[varcnt].type = MKSTYPED(S_DEC, yyvsp[-3].lval, yyvsp[-1].lval);
;
    break;}
case 36:
#line 436 "ppalddc.y"
{
	VarDefs[varcnt].alias[0] = 0;
;
    break;}
case 37:
#line 439 "ppalddc.y"
{
	strncpy(VarDefs[varcnt].alias, yyvsp[0].sval, 15);
	VarDefs[varcnt].alias[15] = 0;
;
    break;}
case 38:
#line 445 "ppalddc.y"
{
	VarDefs[varcnt].format = SetFormat(0, VarDefs[varcnt].type);
;
    break;}
case 39:
#line 448 "ppalddc.y"
{
	VarDefs[varcnt].format = SetFormat(yyvsp[0].sval, VarDefs[varcnt].type);
;
    break;}
case 40:
#line 453 "ppalddc.y"
{
	VarDefs[varcnt].dataID = datacnt;
	VarDefs[varcnt].iterID = iter ? cur_iter : 0;
	VarsRedef(VarDefs[varcnt].name, datacnt, VarDefs[varcnt].iterID);
	varcnt++;
;
    break;}
case 41:
#line 461 "ppalddc.y"
{
	VarDefs[varcnt].rel = GetDataID(yyvsp[0].sval, 1);
;
    break;}
case 42:
#line 464 "ppalddc.y"
{
	if(DataDefs[datacnt].TypeId == 2)
		yyerror("Could not place 'link' in SFilter");
	if(DataDefs[datacnt].HasParent)
		yyerror("Could have only <id>=<expr>;");
	varcnt++;
;
    break;}
case 43:
#line 473 "ppalddc.y"
{
	VarDefs[varcnt].dataID = datacnt;
	VarDefs[varcnt].iterID = iter ? cur_iter : 0;
	VarDefs[varcnt].type = MKSTYPE(S_INT, 4);
	STRNSCPY(VarDefs[varcnt].name, yyvsp[0].sval);
	VarsRedef(yyvsp[0].sval, datacnt, VarDefs[varcnt].iterID);
;
    break;}
case 45:
#line 484 "ppalddc.y"
{
	if(DataDefs[datacnt].TypeId == 2)
		yyerror("Could not place 'equality' in SFilter");
	VarDefs[varcnt].type = yyvsp[0].nType.ret_val;
;
    break;}
case 46:
#line 489 "ppalddc.y"
{
	VarDefs[varcnt].node_offset = node_offset;
	node_offset += VarDefs[varcnt].node_cnt * sizeof(NodeType) + ext_cnt;
	varcnt++;
;
    break;}
case 47:
#line 496 "ppalddc.y"
{
	VarDefs[varcnt].dataID = datacnt;
	VarDefs[varcnt].iterID = iter ? cur_iter : 0;
	STRNSCPY(VarDefs[varcnt].name, yyvsp[0].sval);
	ext_cnt = 0;
	VarsRedef(yyvsp[0].sval, datacnt, VarDefs[varcnt].iterID);
;
    break;}
case 48:
#line 505 "ppalddc.y"
{
	yyval.nType.type = OP_TERM;
	yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
	yyval.nType.dbl_val = atof(yyvsp[0].sval);
	yyval.nType.ext_val = 0;
	SaveNode(yyval.nType);
;
    break;}
case 49:
#line 512 "ppalddc.y"
{
	yyval.nType.type = OP_TERM;
	yyval.nType.ret_val = MKSTYPE(S_INT, 4);
	yyval.nType.lng_val = yyvsp[0].lval;
	yyval.nType.ext_val = 0;
	SaveNode(yyval.nType);
;
    break;}
case 50:
#line 519 "ppalddc.y"
{
	yyval.nType.type = OP_TERM;
	yyval.nType.ext_val = (strlen(yyvsp[0].sval) < MAX_STR_LEN) ? strlen(yyvsp[0].sval) : (MAX_STR_LEN-1);
	yyval.nType.ret_val = MKSTYPE(S_ZSTRING, ++yyval.nType.ext_val);
	SaveNode(yyval.nType);
	fwrite(yyvsp[0].sval, yyval.nType.ext_val, 1, nodefile);
	ext_cnt += yyval.nType.ext_val;
;
    break;}
case 51:
#line 527 "ppalddc.y"
{ yyval.nType = yyvsp[-1].nType; ;
    break;}
case 52:
#line 528 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType3(OP_IF_ELSE, yyvsp[-4].nType, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 53:
#line 529 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_IF, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 54:
#line 530 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType3(OP_IF_ELSE, yyvsp[-4].nType, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 55:
#line 531 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType1(OP_BIT_NOT, yyvsp[0].nType)); ;
    break;}
case 56:
#line 532 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType1(OP_UMINUS, yyvsp[0].nType)); ;
    break;}
case 57:
#line 533 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType1(OP_UPLUS, yyvsp[0].nType)); ;
    break;}
case 58:
#line 534 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType1(OP_LEN, yyvsp[0].nType)); ;
    break;}
case 59:
#line 536 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT) {
		yyval.nType.type = OP_SQRT_INT;
		yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else if(GETSTYPE(yyvsp[-1].nType.ret_val) == S_FLOAT) {
		yyval.nType.type = OP_SQRT_DBL;
		yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 60:
#line 554 "ppalddc.y"
{
	ary_type = GETSTYPE(yyvsp[-3].nType.ret_val);
	if(ary_type & 0x80 && (GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT || GETSTYPE(yyvsp[-1].nType.ret_val) == S_AUTOINC)) {
		switch(ary_type & 0x7f) {
			case S_INT:
				yyval.nType.ret_val = MKSTYPE(S_INT, 4);
				yyval.nType.type = OP_ARRAY_MEMBER_INT;
				break;
			case S_FLOAT:
				yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
				yyval.nType.type = OP_ARRAY_MEMBER_DBL;
				break;
			default:
				yyerror("Not correct type of parameter");
		}
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 2;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 61:
#line 576 "ppalddc.y"
{
	yyval.nType.type = OP_ROUND;
	yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
	yyval.nType.ext_val = 0;
	yyval.nType.fnk_val.VarCount = 2;
	yyval.nType.fnk_val.VarTypes[0] = yyvsp[-3].nType.ret_val;
	yyval.nType.fnk_val.VarTypes[1] = yyvsp[-1].nType.ret_val;
	if((GETSTYPE(yyvsp[-3].nType.ret_val) == S_DEC || GETSTYPE(yyvsp[-3].nType.ret_val) == S_FLOAT) && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType);
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 62:
#line 588 "ppalddc.y"
{
	yyval.nType.type = OP_TRUNC;
	yyval.nType.ret_val = MKSTYPE(S_FLOAT, 8);
	yyval.nType.ext_val = 0;
	yyval.nType.fnk_val.VarCount = 2;
	yyval.nType.fnk_val.VarTypes[0] = yyvsp[-3].nType.ret_val;
	yyval.nType.fnk_val.VarTypes[1] = yyvsp[-1].nType.ret_val;
	if((GETSTYPE(yyvsp[-3].nType.ret_val) == S_DEC || GETSTYPE(yyvsp[-3].nType.ret_val) == S_FLOAT) && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType);
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 63:
#line 600 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[0].nType.ret_val) == S_FLOAT)
		yyval.nType = yyvsp[0].nType;
	else
		args[0] = yyvsp[0].nType;
	yyval.nType = GetNodeType(OP_TO_DBL, args);
	SaveNode(yyval.nType);
;
    break;}
case 64:
#line 608 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[0].nType.ret_val) == S_INT)
		yyval.nType = yyvsp[0].nType;
	else
		args[0] = yyvsp[0].nType;
	yyval.nType = GetNodeType(OP_TO_INT, args);
	SaveNode(yyval.nType);
;
    break;}
case 65:
#line 616 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_FLOAT) {
		yyval.nType.type = OP_MONEY;
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, yyvsp[-1].lval+1);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 66:
#line 627 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-5].nType.ret_val) == S_FLOAT) {
		yyval.nType.type = OP_MONEY_FULL;
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, yyvsp[-3].lval+1);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 67:
#line 638 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_DATE) {
		yyval.nType.type = OP_DATE;
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, yyvsp[-1].lval+1);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Not correct type of parameter");
;
    break;}
case 68:
#line 649 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_DATE) {
		yyval.nType.type = OP_WORD_DATE;
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, yyvsp[-1].lval+1);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerr_invparam("Date2WStr(date, int)");
;
    break;}
case 69:
#line 660 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_FLOAT) {
		yyval.nType.type = OP_NUMBER;
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, yyvsp[-1].lval+1);
		yyval.nType.ext_val = 0;
		yyval.nType.fnk_val.VarCount = 1;
		SaveNode(yyval.nType);
	}
	else
		yyerr_invparam("Num2Str(number, int)");
;
    break;}
case 70:
#line 671 "ppalddc.y"
{
;
    break;}
case 71:
#line 673 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_ZSTRING && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType = GetNodeType2(OP_LEFT, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("left(string, int)");
;
    break;}
case 72:
#line 679 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_ZSTRING && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType = GetNodeType2(OP_RIGHT, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("right(string, int)");
;
    break;}
case 73:
#line 684 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-5].nType.ret_val) == S_ZSTRING && GETSTYPE(yyvsp[-3].nType.ret_val) == S_INT && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType = GetNodeType3(OP_MIDL, yyvsp[-5].nType, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("midl(string, int, int)");
;
    break;}
case 74:
#line 690 "ppalddc.y"
{
	if((GETSTYPE(yyvsp[-3].nType.ret_val) == S_ZSTRING) && (GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT))
		SaveNode(yyval.nType = GetNodeType2(OP_WRAP, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("wrap(string, int)");
;
    break;}
case 75:
#line 696 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_ZSTRING)
		yyval.nType = yyvsp[-3].nType;
	else {
		yyval.nType.type = OP_TERM;
		yyval.nType.ret_val = MKSTYPE(S_INT, 4);
		fspec = SetFormat(yyvsp[-1].sval, yyvsp[-3].nType.ret_val);
		if((GETSTYPE(yyvsp[-3].nType.ret_val) == S_FLOAT) || (GETSTYPE(yyvsp[-3].nType.ret_val) == S_DEC))
			yyval.nType.lng_val = MKSFMTD(fspec.len, fspec.prec, fspec.flags);
		else
			yyval.nType.lng_val = MKSFMT(fspec.len, fspec.flags);
		SaveNode(yyval.nType);
		args[0] = yyvsp[-3].nType;
		yyval.nType = GetNodeType(OP_TO_STR, args);
		yyval.nType.ret_val = MKSTYPE(S_ZSTRING, fspec.len ? fspec.len+1 : 32);
		SaveNode(yyval.nType);
	}
;
    break;}
case 76:
#line 714 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_DATE && GETSTYPE(yyvsp[-1].nType.ret_val) == S_DATE)
		SaveNode(yyval.nType = GetNodeType2(OP_FORMATPERIOD, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("formatperiod(date, date)");
;
    break;}
case 77:
#line 720 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-3].nType.ret_val) == S_ZSTRING && GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType = GetNodeType2(OP_PRINTABLEBARCODE, yyvsp[-3].nType, yyvsp[-1].nType));
	else
		yyerr_invparam("PrintableBarcode(string, int)");
;
    break;}
case 78:
#line 726 "ppalddc.y"
{
	if(GETSTYPE(yyvsp[-1].nType.ret_val) == S_FLOAT || GETSTYPE(yyvsp[-1].nType.ret_val) == S_DEC)
		SaveNode(yyval.nType = GetNodeType1(OP_ABS_DBL, yyvsp[-1].nType));
	else if(GETSTYPE(yyvsp[-1].nType.ret_val) == S_INT)
		SaveNode(yyval.nType = GetNodeType1(OP_ABS_INT, yyvsp[-1].nType));
	else
		yyerr_invparam("abs(number)");
;
    break;}
case 79:
#line 734 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_EQUL, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 80:
#line 735 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_NOTEQUL, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 81:
#line 736 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_LESS, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 82:
#line 737 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_LESS_EQ, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 83:
#line 738 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_GREAT, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 84:
#line 739 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_GREAT_EQ, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 85:
#line 740 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_LOG_OR, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 86:
#line 741 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_LOG_AND, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 87:
#line 742 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_BIT_OR, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 88:
#line 743 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_BIT_XOR, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 89:
#line 744 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_BIT_AND, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 90:
#line 745 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_PLUS, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 91:
#line 746 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_MINUS, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 92:
#line 747 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_MULT, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 93:
#line 748 "ppalddc.y"
{ SaveNode(yyval.nType = GetNodeType2(OP_DIV, yyvsp[-2].nType, yyvsp[0].nType)); ;
    break;}
case 94:
#line 749 "ppalddc.y"
{ yyval.nType = yyvsp[0].nType; ;
    break;}
case 95:
#line 752 "ppalddc.y"
{
	if((link_var = GetVarID(yyvsp[0].sval, datacnt, iter ? cur_iter : 0)) >= 0) {
		yyval.nType.type = OP_IDENT;
		yyval.nType.lnk_val.DataId = datacnt;
		yyval.nType.lnk_val.IterId = VarDefs[link_var].iterID ? cur_iter : 0;
		yyval.nType.lnk_val.VarId = link_var;
		yyval.nType.ret_val = VarDefs[link_var].type;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Bad identifier");
;
    break;}
case 96:
#line 764 "ppalddc.y"
{
	yyval.nType.type = OP_LINK;
	yyval.nType.ret_val = yyvsp[0].nType.ret_val;
	yyval.nType.fnk_val.VarCount = 2;
	yyval.nType.fnk_val.VarTypes[0] = yyvsp[-2].nType.ret_val;
	yyval.nType.fnk_val.VarTypes[1] = yyvsp[0].nType.ret_val;
	SaveNode(yyval.nType);
;
    break;}
case 97:
#line 774 "ppalddc.y"
{
	if(VarDefs[link_var].rel <= 0)
		yyerror("Not 'link' variable");
	if((link_var = GetVarID(yyvsp[0].sval, VarDefs[link_var].rel-1, 0)) >= 0) {
		yyval.nType.type = OP_IDENT;
		yyval.nType.lnk_val.DataId = VarDefs[link_var].dataID;
		yyval.nType.lnk_val.IterId = VarDefs[link_var].iterID;
		yyval.nType.lnk_val.VarId = link_var;
		yyval.nType.ret_val = VarDefs[link_var].type;
		SaveNode(yyval.nType);
	}
	else
		yyerror("Bad identifier");
;
    break;}
case 99:
#line 792 "ppalddc.y"
{
;
    break;}
case 100:
#line 794 "ppalddc.y"
{
	if(!iter)
		yyerror("Order must be inside an iteration");
	if(IsOrder)
		yyerror("Could be just one Order inside an iteration");
	if(DataDefs[datacnt].HasParent)
		yyerror("Could not be inside child struct");
	IsOrder = 1;
;
    break;}
case 101:
#line 803 "ppalddc.y"
{
	IsOrder = 0;
;
    break;}
case 104:
#line 810 "ppalddc.y"
{
	OrderDefs[ordercnt].iterID = itercnt;
	OrderDefs[ordercnt].dataID = datacnt;
	STRNSCPY(OrderDefs[ordercnt].name, yyvsp[0].sval);
	ordercnt++;
;
    break;}
case 105:
#line 818 "ppalddc.y"
{
	if(DataDefs[datacnt].TypeId == 2)
		yyerror("Could not place 'iteration' in SFilter");
	if(iter)
		yyerror("Embedded iteration");
	if(!strcmp("Head", yyvsp[0].sval))
		yyerror("Reserved symbol");
	if(!strcmp("default", yyvsp[0].sval))
		yyerror("Reserved symbol");
	if(have_key)
		yyerror("Could not place iteration in struct with 'key'");
	have_iter = 1;
	cur_iter = itercnt;
	if(DataDefs[datacnt].HasParent)
		cur_iter = GetIterID(datacnt, yyvsp[0].sval);
	else
		STRNSCPY(IterDefs[itercnt].name, yyvsp[0].sval);
	iter = 1;
;
    break;}
case 106:
#line 837 "ppalddc.y"
{
	if(iter)
		yyerror("Embedded iterations");
	if(have_key)
		yyerror("Could not place iteration in struct with 'key'");
	have_iter = 1;
	cur_iter = itercnt;
	if(DataDefs[datacnt].HasParent)
		cur_iter = GetIterID(datacnt, "default");
	else
		STRNSCPY(IterDefs[itercnt].name, "default");
	iter = 1;
;
    break;}
case 107:
#line 852 "ppalddc.y"
{
	IterDefs[cur_iter].dataID = datacnt;
	IterDefs[cur_iter].type = T_ITER;
	if(!DataDefs[datacnt].HasParent)
		itercnt++;
	iter = 0;
;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/mingw32/share/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
        fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
        {
          int size = 0;
          char *msg;
          int x, count;

          count = 0;
          /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
          for (x = (yyn < 0 ? -yyn : 0);
               x < (sizeof(yytname) / sizeof(char *)); x++)
            if (yycheck[x + yyn] == x)
              size += strlen(yytname[x]) + 15, count++;
          msg = (char *) malloc(size + 15);
          if (msg != 0)
            {
              strcpy(msg, "parse error");

              if (count < 5)
                {
                  count = 0;
                  for (x = (yyn < 0 ? -yyn : 0);
                       x < (sizeof(yytname) / sizeof(char *)); x++)
                    if (yycheck[x + yyn] == x)
                      {
                        strcat(msg, count == 0 ? ", expecting `" : " or `");
                        strcat(msg, yytname[x]);
                        strcat(msg, "'");
                        count++;
                      }
                }
              yyerror(msg);
              free(msg);
            }
          else
            yyerror ("parse error; also virtual memory exceeded");
        }
      else
#endif /* YYERROR_VERBOSE */
        #ifdef MSG_ENUM
            yyerror(msgYaccParse);
        #else
            yyerror("parse error");
        #endif
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
        YYABORT;

#if YYDEBUG != 0
      if (yydebug)
        fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;              /* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
        fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
        goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 860 "ppalddc.y"


void SaveNode(NodeType nt)
{
	VarDefs[varcnt].node_cnt++;
	fwrite(&nt, sizeof(nt), 1, nodefile);
}

static void SetupVarDef(const char * pName, long typ)
{
	VarDefs[varcnt].type = typ;
	STRNSCPY(VarDefs[varcnt].name, pName);
}

int main(int argc, char *argv[])
{
	FILE *fs;
	long i, j, k, l, m, len, fld_offset, ext_fld_offset, n;
	PpalddHead Head = { {'P','P','A','L','D','D',' ',0}, 0, 0, 0, 0, 0, 0};
	PpalddDataHead DataHead;
	PpalddListHead IterHead;
	PpalddField    Field;
	PpalddOrder    Order;
	PpalddIdxData  S_id;
	NodeType       Node;

	STRNSCPY(PREFIX, "PPALDD");
	/*
	yydebug = 1;
	*/
	if(argc < 2)
		yyerror("Too few params...\nMust be: ppalddc source[.ald] [h-file] [cpp-file] [bin-file].\n");
	replaceExt(STRNSCPY(in_file_name, argv[1]), ".ALD", 0);
	if(argc > 2) {
		replaceExt(STRNSCPY(h_file_name, argv[2]), ".H", 0);
		replaceExt(STRNSCPY(hflt_file_name, argv[2]), ".H_", 0);
	}
	else {
		replaceExt(STRNSCPY(h_file_name, in_file_name), ".H", 1);
		replaceExt(STRNSCPY(hflt_file_name, in_file_name), ".H_", 1);
	}
	if(argc > 3) {
		replaceExt(STRNSCPY(cpp_file_name, argv[3]), ".CPP", 0);
		replaceExt(STRNSCPY(cppflt_file_name, argv[3]), ".CP_", 0);
	}
	else {
		replaceExt(STRNSCPY(cpp_file_name, in_file_name), ".CPP", 1);
		replaceExt(STRNSCPY(cppflt_file_name, in_file_name), ".CP_", 1);
	}
	if(argc > 4)
		replaceExt(STRNSCPY(bin_file_name, argv[4]), ".BIN", 0);
	else
		replaceExt(STRNSCPY(bin_file_name, in_file_name), ".BIN", 1);
	nodefile = fopen("node.tmp", "w+b");
	if(!(fs = fopen(h_file_name, "w+"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", h_file_name);
		yyerror(tmpbuff);
	}
	fclose(fs);
	if(!(fs = fopen(hflt_file_name, "w+"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", hflt_file_name);
		yyerror(tmpbuff);
	}
	fclose(fs);
	if(!(fs = fopen(bin_file_name, "w+b"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", bin_file_name);
		yyerror(tmpbuff);
	}
	fclose(fs);
	if(!(fs = fopen(cpp_file_name, "w+"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", cpp_file_name);
		yyerror(tmpbuff);
	}
	fclose(fs);
	if(!(fs = fopen(cppflt_file_name, "w+"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", cppflt_file_name);
		yyerror(tmpbuff);
	}
	fclose(fs);
	yyin = fopen(in_file_name, "r");
	if(!(yyin = fopen(in_file_name, "r"))) {
		sprintf(tmpbuff, "Could not open file \"%s\".\n", in_file_name);
		yyerror(tmpbuff);
	}
	Head.Len = sizeof(Head);
	VarDefs = 0;
	DataDefs = 0;
	IterDefs = 0;
	OrderDefs = 0;
	VarDefs   = (VARDEFS *)calloc(BUFF_SIZE, sizeof(VARDEFS));
	DataDefs  = (DATADEFS *)calloc(BUFF_SIZE, sizeof(DATADEFS));
	IterDefs  = (ITERDEFS *)calloc(BUFF_SIZE, sizeof(ITERDEFS));
	OrderDefs = (ORDERDEFS *)calloc(BUFF_SIZE, sizeof(ORDERDEFS));
	if(VarDefs && DataDefs && IterDefs && OrderDefs) {
		IterDefs[0].dataID = -1;
		IterDefs[0].type = 0;
		STRNSCPY(IterDefs[0].name, "Head");

		yyparse();

		/*
			 *.h 
		*/
		fs = fopen(h_file_name, "w+");
		fprintf(fs,"\n//\n// This file was compiled from %s by %sC.EXE\n//\n\n", in_file_name, PREFIX);
		WriteHFile(fs, 1);
		fclose(fs);
		/*
			 *.h_ 
		*/
		fs = fopen(hflt_file_name, "w+");
		fprintf(fs,"\n//\n// This file was compiled from %s by %sC.EXE\n//\n\n", in_file_name, PREFIX);
		WriteHFile(fs, 2);
		fclose(fs);
		/*
			 *.cpp 
		*/
		fs = fopen(cpp_file_name, "w+");
		fprintf(fs,"\n//\n// This file was compiled from %s by %sC.EXE\n//\n\n", in_file_name, PREFIX);

		fprintf(fs, "#ifdef __BORLANDC__\n");
		fprintf(fs, "\t#pragma hdrfile \"PPDEF.SYM\"\n");
		fprintf(fs, "#endif\n");
		fprintf(fs, "#include <pp.h>\n");
		fprintf(fs, "\n");
		fprintf(fs, "#include <ppdlgs.h>\n");
		fprintf(fs, "#pragma hdrstop\n\n");
		fprintf(fs, "#include <%s>\n", h_file_name);
		WriteCppFile(fs, 1);
		fclose(fs);
		/*
			 *.cp_ 
		*/
		fs = fopen(cppflt_file_name, "w+");
		fprintf(fs,"\n//\n// This file was compiled from %s by %sC.EXE\n//\n\n", in_file_name, PREFIX);

		fprintf(fs, "#ifdef __BORLANDC__\n");
		fprintf(fs, "\t#pragma hdrfile \"PPDEF.SYM\"\n");
		fprintf(fs, "#endif\n");
		fprintf(fs, "#include <pp.h>\n");
		fprintf(fs, "\n");
		fprintf(fs, "#include <ppdlgs.h>\n");
		fprintf(fs, "#pragma hdrstop\n\n");
		fprintf(fs, "#include <%s>\n", hflt_file_name);
		WriteCppFile(fs, 2);
		fclose(fs);
		/*
			 BIN'
		*/
		fs = fopen(bin_file_name, "w+b");
		Head.DataCount = datacnt;
		Head.Len = sizeof(Head);
		Head.DataOffset = datacnt * sizeof(S_id) + sizeof(Head);
		/*
			Write Header
		*/
		fwrite(&Head, sizeof(Head), 1, fs);
		for(i = 0; i < datacnt; i++)
			fwrite(&S_id, sizeof(S_id), 1, fs);
		/*
			Circle about List of Lists
		*/
		for(i = 0, len = 0; i < datacnt; i++) {
			/*
				set offset of res
			*/
			fseek(fs, i * sizeof(S_id) + sizeof(Head), SEEK_SET);
			S_id.ID = i+1;
			S_id.Offset = len+Head.DataOffset;
			fwrite(&S_id, sizeof(S_id), 1, fs);
			fseek(fs, 0, SEEK_END);

			memset(&DataHead, 0, sizeof(DataHead));
			DataHead.ID       = i+1;
			DataHead.TypeID   = DataDefs[i].TypeId;
			DataHead.ParentID = DataDefs[i].ParentId;
			STRNSCPY(DataHead.Name, DataDefs[i].Name);
			STRNSCPY(DataHead.ParentName, DataDefs[i].ParentName);
			/*
				Counting Lists in List of Lists
			*/
			for(j = 0, k = 0; j < itercnt; j++)
				if(IterDefs[j].dataID == i)
					k++;
			DataHead.ListCnt = k+1;
			fwrite(&DataHead, sizeof(DataHead), 1, fs);
			len += sizeof(DataHead);
			/*
				Circle about List of Fields
			*/
			for(j = 0, k = 1; j < itercnt; j++)
				if(IterDefs[j].dataID == i || !j) {
					memset(&IterHead, 0, sizeof(IterHead));
					IterDefs[j].ID = IterHead.ID = k;
					STRNSCPY(IterHead.Name, IterDefs[j].name);
					IterHead.Type = IterDefs[j].type;
					/*
						Counting Fields and Order in List of Fields
					*/
					for(l = 0, m = 0; l < ordercnt; l++)
						if(OrderDefs[l].dataID == i && OrderDefs[l].iterID == j)
							m++;
					IterHead.OrderCnt = m;
					for(l = 0, m = 0; l < varcnt; l++)
						if(VarDefs[l].dataID == i && VarDefs[l].iterID == j)
							m++;
					IterHead.FieldCnt = m;
					fwrite((void*) &IterHead, sizeof(IterHead), 1, fs);
					len += sizeof(IterHead);
					/*
						Circle about Order
					*/
					for(l = 0, m = 1; l < ordercnt; l++)
						if(OrderDefs[l].dataID == i && OrderDefs[l].iterID == j) {
							Order.ID = m++;
							STRNSCPY(Order.Name, OrderDefs[l].name);
							fwrite(&Order, sizeof(Order), 1, fs);
							len += sizeof(Order);
						}
					/*
						Circle about Fields
					*/
					for(ext_fld_offset = fld_offset = l = 0, m = 1; l < varcnt; l++)
						if(VarDefs[l].dataID == i && VarDefs[l].iterID == j) {
							memset(&Field, 0, sizeof(Field));
							VarDefs[l].ID = Field.ID = m;
							STRNSCPY(Field.Name, VarDefs[l].name);
							STRNSCPY(Field.Alias, VarDefs[l].alias);
							Field.Type = VarDefs[l].type;
							Field.Rel  = VarDefs[l].rel;
							Field.NodeCount = VarDefs[l].node_cnt;
							if(Field.NodeCount) {
								Field.Offset = ext_fld_offset;
								ext_fld_offset += (GETSTYPE(Field.Type) & 0x80) ?
								 sizeof(void*) : ((GETSTYPE(Field.Type) == S_DEC) ?
								 GETSSIZED(Field.Type) : GETSSIZE(Field.Type));
							}
							else {
								Field.Offset = fld_offset;
								fld_offset += (GETSTYPE(Field.Type) == S_DEC) ?
									GETSSIZED(Field.Type) : GETSSIZE(Field.Type);
							}
							Field.Format = VarDefs[l].format;
							m++;
							fwrite(&Field, sizeof(Field), 1, fs);
							len += sizeof(Field);
							fseek(nodefile, VarDefs[l].node_offset, SEEK_SET);
							for(n = 0; n < Field.NodeCount; n++) {
								memset(&Node, 0, sizeof(NodeType));
								fread(&Node, sizeof(Node), 1, nodefile);
								if(Node.type == OP_IDENT) {
									Node.lnk_val.DataId++;
									Node.lnk_val.IterId = IterDefs[Node.lnk_val.IterId].ID;
									Node.lnk_val.VarId = VarDefs[Node.lnk_val.VarId].ID;
								}
								fwrite(&Node, sizeof(Node), 1, fs);
								len += sizeof(NodeType);
								if(Node.ext_val) {
									fread(tmpbuff, Node.ext_val, 1, nodefile);
									fwrite(tmpbuff, Node.ext_val, 1, fs);
									len += Node.ext_val;
								}
							}
						}
						k++;
				}
		}
		fclose(fs);
		fclose(nodefile);
	}
	else
		printf("Fail alloc for read buffs");
	free(VarDefs);
	free(DataDefs);
	free(IterDefs);
	free(OrderDefs);
	return 0;
}
/*
	 ID   Link'
*/
long GetDataID(char * name, long fl)
{
	int i, j;
	char * cc = strchr(name, ' ');
	if(cc)
		*cc = 0;
	for(i = 0; i < datacnt; i++)
		if(strcmp(DataDefs[i].Name, name) == 0)
			if(fl) {
				for(j = 0; j < varcnt; j++)
					if(VarDefs[j].dataID == i && VarDefs[j].iterID == 0 && VarDefs[j].rel == -1)
						return i+1;
				yyerror("This SData have no 'key'");
				return 0;
			}
			else {
				FillData(i);
				return i+1;
			}
	yyerror("No linked SData");
	return 0;
}

void FillData(long dd)
{
	long i, j, k, l, m, oldcnt, ext_old = 0;
	NodeType Node;

	oldcnt = varcnt;

	for(k = 0, l = varcnt; k < varcnt; k++) {
		if((VarDefs[k].dataID == dd) && (VarDefs[k].iterID == 0)) {
			memcpy(VarDefs+l, VarDefs+k, sizeof(VARDEFS));
			VarDefs[l].dataID = datacnt;
			VarDefs[l].iterID = 0;
			l++;
		}
	}
	varcnt = l;
	for(i = 0, j = itercnt; i < itercnt; i++) {
		if(IterDefs[i].dataID == dd) {
			memcpy(IterDefs+j, IterDefs+i, sizeof(ITERDEFS));
			IterDefs[j].dataID = datacnt;
			for(k = 0, l = varcnt; k < varcnt; k++) {
				if((VarDefs[k].dataID == dd) && ((VarDefs[k].iterID == i) ||
					(VarDefs[k].iterID == -1))) {
					memcpy(VarDefs+l, VarDefs+k, sizeof(VARDEFS));
					VarDefs[l].dataID = datacnt;
					VarDefs[l].iterID = j;
					l++;
				}
			}
			varcnt = l;
			for(k = 0, l = ordercnt; k < ordercnt; k++) {
				if((OrderDefs[k].dataID == dd) && (OrderDefs[k].iterID == i)) {
					memcpy(OrderDefs+l, OrderDefs+k, sizeof(ORDERDEFS));
					OrderDefs[l].dataID = datacnt;
					OrderDefs[l].iterID = j;
					l++;
				}
			}
			ordercnt = l;
			j++;
		}
	}
	itercnt = j;
	for(l = oldcnt; l < varcnt; l++) {
		if(VarDefs[l].node_cnt) {
			for(m = 0, ext_old = 0; m < VarDefs[l].node_cnt; m++, ext_old += sizeof(Node)) {
				memset(&Node, 0, sizeof(NodeType));
				fseek(nodefile, ext_old + VarDefs[l].node_offset, SEEK_SET);
				fread(&Node, sizeof(Node), 1, nodefile);
				if(Node.type == OP_IDENT) {
					if(Node.lnk_val.DataId == dd) {
						Node.lnk_val.IterId = Node.lnk_val.IterId ? VarDefs[l].iterID : 0;
						Node.lnk_val.DataId = datacnt;
						Node.lnk_val.VarId = GetVarID(VarDefs[Node.lnk_val.VarId].name, datacnt, Node.lnk_val.IterId);
					}
				}
				if(Node.ext_val) {
					fread(tmpbuff, Node.ext_val, 1, nodefile);
					ext_old += Node.ext_val;
				}
				fseek(nodefile, 0, SEEK_END);
				fwrite(&Node, sizeof(Node), 1, nodefile);
				if(Node.ext_val)
					fwrite(tmpbuff, Node.ext_val, 1, nodefile);
			}
			VarDefs[l].node_offset = node_offset;
			node_offset += ext_old;
		}
	}
}

long GetIterID(long dt, char * name)
{
	int i;
	char * cc;
	if(cc = strchr(name, 32))
		*cc = 0;
	for(i = 1; i < itercnt; i++)
		if(IterDefs[i].dataID == dt)
			if(!strcmp(IterDefs[i].name, name))
				return i;
	yyerror("Could not add iteration in this SData");
	return 0;
}
/*
	  
*/
void DataRedef(char* str, long id)
{
	for(int i = 0; i < datacnt; i++)
		if(DataDefs[i].TypeId == id && !strcmp(DataDefs[i].Name, str))
			yyerror("Data redefinition");
}

void IterRedef(char* str, long dd)
{
	for(int i = 0; i < itercnt; i++)
		if(IterDefs[i].dataID == dd && !strcmp(IterDefs[i].name, str))
			yyerror("Iterator redefinition");
}

void VarsRedef(char* str, long dd, long ii)
{
	for(int i = 0; i < varcnt; i++)
		if(!strcmp(VarDefs[i].name, str) && VarDefs[i].dataID == dd && VarDefs[i].iterID == ii)
			yyerror("Variable redefinition");
}

int GetVarID(char* str, long dd, long ii)
{
	for(int i = 0; i < varcnt; i++)
		if(!strcmp(VarDefs[i].name, str) && VarDefs[i].dataID == dd &&
			(VarDefs[i].iterID == ii || VarDefs[i].iterID == 0))
			return i;
	return -1;
}

void WriteClassImplementation(FILE * fs, long classIdx, char * pClassName, long type)
{
	long j, k;
	if(DataDefs[classIdx].TypeId == 1 && type == 1) {
		fprintf(fs, "//\n// Implementation of %s_%s\n//\n", PREFIX, pClassName);
		/*
			constructor
		*/
		fprintf(fs, "%s_%s::%s_%s(long resId, PPALDD ** ppA) :\n", PREFIX, pClassName, PREFIX, pClassName);
		fprintf(fs, "\t%s(0, resId, ppA)\n{\n", PREFIX);
		fprintf(fs, "\tif(Valid) {\n");
		for(j = 0, k = 0; j < itercnt; j++)
			if((IterDefs[j].dataID == classIdx) || j == 0) {
				if(IterDefs[j].type == T_ITER)
					fprintf(fs, "\t\tAssignIterData(%d, &IT_%s_data, sizeof(IT_%s_data));\n", k, IterDefs[j].name, IterDefs[j].name);
				else if(IterDefs[j].type == 0)
					fprintf(fs, "\t\tAssignHeadData(&Head_data, sizeof(Head_data));\n");
				k++;
			}
		fprintf(fs, "\t}\n");
		fprintf(fs, "}\n\n");
		/*
			destructor
		*/
		fprintf(fs, "%s_%s::~%s_%s()\n{\n", PREFIX, pClassName, PREFIX, pClassName);
		fprintf(fs, "\tDestroy();\n");
		fprintf(fs, "}\n\n");
		/*
			virtual funcs
		*/
		fprintf(fs, "int %s_%s::InitData(PPFilt * pFilt, long rsrv)\n{\n\treturn PPALDD::InitData(pFilt, rsrv);\n}\n\n", PREFIX, pClassName);
		if(k > 1) {
			fprintf(fs, "int %s_%s::InitIteration(PPIterID iterId, int sortId, long rsrv)\n{\n", PREFIX, pClassName);
			fprintf(fs, "\tif(iterId == DEFAULT_ITER)\n");
			fprintf(fs, "\t\titerId = GetIterID();\n");
			fprintf(fs, "\treturn -1;\n}\n\n");
			fprintf(fs, "int %s_%s::NextIteration(PPIterID iterId, long rsrv)\n{\n", PREFIX, pClassName);
			fprintf(fs, "\tif(iterId == DEFAULT_ITER)\n");
			fprintf(fs, "\t\titerId = GetIterID();\n");
			fprintf(fs, "\treturn DlRtm::NextIteration(iterId, rsrv);\n}\n\n");
		}
		if(DataDefs[classIdx].DeclareFlags & DATADECLF_DESTROY)
			fprintf(fs, "int %s_%s::Destroy()\n{\n\treturn -1;\n}\n", PREFIX, pClassName);
	}
	else if(DataDefs[classIdx].TypeId == 2 && type == 2) {
		fprintf(fs, "//\n// Implementation of %s\n//\n", pClassName);
		/*
			constructor
		*/
		fprintf(fs, "%s::%s() {\n", pClassName, pClassName);
		fprintf(fs, "\tInitFilt();\n");
		fprintf(fs, "\tLoad();\n");
		fprintf(fs, "}\n\n");
		/*
			destructor
		*/
		fprintf(fs, "%s::~%s()\n{\n}\n\n", pClassName, pClassName);
		/*
			ather funcs
		*/
		fprintf(fs, "int %s::InitFilt(char * name)\n{\n\tpHead = &Head_data;\n", pClassName);
		fprintf(fs, "\tmemset(pHead, 0, sizeof(Head_data));\n");
		fprintf(fs, "\t_InitFilt(\"%s\", Name));\n}\n\n", pClassName);

		fprintf(fs, "int %s::Load(char * name)\n{\n", pClassName);
		fprintf(fs, "\tint ok = _Load(name);\n");
		fprintf(fs, "\t\\\\Here's the right place for your code.\n");
		fprintf(fs, "\treturn ok;\n}\n\n");

		fprintf(fs, "int %s::Save(char * name)\n{\n", pClassName);
		fprintf(fs, "\tint ok = 1;\n");
		fprintf(fs, "\t\\\\Here's' the right place for your code.\n");
		fprintf(fs, "\t\\\\Never forget that _Save return value.\n");
		fprintf(fs, "\t_Save();\n");
		fprintf(fs, "\treturn ok;\n}\n\n");
	}
}

void WriteCppFile(FILE * fs, long type)
{
	long i, j, k;
	FILE * gf = 0;
	for(i = 0; i < datacnt; i++)
		if(!DataDefs[i].HasParent)
			WriteClassImplementation(fs, i, DataDefs[i].Name, type);
	/*
		static CreateInstance(resFile, resID)
	*/
	gf = fopen("ldstat.cpp", "w+");
	fprintf(gf,"//\n// This file was compiled from %s by %sC.EXE\n", in_file_name, PREFIX);
	fprintf(gf,"// !!! DON'T MODIFY IT !!!\n//\n");
	fprintf(gf, "#ifdef __BORLANDC__\n");
	fprintf(gf, "#\tpragma hdrfile \"PPDEF.SYM\"\n");
	fprintf(gf, "#endif\n");
	fprintf(gf, "#include <pp.h>\n");
	fprintf(gf, "\n");
	fprintf(gf, "#include <ppdlgs.h>\n");
	fprintf(gf, "#pragma hdrstop\n");
	fprintf(gf, "#include <%s>\n\n", h_file_name);
	fprintf(gf, "%s * %s::CreateInstance(const char * /*pResFile*/, long parentID, long resID, PPALDD ** ppa)\n{\n", PREFIX, PREFIX);
	fprintf(gf, "\tPPALDD * p_rval = 0;\n");
	fprintf(gf, "\tif(!resID)\n\t\tresID = parentID;\n\n");
	fprintf(gf, "\tswitch(parentID) {\n");
	for(i = 0; i < datacnt; i++)
		if(!DataDefs[i].HasParent && DataDefs[i].TypeId == 1) {
			if(DataDefs[i].DeclareFlags & DATADECLF_DOSSTUB)
				fprintf(gf, "#ifdef __WIN32__\n");
			fprintf(gf, "\t\tcase %ld: ", i+1);
			fprintf(gf, "p_rval = new %s_%s(resID, ppa); break;\n", PREFIX, DataDefs[DataDefs[i].ParentId-1].Name);
			if(DataDefs[i].DeclareFlags & DATADECLF_DOSSTUB)
				fprintf(gf, "#endif\n");
		}
	fprintf(gf, "\t}\n");
	fprintf(gf, "\tif(p_rval && !p_rval->IsValid()) {\n");
	fprintf(gf, "\t\tdelete p_rval;\n");
	fprintf(gf, "\t\tp_rval = 0;\n");
	fprintf(gf, "\t}\n");
	fprintf(gf, "\treturn p_rval;\n}\n");
	fclose(gf);
}

void WriteHFile(FILE * fs, long type)
{
	long i, j;
	for(i = 0; i < datacnt; i++)
		if(DataDefs[i].TypeId == 1 && type == 1) {
			if(!DataDefs[i].HasParent) {
				if(DataDefs[i].DeclareFlags & DATADECLF_DOSSTUB) {
					fprintf(fs, "#ifdef __WIN32__\n");
				}
				for(j = 1; j < itercnt; j++)
					if(IterDefs[j].dataID == i)
						break;
				fprintf(fs, "class %s_%s : public %s {\npublic:\n", PREFIX, DataDefs[i].Name, PREFIX);
				fprintf(fs, "\t%s_%s(long resId = %ld, PPALDD ** ppA = 0);\n", PREFIX, DataDefs[i].Name, i+1);
				fprintf(fs, "\t~%s_%s();\n", PREFIX, DataDefs[i].Name);
				fprintf(fs, "\tvirtual int InitData(PPFilt *, long rsrv = 0);\n");
				if(j != itercnt) {
					fprintf(fs, "\tvirtual int InitIteration(PPIterID, int sortId, long rsrv = 0);\n");
					fprintf(fs, "\tvirtual int NextIteration(PPIterID, long rsrv = 0);\n");
				}
				if(DataDefs[i].DeclareFlags & DATADECLF_DESTROY)
					fprintf(fs, "\tvirtual int Destroy();\n");
				WriteFields(fs, i);
				fprintf(fs, "};\n\n");
				if(DataDefs[i].DeclareFlags & DATADECLF_DOSSTUB)
					fprintf(fs, "#endif // __WIN32__\n");
			}
		}
		else if(DataDefs[i].TypeId == 2 && type == 2) {
			fprintf(fs, "class %s : public %s {\npublic:\n", DataDefs[i].Name, PPFILTER);
			fprintf(fs, "\t%s();\n", DataDefs[i].Name);
			fprintf(fs, "\t~%s();\n", DataDefs[i].Name);
			fprintf(fs, "\tint Load(char * Name = 0);\n");
			fprintf(fs, "\tint Save(char * Name = 0);\n");
			fprintf(fs, "\tint InitFilt(char * Name = 0);\n");
			WriteFields(fs, i);
			fprintf(fs, "};\n\n");
		}
}

void WriteFields(FILE * fs, long dID)
{
	long i, j, k;
	fprintf(fs, "\n\tstruct Head {\n");
	WriteIterFields(fs, dID, 0);
	fprintf(fs, "\t} Head_data;\n");

	for(i = 1; i < itercnt; i++) {
		if(IterDefs[i].dataID == dID) {
			fprintf(fs, "\tstruct IT_%s {\n", IterDefs[i].name);
			for(j = 0; j < ordercnt; j++)
				if(OrderDefs[j].iterID == i)
					break;
			if(j < ordercnt) {
				fprintf(fs, "\t\tenum {\n");
				for(j = k = 0; j < ordercnt; j++)
					if(OrderDefs[j].iterID == i) {
						if(!k)
							fprintf(fs, "\t\t\tOrd%s = 1,\n", OrderDefs[j].name);
						else
							fprintf(fs, "\t\t\tOrd%s,\n", OrderDefs[j].name);
						OrderDefs[j].ID = ++k;
					}
				fprintf(fs, "\t\t};\n");
			}
			WriteIterFields(fs, dID, i);
			fprintf(fs, "\t} IT_%s_data;\n", IterDefs[i].name);
		}
	}
}

void WriteIterFields(FILE * fs, long dID, long iID)
{
	long i;
	for(i = 0; i < varcnt; i++) {
		VARDEFS j = VarDefs[i];
		if((!j.node_cnt) && (j.dataID == dID) && (j.iterID == iID)) {
			switch(GETARYSTYPE(j.type)) {
				case S_DEC:
					fprintf(fs, "\t\tchar %s[%d];\n", j.name, GETSSIZED(j.type));
					break;
				case S_ZSTRING:
					fprintf(fs, "\t\tchar %s[%d];\n", j.name, GETSSIZE(j.type));
					break;
				case S_AUTOINC:
				case S_INT:
					fprintf(fs, "\t\t");
					if(GETISARY(j.type))
						fprintf(fs, "TSArray <");
					if(GETSSIZE(j.type) == 2)
						fprintf(fs, "int16");
					else
						fprintf(fs, "int32");
					if(GETISARY(j.type))
						fprintf(fs, "> *");
					fprintf(fs, " %s;\n", j.name);
					break;
				case S_FLOAT:
					fprintf(fs, "\t\t");
					if(GETISARY(j.type))
						fprintf(fs, "TSArray<");
					if(GETSSIZE(j.type) == 4)
						fprintf(fs, "float");
					else
						fprintf(fs, "double");
					if(GETISARY(j.type))
						fprintf(fs, "> *");
					fprintf(fs, " %s;\n", j.name);
					break;
				case S_TIME:
					fprintf(fs, "\t\tLTIME %s;\n", j.name);
					break;
				case S_DATE:
					fprintf(fs, "\t\tLDATE %s;\n", j.name);
					break;
				case S_DATETIME:
					fprintf(fs, "\t\tLDATETIME %s;\n", j.name);
					break;
				case S_CHAR:
					fprintf(fs, "\t\tbyte %s;\n", j.name);
					break;
			}
		}
	}
}

static NodeType GetNodeType1(long opType, NodeType & arg1)
{
	NodeType arg_list[1];
	arg_list[0] = arg1;
	return GetNodeType(opType, arg_list);
}

static NodeType GetNodeType2(long opType, NodeType & arg1, NodeType & arg2)
{
	NodeType arg_list[2];
	arg_list[0] = arg1;
	arg_list[1] = arg2;
	return GetNodeType(opType, arg_list);
}

static NodeType GetNodeType3(long opType, NodeType & arg1, NodeType & arg2, NodeType & arg3)
{
	NodeType arg_list[3];
	arg_list[0] = arg1;
	arg_list[1] = arg2;
	arg_list[2] = arg3;
	return GetNodeType(opType, arg_list);
}

NodeType GetNodeType(long opType, NodeType * args)
{
#define ISARG(t1)        (arg_type[0]==(t1))
#define ISARG2(t1,t2)    (arg_type[0]==(t1)||arg_type[0]==(t2))
#define ISARG3(t1,t2,t3) (arg_type[0]==(t1)||arg_type[0]==(t2)||arg_type[0]==(t3))
#define ISARGPAIR(t1,t2) (arg_type[0]==(t1)&&arg_type[1]==(t2))
#define ISONEOFARGS2(t)  (arg_type[0]==(t)||arg_type[1]==(t))

	NodeType rval;
	int  i;
	long l1, l2;
	long arg_type[MAX_ARGS];
	rval.type = opType;
	rval.ret_val = 0;
	rval.ext_val = 0;
	for(i = 0; i < MAX_ARGS; i++) {
		arg_type[i] = GETSTYPE(args[i].ret_val);
		rval.fnk_val.VarTypes[i] = args[i].ret_val;
	}
	switch(opType) {
		case OP_PLUS:
		case OP_MINUS:
		case OP_MULT:
		case OP_DIV:
		case OP_TO_STR:
		case OP_IF:
		case OP_LEFT:
		case OP_RIGHT:
		case OP_WRAP:
		case OP_FORMATPERIOD:
		case OP_PRINTABLEBARCODE:
		case OP_EQUL:
		case OP_NOTEQUL:
		case OP_LESS:
		case OP_GREAT:
		case OP_LESS_EQ:
		case OP_GREAT_EQ:
		case OP_LOG_OR:
		case OP_LOG_AND:
		case OP_BIT_AND:
		case OP_BIT_OR:
		case OP_BIT_XOR: rval.fnk_val.VarCount = 2; break;
		case OP_UPLUS:
		case OP_UMINUS:
		case OP_TO_DBL:
		case OP_TO_INT:
		case OP_LEN:
		case OP_BIT_NOT: rval.fnk_val.VarCount = 1; break;
		case OP_IF_ELSE:
		case OP_MIDL:    rval.fnk_val.VarCount = 3; break;
		default:
			yyerror("Could not translate operation");
			break;
	}
	switch(opType) {
		case OP_BIT_NOT:
			if(ISARG(S_INT))
				rval.SetTR(opType, args[0].ret_val);
			break;
		case OP_UPLUS:
			if(ISARG3(S_INT, S_FLOAT, S_DEC))
				rval.ret_val = args[0].ret_val;
			break;
		case OP_UMINUS:
			if(ISARG3(S_INT, S_FLOAT, S_DEC)) {
				rval.ret_val = args[0].ret_val;
				if(ISARG(S_INT))
					rval.type = OP_UMINUS_INT;
				else if(ISARG(S_FLOAT))
					rval.type = OP_UMINUS_DBL;
			}
			break;
		case OP_PLUS:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING)) {
				l1 = GETSSIZE(args[0].ret_val)+GETSSIZE(args[1].ret_val)-1;
				rval.ret_val = MKSTYPE(S_ZSTRING, (l1 < MAX_STR_LEN) ? l1 : MAX_STR_LEN);
				rval.type = OP_PLUS_STR_STR;
				break;
			}
			if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(arg_type[0] == S_DATE && arg_type[1] != S_DATE) {
				rval.type = (arg_type[1] == S_INT) ? OP_PLUS_DAT_INT : OP_PLUS_DAT_DBL;
				rval.ret_val = MKSTYPE(S_DATE, sizeof(LDATE));
				break;
			}
			if(ISONEOFARGS2(S_DATE))
				break;
			if(arg_type[1] == S_DATE && arg_type[0] != S_DATE) {
				rval.type = (arg_type[0] == S_INT) ? OP_PLUS_INT_DAT : OP_PLUS_DBL_DAT;
				rval.ret_val = MKSTYPE(S_DATE, sizeof(LDATE));
				break;
			}
			if(arg_type[0] == S_TIME && arg_type[1] != S_TIME) {
				rval.type = (arg_type[1] == S_INT) ? OP_PLUS_TIM_INT : OP_PLUS_TIM_DBL;
				rval.ret_val = MKSTYPE(S_TIME, sizeof(LTIME));
				break;
			}
			if(arg_type[1] == S_TIME && arg_type[0] != S_TIME) {
				rval.type = (arg_type[0] == S_INT) ? OP_PLUS_INT_TIM : OP_PLUS_DBL_TIM;
				rval.ret_val = MKSTYPE(S_TIME, sizeof(LTIME));
				break;
			}
			if(ISONEOFARGS2(S_TIME))
				break;
			switch(arg_type[0]) {
				case S_DEC:
					if(arg_type[1] == S_DEC) {
						l1 = GETSSIZED(arg_type[0]);
						l2 = GETSSIZED(arg_type[1]);
						l1 = (l1 > l2) ? l1 : l2;
						l2 = GETSPRECD(arg_type[0]);
						l2 = (l2 > GETSPRECD(arg_type[1])) ? l2 : GETSPRECD(arg_type[1]);
						rval.ret_val = MKSTYPED(S_DEC, l1, l2);
					}
					else
						rval.ret_val = args[0].ret_val;
					rval.type = (arg_type[1] == S_INT) ? OP_PLUS_DBL_INT : OP_PLUS_DBL_DBL;
					break;
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_PLUS_DBL_INT : OP_PLUS_DBL_DBL;
					rval.ret_val = (arg_type[1] == S_DEC) ? args[1].ret_val : MKSTYPE(S_FLOAT, 8);
					break;
				case S_INT:
					if(arg_type[1] != S_INT)
						rval.SetTR(OP_PLUS_INT_DBL, args[1].ret_val);
					else
						rval.SetTR(OP_PLUS_INT_INT, MKSTYPE(S_INT, 4));
					break;
			}
			break;
		case OP_MINUS:
			if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(arg_type[0] == S_DATE) {
				if(arg_type[1] != S_TIME) {
					if(arg_type[1] == S_DATE)
						rval.SetTR(OP_MINUS_DAT_DAT, MKSTYPE(S_INT, 4));
					else if(arg_type[1] == S_INT)
						rval.SetTR(OP_MINUS_DAT_INT, args[0].ret_val);
					else
						rval.SetTR(OP_MINUS_DAT_DBL, args[0].ret_val);
				}
				break;
			}
			if(ISONEOFARGS2(S_DATE))
				break;
			if(arg_type[0] == S_TIME) {
				if(arg_type[1] != S_DATE) {
					if(arg_type[1] == S_TIME)
						rval.SetTR(OP_MINUS_TIM_TIM, MKSTYPE(S_INT, 4));
					else if(arg_type[1] == S_INT)
						rval.SetTR(OP_MINUS_TIM_INT, args[0].ret_val);
					else
						rval.SetTR(OP_MINUS_TIM_DBL, args[0].ret_val);
				}
				break;
			}
			if(ISONEOFARGS2(S_TIME))
				break;
			switch(arg_type[0]) {
				case S_DEC:
					if(arg_type[1] == S_DEC) {
						l1 = GETSSIZED(arg_type[0]);
						l2 = GETSSIZED(arg_type[1]);
						l1 = (l1 > l2) ? l1 : l2;
						l2 = GETSPRECD(arg_type[0]);
						l2 = (l2 > GETSPRECD(arg_type[1])) ? l2 : GETSPRECD(arg_type[1]);
						rval.ret_val = MKSTYPED(S_DEC, l1, l2);
					}
					else
						rval.ret_val = args[0].ret_val;
					rval.type = (arg_type[1] == S_INT) ? OP_MINUS_DBL_INT : OP_MINUS_DBL_DBL;
					break;
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_MINUS_DBL_INT : OP_MINUS_DBL_DBL;
					rval.ret_val = (arg_type[1] == S_DEC) ? args[1].ret_val : MKSTYPE(S_FLOAT, 8);
					break;
				case S_INT:
					if(arg_type[1] != S_INT)
						rval.SetTR(OP_MINUS_INT_DBL, args[1].ret_val);
					else
						rval.SetTR(OP_MINUS_INT_INT, MKSTYPE(S_INT, 4));
					break;
			}
			break;
		case OP_MULT:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING)) {
				l1 = GETSSIZE(args[0].ret_val) + GETSSIZE(args[1].ret_val);
				rval.ret_val = MKSTYPE(S_ZSTRING, (l1 < MAX_STR_LEN) ? l1 : MAX_STR_LEN);
				rval.type = OP_MULT_STR_STR;
				break;
			}
			if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DATE))
				break;
			switch(arg_type[0]) {
				case S_DEC:
					if(arg_type[1] == S_DEC) {
						l1 = GETSSIZED(arg_type[0]);
						l2 = GETSSIZED(arg_type[1]);
						l1 = (l1 > l2) ? l1 : l2;
						l2 = GETSPRECD(arg_type[0]);
						l2 = (l2 > GETSPRECD(arg_type[1])) ? l2 : GETSPRECD(arg_type[1]);
						rval.ret_val = MKSTYPED(S_DEC, l1, l2);
					}
					else
						rval.ret_val = args[0].ret_val;
					rval.type = (arg_type[1] == S_INT) ? OP_MULT_DBL_INT : OP_MULT_DBL_DBL;
					break;
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_MULT_DBL_INT : OP_MULT_DBL_DBL;
					rval.ret_val = (arg_type[1] == S_DEC) ? args[1].ret_val : MKSTYPE(S_FLOAT, 8);
					break;
				case S_INT:
					if(arg_type[1] == S_INT)
						rval.SetTR(OP_MULT_INT_INT, MKSTYPE(S_INT, 4));
					else
						rval.SetTR(OP_MULT_INT_DBL, args[1].ret_val);
					break;
			}
			break;
		case OP_DIV:
			if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DATE))
				break;
			switch(arg_type[0]) {
				case S_DEC:
					if(arg_type[1] == S_DEC) {
						l1 = GETSSIZED(arg_type[0]);
						l2 = GETSSIZED(arg_type[1]);
						l1 = (l1 > l2) ? l1 : l2;
						l2 = GETSPRECD(arg_type[0]);
						l2 = (l2 > GETSPRECD(arg_type[1])) ? l2 : GETSPRECD(arg_type[1]);
						rval.ret_val = MKSTYPED(S_DEC, l1, l2);
					}
					else
						rval.ret_val = args[0].ret_val;
					rval.type = (arg_type[1] == S_INT) ? OP_DIV_DBL_INT : OP_DIV_DBL_DBL;
					break;
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_DIV_DBL_INT : OP_DIV_DBL_DBL;
					rval.ret_val = (arg_type[1] == S_DEC) ? args[1].ret_val : MKSTYPE(S_FLOAT, 8);
					break;
				case S_INT:
					if(arg_type[1] != S_INT)
						rval.SetTR(OP_DIV_INT_DBL, args[1].ret_val);
					else
						rval.SetTR(OP_DIV_INT_INT, MKSTYPE(S_INT, 4));
					break;
			}
			break;
		case OP_TO_DBL:
			if(ISARG(S_INT))
				rval.SetTR(OP_TO_DBL_INT, MKSTYPE(S_FLOAT, 8));
			else if(ISARG(S_ZSTRING))
				rval.SetTR(OP_TO_DBL_STR, MKSTYPE(S_FLOAT, 8));
			break;
		case OP_TO_INT:
			if(ISARG(S_FLOAT))
				rval.SetTR(OP_TO_INT_DBL, MKSTYPE(S_INT, 4));
			else if(ISARG(S_ZSTRING))
				rval.SetTR(OP_TO_INT_STR, MKSTYPE(S_INT, 4));
			break;
		case OP_TO_STR:
			switch(arg_type[0]) {
				case S_FLOAT:
				case S_DEC:  rval.SetTR(OP_TO_STR_DBL, MKSTYPE(S_ZSTRING, 16)); break;
				case S_INT:  rval.SetTR(OP_TO_STR_INT, MKSTYPE(S_ZSTRING, 16)); break;
				case S_DATE: rval.SetTR(OP_TO_STR_DAT, MKSTYPE(S_ZSTRING, 16)); break;
				case S_TIME: rval.SetTR(OP_TO_STR_TIM, MKSTYPE(S_ZSTRING, 16)); break;
			}
			break;
		case OP_IF:
			if(arg_type[0] == S_INT) {
				switch(arg_type[1]) {
					case S_FLOAT:
					case S_DEC:     rval.type = OP_IF_DBL; break;
					case S_INT:     rval.type = OP_IF_INT; break;
					case S_DATE:    rval.type = OP_IF_DAT; break;
					case S_TIME:    rval.type = OP_IF_TIM; break;
					case S_ZSTRING: rval.type = OP_IF_STR; break;
				}
				rval.ret_val = args[1].ret_val;
			}
			break;
		case OP_IF_ELSE:
			if(arg_type[0] == S_INT && arg_type[1] == arg_type[2]) {
				switch(arg_type[1]) {
					case S_FLOAT:
					case S_DEC:  rval.type = OP_IF_ELSE_DBL; break;
					case S_INT:  rval.type = OP_IF_ELSE_INT; break;
					case S_DATE: rval.type = OP_IF_ELSE_DAT; break;
					case S_TIME: rval.type = OP_IF_ELSE_TIM; break;
					case S_ZSTRING:
						rval.type = OP_IF_ELSE_STR;
						l1 = GETSSIZE(args[1].ret_val);
						l2 = GETSSIZE(args[2].ret_val);
						args[1].ret_val = MKSTYPE(S_ZSTRING, (l1 > l2) ? l1 : l2);
						break;
				}
				rval.ret_val = args[1].ret_val;
			}
			break;
		case OP_LEN:
			if(ISARG(S_ZSTRING))
				rval.SetTR(OP_LEN, MKSTYPE(S_INT, 4));
			break;
		case OP_LEFT:
		case OP_MIDL:
		case OP_RIGHT:
		case OP_WRAP:             rval.SetTR(opType, args[0].ret_val); break;
		case OP_FORMATPERIOD:     rval.SetTR(opType, MKSTYPE(S_ZSTRING, 30)); break;
		case OP_PRINTABLEBARCODE: rval.SetTR(opType, MKSTYPE(S_ZSTRING, 20)); break;
		case OP_ABS_DBL:          rval.SetTR(opType, MKSTYPE(S_FLOAT, 8)); break;
		case OP_ABS_INT:          rval.SetTR(opType, MKSTYPE(S_INT, 4)); break;
		case OP_EQUL:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_EQUL_STR_STR;
			else if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_EQUL_DAT_DAT;
			else if(ISARGPAIR(S_DATE, S_INT))
				rval.type = OP_EQUL_DAT_INT;
			else if(ISARGPAIR(S_INT, S_DATE))
				rval.type = OP_EQUL_INT_DAT;
			else if(ISONEOFARGS2(S_DATE))
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_EQUL_TIM_TIM;
			else if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DEC))
				break;
			if(ISARG(S_FLOAT))
				rval.type = (arg_type[1] == S_INT) ? OP_EQUL_DBL_INT : OP_EQUL_DBL_DBL;
			else if(ISARG(S_INT))
				rval.type = (arg_type[1] != S_INT) ? OP_EQUL_INT_DBL : OP_EQUL_INT_INT;
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_NOTEQUL:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_NOTEQUL_STR_STR;
			else if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_NOTEQUL_DAT_DAT;
			else if(ISARGPAIR(S_DATE, S_INT))
				rval.type = OP_NOTEQUL_DAT_INT;
			else if(ISARGPAIR(S_INT, S_DATE))
				rval.type = OP_NOTEQUL_INT_DAT;
			else if(ISONEOFARGS2(S_DATE))
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_NOTEQUL_TIM_TIM;
			else if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DEC))
				break;
			switch(arg_type[0]) {
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_NOTEQUL_DBL_INT : OP_NOTEQUL_DBL_DBL;
					break;
				case S_INT:
					rval.type = (arg_type[1] != S_INT) ? OP_NOTEQUL_INT_DBL : OP_NOTEQUL_INT_INT;
					break;
			}
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_LESS:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_LESS_STR_STR;
			else if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_LESS_DAT_DAT;
			else if(ISONEOFARGS2(S_DATE))
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_LESS_TIM_TIM;
			else if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DEC))
				break;
			switch(arg_type[0]) {
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_LESS_DBL_INT : OP_LESS_DBL_DBL;
					break;
				case S_INT:
					rval.type = (arg_type[1] != S_INT) ? OP_LESS_INT_DBL : OP_LESS_INT_INT;
					break;
			}
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_LESS_EQ:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_LESSEQ_STR_STR;
			else if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_LESSEQ_DAT_DAT;
			else if(ISONEOFARGS2(S_DATE))
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_LESSEQ_TIM_TIM;
			else if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DEC))
				break;
			switch(arg_type[0]) {
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_LESSEQ_DBL_INT : OP_LESSEQ_DBL_DBL;
					break;
				case S_INT:
					rval.type = (arg_type[1] != S_INT) ? OP_LESSEQ_INT_DBL : OP_LESSEQ_INT_INT;
					break;
			}
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_GREAT:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_GREAT_STR_STR;
			else if(ISONEOFARGS2(S_ZSTRING))
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_GREAT_DAT_DAT;
			else if(ISONEOFARGS2(S_DATE))
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_GREAT_TIM_TIM;
			else if(ISONEOFARGS2(S_TIME))
				break;
			if(ISONEOFARGS2(S_DEC))
				break;
			switch(arg_type[0]) {
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_GREAT_DBL_INT : OP_GREAT_DBL_DBL;
					break;
				case S_INT:
					rval.type = (arg_type[1] != S_INT) ? OP_GREAT_INT_DBL : OP_GREAT_INT_INT;
					break;
			}
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_GREAT_EQ:
			if(ISARGPAIR(S_ZSTRING, S_ZSTRING))
				rval.type = OP_GREATEQ_STR_STR;
			else if(arg_type[0] == S_ZSTRING || arg_type[1] == S_ZSTRING)
				break;
			if(ISARGPAIR(S_DATE, S_DATE))
				rval.type = OP_GREATEQ_DAT_DAT;
			else if(arg_type[0] == S_DATE || arg_type[1] == S_DATE)
				break;
			if(ISARGPAIR(S_TIME, S_TIME))
				rval.type = OP_GREATEQ_TIM_TIM;
			else if(arg_type[1] == S_TIME || arg_type[0] == S_TIME)
				break;
			if(arg_type[0] == S_DEC || arg_type[1] == S_DEC)
				break;
			switch(arg_type[0]) {
				case S_FLOAT:
					rval.type = (arg_type[1] == S_INT) ? OP_GREATEQ_DBL_INT : OP_GREATEQ_DBL_DBL;
					break;
				case S_INT:
					rval.type = (arg_type[1] != S_INT) ? OP_GREATEQ_INT_DBL : OP_GREATEQ_INT_INT;
					break;
			}
			rval.ret_val = MKSTYPE(S_INT, 4);
			break;
		case OP_LOG_OR:
		case OP_LOG_AND:
		case OP_BIT_AND:
		case OP_BIT_OR:
		case OP_BIT_XOR:
			if(arg_type[0] == S_INT && arg_type[1] == S_INT)
				rval.SetTR(opType, MKSTYPE(S_INT, 4));
			break;
	}
	if(!rval.ret_val)
		yyerror("Could not translate operation1");
	return rval;
}

FormatSpec SetFormat(char * fmt, long tp)
{
	int    oset = 0;
	char * curpos = fmt;
	FormatSpec fs;

	memset(&fs, 0, sizeof(FormatSpec));
	switch(GETARYSTYPE(tp)) {
		case S_INT:
			if(fmt && (fmt[0] != '>') && (fmt[0] != '|') && (fmt[0] != '<'))
				fs.flags = ALIGN_RIGHT;
			break;
		case S_FLOAT:
			if(fmt && (fmt[0] != '>') && (fmt[0] != '|') && (fmt[0] != '<'))
				fs.flags = ALIGN_RIGHT;
			fs.prec = 2;
			break;
		case S_DEC:
			if(fmt && (fmt[0] != '>') && (fmt[0] != '|') && (fmt[0] != '<'))
				fs.flags = ALIGN_RIGHT;
			fs.prec = (short)GETSPRECD(tp);
			break;
		case S_ZSTRING:
			fs.len = (short)GETSSIZE(tp);
		case S_DATE:
		case S_TIME:
			if(fmt && (fmt[0] != '>') && (fmt[0] != '|') && (fmt[0] != '<'))
				fs.flags = ALIGN_LEFT;
			break;
	}
	if(fmt && fmt[0]) {
		if(fmt[0] == '>') {
			fs.flags = ALIGN_RIGHT;
			curpos++;
		}
		else if(fmt[0] == '<') {
			fs.flags = ALIGN_LEFT;
			curpos++;
		}
		else if(fmt[0] == '|') {
			fs.flags = ALIGN_CENTER;
			curpos++;
		}
		if(*curpos == '*') {
			fs.flags |= COMF_FILLOVF;
			curpos++;
		}
		if(atoi(curpos))
			fs.len = atoi(curpos);
		if((GETSTYPE(tp) == S_FLOAT) || (GETSTYPE(tp) == S_DEC))
			if(curpos = strchr(curpos, '.'))
				fs.prec = atoi(curpos+1);
		if(curpos = strchr(fmt, '@')) {
			switch(toupper(curpos[1])) {
				case 'U': fs.flags |= STRF_UPPER;    break;
				case 'L': fs.flags |= STRF_LOWER;    break;
				case 'P': fs.flags |= STRF_PASSWORD; break;
			}
		}
		if(curpos = strchr(fmt, '#')) {
			switch(toupper(curpos[1])) {
				case 'A': fs.flags |= DATF_AMERICAN; break;
				case 'G': fs.flags |= DATF_GERMAN;   break;
				case 'B': fs.flags |= DATF_BRITISH;  break;
				case 'I': fs.flags |= DATF_ITALIAN;  break;
				case 'J': fs.flags |= DATF_JAPAN;    break;
				case 'F': fs.flags |= DATF_FRENCH;   break;
				case 'U': fs.flags |= DATF_USA;      break;
				case 'D': fs.flags |= DATF_DMY;      break;
				case 'W': fs.flags |= DATF_ANSI;     break;
				case 'M': fs.flags |= DATF_MDY;      break;
				case 'Y': fs.flags |= DATF_YMD;      break;
			}
			if(toupper(curpos[2]) == 'C') {
				fs.flags |= DATF_CENTURY;
				if(!fs.len)
					fs.len = 10;
			}
			else if(!fs.len)
				fs.len = 8;
		}
		if(curpos = strchr(fmt, '$')) {
			for(curpos++; *curpos; curpos++)
				switch(toupper(*curpos)) {
					case 'C': fs.flags |= NMBF_DELCOMMA;  break;
					case 'A': fs.flags |= NMBF_DELAPOSTR; break;
					case 'S': fs.flags |= NMBF_DELSPACE;  break;
					case 'Z': fs.flags |= NMBF_NOZERO;    break;
					case 'F': fs.flags |= NMBF_FORCEPOS;  break;
					case 'N': fs.flags |= NMBF_NOTRAILZ;  break;
				}
		}
		if((curpos = strchr(fmt, '&')) != 0) {
			switch(curpos[1]) {
				case 'F':
				case 'f':
					if(!fs.len)
						fs.len = 11;
					fs.flags |= TIMF_HMS | TIMF_MSEC;
					break;
				case 'N':
				case 'n':
					if(!fs.len)
						fs.len = 8;
					fs.flags |= TIMF_HMS;
					break;
				case 'H':
				case 'h':
					if(!fs.len)
						fs.len = 5;
					fs.flags |= TIMF_HM;
					break;
				case 'L':
					if(!fs.len)
						fs.len = 5;
					fs.flags |= TIMF_MS | TIMF_MSEC;
					break;
				case 'l':
					if(!fs.len)
						fs.len = 5;
					fs.flags |= TIMF_MS;
					break;
				case 'S':
					if(!fs.len)
						fs.len = 5;
					fs.flags |= TIMF_S | TIMF_MSEC;
					break;
				case 's':
					if(!fs.len)
						fs.len = 2;
					fs.flags |= TIMF_S;
					break;
			}
			if(toupper(curpos[2]) == 'B')
				fs.flags |= TIMF_BLANK;
		}
	}
	return fs;
}

