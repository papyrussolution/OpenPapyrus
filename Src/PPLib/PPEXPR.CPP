// PPEXPR.CPP
// Copyright (c) A.Sobolev 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2024, 2025
// @codepage UTF-8
// @Kernel
// Трансляция формул
//
#include <pp.h>
#pragma hdrstop

ExprEvalContext::FC::FC() : RetType(MKSTYPE(S_FLOAT, 8)), RetReal(0.0)
{
}

ExprEvalContext::FC & ExprEvalContext::FC::Z()
{
	ArgList.clear();
	StrArg.Z();
	RetType = MKSTYPE(S_FLOAT, 8);
	RetReal = 0.0;
	RetStr.Z();
	return *this;
}

ExprEvalContext::ExprEvalContext() : ImplementFlags(0), P_Next__(0)
{
}

ExprEvalContext::~ExprEvalContext()
{
}

int ExprEvalContext::SetInnerContext(ExprEvalContext * pInner)
{
	int    ok = -1;
	if(pInner) {
		int    done = 0;
		ExprEvalContext * p_last = this;
		if(p_last != pInner) {
			while(!done && p_last && p_last->P_Next__) {
				p_last = p_last->P_Next__;
				if(p_last == pInner) {
					assert(!p_last->P_Next__ || !p_last->P_Next__->P_Next__);
					p_last->P_Next__ = 0;
					done = 1;
				}
			}
		}
		else
			done = 1;
		assert(p_last != 0 && p_last->P_Next__ == 0);
		if(!done) {
			p_last->P_Next__ = pInner;
			ok = 1;
		}
	}
	else {
		P_Next__ = 0;
		ok = 2;
	}
	return ok;
}

bool ExprEvalContext::SelfScanArgList() const { return LOGIC(ImplementFlags & fSelfScanArgList); }
/*virtual*/int ExprEvalContext::IsFunc(const char * pSymb, int * pFuncId) { return 0; }
/*virtual*/int ExprEvalContext::ResolveFunc(int funcId, FC & rFc) { return 0; }

/*static*/int STDCALL PPExprParser::CalcExpression(const char * pStr, double * pResult, const PPCalcFuncList * pCFL, ExprEvalContext * pCtx)
{
	PPExprParser parser(pStr, pCFL, pCtx);
	return parser.CalcExpr(pResult);
}
//
// BillContext
//
BillSymbCache::BillSymbCache() : ObjCache(PPOBJ_BILLSYMB, sizeof(Data)), sDELIM(0x0000005CL)
{
	FormSet.setDelim(reinterpret_cast<const char *>(&sDELIM));
}

/*virtual*/int BillSymbCache::FetchEntry(PPID id, ObjCacheEntry * pEntry, void * /*extraData*/)
{
	return 0;
}

/*virtual*/void BillSymbCache::EntryToData(const ObjCacheEntry * pEntry, void * pDataRec) const
{
}

int DirtyBillSymbCache(const char * pSymb)
{
	int    ok = -1;
	if(pSymb) {
		BillSymbCache * p_cache = GetDbLocalCachePtr <BillSymbCache> (PPOBJ_BILLSYMB);
		if(p_cache) {
			p_cache->DirtySymb(pSymb);
			ok = 1;
		}
	}
	return ok;
}

int BillSymbCache::Add(int F, PPID id, const char * symb, const char * form)
{
	int    ok = 1;
	uint   pos;
	Data   entry;
	MEMSZERO(entry);
	entry.ID = id;
	entry.F = F;
	THROW_SL(SymbSet.add(symb, &(pos = 0)));
	THROW_SL(FormSet.add(form, &(pos = 0)));
	THROW_SL(P_Ary->insert(&entry));
	CATCHZOK
	return ok;
}

int BillSymbCache::Search(const char * pSymb, PPID * pID, SString & rBuf) const
{
	int    ok = 0;
	SString s, f;
	rBuf.Z();
	for(uint n = 0, pos = 0; !ok && SymbSet.get(&pos, s); n++)
		if(stricmp866(s, pSymb) == 0) {
			const Data * p_entry = static_cast<const Data *>(SearchByPos(n, 0));
			if(p_entry->F & 0x0001) {
				*pID = p_entry->ID;
				ok = 1;
			}
			else if(p_entry->F & 0x0002) {
				uint j = 0;
				for(pos = 0; FormSet.get(&pos, f) && j < n; j++)
					;
				rBuf = f;
				*pID = p_entry->ID;
				ok = 2;
			}
			else if(p_entry->F & 0x0008) {
				*pID = p_entry->ID;
				ok = 3;
			}
		}
	return ok;
}

int BillSymbCache::DirtySymb(const char * pSymb)
{
	int    ok = 0;
	SString s;
	{
		SRWLOCKER(RwL, SReadWriteLocker::Write);
		for(uint n = 0, pos = 0; !ok && SymbSet.get(&pos, s); n++) {
			if(stricmp866(s, pSymb) == 0) {
				Data * p_entry = static_cast<Data *>(SearchByPos(n, 0));
				p_entry->F = 0;
			}
		}
	}
	return ok;
}

int BillSymbCache::Fetch(const char * pSymb, PPID * pID, SString & rBuf)
{
	int    ok = 0;
	int    r;
	Data   entry;
	SString s, f;
	PPErrCode = 0;
	rBuf.Z();
	{
		SRWLOCKER(RwL, SReadWriteLocker::Read);
		StatData.Count.Incr();
		ok = Search(pSymb, pID, rBuf);
		if(ok)
			StatData.Hits.Incr();
		else
			StatData.Misses.Incr();
		if(!ok) {
			SRWLOCKER_TOGGLE(SReadWriteLocker::Write);
			PPID   id = 0;
			PPObjAmountType at_obj;
			PPObjFormula    f_obj;
			if((r = at_obj.SearchSymb(&id, pSymb)) > 0) {
				f.Z();
				s = pSymb;
				if(Add(0x0001, id, s.Strip(), f.Strip())) {
					*pID = id;
					ok = 1;
				}
				else
					ok = 0;
			}
			else if(r && (r = f_obj.SearchByName(pSymb, &id)) > 0) {
				if(f_obj.Get(id, s, f) > 0) {
					if(Add(0x0002, id, s.Strip(), f.Strip())) {
						*pID = id;
						rBuf = f;
						ok = 2;
					}
					else
						ok = 0;
				}
			}
			else {
				PPSymbTranslator st;
				if(!st)
					ok = 0;
				else {
					size_t next_pos = 0;
					id = st.Translate(pSymb, &next_pos);
					if(id == PPSYM_ADVLNAMT) {
						f.Z();
						s = pSymb;
						if(Add(0x0008, PPAMT_ADLN_MAIN, s.Strip(), f.Strip())) {
							*pID = PPAMT_ADLN_MAIN;
							ok = 3;
						}
						else
							ok = 0;
   					}
					if(!r)
						ok = 0;
				}
			}
		}
	}
	if(!ok && !PPErrCode)
		PPSetError(PPERR_ILLVAR, pSymb);
	return ok;
}
//
//
//
#define CURR_BILL      0
#define LINK_BILL      1
#define RCKN_BILL      2

#define ARTSYMB_QTTY   1
#define ARTSYMB_PHQTTY 2

BillContext::BillContext(const PPBillPacket * p, PPID curID, uint advLineIdx) : ExprEvalContext(),
	P_Pack(p), CurID(curID), LinkID(p ? p->Rec.LinkBillID : 0), ReckonID(p ? p->PaymBillID : 0), AdvLineIdx(advLineIdx)
{
}

/*virtual*/int BillContext::IsFunc(const char * pSymb, int * pFuncId)
{
	// amountbyvat(x)
	int    func_id = 0;
	SString temp_buf;
	SStrScan scan(pSymb);
	if(scan.Skip().GetIdent(temp_buf)) {
		temp_buf.ToLower();
		if(temp_buf == "amountbyvat")
			func_id = funcAmountByVat;
		else if(temp_buf == "amountbygvat")
			func_id = funcAmountByGVat;
		else if(temp_buf == "amountbytvat")
			func_id = funcAmountByTVat;
		else if(temp_buf == "costbyvat")
			func_id = funcCostByVat;
		else if(temp_buf == "costvat")
			func_id = funcCostVat;
		else if(temp_buf == "pricebyvat")
			func_id = funcPriceByVat;
		else if(temp_buf == "pricevat")
			func_id = funcPriceVat;
		else if(temp_buf == "haswhitelabel")
			func_id = funcHasWhiteLabel;
		else
			PPSetError(PPERR_UNDEFGOODSFUNC, pSymb);
	}
	ASSIGN_PTR(pFuncId, func_id);
	return BIN(func_id);
}

int BillContext::ResolveFunc(int funcId, FC & rFc)
{
	int    ok = 1;
	double result = 0.0;
	double arg = rFc.ArgList.getCount() ? rFc.ArgList.at(0) : 0.0;
	const  BillVatEntry * p_vat_entry = 0;
	switch(funcId) {
		case funcAmountByVat:
			CalcTotalBlock();
			p_vat_entry = Bt.VatList.GetByRate(arg);
			if(p_vat_entry)
				result = p_vat_entry->AmountByVat;
			break;
		case funcCostByVat:
			CalcTotalBlock();
			p_vat_entry = Bt.CostVatList.GetByRate(arg);
			if(p_vat_entry)
				result = p_vat_entry->AmountByVat;
			break;
		case funcCostVat:
			CalcTotalBlock();
			p_vat_entry = Bt.CostVatList.GetByRate(arg);
			if(p_vat_entry)
				result = p_vat_entry->VatSum;
			break;
		case funcPriceByVat:
			CalcTotalBlock();
			p_vat_entry = Bt.PriceVatList.GetByRate(arg);
			if(p_vat_entry)
				result = p_vat_entry->AmountByVat;
			break;
		case funcPriceVat:
			CalcTotalBlock();
			p_vat_entry = Bt.PriceVatList.GetByRate(arg);
			if(p_vat_entry)
				result = p_vat_entry->VatSum;
			break;
		case funcAmountByGVat:
			//
			// Для этого расчета нельзя воспользоваться общим блоком this->Bt
			// из-за специального флага BTC_CALCNOMINALGVAT.
			//
			{
				BillTotalData local_bt;
				const_cast<PPBillPacket *>(P_Pack)->CalcTotal(local_bt, BTC_CALCSALESTAXES|BTC_CALCNOMINALGVAT); // @attention cast const-->nonconst
				const BillVatEntry * p_vat_entry = local_bt.VatList.GetByRate(arg);
				if(p_vat_entry)
					result = p_vat_entry->AmountByVat;
			}
			break;
		case funcAmountByTVat:
			{
				PPObjID_Base objid;
				objid = arg;
				double arg2 = (rFc.ArgList.getCount() > 1) ? rFc.ArgList.at(1) : 0.0;
				THROW_PP(objid.Obj == PPOBJ_GOODSTYPE, PPERR_OBJEXPECTED_GOODSTYPE);
				BillTotalData local_bt;
				const_cast<PPBillPacket *>(P_Pack)->CalcTotal(local_bt, objid.Id, BTC_CALCSALESTAXES); // @attention cast const-->nonconst
				const BillVatEntry * p_vat_entry = local_bt.VatList.GetByRate(arg2);
				if(p_vat_entry)
					result = p_vat_entry->AmountByVat;
			}
			break;
		case funcHasWhiteLabel:
			result = (P_Pack->Rec.Flags & BILLF_WHITELABEL) ? 1.0 : 0.0;
			break;
	}
	CATCHZOK
	rFc.RetType = T_DOUBLE;
	rFc.RetReal = result;
	return ok;
}

int BillContext::CalcTotalBlock()
{
	int    ok = -1;
	if(!(Bt.Flags & BillTotalData::fInitialized) && P_Pack) {
		const_cast<PPBillPacket *>(P_Pack)->CalcTotal(Bt, BTC_CALCSALESTAXES); // @attention cast const-->nonconst
		ok = 1;
	}
	return ok;
}

int BillContext::ProcessLink(PPID linkBillID, PPID amtID, int artefactSymb, PPID addCurID, bool errOnDefault, double * pResult)
{
	int    ok = 1;
	double result = 0.0;
	if(linkBillID) {
		PPObjBill * p_bobj = BillObj;
		if(artefactSymb) {
			BillTotalData btd;
			PPBillPacket link_pack;
			THROW(p_bobj->ExtractPacket(linkBillID, &link_pack) > 0);
			link_pack.CalcTotal(btd, 0);
			if(artefactSymb == ARTSYMB_QTTY)
				result = btd.UnitsCount;
			else if(artefactSymb == ARTSYMB_PHQTTY)
				result = btd.PhUnitsCount;
		}
		else {
			THROW_PP((p_bobj->P_Tbl->GetAmount(linkBillID, amtID, CurID, &result) > 0 || !errOnDefault), PPERR_AMTNOTPRESENT);
			if(addCurID >= 0) {
				double add_amt = 0.0;
				THROW_PP((p_bobj->P_Tbl->GetAmount(linkBillID, amtID, addCurID, &add_amt) > 0 || !errOnDefault), PPERR_AMTNOTPRESENT);
				result += add_amt;
			}
		}
	}
	CATCHZOK
	ASSIGN_PTR(pResult, result);
	return ok;
}

int BillContext::Resolve(const char * b, double * pResult)
{
	int    ok = 1, r, sel = CURR_BILL;
	bool   err_on_default = false;
	int    artefact_symb = 0; // ahtoxa
	PPID   id = 0;
	double val = 0.0;
	char   sel_buf[64];
	SString form;
	char * p_delim = const_cast<char *>(sstrchr(b, '.')); // @badcast
	*pResult = 0;
	if(p_delim) {
		*p_delim = 0;
		STRNSCPY(sel_buf, b);
		if(sstreqi_ascii(b, "LINK"))
			sel = LINK_BILL;
		else if(sstreqi_ascii(b, "RCKN"))
			sel = RCKN_BILL;
		else {
			CALLEXCEPT_PP_S(PPERR_ILLVAR, b);
		}
		b = p_delim+1;
		*p_delim = '.';
	}
	if(sstreqi_ascii(b, "QTTY")) {
		artefact_symb = ARTSYMB_QTTY;
		r = 1;
	}
	else if(sstreqi_ascii(b, "PHQTTY")) {
		artefact_symb = ARTSYMB_PHQTTY;
		r = 1;
	}
	else {
		BillSymbCache * p_cache = GetDbLocalCachePtr <BillSymbCache> (PPOBJ_BILLSYMB);
		THROW((r = p_cache->Fetch(b, &id, form)) > 0);
	}
	if(r == 1) {
		PPID   add_cur_id = -1;
		double add_amt = 0.0;
		const  PPID base_cur_id = LConfig.BaseCurID;
		if(CurID == 0) {
			if(base_cur_id)
				add_cur_id = base_cur_id;
		}
		else if(CurID == base_cur_id)
			add_cur_id = 0L;
		if(sel == CURR_BILL) {
			// ahtoxa {
			if(artefact_symb) {
				CalcTotalBlock();
				if(artefact_symb == ARTSYMB_QTTY)
					val = Bt.UnitsCount;
				else if(artefact_symb == ARTSYMB_PHQTTY)
					val = Bt.PhUnitsCount;
			}
			// } ahtoxa
			else {
				THROW_PP(((r = P_Pack->Amounts.Get(id, CurID, &val)) > 0 || !err_on_default), PPERR_AMTNOTPRESENT);
				if(r < 0 && id == PPAMT_MAIN && CurID == P_Pack->Rec.CurID)
					val = P_Pack->GetAmount();
				if(add_cur_id >= 0) {
					THROW_PP(((r = P_Pack->Amounts.Get(id, add_cur_id, &add_amt)) > 0 || !err_on_default), PPERR_AMTNOTPRESENT);
					if(r < 0 && id == PPAMT_MAIN && add_cur_id == P_Pack->Rec.CurID)
						add_amt = P_Pack->GetAmount();
					val += add_amt;
				}
			}
		}
		else if(sel == LINK_BILL) {
			THROW_PP(LinkID, PPERR_ILLVAR);
			THROW(ProcessLink(LinkID, id, artefact_symb, add_cur_id, err_on_default, &val));
		}
		else if(sel == RCKN_BILL) {
			if(ReckonID) {
				THROW(ProcessLink(ReckonID, id, artefact_symb, add_cur_id, err_on_default, &val));
			}
			else
				val = 0.0;
		}
	}
	else if(r == 3) {
		PPAdvBillItemList::Item & r_adv_line = P_Pack->AdvList.Get(AdvLineIdx);
		if((&r_adv_line) != 0) {
			if(id == PPAMT_ADLN_MAIN)
				val = r_adv_line.Amount;
		}
	}
	else
		THROW(PPExprParser::CalcExpression(form, &val, 0, this));
	*pResult = val;
	CATCH
		*pResult = 0;
		ok = 0;
	ENDCATCH
	return ok;
}
//
//
//
PPExprParser::State::State() : OidObjType(0), OidObjTypeExt(0)
{
}

PPExprParser::State::State(const State & rS) : OidObjType(rS.OidObjType), OidObjTypeExt(rS.OidObjTypeExt)
{
}

PPExprParser::State & FASTCALL PPExprParser::State::operator = (const PPExprParser::State & rS)
{
	OidObjType = rS.OidObjType;
	OidObjTypeExt = rS.OidObjTypeExt;
	return *this;
}

PPExprParser::FuncBlock::FuncBlock() : Func(0)
{
}

PPExprParser::FuncBlock & PPExprParser::FuncBlock::Z()
{
	Func = 0;
	ExtToken.Z();
	ClearSieve();
	return *this;
}
		
int   PPExprParser::FuncBlock::GetFuncId() const { return Func; }
void  PPExprParser::FuncBlock::SetFuncId(int f) { Func = f; }

void  PPExprParser::FuncBlock::ClearSieve()
{
	Sieve.Z();
	SieveVal.freeAll();
}

PPExprParser::PPExprParser(const char * pStr, const PPCalcFuncList * pCFL, ExprEvalContext * pContext) :
	Token(0), Number(0.0), Pos(0), P_Ctx(pContext), P_CFL(pCFL), P_S(newStr(pStr)), /*Func(0)*/Fb()
{
	Next();
}

PPExprParser::~PPExprParser()
{
	delete P_S;
}

int PPExprParser::Next() { return P_S[Pos] ? (Cur = static_cast<int>(P_S[Pos++])) : (Cur = -1); }

// sieve[1.0; 20000.0 ? 2.5; 40000 ? 4]
// sieve[1.0; @pp:alc_price_limit]

int PPExprParser::GetSieve()
{
	int    ok = 1;
	SString temp_buf, sub;
	//Sieve.Z();
	//SieveVal.freeAll();
	Fb.ClearSieve();
	while(oneof2(Cur, ' ', '\t'))
		Next();
	THROW_PP_S(Cur == '[', PPERR_INVEXPR, P_S);
	while(Next() != ']') {
		THROW_PP_S(Cur != -1, PPERR_INVEXPR, P_S);
		temp_buf.CatChar(Cur);
	}
	{
		Next(); // Забрать символ ']' из потока
		SString sub, left, right;
		StringSet ss(';', temp_buf.Strip());
		long   id = 0;
		int    was_default = 0;
		for(uint pos = 0; ss.get(&pos, sub);) {
			if(sub.Strip()[0] == '@') {
				//
				// Загрузка таблицы из файла
				//
				sub.ShiftLeft(1);
				if(sub.Divide(':', left, right) <= 0) {
					right = left;
					left = "pp";
				}
				SString file_name;
				PPGetFilePath(PPPATH_DD, left, file_name);
				SFsPath::ReplaceExt(file_name, "tab", 0);
				STab tab;
				STab::Row row;
				STabFile f(file_name, 0);
				THROW_SL(f.IsValid());
				THROW_SL(f.LoadTab(right.Strip(), tab) > 0);
				for(uint i = 0; i < tab.GetCount(); i++) {
					double bin = 0.0;
					double val = 0.0;
					tab.GetRow(i, row);
					if(row.Get(0, bin)) {
						++id;
						if(row.Get(1, val)) {
							Fb.Sieve.AddBin(id, bin);
							Fb.SieveVal.Add(id, val, 0);
						}
						else {
							THROW_PP(was_default == 0, PPERR_SIEVEFUNC_DUPDEF);
							Fb.SieveVal.Add(-MAXLONG, bin, 0);
							was_default = 1;
						}
					}
				}
			}
			else {
				++id;
				if(sub.Divide('?', left, right) > 0) {
					Fb.Sieve.AddBin(id, left.ToReal());
					Fb.SieveVal.Add(id, right.ToReal(), 0);
				}
				else {
					THROW_PP(was_default == 0, PPERR_SIEVEFUNC_DUPDEF);
					Fb.SieveVal.Add(-MAXLONG, left.ToReal(), 0);
					was_default = 1;
				}
			}
		}
	}
	CATCHZOK
	return ok;
}

void PPExprParser::Skip()
{
	while(oneof4(Cur, ' ', '\t', '\r', '\n'))
		Next();
}

int PPExprParser::ResolveContextName(const char * pSymb, double * pResult)
{
	int    ok = 0;
	for(ExprEvalContext * p_ctx = P_Ctx; !ok && p_ctx; p_ctx = p_ctx->P_Next__) {
		if(p_ctx->Resolve(pSymb, pResult))
			ok = 1;
	}
	return ok;
}

int PPExprParser::GetToken()
{
	char   buf[512];
	char * p = buf;
	Token = -1;
	if(Cur > 0) {
		size_t offs = 0;
		Skip();
		if(Cur == '[') {
			do {
				if(!oneof4(Cur, ' ', '\t', '\r', '\n'))
					*p++ = Cur;
				Next();
			} while(Cur != 0 && Cur != ']');
			if(Cur == ']') {
				*p++ = ']';
				Next();
			}
			*p = 0;
			//Func = 0;
			Fb.SetFuncId(0);
			Name = buf;
			Token = tokName;
		}
		else if(isalpha(static_cast<uchar>(Cur)) || oneof3(Cur, '_', '@', '?')) {
			do {
				*p++ = Cur;
				Next();
			} while(isasciialnum(static_cast<uchar>(Cur)) || oneof2(Cur, '_', '.')); // @v11.4.9 isalnum-->isasciialnum
			*p = 0;
			//Func = 0;
			Fb.SetFuncId(0);
			if(sstreqi_ascii(buf, "abs")) { Fb.SetFuncId(funcAbs); }
			else if(sstreqi_ascii(buf, "sqrt")) { Fb.SetFuncId(funcSqrt); }
			else if(sstreqi_ascii(buf, "sin"))   { Fb.SetFuncId(funcSin); }
			else if(sstreqi_ascii(buf, "cos"))   { Fb.SetFuncId(funcCos); }
			else if(sstreqi_ascii(buf, "tan"))   { Fb.SetFuncId(funcTan); }
			else if(sstreqi_ascii(buf, "log"))   { Fb.SetFuncId(funcLog); } // @v11.0.2
			else if(sstreqi_ascii(buf, "log10")) { Fb.SetFuncId(funcLog10); } // @v11.0.2
			else if(sstreqi_ascii(buf, "round")) { Fb.SetFuncId(funcRound); }
			else if(sstreqi_ascii(buf, "roundup")) { Fb.SetFuncId(funcRoundUp); }
			else if(sstreqi_ascii(buf, "rounddown")) { Fb.SetFuncId(funcRoundDown); }
			else if(sstreqi_ascii(buf, "rounddn")) { Fb.SetFuncId(funcRoundDown); }
			else if(sstreqi_ascii(buf, "oid"))   { Fb.SetFuncId(funcOid); }
			else if(sstreqi_ascii(buf, "pow"))   { Fb.SetFuncId(funcPow); }
			else if(sstreqi_ascii(buf, "min"))   { Fb.SetFuncId(funcMin); }
			else if(sstreqi_ascii(buf, "minz")) { Fb.SetFuncId(funcMinZ); }
			else if(sstreqi_ascii(buf, "max"))   { Fb.SetFuncId(funcMax); }
			else if(sstreqi_ascii(buf, "?"))     { Fb.SetFuncId(funcQuest); }
			else if(sstreqi_ascii(buf, "eq"))    { Fb.SetFuncId(funcEq); }
			else if(sstreqi_ascii(buf, "neq"))   { Fb.SetFuncId(funcNEq); }
			else {
				const char * p_tagexpr_symb = "tagexpr";
				const uint tagexpr_symb_len = sstrlen(p_tagexpr_symb);
				if(sstreqni_ascii(buf, "tagexpr", tagexpr_symb_len) && buf[tagexpr_symb_len] == '.') { // @v12.0.11
					SString left, right;
					const int dr = SString(buf).Divide('.', left, right);
					assert(dr > 0);
					assert(left.IsEqiAscii(p_tagexpr_symb));
					if(dr > 0) {
						Fb.SetFuncId(funcTagExpr); 
						Fb.ExtToken = right;
					}
				} 
				else if(sstreqi_ascii(buf, "sieve")) {
					Fb.SetFuncId(funcSieve);
					THROW(GetSieve());
				}
				else {
					int    func_id = 0;
					if(P_Ctx && P_Ctx->IsFunc(buf, &func_id)) {
						Fb.SetFuncId(func_id);
					}
					else {
						Fb.SetFuncId(0);
						Name = buf;
						Token = tokName;
					}
				}
			}
			if(Fb.GetFuncId())
				Token = tokFunc;
		}
		else if(isdec(Cur) || Cur == '.') {
			int    dot = 0;
			do {
				if(Cur == '.')
					dot = 1;
				*p++ = Cur;
				Next();
			} while(isdec(Cur) || ((Cur == '.') && !dot));
			*p = 0;
			Number = satof(buf);
			Token  = tokNumber;
		}
		else if(Cur == '<') {
			if(Next() == '=') {
				Token = tokLe;
				Next();
			}
			else
				Token = '<';
		}
		else if(Cur == '>') {
			if(Next() == '=') {
				Token = tokGe;
				Next();
			}
			else
				Token = '>';
		}
		else if(Cur == '!') {
			if(Next() == '=') {
				Token = tokNe;
				Next();
			}
		}
		else if(sstrchr("*)(%/-+=,", Cur)) {
			Token = Cur;
			Next();
		}
	}
	CATCH
		Token = 0;
	ENDCATCH
	return Token;
}

int FASTCALL PPExprParser::GetFactor(double * pResult)
{
	int    ok = 1;
	int    uminus = 0;
	THROW(GetToken());
	while(oneof2(Token, '-', '+')) { // Цикл для корректной обработки любого количества подряд идущих плюсов и минусов
		if(Token == '-')
			uminus++;
		THROW(GetToken());
	}
	uminus = uminus % 2;
	switch(Token) {
		case '(':
			THROW(CalcExpr(pResult));
			THROW_PP_S(Token == ')', PPERR_INVEXPR, P_S);
			break;
		case tokNumber:
			*pResult = Number;
			break;
		case tokName:
			{
				uint16 func_id = 0;
				if(Name.IsEqiAscii("pi")) { // @v12.0.11
					*pResult = SMathConst::Pi;
				}
				else if(P_CFL && (func_id = P_CFL->SearchFuncByName(Name)) != 0) {
					StringSet params;
					char   result[64];
					size_t next_pos;
					THROW(P_CFL->ReadParams(func_id, P_S+Pos-1, &next_pos, &params));
					Pos += next_pos;
					Cur = P_S[Pos-1];
					THROW(P_CFL->CalcFunc(func_id, &params, result, sizeof(result)));
					*pResult = satof(result);
				}
				else {
					//THROW_PP(P_Ctx, PPERR_ILLVAR);
					//THROW(P_Ctx->Resolve(Name, pResult));
					THROW_PP_S(ResolveContextName(Name, pResult), PPERR_ILLVAR, Name);
				}
			}
			break;
		case tokFunc:
			{
				ExprEvalContext::FC fc;
				// @v11.3.7 (@ctr) fc.Init();
				const  int func = Fb.GetFuncId();
				size_t arg_list_offs = 0;
				double first_arg = 0.0;
				ReadArgString(fc.StrArg, &arg_list_offs);
				if(func == funcOid || (func >= EXRP_EVAL_FIRST_FUNC && P_Ctx && P_Ctx->SelfScanArgList())) {
					Pos += arg_list_offs+1;
					Cur = P_S[Pos-1];
				}
				else {
					THROW(GetToken());
					THROW_PP_S(Token == '(', PPERR_INVEXPR, P_S);
					Skip();
					if(Cur != ')') {
						do {
							double arg = 0.0;
							const int arg_n = fc.ArgList.getCount();
							THROW(CalcExpr(&arg));
							if(arg_n == 0)
								first_arg = arg;
							fc.ArgList.insert(&arg);
						} while(Token == ',');
					}
					else {
						THROW(GetToken());
					}
					THROW_PP_S(Token == ')', PPERR_INVEXPR, P_S);
				}
				const uint arg_count = fc.ArgList.getCount();
				switch(func) {
					case funcAbs:   *pResult = fabs(first_arg); break;
					case funcSqrt:  *pResult = sqrt(first_arg); break;
					case funcSin:   *pResult = sin(first_arg);  break;
					case funcCos:   *pResult = cos(first_arg);  break;
					case funcTan:   *pResult = tan(first_arg);  break;
					case funcPow:   *pResult = pow(first_arg, (arg_count > 1) ? fc.ArgList.at(1) : 1.0); break;
					case funcLog:   *pResult = log(first_arg);  break; // @v11.0.2
					case funcLog10: *pResult = log10(first_arg);  break; // @v11.0.2
					case funcRound:
						*pResult = round(first_arg, (arg_count > 1) ? static_cast<int>(fc.ArgList.at(1)) : 0);
						break;
					case funcRoundUp:
						*pResult = round(first_arg, (arg_count > 1) ? fc.ArgList.at(1) : 0.01, +1);
						break;
					case funcRoundDown:
						*pResult = round(first_arg, (arg_count > 1) ? fc.ArgList.at(1) : 0.01, -1);
						break;
					case funcEq:
						*pResult = ((arg_count == 2) && first_arg == fc.ArgList.at(1)) ? 1.0 : 0.0;
						break;
					case funcNEq:
						if(arg_count == 2)
							*pResult = (first_arg != fc.ArgList.at(1)) ? 1.0 : 0.0;
						else
							*pResult = 1.0;
						break;
					case funcMin:
						if(arg_count) {
							double t = SMathConst::Max;
							for(uint i = 0; i < arg_count; i++) {
								double v = fc.ArgList.at(i);
								SETMIN(t, v);
							}
							*pResult = (t == SMathConst::Max) ? 0.0 : t;
						}
						break;
					case funcMinZ:
						if(arg_count) {
							double t = SMathConst::Max;
							for(uint i = 0; i < arg_count; i++) {
								double v = fc.ArgList.at(i);
								if(v != 0.0) {
									SETMIN(t, v);
								}
							}
							*pResult = (t == SMathConst::Max) ? 0.0 : t;
						}
						break;
					case funcMax:
						if(arg_count) {
							double t = -SMathConst::Max;
							for(uint i = 0; i < arg_count; i++) {
								double v = fc.ArgList.at(i);
								SETMAX(t, v);
							}
							*pResult = t;
						}
						break;
					case funcQuest:
						if(first_arg != 0.0)
							*pResult = (arg_count > 1) ? fc.ArgList.at(1) : 1.0;
						else
							*pResult = (arg_count > 2) ? fc.ArgList.at(2) : 0.0;
						break;
					case funcOid:
						{
							PPObjID oid;
							SString obj_type_symb;
							SString obj_id_symb;
							uint   pos = 0;
							oid.Z();
							fc.StrArg.Strip();
							THROW_PP_S(fc.StrArg[0] == '(', PPERR_INVEXPR, P_S);
							fc.StrArg.ShiftLeft().Strip();
							THROW_PP_S(fc.StrArg.Last() == ')', PPERR_INVEXPR, P_S);
							fc.StrArg.TrimRight().Strip();
							{
								StringSet ss(',', fc.StrArg);
								THROW_PP(ss.get(&pos, obj_type_symb) && ss.get(&pos, obj_id_symb), PPERR_OIDFUNC_ARGCOUNT);
								// @v12.0.11 Пытаемся трактовать obj_id_symb как выражение {
								/*{
									if(obj_id_symb.NotEmptyS()) {
										long obj_id_as_int = obj_id_symb.ToLong();
										if(obj_id_as_int) {
											;
										}
										else {
												
										}
									}
								}*/
								// } @v12.0.11
								THROW(PPObject::Identify(obj_type_symb.Strip(), obj_id_symb.Strip(), &oid) > 0);
								*pResult = static_cast<double>(oid);
							}
						}
						break;
					case funcTagExpr: // @v12.0.11
						{
							if(arg_count >= 1) {
								PPObjID oid;
								oid.FromDouble(first_arg);
								if(Fb.ExtToken.NotEmpty()) {
									PPObjTag tag_obj;
									PPObjectTag tag_rec;
									PPID   tag_id = 0;
									THROW(tag_obj.FetchBySymb(Fb.ExtToken, &tag_id) > 0);
									THROW(tag_obj.Fetch(tag_id, &tag_rec) > 0);
									THROW(tag_rec.ObjTypeID == oid.Obj); // @todo @err
									{
										ObjTagCore & r_ot = PPRef->Ot;
										SString expr_buf;
										double local_result = 0.0;
										r_ot.GetTagStr(oid.Obj, oid.Id, tag_id, expr_buf);
										THROW(expr_buf.NotEmptyS()); // @todo @err
										THROW(PPExprParser::CalcExpression(expr_buf, &local_result, 0, P_Ctx));
										*pResult = local_result;
									}
								}
							}
						}
						break;
					case funcSieve:
						{
							long   bin_id = 0;
							*pResult = Fb.Sieve.GetBinByVal(first_arg, &bin_id) ? Fb.SieveVal.Get(bin_id) : 0.0;
						}
						break;
					default:
						CALLPTRMEMB(P_Ctx, ResolveFunc(func, fc));
						*pResult = fc.RetReal;
				}
			}
			break;
		default:
			CALLEXCEPT_PP_S(PPERR_INVEXPR, P_S);
	}
	THROW(GetToken());
	if(uminus)
		*pResult = -*pResult;
	CATCHZOK
	return ok;
}

int PPExprParser::ReadArgString(SString & rBuf, size_t * pOffs) const
{
	int    ok = 1;
	rBuf.Z();
	const size_t pos = Pos ? (Pos-1) : Pos; // Pos является указателем на символ, следующий за PPExprParser::Cur
	const char * p = &P_S[pos];
	while(oneof4(*p, ' ', '\t', '\r', '\n'))
		p++;
	if(*p == '(') {
		uint   par_count = 0;
		rBuf.CatChar('(');
		p++;
		do {
			if(*p == '(')
				++par_count;
			else if(*p == ')') {
				if(par_count)
					--par_count;
				else
					break;
			}
			rBuf.CatChar(*p++);
		} while(*p != 0);
		if(*p != ')')
			ok = 0;
		else
			rBuf.CatChar(')');
		ASSIGN_PTR(pOffs, (p - &P_S[pos]));
	}
	else
		ok = -1;
	return ok;
}

int FASTCALL PPExprParser::GetTerm(double * pResult)
{
	int    ok = 1;
	THROW(GetFactor(pResult));
	while(Token == '*' || Token == '/' || Token == '%') {
		double mult = 0.0;
		int    op   = Token;
		THROW(GetFactor(&mult));
		switch(op) {
			case '*':
				if(*pResult != 0.0)
					*pResult *= mult;
				break;
			case '/':
				*pResult = fdivnz(*pResult, mult);
				break;
			case '%':
				if(mult != 0.0)
					*pResult = static_cast<long>(*pResult) % static_cast<long>(mult);
				else
					*pResult = 0.0;
				break;
		}
	}
	CATCHZOK
	return ok;
}

static double FASTCALL quest(int condition) { return condition ? 1.0 : 0.0; }

int FASTCALL PPExprParser::CalcExpr(double * pResult)
{
	int    ok = 1;
	double result = 0.0;
	const State save_state(St); // Сохраняем текущее состояние, критичное к рекурсивному вызову CalcExpr
	THROW(GetTerm(&result));
	while(oneof8(Token, '+', '-', '<', '>', '=', tokLe, tokGe, tokNe)) {
		double add = 0.0;
		if(Token == '+' || Token == '-') {
			int    sign = (Token == '+') ? 1 : -1;
			THROW(GetTerm(&add));
			if(sign > 0)
				result += add;
			else
				result -= add;
		}
		else {
			const int tok = Token;
			//
			// Операции -, + имеют больший приоритет, чем <>=. Поэтому вызываем
			// CalcExpr вместо { GetToken(); GetTerm(&add); }
			//
			THROW(CalcExpr(&add)); // @recursion
			switch(tok) {
				case '=':   result = quest(result == add); break;
				case tokNe: result = quest(result != add); break;
				case '<':   result = quest(result <  add); break;
				case tokLe: result = quest(result <= add); break;
				case '>':   result = quest(result >  add); break;
				case tokGe: result = quest(result >= add); break;
			}
		}
	}
	CATCH
		ok = 0;
		result = 0.0;
	ENDCATCH
	St = save_state; // Восстанавливаем текущее состояние
	ASSIGN_PTR(pResult, result);
	return ok;
}
//
// GoodsContext
//
GoodsContext::Param::Param()
{
	THISZERO();
}

GoodsContext::GoodsContext(GdsClsCalcExprContext * pCtx) : ExprEvalContext()
{
	Init();
	P_ClsPack = pCtx->P_GcPack;
	P_Pack = pCtx->P_GPack;
	P_Gs = pCtx->P_GsPack;
	P_BillPack = pCtx->P_BillPack;
	P_Ti = pCtx->P_Ti;
	P_Ci = pCtx->P_Ci; // @v11.0.7 @fix
	P_TslRec = pCtx->P_TslRec;
	P.Par1 = pCtx->Par1;
	P.Par2 = pCtx->Par2;
	P.Par3 = pCtx->Par3;
	P.TSessID = pCtx->TSessID;
	P.GoodsID = pCtx->GoodsID;
	P.PrevGoodsID = pCtx->PrevGoodsID;
	if(P.TSessID)
		P_TSesObj = new PPObjTSession;
}

GoodsContext::GoodsContext(Param & rParam)
{
	Init();
	P = rParam;
}

GoodsContext::GoodsContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack) : ExprEvalContext()
{
	Init();
	P_Ti = pTi;
	P_BillPack = pBillPack;
	P.GoodsID = P_Ti ? P_Ti->GoodsID : 0;
}

GoodsContext::GoodsContext(const CCheckItem * pCi) : ExprEvalContext()
{
	Init();
	P_Ci = pCi;
	P.GoodsID = P_Ci ? P_Ci->GoodsID : 0;
}

void GoodsContext::Init()
{
	P_ClsPack = 0;
	P_Pack = 0;
	P_Gs = 0;
	P_BillPack = 0;
	P_Ti = 0;
	P_Ci = 0; // @v11.0.7 @fix
	P_TslRec = 0; // @v11.0.7
	MEMSZERO(P);
	P_TSesObj = 0;
}

GoodsContext::~GoodsContext()
{
	delete P_TSesObj;
}

const GoodsContext::Param & GoodsContext::GetParam() const
{
	return P;
}

int GoodsContext::SetParam(const GoodsContext::Param & rP)
{
    P = rP;
    return 1;
}

void GoodsContext::AllocGoodsStruc()
{
	if(!P_Gs) {
		if(P.TSessID) {
			TSessionTbl::Rec tses_rec;
			if(P_TSesObj->Search(P.TSessID, &tses_rec) > 0 && tses_rec.TechID) {
				TechTbl::Rec tec_rec;
				if(P_TSesObj->GetTech(tses_rec.TechID, &tec_rec, 1) > 0 && tec_rec.GStrucID) {
					if(GObj.GSObj.Get(tec_rec.GStrucID, &ProperGs) > 0)
						P_Gs = &ProperGs;
				}
			}
		}
		else if(P_Pack) {
			if(P_Pack->GS.Rec.ID)
				P_Gs = &P_Pack->GS;
		}
		else if(P.GoodsID) {
			Goods2Tbl::Rec goods_rec;
			if(GObj.Fetch(P.GoodsID, &goods_rec) > 0 && goods_rec.StrucID && GObj.GSObj.Get(goods_rec.StrucID, &ProperGs) > 0)
				P_Gs = &ProperGs;
		}
	}
}

/*virtual*/int GoodsContext::IsFunc(const char * pSymb, int * pFuncId)
{
	int    func_id = 0;
	SString temp_buf;
	SStrScan scan(pSymb);
	if(scan.Skip().GetIdent(temp_buf)) {
		if(temp_buf.IsEqiAscii("vat"))
			func_id = funcVat;
		else if(temp_buf.IsEqiAscii("vatplus"))
			func_id = funcVatPlus;
		else if(temp_buf.IsEqiAscii("vatminus"))
			func_id = funcVatMinus;
		else if(temp_buf.IsEqiAscii("getquot"))
			func_id = funcGetQuot;
		else if(temp_buf.IsEqiAscii("getquotcp"))
			func_id = funcGetQuotCP;
		else {
			PPSetError(PPERR_UNDEFGOODSFUNC, pSymb);
		}
	}
	ASSIGN_PTR(pFuncId, func_id);
	return BIN(func_id);
}

int GoodsContext::ResolveFunc(int funcId, FC & rFc)
{
	double result = 0.0;
	double arg = rFc.ArgList.getCount() ? rFc.ArgList.at(0) : 0.0;
	Goods2Tbl::Rec goods_rec;
	if(funcId == funcVat) {
		int with_vat = (rFc.ArgList.getCount() > 1) ? static_cast<int>(rFc.ArgList.at(1)) : 0;
		if(GObj.Fetch(P.GoodsID, &goods_rec) > 0) {
			GObj.CalcCostVat(0, goods_rec.TaxGrpID, ZERODATE, 1.0, arg, &result, !with_vat, 0);
		}
	}
	else if(funcId == funcVatPlus) {
		if(GObj.Fetch(P.GoodsID, &goods_rec) > 0) {
			GObj.CalcCostVat(0, goods_rec.TaxGrpID, ZERODATE, 1.0, arg, &result, 1, 0);
			result += arg;
		}
		else
			result = arg;
	}
	else if(funcId == funcVatMinus) {
		if(GObj.Fetch(P.GoodsID, &goods_rec) > 0) {
			GObj.CalcCostVat(0, goods_rec.TaxGrpID, ZERODATE, 1.0, arg, &result, 0, 0);
			result = arg - result;
		}
		else
			result = arg;
	}
	else if(oneof2(funcId, funcGetQuot, funcGetQuotCP)) {
		PPID   qk_id = 0;
		PPID   cur_id = 0;
		PPID   ar_id = 0;
		PPID   loc_id = 0;
		int    loc_arg_defined = 0;
		uint   cn = 0;
		double cost  = P_Ti ? P_Ti->Cost  : 0.0;
		double price = P_Ti ? P_Ti->Price : 0.0;
		for(uint i = 0; i < rFc.ArgList.getCount(); i++) {
			const double arg = rFc.ArgList.at(i);
			PPObjID_Base oid;
			oid = arg;
			switch(oid.Obj) {
				case PPOBJ_QUOTKIND: SETIFZ(qk_id, oid.Id); break;
				case PPOBJ_CURRENCY: SETIFZ(cur_id, oid.Id); break;
				case PPOBJ_LOCATION: SETIFZ(loc_id, oid.Id); loc_arg_defined = 1; break;
				case PPOBJ_ARTICLE:  SETIFZ(ar_id, oid.Id); break;
				default:
					if(funcId == funcGetQuotCP) {
						if(cn == 0)
							cost = arg;
						else if(cn == 1)
							price = arg;
					}
					cn++;
					break;
			}
		}
		if(qk_id) {
			if(!loc_arg_defined) {
				SETIFZ(loc_id, P_BillPack ? P_BillPack->Rec.LocID : P.LocID);
			}
			SETIFZ(cur_id, P_BillPack ? P_BillPack->Rec.CurID : P.CurID);
			SETIFZ(ar_id, P_BillPack ? P_BillPack->Rec.Object : P.ArID);
			GObj.GetQuotExt(P.GoodsID, QuotIdent(QIDATE(getcurdate_()), loc_id, qk_id, cur_id, ar_id), cost, price, &result, 0);
		}
	}
	rFc.RetType = T_DOUBLE;
	rFc.RetReal = result;
	return 1;
}

int GoodsContext::IsRef(const char * pStr, size_t * pPos, SString & rRef)
{
	size_t pos = *pPos;
	SString temp_buf;
	if(isalpha(pStr[pos]) || pStr[pos] == '_' || pStr[pos] == '@') do {
		temp_buf.CatChar(pStr[pos++]);
	} while(isasciialnum(pStr[pos]) || pStr[pos] == '_'); // @v11.4.9 isalnum-->isasciialnum
	if(pStr[pos] == '.') {
		pos++;
		ASSIGN_PTR(pPos, pos);
		rRef = temp_buf;
		return 1;
	}
	else
		return 0;
}

int GoodsContext::ResolveRefQtty(PPID goodsID, int cbItemRef, int isPhQtty, double * pVal)
{
	int    ok = 1;
	double v = 0.0;
	if(goodsID) {
		// @v11.0.7 {
		if(P_TslRec) {
			if(isPhQtty) {
				double phqtty = 0.0;
				if(P_TslRec->Flags & TSESLF_INDEPPHQTTY)
					phqtty = P_TslRec->WtQtty;
				else if(P_TslRec->Flags & TSESLF_PLAN_PHUNIT)
					phqtty = P_TslRec->Qtty;
				else {
					double phuperu = 0.0;
					GObj.GetPhUPerU(P_TslRec->GoodsID, 0, &phuperu);
					phqtty = P_TslRec->Qtty * phuperu;
				}
				v = phqtty;
			}
			else {
				v = P_TslRec->Qtty;
			}
		}
		// } @v11.0.7 
		else if(P.TSessID) {
			SETIFZ(P_TSesObj, new PPObjTSession);
			TSessGoodsTotal tsgt;
			THROW(P_TSesObj->P_Tbl->CalcGoodsTotal(P.TSessID, goodsID, &tsgt));
			v = isPhQtty ? tsgt.PhQtty : tsgt.Qtty;
		}
		else if(cbItemRef >= 0 && P_Gs && P_Gs->P_Cb) {
			const ComplItem * p_ci = 0;
			if(cbItemRef == 0)
				p_ci = &P_Gs->P_Cb->Head;
			else if(cbItemRef <= static_cast<int>(P_Gs->P_Cb->getCount()))
				p_ci = &P_Gs->P_Cb->at(cbItemRef-1);
			if(p_ci) {
				if(isPhQtty) {
					// @todo
				}
				else {
					v = fabs(p_ci->NeedQty);
				}
			}
		}
		else if(P_BillPack) {
            for(uint i = 0; i < P_BillPack->GetTCount(); i++) {
				const PPTransferItem & r_ti = P_BillPack->ConstTI(i);
				if(labs(r_ti.GoodsID) == labs(goodsID)) {
					if(isPhQtty) {
						// @todo
					}
					else {
						v += fabs(r_ti.Qtty());
					}
				}
            }
		}
		else {
			v = P.Qtty;
		}
	}
	CATCHZOK
	ASSIGN_PTR(pVal, v);
	return ok;
}

int GoodsContext::ResolveGoodsAttr(const SString & rSymb, PPID goodsID, double * pVal)
{
	int    ok = 1;
	int    ref_dim = 0;
	Goods2Tbl::Rec goods_rec;
	double v = 0.0;
	if(rSymb.IsEqiAscii("X")) ref_dim = PPGdsCls::eX;
	else if(rSymb.IsEqiAscii("Y")) ref_dim = PPGdsCls::eY;
	else if(rSymb.IsEqiAscii("Z")) ref_dim = PPGdsCls::eZ;
	else if(rSymb.IsEqiAscii("W")) ref_dim = PPGdsCls::eW;
	else if(rSymb.IsEqiAscii("KIND")) ref_dim = PPGdsCls::eKind;
	else if(rSymb.IsEqiAscii("GRADE")) ref_dim = PPGdsCls::eGrade;
	else if(rSymb.IsEqiAscii("ADDPROP2")) ref_dim = PPGdsCls::eAdd;
	else if(rSymb.IsEqiAscii("ADDPROP")) ref_dim = PPGdsCls::eAdd2;
	else if(rSymb.IsEqiAscii("PHUPERU")) {
		if(GObj.Fetch(goodsID, &goods_rec) > 0)
			v = goods_rec.PhUPerU;
		else if(P_Pack)
			v = P_Pack->Rec.PhUPerU;
	}
	else if(rSymb.IsEqiAscii("DENSITY")) { // @v12.0.10
		// Переменная density работает следующим образом: перебираются перечисляемые компоненты класса товаров (kind, grade, addprop, addprop2),
		// если какой-либо из этих компонентов ссылается на тип объекта "сырьевые материалы" (PPOBJ_RAWMATERIAL), то для товара
		// извлекается соответствующее свойство и плотность материала трактуется как результат переменной.
		// Если целевое свойство не найдено, то возвращается 0.0
		double local_result = 0.0;
		const PPGdsClsPacket * p_local_gc_pack = 0;
		const GoodsExtTbl::Rec * p_local_ge_rec = 0;
		PPGdsClsPacket gc_pack;
		GoodsExtTbl::Rec ge_rec;
		if(goodsID) {
			if(GObj.FetchCls(goodsID, &goods_rec, &gc_pack) > 0) {
				p_local_gc_pack = &gc_pack;
				if(GObj.P_Tbl->GetExt(goodsID, &ge_rec) > 0)
					p_local_ge_rec = &ge_rec;
			}
		}
		else {
			p_local_gc_pack = P_ClsPack;
			if(P_Pack)
				p_local_ge_rec = &P_Pack->ExtRec;
		}
		if(p_local_gc_pack && p_local_ge_rec) {
			const int local_dim_ref_list[] = {PPGdsCls::eKind, PPGdsCls::eGrade, PPGdsCls::eAdd, PPGdsCls::eAdd2};
			for(uint i = 0; i < SIZEOFARRAY(local_dim_ref_list); i++) {
				PPObjID oid;
				switch(local_dim_ref_list[i]) {
					case PPGdsCls::eKind : oid.Set(p_local_gc_pack->PropKind.ItemsListID, p_local_ge_rec->KindID); break;
					case PPGdsCls::eGrade: oid.Set(p_local_gc_pack->PropGrade.ItemsListID, p_local_ge_rec->GradeID); break;
					case PPGdsCls::eAdd  : oid.Set(p_local_gc_pack->PropAdd.ItemsListID, p_local_ge_rec->AddObjID); break;
					case PPGdsCls::eAdd2 : oid.Set(p_local_gc_pack->PropAdd2.ItemsListID, p_local_ge_rec->AddObj2ID); break;
				}
				if(oid.Obj == PPOBJ_RAWMATERIAL) {
					if(oid.Id) {
						PPObjRawMaterial rawm_obj;
						PPRawMaterial rawm_rec;
						if(rawm_obj.Search(oid.Id, &rawm_rec) > 0)
							local_result = rawm_rec.Density;
					}
					break;
				}
			}
		}
		v = local_result;
	}
	else if(rSymb.IsEqiAscii("TYPE")) {
		PPID   goods_type = (GObj.Fetch(goodsID, &goods_rec) > 0) ? goods_rec.GoodsTypeID : 0;
		PPObjID oid;
		v = (double)oid.Set(PPOBJ_GOODSTYPE, goods_type);
	}
	else if(rSymb.IsEqiAscii("ID"))
		v = goodsID;
	else
		ok = 0;
	if(ref_dim) {
		PPObjID oid;
		if(goodsID) {
			PPGdsClsPacket gc_pack;
			if(GObj.FetchCls(goodsID, &goods_rec, &gc_pack) > 0) {
				GoodsExtTbl::Rec ge_rec;
				if(GObj.P_Tbl->GetExt(goodsID, &ge_rec) > 0) {
					switch(ref_dim) {
						case PPGdsCls::eKind : v = static_cast<double>(oid.Set(gc_pack.PropKind.ItemsListID, ge_rec.KindID)); break;
						case PPGdsCls::eGrade: v = static_cast<double>(oid.Set(gc_pack.PropGrade.ItemsListID, ge_rec.GradeID)); break;
						case PPGdsCls::eAdd  : v = static_cast<double>(oid.Set(gc_pack.PropAdd.ItemsListID, ge_rec.AddObjID)); break;
						case PPGdsCls::eAdd2 : v = static_cast<double>(oid.Set(gc_pack.PropAdd2.ItemsListID, ge_rec.AddObj2ID)); break;
						default:
							gc_pack.GetExtDim(&ge_rec, ref_dim, &v);
							break;
					}
				}
			}
		}
		else if(P_ClsPack && P_Pack) {
			switch(ref_dim) {
				case PPGdsCls::eKind : v = static_cast<double>(oid.Set(P_ClsPack->PropKind.ItemsListID, P_Pack->ExtRec.KindID)); break;
				case PPGdsCls::eGrade: v = static_cast<double>(oid.Set(P_ClsPack->PropGrade.ItemsListID, P_Pack->ExtRec.GradeID)); break;
				case PPGdsCls::eAdd  : v = static_cast<double>(oid.Set(P_ClsPack->PropAdd.ItemsListID, P_Pack->ExtRec.AddObjID)); break;
				case PPGdsCls::eAdd2 : v = static_cast<double>(oid.Set(P_ClsPack->PropAdd2.ItemsListID, P_Pack->ExtRec.AddObj2ID)); break;
				default:
					P_ClsPack->GetExtDim(&P_Pack->ExtRec, ref_dim, &v);
					break;
			}
		}
	}
	ASSIGN_PTR(pVal, v);
	return ok;
}

int GoodsContext::Resolve(const char * pSymb, double * pVal)
{
	int    ok = 1;
	int    prev_goods_prefix = 0;
	double v = 0.0;
	SString ref;
	if(!ResolveGoodsAttr(ref = pSymb, P_Pack ? 0 : P.GoodsID, &v)) {
		size_t pos = 0;
		if(IsRef(pSymb, &pos, ref.Z())) {
			enum {
				spcrefQuot = 1,
				spcrefLotTag,
				spcrefGoodsTag,
				spcrefGcFormula // @v12.0.11
			};
			int    spcref = 0;
			int    ref_dim = 0;
			PPID   ref_goods_id = 0;
			int    ref_gscb_item = -1;
			int    ref_gs_item_idx = -1;
			const  PPGoodsStrucItem * p_ref_gs_item = 0;
			if(ref.IsEqiAscii("MAIN")) {
				AllocGoodsStruc();
				THROW_PP_S(P_Gs, PPERR_INVEXPRCTX_GS, pSymb);
				ref_goods_id = P_Gs->GoodsID;
				if(P_Gs->P_Cb)
					ref_gscb_item = 0;
			}
			else if(ref.IsEqiAscii("MAINCOM")) {
				const PPGoodsStrucItem * p_gsi = 0;
				AllocGoodsStruc();
				THROW_PP_S(P_Gs, PPERR_INVEXPRCTX_GS, pSymb);
				{				
					uint   gs_item_idx = 0;
					THROW(p_gsi = P_Gs->GetMainItem(&gs_item_idx));
					ref_gs_item_idx = static_cast<int>(gs_item_idx);
					p_ref_gs_item = p_gsi; // @v12.3.7
				}
				ref_goods_id = p_gsi->GoodsID;
				if(P_Gs->P_Cb) {
					for(uint i = 0; ref_gscb_item < 0 && i < P_Gs->P_Cb->getCount(); i++) {
						const ComplItem & r_ci = P_Gs->P_Cb->at(i);
						if(r_ci.GsiFlags & GSIF_MAINITEM)
							ref_gscb_item = i+1;
					}
				}
			}
			else if(ref.IsEqiAscii("PREV"))
				ref_goods_id = P.PrevGoodsID;
			else if(ref.IsEqiAscii("QUOT"))
				spcref = spcrefQuot;
			else if(ref.IsEqiAscii("LOTTAG"))
				spcref = spcrefLotTag;
			else if(ref.IsEqiAscii("TAG"))
				spcref = spcrefGoodsTag;
			else if(ref.IsEqiAscii("GCFORMULA")) // @v12.0.11
				spcref = spcrefGcFormula;
			else {
				AllocGoodsStruc();
				if(P_Gs) {
					uint   gs_pos = 0;
					BarcodeTbl::Rec bc_rec;
					//
					// Сначала выясняем, не является ли ссылка кодом элемента структуры
					//
					if(P_Gs->SearchSymb(ref, &gs_pos) > 0) {
						ref_gs_item_idx = static_cast<int>(gs_pos);
						p_ref_gs_item = &P_Gs->Items.at(gs_pos); // @v12.3.7
						ref_goods_id = p_ref_gs_item->GoodsID;
						if(P_Gs->P_Cb) {
							for(uint i = 0; ref_gscb_item < 0 && i < P_Gs->P_Cb->getCount(); i++) {
								const ComplItem & r_ci = P_Gs->P_Cb->at(i);
								if(r_ci.SrcGsPos == (gs_pos+1))
									ref_gscb_item = i+1;
							}
						}
					}
					//
					// Ссылка может являться кодом товара
					//
					else if(GObj.P_Tbl->SearchBarcode(ref, &bc_rec) > 0) {
						ref_goods_id = bc_rec.GoodsID;
					}
					else {
						SString ref2;
						//
						// Возможно, ссылка является кодом группы
						//
						ref2.CatChar('@').Cat(ref);
						if(GObj.P_Tbl->SearchBarcode(ref2, &bc_rec) > 0)
							ref_goods_id = bc_rec.GoodsID;
						//
						// Ничего не помогает: ссылка не может быть разрешена
						//
						else {
							CALLEXCEPT_PP_S(PPERR_INVEXPRREF, ref);
						}
					}
				}
				else {
					CALLEXCEPT_PP_S(PPERR_INVEXPRREF, ref);
					//THROW_PP_S(P_Gs, PPERR_INVEXPRCTX_GS, pSymb);
				}
			}
			ref = pSymb+pos;
			if(spcref == spcrefQuot) {
				PPObjQuotKind qk_obj;
				PPID   qk_id = 0;
				THROW(qk_obj.SearchSymb(&qk_id, ref) > 0);
				{
					const double cost  = P_Ti ? P_Ti->Cost  : 0.0;
					const double price = P_Ti ? P_Ti->Price : (P_Ci ? P_Ci->Price : 0.0);
					const PPID   loc_id = P_BillPack ? P_BillPack->Rec.LocID : P.LocID;
					const PPID   cur_id = P_BillPack ? P_BillPack->Rec.CurID : P.CurID;
					const PPID   ar_id  = P_BillPack ? P_BillPack->Rec.Object : P.ArID;
					const LDATE  _dt = P_BillPack ? P_BillPack->Rec.Dt : getcurdate_();
					GObj.GetQuotExt(P.GoodsID, QuotIdent(QIDATE(_dt), loc_id, qk_id, cur_id, ar_id), cost, price, &v, 0);
				}
			}
			else if(spcref == spcrefLotTag) {
				PPObjBill * p_bobj = BillObj;
				PPObjTag tag_obj;
				PPID   tag_id = 0;
				ObjTagList tag_list;
				const ObjTagItem * p_tag_item = 0;
				THROW(tag_obj.SearchBySymb(ref, &tag_id, 0) > 0);
				if(P_Ti) {
					if(P_BillPack) {
						int    row_pos = static_cast<int>(P_BillPack->GetTPointer());
						ObjTagList * p_tag_list = P_BillPack->LTagL.Get(row_pos);
						p_tag_item = p_tag_list ? p_tag_list->GetItem(tag_id) : 0;
					}
					else if(P_Ti->LotID) {
						p_bobj->GetTagListByLot(P_Ti->LotID, 0, &tag_list);
						p_tag_item = tag_list.GetItem(tag_id);
					}
				}
				else if(P.LotID) { // @v11.1.12
					p_bobj->GetTagListByLot(P.LotID, 0, &tag_list);
					p_tag_item = tag_list.GetItem(tag_id);
				}
				CALLPTRMEMB(p_tag_item, GetReal(&v));
			}
			else if(spcref == spcrefGoodsTag) {
				PPObjTag tag_obj;
				PPID   tag_id = 0;
				THROW(tag_obj.SearchBySymb(ref, &tag_id, 0) > 0);
				{
					ObjTagItem tag_item;
					if(PPRef->Ot.GetTag(PPOBJ_GOODS, P.GoodsID, tag_id, &tag_item) > 0)
						tag_item.GetReal(&v);
				}
			}
			else if(spcref == spcrefGcFormula) { // @v12.0.11
				const PPGdsClsPacket * p_local_gc_pack = 0;
				PPGdsClsPacket gc_pack;
				if(P_ClsPack)
					p_local_gc_pack = P_ClsPack;
				else if(P.GoodsID) {
					Goods2Tbl::Rec goods_rec;
					if(GObj.FetchCls(P.GoodsID, &goods_rec, &gc_pack) > 0) {
						p_local_gc_pack = &gc_pack;
					}
				}
				if(p_local_gc_pack) {
					PPGdsClsFormula f;
					THROW(p_local_gc_pack->GetFormulaBySymb(ref, &f));
					if(f.Formula.NotEmpty()) {
						double local_result = 0.0;
						THROW(PPExprParser::CalcExpression(f.Formula, &local_result, 0, this));
						v = local_result;
					}
				}
			}
			else if(ref.IsEqiAscii("QTTY") || ref.IsEqiAscii("QTY")) {
				THROW(ResolveRefQtty(ref_goods_id, ref_gscb_item, 0, &v));
			}
			else if(ref.IsEqiAscii("PHQTTY") || ref.IsEqiAscii("PHQTY")) {
				THROW(ResolveRefQtty(ref_goods_id, ref_gscb_item, 1, &v));
			}
			else if(ref.IsEqiAscii("VALUE")) { // @v12.3.7 Значение в элементе структуры
				if(P_Gs && p_ref_gs_item) {
					assert(ref_gs_item_idx >= 0 && ref_gs_item_idx < P_Gs->Items.getCountI());
					if(P_Gs->GetKind() == PPGoodsStruc::kPricePlanning) {
						double local_result = 0.0;
						if(P_Gs->GetItemValue(ref_gs_item_idx, 0, &local_result)) {
							v = local_result;
						}
					}
				}
			}
			else if(ref.IsEqiAscii("QTTYCOM")) {
				AllocGoodsStruc();
				THROW_PP_S(P_Gs, PPERR_INVEXPRCTX_GS, pSymb);
				THROW(P_Gs->GetItemQtty(ref_goods_id, 1, &v));
			}
			else {
				THROW_PP_S(ResolveGoodsAttr(ref, ref_goods_id, &v), PPERR_INVEXPRVAR, ref)
			}
		}
		else {
			ref = pSymb;
			if(ref.IsEqiAscii("pi"))
				v = SMathConst::Pi;
			else if(ref.IsEqiAscii("a1"))
				v = P.Par1;
			else if(ref.IsEqiAscii("a2"))
				v = P.Par2;
			else if(ref.IsEqiAscii("a3"))
				v = P.Par3;
			else {
				int    r = 1;
				if(ref.IsEqiAscii("cost")) {
					if(P_Ti)
						v = P_Ti->Cost;
					else if(P.Flags & P.fCostSettled)
						v = P.Cost;
					else
						r = 0; // cost может быть суммой документа
				}
				else if(ref.IsEqiAscii("price")) {
					if(P_Ti)
						v = P_Ti->Price;
					else if(P_Ci)
						v = P_Ci->Price;
					else if(P.Flags & P.fPriceSettled)
						v = P.Price;
					else
						r = 0; // price может быть суммой документа
				}
				else if(ref.IsEqiAscii("discount")) {
					if(P_Ti)
						v = P_Ti->Discount;
					else if(P_Ci)
						v = P_Ci->Discount;
					else
						r = 0; // discount может быть суммой документа
				}
				else if(ref.IsEqiAscii("QTTY") || ref.IsEqiAscii("QTY")) {
					if(P_Ti)
						v = P_Ti->Quantity_;
					else if(P_TslRec)
						v = P_TslRec->Qtty;
					else
						v = P.Qtty;
				}
				else if(ref.IsEqiAscii("PHQTTY") || ref.IsEqiAscii("PHQTY")) {
					if(P_Ti) {
						if(P_Ti->Flags & PPTFR_INDEPPHQTTY)
							v = P_Ti->WtQtty;
						else {
							PPID   ph_unit_id = 0;
							double phuperu = 0.0;
							GObj.GetPhUPerU(P_Ti->GoodsID, &ph_unit_id, &phuperu);
							v = P_Ti->Quantity_ * phuperu;
						}
					}
					else if(P_TslRec) {
						if(P_TslRec->Flags & TSESLF_INDEPPHQTTY)
							v = P_TslRec->WtQtty;
						else if(P_TslRec->Flags & TSESLF_PLAN_PHUNIT)
							v = P_TslRec->Qtty;
						else {
							double phuperu;
							GObj.GetPhUPerU(P_TslRec->GoodsID, 0, &phuperu);
							v = P_TslRec->Qtty * phuperu;
						}
					}
					else
						v = 0.0;
				}
				else if(ref.IsEqiAscii("LOTDIMX"))
                    v = P.LotDim.X;
				else if(ref.IsEqiAscii("LOTDIMY"))
					v = P.LotDim.Y;
				else if(ref.IsEqiAscii("LOTDIMZ"))
					v = P.LotDim.Z;
				else
					r = 0;
				if(!r) {
					SString form;
					PPID   id = 0;
					BillSymbCache * p_cache = GetDbLocalCachePtr <BillSymbCache> (PPOBJ_BILLSYMB);
					THROW((r = p_cache->Fetch(ref, &id, form)) > 0);
					THROW_PP_S(r == 2, PPERR_INVEXPRREF, pSymb);
					THROW(PPExprParser::CalcExpression(form, &v, 0, this));
				}
			}
		}
	}
	CATCHZOK
	ASSIGN_PTR(pVal, v);
	return ok;
}
//
//
//
int PPCalcExpression(const char * pStr, double * pResult, const PPCalcFuncList * pCFL)
{
	return PPExprParser::CalcExpression(pStr, pResult, pCFL, 0);
}

int PPCalcExpression(const char * pStr, double * pResult, PPBillPacket * pPack, PPID curID, uint advItemIdx)
{
	int    ok = 1;
	BillContext * p_ctx = 0;
	PPOprKind op_rec;
	if(pPack && GetOpType(pPack->Rec.OpID, &op_rec) == PPOPT_ACCTURN && op_rec.SubType == OPSUBT_ACCWROFF) {
		DL2_Resolver dl200r;
		DateRange period;
		p_ctx = new BillContext(pPack, curID, advItemIdx);
		dl200r.SetPeriod(period.Set(pPack->Rec.PeriodLow, pPack->Rec.PeriodUpp));
		dl200r.SetCurArticle(advItemIdx);
		DL200_Context ctx_dl200(&dl200r, p_ctx);
		ok = PPExprParser::CalcExpression(pStr, pResult, 0, &ctx_dl200);
	}
	else {
		p_ctx = pPack ? new BillContext(pPack, curID, advItemIdx) : static_cast<BillContext *>(0);
		ok = PPExprParser::CalcExpression(pStr, pResult, 0, p_ctx);
	}
	delete p_ctx;
	return ok;
}
//
//
//
GdsClsCalcExprContext::GdsClsCalcExprContext(const PPGdsClsPacket * pGcPack, const PPGoodsPacket * pGPack)
{
	THISZERO();
	P_GcPack = pGcPack;
	P_GPack = pGPack;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(const PPGoodsStruc * pGs, PPID sessID)
{
	THISZERO();
	P_GsPack = pGs;
	TSessID = sessID;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(const PPGoodsStruc * pGs, const PPBillPacket * pBillPack)
{
	THISZERO();
	P_GsPack = pGs;
	P_BillPack = pBillPack;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(PPID goodsID, PPID prevGoodsID)
{
	THISZERO();
	GoodsID = goodsID;
	PrevGoodsID = prevGoodsID;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack)
{
	THISZERO();
	P_Ti = pTi;
	P_BillPack = pBillPack;
	GoodsID = P_Ti ? P_Ti->GoodsID : 0;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(const CCheckItem * pCi) // @v10.7.6
{
	THISZERO();
	P_Ci = pCi;
	GoodsID = P_Ci ? P_Ci->GoodsID : 0;
}

GdsClsCalcExprContext::GdsClsCalcExprContext(const TSessLineTbl::Rec * pTslRec) // @v11.0.7
{
	THISZERO();
	P_TslRec = pTslRec;
	GoodsID = P_TslRec ? P_TslRec->GoodsID : 0;
	TSessID = P_TslRec ? P_TslRec->TSessID : 0;
}

int PPCalcExpression(const char * pStr, double * pResult, GdsClsCalcExprContext * pCtx)
{
	GoodsContext * p_ctx = (pCtx && (pCtx->P_GPack || pCtx->P_GsPack ||
		(pCtx->GoodsID && (pCtx->PrevGoodsID || pCtx->P_Ti || pCtx->P_Ci || pCtx->P_TslRec)))) ? new GoodsContext(pCtx) : static_cast<GoodsContext *>(0);
	if(p_ctx && pCtx->P_LotRec) {
		GoodsContext::Param param(p_ctx->GetParam());
		param.Cost = pCtx->P_LotRec->Cost;
		param.Price = pCtx->P_LotRec->Price;
		param.LotID = pCtx->P_LotRec->ID;
		param.Flags |= (GoodsContext::Param::fCostSettled|GoodsContext::Param::fPriceSettled);
		p_ctx->SetParam(param);
	}
	int    ok = PPExprParser::CalcExpression(pStr, pResult, 0, p_ctx);
	delete p_ctx;
	return ok;
}

#if SLTEST_RUNNING // {

/*SLTEST_R(PPExprParser__)
{
	const double tolerance = 1.0e-14;

	SEnum en = EnumTab(GetTestName());
	THROW(en);
	{
		SString left, right;
		SString msg_buf;
		STab::Row row;
		while(en.Next(&row)) {
			double v_left = 0.0;
			double v_right = 0.0;
			row.Get(0, left = 0);
			row.Get(1, right = 0);
			if(left.NotEmptyS() || right.NotEmptyS()) {
				SLCHECK_NZ(PPExprParser::CalcExpression(left, &v_left, 0, 0));
				SLCHECK_NZ(PPExprParser::CalcExpression(right, &v_right, 0, 0));
				SLCHECK_EQ_TOL(v_left, v_right, tolerance);
			}
		}
	}
	CATCH
		CurrentStatus = 0;
	ENDCATCH
	return CurrentStatus;
}*/

#endif // } SLTEST_RUNNING
