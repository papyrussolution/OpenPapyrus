// PP.H
// Copyright (c) A.Sobolev 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025
// @codepage UTF-8
//
// Спасибо за проделанную работу (Thanks for the work you've done):
//   Ефимову Сергею
//   Насонову Вадиму (VADIM)
//   Стародубу Антону (AHTOXA)
//   Казакову Михаилу (Muxa)
//   Миллер Владиславе (vmiller)
//   Осолоткину Алексею [rip]
//   Антонову Валерию
//   Симанову Александру [rip]
//   Курилову Андрею (Andrew)
//   Кретову Алексею
//   Ванаг Светлане
//   Родькиной Алене
//   Поценковскоей Элине
//   Соболеву Эрику
//   Егорову Геннадию Николаевичу [rip]
//
//  Соглашение об обозначениях:
//
//  @v9.99.99 - номер версии, в которой добавлена или изменена строка. Набор строк, измененных в
//  в этой версии обрамляется так:
//  // @v9.99.99 {
//  ...
//  // } @v9.99.99
//
//  @<<FunctionName - имя функции, которая вызывает ту функцию, которая помечена этим обозначением
//	  Обычно это обозначение следует строкой ниже объявления функции, к которой относится //
//
//  @>>FunctionName - имя функции, которую вызывает та функция, которая помечена этим обозначением
//	  Обычно это обозначение следует строкой ниже объявления функции, к которой относится //
//
//  @attention - комментарии, учет которых крайне важен для корректного функционирования системы
//
//  @global - глобальные переменные. Критичны для многопоточного испольнения. Если за этим обозначением
//    следует @threadsafe, то в программном коде приняты меры для того, чтобы эта переменная //
//    была безопасна для многопоточного исполнения.
//
// @transient - этим признаком помечаются флаги, поля структур, сами структуры, которые не сохраняются //
//    в базе данных или в каких-либо файлах. Признак контекстно-зависимый: используется тогда, когда
//    в контексте какого-либо содержания необходимо подчеркнуть, что некоторый объект не будет
//    сохраняться в базе данных или файле передачи данных.
// @flat - помечаются структуры, которые обязательно должны быть "плоскими". То есть не иметь в своем
//    составе указателей, и сложных объектов.
//    Обращаю внимание на то, что в связи с частичным переходом с SArray на SVector данный признак
//    становится очень важным (SVector не следует использовать над множеством non-flat объектов из-за
//    отсутствия механизма разрушения элементов).
// @persistent - этим признаком помечаются структуры, которые сохраняются в базе данных или
//    в каком-либо файле. Признак контекстно-зависимый.
// @used FunctionName | ClassName - имя функции или класса, использующего переменную или класс,
//    которые помечены этим признаком
// @cstr - помечаются строки кода, использующие строковые константы, которые должны находится в ресурсах
//
// @# - Строгое утверждение, которое должно выполняться //
//      далее могут следовать следующие формальные обозначения:
//        vptr      - допустимый указатель
//        vptr0     - допустимый указатель или нулевой указатель.
//        !0        - не ноль
//        val1^val2 - значения val1 и val2 являются взаимоисключающими
//        low..upp  - диапазон допустимых значений (включая границы)
//
// @novtbl - помечаются структуры и классы, которые не имеют и не должны иметь виртуальных
//      функций. В том числе не могут быть порождены от классов с виртуальными функциями.
//      Специальный акцент на этом моменте делается из-за потенциальной опасности обнуления
//      всей структуры целиком, что повлечет разрушение указателя на таблицу виртуальных функций.
// @noctr - помечаются структуры и классы не имеющие и не могущие иметь конструктора.
//      Пометка важна в случаях, когда структура может входить в union. В этом случае компилятор
//      (возможно, не любой) выдает ошибку.
// @nointeract - признак, означающий, что функция или класс никак не взаимодействуют
//      с пользователем. В том числе не выдают никаких сообщений или предупреждений
//      Этот признак следует учитывать, принимая решение о том, следует ли после ошибочного
//      завершения функции вызывать PPError().
//      Если этот признак определен для класса, то ни один из методов класса не является //
//      интерактивным.
// @dbd_exchange - помечаются позиции, ввод в действие которых отложен из-за невозможности
//      изменить формат обмена данными между разделами
// @ta - транзактивная функция. Внутри функции безусловно вызывается транзакция обработки данных.
//      Этот признак следует выставлять для того, чтобы вызывающая функция не пыталась
//      вызывать такую функцию внутри транзакции.
// @wota - транзактивная функция. Внутри функции не вызывается транзакция обработки данных, но
//      функция должна обрамляться транзакцией посколько в ней используются методы изменения базы данных.
//      Такая особенность может применяться только для локально используемых helper-функций.
// @*  - обозначает функцию или класс, инициализирующие поле. Например:
//     struct Foo {
//        int Setup();
//        double M; // @*Foo::Setup
//     };
// @cs   - функция вызывает локальную критическую секцию
// @temp - временный участок кода. После этого обозначения может следовать период действия //
//     Example:
//     // @temp(..31/12/2005) {
//     ... // Этот участок кода после 31/12/2005 должен быть удален
//     // } @temp
// @recursion - функция вызывается рекурсивно
// @memleak   - не устраненный источник утечки памяти
// @internal  - поле или флаг используется только для внутренний потребностей.
//    !Запрещена публикация этого поля (флага) во внешних описаниях и интерфейсах!
// @anchor    - поле структуры, к положению и (или) размеру которого в исходном коде
//    существует привязка. Следует быть крайне аккуратным при изменении типа и положения этого поля.
// @temptest  - помечаются участки кода, которые оставляются на некоторое время для автоматического
//    тестирования. Следует освобождать от проверки спустя не менее трех месяцев с момента установки //
// @stypeset  - помечаются участки кода, где не полностью учтен набор типов данных STYPE
// @sfu-r     - временная пометка для вызовов updateRec и updateRecBuf означающая, что
//              предварительный вызов search приведен к searchForUpdate
// @speedcritical - пометка, означающая, что код введен ради ускорения критичной по времени исполнения функции
// @fastreuse     - помечаются члены классов, используемые лишь для повторного использования результатов
//                  вычислений или какой-то иной медленной операции.
// @allocreuse    - помечаются члены классов, используемые как временные буферы
//                  для предотвращения повторного распределения памяти с целью ускорения исполнения функций.
// @ambiguity     - обозначает наличие неоднозначности или проверку на неоднозначность чего-либо (по контексту)
// @redundant     - обозначает избыточный код (иногда как аргументация комментария)
// @fallthrough   - помечаются варианты switch {case} для подтверждения, что отсутствие break - не ошибка.
// @macrow        - специальная пометка рядом с декларацией функции, означающая, что ее определение обернуто в макрос
//                  (для того, чтобы программиста не смущала неспособность слишком "умной" IDE найти это определение)
// @firstmember   - Помечается переменная-член структуры (класса), местонахождение которой на первой позиции
//                  экспериментально обосновано.
// @funcdef       - Помечаются typedef-определения функций.
// @default-only-switch - помечаются корректировки в сторонних модулях с целью избежать предупреждения компилятора
//                  о том, что switch-statement содержит лишь default-компонент.
// @x64crit       - Помечаются участки кода, требующие пересмотра для правильной работы в 64-разрядном варианте сборки
// @ctr           - Помечаются закомментированные участки кода причиной закрытия которых стал ввод конструктора для соответствующего объекта
//
// @todo Повторная загрузка на асинхронный узел всех объектов, начиная с заданной записи журнала загрузки
// @todo В примитивы бизнес-показателей добавить фильтрацию по группам
// @todo Конвертация CpTransf с целью уменьшения размера структуры
//       @done @todo Перенос Account в Reference2
//       @done @todo Перенос BankAccount в одну из общих таблиц (пока не совсем ясно куда и как)
// @todo Добавить в стуктуры оплаты по чеку валюту
//
//
#ifndef __PP_H // {
#define __PP_H

#define SLIB_INCLUDE_CPPSTDLIBS
#define _HAS_EXCEPTIONS 0 // @v12.2.6
#include <slib.h>
#include <db.h>
#include <ppdbs.h>
#include <ppdefs.h>
#include <ued.h>
#include <report.h>
#include <snet.h>
#include <stylopalm.h>
#include <stylobhtii.h>
#include <ppedi.h>
#include <pp-ifm.h> // @v12.3.4
#include <..\rsrc\str\ppstr2.h>
#ifdef _MSC_VER
	#pragma intrinsic (fabs)
#else
	#pragma intrinsic fabs
#endif

#define DECL_REF_REC(rec)     struct rec##2; typedef rec##2 rec
#define ReferenceTbl          Reference2Tbl
#define REF_TEST_RECSIZE(rec) STATIC_ASSERT(sizeof(rec##_) == sizeof(Reference_ObsoleteTbl::Rec) && sizeof(rec##2) == sizeof(Reference2Tbl::Rec));

DECL_REF_REC(PPObjectTag);
DECL_REF_REC(PPSecur);
DECL_REF_REC(PPBarcodeStruc);
DECL_REF_REC(PPUnit);
DECL_REF_REC(PPNamedObjAssoc);
DECL_REF_REC(PPPersonKind);
DECL_REF_REC(PPPersonStatus);
DECL_REF_REC(PPELinkKind);
DECL_REF_REC(PPCurrency);
DECL_REF_REC(PPCurRateType);
DECL_REF_REC(PPAmountType);
DECL_REF_REC(PPOprType);
DECL_REF_REC(PPOpCounter);
DECL_REF_REC(PPGdsCls);
DECL_REF_REC(PPAssetWrOffGrp);
DECL_REF_REC(PPOprKind);
DECL_REF_REC(PPBillStatus);
DECL_REF_REC(PPAccSheet);
DECL_REF_REC(PPCashNode);
DECL_REF_REC(PPLocPrinter);
DECL_REF_REC(PPBarcodePrinter);
DECL_REF_REC(PPStyloPalm);
DECL_REF_REC(PPTouchScreen);
DECL_REF_REC(PPInternetAccount);
DECL_REF_REC(PPDBDiv);
DECL_REF_REC(PPGoodsType);
DECL_REF_REC(PPGoodsStrucHeader);
DECL_REF_REC(PPGoodsTax);
DECL_REF_REC(PPRegisterType);
DECL_REF_REC(PPQuotKind);
DECL_REF_REC(PPPsnOpKind);
DECL_REF_REC(PPWorldObjStatus);
DECL_REF_REC(PPPersonRelType);
DECL_REF_REC(PPSalCharge);
DECL_REF_REC(PPDateTimeRep);
DECL_REF_REC(PPDutySched);
DECL_REF_REC(PPStaffCal);
DECL_REF_REC(PPGoodsInfo);
DECL_REF_REC(PPScale);
DECL_REF_REC(PPBhtTerminal);
DECL_REF_REC(PPSCardSeries);
DECL_REF_REC(PPDraftWrOff);
DECL_REF_REC(PPAdvBillKind);
DECL_REF_REC(PPGoodsBasket);
DECL_REF_REC(PPDraftCreateRule);

class  PPThread;
class  PPObjBill;
class  PPObjWorld;
class  PPObjWorkbook;
class  PPObjTSession;
class  PPObjSCard;
class  PPObjCashNode;
class  PPObjGoods;
class  PPObjBrand;
class  PPObjPerson;
class  PPObjLocation;
class  PPObjArticle;
class  PPObjProcessor;
class  PPObjQCert;
class  PPObjCSession;
class  PPObjAccTurn;
class  PPObjPrjTask;
class  PPObjEventSubscription;
class  SysJournal;
class  ObjSyncCore;
class  StyloQCore;
class  BillFilt;
class  PPBillPacket;
class  CCheckPacket;
class  DbfTable;
struct PathData;
class  PPGoodsPacket;
struct PPRegistrInfo;
class  PPPersonPacket;
class  PPLocationPacket;
class  BillCore;
class  Transfer;
class  PPDbEntrySet2;
class  TView;
class  BrowserWindow;
struct AsyncCashGoodsInfo;
class  TDialog;
class  ComboBox;
class  ListWindow;
class  ListBoxDef;
class  AccTurnDialog;
class  TVRez;
class  BrowserWindow;
class  AccAnlzFilt;
class  BhtProtocol;
class  CipherProtocol;
class  BhtRecord;
class  GoodsListDialog;
class  PPBasketPacket;
class  EmbedDialog;
class  MrpTabPacket;
class  HierArray;
class  PPELinkArray;
class  PPGoodsStruc;
class  GRI;
class  GoodsReplacementArray;
struct TIDlgInitData;
struct PPGdsClsPacket;
struct ObjTransmContext;
class  PPCommandGroup;
class  DlContext;
struct TaxAmountIDs;
class  ObjCollection;
class  PPBasketCombine;
class  PPServerSession;
class  UhttSCardOpFilt;
class  UhttStatus;
class  UhttBrandPacket;
class  UhttGoodsPacket;
class  UhttSpecSeriesPacket;
class  UhttSCardPacket;
class  UhttCheckPacket;
class  UhttLocationPacket;
class  UhttBillPacket;
class  UhttBillFilter;
class  UhttQuotPacket;
class  UhttQuotFilter;
class  UhttPersonPacket;
class  UhttWorkbookItemPacket;
class  UhttGoodsRestListItem;
class  UhttDCFileVersionInfo;
class  UhttSmsPacket; // @vmiller
class  UhttStyloDevicePacket;
class  UhttProcessorPacket;
class  UhttTSessionPacket;
class  PersonRelFilt;
struct SBrowserDataProcBlock;
class  CCheckFilt;
struct PrjTaskFilt;
struct RegisterFilt;
class  SStatFilt;
class  GoodsFilt;
struct SysJournalFilt;
class  FreightFilt;
struct BudgetFilt;
class  SpecSeriesFilt;
struct SCardFilt;
struct CurRateFilt;
struct ClsdGoodsFilt;
struct TSessionFilt;
struct ProcessorFilt;
struct OpGroupingFilt;
struct MrpTabFilt;
class  PPView;
class  PPViewBrowser;
class  PPViewDebtTrnovr;
class  PPViewGoodsRest;
class  PPViewTrfrAnlz;
class  PPViewSStat;
class  PPViewPrjTask;
class  PPViewBill;
class  PPViewPersonEvent;
class  PPTransferItem;
class  TSessionPacket;
struct PPBillConfig;
class  CheckOpJrnl;
struct CCheckViewItem;
class  PPAlbatrossConfig;
struct PPSCardSeries2;
class  GtaJournalCore;
struct PPSCardSerPacket;
class  ObjTagItem;
class  ObjTagList;
class  LocTransfCore;
class  PrcssrAlcReport;
class  BillTransmDeficit;
struct PPQuot;
class  GoodsToObjAssoc;
class  PPSoapClientSession;
struct PPAccount;
class  CPosProcessor;
class  PPPaintCloth;
class  SaComplex;
class  BVATAccmArray;
struct BarcodeLabelParam;
struct BarcodeLabelEntry;
struct RetailGoodsInfo;
class  PPCommandItem;
class  PPCommand;
class  PPCommandHandler;
class  PPDesktop;
struct BillGoodsBrwItem;
class  BillGoodsBrwItemArray;
class  LocValList;
struct LocValEntry;
class  __HolidayArray;
class  DL2_Resolver;
class  DL2_Entry;
class  DL2_Group;
class  DL2_Data;
class  CMrpTab;
struct TagrCacheItem;
struct GoaAddingBlock;
struct GoaCacheItem;
struct ProfileEntry;
class  LogListWindowSCI;
struct PPCheckInPersonConfig;
class  PPCheckInPersonArray;
struct _PPRights;
struct PPSupplExchangeCfg;
class  EAddrCore;
struct ArticleDlgData;
class  ArticleCache;
class  PPComplBlock;
class  PPSCardPacket;
class  SCardTransmitPacket;
class  PPWorkbookExporter;
class  PPEgaisProcessor;
struct AddrItemDescr;
class  GoodsRestFilt;
class  SmsProtocolBuf;
class  SrGeoNodeTbl;
class  PPTextAnalyzerWrapper;
class  SelectObjectBlock;
class  Backend_SelectObjectBlock;
class  CPosNodeBlock;
class  WsCtlSrvBlock; // @v11.7.2
struct CPosProcessor_SetupDiscontBlock;
class  PersonCache;
class  BhtTSess;
class  ExtGoodsSelDialog;
struct StyloBhtIIConfig;
class  SrSyntaxRuleSet;
class  DeviceLoadingStat;
class  PPSyncCashSession;
class  PPAsyncCashSession;
class  PPCashMachine;
class  PPGoodsImpExpParam;
class  TSessAnlzList;
class  PhoneServiceEventResponder;
struct StTspResponse; // Описание в ppeds.cpp
struct LotViewItem;
class  AsteriskAmiClient;
struct VetisNamedGenericVersioningEntity;
struct VetisVetDocument;
struct VetisEnterprise;
struct VetisBusinessEntity;
struct VetisProductItem;
struct VetisProduct;
struct VetisSubProduct;
struct VetisStockEntry;
class  PPVetisInterface;
struct Fann2;
class  TsStakeEnvironment;
class  RetailPriceExtractor;
struct PPGlobalUserAcc;
struct amqp_rpc_reply_t;
struct PhnSvcChannelStatus;
class  PPAdviseEventVector;
struct PPNotifyEvent;
struct CCheckItem;
struct TimeSeries_OptEntryList_Graph_Param;
class  UhttTagItem;
struct GravityValue;
struct GravityErrorDescription;
struct UfpFileSet;
class  PPViewAlcoDeclRu;
class  PPNamedFilt;
struct bignum_st; // OpenSSL
struct DBDivPack;
struct PPCommSyncID;
class  PPFtsDatabase;
class  PPTextAnalyzer;
struct ResolveGoodsItem;
struct StyloQBlobInfo;
class  PPBillImpExpParam;
class StyloQAttendancePrereqParam;
class StyloQIndexingParam;
class StyloQGoodsInfoParam;
class StyloQIncomingListParam;
class StyloQDocumentPrereqParam;
class StyloQPersonEventParam;
class StyloQTestCmdParam;
class PPObjTech;
class PPBillImporter;
class EgaisMarkAutoSelector;
class PPMarketplaceInterface;
class PrcssrMarketplaceInterchange;

typedef struct bignum_st BIGNUM; // OpenSSL
typedef int32 PPID; // @v11.6.8 long-->int32
typedef LongArray PPIDArray;
//
// Descr: Блок константных параметров, которые инициализируются единожды при запуске процесса,
//   и не могут меняться в течении жизни процесса.
//   Мотивацией для ввода этого блока является большое число всевозможных константных флагов и значений
//   разбросанных по всему проекту - их надо собрать в одном месте.
// Attention! Ни в коем случае нельзя менять значения этих констант: последствия могут быть сколь угодно тяжелыми.
//
class PPConst { // @v11.7.3 PPConstParam-->PPConst
public:
	enum {
		fDoSeparateNonFiscalCcItems = 0x0001
	};

	static constexpr int    UseAdvEvQueue = 1; // {0, 1, 2} USE_ADVEVQUEUE Использовать очередь сообщений
	static constexpr uint32 Flags = 0/*fDoSeparateNonFiscalCcItems*/;
	static constexpr int16  EgaisInRowIdentDivider = 27277; // Специальное смещение для значений номеров строк, с помощью которого
		// решается проблема одиозных входящих идентификаторов строк документов (0, guid, текст, значения большие чем EgaisInRowIdentDivider)
	static constexpr long   CommonCmdAssocDesktopID = 100000L; // @v10.9.3 100000L Искусственный идентификатор рабочего стола, используемый для хранения общих ассоциаций команд
	static constexpr long   TechSurrogateGoodsIdStart = -524288L; // @v11.6.4 (-524288L) Верхнее значение специального поля фейковых идентификаторов товаров, 
		// используемых для предотвращения дублирования индексов в таблице Tech при создании трехнологий верхнего уровня (folders).
	static constexpr uint32 Signature_PPObjSCard_Filt              = 0xfbefffffU; // Специальная сигнатура объекта PPObjSCard::Filt
	static constexpr uint32 Signature_DbDump                       = 0x44445050U;
	static constexpr uint32 Signature_VerHist                      = 0x48565050U; // 'PPVH' Сигнатура файла истории обновления версий
	static constexpr uint32 Signature_PhoneServiceEventResponder   = 0x5A6B7C8EU; // Сигнатура респондера событий телефонного сервиса
	static constexpr uint32 Signature_MqbEventResponder            = 0xB4C7E6F1U; // Сигнатура респондера событий брокера сообщений
	static constexpr uint32 Signature_SysMaintenanceEventResponder = 0x35079E8DU; // Сигнатура респондера событий обслуживания системы
	static constexpr uint64 Signature_Quotation2_DumpHeader        = 0x7654321098fedcbaULL; // Сигнатура дампа котировок = 0x7654321098fedcbaLL; // @persistent
	static constexpr uint32 Signature_PPView                       = 0x099A099BU; // Сигнатура класса PPView 0x099A099BUL (former SIGN_PPVIEW)
	static constexpr uint32 Signature_PPThreadLocalArea            = 0x7D08E311U; // @v10.9.12 Сигнатура класса PPThreadLocalArea (former SIGN_PPTLA)
	static constexpr uint32 Signature_StqDbSymbToSvcIdMap          = 0xBCA10DD9U; // @v11.1.12 Сигнатура файла соответствий символов баз данных идентификаторам сервисов Stylo-Q
	static constexpr uint32 Signature_BillMultiPrintParam          = 0xA4183530U; // @v11.2.0  Сигнатура класса BillMultiPrintParam
	static constexpr uint32 Signature_StyloQStoragePacket          = 0x11A52FB6U; // @v11.6.0 Сигнатура класса StyloQCore::StoragePacket
	static constexpr uint32 Signature_StyloQPersonEventParam       = 0x230759EAU; // @v11.6.1 Сигнатура класса StyloQPersonEventParam
	static constexpr long   Signature_LaunchAppParam               = 0x4c484150L; // 'LHAP'
	static constexpr uint32 Signature_EgaisMarkAutoSelector_ResultBlock = 0x938EF619U; // @v12.2.11 Сигнатура класса EgaisMarkAutoSelector::ResultBlock. Для сериализации.
	static constexpr const char * P_SubjectDbDiv = "$PpyDbDivTransmission$";
	static constexpr const char * P_SubjectOrder = "$PpyOrderTransmission$";
	static constexpr const char * P_SubjectCharry = "$PpyCharryTransmission$";
	static constexpr const char * P_BillNotePrefix_IntrExpnd = "$INTREXPND"; // "$INTREXPND" Специальный префикс примечания документа передаваемый через ЕГАИС для привязка документа внутренней передачи
	static constexpr const char * P_MagicFileTransmit = "$#FILETRANSMITMAGIC#$"; // @v11.2.9 "$#FILETRANSMITMAGIC#$" Префикс команды JobServer'а для передачи файлов
	static constexpr const char * P_ObjMemoDelim      = "=^%"; // MemosDelim разделитель примечаний объектов
	static constexpr const char * P_ObjMemo_UtmRejPfx = "UTM Rej"; // Префикс примечания документа для индикации сообщения об ошибке поступившего от ЕГАИС УТМ
	static constexpr const char * P_ObjMemo_EgaisRejPfx = "EGAIS Rej"; // Префикс примечания документа для индикации сообщения об ошибке поступившего от ЕГАИС
	static constexpr const char * P_ObjMemo_ChznRejPfx = "ChZn Rej";   // Префикс примечания документа для индикации сообщения об ошибке поступившего от честного знака
	static constexpr const char * P_TagValRestrict_Empty = "#EMPTY"; // @v11.3.6
	static constexpr const char * P_TagValRestrict_Exist = "#EXIST"; // @v11.3.6
	static constexpr const char * P_TagValRestrict_List = "#LIST"; // @v11.3.6
	static constexpr const char * WrKey_PrefSettings = "Software\\Papyrus\\Pref"; // @v11.4.4 (replaced PPRegKeys)
	static constexpr const char * WrKey_PrefBasketSelSettings = "Software\\Papyrus\\Pref\\BasketSel"; // @v11.4.4 (replaced PPRegKeys)
	static constexpr const char * WrKey_SysSettings = "Software\\Papyrus\\System"; // @v11.4.4 (replaced PPRegKeys)
	static constexpr const char * WrKey_Sessions = "Software\\Papyrus\\Sessions"; // @v11.4.4 (replaced PPRegKeys)
	static constexpr const char * WrKey_WsCtl = "Software\\Papyrus\\WsCtl"; // @v11.7.2 HKEY_LOCAL_MACHINE
	static constexpr const char * WrKey_SlTestApp = "Software\\Papyrus\\SlTestApp"; // @v11.8.2 HKEY_LOCAL_MACHINE && HKEY_CURRENT_USER
	static constexpr const char * WrKey_RecentItems = "Software\\Papyrus\\RecentItems"; // @v12.3.2 moved from pptvutil.cpp
	static constexpr const char * WrParam_ViewQuotsAsListBox = "ViewQuotsAsListBox";
	static constexpr const char * WrParam_BillAddFilesFolder = "BillAddFilesFolder";
	static constexpr const char * WrParam_CalcPriceParam = "CalcPriceParam";
	static constexpr const char * WrParam_BinPath = "BinPath";
	static constexpr const char * WrParam_PhnSvcLocalUpChannelSymbol = "PhnSvcLocalChannelSymbol";
	static constexpr const char * WrParam_PhnSvcLocalScanChannelSymbol = "PhnSvcLocalScanChannelSymbol";
	static constexpr const char * WrParam_DefaultWindowsPrinter = "DefaultWindowsPrinter";
	static constexpr const char * WrParam_PersonAddImageFolder = "PersonAddImageFolder";
	static constexpr const char * WrParam_UseDuplexPrinting = "UseDuplexPrinting";
	static constexpr const char * WrParam_StoreLastSelectedPrinter = "StoreLastSelectedPrinter";
	static constexpr const char * WrParam_LastSelectedPrinter = "LastSelectedPrinter";
	static constexpr const char * WrParam_BillMultiplePrintCfg2 = "BillMultiplePrintCfg2"; // @v11.2.0
	static constexpr const char * WrParam_StyloQLoclMachineUuid = "StyloQLoclMachineUuid"; // @v11.2.3
	static constexpr const char * WrParam_WsCtl_MachineUUID = "MachineUUID"; // @v11.7.2 
	static constexpr const char * WrParam_WsCtl_Config = "Config"; // @v11.7.8
	static constexpr const char * WrParam_SlTestApp_TestParam = "TestParam"; // @v11.8.2
	static constexpr const char * FnExt_PPS    = ".PPS"; // Файлы передачи данных между разделами БД
	static constexpr const char * FnExt_CHARRY = ".CHY"; // Файлы charry
	static constexpr const char * FnExt_ORD    = ".ord";
	static constexpr const char * DefSrvCmdTerm = "\xD\xA"; // @v11.8.6 Терминатор неструктурированных ответов job-server'а
	// @v11.8.11 {
	static constexpr uint PwSize_PHNSVC           = 64; // @attention изменение значения требует конвертации хранимого пароля
	static constexpr uint PwSize_POP3_BEFORE11509 = 20; // @attention изменение значения требует конвертации хранимого пароля
	static constexpr uint PwSize_POP3_2           = 32; // @attention изменение значения требует конвертации хранимого пароля
	static constexpr uint PwSize_UHTT             = 20; // @attention изменение значения требует конвертации хранимого пароля
	// } @v11.8.11 
	static constexpr const char * PipeCrr32Proxi = "PapyrusCrr32Proxi"; // @v11.9.5 @construction Имя именованного канала, по которому осуществляется взаимодействие
		// с proxi-сервером, обеспечивающим интерфейс с 32-битным клиентом CristalReports.
};
//
// @v11.7.3 (все константы стали static constexpr) extern const PPConstParam _PPConst;
//
// Output message functions
//
SString & CDECL PPFormat(const SString & rFmt, SString * pBuf, ...);
SString & CDECL PPFormatT(int textCode, SString * pBuf, ...);
SString & CDECL PPFormatS(int textGroup, int textCode, SString * pBuf, ...);
void   FASTCALL PPSetAddedMsgString(const char * pStr);
void   FASTCALL PPSetAddedMsgObjName(PPID objType, PPID objID);
int    STDCALL  PPGetMessage(uint options, int msgcode, const char * pAddInfo, int rmvSpcChrs, SString & rBuf);
//
// Descr: Сокращенный аналог PPGetLastErrorMessage(rmvSpcChrs, rBuf)
//
int    FASTCALL PPGetLastErrorMessage(int rmvSpcChrs, SString & rBuf);
int    PPOutputMessage(const char * msg, uint option);
int    STDCALL  PPMessage(uint options, int msgcode, const char * pAddInfo);
int    FASTCALL PPMessage(uint options, int msgcode);
int    FASTCALL PPError(int errcode);
int    FASTCALL PPError(int errcode, const char * pAddInfo);
int    STDCALL  PPError(int errcode, const char * pAddInfo, uint extraMfOptions);
int    PPTooltipMessage(uint options, int msgcode, const char * pAddInfo);
int    PPTooltipMessage(const char * pMsg, const char * pImgPath, HWND parent, long timer, COLORREF color, long flags);
//
// Descr: Единственная польза от следующей функции - снижение размера
//   бинарного кода за счет устранения передачи лишних параметров.
//   Вызов PPError() в кодах встречается более 1100 раз
//
int    PPError(); // @>>PPError(-1, 0)
//
// Descr: То же, что и PPError() но гарантированно возвращает 0.
//   Создана для замены конструкции (PPError(), 0)
//
int    PPErrorZ();
int    FASTCALL PPErrorTooltip(int errCode, const char * pAddedMsg);
//
// Descr: Устанавливает код текущей ошибки Papyrus в значение errCode и дополнительную строку pAddedMsg.
// Returns: 0
//
int    FASTCALL PPSetError(int errCode, const char * pAddedMsg);
int    FASTCALL PPSetError(int errCode, long val);
//
// Descr: Устанавливает текущую (относительно потока) ошибку.
//   Очищает дополнительную информацию об ошибке.
// Returns: 0
//
int    FASTCALL PPSetError(int errCode);
//
// Descr: Устанавливает текущую (относительно потока) ошибку.
//   Не очищает дополнительную информацию об ошибке.
// Returns: 0
//
int    FASTCALL PPSetErrorPreserveAddendum(int errCode);
int    FASTCALL PPSetLibXmlError(const xmlParserCtxt * pCtx);
int    PPSetErrorNoMem();
int    PPSetErrorInvParam();
//
// Returns: 0
//
int    PPSetErrorSLib();
//
// Returns: 0
//
int    PPSetErrorDB();
int    PPDbSearchError(); // { return (BTROKORNFOUND) /**/ ? -1 : PPSetErrorDB(); }
int    STDCALL PPSetObjError(int errCode, PPID objType, PPID objID);
//
// Descr: Утилитный класс, используемый как базовый для классов, имеющих
//   строки расширения, идентифицируемые целочисленными значениями.
//
class PPExtStrContainer {
public:
	PPExtStrContainer();
	PPExtStrContainer & Z();
	bool   FASTCALL Copy(const PPExtStrContainer & rS);
	//
	// Descr: Определяет эквивалентность объекта this объекту rS по множеству подстрок,
	//   размером fldCount и с идентификаторами переданными в pFldList.
	// Descr:
	//   !0 - объекты this и rS эквивалентны по множетсву pFldList[fldCount]
	//   0 - объекты this и rS не эквивалентны
	//
	bool   IsEq(const PPExtStrContainer & rS, int fldCount, const int * pFldList) const;
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char * pStr);
	int    SerializeB(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	void   FASTCALL SetBuffer(const char * pSrc);
	const  SString & GetBuffer() const;
protected:
	SString ExtString;
};
//
// Descr: Общие предопределенные форматы обмена данными (общее поле идентификации, используемое для импорта/экспорта)
//
enum PredefinedImpExpFormat { // @persistent
	piefUndef                    =  0, //
	piefNalogR_Invoice           =  1, // Счет-фактура в формате nalog.ru
	piefNalogR_REZRUISP          =  2, // Специальный тип документа в формате nalog.ru
	piefNalogR_SCHFDOPPR         =  3, // УПД ON_SCHFDOPPR_1_995_01_05_01_02.xsd
	piefExport_Marks             =  4, // Внутренний простой текстовый формат экспорта марок
	piefNalogR                   =  5, // import-only Файлы в формате nalog.ru
	piefNalogR_ON_NSCHFDOPPRMARK =  6, // Счет-фактура с марками
	piefICalendar                =  7, // @v11.0.1 iCalendar
	piefNalogR_ON_NSCHFDOPPR     =  8, // @v11.2.1 Счет-фактура
	piefCokeOrder                =  9, // @v11.3.8 xml-заказы кока-кола
	piefChicago                  = 10, // @v11.5.8 xml-заказы системы чикаго (системные технологии, калининград)
	piefNalogR_ON_NKORSCHFDOPPR  = 11, // @v11.7.0 Корректировочная счет-фактура
	piefCCheck_Contract01        = 12  // @v11.8.4 Заказной формат импорта внешних чеков. Фантазии на имя не хватило, потому пока называется назамысловато.
};
//
// Descr: Габаритные размеры (mm).
//
struct PPDimention { // @noctr @novtbl
	PPDimention & Z();
	int    operator !() const;
	bool   FASTCALL IsEq(const PPDimention & rS) const;
	bool   FASTCALL operator == (const PPDimention & rS) const;
	bool   FASTCALL operator != (const PPDimention & rS) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Возвращает объем в куб.метрах
	//
	double CalcVolumeM() const;
	//
	// Descr: Возвращает объем в куб.миллиметрах
	//
	double CalcVolumeMM() const;
	//
	// Descr: Устанавливает общий объем в куб.метрах.
	//   При этом ширина и высота устанавливаются равными 100мм, а длина в R0i(volume * fpow10i(5))
	//
	void   SetVolumeM(double volume);

	long   Length;
	long   Width;
	long   Height;
};
//
//
//
class ObjLinkFiles {
public:
	//
	// Descr: Флаги состояния объекта
	//
	enum {
		stTransmissionNotSupported = 0x0001, // При восстановлении объекта из буфера выяснилось, что сторона, упаковавшая его в буфер, не поддерживает сериализацию.
		stIgnoreCheckStorageDir    = 0x0002  //
	};

	// @v12.0.4 ObjLinkFiles();
	explicit ObjLinkFiles(PPID objType);
	ObjLinkFiles(const ObjLinkFiles & rS);
	void   SetMode_IgnoreCheckStorageDir(int set);
	int    FASTCALL Copy(const ObjLinkFiles & rS);
	ObjLinkFiles & FASTCALL operator = (const ObjLinkFiles & rSrc);
	void   Init(PPID objType, const char * pDir);
	void   FASTCALL Init(PPID objType);
	int    Load(PPID objID, const char * pAddedSubstr);
	int    Save(PPID objID, const char * pAddedSubstr);
	int    SaveSingle(PPID objID, const char * pAddedSubstr, uint idx, SString * pResultName);
	//int    IsChanged(PPID id, const char * pAddedSubstr) const;
	int    Load(PPID objID, PPID addedID);
	int    Save(PPID objID, PPID addedID);
	int    IsChanged(PPID id, PPID addedID) const;
	uint   GetCount() const;
	int    At(uint i, SString & rPath) const;
	int    Remove(uint i);
	int    CheckFile(uint pos, const char * pPath);
	int    Replace(uint i, const char * pPath);
	void   Clear();
	//
	// Descr: Высокоуровневая функция устанавливающая (возможно, замещая существующий) файл по индексу 0.
	//
	int    SetupZeroPositionFile(PPID objType, PPID objID, const char * pPath);
	//
	// Descr: Высокоуровневая функция извлекающая файл по индексу 0
	//
	int    GetZeroPositionFile(PPID objType, PPID objID, SString & rPath);
	long   GetState() const;
	//
	// Descr: Процедура сериализации прикрепленных файлов.
	// ARG(dir   IN): Направление сериализации. >0 - объект-->буфер, <0 - буфер-->объект
	// ARG(transmissionNotSupported IN): Индикатор, сигнализирующий о том, что сериализация прикрепленных
	//   файлов не поддерживается для данного объекта. Имеет значение только при dir > 0.
	//   Если transmissionNotSupported != 0, то в буфер записывается специальное значение,
	//   при считывании которого десериализация (dir<0) может специальным образом это обработать.
	// ARG(rBuf  INOUT): Буфер, в который (dir>0) или из которого (dir<0) сериализуется объект this
	// ARG(pSCtx INOUT): Контекст сериализации
	//
	int    Serialize(int dir, int transmissionNotSupported, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Служебная структура, используемая для кодирования/декодирования хранимых имен файлов
	//
	struct Fns {
		Fns();
		void   Reset();

		long   ObjType;
		long   ObjID;
		SString AddedStr;
		long   Cntr;
		char   Ext[32];
	};
	static bool SplitInnerFileName(const char * pFileName, Fns * pS) /*const*/;
private:
	int    MakeFilePath(PPID objID, /*PPID addedID*/const char * pAddedStr, SString & rPath);
	int    MakeExistsFilePath(uint i, PPID objID, /*PPID addedID*/const char * pAddedStr, SString & rPath);
	int    GetFreeNum(uint * pNum) const;
	int    GetNum(const char * pPath, uint * pNum);
	int    Helper_ClearBeforeSaving(PPID objID, const char * pAddedStr);
	int    Helper_Save(PPID objID, const char * pAddedStr, uint idx, SString * pResultFileName);

	const  PPID ObjType; // @v12.0.4 const
	PPID   ObjID;
	ulong  FilesNums;
	ulong  InitFilesNums; // номера файлов присоединенных к объекту, не изменяется после загрузки
	long   State;         // Флаги состояния объекта
	SString StoreDir;
	SStrCollection Files;
};
//
//
//
class PapyrusPrivateBlock {
public:
	PapyrusPrivateBlock();
	~PapyrusPrivateBlock();
	PapyrusPrivateBlock & Z();
	int    ReadFromIni(SIniFile & rIniFile);
	int    WriteToSrc(const char * pFileName);
	int    RestoreBuffer(const void * pSrcData, size_t srcDataSize);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		fDemo       = 0x0001,
		fOpenSource = 0x0002
	};
	struct Header {
		char   Signature[32];  // Заголовочная сигнатура структуры
		uint32 RawBufferSize;  // Полный размер "сырого" сериализованного буфера
	} H;
	uint32 StructVer;      // Версия структуры данных. [1..]
	int32  StartDevYear;   // Год начала разработки
	int32  LastDevYear;    // Последний год разработки
	SVerT  Ver;            // Номер версии продукта
	SVerT  MinVer;         // Минимальная версия базы данных, с которой может работать данная версия системы
	int32  AssemblyN;      // Номер сборки
	int32  Flags;          // @flags
	SString ProductName;   // Наименование продукта
	SString Team;          // Команда разработчиков
	SString Secret;        // Секретный текст
	SString DefPassword;   // Пароль для шифрования/расшифрования по умолчанию
	SString MsftTranslAcc; // Аккаунт доступа к службе Microsoft Translate
	SString UhttAcc;       // Default-аккаунт доступа к службам Universe-HTT
	SString VkAppIdent;    // @v10.9.6 Идентификатор приложения Papyrus в ВКонтакте
	SString GoogleAppIdent; // @v11.0.2 Идентификатор приложения Papyrus в Google
	SString FacebookAppIdent; // @v11.0.7 Идентификатор приложения Papyrus в Facebook
};
//
// Descr: Блок информации о версии системы.
//   Данные хранятся в зашифрованном виде.
//
class PPVersionInfo {
public:
	//
	// Descr: Идентификаторы текстовых атрибутов
	//
	enum {
		tiaUndef = 0,
		taiProductName,
		taiTeam,
		taiVersionText,
		taiCopyrightText,
		taiMsftTranslAcc,
		taiVkAppIdent,
		taiGoogleAppIdent, // @v11.0.2
		taiFacebookAppIdent, // @v11.0.7
	};
	explicit PPVersionInfo(const char * pOuterFileName = 0);
	PPVersionInfo(const PPVersionInfo & s);
	~PPVersionInfo();
	PPVersionInfo & FASTCALL operator = (const PPVersionInfo &);
	// @v10.9.6 int    GetProductName(SString & rBuf);
	// @v10.9.6 int    GetTeam(char *, size_t);
	int    GetDevYears(uint * pStart, uint * pLast);
	int    GetVersion(uint * pMajor, uint * pMinor, uint * pRevision, char * pDemo = 0, int minVersion = 0);
	SVerT  GetVersion(int minVersion = 0);
	int    GetAssemblyN();
	int    GetSecret(char * pBuf, size_t bufSize);
	// @v10.9.6 int    GetVersionText(char *, size_t);
	// @v10.9.6 int    GetCopyrightText(SString & rBuf);
	int    GetDefaultEncrKey(SString & rBuf);
	// @v10.9.6 int    GetMsftTranslAcc(SString & rBuf);
	// @v10.9.6 int    GetVkAppIdent(SString & rBuf);
	int    GetTextAttrib(int ident, SString & rBuf);
	long   GetFlags();
private:
	int    Decrypt();
	void   Clear();
	void * P_Info_Pre9303;
	PapyrusPrivateBlock * P_Info_;
	char * P_OuterFileName;
};
//
// Descr: Блок данных о лицензиях, которыми владеет пользователь программы.
//
struct PPLicData {
	PPLicData();

	enum {
		effJobServer  = 0x0001,
		effDebtorStat = 0x0002,
		effRemove     = 0x8000, // Если флаг установлен, то транспортный
			// файл накладывает флаги на существующий файл операцией "&~"
			// В противном случае - операцией "|"
		effEgais      = 0x0004  // Лицензия на использование интерфейса с ЕГАИС
	};
	char   RegName[48];
	char   RegNumber[32];
	int32  LicCount;
	LDATE  LastUpdate;
	int16  Transport;
	int16  Version;         // 0..
	char   Reserve2[24];
	uint32 ExtFunc;         // Битовые флаги доступности дополнительных функций
	int32  FreeLicCount;    //
	uint32 DbDivArray[8];   // Битовый массив доступных разделов БД
	uint32 SrvJobArray[16]; // Битовый массив доступных задач сервера
};
//
// Descr: Класс, управляющий получение списка файлов по шаблону
//
/*class PPFileNameArray : public TSArray <SDirEntry> {
public:
	PPFileNameArray();
	int    Scan(const char * pPath, const char * pWildcard);
	int    Enum(uint * pIdx, SDirEntry * pEntry, SString * pFullPath) const;
	const  SString & GetPath() const;
//private:
	SString Path; //
};*/
//
// Descr: Список идентификаторов. Практически полностью повторяет
//   функционал LongArray (PPIDArray) за исключением того, что может быть
//   неопределенным (!ObjIdListFilt::IsExists()).
//   Используется для фильтрации по списку идентификаторов объектов.
//   Неопределенный экземпляр не накладывает ограничений фильтрации.
//
class ObjIdListFilt { // @size=sizeof(PPIDArray *) Передается в качестве аргументов по значению
public:
	ObjIdListFilt();
	ObjIdListFilt(const ObjIdListFilt &);
	~ObjIdListFilt();
	ObjIdListFilt & FASTCALL operator = (const ObjIdListFilt &);
	//
	// Descr: Устанавливает единственное значение списка, равное value
	//   Если до присвоения список был не пуст, то он очищается.
	//   Если value == 0, то список просто очищается.
	//
	ObjIdListFilt & FASTCALL operator = (long value);
	bool   operator ! () const { return (P_List == 0); }
	bool   IsExists() const { return LOGIC(P_List); }
	bool   FASTCALL IsEq(const ObjIdListFilt &) const;
	bool   IsEmpty() const;
	bool   FASTCALL CheckID(PPID) const;
	const  PPIDArray & Get() const { return *P_List; }
	PPIDArray * GetP() const { return P_List; }
	int    FASTCALL Get(PPIDArray & rResult) const;
	//
	// Descr: Распределяет память для массива P_List.
	//   Если P_List != 0, то ничего не делает.
	//   Вызов этой функции может понадобиться для того, чтобы
	//   функция IsExists возвращала !0.
	// Returns:
	//   !0 - либо P_List не был равен нулю, либо удалось его создать
	//   0  - не удалось распределить память для массива P_List (PPErrCode = PPERR_NOMEM)
	//
	ObjIdListFilt & InitEmpty();
	//ObjIdListFilt & FASTCALL Set(const PPIDArray *);
	void   FASTCALL Set(const PPIDArray *);
	//int    Add(PPID, int ignoreZero = 1);
	int    FASTCALL Add(PPID id);
	int    FASTCALL AddNotIgnoringZero(PPID id);
	//
	// Descr: Добавляет в список элементы из массива pList.
	// Attention: В отличии от метода ObjIdListFilt::Add(PPID, int)
	//   эта функция не игноирует нулевые значения.
	//
	int    FASTCALL Add(const PPIDArray * pList);
	int    Update(uint pos, PPID newId, int ignoreZero = 1);
	int    Remove(PPID, int bsearch = 0);
	int    RemoveByIdx(uint idx);
	PPID   GetSingle() const;
	PPID   FASTCALL Get(uint pos) const;
	uint   IncPointer(); // @>>P_List->incPointer
	//
	// Descr: Очищает список и вставляет в него единственный элемент id.
	//   Если id == 0, то список остается пустым.
	//
	int    SetSingle(PPID id);
	uint   GetCount() const;
	int    Sort();
	int    Search(PPID id, uint * pPos, int bsearch = 0) const;
	ObjIdListFilt & Z();
	int    FASTCALL CopyTo(PPIDArray * pAry) const;
	int    Intersect(const ObjIdListFilt * pList, int binary = 0); // -> LongArray::intersect
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	PPIDArray * P_List;
};
//
//
//
struct PPCycleFilt { // @size=4
	PPCycleFilt();
	PPCycleFilt & Z();
	bool   FASTCALL operator == (const PPCycleFilt & rS) const;
	bool   operator !() const;
	int16  Cycle;
	int16  NumCycles;
};

class PPCycleArray : public TSVector <DateRange> {
public:
	PPCycleArray();
	PPCycleArray(LDATE, LDATE, int cycle, int numCycles);
	int    init(LDATE beg, LDATE end, int cycle, int numCycles);
	int    init(const DateRange *, int cycle, int numCycles);
	int    init(const DateRange *, PPCycleFilt cycl);
	int    init2(DateRange * pPeriod, PPCycleFilt * pCycl);
	int    concat(const PPCycleArray *);
	void   getCycleParams(DateRange *, PPCycleFilt * pCycl) const;
	int    getPeriod(uint pos, DateRange *) const;
	int    searchDate(LDATE, uint *) const;
	int    searchPeriodByDate(LDATE, DateRange *) const;
	void   formatCycle(LDATE, char *, size_t) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	DateRange Period;
	int    Cycle;
	int    NumCycles;
};

class DateIter {
public:
	DateIter();
	DateIter(long start, long finish);
	explicit DateIter(const DateRange *);
	void   Init();
	void   Init(long start, long finish);
	void   Init(const DateRange *);
	int    Advance(LDATE d, long o);
	bool   IsEnd() const;
	//
	// Descr: Сравнивает объект this с объектом rS.
	//   Сравнение осуществляется по паре {dt, oprno}
	// Returns:
	//   >0 - this > rS
	//   <0 - this < rS
	//    0 - this == rS
	//
	int    FASTCALL Cmp(const DateIter & rS) const;

	LDATE  end;
	LDATE  dt;
	long   oprno;
};
//
// Descr: Специализированный массив, хранящий пары {id, binary data}. Причем
//   значение ключа автоматически назначается экземпляром массива при обращении
//   к функции SurKeyArray::Add.
//
class SurKeyArray : public SArray {
public:
	SurKeyArray();
	int    Add(long * pID, const void * pData, size_t dataLen);
	int    Remove(long id);
	const void * Get(long id, size_t * pDataLen) const;
private:
	virtual void FASTCALL freeItem(void * pItem);
	long   LastId;
};
//
// Descr: Специализированный потомок StringSet использующий предопределенный разделитель "/&"
//   и применяемый для хранения списков строк в кэшах и для некоторых пакетов данных.
// Note: Учитывая то, что применяется для persistent-объектов, разделитель не может быть
//   произвольным образом модифицирован.
//
class PPStringSetSCD : public StringSet {
public:
	PPStringSetSCD();
};
//
//
//
struct PPCalcFuncEntry {
	PPCalcFuncEntry();
	~PPCalcFuncEntry();
	uint   FuncID;
	uint   RetType;
	uint   ParamCount;
	uint * P_ParamTypeList;
	SString Name;
	SString Description;
};

class PPCalcFuncList : public TSCollection <PPCalcFuncEntry> {
public:
	PPCalcFuncList();
	int    Load();
	void   Release();
	int    ReadParams(uint16 funcID, const char *, size_t *, StringSet *) const;
	int    CalcFunc(uint16 funcID, const StringSet * pParams, char * pRes, size_t resBufLen) const;
	const  PPCalcFuncEntry * FASTCALL SearchFunc(uint16 funcID) const;
	uint16 FASTCALL SearchFuncByName(const char * pName) const;
};
//
// Descr: Класс, позволяющий организовать централизованное создание и уничтожение запросов
//   BExtQuery с сокрытием деталей создания этих запросов.
//
class PPTblEnumList {
public:
	PPTblEnumList();
	~PPTblEnumList();
	int    RegisterIterHandler(BExtQuery * pQ, long * pHandle);
	int    DestroyIterHandler(long handle);
	int    FASTCALL NextIter(long handle);
private:
	TSArray <void *> Tab;
};
//
//
//
template <class T> class PPTblEnum : public SEnum::Imp {
public:
	PPTblEnum(T * pT, long h) : P_T(pT), H(h)
	{
	}
	virtual ~PPTblEnum()
	{
		CALLPTRMEMB(P_T, EnumList.DestroyIterHandler(H));
	}
	virtual int Next(void * pRec)
	{
		return (P_T && P_T->EnumList.NextIter(H) > 0) ? (P_T->copyBufTo(pRec), 1) : 0;
	}
protected:
	T * P_T;
	long   H;
};
//
// Descr: Базовый класс контекстов разрешения переменных в формулах.
//
#define EXRP_EVAL_FIRST_FUNC 1000

class ExprEvalContext {
public:
	friend class PPExprParser;

	ExprEvalContext();
	virtual ~ExprEvalContext();
	bool   SelfScanArgList() const;
	int    SetInnerContext(ExprEvalContext * pInner);
	virtual int Resolve(const char * pSymb, double * pVal) = 0;
	//
	// Descr: Определяет, является ли строка pSymb функцией.
	//   Если "да", то должна вернуть !0, по указателю pFuncId
	//   присвоить идентификатор функции.
	//
	virtual int IsFunc(const char * pSymb, int * pFuncId);

	struct FC {
		FC();
		FC & Z();
		RealArray ArgList;    // Список числовых представлений аргументов
		SString StrArg;       // Список аргументов одной строкой
		TYPEID RetType;
		double RetReal;
		SString RetStr;
	};
	virtual int ResolveFunc(int funcId, FC & rFc);
protected:
	enum {
		fSelfScanArgList = 0x0001 // Контекст самостоятельно сканирует аргументы функции.
	};
	long   ImplementFlags;
	ExprEvalContext * P_Next__; // Внутренний контекст, используемый, если не удается разрешить формулу (переменную) с помощью данного контекста
};
//
// Descr: Реализует разрешение формулы. Использует ExprEvelContext для разрешения переменных
//   и функций. Формулы обрабатывают только значения с плавающей точкой.
//   Доступ к сервису этого класса осуществляется только через статический метод
//   PPExprParser::CalcExpression
//
class PPExprParser {
public:
	static int STDCALL CalcExpression(const char * pFormula, double * pResult, const PPCalcFuncList * pFuncList, ExprEvalContext * pCtx);
private:
	enum {
		tokNumber = 257,
		tokName = 258,
		tokFunc = 259,
		tokLe,          // <=
		tokGe,          // >=
		tokNe           // !=
	};
	enum {
		funcAbs   = 1, // abs(x)
		funcSqrt,      // sqrt(x)
		funcSin,       // sin(x)
		funcCos,       // cos(x)
		funcTan,       // tan(x)
		funcSieve,     // sieve[1.0; 20000.0 ? 2.5; 40000 ? 4](x)
		funcRound,     // round(x, prec) округление до ближайшего
		funcOid,       // oid(objtypesymb, objsymb) oid(GoodsType, tare)
		funcPow,       // pow(x, p)
		funcQuest,     // ?(condition, true_val, false_val)
		funcMin,       // min(...) любое количество аргументов
		funcMinZ,      // minz(...) любое количество аргументов
		funcMax,       // max(...) любое количество аргументов
		funcEq,        // eq(a, b)
		funcNEq,       // neq(a, b)
		funcRoundUp,   // roundup(x, prec) округление до верхней границы
		funcRoundDown, // rounddown(x, prec) округление до нижней границы
		funcLog,       // log(a) натуральный логарифм
		funcLog10,     // log10(a) десятичный логарифм
		funcTagExpr    // @v12.0.11 tagexpr(oid, tagsymb) выражение, заданное тегом с символом tagsymb объекта oid 
	};
	PPExprParser(const char *, const PPCalcFuncList *, ExprEvalContext *);
	~PPExprParser();
	int    FASTCALL CalcExpr(double *);
	int    FASTCALL GetFactor(double *);
	int    FASTCALL GetTerm(double *);
	void   Skip();
	int    GetToken();
	int    Next();
	int    GetSieve();
	int    ReadArgString(SString & rBuf, size_t * pOffs) const;
	int    ResolveContextName(const char * pSymb, double * pResult);

	struct State {
		State();
		State(const State &);
		State & FASTCALL operator = (const State & rS);

		PPID   OidObjType;    // for oid()
		PPID   OidObjTypeExt; // for oid()
	};
	class FuncBlock {
	public:
		FuncBlock();
		FuncBlock & Z();
		int   GetFuncId() const;
		void  SetFuncId(int f);
		void  ClearSieve();

		int   Func;
		SString ExtToken; // Используется для сложных конструкций. Введен ради tagexpr.tagsymb
		SHistogram Sieve;
		RAssocArray SieveVal;
	};
	int    Token;
	double Number;
	SString Name;
	//int    Func;
	int    Cur;
	char * P_S;
	size_t Pos;
	State  St;
	//SHistogram Sieve;
	//RAssocArray SieveVal;
	FuncBlock Fb;
	const PPCalcFuncList * P_CFL;
	ExprEvalContext * P_Ctx;
};
//
//
//
struct GdsClsCalcExprContext {
	GdsClsCalcExprContext(const PPGdsClsPacket * pGcPack, const PPGoodsPacket * pGPack);
	//
	// Descr: Конструктор, используемый для расчетов формул в структуре товара
	//
	GdsClsCalcExprContext(const PPGoodsStruc * pGs, PPID sessID = 0);
	GdsClsCalcExprContext(const PPGoodsStruc * pGs, const PPBillPacket * pBillPack);
	//
	// Descr: Конструктор, используемый для расчетов технологий перенастройки, в
	//   которых участвуют два товара: тот который будет производиться (goodsID) и тот,
	//   который производился непосредственно до этого (prevGoodsID).
	//
	GdsClsCalcExprContext(PPID goodsID, PPID prevGoodsID);
	GdsClsCalcExprContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack);
	GdsClsCalcExprContext(const CCheckItem * pCi);
	GdsClsCalcExprContext(const TSessLineTbl::Rec * pTslRec);

	const  PPGdsClsPacket * P_GcPack;
	const  PPGoodsPacket  * P_GPack;
	const  PPGoodsStruc * P_GsPack;
	const  PPBillPacket * P_BillPack;
	const  PPTransferItem * P_Ti;
	const  CCheckItem * P_Ci;
	const  TSessLineTbl::Rec * P_TslRec;
	const  ReceiptTbl::Rec * P_LotRec; // @v11.1.12
	PPID   TSessID;
	double Par1;
	double Par2;
	double Par3;
	PPID   GoodsID;
	PPID   PrevGoodsID;
};
//
//	Структура результирующей кросс-таблицы следующая:
//		autolong CTID;
//		Поля, заданные в списке IdxFldList, копируемые из исходной таблицы;
//		Поля, заданные в списке InhFldList, копируемые из исходной таблицы;
//		Поля, заданные в списке FixFldList
//		Список кросс-таб-полей (по AggrFldList.GetCount() на каждое табулируемое значение)
//			Наименования имеют следующую форму: CTFxxyy, где xx - номер табулированного значения,
//			yy - номер поля в списке AggrFldList;
//		AggrFldList.GetCount() итоговых поля //
//			Наименования имеют следующую форму: CTFTyy, где yy - номер поля в списке AggrFldList;
//
class Crosstab {
public:
	enum AggrFunc {
		afSum = 1,
		afCount,
		afAvg,     // not supported
		afMin,
		afMax,
	};
	Crosstab();
	virtual ~Crosstab();
	int    SetTable(DBTable * pTbl, const DBField & crssFld);
	int    AddIdxField(const DBField &);
	int    AddAggrField(const DBField &, AggrFunc af = afSum, const char * pColName = 0, long format = 0, long options = 0);
	int    AddFixField(const char * pName, TYPEID type);
	int    AddInheritedFixField(const DBField &);
	int    AddTotalRow(const DBFieldList & rAggrFldList, size_t extSize, const char * pTitle);
	int    AddTotalColumn(const DBField & rAggrFld, size_t extSize, const char * pTitle);
	int    CDECL SetSortIdx(const char * pFldName, ...);
	int    Create(int use_ta);
	uint   GetAggrCount() const;
	uint   GetTotalRowsCount() const;
	uint   GetTotalColsCount() const;
	virtual DBQuery * CreateBrowserQuery();
	virtual BrowserWindow * CreateBrowser(uint brwId, int dataOwner);
	virtual void GetTabTitle(const void * pVal, TYPEID typ, SString & rBuf) const;
		// @<<Crosstab::SetupBrowserCtColumns
	int    SetupBrowserCtColumns(BrowserWindow * pBrw) const;
		// @<<Crosstab::CreateBrowser
	DBTable * GetResultTable();
	const  DBFieldList & GetTabFieldList() const;
	int    GetIdxFields(PPID id, DBFieldList * pFldList);
	int    GetTab(uint tabIdx, void * pTabVal);
	int    SetFixFieldValByCTID(long ctID, uint fldPos, const void * pBuf);
	int    GetFixFieldValByCTID(long ctID, uint fldPos, void * pBuf, size_t bufSize);
	//
	// Descr: Извлекает индексное поле с номером idxFldN из строки буфера записи pDataBuf.
	//   Если pDataBuf == 0, то данные извлекаются из буфера текущей записи таблицы P_RTbl.
	//
	int    GetIdxFieldVal(uint idxFldN, const void * pDataBuf, void * pBuf, size_t bufSize);
	//
	// Descr: Извлекает агрегатное поле с номером aggrFldN из строки буфера записи pDataBuf.
	//   Если pDataBuf == 0, то данные извлекаются из буфера текущей записи таблицы P_RTbl.
	//
	int    GetAggrFieldVal(uint tabIdx, uint aggrFldN, const void * pDataBuf, void * pBuf, size_t bufSize);
	int    Write(SBuffer & rBuf, SSerializeContext * pCtx);
	int    Read(DBTable * pTbl, SBuffer & rBuf, SSerializeContext * pCtx);
protected:
	struct CalcSummaryBlock {
		explicit CalcSummaryBlock(int dir);
		const  int Dir;          // 0 - total row, 1 - total column
		uint   TotalItemPos; // @#[0..TotalLinesCount]
		uint   CtValPos;     // Номер кросстабулированной колонки
		uint   AggrPos;      // Номер кросстабилированной субколоки
		int    AggrFunc;     // (Crosstab::AggrFunc) Агрегирующая функция, используемая для расчета итоговых столбцев.
			// Это значение применяется только базовой реализацией метода CalcSummary
		void * P_ExtData;    // Указатель на область дополнительных данных, используемый функцией CalcSummary
		double CellVal;      // Значение в ячейке, для которой осуществляется суммирование
		double Result;       // Результат. При входе в функцию CalcSummary это поле содержит
			// значение, рассчитанное предыдущими итерациями.
			// Функция CalcSummary должна после вычисления присвоить этому полю новое
			// значение результата.
	};
	virtual int SetupFixFields(int initialCall);
	virtual int CalcSummary(int action, CalcSummaryBlock & rBlk);
	int    Helper_SetupBrowserCtColumn(BrowserWindow * pBrw, uint ctValPos, const SString & rTitle) const;
		// @<<Crosstab::SetupBrowserCtColumns
	uint   GetFixFieldOffs() const;
	uint   GetTabFldPos(uint ctValPos, uint aggrFldPos) const;
private:
	enum {
		fHasSortIdx      = 0x0004, // Внутреннее значение, указывающее на то, что таблица содержит сортирующий индекс
		fHasExtSortField = 0x0008  // Таблица содержит дополнительное сортирующее поле
			// для смещения итоговых строк в нижнюю часть области просмотра.
			// Если это поле существует, то она расположено 2-м по счету сразу после поля идентификатора
	};

	int    CreateTable();
	int    FillTable();
	int    DestroyTable();
	int    GetCrossValues(DBTable * pTbl, const DBField & crssFld, STypArray ** ppList);
	int    SetAggrValues(uint ctValPos);
	int    SetAggrSummaryValues();
	int    SetAggrSummaryRow();
	int    SetSummaryRows();
	int    WriteDbFieldList(const DBFieldList & rList, SBuffer & rBuf, SSerializeContext * pCtx);
	int    ReadDbFieldList(const DBTable * pTbl, DBFieldList & rList, SBuffer & rBuf, SSerializeContext * pCtx);

	long   Flags;              // @viewstate
	DBTable * P_Tbl;           // Исходная таблица для построения кросс-таба
	DBTable * P_RTbl;          // @viewstate Кросстабулированная таблица
	DBField     CrssFld;       // @viewstate Поле, по которому разворачивается таблица P_Tbl
	DBFieldList IdxFldList;    // @viewstate Список полей, образующих индекс
	BNFieldList FixFldList;    // @viewstate Список фиксированных полей, заполняемых вызовом виртуальной функции SetupFixFields
	DBFieldList InhFldList;    // @viewstate Список полей, унаследованных из исходой таблицы
	DBFieldList CrssFldList;   // @viewstate Список результирующих кросс-таб полей
	DBFieldList AggrFldList;   // @viewstate Список агрегируемых полей
	LongArray    AggrFuncList;  // @viewstate Список агрегатных функций, ассоциированный со списком AggrFldList
	SStrCollection AggrFldColNames; // @viewstate Наименования столбцов агрегируемых полей
	LAssocArray   AggrFldFormats; // @viewstate Формат и опции колонки
	STypArray * P_CtValList;   // @viewstate
	StringSet SortIdxList;     // @viewstate

	struct Summary {
		Summary(size_t extSize, uint aggrFldCount);
		size_t GetEntrySize() const;
		uint   GetCount() const;
		int    IsAggrField(uint lineNo, uint aggrPos) const;
		int    AddLine(uint32 aggrFldPosMask, const char * pTitle);
		int    GetTitle(uint lineN, SString & rBuf) const;
		double GetValue(uint lineNo, uint ctValPos, uint aggrPos);
		int    SetValue(uint lineNo, uint ctValPos, uint aggrPos, double val);
		void * GetExtPtr(uint lineNo, uint ctValPos);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	private:
		uint   AggrFldCount;
		size_t ExtSize;
		struct Item {
			Item(uint32 aggrFldPosMask, const char * pTitle, uint entrySize);
			uint32 AggrFldPosMask;
			SString Title;
			SArray List;
		};
		TSCollection <Item> Data;
	};
	Summary * P_TotalRows; // @viewstate
	Summary * P_TotalCols; // @viewstate
};
//
//
//
class PPDbqFuncPool {
public:
	static int IdEmpty;             //
	static int IdBillDebt;          //
	static int IdCQtty;             //
	static int IdTrfrPrice;         // (fldOpID, fldCost, fldPrice, fldDiscount)
	static int IdObjNameBillStatus; // (fldBillStatusID)
	static int IdObjNameOprKind;    // (fldOpID)
	static int IdObjNameLoc;        // (fldLocID)
	static int IdObjNameAr;         // (fldArID)
	static int IdObjNameArByAcc;    // (fldArID, fldAccID) Если у пользователя нет прав на доступ к счету fldAccID, то выдается пустое имя статьи fldArID //
	static int IdObjNameUser;       // (fldUserID)
	static int IdObjNameGlobalUser; // (fldGlobalUserID)
	static int IdObjNameUnit;       // (fldUnitID)
	static int IdObjNameTech;       // (fldTechID)
	static int IdObjNameGoodsByTech; // (fldTechID)
	static int IdObjNamePrc;        // (fldPrcID)
	static int IdObjNameGoods;      // (fldGoodsID)
	static int IdObjNamePerson;     //
	static int IdObjNameSalCharge;  // (fldSalChargeID)
	static int IdObjNameStaff;      // (fldStaffID)
	static int IdObjNameStaffCal;   // (fldStaffCalID)
	static int IdObjNamePersonPost; // (fldPersonPostID)
	static int IdObjStaffOrg;       // (fldStaffListID)
	static int IdObjStaffDiv;       // (fldStaffListID)
	static int IdObjSymbCurrency;   // (fldCurrencyID)
	static int IdObjNameAccSheet;   // (fldAcsID)
	static int IdObjNameQuotKind;   // (fldQkID)
	static int IdObjNameCashNode;   // (fldCashNodeID)
	static int IdObjNameScale;      // (fldScaleID)
	static int IdObjNamePsnOpKind;  // (fldScaleID)
	static int IdObjNameBizScore;   // (fldBizScoreID)
	static int IdObjNameAcctRel;    // (fldAcctRelID)
	static int IdObjNameBrand;      // (fldBrandID)
	static int IdObjNameWorld;      // (fldWorldID)
	static int IdObjNamePersonStatus; //
	static int IdObjNamePersonCat;  //
	static int IdObjNameAmountType; //
	static int IdObjNamePsnKind;    //
	static int IdObjCodeBillCmplx;  // (fldBillID) Формирует строку, состоящую из даты и номера документа
	static int IdObjCodeBill;       // (fldBillID) Формирует строку, состоящую из номера документа
	static int IdObjMemoBill;       // (fldBillID) Формирует строку примечания к документу
	static int IdObjNameSCardSer;   // (fldSCardSeriesID)
	static int IdObjNameDebtDim;    //
	static int IdObjCodeSCard;      // (fldSCardID)
	static int IdSCardOwnerName;    // (fldSCardID)
	static int IdUsrPersonName;     // (fldUsrID)
	static int IdLocOwnerName;      // (fldLocID) Формирует строку с именем персоналии-владельца локации
	static int IdUfpFuncName;       // (fldFuncId)
	static int IdVersionText;       // (fldLong)
	static int IdUfpFuncId;         // (fldLong)
	static int IdDateTime;          // (fldDate, fldTime)
	static int IdDurationToTime;    // (fldLong)
	static int IdInventDiffQtty;    // (fldFlags, fldDiffQtty)
	static int IdInventLnStatus;    // (fldFlags, fldBillID)
	static int IdTSesLnPhQtty;      // (fldGoodsID, fldFlags, fldQtty, fldWtQtty)
	static int IdTSesLnFlags;       // (fldFlags)
	static int IdPercent;           // (fldDividend, fldDivisor) =(100 * div / divisor)
	static int IdPercentIncDiv;     // (fldDividend, fldDivisor) =(100 * div / (divisor+div))
	static int IdPercentAddendum;   // (fldDividend, fldDivisor) =(100 * (fldDividend-fldDivisor) / fldDivisor))
	static int IdWorldIsMemb;       // (fldCity, WorldItemFilt)
	static int IdTaCost;            // Цена поступления в анализе товарных операций
	static int IdTaPrice;           // Цена реализации в анализе товарных операций
	static int IdCommSyncId;        // Общий идентификатор синхронизации объектов {int16; int32}
	static int IdObjTitle;          // (objType)  Наименование типа объекта данных
	static int IdGoodsStockDim;     // (fldGoods) Строка габаритов товара "width x length x height"
	static int IdGoodsStockBrutto;  // (fldGoods) Строка массы брутто товара
	static int IdGoodsStockMin;     // (fldGoods) Строка массы минимального остатка товара
	static int IdGoodsStockPackage; // (fldGoods) Строка емкости упаковки поставки товара
	static int IdGoodsSingleBarcode; // (fldGoods) Штрихкод товара
	static int IdReportTypeName;    // (fldReportTypeID) Строка типа отчета (стандартный или локальный)
	static int IdLogFileName;		// Имя файла журнала
	static int IdSysJActionName;    // Строка наименования системного события //
	static int IdGtaJActionName;    // Строка наименования тарифицируемого события глобальной учетной записи
	static int IdCounter;           // Счетчик. ((long)(long *)) В качестве параметра должен передаваться указатель на статическую переменную long.
	static int IdPropSubStr;        // (ObjType, ObjID, PropID, Sub)
		// Подстрока, извлекаемая из строки переменной длины,
		// привязанной к объекту {ObjType, ObjID} с идентификатором PropID.
		// Индекс подстроки задается значением Sub.
	static int IdCheckUserID;       // (userID, filtUserID) Проверка на соответствие пользователя userID критерию filtUserID
	static int IdCheckWmsLocID;     // (locID, filtLocID) Проверка на принадлежность локации locID критерию filtLocID.
		// locID принадлежит filtLocID если PPObjLocation::IsMemberOfGroup(locID, filtLocID).
	static int IdTransportTypeName; // (fldTransportTypeID) Строка типа транспортного средства (Автомобиль или судно)
	static int IdLotCloseDate;      //
	static int IdFormatCycle;       // (fldDate, CycleList) Форматирует временной цикл (@>>PPCycleArray::formatCycle)
	static int IdYesWordByFlag;     // (flags, flag) Если flag присутствует в flags, то возвращаем "Да", иначе пустую строку
	static int IdBudgetPlanOrFact;  // (amount, kind, is_fact) Если kind != is_fact, то 0 иначе amount
	static int IdChkOpJActionName;  // (action_id - 0..)
	static int IdAddrCityName;      // (locID)
	static int IdAddrExField;       // (locID, locExFld)
	static int IdCheckCsPosNode;    // (csessID, posNodeID)
	static int IdCheckCsPosNodeList; // (csessID, (const LongArray *))
	static int IdStrExistSubStr;	// @vmiller (fldName, const char *) Определяет, содержит ли строковое поле заданную подстроку
	static int IdAddedCreditLimit;  // (limit, limit_term, added_limit_term)
	static int IdBillFrghtIssueDt;  // (billID)
	static int IdBillFrghtArrvlDt;  // (billID)
	static int IdBillFrghtDlvrAddr; // (billID)
	static int IdGetAgrmntSymbol;   // @vmiller
	static int IdBillAgentName;     // (billID) Наименование агента по документу (извлекается из записи расширения документа)
	static int IdBillStatusName;    // (billID) Наименование статуса документа
	static int IdCheckBillAgent;    // @v12.1.6 (billID, agentID) Определяет, равен ли атрибут 'Agent' документа с идентификатором, равным первому аргументу, значению второго аргумента функции.
	static int IdCheckBillFlag;     // @v12.1.6 (billID, flag) Определяет установку флага (BillTbl::Flags) у документа с заданным идентификатором
	static int IdCheckBillFlag2;    // @v12.1.6 (billID, flag) Определяет установку флага2 (BillTbl::Flags2) у документа с заданным идентификатором
	static int IdRegisterText;      // (registerID) Текст описания регистрационного документа
	static int IdObjRegisterText;   // (registerTypeID, objtype, objid) Текст описания регистрационного документа типа registerTypeID полученного по объекту {objtype, objid}
	static int IdObjTagText;        // (tagid, objid) Текстовое представление тега объекта
	static int IdObjTagText_NoCache; // (tagid, objid) Текстовое представление тега объекта (без посредничества кэша)
	static int IdDateRange;         // (low, upp) Текстовое представление периода
	static int IdOidText;           // (objType, objID) Текстовое представление полного OID
	static int IdDateBase;          // (dateValue, baseDate) Текстовое представление даты, сжатой в виде количества дней, прошедших с baseDate
	static int IdBillFrghtStrgLoc;  // (billID)
	static int IdSCardExtString;    // (scardID, fldId)
	static int IdStrByStrGroupPos;  // (position, (const SStrGroup *)) Возвращает строку из пула строк, идентифицируемую позицией position
	static int IdSubStrById;        // @v12.2.0 (textId, substrIdx) Возвращает нумерованную подстроку строки и идентификатором ресурса textId (see PPGetSubStrById) 
	static int IdBillDate;          // (billID) Дата документа по его идентификатору
	static int IdUnxText;           // (fldObjType, fldObjID, fldTxtProp)
	static int IdIsTxtUuidEq;       // (fldUUID_s, GUID) Определяет эквивалентность строкового представления GUID значению второго аргумента
	static int IdArIsCatPerson;     // @v11.1.9 (fldArticle, personCategoryID) Определяет соотносится ли статья fldArticle с персоналией, имеющей категорию personCategoryID
	static int IdObjMemoPerson;     // @v11.1.12 (fldPersonID)
	static int IdObjMemoPersonEvent; // @v11.1.12 (fldPersonEventID)
	static int IdTechCapacity;      // @v11.3.10 (fldPrcID, fldCapacity)
	static int IdTSessBillLinkTo;   // @v11.6.12 (fldBillID)
	static int IdTSessBillLinkTo_Text; // @v11.6.12 (fldBillID)
	static int IdBillMemoSubStr;    // @v11.7.4 (fldBillID, const char *) Определяет, содержит ли примечание к документу заданную подстроку
	static int IdBillAmount;        // @v12.1.0 (fldBillID, amountType)
	static int IdClientActivityStatisticsIndicator; // @v12.2.2 (personID, actualDate, indicator/*PPObjPerson::casiXXX*/) Возвращает значение индикатора статистики клиентской активности
	static int IdClientActivityState; // @v12.2.2 (personID, LDATE actualDate, LDATE newCliPeriodLo, LDATE newCliPeriodUp) Возвращает ClientActivityState::State

	static int Register();
	static void STDCALL InitObjNameFunc(DBE & rDbe, int funcId, DBField & rFld);
	static void STDCALL InitObjTagTextFunc(DBE & rDbe, PPID tagID, DBField & rFld, int dontUseCache = 0);
	static void STDCALL InitLongFunc(DBE & rDbe, int funcId, DBField & rFld);
	static void STDCALL InitFunc2Arg(DBE & rDbe, int funcId, DBItem & rA1, DBItem & rA2);
	//
	// ARG(incDiv)
	//   Если 0, то результат равен (100 * fld1 / fld2)
	//   Если 1, то результат равен (100 * fld1 / (fld2+fld1))
	//   Если 2, то результат равен (100 * (fld1-fld2) / fld2)
	//
	static void STDCALL InitPctFunc(DBE & rDbe, DBField & rFld1, DBField & rFld2, int incDiv);
	static void STDCALL InitStrPoolRefFunc(DBE & rDbe, DBField & rFld, SStrGroup * pSg);
	//static PPID FASTCALL helper_dbq_name(const DBConst * params, char * pNameBuf);
	static PPID FASTCALL helper_dbq_name(const DBConst * params, char * pNameBuf);
};
//
// Descr: Утилита, используемая для инициализации размера строки, возвращаемой динамической функцией.
//
int STDCALL DbeInitSize(int option, DBConst * result, size_t s);
//
//
//
#define MONEYTOLDBL(m)         dectobin((m),sizeof(m),2)
#define LDBLTOMONEY(ldbl,m)    dectodec((ldbl),(m),sizeof(m),2)
#define MONEYTOMONEY(s,d)      dectodec(dectobin((s),sizeof(s),2),(d),sizeof(d),2)
#define CONFIRM(m)             (PPMessage(mfConf|mfYes|mfNo,m)==cmYes)
#define CONFIRM_S(m,s)         (PPMessage(mfConf|mfYes|mfNo,m,s)==cmYes)
#define CONFIRMCRIT(m)         (PPMessage(mfCritWarn,m)==cmYes)
#define THROW_PP(expr,val)     {if(!(expr)){PPSetError(val);goto __scatch;}}
#define THROW_PP_S(expr,val,s) {if(!(expr)){PPSetError(val,s); goto __scatch;}}
#define THROW_SL(expr)         {if(!(expr)){PPSetErrorSLib();goto __scatch;}}
#define THROW_MEM(expr) {if(!(expr)){PPSetErrorNoMem();goto __scatch;}}
#define THROW_INVARG(expr)     {if(!(expr)){PPSetErrorInvParam();goto __scatch;}}
#define THROW_DB(expr)         {if(!(expr)){PPSetErrorDB();goto __scatch;}}
#define THROW_LXML(expr, ctx) {if(!(expr)){PPSetLibXmlError(ctx);goto __scatch;}}
#define CALLEXCEPT_PP(val)     {PPSetError(val);goto __scatch;}
#define CALLEXCEPT_PP_S(val,s) {PPSetError(val,s); goto __scatch;}
#define CATCHZOKPPERR \
	goto __sendcatch;__scatch:\
	ok = PPErrorZ();\
	__sendcatch:;
#define CATCHZOKPPERRBYDLG \
	goto __sendcatch;__scatch:\
	ok = PPErrorByDialog(this, sel);\
	__sendcatch:;

#define BR2(v) R2(v) // Используется для округления сумм документов
#define TR5(v) R5(v) // Используется для округления цен в Transfer

long STDCALL CheckXORFlags(long v, long f1, long f2);
long STDCALL SetXORFlags(long v, long f1, long f2, long f);
//
// Функции и макросы для профилирования кодов
//
#define USRPROFF_FINISHED 0x00000001L

struct PPUserProfileFileItem {
	S_GUID DbID;
	char   DbSymb[32];
	LDATETIME CrtDtm;
	int64  StartOffs;
	int64  FinishOffs;
};

struct PPUserProfileFile { // @Property
	PPID   ObjType;
	PPID   ObjID;
	PPID   PropID;
	long   Count;
	// PPUserProfileLogOffsItem[Count]
};

struct PPUserProfileFuncEntry {
	static uint16 FASTCALL FromLoggedFuncId(long logFuncId, uint16 * pFuncVer);
	long   GetLoggedFuncId() const;

	enum {
		fFinishOnly = 0x0001, // Для функции не формируется стартовая запись (предполагается гарантированное завершение)
		fAccumulate = 0x0002  // Для функции результаты профилирования накапливаются в аккумуляторе
			// и сбрасываются в журнал время от времени.
	};
	uint16 FuncId;      // @anchor
	uint16 FuncVer;
	uint16 FactorCount;
	uint16 Flags;
	uint32 AccumLimit;
};

class Profile : public SProfile, public SArray {
public:
	explicit Profile(int singleThreaded = 0);
	~Profile();
	void   Output(uint fileId, const char * pDescription);
	void   Start(const char * pFileName, long lineNum, const char * pAddedInfo = 0); // @cs
	void   Finish(const char * pFileName, long lineNum); // @cs
	int    Start(uint logFileId, const char * pName, const char * pAddedInfo = 0);  // @cs
	int    Finish(uint logFileId, const char * pName, const char * pAddedInfo = 0); // @cs
	//uint64 GetAbsTimeMicroseconds(); // @cs
	int    InitUserProfile(const char * pUserName);
	int    SetUserProfileFactor(uint handle, uint factorN, double value);
	double GetUserProfileFactor(uint handle, uint factorN) const;
	//
	// Descr: Возвращает идентификатор функции профилирования, с которой ассоциирован хандлер handle.
	//
	int    FASTCALL GetUserProfileFuncID(uint handle) const;
	uint   FASTCALL StartUserProfileFunc(int funcId);
	int    FASTCALL FinishUserProfileFunc(uint handle);
	int    FlashUserProfileAccumEntries();

	enum {
		fkSession = 1,
		fkStart,
		fkFinish
	};

	SString & GetUserProfileFileName(int fk, SString & rBuf);
private:
	virtual void FASTCALL freeItem(void *);
	ProfileEntry & FASTCALL at(uint) const;
	void * FASTCALL Search(const char * pFileName, long lineNum) const;
	int    Insert(ProfileEntry *, uint * p);
	int    AddEntry(const char * pFileName, long lineNum, int iterOp, const char * pAddedInfo = 0);
	void   Helper_Start(const char * pFileName, long lineNum, const char * pAddedInfo);
	void   Helper_Finish(const char * pFileName, long lineNum);
	//
	// Descr: Блок, хранящий постоянные для потока данные, ради экономии времени на вывод в журналы.
	//
	struct UserProfileStaticBlock {
		S_GUID SessUuid;
		S_GUID DbUuid;
		SString DbSymb;
		SString LogFileName_Start;
		SString LogFileName_Finish;
		SString LogItemPrefix;
	};
	struct UserProfileEntry {
		PPUserProfileFuncEntry Fe;
		int64  Seq;
		uint64 StartClock;
		LDATETIME StartDtm;
		uint64 AccumClock;
		uint64 Accum;
		double Factors[8];
	};
	struct FunctionStartDtm {
		uint   FuncId;
		uint64 StartClock;
		LDATETIME StartDtm;
	};

	UserProfileStaticBlock UPSB;
	TSStack <UserProfileEntry> UserProfileStack;
	TSVector <UserProfileEntry> UserProfileAccum;
	SMtLock Lck;
};

class PPUserFuncProfiler {
public:
	static int Init();
	//
	// Descr: Возвращает имя файла начала или окончания профилировани
	//
	static SString & GetFileName_(int fk /* Profile::fkXXX */, SString & rBuf);
	//
	// Descr: Конструктор. Если funcId != 0, то сразу запускает процесс профилирования функции.
	//   В противном случае должен быть вызван метод Begin() для запуска профилирования.
	//
	explicit PPUserFuncProfiler(int funcId);
	//
	// Descr: Деструктор. Если процесс профилирования был запущен, но не был остановлен методом
	//   Commit(), то останавливает профилирование функции.
	//
	~PPUserFuncProfiler();
	int    operator !() const;
	int    FlashAccumEntries();
	//
	// Descr: Запускает процесс профилирования Функции funcId если он до этого не был запущен.
	//
	int    FASTCALL Begin(int funcId);
	//
	// Descr: Завершает процесс профилирования установленной до этого функции.
	//
	int    Commit();
	int    CommitAndRestart();
	int    SetFactor(uint factorN, double value);
	double GetFactor(uint factorN) const;
private:
	uint   H;
};

#if !defined(DL600C) // {
	#define PROFILE(line) {DS.GProfileStart(__FILE__, __LINE__); line; DS.GProfileFinish(__FILE__, __LINE__);}
	#define PROFILE_S(line, s)   {DS.GProfileStart(__FILE__, __LINE__, s); line; DS.GProfileFinish(__FILE__, __LINE__);}
	#define PROFILE_START        {long _profile_start_ln_num = __LINE__; DS.GProfileStart(__FILE__, _profile_start_ln_num);
	#define PROFILE_START_S(s)   {long _profile_start_ln_num = __LINE__; DS.GProfileStart(__FILE__, _profile_start_ln_num, s);
	#define PROFILE_END          DS.GProfileFinish(__FILE__, _profile_start_ln_num); }
#else
	#define PROFILE(line) line
	#define PROFILE_S(line,s) line
	#define PROFILE_START
	#define PROFILE_START_S(s)
	#define PROFILE_END
	#define PROFILE_END_THR
#endif // } SL_PROFILE
//
// @ModuleDecl(PPSync)
// Модуль блокировки объектов данных
//

//
// Descr: Заголовок файла блокировок
//
struct PPSyncHeader { // @persistent @size=62 (+4 Lock Prefix Size)
	PPSyncHeader();
	long   Magic;          // unique identifier
	long   RecsCount;      // number of records
	int16  Ver;            // Since v4.6.15 Ver=1
	char   Reserved[52];   // @reserve
};

#define PPSYNC_SEMAPHORE  1
#define PPSYNC_MUTEX      2
#define PPSYNC_DBLOCK     3
//
// Descr: Запись файла блокировок
//
struct PPSyncItem { // @persistent @size=66 (+4 Lock Prefix Size)
	PPSyncItem();
	long   ID;             // record id
	long   Type;           // record type (1-Semaphore, 2-Mutex, 3-DbLock, 0-Logout) PPSYNC_XXX
	long   UserID;         // user unique identifier
	char   Name[32];       // user name
	long   ObjType;        // type of semaphore object
	long   ObjID;          // semaphore object identifier.
		// Для типа записи PPSYNC_DBLOCK (пользовательская сессия) значение этого
		// поля может быть 0 или 1. 1 означает, что вход совершен серверной сессией.
	long   Counter;        // semaphore/mutex counter
	MACAddr MchnID;        //
	ulong  TerminalSessID; //
};

typedef TSVector <PPSyncItem> PPSyncArray;
//
// Descr: Класс, управляющий блокировками объектов данных
//
class PPSync {
public:
	PPSync();
	~PPSync();
	int    Init(const char * pDataPath);
	bool   IsValid() const;
	//
	// Descr: Closes file. If database don't locked, then removes sync file.
	// Returns:
	//   1 - Файл был открыт. Функция его успешно закрыла, но не удалила, по-скольку он заблокирован.
	//   2 - Файл был открыт. Функция его успешно закрыла, и удалила.
	//  -1 - Файл не был открыт.
	//
	int    Release();
	int    LoginUser(long userID, const char * pUserName, long * pSessID, const MACAddr * pMachineID, ulong terminalSessID);
	int    LogoutUser(long sessID);
	//
	// Checks is sombody works with database.
	// Returns 1 if database is locked, 0 - otherwise.
	//
	int    IsDBInUse();
	int    GetItemsList(long recType, PPSyncArray *);
	int    GetItem(PPID id, PPSyncItem * pItem);
	int    LockDB();
	int    UnlockDB();
	//
	// Checks is login to database is forbidden.
	// Returns 1 if database is locked, 0 - otherwise.
	//
	int    IsDBLocked();
	int    CreateMutex_(long sessionid, long objtype, long objid, long * pMutexID, PPSyncItem *);
	int    ReleaseMutex(long objtype, long objid);
	int    ReleaseMutex(long mutexid);
	int    ClearMutex(long mutexID);
	int    IsMyLock(long sessID, long objtype, long objid);
	int    GetLockingText(PPID mutexID, int resolveHostName, SString & rBuf);
private:
	SString & GetFileName(SString & rBuf) const;
	int    CreateEmptyFile();
	int    ImplementGetBlock(ulong offs, void * pBuf, int * pIsLocked);
	long   AddRecord(long type, long appID, const char * pName, long, long, ulong * pOffs, const MACAddr * pMachineID, ulong terminalSessID);
	int    Lock(ulong offs, int checkOnly);
	int    FASTCALL Unlock(ulong offs);
	bool   FASTCALL IsLocked(ulong offs);
	int    ReleaseItem(ulong offs);
	int    GetInitPosition(ulong * pOffs, long * pNumItems);
	int    GetHeader(ulong offs, PPSyncHeader *, int * pIsLocked);
	int    GetItem(ulong offs, PPSyncItem *, int * pIsLocked);
	int    FASTCALL AdvanceOffset(ulong * pOffs) const;
	int    GetOffsetByID(long id, ulong * pOffs);
	int    GetFreeEntry(ulong * pOffs, long * pId);
	int    SearchMutexByObj(long objtype, long objid, PPSyncItem * pItem, ulong * pOffs);
	int    ReleaseSessionMutex(long sessID);
	int    FASTCALL CheckOffset(ulong offs) const;

	int    Handle;
	int    NoSHARE; // if !0 then share.exe not loaded (DOS)
	SString DataPath;
};
//
// Backing up
//
struct PPBackupScen { // @flat // @persistent
	PPBackupScen();
	PPBackupScen & Z();
	bool   FASTCALL IsEq(const PPBackupScen & rS) const;
	bool   ValidateValue_MaxCopies() const { return (MaxCopies > 0 && MaxCopies <= 1000); }
	bool   NormalizeValue_MaxCopies();
	int    ToStr(SString & rBuf) const;
	long   ID;
	long   Period;     // Backup period (days)
	long   Flags;      // Reserved
	uint32 MaxCopies;  // Max number of copies // @v12.1.8 long NumCopies-->uint32 MaxCopies
	char   Name[64];
	char   DBName[64];
	char   BackupPath[261]; // абсолютное значение (не макрос) из-за @persistent
};

class PPBackup : public DBBackup {
public:
	static PPBackup * CreateInstance(const PPDbEntrySet2 *);
	static int GetScenList(const char * pDbSymb, DbProvider * pDbp, TSVector <PPBackupScen> & rList);
	static int GetDefaultScen(DbProvider * pDbp, PPBackupScen * pScen);
	static int GetDefaultBackupPath(DbProvider * pDbp, SString & rBuf);
	PPBackup(const char * pDbName, DbProvider * pDb);
	~PPBackup();
	bool   IsValid() const;
	int    EnumScen(long * pIdx, PPBackupScen * pScen);
	int    GetScen(long ide, PPBackupScen * pScen);
	int    GetScenBySymb(const char * pSymb, PPBackupScen * pScen);
	int    GetLastScenCopy(PPBackupScen * pScen, BCopyData *);
	//
	// Descr: пытается заблокировать БД для входа. Если ей это удалось сделать,
	//   то возвращается (>0) в противном случае функция выдает на экран запрос
	//   на ожидание возможности заблокировать БД. Если пользователь отвечает
	//   отрицательно или прерывает ожидание, то возвращается (<0). В случае ошибки возвращается 0.
	//
	int    LockDatabase();
	void   UnlockDatabase();
private:
	//int    GetScenList(SArray *);
	virtual int CBP_CopyProcess(const char * pSrcFile, const char * pDestFile, int64 totalSize, int64 fileSize, int64 totalBytesReady, int64 fileBytesReady);
	enum {
		stValid      = 0x0001,
		stDbIsLocked = 0x0002
	};
	long   State;
	char   DBName[64];
	//SArray * P_ScenList;
	TSVector <PPBackupScen> * P_ScenList2;
	PPSync * P_Sync;
};
//
// PPMsgLog
//
#define LF_BUFFSIZE  4096
#define LF_MAXMSG    1000
#define LF_DONTWRITE 0x00010000l
#define LF_SHOW      0x00020000l
#define LF_MODAL     0x00040000l

struct PPLogIdx {
	long   flags;
	long   address;
};
//
// PPMsgLog::SaveLogFile options
//
#define SAVELOGF_OVERWRITE  0x0001L
#define SAVELOGF_APPEND     0x0002L

#define LOGLIST_MAXSTRLEN   256

struct MsgLogItem {
	char   LogListStr[LOGLIST_MAXSTRLEN];
};

class PPMsgLog {
public:
	//
	// Descr: Удаляет все файлы, сформированные логгером и не удаленные из-за аварийного прерывания сеанса.
	//
	static int RemoveTempFiles();

	PPMsgLog();
	virtual ~PPMsgLog();
	long   GetCount() const;
	long   GetCurMsg() const;
	long   GetVisCount() const;
	// -1 - error code
	// 0 - no action
	long   PutMessage(const char * pBody, long flags = 0, const void * head = 0, size_t hsize = 0);
	long   Init();
	void   DeleteVisibleMessage(long row);
	int    SaveLogFile(const char *, long flags);
	int    Print();
	int    InitIteration();
	int    FASTCALL NextIteration(MsgLogItem *);
	virtual int ShowLogWnd(const char * pTitle = 0);
	//
	// If nmsg>0 - search message with No=nmsg
	// If nmsg=0 - search next message
	// Return 0 - end of search
	// > 0 - message number
	//
	long   EnumMessages(long nmsg, void * buff, int16 bsize, int16 *retsize, int16 *hsize);
	long   GetVisibleMessage(long nrow);
	void * GetRow(long r);
protected:
	virtual  long  ImplPutMsg(const char * pText, long flags);
	void   Destroy();
	PPLogIdx GetLogIdx(long);
	void   SetLogIdx(long, const PPLogIdx * pLi);

	long   CurMsg;
	char   TmpText[LF_BUFFSIZE];
	long   Valid;
	long   AllCount;
	SString FileName;
	SString InFileName;
	int    Stream;
	int    InStream;
	SArray * P_Index;
	int    NextStrOffset;
};

class PPLogger {
public:
	enum {
		fDisableOutput = 0x0001,
		fDisableWindow = 0x0002,  // @v10.6.8 Если установлен, то не отображается окно с данными вывода
		fStdErr        = 0x0004   // @v11.8.3 Выводить данные в stderr. Этот флаг отменяет все остальные варианты вывода.
	};
	PPLogger();
	explicit PPLogger(long flags);
	~PPLogger();
	int    FASTCALL Log(const char * pMsg);
	int    LogMsgCode(uint msgOptions, uint msgId, const char * pAddedInfo);
		// @>>PPGetMessage(msgOptions, msgId, pAddedInfo, ...)
	int    LogSubString(uint strID, int idx);
	int    LogString(uint strId, const char * pAddedInfo);
	int    LogAcceptMsg(PPID objType, PPID objID, int upd);
		// @>>PPObject::GetAcceptMsg
	int    LogLastError();
	int    Save(const char * pFileName, long options); // @>>PPMsgLog::SaveLogFile
	int    Save(uint fileId, long options); // @>>PPMsgLog::SaveLogFile
	void   Clear();
private:
	long   Flags;
	PPMsgLog * P_Log;
};
//
// Descr: Специализированный класс, используемый как базовый для управления внешним или собственным логгером.
//
class PPEmbeddedLogger {
protected:
	enum {
		ctrfDirectLogging = 0x0001
	};

	PPEmbeddedLogger(long ctrflags, PPLogger * pOuterLogger, uint fileNameId, uint defLogOptions);
	~PPEmbeddedLogger();
	void   FASTCALL Log(const SString & rMsg);
	void   LogTextWithAddendum(int msgCode, const SString & rAddendum);
	void   LogLastError();
	int    Save(uint fileNameId, long options);
private:
	enum {
		elstOuterLogger   = 0x0001,
		elstDirectLogging = 0x0002
	};
	long    ElState;
	uint    LogFileNameId;
	long    DefLogOptions;
	PPLogger * P_Logger;
};
//
// Descr: Опции функция вывода в журнал
//
#define LOGMSGF_TIME        0x0001L // Выводить текущее время //
#define LOGMSGF_USER        0x0002L // Выводить имя активного пользователя //
#define LOGMSGF_LASTERR     0x0004L // Выводить текст сообщения о последней ошибке @#{pStr == 0}
#define LOGMSGF_DBINFO      0x0008L // Выводить символ базы данных
#define LOGMSGF_COMP        0x0010L // Выводить имя компьютера
#define LOGMSGF_UNLIMITSIZE 0x0020L // Размер файла не лимитирован
#define LOGMSGF_THREADINFO  0x0040L // Сообщение заносится в информационный буфер потока (для отображения в мониторах)
#define LOGMSGF_THREADID    0x0080L // Выводить идент потока
#define LOGMSGF_DIRECTOUTP  0x0100L // Сообщение выводится без посредничества специального потока, управляющего выводом в журналы
#define LOGMSGF_NODUPFORJOB 0x0200L // Сообщение не следует дублировать в спец журнале для рассылки результатов выполнения задач
#define LOGMSGF_SLSSESSGUID 0x0400L // Выводить GUID сессии
#define LOGMSGF_UTF8        0x0800L // @v11.6.11 Текст в файле журнала сохранять в кодировке utf-8
#define LOGMSGF_LASTERR_TIME_USER (LOGMSGF_LASTERR|LOGMSGF_TIME|LOGMSGF_USER) // @v11.9.6

int STDCALL PPLogMessage(const char * pFileName, const char * pStr, long options);
int STDCALL PPLogMessage(uint fileNameId, const char * pMsg, long options);
int STDCALL PPLogMessageList(uint fileNameId, const SStrCollection & rList, long options);
int STDCALL PPLogMessage(uint fileId, uint strGroup, uint strId, long options);
//
//
//
#if 0 // @v12.2.10 replaced with SObjID_Base {
class PPObjID_Base { // @flat @noctr @persistent
public:
	PPObjID_Base Set(PPID objType, PPID objID);
	PPObjID_Base & Z();
	bool   IsZero() const;
	bool   IsFullyDefined() const { return (Obj && Id); }
	bool   IsEq(PPID objType, PPID objID) const;
	bool   FASTCALL operator == (PPObjID_Base s) const;
	bool   FASTCALL operator != (PPObjID_Base s) const;
	double ToDouble() const;
	bool   FromDouble(double oid);
	operator double() const;
	PPObjID_Base & FASTCALL operator = (double);
	//
	// GOODS(1204)
	//
	SString & FASTCALL ToStr(SString & rBuf) const;
	int    FASTCALL FromStr(const char * pStr);

	PPID   Obj;
	PPID   Id;
};
#endif // } 0 @v12.2.10 replaced with SObjID_Base

#if 0 // @v12.2.10 replaced with SObjID {
class PPObjID : public PPObjID_Base { // @flat @persistent
public:
	PPObjID();
	PPObjID(const PPObjID_Base & rS);
	PPObjID(PPID objType, PPID objID);
	PPObjID & FASTCALL operator = (const PPObjID_Base & rS);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v11.7.0
};
#endif // } 0 @v12.2.10 replaced with SObjID

typedef SObjID_Base PPObjID_Base;
typedef SObjID PPObjID;

SString & SObjID_ToStr(const SObjID & rOid, SString & rBuf);
int   SObjID_FromStr(const char * pStr, SObjID & rOid);

/*class PPObjID : public SObjID {
public:
	PPObjID() : SObjID()
	{
	}
	PPObjID(int32 objType, int32 objID) : SObjID(objType, objID)
	{
	}
	SString & FASTCALL ToStr(SString & rBuf) const;
	int    FASTCALL FromStr(const char * pStr);	
};*/

//
// Descr: Специализированная структура, используемая для индексации наименований
//   объектов данных в строковых пулах.
//
struct PPObjNamePEntry : public PPObjID {
	PPObjNamePEntry(PPID objType, PPID objID);
	uint   NameP;
};

class PPObjIDArray : public TSVector <PPObjID> {
public:
	friend class PPObjectTransmit;
	PPObjIDArray();
	bool   Search(PPObjID key, uint * pPos) const;
	int    Add(PPID objType, PPID objID);
	int    Add(PPID objType, const PPIDArray & rList);
	int    Add_NotPreprocess(PPID objType, PPID objID);
	int    FASTCALL Is_NotPreprocess_Pos(uint pos) const;
	int    ProcessRef(PPID objType, PPID * pObjID);
	PPObjIDArray & SortAndUndup();
private:
	int    DoReplace; // @transient
	LongArray DontPreprocPosList; // @transient Список позиций, которые не должны обрабатываться //
		// функцией PPObjectTransmit::RestoreObj() при приеме данных из другого раздела.
};
//
// ObjRestrictArray
//
// Descr: Список, позволяющий хранить ссылки на объекты с дополнительными флагами. Тип объектов определяется неявно
//   использующим контекстом.
//   Используется в правах доступа, обобщенных объектах и др.
// @todo DATE:12/06/2004 Объединить с LAssocArray
//
struct ObjRestrictItem { // @flat
	ObjRestrictItem();
	ObjRestrictItem(PPID objID, long flags);
	PPID   ObjID;
	long   Flags;
};

class ObjRestrictArray : public TSVector <ObjRestrictItem> {
public:
	ObjRestrictArray();
	ObjRestrictArray(const ObjRestrictArray &);
	ObjRestrictArray & FASTCALL operator = (const ObjRestrictArray &);
	bool   FASTCALL IsEq(const ObjRestrictArray & rS) const { return SVector::IsEq(rS); /* Items are @flat so we can use it here */ }

	enum {
		moEmptyListIsFull = 0x0001 // Пустой список дает все доступные права
	};

	int    Merge(const ObjRestrictArray * pS, long options);
	int    Add(PPID objID, long flags, uint * pPos);
	//
	// Returns:
	//   0  - В списке уже есть элемент с идентификатором id
	//   !0 - В списке нет элемента с идентификатором id.
	//
	bool   FASTCALL CheckUniqueID(PPID id) const;
	int    UpdateItemByID(PPID id, long flags);
	int    FASTCALL RemoveItemByID(PPID id);
	bool   SearchItemByID(PPID id, uint * pPos) const;
	bool   CheckFlag(PPID id, long flag) const;
private:
	int    FASTCALL Helper_MergeItems(const ObjRestrictArray * pS);
};
//
// Общие флаги доступа (первые восемь бит зарезервированы как общие)
//
#define PPR_READ        0x0001
#define PPR_INS         0x0002
#define PPR_MOD         0x0004
#define PPR_DEL         0x0008
#define PPR_ADM         0x0010
//
// @v10.7.9 Специальные права доступа динамических объектов
//
#define DYNOBJRT_RMVALL 0x0100 // Удаление всей выборки объектов
//
// Последние два операционных бита зарезервированы
//
#define PPORF_INHERITED 0x4000 // Структура унаследована от вышестоящего объекта
#define PPORF_DEFAULT   0x8000 // Права установлены по умолчанию (не из БД)
//
// Descr: Дескриптор прав доступа по объекту данных
// Note: Variable length struct
//
class ObjRights { // @persistent
public:
	static ObjRights * Create(PPID objType, size_t totalSize);
	static void FASTCALL Destroy(ObjRights * pObj);
	explicit ObjRights(PPID objType = 0);
	bool   FASTCALL IsEq(const ObjRights & rS) const;

	PPID   ObjType;
	uint16 Size;
	uint16 Flags;
	long   OprFlags;
	// ... [Size - sizeof(ObjRights)];
};

struct PPAccessRestriction { // @transient (translated for storage to PPRights)
public:
	enum {
		pparR = 1,
		pparW
	};
	enum {
		cfStrictOnlyGoodsGrp      = 0x0001,  // Строгое ограничение на товарную группу OnlyGoodsGrpID
		cfDesktopCr       = PPR_INS, // (0x0002) Возможнось создавать рабочие столы
		cfDesktopMod      = PPR_MOD, // (0x0004) Возможность изменять рабочие столы
		//
		// -- Если (CFlags & (cfOwnBillRestr|cfOwnBillRestr2)) == cfOwnBillRestr
		//    то доступ ограничен только теми документами, которые пользователь сам создал
		// -- Если (CFlags & (cfOwnBillRestr|cfOwnBillRestr2)) == cfOwnBillRestr2
		//    то доступ ограничен только теми документами, которые созданы либо
		//    самим пользователем, либо пользователями, входящими в ту же группу, что
		//    и данный пользователь.
		//
		cfOwnBillRestr    = 0x0008,
		cfOwnBillRestr2   = 0x0010,
		cfApplyBillPeriodsToCSess = 0x0020, // Применять периоды доступа к документам и к кассовым сессиям
		cfAllowDbxReceive = 0x0040  // @v10.5.7 Допускает прием данных из других разделов. На начальном этапе флаг имеет ограниченное
			// действие только для автоматической синхронизации, транспортируемой посредство брокера сообщений.
	};
	PPAccessRestriction();
	int    GetRBillPeriod(DateRange *) const;
	int    GetWBillPeriod(DateRange *) const;
	int    SetBillPeriod(const DateRange * pPeriod, int setROrW);
	int    GetPeriodInputExt(TDialog * pDlg, uint ctrlID, int setROrW);
	int    SetPeriodInputExt(TDialog * pDlg, uint ctrlID, int getROrW) const;
	int    GetOwnBillRestrict() const;
	void   SetSaveMode(int saveData);

	LTIME  TimeBeg;       // Допустимое начало рабочей сессии (0..23:59:59)
	LTIME  TimeEnd;       // Допустимый конец рабочей сессии
	ushort WeekDays;      // Допустимые дни работы (биты: 0 - вскр, 1 - пнд ...)
	short  PwMinLen;      // Минимальная длина пароля //
	short  PwPeriod;      // Продолжительность действия пароля (дней)
	short  AccessLevel;   // Уровень доступа
	long   CFlags;        // Общие флаги прав (PPAccessRestriction::cfXXX)
	PPID   OnlyGoodsGrpID; // Единственная товарная группа, товары которой доступны для анализа
private:
	DateRange RBillPeriod;  // Период, в течении которого R-доступ к документам разрешен
	DateRange WBillPeriod;  // Период, в течении которого W-доступ к документам разрешен
	int    ShowInnerDates; // В GetR(W)BillPeriod подставлять даты так, как они хранятся //
};

class PPRights {
public:
	static ushort GetDefaultFlags();
	static long   GetDefaultOprFlags();

	PPRights();
	PPRights(const PPRights & rS);
	~PPRights();
	int    FASTCALL Copy(const PPRights & rS);
	PPRights & FASTCALL operator = (const PPRights & rS);
	bool   FASTCALL IsEq(const PPRights & rS) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	size_t Size() const;
	PPRights & Z();
	bool   IsEmpty() const;
	int    IsInherited() const;
	int    Merge(const PPRights & rS, long flags);
	int    Put(PPID securType, PPID securID);
	int    Get(PPID securType, PPID securID, int ignoreCheckSum/*= 0*/);
	int    Remove(PPID securType, PPID securID);
	//
	// Descr: Возвращает указатель на дескриптор прав доступа по объекту objType.
	//   ! Возвращенный указатель должен быть освобожден вызывающей функцией !
	//   (delete p_rights)
	// ARG(objType    IN): Тип объекта, для которого необходимо получить дескриптор прав
	// ARG(useDefault IN): Если !0 и собственной записи прав доступа для типа объектов objType
	//   нет, то функция создаст дескриптор по умолчанию.
	//
	ObjRights * GetObjRights(PPID objType, int useDefault = 0) const;
	const ObjRights * GetConstObjRights(PPID objType, ObjRights * pDef = 0) const;
	//
	// Descr: устанавливает новые права доступа к объекту objType.
	//   Если rt == 0, то права доступа для этого объекта удаляются.
	//   Если replace == 0 и в структуре уже имеются права для заданного
	//   объекта, то они не заменяются на новые.
	//
	int    SetObjRights(PPID objType, const ObjRights * rt, int replace = 1);
	PPAccessRestriction & GetAccessRestriction(PPAccessRestriction & rAcsr) const;
	int    SetAccessRestriction(const PPAccessRestriction *);
	//
	// Descr: Проверяет доступность даты dt для работы с документом.
	//   Если forRead == 0, то проверяется возможность записи, в противном
	//   случае проверяется возможность чтения.
	// Returns:
	//   !0 - дата dt доступна (если forRead, то на чтение).
	//   0  - дата dt не доступна.
	//
	int    CheckBillDate(/*LDATE dt*/const BillTbl::Rec & rRec, int forRead = 0) const;
	int    AdjustBillPeriod(DateRange & rPeriod, int checkOnly) const;
	int    AdjustCSessPeriod(DateRange & rPeriod, int checkOnly) const;
	int    IsOpRights() const;
	int    IsLocRights() const;
	int    ExtentOpRights();
	int    MaskOpRightsByOps(const PPIDArray * pOpList, PPIDArray * pResultOpList) const;
	int    MaskOpRightsByTypes(const PPIDArray * pOpTypeList, PPIDArray * pResultOpList) const;
	int    CheckOpID(PPID, long) const;
	int    CheckLocID(PPID, long) const;
	int    CheckPosNodeID(PPID id, long flags) const;
	int    CheckQuotKindID(PPID id, long flags) const;
	int    CheckAccID(PPID, long) const;
	int    CheckDesktopID(long deskID, long rt) const;

	ObjRestrictArray * P_OpList;   // Доступные операции
	ObjRestrictArray * P_LocList;  // Доступные склады
	ObjRestrictArray * P_CfgList;  // Список доступных конфигураций
	ObjRestrictArray * P_AccList;  // Список доступный счетов. Элемент с ид = 0 - для счетов отсутствующих в списке
	ObjRestrictArray * P_PosList;  // Список доступных кассовых узлов
	ObjRestrictArray * P_QkList;   // Список доступных видов котировок
private:
	ulong  CheckSum();
	int    Resize(uint);
	int    ReadRights(PPID securType, PPID securID, int ignoreCheckSum);
	int    SerializeArrayPtr(int dir, ObjRestrictArray ** ppA, SBuffer & rBuf, SSerializeContext * pSCtx);

	_PPRights * P_Rt;
};

int    ParseBound(const char * pBuf, long * pVal);
//
// Descr: Класс, управляющий ini-файлами
//
class PPIniFile : public SIniFile {
public:
	static int   FASTCALL GetSectSymb(int idx, SString & rBuf);
	static int   FASTCALL GetParamSymb(int idx, SString & rBuf);

	explicit PPIniFile(const char * pFileName, int fcreate = 0, int winCoding = 0, int useIniBuf = 0);
	PPIniFile();
	~PPIniFile();
	int    GetEntryList(uint sectId, StringSet * pEntries, int storeAllString = 0);
	int    Get(uint sectId, uint paramId, SString & rBuf);
	int    Get(uint sectId, const char * pParamName, SString & rBuf);
	int    Get(const char * pSectName, uint paramId, SString & rBuf);
	int    GetInt(uint sectId, uint paramId, int *);
	int    GetInt(const char * pSectName, uint paramId, int *);
	//
	// Descr: Возвращает значение параметра [pSectName] paramId заданное как
	//   размер данных в байтах. В ini-файле значение может быть задано как просто в байтах,
	//   так и с указанием единицы измерения в формате 9999UNIT где 9999 - не отрицательное целое число, а
	//   UNIT одно из следующих сокращений: b, kb, k, m, mb, g, gb (регистр символов не важен).
	//
	int    GetDataSize(const char * pSectName, uint paramId, int64 * pSz);
	int    GetDataSize(uint sectId, uint paramId, int64 * pSz);
	int    Append(uint sectId, uint paramId, const char * pVal, int overwrite);
	int    IsWinCoding();
	int    Backup(uint maxCopies = 5);
	int    UpdateFromFile(const char * pSrcFileName);
private:
	static void STDCALL ParamIdToStrings(uint sectId, uint paramId, SString * pSectName, SString * pParam);
};
/* @v11.4.4 (replaced with PPConst::WrKey_XXX)
class PPRegKeys {
public:
	static const char * PrefSettings;          // @defined(ppappo.cpp) "Software\\Papyrus\\Pref"
	static const char * PrefBasketSelSettings; // @defined(ppappo.cpp) "Software\\Papyrus\\Pref\\BasketSel"
	static const char * SysSettings;           // @defined(ppappo.cpp) "Software\\Papyrus\\System"
	static const char * Sessions;              // @defined(ppappo.cpp) "Software\\Papyrus\\Sessions"
};*/
//
//
//
class PPConfigDatabase {
public:
	enum {
		tExport = 1,
		tImport,
		tMenu,
		tDesktop,
		tJob
	};
	//
	// Descr: Заголовочная структура объекта конфигурации, хранящегося в базе данных.
	//   Уникальными комбинациями структуры являются {ID} и {Type, Name, DbSymb, OwnerSymb}
	//
	struct CObjHeader {
		CObjHeader();
		int    Cmp(const CObjHeader & rS, long flags) const;

		int32  ID;         //
		int32  Ver;        //
		int32  Type;       //
		int32  Flags;      //
		SString Name;      // Наименование конфигурации
		SString SubSymb;   // Уточняющая строка.
			// tExport:  символ внутренней структуры данных
			// tImport:  символ внутренней структуры данных
			// tMenu:    none
			// tDesktop: none
			// tJob:     символ команды
		SString DbSymb;    // Символ базы данных, к которой относится конфигурация (может быть пустым)
		SString OwnerSymb; // Символ владельца конфигурации. Конкретный смысл зависит от типа записи (может быть пустым)
	};
	struct CItemHeader {
		int32  ID;
		int32  ObjID;
		SString Name;
	};
	class StringHistoryPool : public SStrGroup {
	public:
		//
		// Descr: Опции поиска текста
		//
		enum {
			sefSubString  = 0x0000,
			sefFullString = 0x0001,
			sefFromBegin  = 0x0002
		};
		explicit StringHistoryPool(const char * pKey);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		const  SString & GetKey() const;
		int    Add(const char * pTextUtf8);
		int    Get(const char * pSubUtf8, long flags, StringSet & rList) const;
		int    GetRecent(uint maxItems, StringSet & rList) const;
		int    BuildHash();
		//
		// Descr: Сливает экземпляр this с rS. При этом изменяется rS, this остается
		//   неизменным (функция non-const из-за того, что должна вызвать Ht.BuildAssoc).
		//
		int    Merge(StringHistoryPool & rS);
		int    FASTCALL CmpEntryIndices(const void * p1, const void * p2) const;
		//
		// Descr: Устанавливает внутреннее состояние, фиксирующее факт сохранения пула в базе данных
		//
		void   OnSave();
		int    IsSavingNeeded() const;
	private:
		int    SearchEntries(const char * pSubUtf8, long flags, LongArray & rPosList) const;
		struct InnerEntry {
			LDATETIME Dtm;
			uint32 UsageCount;
			uint32 OrgUsageCount; // Значение UsageCount которое было в записи при считывании из БД
			uint   TextP;
			//uint   TextCiP;
		};
		SString Key;
		TSVector <InnerEntry> L; // Порядок элементов в массиве не меняется (на номер элемента ссылается символ в хэше Ht)
		SymbHashTable Ht;
		struct State {
			State() : Dirty(0), LastSaveTm(ZERODATETIME)
			{
			}
			int    Dirty;
			LDATETIME LastSaveTm; // Время последнего сохранения пула в базе данных
		};
		State St; // @transient
	};

	explicit PPConfigDatabase(const char * pDbDir);
	~PPConfigDatabase();
	int    Open(const char * pDbPath);
	void   Close();
	int    GetObjList(int type, const char * pSubSymb, const char * pDbSymb, const char * pOwner, StrAssocArray & rList);
	int    GetObj(int32 id, CObjHeader * pHdr, SBuffer * pData);
	int    GetObj(CObjHeader & rHdr, int32 * pID, SBuffer * pData);
	int    PutObj(int32 * pID, CObjHeader & rHdr, SBuffer & rData, int use_ta);
	int    DeleteObj(int32 id, int use_ta);
	const  StringHistoryPool * GetStringHistoryPool(const char * pKey);
	int    AddStringHistory(const char * pKey, const char * pTextUtf8);
	int    GetStringHistory(const char * pKey, const char * pSubUtf8, long flags, StringSet & rList);
	int    GetRecentStringHistory(const char * pKey, uint maxItems, StringSet & rList);
	int    LoadStringHistory(StringHistoryPool & rPool);
	int    SaveStringHistory(StringHistoryPool * pPool, int use_ta);
private:
	class CObjTbl : public BDbTable {
	public:
		explicit CObjTbl(BDbDatabase * pDb);
		~CObjTbl();
		int    SerializeKeyBuf(int dir, CObjHeader * pKey, SBuffer & rBuf);

		long   SeqID;
	private:
		virtual int Implement_Cmp(const BDbTable::Buffer * pKey1, const BDbTable::Buffer * pKey2);
	};
	class CObjTailTbl : public BDbTable {
	public:
		explicit CObjTailTbl(BDbDatabase * pDb);
		~CObjTailTbl();
	};
	class StringHistoryTbl : public BDbTable {
	public:
		explicit StringHistoryTbl(BDbDatabase * pDb);
		~StringHistoryTbl();
	};
	BDbDatabase * P_Db;
	CObjTbl * P_OT;
	CObjTailTbl * P_OtT;
	StringHistoryTbl * P_ShT; // @v10.7.6
	TSCollection <StringHistoryPool> ShL; // @v10.7.6
};
//
// Параметры подстановки объектов для получения агрегированных отчетов
// Строки соответствующие SubstGrpGoods: PPTXT_SUBSTGOODSLIST
//
enum SubstGrpGoods { // @persistent
	sggNone = 0,           //
	sggGeneric,            // PPObjGoods      Обобщенный товар
	sggGroup,              // PPObjGoodsGroup Обыкновенная товарная группа
	sggManuf,              // PPObjPerson     Производитель
	sggDimX,               // Размерность X
	sggDimY,               // Размерность Y
	sggDimZ,               // Размерность Z
	sggClsKind,            // Классификатор Kind
	sggClsGrade,           // Классификатор Grade
	sggClsAddObj,          // Классификатор AddObj
	sggClsKind_Grade,      // Классификаторы Kind-Grade
	sggSuppl,              // PPObjArticle  Поставщик
	sggBrand,              // PPObjBrand    Торговая марка
	sggClsKind_Grade_AddObj, // Классификаторы Kind-Grade-AddObj
	sggClsKind_AddObj_Grade, // Классификаторы Kind-AddObj-Grade
	sggSupplAgent,         // PPObjArticle  Агент поставщика
	sggLocation,           // PPObjLocation Склад
	sggBrandOwner,         // PPOBJ_PERSON(PPPRK_MANUF)
	sggVatRate,            // Ставка НДС в ценах реализации
	sggCVatRate,           // Ставка НДС в ценах поступления
	sggAlcoCategory,       // Категория алкогольной продукции по классификации РосАлкогольРегулирования
		// Доступно только в случае, если правильно определена конфигруация алкогольной декларации
	sggDimW,               // Размерность W
	sggLocAssoc,           // Ассоциированное с товаром место хранения //
	sggType,               // Тип товара
	sggGroupSecondLvl = 100,   // PPObjGoodsGroup Группа уровня 2 и далее идут группы уровня 2 и т.д.
	sggTagBias        = 100000 // Смещение для группировки по тегам товаров.
};
//
// Строки соответствующие SubstGrpDate: PPTXT_SUBSTDATELIST
//
enum SubstGrpDate {
	sgdNone = 0,
	sgdWeek,
	sgdMonth,
	sgdQuart,
	sgdYear,
	sgdHour,    // для совместимости добавлены последними
	sgdWeekDay  // если нужно использовать эти 2 параметра, то в ComboBox должна грузиться строка PPTXT_SUBSTDATELISTEXT
};
//
// Строки соответствующие SubstGrpPerson: PPTXT_SUBSTPERSONLIST
//
enum SubstGrpPerson {
	sgpNone = 0,
	sgpCity,           // Город
	sgpRegion,         // Регион
	sgpCountry,        // Государство
	sgpCategory,       // Категория персоналии
	//
	// За подстановку вместо персоналии агента по документу и транспортного брокера функция PPObjPerson::Subst не
	// отвечает. О правильности такой подстановки должен позаботиться класс, отвечающий
	// за перебор объектов, в которых необходимо осуществить подстановку.
	//
	sgpBillAgent,      // Агент по документу
	sgpVesselAgent,    // Транспортный брокер
	sgpAccSheet,       // Таблица статей аналитического учета
	sgpFirstRelation = 10000,
		// 10001 начиная с этого значения, типы отношений персоналий
		// Строки соответствующие типам отношений не указаны в PPTXT_SUBSTPERSONLIST
		// и заносятся в строки для combobox'а динамически
	sgpArticleMask   = 0x8000000 // Маска, индицирующая то, что идентификатор для подстановки является статьей, а не персоналией.
};

#define IS_SGG_CLSSUBST(x) oneof10(x, sggDimX, sggDimY, sggDimZ, sggDimW, sggClsKind, sggClsGrade,\
	sggClsAddObj, sggClsKind_Grade, sggClsKind_Grade_AddObj, sggClsKind_AddObj_Grade)
//
// Строки соответствующие SubstGrpSCard: PPTXT_SUBSTSCARDLIST
//
enum SubstGrpSCard {
	sgcNone = 0,
	sgcSeries,
	sgcOwner
};
//
// Descr: Варианты подстановки атрибута документа
//
struct SubstGrpBill { // @size=8
	SubstGrpBill();
	void   Reset();
	int    operator !() const;

	enum _S {
		sgbNone = 0,
		sgbOp,
		sgbDate,
		sgbLocation,
		sgbObject,
		sgbObject2,
		sgbStatus,
		sgbAgent,
		sgbPayer,
		sgbDebtDim,    //
		sgbStorageLoc, // Место хранения, ассоциированное с фрахтом документа
		sgbDlvrLoc     // Адрес доставки
	} S;
	union {
		SubstGrpDate   Sgd;
		SubstGrpPerson Sgp;
	} S2;
};

/* @v10.7.8 (@unused) class BillSubstList {
public:
	struct Item {
		PPID   BillID;
	};
	BillSubstList();
	int    AddItem(const BillSubstList::Item * pItem, PPID * pID);
	int    GetItem(PPID id, BillSubstList::Item * pItem) const;
private:
	SArray List;
	LAssocArray * P_AsscList;
};*/
//
// Descr: Внешнее представление элемента списка PPViewDisplayExtList
//   Схема нумерации идентификаторов данных:
//     1..1000 - зарезервировано за существующими полями (определенными в броузерах ppbrow.rc2)
//     1001..100000 - доступный для использования диапазон
//     100001.. - специальный диапазон для динамически заданных полей с использованием специальных комбинаций (например, тип т'га)
//
struct PPViewDisplayExtItem {
	int    DataId;   // Идентификатор данных для отображения.
	int    Position; // Позиция в таблице. 0 - на усмотрение отображающего класса, -1 - последней колонкой, >0 - явно заданное значение.
	SString Title;   // Заголовок колонки. Если строка пустая, то - на усмотрение отображающего класса.
};
//
// Descr: Класс PPViewDisplayExtList представляющий список (дополнительных) полей для отображения в
//   в таблицах объектов PPView. экземпляр класса следует хранить в фильтре.
//
class PPViewDisplayExtList : private SStrGroup {
public:
	PPViewDisplayExtList();
	PPViewDisplayExtList & Z();
	bool   FASTCALL IsEq(const PPViewDisplayExtList & rS) const;
	int    SetItem(int dataId, int position, const char * pTitle);
	int    GetItemByPos(uint pos, PPViewDisplayExtItem * pItem) const;
	int    GetItemByDataId(int dataId, PPViewDisplayExtItem * pItem) const;
	int    RemoveItem(int dataId);
	int    Pack();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);
private:
	int    SearchItem(int dataId, uint * pPos) const;

	struct InnerItem { // @persistent
		int32  DataId;
		int32  Position;
		uint   TitleP;
		uint8  Reserve[16];
	};
	TSVector <InnerItem> L;
};
//
// Descr: Базовый класс для определения фильтров
//
class PPBaseFilt { // @persistent
public:
	static const char * P_TextSignature; // "#TFD";
	//
	// Флаги "врожденных" особенностей фильтра (Capability)
	//
	enum {
		cFlat = 0x0001 // Фильтр является "плоским" (то есть не содержит указателей и прочих отростков)
	};
	//
	// Descr: Служебная функция, создающая копию фильтра pSrcFilt по указателю **ppDestFilt.
	//   Тип фильтра определяется аргументом filtId.
	//   Если pSrcFilt == 0, то *ppDestFilt разрушается (если не нулевой) и обнуляется.
	//
	static int CopyBaseFiltPtr(int filtId, const PPBaseFilt * pSrcFilt, PPBaseFilt ** ppDestFilt);
	DECL_INVARIANT_C();
	PPBaseFilt(long signature, long capability, int32 ver);
	virtual ~PPBaseFilt();
	virtual int Init(int fullyDestroy, long extraData);
	virtual int Write(SBuffer &, long) const;
	virtual int Read(SBuffer &, long);
	virtual int Copy(const PPBaseFilt *, int);
	//
	// Descr: Эта функция должна сравнить фильтры и, если они эквивалентны,
	//   вернуть значение >0.
	//
	virtual bool IsEq(const PPBaseFilt *, int) const;
	virtual bool IsEmpty() const;
	//
	// Descr: описание внутреннего состояния фильтра
	//
	virtual int Describe(long flags, SString & rBuf) const;
	//
	// Descr: Проверяет соответствие между фильтром this и pS по сигнатуре.
	//   Метод используется для идентификации "подлога". То есть, выявлени
	//   факта передачи под видом PPBaseFilt не того типа фильтра,
	//   который ожидает некоторая функция.
	//
	int    FASTCALL IsA(const PPBaseFilt * pS) const;
	long   GetSignature() const;
	int32  GetVer() const;
	PPBaseFilt & FASTCALL operator = (const PPBaseFilt &);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
protected:
	static const int RpvInvSignValue = 0xECA5B7F9;
	//
	// Descr: Если функция PPBaseFilt::Read встретила несоответствие считываемой версии
	//   фильтра текущей, и считываемая версия меньше текущей, то вызывает метод ReadPreviousVer()
	//   с номером считанной версии в качестве параметра.
	//
	//   Специальный случай: если параметр ver == PPBaseFilt::RpvInvSignValue (0xECA5B7F9) то это значит, что считанная в начале
	//   буфера 4-байтовая сигнатура не равна this->Signature.
	//   На момент ввода этого случая (@v9.2.1) функция Read не проверяла данное условие, по этому,
	//   если в ответ на такой параметр функция вернет <0 то считывание продолжится.
	//   Если порожденный класс каким-то специальным способом обрабатывает эту ситуацию, то
	//   он должен вернуть >0 (ok) или 0 (error).
	// Note: К моменту вызова ReadPreviousVer() смещение на чтение из буфера rBuf
	//   возвращется на исходную позицию, где оно находилось до вызова PPBaseFilt::Read
	// Returns:
	//   >0 - фильтр с заданной версией успешно считан.
	//   <0 - функция не поддерживается или нет возможности считать фильтр с заданным номером версии.
	//   0  - ошибка
	//
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	//
	// Descr: Реализует извлечение параметров фильтрации из текстового описания.
	//   Функция вызывается из PPBaseFilt::Read при обнаружении специального префикса.
	// Returns:
	//   >0 - фильтр успешно считан
	//   <0 - функция считывания текстового описания не поддерживается //
	//   0  - ошибка
	//
	virtual int ReadText(const char * pText, long); // @<<PPBaseFilt::Read
	//
	// Descr: Устанавливает "плоский" участок фильтра. Такой участок фильтра базовый класс
	//   обрабатывает самостоятельно. Это касается методов Init, Write, Read, Copy, IsEq.
	//
	void   SetFlatChunk(size_t offs, size_t len);
	int    FASTCALL SetBranchSString(size_t offs);
	int    FASTCALL SetBranchSArray(size_t offs);
	int    FASTCALL SetBranchSVector(size_t offs);
	int    FASTCALL SetBranchObjIdListFilt(size_t offs);
	int    FASTCALL SetBranchStrAssocArray(size_t offs);
	int    SetBranchBaseFiltPtr(int filtID, size_t offs);
	int    FASTCALL SetBranchDisplayExtList(size_t offs);
	//
	// Вспомогательные методы для функции Describe
	//
	static void STDCALL PutObjMembListToBuf(PPID objType, const ObjIdListFilt * pList, const char * pMembName, SString & rBuf);
	static void STDCALL PutFlagsMembToBuf(const StrAssocArray * pFlagList, const char * pMembName, SString & rBuf);
	static void STDCALL PutObjMembToBuf(PPID objType, PPID objID, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(LDATE, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(const DateRange *, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(const RealRange *, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(const char *, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(const SString &, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(double, const char * pMembName, SString & rBuf);
	static void STDCALL PutMembToBuf(long, const char * pMembName, SString & rBuf);
	void   PutSggMembToBuf(SubstGrpGoods,  const char * pMembName, SString & rBuf) const;
	void   PutSgpMembToBuf(SubstGrpPerson, const char * pMembName, SString & rBuf) const;
	void   PutSgdMembToBuf(SubstGrpDate,   const char * pMembName, SString & rBuf) const;
private:
	int    FASTCALL CheckBranchOffs(size_t offs);
	void   Destroy();
	int    AddBranch(uint type, size_t offs, int32 extraId);

	long   Signature;
	long   Capability;
	int32  Ver;
	uint16 FlatOffs; // @transient Смещение плоского участка фильтра
	uint16 FlatSize; // @transient Длина плоского участка фильтра
	//
	// Описание ветвления структуры
	//
	struct Branch {
		enum {
			tSString = 1,
			tSArray,
			tObjIdListFilt,
			tBaseFiltPtr,
			tStrAssocArray,
			tDisplayExtList,
			tSVector,
		};
		uint16 Type;
		uint16 Offs;
		int32  ExtraId; // For tBaseFiltPtr - FiltID
	};
	SVector BranchList; // @transient Список ветвлений структуры фильтра
};
//
//
//
class TagFilt : public PPBaseFilt {
public:
	enum {
		fNotTagsInList = 0x0001,
		fColors        = 0x0002  // Фильтр используется для определения цветового выделения объектов, удовлетворяющих ограничениям
	};

	static void FASTCALL SetRestriction(const char * pRestrictionString, SString & rItemBuf);
	static void FASTCALL SetColor(const SColor * pClr, SString & rItemBuf);
	static int  FASTCALL GetRestriction(const char * pItemString, SString & rRestrictionBuf);
	static int  FASTCALL GetColor(const char * pItemString, SColor & rClr);
	static int  FASTCALL SetRestrictionIdList(SString & rRestrictionBuf, const PPIDArray & rList);
	static int  FASTCALL GetRestrictionIdList(const SString & rRestrictionBuf, PPIDArray * pList);
	TagFilt();
	virtual bool IsEmpty() const;
	TagFilt & FASTCALL operator = (const TagFilt & rS);
	int    FASTCALL Check(const ObjTagList * pList) const;
	int    CheckTagItemForRestrict(const ObjTagItem * pItem, const SString & rRestrict) const;
	bool   SelectIndicator(PPID objID, SColor & rClr) const;
	bool   SelectIndicator(const ObjTagList * pTagList, SColor & rClr) const;

	char   ReserveStart[32];    // @anchor
	long   Flags;               // @flags
	StrAssocArray TagsRestrict; // @anchor
private:
	static int  ParseString(const char * pItemString, SString * pRestrictionBuf, SString * pColorBuf);
	static void MergeString(const char * pRestrictionString, const char * pColorString, SString & rItemBuf);
	int   Helper_CheckTagItemForRestrict_EnumID(const ObjTagItem * pItem, long restrictVal) const;
};
//
//
//
extern "C" typedef PPBaseFilt * (*FN_PPFILT_FACTORY)();

#define PPFILT_FACTORY(filtSymb)  BFF_##filtSymb
#define IMPLEMENT_PPFILT_FACTORY(filtSymb) extern "C" __declspec(dllexport) PPBaseFilt * BFF_##filtSymb() { return new filtSymb##Filt(); }
#define IMPLEMENT_PPFILT_FACTORY_CLS(filtSymb) extern "C" __declspec(dllexport) PPBaseFilt * BFF_##filtSymb() { return new filtSymb(); }
//
// @ModuleDecl(PPConfig)
//

//
// Некоторые флаги установлены жестко, независимо от внешней настройки
// Такие установки делаются функцией PPSession::FetchConfig
//
#define CFGFLG_CHECKTURNREST           0x00000001L // Проверять остатки при бух. проводках
#define CFGFLG_DISCOUNTBYSUM           0x00000002L // Ввод скидки неявный через сумму
#define CFGFLG_UNITEINTRTRFR           0x00000008L // Объединять проводки по межскладской передаче товаров
#define CFGFLG_CHECKBILLACCS           0x00000010L // Проверять доступ к документам
#define CFGFLG_CHECKACCTACCS           0x00000020L // Проверять доступ к счетам
#define CFGFLG_FORCEMANUF              0x00000040L // При вводе товара необходимо ввести производителя //
#define CFGFLG_UNIQUELOT               0x00000080L // В одном пакете не может быть двух строк из одного лота
#define CFGFLG_SELGOODSBYPRICE         0x00000100L // Выбор товара при реализации по цене
#define CFGFLG_USEPACKAGE              0x00000200L // Использовать поля упаковки в диалогах PPTransferItem
	// Следующие два флага определяют направление округления //
	// Если оба этих флага установлены или сброшены, то до ближайшего
#define CFGFLG_ROUNDUP                 0x00000400L
#define CFGFLG_ROUNDDOWN               0x00000800L
#define CFGFLG_FREEPRICE               0x00002000L // Определяет, что цена реализации товаров является //
	// свободной. То есть при операциях с поставщиком и межскладских передачах
	// цена реализации не отражается в бухгалтерских проводках.
#define CFGFLG_ALLOWOVERPAY            0x00010000L // Допускается переплата по документам
#define CFGFLG_ENABLEFIXDIS            0x00020000L // Разрешать фиксацию скидки
#define CFGFLG_STAFFMGMT               0x00040000L // Управление кадрами
#define CFGFLG_TURNINVOICE             0x00080000L // Развернуть счет-фактуру
#define CFGFLG_MULTICURACCT            0x00100000L // Допускаются многовалютные счета (Global)
#define CFGFLG_AUTOQUOT                0x00200000L // Автоматически устанавливать котировку при продаже товара
#define CFGFLG_SHOWPHQTTY              0x00400000L // Показывать физические единицы в товарных документах
#define CFGFLG_CONFGBROWRMV            0x00800000L // Подтверждать удаление товарной строки документа
#define CFGFLG_SEC_CASESENSPASSW       0x01000000L // Пароль, чувствительный к регистру символов
#define CFGFLG_SEC_DSBLMULTLOGIN       0x02000000L // Запрет на вход в систему с одним именем с разных машин
#define CFGFLG_USEGOODSMATRIX          0x04000000L // Товарная матрица ограничивает выбор товаров в
	// списках и использование в документах. Эта опция занесена в общую конфигурацию для того, чтобы можно было
	// раздельно назначать ее разным пользователям (группам).
#define CFGFLG_SEC_DSBLNSYSDATE        0x08000000L // Запрет на вход с операционной датой, отличной от системной
#define CFGFLG_DONTPROCESSDATAONJOBSRV 0x10000000L // Не обрабатывать данные на Job сервере
#define CFGFLG_FEFO                    0x20000000L // Модификация метода подбора партий по наиболее близкому сроку истечения годности лота
#define CFGFLG_MULTICURBILL_DISABLE    0x40000000L // @v10.7.8 Допускается применять мультивалютность в документах (дифференцируется оп пользователям/группам)

#define CFGST_INITIATE                 0x00000001L // Структура инициализирована
#define CFGST_INHERITED                0x00000002L // Структура унаследована от предыдущего уровня //
#define CFGST_MASTER                   0x00000004L // Признак пользователя "Master"
#define CFGST_WAREHOUSE                0x00000008L // Текущая позиция - складская //
#define CFGST_PWEXPIRED                0x00000010L // Срок действия пароля истек
#define CFGST_EMPTYBASE                0x00000020L // Вероятно база данных пуста
#define CFGST_DEMOMODE                 0x00000040L // Демо режим работы системы
#define CFGST_TRANSGLED                0x00000080L // Аварийный флаг, предназначен для передачи информации по лотам с товарами
#define CFGST_STOP                     0x00000100L // Флаг останова текущего потока
#define CFGST_TRANSQUOT                0x00000200L // Флаг, предписывающий функции PPObjGoods::Read()
	// выставлять флаг GF_TRANSQUOT в извлеченном из БД пакете для переноса только котировок по товару
	// без изменения самого товара в разделе-приемнике.
	// Флаг CFGST_TRANSQUOT выставляется функцией PPViewQuot::Transmit() эта же функция снимает
	// убирает этот флаг после передачи товаров.
	// Возможно возникновение проблем при рекурсивном извлечении товаров или групп товаров от которых
	// зависит изначально извлекаемый товар (эти пакеты также получат указанный флаг).
//
// Опции и параметры конфигурации по умолчанию
//
#define DEFCFG_FLAGS             (CFGFLG_CHECKTURNREST|CFGFLG_UNITEINTRTRFR)
#define DEFCFG_RLZORD            RLZORD_FIFO
#define DEFCFG_ACCESS            0
#define DEFCFG_USERID            PPUSR_MASTER // Если в БД нет ни одного пользовател
#define DEFCFG_MENU              MENU_DEFAULT
#define DEFCFG_LOCATION          0
#define DEFCFG_LOCSHEET          0
#define DEFCFG_CURRENCY          0

struct PPConfig {          // @persistent @store(PropertyTbl) size=92
	PPConfig();
	bool   FASTCALL IsEq(const PPConfig & rS) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	long   Tag;            //  4  0 || PPOBJ_CONFIG || PPOBJ_USRGRP || PPOBJ_USR
	long   ObjID;          //  8  Идентификатор объекта к которому относится конфигурация //
	long   PropID;         // 12  Const=PPPROP_CFG
	PPID   DefBillCashID;  // 16  Кассовый узел, используемый для печати чеков по документам
	LDATE  InitDate;       // 20  Дата первого баланса после инсталляции
	LDATE  OperDate;       // 24  Операционная дата
	short  AccessLevel;    // 26  Из прав доступа (в БД - 0)
	long   BaseCurID;      // 30  Базовая валюта (PPOBJ_CONFIG only)
	short  RealizeOrder;   // 32  Порядок использования лотов при расходе товара
	short  Menu;           // 34  Номер меню, используемого этой конфигурацией
	PPID   UserID;         // 38  @v10.8.9 User-->UserID
	PPID   LocAccSheetID;  // 42  Таблица аналитических статей, ссылающихся на склады
	PPID   Location;       // 46  Склад по умолчанию
	long   Flags;          // 50  Флаги CFGFLG_XXX
	long   State;          // 54  Текущее состояние (Только для текущего сеанса) CFGST_XXX
	short  BillAccess;     // 56  Уровень доступа к документу, устанавливаемый по умолчанию
	PPID   Cash;           // 60  Текущий кассовый узел (!0 только при вводе кассы)
	double RoundPrec;      // 68  Точность округления //
	PPID   MainOrg;        // 72  Главная организация по умолчанию
	long   SessionID;      // 76  Идентификатор сессии исполнения //
	PPID   DBDiv;          // 80  ИД раздела базы данных (PPOBJ_CONFIG only)
	long   BaseRateTypeID; // 84  Базовый тип валютного курса (PPOBJ_CONFIG only)
	long   DesktopID_Obsolete; // 88  Идентификатор рабочего стола, испольуемого пользователем (группой)
	long   MenuID_Obsolete;    // 92  Идентификатор меню, используемого пользователем (группой)
	S_GUID DesktopUuid_;    // @v10.9.3
	S_GUID MenuUuid;       // @v10.9.3
};
//
// Descr: Частная конфигурация, привязанная к конкретному пользователю.
//   В этой структуре держатся поля, которые должны относится строго к пользователю
//   без возможности наследования из родительской конфигурации.
//
struct PPConfigPrivate {   // @persistent @store(PropertyTbl)
	long   Tag;            // Const=PPOBJ_USR
	long   ObjID;          // ->Ref(PPOBJ_USR)
	long   PropID;         // Const=PPPRP_CFGPRIVATE
	char   Reserve[28];    // @reserve // @v10.9.3 [60]-->[28]
	S_GUID DesktopUuid;    // @v10.9.3
	S_GUID MenuUuid;       // @v10.9.3
	long   DesktopID_Obsolete; // Идентификатор рабочего стола, испольуемого пользователем
	long   Reserve2[2];    // @reserve
	char   Tail[1024];     //
};

#define PATHF_EMPTY              0x0001 // Может возвращаться функцией Path::GetPath
#define PATHF_INHERITED          0x4000 // Путь наследуется от предыдущего уровня //

class PPPaths {
public:
	PPPaths();
	PPPaths(const PPPaths & rS);
	~PPPaths();
	PPPaths & FASTCALL operator = (const PPPaths & rS);
	PPPaths & Z();
	bool   FASTCALL IsEq(const PPPaths & rS) const;
	bool   IsEmpty() const;
	int    Get(PPID securType, PPID securID);
	int    Put(PPID securType, PPID securID);
	int    Remove(PPID securType, PPID securID);
	int    GetPath(PPID pathID, short * pFlags, SString & rBuf) const;
	int    SetPath(PPID pathID, const char * buf, short flags = 0, int replace = 1);
	int    Get__(PPID obj, PPID id, PPID pathID, SString & rBuf);
	void   DumpToStr(SString & rBuf) const;
private:
	size_t Size() const;
	int    Resize(size_t);
	PathData * P;
};

class PPDriveMapping : public StringSet {
public:
	PPDriveMapping();
	int    Load(PPIniFile * pIniFile);
	int    Get(int drive, SString & rMapping) const;
	int    ConvertPathToUnc(SString & rPath) const;
};

struct PPPrinterCfg { // @persistent @store(PropertyTbl)
	enum {
		fUseDuplexPrinting = 0x0001, // Использовать дуплексную печать (Win32).
			// Этот флаг хранится в win-реестре по адресу HKEY_CURRENT_USER\\Software\\Papyrus\\System
			// Parameter UseDuplexPrinting=(1|0)
		fStoreLastSelPrn   = 0x0002  // @v10.7.10 Сохранять в реестре последний выбор принтера
	};
	long   Tag;           // 0 || PPOBJ_CONFIG || PPOBJ_USRGRP || PPOBJ_USR
	long   ObjID;         //
	long   PropID;        // Const=PPPRP_PRINTER
	long   PrnCmdSet;     // ИД набора команд принтера
	short  LeftMargin;    // [0..127]
	int16  Flags;
	char   Port[64];
};

int PPGetPrinterCfg(PPID obj, PPID id, PPPrinterCfg *);
int PPSetPrinterCfg(PPID obj, PPID id, PPPrinterCfg *);
//
//
//
class UuidRefCore : public UuidRefTbl {
public:
	UuidRefCore();
	~UuidRefCore();
	int    Search(long id, S_GUID & rUuid);
	int    SearchUuid(const S_GUID & rUuid, int useCache, long * pID);
	//
	// Descr: Опции функции GetUuid
	//
	enum {
		sgoOptimistic = 0x0001, // Предварительно предполагается, что rGuid в таблице отсутствует
		sgoHash       = 0x0002  // Использовать хэш для поиска GUID
	};
	int    GetUuid(const S_GUID & rUuid, long * pID, int options, int use_ta);
	int    RemoveUuid(const S_GUID & rUuid, int use_ta);
	int    Remove(long id, int use_ta);
	int    PutChunk(const TSVector <S_GUID> & rChunk, uint maxCount, int use_ta);
private:
	int    InitCache();

	GuidHashTable * P_Hash;
};
//
//
//
class TextRefIdent { // @flat
public:
	TextRefIdent();
	TextRefIdent(PPID objType, PPID objID, int16 prop);
	int operator !() const;

	PPObjID O; // Идентификатор объекта 
	int16   P; // Идентификатор свойства PPTRPROP_XXX (ppdefs.h). В дальнейшем планируется объединение семейства PPTRPROP_XXX с PPOBJATTR_XXX
	int16   L; // Идентификатор языка (slangXXX; 0 - default)
};

class TextRefEnumItem : public TextRefIdent {
public:
	SString	S; // Строка UTF8
};

class TextRefCore : public TextRefTbl {
public:
	TextRefCore();
	int    Search(const TextRefIdent & rI, SStringU & rBuf);
	int    SearchSelfRef(long id, SStringU & rBuf);
	int    SearchText(const TextRefIdent & rI, const wchar_t * pText, TextRefIdent * pResult);
	int    SearchSelfRefText(const wchar_t * pText, PPID * pID);
	//
	// Descr: Находит SelfRefText через кэш.
	// Note: Параметр pText должен быть представлен в ANSI кодировке
	//
	int    FetchSelfRefText(const char * pText, PPID * pID);
	int    GetSelfRefText(const wchar_t * pText, PPID * pID, int use_ta);
	int    SetText(const TextRefIdent & rI, const wchar_t * pText, int use_ta);
	int    SearchTextByPrefix(const TextRefIdent & rI, const wchar_t * pPrefix, TSVector <TextRefIdent> * pList);
	int    SearchSelfRefTextByPrefix(const wchar_t * pPrefix, TSVector <TextRefIdent> * pList);
private:
	int    GetLastObjId(PPID objType, int prop, PPID * pID);
};

class UnxTextRefCore : public UnxTextRefTbl {
public:
	UnxTextRefCore();
	int    Search(const TextRefIdent & rI, SStringU & rBuf);
	int    Search(const TextRefIdent & rI, STimeSeries & rTs);
	int    SetText(const TextRefIdent & rI, const wchar_t * pText, int use_ta);
	//
	// Descr: Возвращает текст в кодировке utf-8
	//
	int    GetText(const TextRefIdent & rI, SString & rBuf);
	int    FilterIdList(PPID objType, int prop, const char * pPattern, const PPIDArray * pFiltIdList, PPIDArray & rResultIdList);
	int    FilterIdRange(PPID objType, int prop, const char * pPattern, const IntRange * pFiltIdRange, PPIDArray & rResultIdList);
	//
	// Descr: Сохраняет текст, заданный в кодировке utf-8
	//
	int    SetText(const TextRefIdent & rI, const char * pText, int use_ta);
	//
	// Descr: Сохраняет временную серию в записи.
	//
	int    SetTimeSeries(const TextRefIdent & rI, STimeSeries * pTs, int use_ta);
	//
	SEnum::Imp * Enum(PPID objType, int prop);
	SEnum::Imp * Enum(PPID objType, int prop, PPID minObjID);
	int    InitEnum(PPID objType, int prop, long * pHandle);
	int    InitEnum(PPID objType, int prop, PPID minObjID, long * pHandle);
	int    NextEnum(long enumHandle, TextRefEnumItem * pRec);
private:
	class _Enum : public SEnum::Imp {
	public:
		_Enum(UnxTextRefCore * pT, long h);
		virtual ~_Enum();
		virtual int Next(void * pRec);
	protected:
		UnxTextRefCore * P_T;
		long   H;
	};
	int    FASTCALL PostprocessRead(SStringU & rBuf);
	int    Helper_Filter(PPID objType, int prop, const char * pPattern, const IntRange & rRange, const PPIDArray * pFiltIdList, PPIDArray & rResultIdList);

	PPTblEnumList EnumList;
};
//
//
//
class ObjAssoc : public ObjAssocTbl {
public:
	friend class PPTblEnum <ObjAssoc>;

	ObjAssoc();
	int    Add(PPID * pID, ObjAssocTbl::Rec * b, int use_ta);
	//
	// Descr: если pList != 0, добавляет в таблицу записи со следующими полями:
	//   {AsscType=asscTyp, PrmrObjID=pList[i].Key, ScndObjID=pList[i].Val, InnerNum=1 }
	//   Если preRemove != 0, то предварительно удаляет все записи, соответствующие
	//   типу ассоциации asscTyp.
	//   Если pList == 0 && preRemove, то записи удаляются все равно
	// ARG(asscTyp   IN): @#{!0}    тип ассоциации. Если 0, то функция возвращает ошибку (PPErrCode=PPERR_INVPARAM)
	// ARG(pList     IN): @#{vptr0} список ассоциаций, который следует добавить в таблицу.
	// ARG(preRemove IN): если !0, то прежде всего функция удалит все записи,
	//   имеющие тип ассоциации asscTyp
	// ARG(use_ta    IN): если !0, то операция осуществляется в транзакции
	// Returns:
	//   >0 - операция успешно выполнена
	//   0  - ошибка
	//
	int    AddArray(PPID asscTyp, const LAssocArray * pList, int preRemove, int use_ta);
	//
	// Descr: добавляет в таблицу список записей pList по типу ассоциации asscTyp и с первичным
	//   идентификатором prmrID.
	//   Перед выполнением функции проверяются следующие условия:
	//     asscTyp != 0; prmrID != 0; pList == 0 || pList->getItemSize() == sizeof(ObjAssocTbl::Rec).
	//     Если эти условия не выполняются, то возвращается 0 с кодом ошибки PPERR_INVPARAM.
	//   Если параметр preRemove != 0, то предварительно удаляются все записи с типом ассоциации
	//   asscTyp и первичным идентификатором prmrID.
	//   При вставке записей из массива pList в каждой записи устанавливаются следующие атрибуты:
	//     AsscType = asscTyp; PrmrObjID = prmrID; если InnerNum == 0, то устанавливается равным
	//     позиции элемента в массиве pList с базой 1 (1..).
	// Returns:
	//   >0 - операция успешно выполнена
	//   0  - ошибка
	//
	int    AddArray(PPID asscTyp, PPID prmrID, const TSVector <ObjAssocTbl::Rec> * pList, int preRemove, int use_ta);
	int    Update(PPID asscID, ObjAssocTbl::Rec * pRec, int use_ta);
	int    Remove(PPID asscID, int use_ta);
	//
	// Descr: удаляет кортеж записей, соответствующий условию:
	//   (!asscType || (asscTyp == AssType && (!prmr || prmr == PrmrObjID) &&
	//   (!scnd || scnd == ScndObjID)))
	//
	int    Remove(PPID asscTyp, PPID prmrID, PPID scnd, int use_ta);
	int    Search(PPID, ObjAssocTbl::Rec * = 0);
	int    Search(PPID asscTyp, PPID prmrID, PPID scnd, ObjAssocTbl::Rec * = 0);
	int    SearchNum(PPID asscTyp, PPID prmrID, long num, ObjAssocTbl::Rec * = 0);
	int    SearchFreeNum(PPID asscTyp, PPID prmrID, long * num, ObjAssocTbl::Rec * = 0);
	int    EnumByPrmr(PPID asscTyp, PPID prmrID, PPID * scnd, ObjAssocTbl::Rec * = 0);
	SEnum::Imp * Enum(PPID asscType, PPID keyID, int byScnd);
	int    GetList(PPID asscTyp, LAssocArray *);
	int    GetListByPrmr(PPID asscTyp, PPID prmrID, PPIDArray * pList);
	int    GetItemsListByPrmr(PPID asscType, PPID prmrID, TSVector <ObjAssocTbl::Rec> * pList);
	int    Count(PPID asscTyp, PPID prmrID, long * pCount);
	int    _SearchNum(PPID asscTyp, PPID prmrID, long num, int spMode, ObjAssocTbl::Rec *);
private:
	int    GetByPrmr_Helper(PPID asscTyp, PPID prmrID, PPIDArray * pList, long * pCount, TSVector <ObjAssocTbl::Rec> * pItemsList);

	PPTblEnumList EnumList;
};
//
//
//
typedef int (*PPCheckInPersonTurnProc)(const PPCheckInPersonConfig * pCfg, PPCheckInPersonArray * pList, uint itemPos, void * pExtPtr);
//
// Descr: Транзиентная (пока) конфигурация регистрации персоналий
//
struct PPCheckInPersonConfig {
	PPCheckInPersonConfig();
	PPCheckInPersonConfig(PPObjTSession & rTSesObj, const TSessionPacket & rTSessPack);
	int    operator !() const;

	enum {
		fInitPrc  = 0x0001, // При инициализации был идентифицирован процессор
		fInitTech = 0x0002, // При инициализации была идентифицирована технология
		fError    = 0x0004  // При инициализации экземпляра произошла ошибка
	};
	long   Flags;
	PPID   PersonKindID; // Вид персоналий, которые могут быть загеристрированы
	int    Capacity;     // Максимальное количество персоналий в регистрационном списке. 0 - unlimited
	PPID   GoodsID;      // Товар, который применяется для определения цены регистрации и для проведения кассового чека.
	PPID   LocID;        // Локация для определения цены товара GoodsID
	PPCheckInPersonTurnProc TurnProc; // Процедура для сохранения списка персональных регистраций.
		// Необходимость в процедуре (на текущий момент) обусловлена механизмом проведения чека для регистрации:
		// чек должен быть проведен только по объекту, который имеет свою копию в базе данных.
	void * P_TurnProcExt;
};
//
// Descr: Структура членства персоналии в агрегации "Регистрация персоналий".
//
class PPCheckInPersonItem { // @persistent(DBX) @flat
public:
	friend class PPCheckInPersonMngr;
	friend class PPCheckInPersonArray;

	DECL_INVARIANT_C();

	enum {
		statusUnkn = 0,
		statusRegistered = 1,
		statusCheckedIn,
		statusCanceled
	};
	enum {
		kUnkn = 0,
		kTSession
	};
	enum {
		fCheckedIn = 0x0001, // Подтвержденная регистрация (CheckIn)
		fCanceled  = 0x0002, // Явно отмененная регистрация //
		fAnonym    = 0x0004  // Запись с анонимной персоналией. Если флаг установлен, то поле PersonID получает специальное значение.
	};
	PPCheckInPersonItem();
	PPCheckInPersonItem & Z();
	int    GetStatus() const;
	int    SetStatus(int status);
	int    FASTCALL SetPerson(PPID personID);
	PPID   GetPerson() const;
	int    GetPersonName(SString & rBuf) const;
	void   SetAnonym();
	int    IsAnonym() const;
	//
	// Descr: Опции функции PPCheckInPersonItem::IsEq
	//
	enum {
		eqoNoID    = 0x0001, // Сравнивать без учета ID
		eqoNoNum   = 0x0002, // Сравнивать без учета Num
		eqoKeyOnly = 0x0004  // Сравнивает комбинации {Kind, PrmrID, PersonID}
			// Если запись оба объекта анонимные, то PersonID не сравниваются.
			// Если одна запись анонимная, а другая - нет, то записи разные.
	};
	bool   FASTCALL IsEq(const PPCheckInPersonItem & rS, long options) const;
	bool   FASTCALL operator == (const PPCheckInPersonItem & rS) const;

	struct Total {
		Total();
		uint   RegCount;
		uint   CiCount;
		uint   CalceledCount;
	};
	void   Count(Total & rT) const;
	//int    Count(uint * pRegCount, uint * pCiCount, uint * pCanceledCount) const;
	int    CalcAmount(const PPCheckInPersonConfig * pCfg, double * pPrice, double * pAmount) const;
	int    CalcPinCode(SString & rCode) const;

	enum {
		opfVerifyPinCode = 0x0001
	};

	int    Cancel(long flags, const char * pPinCode);
	int    CheckIn(long flags, const char * pPinCode);

	PPID   ID;             // Идентификатор ассоциации. В пределах одного раздела БД строка идентифицируется этим полем.
	int32  Kind;           // Вид ассоциации.
	PPID   PrmrID;         // Идентификатор первичного объекта, для которого фиксируется регистрация (например, PPObjTSession)
private:
	PPID   PersonID;       // ->Person.ID
public:
	long   Num;            // Номер записи в однородном списке относительно заданного первичного объекта
	uint16 RegCount;       // Количество персоналий, включенное в данную регистрацию. Как правило =1,
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	uint16 CiCount;        // Количество персоналий, включенное в данную регистрацию со статусом CheckedIn. Как правило =(0|1),
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	long   Flags;          // @flags
	LDATETIME RegDtm;      // Время регистрации //
	LDATETIME CiDtm;       // Время подтверждения регистрации (CheckID)
	double Amount;         // Сумма, уплаченная или которая должна быть уплачена за регистрацию (подтверждение)
	PPID   CCheckID;       // Кассовый чек, которым оплачено подтверждение регистрации
	PPID   SCardID;        // Карта, с которой ассоциирована зерегистрированная персоналия //
	uint   MemoPos;        // @internal
	char   PlaceCode[8];   // Номер места (для регистрации, ассоциированной с посадочным местом)
	PPID   BillID;         // ИД документа, который связан с данной регистрацией
	uint8  Reserve[8];     //
};
//
// Descr: Список членства персоналий в агрегации "Регистрация персоналий"
//
class PPCheckInPersonArray : private TSVector <PPCheckInPersonItem> { // @persistent(DBX)
public:
	friend class PPCheckInPersonMngr;

	DECL_INVARIANT_C();

	PPCheckInPersonArray();
	PPCheckInPersonArray(const PPCheckInPersonArray & rS);
	PPCheckInPersonArray & Init(int kind = 0, PPID prmrID = 0);
	PPCheckInPersonArray & Z();
	PPCheckInPersonArray & FASTCALL Copy(const PPCheckInPersonArray & rS);
	PPCheckInPersonArray & FASTCALL operator = (const PPCheckInPersonArray & rS);
	void   FASTCALL InitItem(PPCheckInPersonItem & rItem) const;
	int    SearchByID(PPID id, uint * pPos) const;
	int    SearchByNum(long num, uint * pPos) const;
	int    SearchItem(const PPCheckInPersonItem & rItem, uint * pPos) const;
	uint   GetCount() const;
	int    AddItem(const PPCheckInPersonItem & rItem, const PPCheckInPersonConfig * pCipCfg, uint * pPos);
	int    UpdateItem(uint pos, const PPCheckInPersonItem & rItem, const PPCheckInPersonConfig * pCipCfg);
	int    UpdateStatusForAll(long newStatus);
	int    FASTCALL RemoveItem(uint pos);
	void   Normalize(int kind, PPID prmrID);
	//
	// Descr: Вспомогательная функция, реализующая разрешение ссылок при синхронизации
	//   объекта, который содержит экземпляр this.
	//
	int    ProcessObjRefs(PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	void   InitIteration();
	int    FASTCALL NextIteration(PPCheckInPersonItem & rItem);
	void   Count(PPCheckInPersonItem::Total & rT) const;
	//int    Count(uint * pRegCount, uint * pCiCount, uint * pCanceledCount) const;
	const  PPCheckInPersonItem & FASTCALL Get(uint pos) const;
	int    CalcAmount(const PPCheckInPersonConfig * pCfg, double * pAmount) const;
	int    SetMemo(uint rowPos, const char * pMemo);
	int    GetMemo(uint rowPos, SString & rMemo) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	SVerT  Ver;    // Версия системы, создавшая структуру. Необходимо для сериализации.
	int32  Kind;
	PPID   PrmrID;
	long   LastAnonymN;     // Последнее значение, использованное для нумерации анонимных записей
	StringSet MemoPool;     //
};
//
// Descr: Класс, управляющий хранением и извлечением агрегации "Регистрация персоналий"
//
class PPCheckInPersonMngr {
public:
	PPCheckInPersonMngr();
	int    Search(PPID id, PPCheckInPersonItem * pItem);
	int    Search(/*int kind, PPID prmrID, PPID personID*/const PPCheckInPersonItem & rKeyItem, PPCheckInPersonItem * pItem);
	int    Put(PPCheckInPersonItem & rItem, int use_ta);
	int    Put(PPCheckInPersonArray & rList, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    Remove(int kind, PPID prmrID, int use_ta);
	int    GetList(int kind, PPID prmrID, PPCheckInPersonArray & rList);
private:
	static PPID FASTCALL GetAssocType(int kind);
	static int  FASTCALL GetKind(PPID asscType);
	static int  FASTCALL ItemToStorage(const PPCheckInPersonItem & rItem, ObjAssocTbl::Rec & rRec);
	static int  FASTCALL StorageToItem(const ObjAssocTbl::Rec & rRec, PPCheckInPersonItem & rItem);
};
//
// Descr: Класс управляющий таблицей сохранения версий удаленных или изменных объектов данных
//
class ObjVersioningCore : public ObjVerTbl {
public:
	ObjVersioningCore();
	int    IsInited() const;
	int    InitSerializeContext(int use_ta);
	SSerializeContext & GetSCtx();
	int    Add(PPID * pID, PPObjID oid, SBuffer * pBuf, int use_ta);
	int    Search(PPID id, PPObjID * pOid, long * pVer, SBuffer * pPackBuf);
	int    SearchOid(PPObjID oid, long ver, ObjVerTbl::Rec * pRec, SBuffer * pDataBuf);
	int    GetNextVer(PPObjID oid, long * pVer);
private:
	enum {
		stSCtxInited = 0x0001
	};
	long   State;
	SSerializeContext SCtx;
};
//
// @ModuleDecl(ObjTagCore)
// Теги объектов
//
// Типы данных для тегов
//
#define OTTYP_GROUP         0  // Группа тегов
#define OTTYP_BOOL          1  // Логическое значение
#define OTTYP_STRING        2  // Строка
#define OTTYP_NUMBER        3  // double
#define OTTYP_ENUM          4  // Перечисление (PPObjectTag::TagEnumID)
#define OTTYP_INT           5  // long
#define OTTYP_OBJLINK       6  // Ссылка на объект (PPObjectTag::TagEnumID)
#define OTTYP_DATE          7  // LDATE
#define OTTYP_GUID          8  // GUID
#define OTTYP_IMAGE         9  // Строка, содержащая путь к файлу с изображением
#define OTTYP_TIMESTAMP    10  // Временная метка.
#define OTTYP_LAST         10  // Последнее допустимое значение типа тега
//
// Флаги тегов
//
#define OTF_NOZERO           0x0002 // Тег с нулевым значение удаляется //
#define OTF_NMBRULE          0x0004 // Для тега с числовым значением определено правило
#define OTF_WARNZERO         0x0008 // Нулевое или отрицательное значение тега является поводом для предупреждения оператора (в документах, персональных операциях и т.д.)
#define OTF_INHERITABLE      0x0010 // Наследуемый tag. Интерпретация флага зависит от типа объектов, к которому относится tag.
#define OTF_NOTICEINCASHPANE 0x0020 // Извещение в кассовой панели
#define OTF_HIERENUM         0x0040 // Иерерхическое перечисление
#define OTF_PASSIVE          0x0080 // @v12.0.8 Пассивный тег (не отображается в списках)

struct PPObjectTag2 {   // @persistent @store(Reference2Tbl+)
	PPObjectTag2();
	PPID   Tag;         // Const=PPOBJ_TAG
	PPID   ID;          // @id
	char   Name[48];    // @name @!refname
	char   Symb[20];    // Символ для использования в формулах
	char   Reserve[44]; // @reserve // @v11.2.8 [48]--[44]
	uint32 HotKey;      // @v11.2.8 Горячая клавиша для редактирования тега из таблиц (после '/')
		// LOWORD - keycode, HIWORD - modifier (alt||ctrl||shift)
	PPID   LinkObjGrp;  // Дополнительный параметр для ссылочного объекта
	PPID   TagEnumID;   // Тип ссылочного объекта
	long   TagDataType; // OTTYP_XXX
	long   Flags;       // OTF_XXX
	PPID   ObjTypeID;   // Тип объекта, для которого определен тег
	PPID   TagGroupID;  // Группа, к которой относится тег
};

class PPTagEnumList : public StrAssocArray {
public:
	explicit PPTagEnumList(PPID enumID = 0);
	PPTagEnumList & FASTCALL operator = (const PPTagEnumList & s);
	int    FASTCALL Copy(const PPTagEnumList &);
	int    PutItem(PPID * pID, const char * pName, PPID parentID);
	void   SetEnumID(PPID enumID);
	PPID   GetEnumID() const { return EnumID; }
	void   SetFlags(long flags);
	long   GetFlags() const { return Flags; }
	//
	// Descr: Считывает из базы данных все элементы перечисления объекта enumID
	//
	int    Read(PPID enumID);
	int    Write(int use_ta);
private:
	PPID   EnumID;
	long   Flags;
};
//
// Descr: Пакет объекта PPOBJ_TAG.
//   При обмене данными с другими разделами передается и принимается только
//   поле Rec (EnumList синхронизируется посредством Rec.TagEnumID, Rule не используется).
//
class PPObjTagPacket {
public:
	PPObjTagPacket();
	PPObjTagPacket & Z();
	PPObjTagPacket & FASTCALL operator = (const PPObjTagPacket &);

	PPObjectTag Rec;
	SString Rule;
};
//
// Descr: Представление значения тега
//
class ObjTagItem { // @persistent(DBX)
public:
	static SString & STDCALL GetTypeString(int tagType, PPID enumId, SString & rBuf);

	ObjTagItem();
	ObjTagItem(const ObjTagItem & rS);
	~ObjTagItem();
	int    FASTCALL Init(PPID tagID);
	int    SetInt(PPID tagID, long);
	int    SetReal(PPID tagID, double);
	int    SetStr(PPID tagID, const char *);
	int    SetDate(PPID tagID, LDATE dt);
	int    SetGuid(PPID tagID, const S_GUID_Base *);
	int    SetTimestamp(PPID tagID, LDATETIME dtm);
	int    AddKeyword(PPID tagID, const char * pKeyword);
	int    FASTCALL GetInt(long * pVal) const;
	int    FASTCALL GetInt(int * pVal) const { return GetInt(reinterpret_cast<long *>(pVal)); } // @v11.7.10
	int    FASTCALL GetInt64(int64 *) const;
	int    FASTCALL GetReal(double *) const;
	int    FASTCALL GetStr(SString &) const;
	int    FASTCALL GetDate(LDATE *) const;
	//
	// Descr: Получает значение типа S_GUID из тега.
	//   Результат функции считается успешным в случае, если тип тега OTTYP_GUID или OTTYP_STRING, а
	//   значение может быть благополучно преобразовано к S_GUID. В этом случае функция возвращает true,
	//   а по указателю pData (если он не нулевой) присваивается полученное значение.
	//   Если перечисленные критерии успешности не выполнены, то функция возвращает false, а 
	//   по указателю pData (если он не нулевой) присваивается пустое значение.
	//
	bool   FASTCALL GetGuid(S_GUID * pData) const;
	int    FASTCALL GetTimestamp(LDATETIME *) const;
	int    GetEnumData(long * pID, long * pParentID, SString * pTxt, SString * pSymb) const;
	int    AddReal(double rVal);
	int    FASTCALL Copy(const ObjTagItem &);
	void   Destroy();
	int    FASTCALL Get_(const ObjTagTbl::Rec & rRec);
	int    Put(PPID objType, PPID objID, long tagByObj, ObjTagTbl::Rec *) const;
	int    FASTCALL Cmp(const ObjTagItem &) const;
	bool   IsZeroVal() const;
	bool   IsWarnVal() const;
	ObjTagItem & FASTCALL operator = (const ObjTagItem &);
	bool   FASTCALL operator == (const ObjTagItem & a) const;
	bool   FASTCALL operator != (const ObjTagItem & a) const;
	int    Write__(SBuffer & rBuf) const; // @todo(eliminate)
	int    Read__(SBuffer & rBuf);        // @todo(eliminate)
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	PPID   TagID;          // ->Ref(PPOBJ_TAG)
	long   TagDataType;    // OTTYP_XXX
	PPID   TagEnumID;      //
	union {
		long   IntVal;     //
		double RealVal;    //
		char * PStr;       //
		LDATE  DtVal;      //
		LDATETIME DtmVal;  //
	} Val;
};
//
// Descr: Список значений тегов
//
class ObjTagList : SArray {
public:
	ObjTagList();
	ObjTagList(const ObjTagList & s);
	~ObjTagList();
	ObjTagList & FASTCALL operator = (const ObjTagList & s);
	ObjTagList & Z();
	uint   GetCount() const;
	int    FASTCALL IsEq(const ObjTagList & rS) const;
	//
	// Descr: Возвращает указатель на тег с идентификатором типа tagID.
	//   Если список не содержит такого тега, то, при forceEmpty != 0
	//   в список добавляется пустой тег с типом tagID и возвращается указатель
	//   на него, в противном случае возвращается 0.
	//
	const  ObjTagItem * FASTCALL GetItem(PPID tagID) const;
	int   GetItemStr(PPID tagID, SString & rBuf) const;
	const  ObjTagItem * FASTCALL GetItem_ForceEmpty(PPID tagID);
	const  ObjTagItem * FASTCALL GetItemByPos(uint) const;
	const  ObjTagItem * FASTCALL EnumItems(uint * pos) const;
	//
	// Descr: Список получает собственную копию элемента ObjTagItem.
	//   По-этому, объект, переданный функции параметром pItem
	//   может (и, вероятно, должен) быть разрушен вызывающей функцией.
	//
	int    PutItem(PPID tagID, const ObjTagItem * pItem);
	//
	// Descr: Флаги функции PutItemNZ()
	//
	enum {
		pinzfInheritableOnly = 0x0001,
		pinzfUnmirroredOnly  = 0x0002
	};

	int    PutItemNZ(const ObjTagItem * pItem, long flags);
	int    PutItemReal(PPID tagID, double value);
	int    PutItemStr(PPID tagID, const char * pStr);
	//
	// Descr: Вставляет в список тег со значением равным строке pStr
	//   но только в том случае, если !isempty(pStr).
	// Returns:
	//   >0 - тег успешно вставлен в список
	//   <0 - строка pStr пустая: ничего не произошло
	//   0  - ошибка
	//
	int    PutItemStrNE(PPID tagID, const char * pStr);
	int    FASTCALL Copy(const ObjTagList & src);
	//
	// Descr: Опции функции ObjTagList::Merge().
	//
	enum {
		mumAdd       = 0x0001, // Добавлять не существующие теги из rSrc в this
		mumUpdate    = 0x0002, // Изменять теги из rSrc в this (если для типа тега не установлен признак OTF_DUP)
		mumRemove    = 0x0004, // Удалить в списке this теги с типами, перечисленными в rSrc. Эта опция отменяет остальные флаги.
		mumIgnoreDup = 0x0008  // Если в rSrc встретился тег с типом, который уже есть в this, то тег в this
			// будет изменен, даже если для типа тега установлен признак OTF_DUP.
	};
	//
	// Descr: Объединяет список тегов this со списком rSrc.
	//
	int    Merge(const ObjTagList & rSrc, int updateMode);
	int    Write__(SBuffer & rBuf) const; // @todo(eliminate)
	int    Read__(SBuffer & rBuf);        // @todo(eliminate)
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    ProcessObjRefs(PPObjIDArray * ary, int replace);

	PPObjID  Oid;
protected:
	virtual void FASTCALL freeItem(void *);
};
//
// Descr: Вспомогательный класс, унифицирующий некоторые манипуляции с контейнером тегов
//   внутри объектный пакетов.
//
class ObjTagContainerHelper {
public:
	//
	// Descr: Устанавливает GUID объекта в значение rGuid. Если rGuid.IsZero(), то удаляет то, что есть.
	//
	int    SetGuid(const S_GUID & rGuid);
	//
	// Descr: Генерирует GUID объекта и уставливает его в пакет функцией SetGuid
	//
	int    GenerateGuid(S_GUID * pGuid);
	//
	// Descr: Извлекает GUID объекта из пакета. Считает, что этот тег идентифицируется значением this->GuidTagID.
	//   Если пакет не содержит GUID, то возвращает false и присваивает rGuid пустое значение.
	//   Если пакет содержит тег GuidTagID, но значение этого тега не может быть валидным образом преобразовано к S_GUID,
	//   то возвращает false и присваивает rGuid пустое значение.
	//
	bool   GetGuid(S_GUID & rGuid) const;
protected:
	ObjTagContainerHelper(ObjTagList & rTagL, PPID objType, PPID guidTagID);

	ObjTagList & R_TagL;
	const  PPID ObjType;
	const  PPID GuidTagID;
};
//
//
//
class ObjTagCore : public ObjTagTbl {
public:
	ObjTagCore();
	//
	// Descr: Специальный конструктор, используемый для открытия таблицы, отличной от той,
	//   что находится в текущей базе данных.
	//
	ObjTagCore(const char * pFileName);
	int    GetList(PPID objType, PPID objID, ObjTagList * pList);
	int    PutList(PPID objType, PPID objID, const ObjTagList * pList, int use_ta);
	//
	// Descr: Вносит в базу данных список тегов pList игнорируя теги с идентификаторами, перечисленными
	//   в pExclList. Если pExclList == 0 или пусто, то работает так же, как и PutList()
	//
	int    PutListExcl(PPID objType, PPID objID, const ObjTagList * pList, const PPIDArray * pExclList, int use_ta);
	int    GetTagRec(PPID objType, PPID objID, PPID tagID, ObjTagTbl::Rec * pRec);
	int    GetTag(PPID objType, PPID objID, PPID tagID, ObjTagItem * pItem);
	//
	// Descr: Высокоуровневая функция, получающая тег и извлекающая из него
	//   строковое значение.
	// Returns:
	//   >0 - тег извлечен и содержит не пустое строковое значение
	//   <0 - тег не найден, либо не может быть преобразован к строке
	//   0  - ошибка
	//
	int    GetTagStr(PPID objType, PPID objID, PPID tagID, SString & rBuf);
	int    GetTagGuid(PPID objType, PPID objID, PPID tagID, S_GUID & rGuid);
	int    EnumTags(PPID objType, PPID objID, PPID * pTagID, long * pTagByObj, ObjTagItem *);
	int    EnumTags(PPID objType, PPID objID, PPID tagID, long * tagByObj, ObjTagItem *);
	//
	// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
	//   тип тега равен tagID, строковое содержимое тега равно pStr (нечувствительное к регистру сравнение).
	// Returns:
	//   >0 - Найден хоть один тег, то возвращается //
	//   <0 - Не найдено ни одного соответствия //
	//   0  - Ошибка
	//
	int    SearchObjectsByStr(PPID objType, PPID tagID, const char * pStr, PPIDArray * pResult);
	//
	// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
	//   тип тега равен tagID, тип значения тега - строка, строковое содержимое тега В ТОЧНОСТИ равно pStr (нечувствительное к регистру сравнение).
	// Returns:
	//   >0 - Найден хоть один тег, то возвращается //
	//   <0 - Не найдено ни одного соответствия //
	//   0  - Ошибка
	//
	int    SearchObjectsByStrExactly(PPID objType, PPID tagID, const char * pStr, PPIDArray *);
	int    SearchObjectsByGuid(PPID objType, PPID tagID, const S_GUID & rGuid, PPIDArray * pList);
	int    GetObjTextList(PPID objType, PPID tagID, StrAssocArray & rList);
	//
	// Descr: Формирует список идентификаторов объектов, для которых существуют теги типа tagID.
	// Note: Список rList предварительно не очищается.
	//
	int    GetObjectList(PPID objType, PPID tagID, UintHashTable & rList);
	//
	// Descr: Ищет запись, соответсвующую типу объект objType и тегу tagID со строковой величиной, равной
	//   pStr. Если находит, то возвращает идентификатор этого объекта. В противном случае создает
	//   такую запись с новым значением идентификатора объекта и возвращает этот ид.
	// Note:
	//   Если длина строки pStr превышает размер (ObjTagTbl::Rec::StrVal-1), то функция возвращает 0
	//   и инициализирует код ошибки PPERR_EXCSTRLEN
	// Returns:
	//   1 - запись найдена
	//   2 - запись не найдена и успешно создана
	//  -1 - строка pStr - пустая //
	//   0 - error
	//
	// @obsolete since @v9.0.11 int    CreateUniqueStr(PPID objType, PPID tagID, PPID * pObjID, const char * pStr, int use_ta);
	int    PutTag(PPID objType, PPID objID, const ObjTagItem *, int use_ta);
	int    RemoveTag(PPID objType, PPID objID, PPID tagID /* if 0 then remove all */, int use_ta);
	int    SearchAnyRefToTagID(PPID tagID, PPObjID *);
protected:
	int    PutTagToRec(PPID objType, PPID objID, long tagByObj, const ObjTagItem *);
	int    GetNewTagByObjCounter(PPID objType, PPID objID, PPID tagID, long * tagByObj);
};
// @EndModuleDecl(ObjTagCore)
//
//
enum {
	objlWithHeader = 0x0001, // Элемент массива стостоит из 4-х байтового идентификатора и наименования //
	objlSortByText = 0x0002  // Сортировать элементы списка по наименованию
};

typedef int (* ObjFilterProc)(void *, void * extraPtr);
//
//
//
#define USRF_INHCFG     0x00000001L // Наследует конфигурацию
#define USRF_INHRIGHTS  0x00000002L // Наследует права
//
// Флаги операционных категорий исключений прав доступа
//
#define PPEXCLRT_OBJDBDIVACCEPT      0x0001
#define PPEXCLRT_CSESSWROFF          0x0002
#define PPEXCLRT_CSESSWROFFROLLBACK  0x0004
#define PPEXCLRT_INVWROFF            0x0008
#define PPEXCLRT_INVWROFFROLLBACK    0x0010
#define PPEXCLRT_DRAFTWROFF          0x0020
#define PPEXCLRT_DRAFTWROFFROLLBACK  0x0040

struct PPSecur2 {          // @persistent @store(Reference2Tbl+)
	PPSecur2();
	bool   FASTCALL IsEq(const PPSecur2 & rS) const;
	long   Tag;            // Const={PPOBJ_USR | PPOBJ_USRGRP}
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // @unused
	char   Password[40];   // (USER only) Пароль (зашифрован и свернут в строку кодировкой MIME64)
	LDATE  ExpiryDate;     // 
	PPID   UerID;          // Исключение прав доступа для PPOBJ_USR
	long   UerFlags;       // Флаги исключений прав доступа для PPOBJ_USREXCLRIGHTS
	uint32 Crc;            // Контрольная сумма для гарантии того, что запись не была создана либо изменена вне сервисов системы.
	LDATE  PwUpdate;       // (USER only) Дата последнего изменения пароля //
	long   Flags;          // (USER only) Флаги (USRF_XXX)
	long   ParentID;       // Родительский объект (группа | конфигурация)
	PPID   PersonID;       // (USER only) Связанная персоналия //
};

struct PPSecurPacket {
	PPSecurPacket();
	PPSecurPacket(const PPSecurPacket & rS);
	bool   FASTCALL IsEq(const PPSecurPacket & rS) const;
	PPSecurPacket & FASTCALL operator = (const PPSecurPacket & rS);
	PPSecur  Secur;
	PPConfig Config;
	PPPaths  Paths;
	PPRights Rights;
	S_GUID PrivateDesktopUUID; // @v11.0.0 UUID приватного рабочего стола пользователя, используемый если конфигурация наследуется //
};

struct PropPPIDArray {
	PPID   ObjType;
	PPID   ObjID;
	PPID   PropID;
	long   Count;
	// long Items[];
};
//
// Descr: Макрос для представления размера фиксированной части (без "хвоста" переменной длины)
//   записи таблицы PropertyTbl
//
//#define PROPRECFIXSIZE sizeof(PropertyTbl::Rec)
#define PROPRECFIXSIZE        offsetof(PropertyTbl::Rec, VT)
#define PCFGEXSTR_DESKTOPNAME 1
//
//
//
class Reference : public ReferenceTbl {
public:
	friend class PPTblEnum <Reference>;

	enum {
		crymDefault = 0,
		crymRef2
	};
	static int Encrypt(int cryptMethod, const char * pText, char * pBuf, size_t bufLen);
	static int Decrypt(int cryptMethod, const char * pBuf, size_t bufLen, SString & rText);
	static int GetPassword(const PPSecur * pSecur, char * pBuf, size_t bufLen);
	static int VerifySecur(PPSecur2 * pSecur, int set);
	static int GetExField(const PPConfigPrivate * pRec, int fldId, SString & rBuf);
	static int SetExField(PPConfigPrivate * pRec, int fldId, const char * pBuf);
	static int Helper_Encrypt_(int cryptMethod, const char * pEncPw, const char * pText, char * pBuf, size_t bufLen);
	static int Helper_Decrypt_(int cryptMethod, const char * pEncPw, const char * pBuf, size_t bufLen, SString & rText);
	static int Helper_EncodeOtherPw(const char * pEncPw, const char * pPw, size_t pwBufSize, SString & rResult);
	static int Helper_DecodeOtherPw(const char * pEncPw, const char * pPw, size_t pwBufSize, SString & rResult);

	Reference();
	~Reference();
	int    AddItem(PPID obj, PPID * pID, const void * b, int use_ta);
	int    UpdateItem(PPID obj, PPID id, const void *, int logAction /*=1*/, int use_ta);
	int    GetItem(PPID obj, PPID id, void * = 0);
	//
	enum {
		eoIdName = 0x0001, // Инициализировать запрос на поля ObjID и ObjName
		eoIdSymb = 0x0002  // Инициализировать запрос на поля ObjID и Symb
		// Если указаны и eoIdName и eoIdSymb, то запрос результат содержит {ObjID, ObjName, Symb}
	};
	int    InitEnum(PPID objType, int options, long * pHandle);
	//
	// Descr: Инициализирует перечисление записей по одному из дополнительных индексированных
	//   значений, соответствующих ReferenceTbl::Rec::Val1 или ReferenceTbl::Rec::Val2.
	// ARG(objType  IN): тип объекта для перечисления //
	// ARG(valN     IN): @#{1,2} номер поля по которому следует перечислять значения. Это может быть
	//   либо 1 (Val1), либо 2 (Val2)
	// ARG(val      IN): Значение дополнительного поля по которому следует перечислять записи
	// ARG(pHandle OUT): Манипулятор перечисления, который используется в функции Reference::NextEnum.
	//   После завершения работы с перечислением его следует разрушить вызовом Reference::DestroyIter.
	// Returns:
	//   >0 - перечисление успешно инициализировано.
	//   0  - ошибка
	//
	int    InitEnumByIdxVal(PPID objType, int valN, long val, long * pHandle);
	int    NextEnum(long enumHandle, void * pRec);
	int    DestroyIter(long enumHandle);
	SEnum::Imp * Enum(PPID objType, int options);
	SEnum::Imp * EnumByIdxVal(PPID objType, int valN, long val);
	int    EnumItems(PPID obj, PPID * pID, void * = 0);
	//
	// Descr: Загружает в массив pList все элементы справочника типа objType.
	//   Массив pList должен иметь размер элемента равный sizeof(ReferenceTbl::Rec).
	// Returns:
	//   0  - ошибка
	//   <0 - нет ни одного элемента
	//   >0 - в массив pList загружено 1 или более элементов
	//
	int    LoadItems(PPID objType, SVector & rList);
	int    SearchName(PPID obj, PPID * pID, const char * pName, void * pRec = 0);
	int    SearchSymb(PPID, PPID *, const char * pSymb, size_t offs);
	int    CheckUniqueSymb(PPID objType, PPID objID, const char * pSymb, size_t offs);
	//
	// Если (*pID == 0) GetFreeID присваивает ему первый доступный
	// пользовательский идентификатор. Иначе, GetFreeID проверяет
	// не занят ли переданный идентификатор. Если занят - возвращает -1.
	// Если не занят и нет ошибок, возвращает (>0).
	//
	int    GetFreeID(PPID obj, PPID * pID);
	int    RemoveItem(PPID obj, PPID id, int use_ta = 1);
	int    AllocDynamicObj(PPID * pDynObjType, const char * pName, long flags, int use_ta);
	int    FreeDynamicObj(PPID dynObjType, int use_ta);
	//
	// Descr: ищет заданную запись свойств и, если не находит, то
	//   добавляет ее, если находит, то обновляет. Если параметр b == 0 и
	//   запись существует, то она удаляется.
	//
	int    PutProp(PPID obj, PPID id, PPID prop, const void * b, size_t sz = 0, int use_ta = 0);
	int    PutPropVlrString(PPID obj, PPID id, PPID prop, const char *, int use_ta = 0);
	int    GetPropVlrString(PPID obj, PPID id, PPID prop, SString & rBuf);
	int    PutPropSBuffer(PPID obj, PPID id, PPID prop, const SBuffer & rBuf, int use_ta);
	int    GetPropSBuffer(PPID obj, PPID id, PPID prop, SBuffer & rBuf);
	int    FASTCALL GetPropSBuffer_Current(SBuffer & rBuf);
	//
	// Если в функции RemoveProp параметр prop == 0, то удаляются все
	// свойства объекта { obj, id }. В противном случае удаляются только
	// свойства с ИД == prop.
	//
	int    RemoveProperty(PPID objType, PPID objID, PPID prop, int use_ta);
	int    GetProperty(PPID objType, PPID objID, PPID prop, void * pBuf = 0, size_t sz = 0);
	//
	// Descr: Вызывает GetProp(PPOBJ_CONFIG, PPCFG_MAIN, prop, pBuf, sz)
	// Note: Реализована исключительно для упрощения кода.
	//
	int    GetPropMainConfig(PPID prop, void * pBuf, size_t sz);
	int    GetPropActualSize(PPID objType, PPID objID, PPID prop, size_t * pActualSize);
	int    EnumProperties(PPID objType, PPID objID, PPID * pProp, void * pData = 0, uint sz = 0);
	int    GetConfig(PPID, PPID, PPID cfgID, void * = 0, uint sz = 0);
	int    SetConfig(PPID, PPID, PPID cfgID, void *, uint sz = 0);
	int    LoadSecur(PPID objType, PPID objID, PPSecurPacket * pPack);
	int    EditSecur(PPID objType, PPID objID, PPSecurPacket * pPack, int isNew, int use_ta);
	int    RemoveSecur(PPID obj, PPID id, int use_ta);
	int    GetPropArrayFromRecBuf(SVectorBase * pAry);
	int    GetPropArray(PPID obj, PPID id, PPID prop, SVectorBase * pAry);
	int    PutPropArray(PPID obj, PPID id, PPID prop, const SVectorBase * pAry, int use_ta);
protected:
	int    _GetFreeID(PPID obj, PPID * id, PPID firstID);
	int    _Search(PPID obj, PPID id, int spMode, void *);
	int    _SearchProp(PPID obj, PPID id, PPID prop, int spMode, void * pBuf, size_t sz = 0);
private:
	int    PreparePropBuf(PPID obj, PPID id, PPID prop, const void * b, uint s);
	int    ReadPropBuf(void * b, size_t s, size_t * pActualSize);

	PPTblEnumList EnumList;
public:
	PropertyTbl Prop;
	ObjAssoc    Assc;
	ObjTagCore  Ot;
	UnxTextRefCore UtrC;
	TextRefCore TrT;
	ObjVersioningCore * P_OvT;
};
//
// Descr: Система внутренних штрихкодов (PPOBJ_BCODESTRUC)
//
struct PPBarcodeStruc2 {   // @persistent @store(Reference2Tbl+)
	PPBarcodeStruc2();
	//
	// Descr: Типы специализации шаблонов
	//
	enum {
		spcNone     = 0,
		spcUhttSync = 1 // Шаблон кодов для синхронизации с Universe-HTT
	};
	long   Tag;            // Const=PPOBJ_BCODESTRUC
	long   ID;             // @id
	char   Name[48];       // @name
	char   Templ[20];      // Шаблон
	char   Reserve[56];    // @reserve // @v10.7.6 [60]-->[56]
	long   Speciality;     // @v10.7.6 Специальное назначение шаблона
	long   Flags;          // @flags
	long   Reserve1;       // @reserve
	long   Reserve2;       // @reserve
};
//
// @ModuleDecl(QuotationCore)
//
struct QuotFilt : public PPBaseFilt {
	QuotFilt();
	//
	// Descr: Возвращает !0 если фильтр предполагает просмотр истории изменений
	//   текущего значения котировки.
	//   Для выполнения этого условия необходимо, что бы был установлен флаг fSeries
	//   и были не нулевыми члены GoodsID и QuotKindID.
	//
	bool   IsSeries() const;

	enum {
		fAllQuotKinds        = 0x0001, // Все котировки (актуально,
			//	если QuotKindID == 0. Если QuotKindID == 0 && !(Flags & fAllQuotKinds),
			//	тогда рассматривается только базовая котировка
		fAllLocations        = 0x0002, // Показывать только котировки, определенные для всех складов
		fOnlyAbsence = 0x0004, // Только товары, для которых котировка, соответствующая фильтру отсутствует
		fActualOnly  = 0x0080, // (quot2) Только актуальные значения (для quot и так все значения актуальные).
		fCrosstab    = 0x0100, // Кросстаб
		fAbsence     = 0x0400, // Показывать товары, для которых котировка, соответствующая фильтру отсутствует
		fSeries      = 0x0800, // Показывать временной ряд значений.
			// Данный флаг имеет несколько требований непротиворечивости:
			// -- должен быть определен товар GoodsID
			// -- комбинация факторов {QuotKindID, LocID, ArticleID} считается определенной
			// -- QTaID игнорируется //
			//
		fListOnly    = 0x1000, // Функция PPViewQuot::Init_ создает только внутренний список значений котировок (PPQuotItemArray)
		fZeroArOnly  = 0x2000, // Отбирать котировки только с нулевой статьей (применяется для разрешения неоднозначности по критерию ArID == 0).
		fByGroupOnly = 0x4000, // Показывать только котировки привязанные к товарным группам
		fByGoodsOnly = 0x8000  // Показывать только котировки привязанные к товарам
			// @# fByGroupOnly^fByGoodsOnly
	};
	char   ReserveStart[32]; // @anchor @v10.1.2
	int32  InitOrder;        // @anchor Порядок сортировки
	int32  QkCls;            // Класс вида котировки
	DateRange Period;        // (quot2) Период значений
	LDATE  EffDate;          // (quot2) Дата, для которой должны быть действительны отображаемые котировки
	PPID   QTaID;            // (quot2) ИД транзакции изменения котировки
	PPID   SellerID;         // ->Article.ID Продавец
	PPID   SellerLocWorldID; // ->World.ID Ид элемента World, которому должна принадлежать локация LocID
	PPID   BrandID;          //
	PPID   LocID;            //
	PPID   QuotKindID;       //
	PPID   CurID;            //
	PPID   ArID;             //
	PPID   GoodsGrpID;       // if !0, тогда это поле ограничивает перебор товаров только указанной группой
	PPID   GoodsID;          // if !0, то строки развернуты либо по складам, либо по клиентам, либо по видам котировок
	RealRange Val;           // Диапазон значений котировки (0..0 - игнорируется)
	long   Flags;            // @flags
	SubstGrpGoods Sgg;       // @v10.1.2
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
	ObjIdListFilt LocList;   // Список складов
	ObjIdListFilt GoodsList; // @v10.1.3 Список товаров, по которым следует получить отчет. Имеет приоритет перед GoodsGrpID и GoodsID
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};
//
//
//
inline LDATE QIDATE(LDATE d) { return d; } // Служебная конструкция для идентификации конструкторов QuotIdent, в которых использована дата

class QuotIdent { // @transient
public:
	QuotIdent(PPID locID = 0, PPID quotKindID = 0, PPID curID = 0, PPID arID = 0);
	QuotIdent(LDATE dt, PPID locID = 0, PPID quotKindID = 0, PPID curID = 0, PPID arID = 0);
	QuotIdent(const QuotIdent & rS);
	QuotIdent(const PPQuot & rS);
	void   SetBase(double);
	double GetPrevBase() const;
	void   FASTCALL SetIdentPeriod(const DateRange * pPeriod);
	void   FASTCALL SetIdentQtty(const long * pQtty);
	enum {
		fUsePeriod             = 0x0001,
		fUseQtty               = 0x0002,
		fOmitRounding          = 0x0004, // @v10.9.11 @internal Не применять округление при извлечении значения.
		fIgnoreTimeLimitValues = 0x0008  // @v11.9.4 Игнорировать значения, привязанные к времени действия //
	};
	long   Flags;          // @flags
	PPID   LocID;
	PPID   QuotKindID;
	PPID   CurID;
	PPID   ArID;
	LDATE  Dt;        // Дата, для которой проверяется период действия котировки. Если !Dt, то предполагается, что Dt == getcurdate_().
	DateRange Period; // Если (Flags & fUsePeriod), то функции извлечения котировки ищут котировку, у которой период точно соответствует this->Period
	double Qtty_;     // Используется для нахождения значения котировки, ограниченного количеством. Если Qtty == 0.0 то значения с ограничением по количеству не считаются.
private:
	double PrevBase;
};
//
// Descr: Структура товарной котировки.
// Note: Замечание по передаче при синхронизации: эта структура синхронизируется по полям
//   функцией PPObjGoods::SerializePacket. То есть, добавлять новые поля в эту структуру можно,
//   однако менять типы существующий полей недопустимо.
//
struct PPQuot { // @persistent(DBX see Note above)
	//
	// Descr: Реализация форматирования значения котировки.
	//
	static SString & PutValToStr(double val, long flags, SString & rBuf);
	//
	// Descr: Расширенный вариант форматирования значения котировки, включающий так же
	//   период действия и минимальное количество.
	//
	static SString & PutValToStr(double val, long flags, const DateRange & rPeriod, double minQtty, SString & rBuf);

	enum {
		fPctOnCost     = 0x0001, // Наценка в процентах к цене поступления (Cost)  'C' //
		fPctOnPrice    = 0x0002, // Наценка в процентах к цене реализации  (Price) 'P' //
		fPctOnAddition = 0x0004, // Наценка в процентах к наценке (Price-Cost)     'D' //
		fPctDisabled   = 0x0008, // Заблокированная котировка                      'X' //
		fPctOnBase     = 0x0010, // Наценка в процентах к базовой котировке        'Q' //
		fWithoutTaxes  = 0x0020, // @construction Цена указана без налогов 'F' //
		fZero  = 0x0040, // Явно заданное нулевое значение.
		fActual        = 0x0080, // @transient Специализированный флаг -
			// используется для индикации признака актуальной котировки во временных структурах.
			// В базе данных не сохраняется.
		fDbUpd = 0x0100, // @transient Устанавливается функциями изменения списка котировок
			// в тех элемента PPQuotArray, которые были реально изменены в БД.
		fAggrCount     = 0x0200, // @v10.1.3 @transient Специальный флаг, указывающий, что значение хранит
			// аггрегированное суммарное количество котировок, соответствующих заданным критериям.
			// Используется только в отчетах
		fDbMask        = (fPctOnCost|fPctOnPrice|fPctOnAddition|fPctDisabled|fPctOnBase|fWithoutTaxes|fZero)
	};
	//
	// Descr: Классы котировок
	//
	enum {
		clsGeneral = 0,   // Обычные котировки
		clsMtx,           // Товарная матрица и ограничение товарной матрицы
		clsMtxRestr,      // Ограничения товарной матрицы
		clsSupplDeal,     // Контрактные цены и допуски контрактных цен
		clsPredictCoeff   // Поправочные коэффициенты прогноза продаж
	};
	//
	// Descr: Определяет, принадлежит ли склад locID котировки множеству ограничивающих
	//   складов rLocList.
	//   Здесь правила следующие:
	//   1. Если rLocList.getCount() == 0, то locID является допустимым
	//   2. Если locID - член списка rLocList, то является допустимым
	//   3. Если locID является группирующим складом и один из членов rLocList - дочерний
	//      элемент этой группы (по всей иерархии), то locID является допустимым
	// Returns:
	//   >0 - locID является приемлемым складом при ограничении rLocList
	//   0  - locID не  вляется приемлемым складом при ограничении rLocList
	//
	static int FASTCALL IsQuotAcceptableForLoc(PPID locID, const PPIDArray & rLocList);

	explicit PPQuot(PPID goodsID = 0);
	PPQuot(const QuotationTbl::Rec &);
	PPQuot & FASTCALL operator = (const QuotationTbl::Rec &);
	QuotIdent & FASTCALL MakeIdent(QuotIdent & rQi) const;
	void   Clear();
	enum {
		cmpFull  = 0x0000,
		cmpNoID  = 0x0001, // Не брать в рассмотрение ИД котировки
		cmpNoVal = 0x0002  // Не брать в рассмотрение значение котировки
	};
	bool   IsEq(const PPQuot & rS, long cmpFlags = 0) const;
	bool   IsRelative() const;
	bool   IsEmpty() const;
	double CalcPrice(double cost, double price) const;
	void   FASTCALL GetFromRec(const QuotationTbl::Rec &);
	int    FASTCALL GetValFromStr(const char * pStr);
	SString & FASTCALL PutValToStr(SString & rBuf) const;
	int    FASTCALL CheckForVal(const RealRange * pRange) const;
	int    FASTCALL CheckForFilt(const QuotFilt * pFilt, const PPIDArray * pKindList) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	PPID   ID;
	PPID   ArID;
	PPID   GoodsID;
	PPID   LocID;
	PPID   Kind;
	PPID   CurID;
	long   Flags;
	long   MinQtty;
	DateRange Period;  // Период действия котировки
	double Quot;
	PPID   SellerArID; // @transient (special for UHTT) ИД статьи-поставщика
	PPID   RelID;      // @transient
	PPID   QTaID;      // @transient
	LDATETIME Dtm;     //
};

class PPQuotArray : public TSVector <PPQuot> {
public:
	explicit PPQuotArray(PPID goodsID = 0);
	PPQuotArray(const PPQuotArray & s);
	PPQuotArray & FASTCALL operator = (const PPQuotArray &);
	//
	// Descr: Формирует сортированный уникальный список видок котировок, представленных в this
	//
	int    GetQuotKindIdList(PPIDArray & rIdList) const;
	//
	// Descr: Устанавливает значение котировки в соответствии с идентифицирующим блоком rQi.
	// Returns:
	//   >0 - номер позиции, в которой было изменено значение либо номер позиции, по которой новое
	//    значение было добавлено. Нумерация начинается с 1. То есть, чтобы получить измененное (вставленное)
	//    значение необходимо вызвать PPQuotArray::at(PPQuotArray::SetQuot()-1) (естественно, необходимо проверить результат на условие >0)
	//   0 - error.
	//
	int    SetQuot(const QuotIdent & rQi, double val, long flags, long minQtty, const DateRange * pPeriod); // minQtty - @v5.5.2 VADIM; minQtty < 0 - don`t update
	bool   FASTCALL SearchQi(const QuotIdent & rQi, uint * pPos) const;
	//
	// Descr: Возвращает список позиций значений котировок, удовлетворяющих условиям rQi
	// Returns:
	//   >0 - найдено по крайней мере одно значение
	//   <0 - не найдено ни одного значения, удовлетворяющего условиям rQi
	//
	int    FASTCALL SearchQiList(const QuotIdent & rQi, LongArray & rPosList) const;
	//
	// Descr: ищет в массиве котировку, соответствующую идентификатору pIdent.
	//   -- Если такая котировка найдена, то она присваивается по указателю pQuot и функция //
	//   возвращает значение больше нуля (> 0).
	//   -- Если котировка не найдена, то объект по указателю pQuot заполняется //
	//   в соответствии с идентификатором pIdent (pQuot->Quot = 0, pQuot->Flags = 0)
	//   и функция возвращает ноль (0).
	// Precondition:
	//   -- pIdent hasn't to be 0
	//   -- pQuot can be 0.
	//
	int    GetQuot(const QuotIdent & rIdent, PPQuot * pQuot) const; // @>>PPQuotArray::Search
	int    SearchNearest(const QuotIdent & rIdent, uint * pPos) const;
	//
	// Descr: Ищет наиболее подходящую для заданного идентификатора pIdent котировку
	//   и возвращает рассчитанное на ее основе значение и по заданным цене поступления (cost)
	//   и цене реализации (price) по указателю pResult.
	// ARG(rIdent  IN)  - ссылка на экземпляр структуры QuotIdent, идентифицирующей условия использования котировки
	//   идентифицирующей условия использования котировки
	// ARG(cost    IN)  - цена поступления, на основе которой будет рассчитано значение котировки,
	//   если найденная котировка окажется относительной (привязанной либо к цене поступления, либо к наценке)//
	// ARG(price   IN)  - цена реализации, на основе которой будет рассчитано значение котировки,
	//   если найденная котировка окажется относительной (привязанной либо к цене реализации, либо к наценке)
	// ARG(pResult OUT) - указатель, по которому функция вернет рассчитанное значение найденной котировки.
	// Returns:
	//   0  - ошибка
	//   1  - найдена подходящая котировка
	//   2  - найдена подходящая котировка, но ее значение "Заблокирована"
	//   3  - подходящая котировка не найдена, но значение вычислено по правилам, заданным в виде котировки // @v12.0.10
	//   -1 - подходящая котировка не найдена (*pResult = 0)
	//
	int    GetResult(const QuotIdent & rIdent, double cost, double price, double * pResult) const;
		// @>>PPQuotArray::SearchNearest
	void   Sort();
	//
	// Descr: проверяет является-ли котировка извлекаемая с помощью pIdent заблокированной
	//   по следующему правилу:
	//   -- Если эта котировка заблокированная или имеется заблокированная котировка с более высоким приоритетом
	//   Рассматриваются только котировки, вид которых принадлежит множеству pQKList. Если pQKList нулевой, то
	//   рассматриваются все котировки.
	//   Если в данном массиве не найдена котировка по pIdent и pParentQuots не нуль, то проверяем данную котировку
	//   на предмет блокировки в этом массиве (pParentQuots - котировки на группу, к которой принадлежит данный товар).
	//
	int    IsDisabled(const QuotIdent & rIdent, const PPIDArray * pQKList = 0, PPQuotArray * pParentQuots = 0);
	//
	// Descr: удаляет из массива те котировки, которые ссылаются на несуществующие
	//   склады. Вызывается при передаче пакета в другой раздел функцией PPObjGoods::Read().
	//
	int    RemoveHangedLocations(); // @<<PPObjGoods::Read
	//
	// Descr: Устанавливает список складов, по которым котировки, находящиеся в базе данных,
	//   но не принадлежащие this могут быть удалены. Если pList == 0 или pList->getCount() == 0,
	//   то функция CanUpdateQuot будет считать, что все котировки по товару GoodsID, не принадлежащие
	//   this могут быть удалены из базы данных.
	//
	void   SetManagedLocList(const PPIDArray * pList);
	//
	// Descr: Определяет можно ли удалить из базы данных котировку rQuot.
	//   Эта функция вызывается в QuotationCore::SetCurrList для котировок,
	//   находящихся в базе данных, но не принадлежащих this.
	//
	int    FASTCALL CanUpdateQuot(const PPQuot & rQuot) const; // @<<QuotationCore::SetCurrList
	//
	// Descr: Корректирует проблему, появившуюся в релизе 7.2.1 и исправленную в 7.8.3.
	//   Суть проблемы в том, что в базу данных попадало несколько значений с идентичными факторами
	//   и, соответственно, атрибутом Actual == 1.
	//   Проблема сказывается только на котировках первого поколения (QuotationTbl).
	//
	int    Correct721(PPLogger * pLogger);
	int    DebugLog() const;

	PPID   GoodsID;
private:
	PPIDArray ManagedLocList; // @transient Список складов, по которым можно удалять
		// котировки из базы данных, если они не принадлежат множеству this.
};
//
// Descr: Специализированная структура для обмена значениями котировок с внешними приложениями.
//
struct PPQuotItem_ { // @persistent
	PPQuotItem_();
	PPQuotItem_(const PPQuot & rS);
	int    FASTCALL Get(PPQuot & rDest) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	int32  GoodsID;
	int32  KindID;
	int32  LocID;
	int32  ArID;
	int32  CurID;
	int32  MinQtty;
	DateRange Period;
	LDATETIME Dtm;
	int32  Flags;
	double Val;
};

class PPQuotItemArray : public TSVector <PPQuotItem_> {
public:
	PPQuotItemArray();
	int    FASTCALL Add(const PPQuotItem_ & rItem);
	int    FASTCALL Add(const PPQuot & rQ);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Флаги функции PPQuotItemArray::Replace
	//
	enum {
		rfGt    = 0x0001, // Заменять значение, если время установки нового значение превышает существующее
		rfLt    = 0x0002, // Заменять значение, если время установки нового значения меньше существующего
		rfCount = 0x0004  // @v10.1.3 Устанавливать величину котировки как количество значение (для агрегирующих отчетов)
	};
	int    Set(const PPQuot & rQ, long flags);
	void   Sort();
};

class QuotationCore : public QuotationTbl {
public:
	QuotationCore();
	int    Search(PPID id, void * = 0);
	//
	// Descr: Изменяет одну котировку.
	// ARG(pID IN/OUT): Идентификатор котировки (если необходимо изменить существующую).
	// ARG(pQuot   IN): Параметры котировки
	// ARG(logSj   IN): записывать в системный журнал событие (PPACN_GOODSQUOTUPD, PPACN_GOODSMTXUPD).
	//   Если ничего не изменилось, то и событие не записывается, даже если logSj != 0.
	// ARG(use_ta  IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   <0 - котировка не была изменена, поскольку pQuot не отличается от записи с идентификатором *pID
	//   >0 - котировка была изменена (добавлена/удалена).
	// 1000 - котировка была изменена (добавлена/удалена). При этом, котировка относится к товарной матрице.
	// 2000 - котировка была изменена (добавлена/удалена). При этом, котировка является ограничением по товарной матрице.
	//    0 - error
	//
	int    SetCurr(PPID * pID, const PPQuot * pQuot, int logSj, int use_ta);
	int    SetCurrList(const PPQuotArray & rQuotList, const PPQuotArray * pTemplate, bool noRmv, int use_ta);
	int    GetCurrList(PPID goodsID, PPID quotKindID, PPID loc, PPQuotArray &);
	int    GetCurr(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache = 0);
	int    GetNearest(PPID goodsID, const QuotIdent & pIdent, PPQuot * pQuot, int useCache);
	int    GetMatrix(PPID mtxQkID, PPID locID, PPIDArray * pList);
	int    GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    BelongToMatrix(PPID goodsID, PPID locID);
	//
	// Descr: Кэшированное извлечение списка котировок для товара goodsID.
	// Returns:
	//   >0 - список котировок успешно извлечен (это не означает, что список не пустой).
	//   <0 - кэш котировок не существует (практически это невозможно).
	//   0  - ошибка при извлечении списка.
	//
	int    FetchList(PPID goodsID, PPQuotArray & rList);
	//
	// Descr: Кэшированное извлечение матрицы товаров по складу locID.
	//
	int    GetMatrix(PPID locID, PPIDArray * pResult);
	//
	// Descr: Объявляет котировки по товару goodsID в кэше недействительными
	//
	int    DirtyGoodsID(PPID goodsID);
	//
	// Descr: Очищает кэш котировок
	//
	int    ClearCache();
	//
	// Descr: Объявляет матрицы товаров по списку складов pMtxLocList в кэше недействительными.
	//   Если pMtxLocList == 0 || pMtxLocList->getCount() == 0, то объявляет недействительными
	//   все товарные матрицы.
	//
	int    DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList, int deferred);
	//
	// Descr: Заменяет все ссылки на статью replacedID ссылками на newID
	//
	int    ReplaceArticleRefs(PPID replacedID, PPID newID, int use_ta);
	int    GetMatrixListByLoc(PPID mtxQkID, PPID locID, PPIDArray & rList, PPIDArray & rNegList);
		// @<<QuotationCore::GetMatrix
};
//
// Descr: Вторая реализация котировок
//
class Quotation2Core : public Quotation2Tbl {
public:
	static int FASTCALL PeriodToPeriodIdx(const DateRange * pPeriod, int32 * pPeriodIdx);
	static int FASTCALL PeriodIdxToPeriod(int32 periodIdx, DateRange * pPeriod);

	Quotation2Core();
	int    VerifyRecord(Quotation2Tbl::Rec & rRec);
	int    Verify();
	int    GetRelByID(PPID relID, PPQuot * pVal);
	int    GetRel(const PPQuot * pVal, PPID * pID, int createIfNExists, int use_ta);
	int    GetRelListByFilt(const QuotFilt * pFilt, PPIDArray & rList);
	int    Get(PPID goodsID, PPID relID, LDATETIME * pAfter, PPQuotArray * pList);
	int    GetAfterDT(const LDATETIME & rAfter, PPQuotArray *pList); //v10.5.8 @erik
	int    GetBeforeDT(const LDATETIME & rBefore, const  PPID & rGoodsID, const  PPID & rRelID, PPQuot *pQuot); //v10.5.8 @erik
	int    GetCurrList(PPID goodsID, PPID quotKindID, PPID locID, PPQuotArray & rQuotList);
	int    GetCurrListByRelList(PPID goodsID, const PPIDArray & rRelList, PPQuotArray & rQuotList);
	int    GetCurr(PPID goodsID, const QuotIdent & pIdent, double cost, double price, double * pQ, int useCache);
	int    GetNearest(PPID goodsID, const QuotIdent & pIdent, PPQuot * pQuot, int useCache);
	//
	// Descr: Возвращает список идентификаторов товаров, имеющих котировки по фактору relID.
	//   Если параметр actualOnly != 0, то возвращается только список тех товаров,
	//   для которых есть актуальные записи.
	//
	int    GetGoodsList(PPID relID, int actualOnly, PPIDArray & rList);
	int    Set(const PPQuot & rQ, long qtaID, int logSj, int use_ta);
	int    Set(PPQuotArray & rQList, long qtaID, int use_ta);
	int    Set_(const PPQuotArray & rQList, long qtaID, const PPQuotArray * pTemplate, bool noRmv, bool updByTime, int use_ta);
	int    RemoveAllForQuotKind(PPID quotKindID, int use_ta);
	int    GetAddressLocList(PPIDArray & rList);
	int    FetchRel(PPID relID, PPQuot * pVal);
	void   RecToQuot(const Quotation2Tbl::Rec * pRec, PPQuot & rQuot);
	void   RecToQuotRel(const Quotation2Tbl::Rec * pRec, PPQuot & rQuot);
	int    FetchList(PPID goodsID, PPQuotArray & rList);
	int    GetMatrix(PPID mtxQkID, PPID locID, PPIDArray * pList);
	int    GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    BelongToMatrix(PPID goodsID, PPID locID);
	//
	// Descr: Кэшированное извлечение матрицы товаров по складу locID.
	//
	int    GetMatrix(PPID locID, PPIDArray * pResult);
	int    GetMatrixListByLoc(PPID mtxQkID, PPID locID, PPIDArray & rList, PPIDArray & rNegList);
	//
	// Descr: Объявляет котировки по товару goodsID в кэше недействительными
	//
	int    DirtyGoodsID(PPID goodsID);
	//
	// Descr: Очищает кэш котировок
	//
	int    ClearCache();
	//
	// Descr: Объявляет матрицы товаров по списку складов pMtxLocList в кэше недействительными.
	//   Если pMtxLocList == 0 || pMtxLocList->getCount() == 0, то объявляет недействительными
	//   все товарные матрицы.
	//
	int    DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList, int deferred);
	int    ReplaceObj(PPID objType, PPID replacedID, PPID newID, int use_ta);
	//
	// Descr: Опции функции DumpCurrent
	//
	enum {
		dumpfIgnoreTimestamp = 0x0001
	};
	int    DumpCurrent(SBuffer & rBuf, long flags, int64 * pItemsCount);
	int    UndumpCurrent(SBuffer & rBuf, int use_ta);

	Quot2RelTbl RelT;
private:
	int    AdjustTime(Quotation2Tbl::Rec & rRec);
	int    Helper_ReplaceRel(PPID replacedRelID, PPID newRelID, int use_ta);
	int    RemoveAllForRel(PPID relID, const char * pPctMsg, int use_ta);
	int    Implement_Set(const PPQuot & rQ, long qtaID, int logSj, bool keepTime, int use_ta);
};
//
//
//
class QuotUpdFilt : public PPBaseFilt {
public:
	QuotUpdFilt();
	QuotUpdFilt & FASTCALL operator = (const QuotUpdFilt & s);
	int    FASTCALL IsQuotByAdvOptExists(const PPQuotArray *) const;
	int    FASTCALL IsQuotSuitesToAdvOpt(const PPQuot &) const;
	//int    Write(SBuffer & rBuf, long) const;
	int    Read_Pre720(SBuffer & rBuf, long);

	enum { // ByWhat
		byLots = 0,  // Изменение по ценам последнего лота
		byLastReval, // По последней переоценке
		byPctVal,    // По процентной величине QuotVal
		byAbsVal,    // По абсолютной величине QuotVal:QuotFlags
		byAddedQuot, // По значению котировки AdvOptQuotKindID:AdvOptLocID
		byDelete,    // Удалить
		byFormula    // По формуле
	};
	enum {
		fExistOnly = 0x0001,  // Обновлять только существующие котировки
		fNonExistOnly      = 0x0002,  // Устанавливать только несуществующие котировки
		fSetupIfNotExists  = 0x0004,  // Обновить существующие и установить несуществующие
		fWarnExistsAbsQuot = 0x0008,  // Предупреждать о замене абсолютной котировки относительной
		fSkipNoDisGoods    = 0x0010,  // Не изменять котировки для товаров с признаком "Без скидки" (GF_NODISCOUNT)
		fSkipDatedQuot     = 0x0020,  // Не изменять значения котировок, заданные с периодом
		fSetupDatedSamples = 0x0040,  // Устанавливать значения котировок по образцу вместе с периодом действия
		fTest              = 0x0080   // @erik Тестовый запуск (только в режиме DEVELOPMENT)
	};
	char   ReserveStart[12]; // @anchor
	DateRange FiltQuotPeriod; // Фильтрующий критерий периода для значений котировок
	PPID   GoodsID;          //
	DateRange QuotValPeriod; // Период, устанавливаемый в значения котировок
	PPID   QuotKindID;       //
	PPID   GoodsGrpID;       //
	PPID   ArticleID;        //
	PPID   RegisterOpID;     // Вид драфт-операции для создания документа, фиксирующего список товаров,
		// для которых изменилось значение котировки.
	int    ByWhat;           //
	long   Flags;            //
	long   EvTokID;          //
	long   QuotFlags;        //
	double QuotVal;          //
	// доп. условия для изменения котировок
	// (у данного товара на данном складе должна быть котировка с ук. ценой) {
	PPID   AdvOptQuotKindID; //
	PPID   AdvOptLocID;      //
	double AdvOptQuot;       //
	// } доп. условия для изменения котировок
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
	ObjIdListFilt LocList;   //
	ObjIdListFilt EventList; //
	ObjIdListFilt ArList;    //
	SString Formula;         //
	//
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};
//
// Стандарты штрихкодов
// В квадратных скобках приведены коэффициенты печати широких и узких полос (Print ratio)
// @v12.0.7 Определения перестроены таким образом, чтобы напрямую формироваться из UED-констант
//
#define BARCSTD_CODE11          UED::GetRawValue32(UED_BARCODESYMB_CODE11)/*1*/ // Code 11 (USD-8)                [2:1 - 3:1]
#define BARCSTD_INTRLVD2OF5     UED::GetRawValue32(UED_BARCODESYMB_INTERLEAVED2OF5)/*2*/ // Interleaved 2 of 5             [2:1 - 3:1]
#define BARCSTD_CODE39          UED::GetRawValue32(UED_BARCODESYMB_CODE39)/*3*/ // Code 39 (USD-3 & 3 of 9)       [2:1 - 3:1]
#define BARCSTD_CODE49          UED::GetRawValue32(UED_BARCODESYMB_CODE49)/*4*/ // Code 49                        [Fixed]
#define BARCSTD_PDF417          UED::GetRawValue32(UED_BARCODESYMB_PDF417)/*5*/ // PDF417                         [Fixed]
#define BARCSTD_EAN8            UED::GetRawValue32(UED_BARCODESYMB_EAN8)/*6*/ // EAN-8                          [Fixed]
#define BARCSTD_UPCE            UED::GetRawValue32(UED_BARCODESYMB_UPCE)/*7*/ // UPC-E                          [Fixed]
#define BARCSTD_CODE93          UED::GetRawValue32(UED_BARCODESYMB_CODE93)/*8*/ // Code 93 (USS-93)               [Fixed]
#define BARCSTD_CODE128         UED::GetRawValue32(UED_BARCODESYMB_CODE128)/*9*/ // Code 128 (USD-6)               [Fixed]
#define BARCSTD_EAN13           UED::GetRawValue32(UED_BARCODESYMB_EAN13)/*10*/ // EAN-13                         [Fixed]
#define BARCSTD_IND2OF5         UED::GetRawValue32(UED_BARCODESYMB_IND2OF5)/*11*/ // Industial 2 of 5               [2:1 - 3:1]
#define BARCSTD_STD2OF5         UED::GetRawValue32(UED_BARCODESYMB_STD2OF5)/*12*/ // Standard 2 of 5                [2:1 - 3:1]
#define BARCSTD_ANSI            UED::GetRawValue32(UED_BARCODESYMB_ANSI)/*13*/ // ANSI Codabar (USD-4 & 2 of 7)  [2:1 - 3:1]
#define BARCSTD_LOGMARS         UED::GetRawValue32(UED_BARCODESYMB_LOGMARS)/*14*/ // LOGMARS                        [2:1 - 3:1]
#define BARCSTD_MSI             UED::GetRawValue32(UED_BARCODESYMB_MSI)/*15*/ // MSI                            [2:1 - 3:1]
#define BARCSTD_PLESSEY         UED::GetRawValue32(UED_BARCODESYMB_PLESSEY)/*16*/ // Plessey                        [2:1 - 3:1]
#define BARCSTD_UPCEAN2EXT      UED::GetRawValue32(UED_BARCODESYMB_UPCEAN2EXT)/*17*/ // UPC/EAN Extensions 2           [Fixed]
#define BARCSTD_UPCEAN5EXT      UED::GetRawValue32(UED_BARCODESYMB_UPCEAN5EXT)/*18*/ // UPC/EAN Extensions 5           [Fixed]
#define BARCSTD_UPCA            UED::GetRawValue32(UED_BARCODESYMB_UPCA)/*19*/ // UPCA                           [Fixed]
#define BARCSTD_POSTNET         UED::GetRawValue32(UED_BARCODESYMB_POSTNET)/*20*/ // PostNet                        [Fixed]
#define BARCSTD_QR              UED::GetRawValue32(UED_BARCODESYMB_QR)/*21*/ // QR-code
#define BARCSTD_DATAMATRIX      UED::GetRawValue32(UED_BARCODESYMB_DATAMATRIX)/*22*/ // DataMatrix
#define BARCSTD_AZTEC           UED::GetRawValue32(UED_BARCODESYMB_AZTEC)/*23*/ // @v11.9.2
#define BARCSTD_DATABAR         UED::GetRawValue32(UED_BARCODESYMB_DATABAR)/*24*/ // @v11.9.2
#define BARCSTD_MICROQR         UED::GetRawValue32(UED_BARCODESYMB_MICROQR)/*25*/ // @v11.9.2 MicroQR-code
#define BARCSTD_ITF             UED::GetRawValue32(UED_BARCODESYMB_ITF)/*26*/ // @v11.9.2
#define BARCSTD_MAXICODE        UED::GetRawValue32(UED_BARCODESYMB_MAXICODE)/*27*/ // @v11.9.2
#define BARCSTD_RMQR            UED::GetRawValue32(UED_BARCODESYMB_RMQR)/*28*/ // @v11.9.2
//
// Конфигурация справочника товаров
// sizeof(PPGoodsConfig) == PROPRECFIXSIZE
//
// Опции справочника товаров
//
#define GCF_SUPPRLZERO                   0x00000001L  // Забивать ведущие нули в штрих-коде
#define GCF_ENABLEWP                     0x00000002L  // Разрешать ввод весового префикса
#define GCF_BCCHKDIG                     0x00000004L  // Штрихкод содержит контрольную цифру
#define GCF_BCNDIG                       0x00000008L  // В штрихкоде допускаются нецифровые символы
#define GCF_DISABLEWOTAXFLAG             0x00000010L  // Запрет установки флага "Цены без налогов"
#define GCF_LOADTOSCALEGID               0x00000020L  // На весы загружать вместо штрихкода строку,
	// состоящую из весового префикса и пятизначного идентификатора товара.
	// Такие сложности нужны для работы с кассой Ладога-Ф
#define GCF_FORCEBARCODE                 0x00000040L  // Запрет на ввод товара без штрихкода
#define GCF_RETAILPRICEBYMOSTRECENTLOT   0x00000080L  // Определять розничную цену по самому последнему лоту.
	// Если этот флаг не установлен, то функция ReceiptCore::GetCurrentGoodsPrice игнорирует флаг GPRET_MOSTRECENT
#define GCF_DONTSELPASSIVE               0x00000100L  // Не показывать пассивные товары в списках
#define GCF_XCHG_DONTRCVTAXGRPUPD        0x00000200L  // Не принимать изменение налоговой группы из другого раздела
#define GCF_ADDTOALTGRPWITHOUTMSG        0x00000400L  // Добавлять товар в альт. группу без предупреждения //
#define GCF_ONUNITEMOVEBARCODE           0x00000800L  // При объединении товаров переносить штрихкоды
#define GCF_VALID                        0x00001000L  // @transient Запись инициализирована
#define GCF_USEGOODSMATRIX               0x00002000L  // Использование матрицы товаров
#define GCF_XCHG_RCVSTRUCUPD             0x00004000L  // Принимать изменения товарных структур из других разделов
#define GCF_USESCALEBCPREFIX             0x00008000L  // Использовать весовые префиксы, определенные в записях весов
#define GCF_USEBRANDINGSELEXTDLG         0x00010000L  // Использовать бренд в расширенном диалоге ввода в товарных строках
#define GCF_AUTOPREFBARCODE              0x00020000L  // Автоматически присваивать первому штрихкоду признак предпочтительного
#define GCF_DONTDELFROMMTXGOODSINOPENORD 0x00040000L  // Не удалять из матрицы товары, которые находятся в отрытых заказах
#define GCF_XCHG_SENDGENGOODSCONTENT     0x00080000L  // Передавать в другие разделы содержимое обобщенных товаров
#define GCF_SHOWGSTRUCPRICE              0x00100000L  // В диалоге товарной структуры в списке вместо цены поступления показывать цену реализации
#define GCF_XCHG_SENDALTGROUP            0x00200000L  // Передавать в другие разделы альтернативные группы (не динамические) с содержимым
#define GCF_XCHG_SENDATTACHMENT          0x00400000L  // Передавать в другие разделы привязанные к товарам файлы (обычно, изображения)
#define GCF_IGNOREFOLDERMATRIX           0x00800000L  // Игнорировать значения товарной матрицы, установленные для товарных групп верхнего уровня
#define GCF_XCHG_RCVSTRUCFROMDDONLY      0x01000000L  // Принимать изменения товарных стуктур только из диспетчерского раздела
#define GCF_BANSTRUCCDONDECOMPL          0x02000000L  // Запрет на общий множитель для декомплектующих структур
#define GCF_XCHG_DONTRCVQUOTS            0x04000000L  // @v11.3.3 Не принимать котировки из другого раздела

struct PPGoodsConfig { // @persistent @store(PropertyTbl)
	PPGoodsConfig();
	PPGoodsConfig & Z();
	size_t GetSize_Pre770() const { return (size_t)(PTR8C(&Ver__) - PTR8C(this)); }
	//
	// Descr: Определяет, является ли заданный штрихкод весовым
	// Returns:
	//   1 - префикс строки pBarcode совпадает с WghtPrefix
	//   2 - префикс строки pBarcode совпадает с WghtCntPrefix
	//   0 - pBarcode == 0 или префикс pBarcode не совпадает ни с WghtPrefix,
	//     ни с WghtCntPrefix (пустое значение WghtPrefix или WghtCntPrefix автоматически
	//     означает несовпадение).
	//
	int    FASTCALL IsWghtPrefix(const char * pBarcode) const;
	//
	// Descr: Возвращает список допустимых длин тованых штрихкодов
	//
	int    GetCodeLenList(PPIDArray * pList, int * pAllowEmpty) const;

	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_GOODSCFG
	char   BarCodeLen[32];     // Список допустимых длин штрих-кодов напр.: "7,11"
	char   WghtPrefix[12];     // Префикс к штрих-коду весового товара
	long   Flags;              //
	PPID   DefUnitID;          // ->Ref(PPOBJ_UNIT)
	PPID   DefPckgTypeID;      //
	int16  MinUniqBcLen;       // Мин длина штрих-кода по которому допускается идентифицировать товар при передаче между разделами БД
	int16  ACGI_Threshold;     // Количество дней с даты последнего прихода товара, в течении которых еще следует
		// загружать полностью израсходованный товар на кассы при полной загрузке (0 = infinity)
		// @v4.6.6 Этот параметр также определяет выбор товаров по цене лота
		// (просматриваются лоты, дата (Receipt.Dt) которых >= (OperDate-ACGI_Threshold))
	PPID   AssetGrpID;         // ->Ref(PPOBJ_GOODSGROUP) Группа основных средств
	PPID   MtxQkID;            // ->Ref(PPOBJ_QUOTKIND) Вид котировки товарной матрицы
	PPID   OwnArCodeCntrID;    // ->Ref(PPOBJ_OPCOUNTER) Счетчик собственных артикулов
	PPID   TareGrpID;          // ->Ref(PPOBJ_GOODSGROUP) Группа тары (для учета остатков по контрагентам)
	PPID   MtxRestrQkID;       // ->Ref(PPOBJ_QUOTKIND) Вид котировки ограничение товарной матрицы
	char   WghtCntPrefix[12];  // Префикс счетного весового товара (возможен специальный вариант передачи на весы).
	PPID   DefGroupID;         // Товарная группа по умолчанию
	SVerT  Ver__;              // @anchor Версия, сформировавшая запись. Если размер считанной записи меньше или равен, чем (&Ver-this), то версия предшествует 7.7.0
	PPID   BcPrefixGuaTagID;   // Тег, содержащий допустимые префиксы штрихкодов для глобальной учетной записи
	PPID   DefGoodsID;         // Товар по умолчанию для подстановки вместо неопределенных или не идентифицированных товаров
	uint8  Reserve[8];         //
	TagFilt TagIndFilt;        // @anchor Фильтр тегов, определяющий окраску наименований товаров в отчетах
};
//
//
//
#define PPGDSK_GROUP               1L // Группы товаров
#define PPGDSK_GOODS               2L // Товары
#define PPGDSK_PCKGTYPE            3L // Типы пакетов
#define PPGDSK_TRANSPORT           4L // Транспортные средства
#define PPGDSK_BRAND               5L // Брэнды
#define PPGDSK_BRANDGROUP          6L // Группы брэндов
#define PPGDSK_SUPRWARE            7L // Составные товары // @vmiller
#define PPGDSK_COMPUTER            8L // @v11.9.11 Компьютерный юнит. Имеется в виду физический компьютер, находящийся на балансе/обслуживании
#define PPGDSK_SWPROGRAM           9L // @v11.9.11 Компьютерная программа. 
//
// Внутрение типы штрихкодов, отражающие специфику товарного кода.
//
#define BARCODE_TYPE_UNDEF        -1
#define BARCODE_TYPE_COMMON        0
#define BARCODE_TYPE_PREFERRED  1000 // Предпочтительный код. Когда необходим единственный код из списка, то код этим признаком используется с приоритетом.
#define BARCODE_TYPE_MARKED    10000 // Маркированный код (на товар нанесена специальная марка тупого российского государства, которое обирает вдов и сирот, обогащая жирных придурков)
#define BARCODE_TYPE_PREFMARK  11000 // 
//
// Функции для работы с внутренними типами штрихкодов
//
int32 FASTCALL MakeInnerBarcodeType(int bt);
void  FASTCALL SetInnerBarcodeType(int32 * pBarcodeType, int bt);
void  FASTCALL ResetInnerBarcodeType(int32 * pBarcodeType, int bt);
int   FASTCALL IsInnerBarcodeType(int32 barcodeType, int bt);

class BarcodeArray : public TSVector <BarcodeTbl::Rec> {
public:
	int    Add(const char * pCode, long codeType, double qtty);
	void   Arrange();
	//
	// Descr: Флаги функции GetSingleItem
	//
	enum {
		sifValidEanUpcOnly = 0x0001 // @v11.9.9 Возвращает только строго валидный EAN или UPC код
	};
	//
	// Descr: Возвращает единственный штрихкод из списка. Порядок предпочтения следующий:
	//    1. Если в списке нет ни одного элемента, то rBuf = 0 и код возврата -1.
	//    2. Если в списке единственный код, то возвращается он.
	//    3. Если в списке есть приоритетный код (BarcodeType == 1000 == BARCODE_TYPE_PREFERRED), то возращается он.
	//    4. Если в списке есть код с количеством == 1.0 то возвращается первый такой код (по порядку следования в списке)
	//    5. Если все предыдущие критерии не нашли своего удовлетворения, то возвращается самый первый код из списка.
	// Returns:
	//    <0 - список пуст
	//    2 - функция вернула приоритетный код, ассоциированный с количеством 1.0
	//    3 - функция вернула приоритетный код, ассоциированный с количеством, отличным от 1.0
	//    1 - функция вернула код по одному из критериев {2, 4, 5}
	//
	int    GetSingle(uint sifFlags/*BarcodeArray::sifXXX*/, SString & rBuf) const;
	int    SearchCode(const char * pCode, uint * pPos) const;
	const  BarcodeTbl::Rec * GetSingleItem(uint * pPos, uint sifFlags/*BarcodeArray::sifXXX*/) const;
	const  BarcodeTbl::Rec * FASTCALL GetPreferredItem(uint * pPos) const;
	int    FASTCALL SetPreferredItem(uint pos);
	int    Replace(const char * pSearchCode, const char * pReplaceCode);
};
//
//
//
#define CARGOUNIT_ITEM   1
#define CARGOUNIT_PCKG   2
#define CARGOUNIT_PALLET 3

typedef TSVector <ArGoodsCodeTbl::Rec> ArGoodsCodeArray;
//
// Descr: Параметры товара для заказа, транспортировки и хранения //
//   Property {PPOBJ_GOODS, Goods2.ID, GDSPRP_STOCKDATA}
//
struct GoodsStockExt { // @persistent(DBX) @size=28+2*sizeof(SArray)
	//
	// Descr: Описание упаковки товара на паллете
	//
	struct Pallet { // @persistent @size=12
		Pallet();
		bool   IsValid() const;

		PPID   PalletTypeID;   // ->Ref(PPOBJ_PALLET) Тип паллета
		int16  PacksPerLayer;  // Количество упаковок поставки в одном слое
		int16  MaxLayers;      // Максимальное число слоев на паллете
		uint32 Reserve;
	};
	GoodsStockExt();
	GoodsStockExt & Z();
	GoodsStockExt & FASTCALL operator = (const GoodsStockExt & rSrc);
	int    FASTCALL IsEq(const GoodsStockExt & rS) const;
	bool   IsEmpty() const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Рассчитывает массу брутто qtty единиц товара в килограммах
	//
	double CalcBrutto(double qtty) const;
	//
	// Descr: Рассчитывает объем qtty единиц товара в куб.метрах
	//
	double CalcVolume(double qtty) const;
	//
	// Descr: Разносит объем, указанный одним числом (в куб. метрах)
	//   по полям Length, Width, Height (уже в миллиметрах)
	//
	void   SetVolume(double volume);
	//
	// Descr: Возвращает минимальный запас товара на складе locID, Если locID == 0,
	// то запас товара общий для всех складов.
	// locID - склад (если 0, то для всех складов), useZeroLoc - если 1 и минимальный остаток по складу locID - 0,
	// то возвращаем минимальный остаток по складу 0.
	//
	double GetMinStock(PPID locID, int useZeroLoc = 1) const;
	//
	// Descr: Возвращает максимальный минимальный запас товара и склад которому данный запас принадлежит.
	//
	double GetMaxMinStock(PPID * pLocID);
	//
	// Descr: Устанавливает запас товара для склада locID.
	//
	void   SetMinStock(PPID locID, double qtty);
	int    GetSinglePalletEntry(Pallet * pEntry) const;
	int    GetPalletEntry(PPID palletTypeID, Pallet * pEntry) const;
	int    ConvertCargoUnits(int fromCargoUnit, int toCargoUnit, PPID palletTypeID, double srcVal, double * pDestVal, long flags) const;

	enum {
		fMultMinShipm = 0x0001 // MinShippmQtty одновременно определяет кратность отгужаемого количества
	};
	long   Brutto;         // Масса брутто, г (Если Package > 0, то масса упаковки поставки)
	PPDimention PckgDim;   // Габаритные размеры упаковки поставки, мм
	double Package;        // Емкость упаковки поставки (торговых единиц)
	int16  ExpiryPeriod;   // Срок годности товара (дней).
	int16  GseFlags;       //
	double MinShippmQtty;  // Минимальное количество, которое можно отгрузить в одном документе
	float  NettBruttCoeff; // Коэффициент пересчета брутто-массы в нетто (для товарных структур)
	PPDimention RtlDim;    // Габаритные размеры торговой единицы, мм
	RAssocArray MinStockList; // @anchor Минимальный запас товара по складам
	TSVector <Pallet> PltList; // Список описаний укладки упаковок на паллете
};

class GoodsCore : public Goods2Tbl {
public:
	friend class GoodsCache;

	GoodsCore();
	~GoodsCore();
	bool   IsRecValid(const Goods2Tbl::Rec * pRec);
	int    Update(PPID * pID, Goods2Tbl::Rec *, int use_ta);
	int    UpdateBarcodes(PPID goodsID, const BarcodeArray * pCodeList, int use_ta);
	int    UpdateArCodes(PPID goodsID, const ArGoodsCodeArray * pCodeList, int use_ta);
	int    SetArCode(PPID goodsID, PPID arID, const char * pCode, int use_ta);
	int    SetArCode(PPID goodsID, PPID arID, const char * pCode, int32 pack, int use_ta);
	int    AddBarcode(PPID goodsID, const char * pBarcode, double qtty, int use_ta);
	int    ReplaceArticleRefs(PPID replacedID, PPID newID, int use_ta);
		// @>>QuotationCore::ReplaceArticleRefs
	int    Search(PPID, void * = 0);
	int    SearchByName(long kind, const char * pName, PPID * pID, Goods2Tbl::Rec * pRec = 0);
	int    SearchAnyRef(PPID objType, PPID objID, PPID * pID = 0);
	int    LoadNameList(const PPIDArray *, long flags, StrAssocArray *);
	int    GetListByExtFilt(const ClsdGoodsFilt *, PPIDArray *);
	int    SearchByExt(const GoodsExtTbl::Rec * pExtRec, PPID * pGoodsID, Goods2Tbl::Rec * pRec);
	int    ReadBarcodes(PPID goodsID, BarcodeArray & rCodeList);
	//
	// Descr: Извлекате из базы данных список кодов, ассоциированных со статьями, по товару
	//   goodsID.
	//   Записи кодов вносятся в массив pCodeList (предварительно очищается функцией).
	// Returns:
	//   >0 - была извлечена по крайней мере одна искомая записись.
	//   <0 - нет ни одного подходящего кода
	//   0  - ошибка
	//
	int    ReadArCodes(PPID goodsID, ArGoodsCodeArray * pCodeList);
	//
	// Descr: Извлекате из базы данных список кодов, ассоциированных со статьей arID, по товару
	//   goodsID. Если goodsID == 0, то извлекает все коды, связанные со статьей arID.
	//   Для arID == 0 извлекаются собственные коды по статьям.
	//   Записи кодов вносятся в массив pCodeList (предварительно очищается функцией).
	// Returns:
	//   >0 - была извлечена по крайней мере одна искомая записись.
	//   <0 - нет ни одного подходящего кода
	//   0  - ошибка
	//
	int    ReadArCodesByAr(PPID goodsID, PPID arID, ArGoodsCodeArray * pCodeList);
	//
	// Descr: Возвращает список идентификатов товаров по аналитической статье codeArID.
	//   Идентификаторы заносятся в массив pList с проверкой уникальности (т.е. один и тот
	//   же ИД в массив не попадает). Функция предварительно массив не очищает.
	// Returns:
	//   >0 - был найден по крайней мере один товарный код, сопоставленный со статей codeArID
	//   <0 - не встретилось ни одного кода, сопоставленного с codeArID
	//   0  - ошибка
	//
	int    GetListByAr(PPID codeArID, PPIDArray * pList);
	//
	// Descr: Флаги переноса кодов по статьям (функция MoveArCodes)
	//
	enum {
		movarcodfCopyOnly = 0x0001 // Только скопировать (не удалять код со статьи-источника)
	};
	//
	// Descr: Переносит товарные коды по статьям со статьи srcArID на destArID.
	//   Если задан ид существующей товарной группы grpID, то переносятся только коды товаров,
	//   принадлежащих этой группе.
	//   Если srcArCode < 0 && grpID != 0 && destArID >= 0, тогда для статьи destArID
	//   генерируются коды товаров, принадлежащих группе grpID и не имеющих соответствующих
	//   кодов.
	//   Если pLogger != 0, тогда информация о ходе процесса (и возможных проблемах) отображается в
	//   журнале.
	//
	int    MoveArCodes(PPID destArID, PPID srcArID, PPID grpID, uint flags, PPLogger * pLogger, int use_ta);
	int    GetSingleBarcode(PPID id, uint sifFlags/*BarcodeArray::sifXXX*/, SString & rBuf);
	int    FetchSingleBarcode(PPID id, SString & rBuf);
	int    SearchGoodsAnalogs(PPID id, PPIDArray & rList, SString * pTransitComponentBuf);
	//
	// Descr: Извлекает список идентификаторов товаров, имеющих штрихкоды, длина которых
	//   соответствует одной из указанных в массиве pLens. Если элементом массива
	//   явялется значение ноль, то перечисляются и те товары, которые вообще не имеют
	//   штрихкодов.
	// Note: Функция предварительно очищает список rList а после формирования сортирует
	//   и удаляет дубликаты.
	//
	int    GetListByBarcodeLen(const PPIDArray * pLens, PPIDArray & rList);
	//
	// Descr: Извлекает список идентификаторов товаров, содержащих в наименовании
	//   подстроку pSubstr.
	// ARG(pSubstr      IN): Указатель на строку, которая должна содержаться в поле Name
	//   найденных товаров
	// ARG(pList       OUT): Указатель на массив, в который будут занесены идентификаторы
	//   найденных товаров.
	//   ! Функция не очищает список pList. То есть, те элементы, которые там уже есть
	//   в нем же и остануться.
	// ARG(skipPassive  IN):
	//   Если >0, то товары, которые имеют признак GF_PASSIV не будут
	//     заносится в список pList.
	//   Если 0, то функция не будет обращать внимание на признак GF_PASSIV в найденных товарах
	//   Если <0, то функция будет пропускать товары, имеющие признак GF_PASSIV только тогда,
	//     если в конфигурации товаров установлен флаг GCF_DONTSELPASSIVE.
	// ARG(srchByExtStr IN): Если !0, то кроме поля Name функция будет искать строку pSubstr
	//   в дополнительных полях товаров.
	//
	int    GetListBySubstring(const char * pSubstr, PPIDArray * pList, int skipPassive, int srchByExtStr = 0);
		// @>>ExtStrSrch
	int    GetListBySubstring(const char * pSubstr, StrAssocArray * pList, int skipPassive, int srchByExtStr = 0);
	//
	// Descr: Возвращает список товаров по списку брендов.
	//   Экземпляр rGoodsList предварительно очищается. В конце работы функция сортирует его вызовом rGoodsList.sortAndUndup()
	// Note: Список rBrandList должен быть отсортирован.
	//
	int    GetListByBrandList(const PPIDArray & rBrandList, PPIDArray & rGoodsList);
	int    PutStockExt(PPID id, const GoodsStockExt * pData, int use_ta);
	int    GetStockExt(PPID id, GoodsStockExt * pData, int useCache /*=0*/);
	int    GetExt(PPID, GoodsExtTbl::Rec *);
	int    PutExt(PPID, GoodsExtTbl::Rec *, int use_ta);
	//
	// Descr: находит товары, принадлежащих классу clsID с ненулевыми значениями свойства gcProp.
	//   Если параметр propVal != 0, то это усиливает требование к поиску: функция ищет только те
	//   товары значение свойства gcProp которых равно propVal.
	//   Если указатель pGoodsIdList не нулевой, то в него заносятся пары {GoodsID, PropVal} для //
	//   найденный товаров.
	// ARG(clsID         IN): @#{>0} ->Ref(PPOBJ_GOODSCLASS) ИД класса товара
	// ARG(gcProp        IN): @#{PPGdsCls::eKind, PPGdsCls::eGrade, PPGdsCls::eAdd, PPGdsCls::eAdd2} Классификатор товара
	// ARG(propVal       IN): @#{0..} Значение свойства товара, которое необходимо найти. Если 0, то
	//   перебираются все ненулевые значения.
	// ARG(pGoodsIdList OUT): @#{vptr0} Если !0 то в этот список заносятся пары {GoodsID, PropVal} для //
	//   найденных товаров.
	// Returns:
	//   >0 - найден по крайней мере один товар, удовлетворяющий заданным условиям.
	//   <0 - не найдено ни одного товара, удовлетворяющего условиям
	//   0  - ошибка
	//
	int    GetExtPropRefList(PPID clsID, int gcProp, PPID propVal, LAssocArray * pGoodsIdList);
	int    ReplaceExtObjRefs(PPID clsID, int gcProp, const LAssocArray * pSubstList, int use_ta);
	int    ReplaceExtDimScale(PPID clsID, int gcDim, long oldScale, long newScale, int use_ta);
	int    FASTCALL Fetch(PPID id, Goods2Tbl::Rec * pRec);
	void   FASTCALL Dirty(PPID id);
	int    FASTCALL FetchConfig(PPGoodsConfig * pCfg);
	int    DirtyConfig();
	//
	// Descr: Функция возвращает указатель на полный список товаров. Список представлен
	//   иерархическим массивом StrAssocArray содержащим идентификатор товара, идентификатор
	//   родительской группы товара и наименование товара.
	//
	//   Если текущий сеанс не поддерживает кэширование полного списка товаров, то
	//   возвращается 0.
	//   Если возникла ошибка, то возвращается 0.
	//
	//   Возвращаемый указатель является указателем на собственно массив, хранящийся в
	//   кэше. Так как этот кэш может совместно использоваться многими потоками, то
	//   после использования указателя необходимо разблокировать его вызовом GoodsCore::ReleaseFullList.
	//
	const StrAssocArray * GetFullList();
	void   ReleaseFullList(const StrAssocArray * pList);
	//
	// Descr: Сбрасывает кэш наименований товаров.
	//
	void   ResetFullList();
	int    SearchBarcode(const char * pCode, BarcodeTbl::Rec *);
	int    SearchByBarcode(const char * pCode, BarcodeTbl::Rec *, Goods2Tbl::Rec * pGoodsRec = 0);
	int    SearchBy2dBarcode(const char * pCodeLine, BarcodeTbl::Rec * pRec, Goods2Tbl::Rec * pGoodsRec);
	int    SearchBarcodeSubstr(const char * pText, BarcodeArray * pCodes);
	int    SearchBarcodeSubstrExt(const char * pText, BarcodeArray * pCodes);
	int    SearchByArCode(PPID arID, const char * pBarcode, ArGoodsCodeTbl::Rec *, Goods2Tbl::Rec * pGoodsRec = 0);
	//
	// Descr: Ищет все товарные артикулы, связанные со статьей arID и содержащие подстроку substr.
	// ARG(arID IN): Идентификатор статьи, которой должны соответствовать найденные коды.
	//   Если arID == -1, то ищутся собственные коды (ArID == 0).
	//   Если arID == 0, то ищутся все коды, независимо от статьи.
	// ARG(substr IN): Указатель на подстроку, которая должна содержаться во всех найденных
	//   артикулах.
	// ARG(codes OUT): Указатель на список найденных кодов. Обращаем внимание на то, что
	//   здесь используется именно BarcodeArray. Каждый элемент, внесенный данной функцией
	//   в этот массив содержит в поле BarcodeType идентификатор статьи, либо -1, если стать
	//   соответсвующего кода нулевая (такой трюк необходим для того, чтобы отличить этот
	//   элемент от настоящего штрихкода, в котором BarcodeType всегда равен нулю).
	// Returns:
	//   >0 - количество элементов, добавленных функцией в массив codes
	//   <0 - функция не нашла ни одного подходящего кода, либо в текущей конфигурации
	//        коды по статьям не исползуются.
	//   0  - ошибка
	// Note: Функция не очищает массив codes перед началом цикла поиска.
	//   то есть, все элементы, которые там были никуда не исчезнут.
	//
	int    SearchArCodeSubstr(PPID arID, const char * substr, BarcodeArray * codes);
	int    GetArCode(PPID arID, PPID goodsID, SString & rCode, int32 * pPack);
	int    GetBarcodeByTemplate(PPID grp, const PPGoodsConfig & rCfg, const char * pTempl, const BarcodeArray * pCurrentList, SString & rBuf);
	//
	// Descr: Определяет соответствует ли код pCode шаблону pTempl
	//
	int    IsTemplatedBarcode(PPID grpID, const PPGoodsConfig & rCfg, const char * pTempl, const char * pCode);
	//
	// Descr: Удаляет штрихкод, эквивалентный pCode и не принадлежащий товару goodsID
	// Note: Используется для устранения дубликатов штрихкодов перед сохранением
	//   пакета товара goodsID, имеющего более высокий приоритет по владению штрихкодов, нежели остальные
	//   записи в базе данных.
	//
	int    RemoveDupBarcode(PPID goodsID, const char * pCode, int use_ta);
	int    RemoveBarcodeLeadingZeros(int use_ta);
	//
	// Descr: переносит все товары из группы srcGrp в destGrp.
	//   Существование и валидность destGrp проверяется.
	//
	int    MoveGrpToGrp(PPID srcGrp, PPID destGrp, int use_ta);
	int    AssignGoodsToAltGrp(PPID goodsID, PPID grpID, long innerNum, int use_ta);
	//
	// Descr: Находит номер, идентифицирующий товар goodsID внутри альтернативной группы grpID.
	// ARG(goodsID    IN): Идентификатор товара
	// ARG(grpID      IN): Идентификатор альтернативной группы
	// ARG(pInnerNum OUT): Указатель, по которому присваивается значение номера.
	//   Если товар не принадлежит группе grpID или эта группа не является альтернативной либо
	//   является альтернативной динамической, то по указателю присваивается 0.
	// Returns:
	//   >0 - товар принадлежит альтернативной(не динамической) группе grpID. По указателю pInnerNum
	//      присвоено значение номера товара в этой группе.
	//   <0 - товар не принадлежит группе grpID либо эта группа не является альтернативной(не динамической).
	//    0 - error
	//
	int    GetGoodsCodeInAltGrp(PPID goodsID, PPID grpID, long * pInnerNum);
	int    GetAltGroupsForGoods(PPID goodsID, PPIDArray * pGrpIDList);
	int    IsExclusiveAltGrp(PPID altGrpID, PPID * pParentID);
	int    CheckGoodsForExclusiveAltGrp(PPID goodsID, PPID altGrpID);
	int    GetExclusiveAltParent(PPID goodsID, PPID parentID, PPID * pAltGrpID);
	int    IsCompatibleByUnit(PPID id1, PPID id2, double * ratio);
	bool   IsChildOf(PPID id, PPID parentID);
	int    IsAltGroup(PPID);
	int    IsTempAltGroup(PPID);
	int    IsDynamicAltGroup(PPID);
	//
	// Descr: Извлекает ЧЕРЕЗ КЭШ список терминальных групп, принадлежащих группе parentID.
	//
	int    GetGroupTerminalList(PPID parentID, PPIDArray * pList, PPIDArray * pUntermList);
	//
	// Descr: Извлекает ЧЕРЕЗ КЭШ фильтр альтернативной группы grpID.
	//   Предварительно проверяет, чтобы grpID действительно была альтернативной группой.
	// ARG(grpID  IN): идентификатор группы, для которой нужно извлечь фильтр
	// ARG(pFilt OUT): #@{vptr} указатель по которому присваивается найденный фильтр.
	// Returns:
	//   >0 - группа grpID является альтернативной и ее фильтр успешно получен.
	//   <0 - либо группа grpID не является альтернативной, либо она не имеет фильтра.
	//        В этом случае по указателю pFilt присваивается пустой фильтр.
	//   0  - ошибка
	//        В этом случае по указателю pFilt присваивается пустой фильтр.
	//
	int    GetAltGroupFilt(PPID grpID, GoodsFilt * pFilt);
	int    GetGroupFilt(PPID grpID, GoodsFilt * pFilt);
	int    BelongToGroup(PPID id, PPID grp, PPID * pSubGrp = 0);
	//
	// Descr: Определяет, принадлежит ли товар goodsID обобщению.
	// ARG(goodsID         IN): идентификатор товара, для которого требуется определить
	//   принадлежность обобщению
	// ARG(pGenGoodsID IN/OUT): @#{vptr} указатель на ид обобщения.
	//   Если *pGenGoodsID != 0, то функция определяет факт принадлежности товара
	//   обобщению *pGenGoodsID.
	//   Если *pGenGoodsID == 0, то функция определяет факт принадлежности товара
	//   любому обобщению идентификатор которого возврадает по адресу pGenGoodsID.
	// ARG(pAsscRec       OUT): @#{vptr0} указатель на структуру записи ассоциации,
	//   хранящей связку товар-обобщение. Если найденное обобщение является динамическим,
	//   то содержимое по этому указателю не изменяется.
	// Returns:
	//   1 - goodsID принадлежит обыкновенному обобщению
	//   2 - goodsID принадлежит динамическому обобщению
	//  <0 - goodsID не принадлежит обобщению
	//   0 - error
	//
	int    BelongToGen(PPID goodsID, PPID * pGenGoodsID, ObjAssocTbl::Rec * pAsscRec = 0);
		// @>>GoodsCore::BelongToDynGen
	//
	// Descr: Определяет, принадлежит ли товар goodsID динамическому обобщению.
	// ARG(goodsID         IN): идентификатор товара, для которого требуется определить
	//   принадлежность динамическому обобщению
	// ARG(pGenGoodsID IN/OUT): @#{vptr0} указатель на ид динамического обобщения.
	//   Если *pGenGoodsID != 0, то функция определяет факт принадлежности товара
	//   обобщению *pGenGoodsID.
	//   Если *pGenGoodsID == 0, то функция определяет факт принадлежности товара
	//   любому обобщению идентификатор которого возврадает по адресу pGenGoodsID.
	// ARG(pList IN): @#{vptr0) указатель на список, по которому (если не нулевой)
	//   присваивается список товаров, входящих в обобщение.
	// Returns:
	//  >0 - goodsID принадлежит динамическому обобщению
	//  <0 - goodsID не принадлежит обобщению
	//   0 - error
	//
	int    BelongToDynGen(PPID goodsID, PPID * pGenGoodsID, PPIDArray * pList);
	int    GetGenericList(PPID genID, PPIDArray *);
	//
	// Descr: Возвращает список идентификаторов товаров, относящихся к динамическому обобщению
	//   genGoodsID.
	//
	int    GetDynGenericList(PPID genGoodsID, PPIDArray * pList);
	int    AssignGoodsToGen(PPID goodsID, PPID genID, int abbr, int use_ta);
	int    RemoveGoodsFromGen(PPID goodsID, PPID genID, int use_ta);
	//
	// Descr: Заносит в БД полный список обобщения, ассоциированного с goodsID.
	//   Установленные до этого члены обобщения удаляются из базы данных.
	//
	int    SetGenericList(PPID goodsID, const PPIDArray & rList, int use_ta);
	int    SetAltGrpList(PPID grpID, const PPIDArray & rList, int use_ta);
	int    MakeFullName(PPID grpID, PPID parentID, SString & rBuf);
	int    GetQuot(PPID goodsID, const QuotIdent & rIdent, double cost, double price, double *, int useCache = 0);
	int    GetQuotNearest(PPID goodsID, const QuotIdent & rIdent, PPQuot * pQuot, int useCache);
	int    SetQuot(const PPQuot & rQ, int use_ta);
	int    GetQuotList(PPID goodsID, PPID locID, PPQuotArray & rList);
	//
	// Descr: Формирует список товаров, имеющих значения для вида котировки qkID по складу locID
	//
	int    GetListByQuotKind(PPID qkID, PPID locID, PPIDArray & rList);
	//
	// Descr: Удаляет все котировки имеющие вид qkID.
	// Note: Сервисная функция, используемая при удалении вида котировки. Прямое использование опасно и нежелательно.
	//
	int    RemoveAllQuotForQuotKind(PPID qkID, int use_ta);
	//
	// Descr: Извлекает через кэш список котировок для товара goodsID.
	//   Параметры qkID и locID, если не нулевые, ограничивают возвращаемый список
	//   только теми элементами, которые содержать соответствующие поля PPQuot::Kind и PPQuot::LocID.
	//
	int    FetchQuotList(PPID goodsID, PPID qkID, PPID locID, PPQuotArray & rList);
	int    SetQuotList(const PPQuotArray & rQList, bool updByTime, int use_ta);
	int    ClearQuotCache();
	//
	// Descr: Более быстрый аналог функции SetQuotList: бережет время за счет использования уже загруженной копии
	//   списка котировок pTemplate.
	// Attention: Применять с осторожностью - если pTemplate будет неактуальным, для другого товара и т.д., то
	//   возможны тяжелые последствия. Крайне нежелателен вариант вызова с pTemplate != 0 и use_ta != 0 (когда
	//   список котировок из БД должен извлекаться внутри транзакции.
	//   В отладочной версии функции установлен assert(!(pTemplate && use_ta)).
	//
	int    SetQuotListQ(const PPQuotArray & rQList, const PPQuotArray * pTemplate, bool noRmv, int use_ta);
	int    GetMatrix(PPID locID, PPIDArray * pResult);
	int    GetMatrix(const ObjIdListFilt & rLocList, int orRule, PPIDArray * pResult);
	int    GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    BelongToMatrix(PPID goodsID, PPID locID);
	int    DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList);
	int    CorrectCycleLink(PPID id, PPLogger * pLogger, int use_ta);
	GoodsExtTbl & GetExtTbl_() { return GeT; }       // really private
	BarcodeTbl  & GetBcTbl_() { return BCTbl; }      // really private
	ArGoodsCodeTbl & GetACodTbl_() { return ACodT; } // really private
private:
	BarcodeTbl    BCTbl;
	GoodsExtTbl   GeT;
	ArGoodsCodeTbl ACodT;
	Reference   * P_Ref;
	QuotationCore  * P_Qc;
	Quotation2Core * P_Qc2;
	int   ParseBarcodeTemplate(PPID grpID, const PPGoodsConfig & rCfg, const char * pTempl, void * pBlk);
	//static int Helper_SearchTemplatedBarcode(const BarcodeArray & rList, const char * pPrfx, const char * pSfx, uint len, int64 low, int64 upp, int addChkDig, SString & rBarcode);
	static int Helper_SearchTemplatedBarcode(const BarcodeArray & rList, const void * pBlk, SString & rBarcode);
	void   InitQc();
	DBQ  & SetupDimDBQ(const PPGdsClsPacket *, int dim, const RealRange *);
		// @<<GoodsCore::GetListByExtFilt
	int    Helper_GetBarcodeByTempl(const void * pBlk, SString & rBarcode);
	int    SearchAnyDynObjRef(PPID objType, PPID objID, PPID * pID);
		// @<<GoodsCore::SearchAnyRef
	int    FetchStockExt(PPID id, GoodsStockExt * pExt);
	int    Helper_ReadArCodes(PPID goodsID, PPID arID, ArGoodsCodeArray * pCodeList, PPIDArray * pIdList);
	int    Helper_BelongToGroup(PPID id, PPID grp, PPID * pSubGrp, PPIDArray *);
	int    Helper_GetGroupTerminalList(PPID parentID, PPIDArray & rList, PPIDArray & rUntermList);
	int    Helper_GetMtxByLoc(PPID locID, PPIDArray & rResult);
	//
	enum {
		glsfStrList     = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		glsfSkipPassive = 0x0002,
		glsfDefPassive  = 0x0004,
		glsfByExtStr    = 0x0008,
		glsfSkipGeneric = 0x0010, // @v10.7.7
		glsfDefGeneric  = 0x0020  // @v10.7.7
	};
	int    Helper_GetListBySubstring(const char * pSubstr, void * pList, long flags);
};
//
// Структуры представления счетов. Существенно,
// что обе структуры имеют одинаковый размер.
//
#define ACCBIN_NATURE 1
#define ACCBIN_DB     2
//
// Бух. счет в формате внешнего представления (Nature format)
//
struct Acct {
	Acct & Z();
	Acct & FASTCALL operator = (const AcctRelTbl::Rec &);
	Acct & FASTCALL operator = (const PPAccount &);
	char * ToStr(long format, char * pBuf) const; // ACCBIN_NATURE
	SString & ToStr(long format, SString & rBuf) const;
	int    FromStr(long format, const char *); // ACCBIN_NATURE

	int16  ac;            // Счет
	int16  sb;            // Субсчет
	long   ar;            // Аналитическая статья //
};

// @v10.3.2 @unused int IsSuitableAcc(const Acct * pAcc, int aco /* ACO_X */, Acct * pPattern);
//
// Бух. счет в форме ид-ров баз данных (DB format);
//
struct AcctID {
	AcctID();
	AcctID & Z();
	bool   FASTCALL operator == (AcctID s) const;
	bool   FASTCALL operator != (AcctID s) const;

	PPID   ac;
	PPID   ar;
};
//
// Тип STAcct подогнан под использование в списках ComboBox'а
//
// Тип STAcct может иметь размер [sizeof(int)+sizeof(int)] (без аналит.
// статьи), либо [sizeof(Acct)] (с аналит. статьей). Если размер больше
// чем sizeof(STAcct), то структура типа такова:
//
// { int16 ac; int16 sb; char name[DataType::s - sizeof(int) * 2]; }
//
class STAcct : public DataType {
public:
	explicit STAcct(uint32 sz = sizeof(Acct));
	char * tostr(const void *, long, char *) const;
	int    fromstr(void *, long, const char *) const;
};

void RegisterSTAcct();

#define PPAF_DBFORMAT          0x0001L // Формат ACCBIN_DB (иначе ACCBIN_NATURE)
#define PPAF_TEMPLATE          0x0010L // Шаблон бухгалтерской проводки
#define PPAF_AUTOBILL          0x0020L // Проводка автоматически генерирует документ
#define PPAF_OUTBAL            0x0040L // Забалансовая проводка
#define PPAF_OUTBAL_WITHDRAWAL 0x0080L // Забалансовый расход (Withdrawal)
	// If PPAF_OUTBAL && !PPAF_OUTBAL_WITHDRAWAL then Deposit
#define PPAF_OUTBAL_TRANSFER   0x0100L // Забалансовый трансфер
	//
#define PPAF_REGISTER          0x0200L // Регистровая проводка
//
// Бухгалтерская проводка
//
// Замечание по забалансовым проводкам:
//   Приход (Deposit):
//     Flags: PPAF_OUTBAL; DbtID: Acc; CrdID: Zero; Amount > 0
//   Расход (Withdrawal):
//     Flags: PPAF_OUTBAL | PPAF_OUTBAL_WITHDRAWAL; DbtID: Acc; CrdID: Zero; Amount < 0
//   Трансфер (Transfer):
//     Flags: PPAF_OUTBAL | PPAF_OUTBAL_TRANSFER; DbtID: Receiver Acc; CrdID: Sender Acc; Amount > 0
//
struct PPAccTurn { // @persistent
	PPAccTurn();
	PPAccTurn & Z();
	void   SwapDbtCrd();
	int    FASTCALL IsEq(const PPAccTurn & rS) const;

	AcctID DbtID;
	PPID   DbtSheet;
	AcctID CrdID;
	PPID   CrdSheet;
	LDATE  Date;
	char   BillCode[48];   // Код документа // @v11.1.12 [24]-->[48]
	PPID   BillID;         // Идентификатор документа
	int16  RByBill;        // Номер проводки по документу
	int16  Reserve;        // @alignment
	PPID   CurID;          // Валюта проводки
	double CRate;          // Курс валюты CurID по отношению к базовой
	double Amount;         // Сумма в валюте CurID
	long   Opr;
	long   Flags;
};
//
// Шаблон бухгалтерской проводки
//
#define ATTF_DACCFIX        0x00000001L // Счет по дебету зафиксирован
#define ATTF_DARTFIX        0x00000002L // Статья по дебету зафиксирована
#define ATTF_CACCFIX        0x00000004L // Счет по кредиту зафиксирован
#define ATTF_CARTFIX        0x00000008L // Статья по кредиту зафиксирована
	//
	// Следующий флаг предназначен для разрешения неопределенности в присвоении идентификатора объекта.
	// В большинстве случаев неопределенности не возникает и этот флаг игнорируется, однако,
	// если в операции участвуют два однотипных объекта (склад-склад | клиент-клиент и тд), то может
	// возникнуть проблема какой стороне проводки какой объект присваивать. Если этот флаг установлен, то
	// первичный объект присваивается счету по кредиту, в противном случае по дебету.
	//
#define ATTF_PRIMONCREDIT   0x00000010L // Первичный объект по кредиту
#define ATTF_EXPRESSION     0x00000020L // Шаблон содержит выражение для суммы
	//
	// Следующие два флага предписывают опустить проводку, если отсутствует
	// ненулевой (первичный или вторичный соответственно) объект для подстановки.
	//
#define ATTF_PSKIPONZOBJ    0x00000040L
#define ATTF_FSKIPONZOBJ    0x00000080L
	//
	// Следующие два флага определяют существование явных правил подстановки
	// для первичного или вторичного объектов соответственно (в поле PPAccTurnTempl::Subst)
	//
#define ATTF_PSUBSTRULE     0x00000100L
#define ATTF_FSUBSTRULE     0x00000200L
#define ATTF_SKIPNEG        0x00000400L // Не проводить отрицательную сумму
#define ATTF_INVERTNEG      0x00000800L // Инвертировать счета при отрицательной сумме
#define ATTF_BASEPROJECTION 0x00001000L // Шаблон должет быть спроецирован на базовую валюту по всем валютам
#define ATTF_INTROUNDING    0x00002000L // Округлять сумму проводки до целых
#define ATTF_PASSIVE        0x00004000L // Пассивный шаблон (не генерировать проводку)
#define ATTF_SUBSTDACC      0x00010000L // Подставлять дебетовый счет из Secondary Obj
#define ATTF_SUBSTCACC      0x00020000L // Подставлять кредитовый счет из Secondary Obj
#define ATTF_BYADVLINES     0x00040000L // Проводки по каждой из строк расширения бух документа
#define ATTF_SKIPEMPTYALIAS 0x00080000L // Не проводить, если нет подстановки для алиаса счета
#define ATTF_CVT6406        0x00100000L // Запись сконвертирована в формат v6.4.06

class PPAccTurnTempl { // @persistent @flat @store(PropertyTbl)
public:
	static int Convert_6407(PropertyTbl::Rec * pRec);
	int    SetupSubst(const char * primStr, const char * foreignStr);
	int    SubstToStrings(SString & rPrimStr, SString & rForeignStr);
	int    CreateAccturns(PPBillPacket *);
	int    CreateBaseProjectionAccturns(PPBillPacket *);
	int    AccTemplToStr(int side, SString & rBuf) const;
	int    AccTemplFromStr(int side, const char * pBuf);

	PPID   ObjType;       // Const=PPOBJ_OPRKIND
	PPID   ObjID;         // ->Ref(PPOBJ_OPRKIND)
	PPID   ID;            // Номер шаблона для операции (1..PP_MAXATURNTEMPLATES)
	AcctID DbtID;
	AcctID CrdID;
	long   Flags;
	DateRange Period;     // Период действия шаблона
	//
	// В это поле сначала заносится порядок подстановки для первичного объекта, затем разделитель -1L,
	// затем порядок подстановки для вторичного объекта, затем двоичный нуль (0L).
	// Если для первичного объекта нет явного порядка, то Subst[0] == -1L.
	// Завершающий нуль должен присутствовать всегда (смотри предыдущий параграф).
	//
	PPID   Subst[8];      // Переменные объектов для подстановки в проводку
	uint8  Reserve[12];
	char   Expr[256];     // Формула для суммы проводки (текст)
private:
	struct ATSubstObjects {
		ATSubstObjects();
		void   destroy();
		struct Item {
			Item();

			AcctID Aid;
			PPID   AcsID;
		};
		TSVector <ATSubstObjects::Item> PrimList;
		TSVector <ATSubstObjects::Item> ForeignList;
	};
	struct ATBillParam {
		ATBillParam();
		enum {
			fIsRcknInited  = 0x0001,
			fAr            = 0x0002  // Поле AdvItemIdx применяется как номер статьи для подставновки
		};
		const PPBillPacket * P_Pack;
		PPBillPacket * P_LinkPack;
		PPBillPacket * P_RcknPack;
		int    AdvItemIdx;
		PPID   AccSheetID;           // Таблица, с которой сопоставлена статья AdvItemIdx (Flags & fAr)
		long   Flags;
	};
	struct ExtLinesBlock {
		int    AccWrOff;        // Блок сформирован как перечисление по статьям таблицы AccSheetID для списания по счетам
		uint   Idx;
		PPID   AccSheetID;
		int    SubstAr;
		const  PPBillPacket * P_Pack;
		PPIDArray SubstArList;
	};
	int    SetupAccounts(ATBillParam & rParam, PPID curID, PPAccTurn * pAT) const;
		// @<<PPAccTurnTempl::CreateAccturns, @<<PPAccTurnTempl::CreateBaseProjectionAccturns
	int    SubstAcct(int side, PPAccTurn *, const ATSubstObjects *, const AcctID *, const AcctID *) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    ParseSubstString(const char * str, int * lp, int * skipzobj);
	int    SubstToString(SString & rBuf, int * lp, int skipzobj);
	int    GetObjByVar(PPID, ATBillParam *, PPID * pObjID) const;
	int    GetSubstObjects(ATBillParam *, ATSubstObjects *, int byAcc) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    ResolveAlias(int side, AcctID * pAcct, const ATSubstObjects * pAtso) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    EnumerateExtLines(const PPBillPacket * pPack, ExtLinesBlock * pBlk) const;
};
//
// Descr: Блок параметров для бухгалтерской проводки по счету
//
struct AccTurnParam {
	int    Side; // Cторона баланса (PPDEBIT || PPCREDIT)
	double Amt;  // Cумма проводки (Amt != 0)
	double Low;  // Mинимальная допустимая разность (debit - credit) по счету после проводки
	double Upp;  // Mаксимальная допустимая разность (debit - credit) по счету после проводки
};
//
// Методы расчета доходности по операциям
//
#define INCM_DEFAULT              0  // По флажкам операций
#define INCM_BYSHIPMENT           1  // По отгрузке
#define INCM_BYPAYMENT            2  // По оплате
#define INCM_BYPAYMENTINPERIOD    3  // Специальный вариант, учитывающий оплаты только по документам, попадающим в тот же период
//
// Флаги общей конфигурации
//
#define CCFLG_PRICEWOEXCISE        0x00000001L // Цена задана без налога с продаж
#define CCFLG_TGGLEXCSNPRICE       0x00000002L // Переключать акциз не меняя цены
#define CCFLG_SETWLONLINK          0x00000004L // Устанавливать WL на связанные документы одновременно с основным документом
#define CCFLG_COSTWOVATBYDEF       0x00000008L // Цены поступления по умолчанию без НДС (в диалоге строки документа прихода устанавливается соответствующий флаг) //
#define CCFLG_COSTWOVATBYSUM       0x00000010L // Если цена поступления задана без НДС, то расчитывать НДС исходя из суммы, иначе - из цены.
	// По умолчанию в этом случае НДС расчитывается исходя из цены (и это правильно).
#define CCFLG_NOADJPRWROFFDRAFT    0x00000020L // Блокировка функции прецизионного выравнивания цен при списании драфт-документов
#define CCFLG_DONTUNDOOPCNTRONESC  0x00000040L // Не пытаться откатывать счетчик операций при отмене провоедения нового документа
#define CCFLG_USEGDSCLS            0x00000080L // Использовать классы товаров
#define CCFLG_USEGOODSPCKG         0x00000100L // Использовать товарные пакеты
#define CCFLG_USEDRAFTBILL         0x00000200L // Использовать драфт-документы // @v9.8.11 @obsolete
#define CCFLG_USENOUPDRESTOPFLAG   0x00000400L // Использовать флаг "Не изменять остатки по лотам" в видах операций. Ошибочная устанока
	// флага может вызвать исключительно неблагоприятные последствия.
#define CCFLG_USEADVBILLITEMS      0x00000800L // Использовать расширенние бухгалтерских документов. Устанавливается функцией SetupConfigByOps().
#define CCFLG_DISABLEACCTURN       0x00001000L // Запрет бухгалтерских проводок по документам
#define CCFLG_IGNOREORDERSDEBT     0x00002000L // Игнорировать долги по заказам
#define CCFLG_USEHISTBILL          0x00004000L // Вести историю документов
#define CCFLG_CHECKSPOILAGE        0x00008000L // Проверять на принадлежность товара к браку
#define CCFLG_DEBUG                0x00010000L // Отладочный режим
#define CCFLG_THROUGHSCARDUNIQ     0x00020000L // Сквозная уникальность дисконтных карт
#define CCFLG_USEHISTGOODS         0x00040000L // Вести историю товаров
#define CCFLG_USECCHECKEXT         0x00080000L // Использовать таблицу расширения кассовых чеков
#define CCFLG_TRFR_DONTRECALCREVAL 0x00100000L // Функция Transfer::UpdateForward не пересчитывает проводки после изменения строки переоценки
#define CCFLG_GENLOTONUNLIMORDER   0x00200000L // Генерировать лоты на нелимитируемые заказы
#define CCFLG_DEBUGTRFRERROR       0x00400000L // Проверять лоты и текущие товарные остатки после каждого проведения или изменения товарного документа
#define CCFLG_USEARGOODSCODE       0x00800000L // Использовать товарные коды, привязанные к статьям
#define CCFLG_CHECKUNIQBILLCODE    0x01000000L // @v11.7.8 Проверять уникальность номера при создании нового документа
#define CCFLG_USECCHECKLINEEXT     0x02000000L // Использовать расширения строк чеков
#define CCFLG_INDIVIDBILLEXTFILT   0x04000000L // Индивидуальная фильтрация по расширению документов
	// Если флаг включен, то при фильтрации документов с помощью функции BillCore::GetBillListByExt
	// используется отбор по вызову PPObjBill::FetchExt.
	// Необходимость в таком переключении может возникнуть в случае, если значительная часть документов
	// имеет расширение и учет ведется в течении длительного времени (BillCore::GetBillListByExt
	// работает в такой ситуации очень долго).
#define CCFLG_USEDISTRIBCOST       0x08000000L // Использовать распределение себестоимости
#define CCFLG_LOGCCHECK            0x10000000L // Заносить в журнал операции с чеками
#define CCFLG_RSRVSJ               0x20000000L // Если не удалось добавить запись в системный журнал, то заносить ее в резервную таблицу.
#define CCFLG_3TIER                0x40000000L // Сеанс запущен в режиме 3tier
//
//
//
#define CCFLG2_QUOT2                     0x00000001L // БД использует 2-е поколение котировок
#define CCFLG2_USESDONPURCHOP            0x00000002L // Проекция флага AGTF_USESDONPURCHOP в общем соглашении с поставщиками
#define CCFLG2_INDEXEADDR                0x00000004L // Индексировать телефоны из персоналий и адресов
	// Если этот флаг включен, то в таблицу EAddr записываются все телефоны из создаваемых и изменяемых
	// персоналий и адресов для ускоренного извлечения объектов, связанных с телефоном.
#define CCFLG2_SYNCLOT                   0x00000008L // Синхронизировать лоты
#define CCFLG2_ADJCPANCCLINETRANS        0x00000010L // При преобразовании строки чека из кассовой панели в запись
	// CCheckLine корректировать разницу за счет скидки. Функция CCheckItem::GetRec().
	// Необходимость в установке пареметра может возникнуть при работе с товарами, которые продаются большими
	// количествами и по ценам, имеющим более двух знаков после точки.
	// Возможно, правило такой корректировки должно быть применено во всех случаях, однако, во
	// избежании проблем с работающими инсталляциями, страхуемся вводом данного параметра.
#define CCFLG2_USECCHECKEXTPAYM          0x00000020L // Использовать расширение оплат по чекам
#define CCFLG2_DONTUSE3TIERGMTX          0x00000040L // Не использовать извлечение товарной матрицы с сервера при 3-tier режиме работы
#define CCFLG2_USEOMTPAYMAMT             0x00000080L // Использовать включенную сумму оплаты по документам
#define CCFLG2_USESARTREDB               0x00000100L // Использовать базу данных Sartre (экспериментальная опция)
#define CCFLG2_USELOTXCODE               0x00000200L // Использовать дополнительные коды привязанные к строкам документов (ЕГАИС)
#define CCFLG2_USELCR2                   0x00000400L // Использовать 2-ю версию индексации остатков по лотам
#define CCFLG2_USEVETIS                  0x00000800L // @transient Использовать функционал ВЕТИС (Меркурий). Определяется динамически
	// по установленным в конфигурации глобального обмена параметрам доступа к ВЕТИС.
#define CCFLG2_USEHISTPERSON             0x00001000L // Вести историю изменения персоналий
#define CCFLG2_USEHISTSCARD              0x00002000L // Вести историю изменения персональных карт
#define CCFLG2_DEVELOPMENT               0x00004000L // Режим разработки - включаются дополнительные опции отображения и управления
#define CCFLG2_VERIFYARTOLOCMETHS        0x00008000L // Отладочный флаг для верификации функций преобразования статей в склады и наоборот
#define CCFLG2_HIDEINVENTORYSTOCK        0x00010000L // Флаг, предписывающий скрывать значения учетных остатков
	// инициируются по параметру в pp.ini [config] PPINIPARAM_INVENTORYSTOCKVIEWRESTRICTION
#define CCFLG2_UNITECHZNCIGBLK10         0x00020000L // @v12.1.9 При продаже 10 пачек сигарет одной позицией с одной chzn-маркой сигаретного блока 
	// в кассовом чеке заменять количество на 1, цену умножать на 10. 
	// Инициируются по параметру в pp.ini [config] PPINIPARAM_UNITECHZNCIGBLK10
#define CCFLG2_INHSUPPLTAXGRPINLOT       0x00040000L // @v12.2.1 Проекция флага AGTF_INHSUPPLTAXGRPINLOT в общем соглашении с поставщиками
#define CCFLG2_RESTRICTCHZNCIGPRICEASMRC 0x00080000L // @v12.2.4 Если при проверке марки chzn для сигарет через разрешительный режим честный знак 
	// выдал максимальную розничную цену (МРЦ) то параметр RestrictChZnCigPriceAsMrc, установленный в 1, запретит продать товар иначе как по этой цене (никих ниже - строго МРЦ).
	// Инициируются по параметру в pp.ini [config] PPINIPARAM_RESTRICTCHZNCIGPRICEASMRC
#define CCFLG2_RESTRICTCHZNPMPRICE       0x00100000L // @v12.2.5 Верифицировать границы цены, полученные при проверке марки честный знак через разрешительный режим.
	// Инициируются по параметру в pp.ini [config] PPINIPARAM_RESTRICTCHZNPMPRICE
//
// Общие параметры конфигурации
//
struct PPCommConfig {      // @persistent @store(PropertyTbl)
	PPID   Tag;               // Const=PPOBJ_CONFIG
	PPID   ID;                // Const=PPCFG_MAIN
	PPID   Prop;              // Const=PPPRP_COMMCFG
	Acct   SupplAcct;         // Счет расчетов с поставщиками
	Acct   SellAcct;          // Счет расчетов с клиентами
	Acct   CashAcct;          // Счет кассы (для кассовой книги)
	PPID   SupplAccSheet;     // Таблица статей поставщиков
	PPID   SellAccSheet;      // Таблица статей покупателей
	short  CcListByMarkBackDays; // DefPayPeriod-->Reserve2 @attention: Это поле может не быть равным нулю 
		// @v12.0.5 Reserve2-->CcListByMarkBackDays. Извлекается из pp.ini [config] CcListByMarkBackDays. default=14
	short  IncomeCalcMethod;  // Метод расчета доходности операций (INCM_XXX)
	PPID   AutoComplOp;       // Операция автокомплектации
	long   Flags;             // CCFLG_XXX
	PPID   MainOrgID;         // Главная организация по умолчанию
	PPID   MainOrgDirector_;   // Директор главной организации
	PPID   MainOrgAccountant_; // Бухгалтер главной организации
	PPID   ReceiptOp;         // Операция прихода товара от поставщика
	PPID   RetailOp;          // Операция розничной продажи
	PPID   RetailRetOp;       // Операция розничного возврата
	PPID   IntrReceiptOp;     // Операция межскладского прихода
	int16  FRRL_Days;         // Порог включения блокировки пересчета
		// форвардных остатков при проводке документов задним числом.
		// Если (LConfig.OperDate - BillDate) >= FRRL_Days, то включается FRRL.
	int16  MaxGoodsBillLines;           // @def=300 Максимальное количество товарных строк в документе.
	int16  GRestCalcThreshold;          // @def=10  Порог расчета остатков товаров по группе, промилле
	char   PrepayInvoiceGoodsCode_obsolete[16];  // Код товара для печати счета-фактуры на предоплату по бухгалтерскому документу
	int16  CSessUnitingPeriod;          // @def=720=(12*60) Период объединения кассовых сессий в
		// суперсессии (минут). Если две сессии различаются по времени закрытия //
		// менее чем на это значение, то они объединяются в одну суперсессию.
	int16  CSessFwAsscPeriod;           // @def=1440=(24*60) Период ассоциирования неопределенных
		// кассовых чеков с форвардным Z-чеком (минут). Если существует Z-чек,
		// отстоящий от чека с неопределенной кассовой сессией менее чем на
		// на это значение, то система считает, что чек относится к сессии,
		// определяемой этим Z-чеком.
	Acct   ImprestAcct;                 // Счет для расчетов с подотчетными лицами (71)
	LDATE  _390_DisCalcMethodLockDate;  // Дата, до которой следует
		// отключать новый метод (@3.9.0) расчета скидки по документу (BPAKCALC.CPP)
		// Документы, с датой меньше или равной указанной расчитываются по-старому.
		// Новый метод правильнее, однако влечет за собой пересчет старых документов.
	LDATE _3918_TDisCalcMethodLockDate; // Дата, до которой следует отключать новый метод расчета общей скидки по товарному документу
	Acct   AssetAcct;                   // Счет для учета основных фондов (01)
	LDATE _405_TDisCalcMethodLockDate;  // Дата, до которой следует отключить новый метод расчета общей скидки по товарному документу
	LDATE _418_TDisCalcMethodLockDate;  // Дата, до которой следует отключить новый метод расчета общей скидки по товарному документу
	PPID   DraftRcptOp;                 //
	int16  LcrUsage;                    // Варианты использования текущих остатков по лотам:
		// 0 - не использовать, 1 - только поддерживать в актуальном состоянии, 2 - применять при расчетах остатков
	PPID   DynGoodsTypeForSupplAgent;   // Динамический тип товара для лотов, имеющих агента поставщика
	long   Flags2;                      // CCFLG2_XXX Дополнительное поле флагов
	int16  IltiCvtQttyEpsilon;          // 1E-7 Величина количественного дефицита, которую следует игнорировать при
		// проведении расходных товарных операций. Умножается на 1E-7.
	// @v10.7.9 int16  Reserve3;                    // @alignment
	int16  StringHistoryUsage;          // @v10.7.9 Использование StringHistory: 0 - disabled, 1 - enabled, -1 - в зависимости от установки в конфигурации пользовательского интерфейса
	LDATE  _InvcMergeTaxCalcAlg2Since;  // Дата, начиная с которой применяется алгорим 2 для расчета налогов по
		// объединенным строкам счет-фактуры (для печати).
	PPID   PrepayInvoiceGoodsID;        // Ид товара для печати счета-фактуры на предоплату по бухгалтерскому документу
		// Так же применяется для печати чеков без подробного содержания.
	LDATE  LcrUsageSince;               // @v10.1.5 Текущие остатки по лотам учитывать начиная с этой даты
};
//
// Extra config flags (from pp.ini)
// Эти флаги храняться в экземпляре PPSession (общие всех потоков)
//
#define ECF_GOODSRESTPACK          0x00000001L
#define ECF_TRFRITEMPACK           0x00000002L
#define ECF_GOODSBILLFILTSHOWDEBT  0x00000004L
#define ECF_ECOGOODSSEL            0x00000008L
#define ECF_433OLDGENBARCODEMETHOD 0x00000010L // Использовать старый метод генерации штрихкода
	// Этот флаг инициализируется  параметром [config] 433OldGenBarcodeMethod в файле pp.ini
	// Различия в методах генерации штрихкода определены функцией int GoodsCore::Helper_GetBarcodeByTempl (goods.cpp)
#define ECF_SYSSERVICE			   0x00000020L // Работа в режиме системного сервиса
// @v10.1.4 #define ECF_CLIENT				   0x00000040L // Работа в режиме клиента трехзвенки
#define ECF_AVERAGE                0x00000080L // Установленный флаг делает доступными некоторые аварийные операции
#define ECF_DBDICTDL600            0x00000100L // Использовать в качестве словаря описание таблицы БД в DL600
#define ECF_FULLGOODSCACHE         0x00000200L // Сеанс использует кэширование полного списка товаров
#define ECF_INITONLOGIN            0x00000400L // Специальный флаг, сигнализирующий о том, что та часть инициализации флагов,
	// за которую отвечает функция PPSession::Login осуществлена.
	// Это важно для многопоточного варианта, дабы снизить время авторизации и избежать конфликтов.
#define ECF_PREPROCBRWONCHGFILT    0x00000800L //
#define ECF_CHKPAN_USEGDSLOCASSOC  0x00001000L // В кассовой панели использовать ассоциации товар-склад.
	// В противном случае будут использоваться локальные по отношению к узлу ассоциации товар-кассовый узел.
	// Речь идет об ассоциациях, применяемых для раздельной печати одного чека на разные кассовые принтеры.
#define ECF_DEBUGDIRTYMTX          0x00002000L // Выводить в журнал mtxdirty.log информацию об актуализации
	// кэша товарной матрицы. Этот журнал - временный и отладочный. Необходим для решения изредка возникающих проблем
	// с актуализацией кэша матрицы сервером Papyrus.
#define ECF_USECDB                 0x00004000L // Использовать конфигурационную базу данных
#define ECF_RCPTDLVRLOCASWAREHOUSE 0x00008000L // При выборе адеса доставки в диалоге документа прихода товаров,
	// комбо-бокс будет отражать склады главной организации (для драфт-документов прихода такое поведение - безусловно).
#define ECF_DETECTCRDBTEXISTBYOPEN 0x00010000L // Флаг, предписывающий системе иднтифицировать
	// существование Btrieve-файлов созданных для печати посредством функций Btrieve, но не через fileExists()
	// Устанавливается, если в pp.ini включен параметр DETECTDBTEXISTBYOPEN=100
#define ECF_USESJLOGINEVENT        0x00020000L //
#define ECF_CODEPREFIXEDLIST       0x00040000L // Элементы списков некоторых объектов предваряются кодами
	// Устанавливается, если в pp.ini включен параметр CodePrefixedList=1
#define ECF_TRACESYNCLOT           0x00080000L // Отладочный флаг для трассировки синхронизации лотов
#define ECF_DISABLEASYNCADVQUEUE   0x00100000L // Защитный флаг, препятствующий применению техники асинхронной очереди системных событий
#define ECF_USEGEOTRACKING         0x00200000L // Если флаг не установлен, то коммуникации с мобильными устройствами по гео-трекингу отключены
#define ECF_DLLMODULE              0x00400000L // Работа в режиме DLL-модуля
#define ECF_OPENSOURCE             0x00800000L // Система собрана в opensource-варианте
#define ECF_PAPERLESSCHEQUE        0x01000000L // @v11.3.7 Разрешение на использование функционала безбумажных чеков. С моей точки зрения
	// флаг неправильный. Сделан для того, чтоб собрать оплату с клиентов за эту функцию. Скорее всего в течении нескольких месяцев будет упразднен.
#define ECF_WSCONTROL              0x02000000L // @v11.6.7 @contruction Сеанс работает в режиме управления рабочей сессией Windows.
	// Состояние значительно модифицирует парадигму работы: сеанс дает управляемый доступ к функциям Windows.
#define ECF_STYLOQSVCLOGGING       0x04000000L // @v11.9.2 Если установлен, то объект PPStyloQInterchange записывает в журнал (styloqsvc-talk.log) входящие запросы и ответы
//
//
//
struct PPLastInputData {
	double CalcMem;
	double VaPercent;
	char   Barcode[24];
	PPID   QuotCurID;
	PPID   BasketID;
	PPID   QCertID;
	DateRange GctPeriod; // PPViewGoodsRest::ViewGoodsOpGrouping()
};
//
// Descr: Структура, определяющая арранжировку штрихкодов с списке, принадлежащем одному товару.
//
class BarcodeArrangeConfig {
public:
	BarcodeArrangeConfig();
	int    Load();
	int    Save();
	int    IsLowPrior(const char * pBarcode) const;
private:
	enum {
		fDisableNonDigit = 0x0001 // Из списка штрихкодов удаляются те, что содержат нецифровые символы
	};
	char   LowPriorPrefix[10];
	int16  LowPriorLen;
	long   Flags;
};
//
// @v10.2.3 (replaced with InetUrl::GetDefProtocolPort(InetUrl::protPapyrusServer)) #define DEFAULT_SERVER_PORT 28015
//
// Descr: Команды сервера
//
#define PPSCMD_HELLO                  10001
#define PPSCMD_LOGIN                  10002
#define PPSCMD_LOGOUT                 10003
#define PPSCMD_QUIT                   10004
#define PPSCMD_SPII                   10005
#define PPSCMD_STYLOBHT               10006
#define PPSCMD_GETBIZSCORES           10007 //
#define PPSCMD_STYLOBHTII             10008 //
#define PPSCMD_GETLASTERRMSG          10011 // Получить сообщение о последней ошибке
#define PPSCMD_SOBLK                  10019 // SELECT, SET, CREATE object //
#define PPSCMD_CHECKGLOBALCREDENTIAL  10020 // CheckGlobalCredential global_acc_name global_acc_password
#define PPSCMD_GETSERVERSTAT          10021 //
#define PPSCMD_STOPTHREAD             10022 // Остановить поток (PPJobSrvProtocol::StopThreadBlock)
#define PPSCMD_CREATEVIEW             10025 //
#define PPSCMD_DESTROYVIEW            10026 //
#define PPSCMD_HSH                    10027 // Handshake
#define PPSCMD_SUSPEND                10028 // SUSPEND переводит сеанс в режим ожидания и возвращает ИД сеанса
#define PPSCMD_RESUME                 10029 // RESUME переключает работу на сеанс с которым до этого было приостановлена
	// работа (командой SUSPEND). Номером сеанса указывается параметром команды.
#define PPSCMD_CONFIG                 10030 // CONFIG устанавливает конфигурационный параметр указанный следующим за командой токеном.
#define PPSCMD_REFRESHVIEW            10031 // Требование серверу обновить содержимое PPView, идентификатор которого передается с командой.
#define PPSCMD_RFIDPRCSSR             10032
#define PPSCMD_GETTDDO                10033 // Извлечение текста по шаблону TDDO
#define PPSCMD_GETIMAGE               10034 // Извлечение изображения, связанного с объектом данных
#define PPSCMD_GETNEXTFILEPART        10035 // Получить очередную часть файла
#define PPSCMD_ACKFILE                10036 // Подтверждение приема файла клиентом
#define PPSCMD_CANCELFILE             10037 // Отмена приема файла клиентом
#define PPSCMD_EXECVIEWNF             10038 // Запуск отчета по именованному фильтру (EXECVIEW file_name [dl600_data_name])
#define PPSCMD_PREPAREPALMOUTDATA     10039 // Подготовка данных для КПК на базе StyloAndroid
#define PPSCMD_PREPAREPALMINDATA      10040 // Подготовка к приему данных с КПК на базе StyloAndroid
#define PPSCMD_GETFILE                10041 // Получить файл с сервера
#define PPSCMD_PUTFILE                10042 // Получить файл от клиента
#define PPSCMD_PUTNEXTFILEPART        10043 // Получить файл следующую часть файла от клиента
#define PPSCMD_PROCESSPALMXMLDATA     10044 // Обработать ранее полученные данные с КПК
#define PPSCMD_SETGLOBALUSER          10045 // Установить идентификатор текущего глобального аккаунта
#define PPSCMD_GETGLOBALUSER          10046 // Получить идентификатор текущего глобального аккаунта
#define PPSCMD_SETOBJECTTAG           10047 // Установить значение тега объекта
#define PPSCMD_GETOBJECTTAG           10048 // Получить значение тега объекта
#define PPSCMD_SETIMAGEMIME           10049 // Установка изображения, связанного с объектом данных
#define PPSCMD_SETIMAGE               10050 // Установка изображения, связанного с объектом данных (бинарный пакет)
#define PPSCMD_PING                   10051 // Тестовая команда, для проверки работоспособности сервера и клиента. Может сопровождаться дополнительными параметрами при специфических тестах.
#define PPSCMD_GTACHECKIN             10052 // Регистрация тарифицируемой транзакции по глобальной учетной записи
#define PPSCMD_EXPTARIFFTA            10053 // Установить флаг - тарифицируемая транзакци
#define PPSCMD_SENDSMS                10054 // Отправка SMS
#define PPSCMD_POS_INIT               10055 //
#define PPSCMD_POS_RELEASE            10056 // CPOSRELEASE id
#define PPSCMD_POS_GETCCHECKLIST      10058 // CPOSGETCCHECKLIST
#define PPSCMD_POS_GETCCHECKLNCOUNT   10060 // CPOSGETCCHECKLNCOUNT
#define PPSCMD_POS_ADDCCHECKLINE      10061 // CPOSADDCCHECKLINE
#define PPSCMD_POS_RMVCCHECKLINE      10062 // CPOSRMVCCHECKLINE
#define PPSCMD_POS_CLEARCCHECK        10063 // CPOSCLEARCHECK
#define PPSCMD_POS_RMVCCHECK          10064 // CPOSRMVCCHECK
#define PPSCMD_POS_PRINTCCHECK        10065 // CPOSPRINTCHECK
#define PPSCMD_POS_GETCONFIG          10066 // CPOSGETCONFIG
#define PPSCMD_POS_SETCONFIG          10067 // CPOSSETCONFIG
#define PPSCMD_POS_GETSTATE           10068 // CPOSGETSTATE
#define PPSCMD_POS_SELECTCCHECK       10069 //
#define PPSCMD_POS_SUSPENDCCHECK      10070 //
#define PPSCMD_POS_SELECTCTABLE       10071
#define PPSCMD_POS_GETCPOSRIGHTS      10072
#define PPSCMD_POS_DECRYPTAUTHDATA    10074
#define PPSCMD_POS_GETGOODSPRICE      10075 // CPOSGETGOODSPRICE
#define PPSCMD_POS_PRINTCCHECKLOCAL   10076 // CPOSPRINTCHECKLOCAL
#define PPSCMD_POS_GETCURRENTSTATE    10077 // CPOSGETCURRENTSTATE
#define PPSCMD_POS_RESETCURRENTLINE   10078 // CPOSRESETCURRENTLINE
#define PPSCMD_POS_PROCESSBARCODE     10079 // CPOSPROCESSBARCODE
#define PPSCMD_POS_GETCTABLELIST      10080 // CPOSGETCTABLELIST
#define PPSCMD_POS_CPOSSETCCROWQUEUE  10081 // CPOSSETCCROWQUEUE
#define PPSCMD_POS_GETMODIFLIST       10082 // CPOSGETMODIFLIST goodsID
#define PPSCMD_RESETCACHE             10101 // RESETCACHE
#define PPSCMD_GETDISPLAYINFO         10102
#define PPSCMD_GETWORKBOOKCONTENT     10103
#define PPSCMD_SETTXTCMDTERM          10104 //
#define PPSCMD_GETKEYWORDSEQ          10105 //
#define PPSCMD_REGISTERSTYLO          10106 //
#define PPSCMD_SETWORKBOOKCONTENT     10107 //
#define PPSCMD_QUERYNATURALTOKEN      10108 //
#define PPSCMD_GETARTICLEBYPERSON     10109 //
#define PPSCMD_GETPERSONBYARTICLE     10110 //
#define PPSCMD_LOGLOCKSTACK           10111 // Отладочная команда приводящая к выводу стека блокировок всех потоков в журнал debug.log
#define PPSCMD_SETTIMESERIES          10112 //
#define PPSCMD_GETREQQUOTES           10113 //
#define PPSCMD_SETTIMESERIESPROP      10114 //
#define PPSCMD_SETTIMESERIESSTKENV    10115 //
#define PPSCMD_TIMESERIESTANOTIFY     10116 //
#define PPSCMD_GETCOMMONMQSCONFIG     10117 //
#define PPSCMD_SQ_ACQUAINTANCE        10118 // @v11.0.10 Инициирующее сообщение от клиента сервису для установки контакта. Клиент еще не "знаком" с сервисом.
#define PPSCMD_SQ_SESSION             10119 // @v11.0.10
#define PPSCMD_SQ_SRPREGISTER         10120 // @v11.0.10 Регистрация по SRP-протоколу
#define PPSCMD_SQ_SRPAUTH             10121 // @v11.0.10 Авторизация по SRP-протоколу
#define PPSCMD_SQ_SRPAUTH_S2          10122 // @v11.0.11 Авторизация по SRP-протоколу (the second phase)
#define PPSCMD_SQ_SRPAUTH_ACK         10123 // @v11.0.11 Авторизация по SRP-протоколу (завершающее сообщение от клиента серверу об Успешности авторизации)
#define PPSCMD_SQ_COMMAND             10124 // @v11.0.11 Собственно команда в рамках протокола Stylo-Q
#define PPSCMD_EXECJOBIMM             10125 // @v11.3.9  Запустить задачу непосредственно по этой команде.
#define PPSCMD_WSCTL_INIT             10126 // @v11.7.1  WSCTL Инициирующий запрос для получения базовых параметров работы управляемой рабочей станции
#define PPSCMD_WSCTL_GETQUOTLIST      10127 // @v11.7.1  WSCTL Получить список котировок для рабочей станции
#define PPSCMD_WSCTL_GETACCOUNTSTATE  10128 // @v11.7.1  WSCTL Получить информацию об аккаунте клиента
#define PPSCMD_WSCTL_AUTH             10129 // @v11.7.1  WSCTL Авторизация клиента
#define PPSCMD_WSCTL_BEGIN_SESS       10130 // @v11.7.6  WSCTL Запуск рабочего сеанса
#define PPSCMD_WSCTL_END_SESS         10131 // @v11.7.6  WSCTL Завершение рабочего сеанса
#define PPSCMD_WSCTL_TSESS            10132 // @v11.7.7  WSCTL Возвращает статус текущей сессии процессора
#define PPSCMD_WSCTL_LOGOUT           10133 // @v11.7.7  WSCTL Выход из сеанса (без завершения текущей рабочей сессии)
#define PPSCMD_WSCTL_QUERYPOLICY      10134 // @v11.7.12 WSCTL Запрос политики ограничений сеанса
#define PPSCMD_WSCTL_QUERYPGMLIST     10135 // @v11.8.5  WSCTL Запрос списка программ для запуска на клиентской машине. Строго говоря, этой команды быть не должно - 
	// следует использовать общую команду SELECT, но я хочу быстрее все это сделать - через спец команду меньше работы (все инфраструктура уже заточена на штатный json-формат). 
	// Однако в дальнейшем команду надо убрать и заменить на SELECT
#define PPSCMD_WSCTL_REGISTRATION     10136 // @v11.9.10 WSCTL Регистрация клиента
#define PPSCMD_WSCTL_REGISTERCOMPUTER 10137 // @v12.0.0 WSCTL Регистрация рабочей станции
#define PPSCMD_GETDBINFO              10138 // @v12.0.6 Возвращает информацию о базе данных, в которой авторизован сеанс. Возвращает json
#define PPSCMD_EGAISMARKAUTOSELECTION 10139 // @v12.2.11 Серверный вызов EgaisMarkAutoSelector::Run для ускорения обработки.

#define PPSCMD_TEST                   11000 // Сеанс тестирования //
#define PPSCMD___LASTIDENTIFIER       99999 // @v12.0.3 Максимальный допустимый идентификатор серверной команды. Этот лимит нужен для ситуативного 
	// формирования локальных идентификаторов, не обрабатываемых сервером, но находящихся в общем поле с идентификаторами серверных команд.
//
//
//
class PPJobSrvProtocol : public SBuffer {
public:
	static const uint8 CurrentProtocolVer; // @v11.0.10 int16-->uint8
	//
	// Descr: Типы данных, используемые в поле Header::Type (только для реплик,
	//   команды применяют поле Header::Type для идентификации собственно команды).
	//
	enum {
		htGeneric = 0,
		htGenericText,
		htStrAssocArray,
		htFile           // Файл (с предваряющим заголовком TransmitFileBlock)
	};
	//
	// Descr: Флаги заголовка реплики.
	//
	enum {
		hfAck        = 0x0001, // Простая реплика, подтверждающая обработку сервером полученной команды.
		hfRepError   = 0x0002, // Реплика сигнализирует об ошибке.
			// После инициализации чтения реплики функцией StartReading, если
			// реплика сигнализирует об ошибке, то возвращаемая функцией структура заголовка будет содержать этот флаг.
		// @#{hfAck^hfRepError}
		hfInformer   = 0x0004, // Реплика информирует клиента о ходе выполнения процесса.
			// Если тип данных равен htGenericText, то после заголовка следует текстовая информация о ходе процесса.
		hfCmd        = 0x0008, // Пакет является командой (в противном случае - репликой)
		hfSlString   = 0x0010, // Пакет представлен строкой, завершенной переводом каретки.
			// Это флаг соответствует неструктурированному пакету, по этому
			// в заголовке структурированного ответа не может быть такого типа.
			// Функция StartReading устанавливает в возвращаемой структуре заголовка
			// этот флаг, если засекает неструктурированный пакет (Header::Zero != 0).
		hfMore       = 0x0020, // Пакет не полностью передал данные. Требуется дополнительный
			// запрос на продолжение передачи. Пока этот флаг используется для передачи больших файлов порциями.
		// Замечания по следующим флагам, регламентирующим сжатие и шифрование сообщения:
		// -- если hfEncrypted установлен, то тело сообщения, следующее за заголовком зашифровано. Алгоритм
		//    и ключ шифрования определяется вне протокола. То есть, сообщение не несет никакой информации
		//    об этом.
		// -- предполагается, сжатие будет работать по различным алгоритмам. Для начала мы ввели самый
		//    популярный вариант - ZLIB. Не должно быть ситуации при которой заголово содержит более одного
		//    флага с признаком сжатия.
		// -- если к сообщению одновременно должны быть применены и сжатие и шифрование, то исходное сообщение
		//    сначала сжимается, затем шифруется.
		// -- поле заголовка DataLen содержит размер сжатого и зашифрованного пакета (не исходного)
		// -- если необходимо включить в пакет хэш для контроля целостности, то это должно быть реализовано
		//    на уровне использования протокола. Данная спецификация не имеет механизма хранения и вычисления хэша.
		//
		hfEncrypted  = 0x0040, // @v11.0.10 Данные пакета (не включая заголовок) зашифрованы
		hfComprZ     = 0x0080, // @v11.0.10 Данные пакета (не включая заголовок) сжаты методом ZLIB
	};

	struct Header01 { // @persistent @flat
		Header01();
		Header01 & Z();
		SString & FASTCALL ToStr(SString & rBuf) const;

		int16  Zero;        // Два нулевых байта, позволяющие отличить структурированную бинарную команду от текстовой
		uint8  ProtocolVer; // Версия протокола. (1..) @v11.0.10 int16-->uint8
		uint8  Padding;     // @v11.0.10 Если данные шифруются, то в это поле вносится размер "набивки" (padding) до величины блока шифрования
		int32  DataLen;     // Полный размер пакета (включая и этот заголовок). Это - размер передаваемый транспортом. Следовательно,
			// при блочном шифровании эффективные данные имеют размер (DataLen-Padding)
		int32  Type;        // Для команды: идент команды, для ответа: тип данных.
		uint32 Flags;       // @flags
	};

	PPJobSrvProtocol();
	PPJobSrvProtocol & Z();
	//
	// Descr: Идентифицирует тип ответа. Информация о типе заносится в
	//   блок PPJobSrvProtocol::H. Если ответ строковый и pRepString != 0,
	//   то копирует строку по этому указателю.
	//   Если ответ не строковый и pRepString != 0, то (*pRepString) = 0.
	//
	//   Если блок строковый, то при выходе из функции указатель
	//   чтения SBuffer::GetRdOffs находится в начале буфера.
	//   Если блок бинарный, то при выходе из функции указатель
	//   чтения SBuffer::GetRdOffs находится в позиции, следующей за заголовком.
	// Returns:
	//   1 - реплика бинарная.
	//   2 - реплика строковая.
	//   0 - error.
	//
	int    FASTCALL StartReading(SString * pRepString);
	int    Helper_Recv(TcpSocket & rSo, const char * pTerminal, size_t * pActualSize);
	const  Header01 & GetH() const { return H; }
	SString & FASTCALL ToStr(SString & rBuf) const;
	int    CheckRepError();

	struct StopThreadBlock {
		StopThreadBlock();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		ThreadID TId;
		MACAddr  MAddr;
		SString  HostName;
		SString  UserName;
	};
	//
	// Descr: Структура заголовка пакета передачи файла
	//
	struct TransmitFileBlock { // @persistent
		TransmitFileBlock();
		//
		// Descr: Типы передачи файлов
		//
		enum {
			ttGeneric = 0,    // Общая //
			ttObjImage,       // Изображение объекта
			ttWorkbookContent // Содержание записи рабочей книги
		};
		int32  Cookie;         // @anchor Идентификатор, необходимый для продолжения скачивания файла.
		LDATETIME CrtTime;     // Время создания файла
		LDATETIME AccsTime;    // Время последнего доступа к файлу
		LDATETIME ModTime;     // Время последней модификации файла
		int64  Size;           // Полный размер файла
		int32  Format;         // SFileFormat::XXX
		int32  Flags;          // @flags @reserve
		uint32 PartSize;       // Размер части файла, передаваемой данным пакетом
		uint8  Hash[32];       // Hash-функция полного файла (возможно, пустая).
		int16  TransmType;     // Тип передачи
		int16  Reserve;        // @reserve
		int32  ObjType;        // Тип объекта
		int32  ObjID;          // Идентификатор объекта
		uint8  Reserve2[20];   // @reserve
		char   Name[256];      // Наименование файла (без пути - только имя с расширением)
	};
protected:
	int    TestSpecToken(const char * pTok);

	enum {
		stStructured = 0x0001,
		stReading    = 0x0002
	};
	long   State;
	Header01 H; // Заголовок, считанный функцией StartReading
	SString ErrText;
	const char * P_TokAck;
	const char * P_TokErr;
};
//
// Descr: Представление бинарной команды сервера
//
class PPJobSrvCmd : public PPJobSrvProtocol {
public:
	PPJobSrvCmd();
	int    StartWriting(int cmdId);
	int    StartWriting(const char * pCmd);
	int    FinishWriting();
};
//
// Descr: Вспомогательный класс, реализующий часть функционала разбора текстовой команды.
//
class PPTextCommandBlock {
public:
	int    GetWord(const char * pBuf, size_t *);
	SString Term;
};

class PPServerCmd : public PPJobSrvCmd, private PPTextCommandBlock {
public:
	enum {
		paridDbSymb = 10001,
		paridUserName,
		paridPassword
	};
	PPServerCmd();
	~PPServerCmd();
	void   Init();
	//
	// Descr: Флаги функции ParseLine()
	//
	enum {
		plfLoggedIn = 0x0001 // Вызывающая сессия авторизована в базе данных
	};
	int    FASTCALL ParseLine(const SString & rLine, long flags);
	int    FASTCALL PutParam(int parid, const char * pVal);
	int    FASTCALL GetParam(int parid, SString & rVal) const;
	void   ClearParams();

	long   SessID;   // Идентификатор сессии, к которой отправлен запрос
	SelectObjectBlock * P_SoBlk;
private:
	StrAssocArray ParamL;
	const  SymbHashTable * P_ShT; // Таблица символов, полученная вызовом PPGetStringHash(int)
};
//
// Descr: Класс, инкапсулирующий ответ JobServer'а (реплику).
//
class PPJobSrvReply : public PPJobSrvProtocol {
public:
	PPJobSrvReply(PPServerSession * pSess = 0);
	//
	// Функции записи
	//
	int    StartWriting();
	void   SetDataType(int dataType, const char * pDataTypeText);
	int    FASTCALL WriteString(const SString & rStr);
	int    WriteFile(const char * pFileName);
	int    FASTCALL FinishWriting(int hdrFlags = 0);
	void   FASTCALL SetString(const char * pStr);
	void   FASTCALL SetString(const SString & rStr);
	int    FASTCALL SetInformer(const char * pMsg);
	//
	// Descr: Устанавливает реплику в состояние ошибки.
	//
	int    SetError();
	//
	// Descr: Устанавливает реплику с состояние подтверждения усешного выполнения операции.
	//
	void   SetAck();
	//
	// Descr: Специальная функция, посылающая клиенту информационное
	//   сообщение о ходе процесса. Сообщение посылается посредством
	//   приватного члена P_Sess (если P_Sess != 0).
	//
	int    FASTCALL SendInformer(const char * pMsg);
private:
	int32  DataType;
	SString DataTypeText;
	PPServerSession * P_Sess; // @notowned
};

class PPJobSrvClient {
public:
	enum {
		stConnected = 0x0001,
		stLoggedIn  = 0x0002,
		stLockExec  = 0x0004, // Сигнализирует от том, что Exec запущен. Необходим для предотвращения параллельного вызова по cmIdle
		stDebugMode = 0x0008  // Клиент находится в отладочном режиме (вывод дополнительной информации в журнал)
	};

	PPJobSrvClient();
	~PPJobSrvClient();
	long   GetState() const { return State; }
	int    Connect(const char * pAddr, int port);
	int    Disconnect();
	int    Reconnect(const char * pAddr, int port);
	int    ExecSrvCmd(const char * pCmd, PPJobSrvReply & rReply);
	int    ExecSrvCmd(const char * pCmd, const char * pTerminal, PPJobSrvReply & rReply);
	int    ExecSrvCmd(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	int    ExecSrvCmd(PPJobSrvCmd & rCmd, const char * pTerminal, PPJobSrvReply & rReply);
	int    Login(const char * pDbSymb, const char * pUserName, const char * pPassword);
	int    Logout();
	int    GetLastErr(SString & rBuf);
	void   SetInformerProc(int (*proc)(const char * pMsg, void * pParam), void * pParam);
	//
	// Descr: Отсылает серверу запрос на подтверждение соединения по таймеру.
	// Returns:
	//   <0 - не наступило время отсылки сообщения //
	//   >0 - сообщение отослано и получено подтверждение.
	//   0  - не удалось получить подтверждение наличия соединения.
	//
	int    FASTCALL Sync(int force = 0);
	//
	// Descr: Тестовая функция, разрывающая соединение с сервером.
	//
	int    TestBreakConnection();
private:
	long   SessId;
	long   State;
	TcpSocket So;
	SString InitAddr;
	int    InitPort;
	SString AuthCookie;
	SString TempBuf; // @allocreuse
	SString DebugLogFileName;
	SBuffer Reply;
	SCycleTimer SyncTimer; // Таймер, по котрому серверу отсылаются запросы на подтверждение соединения.
	SMtLock ExecLock; // Блокировка для гарантированной сериализации обращений к серверу.
	int    (*InformerCallbackProc)(const char * pMsg, void * pParam);
	void * P_InformerCallbackParam;
};
//
//
//
class PPUhttClient {
public:
	enum {
		stAuth  = 0x0001,
		stHasAccount    = 0x0002,
		stDefaultServer = 0x0004 // @v10.5.12
	};
	// @v10.5.12 static int TestUi_GetLocationListByPhone();
	// @v10.5.12 static int TestUi_GetQuotByLoc();
	static int ViewNewVerList(int showSelDlg);
	PPUhttClient();
	~PPUhttClient();
	int    GetState() const;
	// @v10.5.12 int    HasAccount() const;
	// @v10.5.12 int    IsAuth() const;
	int    PreprocessResult(const void * pResult, const PPSoapClientSession & rSess);
	int    Auth();
	int    Unauth();
	//
	// Application methods
	//
	int    GetPersonByID(int id, UhttPersonPacket & rResult);
	int    GetPersonByName(const char * pName, TSCollection <UhttPersonPacket> & rResult);
	int    GetBrandByName(const char * pName, TSCollection <UhttBrandPacket> & rResult);
	int    GetGoodsByCode(const char * pCode, TSCollection <UhttGoodsPacket> & rResult);
	int    GetGoodsByName(const char * pName, TSCollection <UhttGoodsPacket> & rResult);
	int    GetGoodsByID(int id, UhttGoodsPacket & rResult);
	int    GetUhttGoodsRefList(LAssocArray & rList, StrAssocArray * pByCodeList);
	//
	// Descr: Разрешает идентификатор товара в Universe-HTT uhttID относительно текущей базы данных.
	//
	int    ResolveGoodsByUhttID(int uhttID, UhttGoodsPacket * pUhttResult, PPID * pGoodsID, SString * pCode);
	int    GetUhttGoods(PPID goodsID, long flags, int * pUhttID, UhttGoodsPacket * pUhttResult);
	int    GetUhttGoodsList(PPID goodsID, long flags, TSCollection <UhttGoodsPacket> & rResult);
	int    GetLocationByID(int id, UhttLocationPacket & rPack);
	int    GetLocationByCode(const char * pCode, UhttLocationPacket & rPack);
	int    GetLocationListByPhone(const char * pPhone, TSCollection <UhttLocationPacket> & rResult);
	int    CreateStandaloneLocation(long * pID, const UhttLocationPacket & rPack);
	int    CreateGoods(long * pID, const UhttGoodsPacket & rPack);
	int    GetGoodsArCode(const char * pBarcode, const char * pPersonINN, SString & rArCode);
	int    GetGoodsRestList(int uhttGoodsID, TSCollection <UhttGoodsRestListItem> & rResult);
	int    SetObjImage(const char * pObjTypeSymb, PPID uhttObjID, const char * pFileName);
	int    GetSpecSeriesByPeriod(const char * pPeriod, TSCollection <UhttSpecSeriesPacket> & rResult);
	int    CreateSpecSeries(long * pID, const UhttSpecSeriesPacket & rPack);
	int    GetSCardByNumber(const char * pPeriodNumber, UhttSCardPacket & rResult);
	int    CreateSCard(UhttSCardPacket & rPack);
	int    CreateSCardCheck(const char * pLocSymb, const char * pSCardNumber, const UhttCheckPacket & rPack);
	int    CreateBill(UhttBillPacket & rPack);
	int    GetBill(const UhttBillFilter & rFilt, TSCollection <UhttBillPacket> & rResult);
	int    GetQuot(const UhttQuotFilter & rFilt, TSCollection <UhttQuotPacket> & rResult);
	int    SetQuot(const UhttQuotPacket & rPack);
	int    SetQuotList(const TSCollection <UhttQuotPacket> & rList, TSCollection <UhttStatus> & rResult);
	int    DepositSCardAmount(const char * pNumber, const double amount);
	int    WithdrawSCardAmount(const char * pNumber, const double amount);
	int    GetSCardRest(const char * pNumber, const char * pDate, double & rRest);
	int    FileVersionAdd(const char * pFileName, const char * pKey, const char * pVersionLabel, const char * pVersionMemo, SDataMoveProgressProc pp, void * pExtra);
	int    GetVersionList(const char * pKey, TSCollection <UhttDCFileVersionInfo> & rResult, SVerT * pMinVer);
	int    SendSms(const TSCollection <UhttSmsPacket> & rList, TSCollection <UhttStatus> & rResult);
	int    GetWorkbookItemByID(int id, UhttWorkbookItemPacket & rPack);
	int    GetWorkbookItemByCode(const char * pCode, UhttWorkbookItemPacket & rPack);
	int    GetWorkbookListByParentCode(const char * pParentCode, TSCollection <UhttWorkbookItemPacket> & rResult);
	int    GetWorkbookContentByID_ToFile(int id, const char * pFileName);
	int    CreateWorkbookItem(long * pID, const UhttWorkbookItemPacket & rPack);
	int    SetWorkbookContentByID(int id, const char * pFileName);
	//int    SetObjImage(const char * pObjTypeSymb, PPID uhttObjID, const char * pFileName);
	int    GetStyloDeviceByID(int id, UhttStyloDevicePacket & rPack);
	int    GetStyloDeviceByCode(const char * pCode, UhttStyloDevicePacket & rPack);
	int    CreateStyloDevice(long * pID, const UhttStyloDevicePacket & rPack);
	int    GetProcessorByID(long id, UhttProcessorPacket & rPack);
	int    GetProcessorByCode(const char * pCode, UhttProcessorPacket & rPack);
	int    CreateProcessor(long * pID, const UhttProcessorPacket & rPack);
	int    GetTSessionByID(long id, UhttTSessionPacket & rPack);
	int    GetTSessionByUUID(const S_GUID & rUuid, UhttTSessionPacket & rPack);
	int    GetTSessionByPrc(long prcID, const LDATETIME & rSince, TSCollection <UhttTSessionPacket> & rResult);
	int    CreateTSession(long * pID, const UhttTSessionPacket & rPack);
	int    ConvertLocationPacket(const UhttLocationPacket & rUhttPack, LocationTbl::Rec & rLocRec) const;
	int    ConvertPersonPacket(const UhttPersonPacket & rUhttPack, PPID kindID, PPPersonPacket & rPsnPack) const;
	int    GetCommonMqsConfig(PPAlbatrossConfig & rCfg);
	const SString & GetLastMessage() const { return LastMsg; }
	const SString & GetUrlBase() const { return UrlBase; }
	//
	// Descr: Utility
	//
	UhttTagItem * GetUhttTagText(PPID objType, PPID objID, PPID tagID, const char * pTagSymb);
private:
	FARPROC GetFuncEntryAndSetupSess(const char * pFuncName, PPSoapClientSession & rSess);
	int    StartTransferData(const char * pName, int64 totalRawSize, int32 chunkCount, int * pTransferID);
	int    TransferData(int transferID, int chunkNumber, size_t rawChunkSize, const void * pBinaryChunkData);
	int    FinishTransferData(int transferID);
	void   FASTCALL DestroyResult(void ** ppResult);

	long   State;
	// @v10.5.12 @unused SString Urn;
	SString UrlBase;
	SString Token;
	SString LastMsg;
	SDynLibrary * P_Lib;
	void * P_DestroyFunc;
};
//
// Descr: Клиент брокера сообщений
//
class PPMqbClient {
public:
	struct LoginParam {
		LoginParam();
		int    FASTCALL Copy(const LoginParam & rS);
		int    FASTCALL IsEq(const LoginParam & rS) const;
		const char * GetVHost(const char * pDefault = 0) const;

		int    Method;
		SString Auth;
		SString Secret;
		SString VHost; // default: "papyrus"
	};
	//
	// Descr: Флаги, используемые в различных функциях обмена сообщениями.
	//   Ради унификации все они сведены в общий enum.
	//
	enum {
		mqofPassive    = 0x0001, // queue exchange
		mqofDurable    = 0x0002, // queue exchange
		mqofExclusive  = 0x0004, // queue exchange consume
		mqofAutoDelete = 0x0008, // queue exchange
		mqofNoLocal    = 0x0010, // consume
		mqofNoAck      = 0x0020, // consume cancel
		mqofInternal   = 0x0040, // exchange
		mqofMultiple   = 0x0080, // ack
		mqofRequeue    = 0x0100  // @v11.3.1 reject
	};
	//
	// Descr: Блок свойств сообщения. Часть свойств зарезервирована (отдельные поля), часть -
	//   содержатся в Headers (набор текстовых пар {key; value})
	//
	struct MessageProperties {
		MessageProperties();
		MessageProperties & Z();
		uint   Flags;
		int    ContentType; // SFileFormat
		int    Encoding;    // SEncodingFormat
		uint   DeliveryMode; // Non-persistent (1) or persistent (2)
		uint   Priority;     // Message priority, 0 to 9
		LDATETIME TimeStamp;
		SString CorrelationId;
		SString ReplyTo;
		SString Expiration;
		SString MessageId;
		SString Type;
		SString UserId;
		SString AppId;
		SString ClusterId;
		StrStrAssocArray Headers;
	};
	//
	// Descr: Тело и свойства сообщения //
	//
	struct Message {
		Message();
		Message & Z();
		MessageProperties Props;
		SBuffer Body;
	};
	//
	// Descr: Пакет сообщения //
	//
	struct Envelope {
		Envelope();
		Envelope & Z();
		int    FASTCALL IsReservedRoute(int * pRtRsrv) const;
		enum {
			fRedelivered = 0x0001
		};
		uint16 ChannelN;
		uint16 Reserve; // @alignment
		uint64 DeliveryTag;
		uint   Flags;
		SString ConsumerTag;
		SString Exchange;
		SString RoutingKey;
		Message Msg;
	};
	//
	// Descr: Типы зарезервированных параметров маршрутизации
	//
	enum {
		rtrsrvPapyrusDbx         = 1, // Обмен пакетами синхронизации баз данных
		rtrsrvPapyrusPosProtocol = 2, // Обмен между хостом и автономными кассовыми узлами Papyrus
		rtrsrvStyloView          = 3, // Обмен с системой StyloView
		rtrsrvRpc                = 4, // Короткие запросы
		rtrsrvRpcListener        = (rtrsrvRpc | 0x8000), // Короткие запросы (только слушатель)
		rtrsrvRpcReply           = 5, // Ответы на rtrsrvRpc
		rtrsrvStyloQRpc          = 6, // @v11.0.9 Запросы в рамках проекта Stylo-Q
		rtrsrvStyloQRpcReply     = 7, // @v11.0.9 Ответы на rtrsrvStyloQRpc
		rtrsrvStyloQRpcListener  = (rtrsrvStyloQRpc | 0x8000), // @v11.0.9 Короткие запросы (только слушатель)
	};
	struct RoutingParamEntry {
		RoutingParamEntry();
		RoutingParamEntry & Z();
		int    FASTCALL IsEq(const RoutingParamEntry & rS) const;
		int    SetupReserved(int rtrsrv, const char * pDomain, const S_GUID * pDestGuid, long destId, RoutingParamEntry * pReplyEntry);
		int    SetupRpcReply(const PPMqbClient::Envelope & rSrcEnv);
		int    SetupStyloQRpcListener(const SBinaryChunk & rIdent);
		int    SetupStyloQRpc(const SBinaryChunk & rSrcIdent, const SBinaryChunk & rDestIdent, RoutingParamEntry * pReplyEntry);

		int    RtRsrv;
		long   PreprocessFlags; // @v11.0.9 Флаги, управляющие предварительной обработкой параметров маршрутизации в функции PPMqbClient::ApplyRoutingParamEntry (создание очередей и т.д.)
		long   QueueFlags;
		int    ExchangeType; // exgtXXX
		long   ExchangeFlags;
		SString QueueName;
		SString ExchangeName;
		SString RoutingKey;
		SString CorrelationId;
		SString ConsumeTag; // @v11.1.11 Тег, идентифицирующий подписку на QueueName. Может быть использован для отмены подписки
	};
	struct InitParam : public LoginParam {
		InitParam();
		InitParam(const InitParam & rS);
		InitParam & FASTCALL operator = (const InitParam & rS);
		int    FASTCALL Copy(const InitParam & rS);
		int    FASTCALL IsEq(const InitParam & rS) const;
		//
		// Descr: Сравнивает this с rS только по параметрам подключения (Host && Port)
		//
		int    FASTCALL IsEqualConnection(const InitParam & rS) const;
		int    STDCALL  SearchRoutingEntry(const RoutingParamEntry & rPattern, uint * pPos) const;

		SString Host;
		int    Port;
		TSCollection <RoutingParamEntry> ConsumeParamList;
	};

	static int InitClient(PPMqbClient & rC, const PPMqbClient::InitParam & rP);
	static int SetupInitParam(PPMqbClient::InitParam & rP, const char * pVHost, SString * pDomain);
	static int SetupInitParam(PPMqbClient::InitParam & rP, PPAlbatrossConfig & rACfg, const char * pVHost, SString * pDomain);
	static PPMqbClient * CreateInstance(const PPMqbClient::InitParam & rP);
	//
	// Descr: Высокоуровневый вариант инициализации клиента, использующий конфигурацию глобального обмена.
	//
	static int InitClient(PPMqbClient & rC, SString * pDomain);
	PPMqbClient();
	~PPMqbClient();
	bool   IsHostEqual(const char * pHost, int port) const;
	int    Connect(const char * pHost, int port);
	int    Disconnect();
	int    Login(const LoginParam & rP);
	int    DeclarePredefinedExchanges();
	int    QueueDeclare(const char * pQueue, long queueFlags);
	//
	// Descr: Типы Exchange
	//
	enum {
		exgtDefault = 0,
		exgtDirect,
		exgtFanout,
		exgtTopic,
		exgtHeaders
	};
	int    ExchangeDeclare(const char * pExchange, int type /* exgtXXX */, long exchangeFlags);
	int    QueueBind(const char * pQueue, const char * pExchange, const char * pRoutingKey);
	int    QueueUnbind(const char * pQueue, const char * pExchange, const char * pRoutingKey);
	int    QueueDelete(const char * pQueue, long queueFlags);
	int    ApplyRoutingParamEntry(const RoutingParamEntry & rP);
	//
	// Descr: Устанавливает время жизни сообщения (ttlMs) в свойствах pProps и возвращает
	//   установленную величину.
	//   Используется как маркерная функция в комбинациях запрос-ответ (RPC)
	//
	static long SetupMessageTtl(long ttlMs, MessageProperties * pProps);
	int    Publish(const char * pExchangeName, const char * pRoutingKey, const MessageProperties * pProps, const void * pData, size_t dataLen);
	int    Consume(const char * pQueue, SString * pConsumerTag, long consumeFlags);
	int    Cancel(const char * pConsumerTag, long flags);
	int    ConsumeMessage(Envelope & rEnv, long timeoutMs);
	//
	// Descr: Функция ожидает любого сообщения, предназначенного клиенту, в течении не более maxTimeMs миллисекунд.
	//   Периодичность опроса очереди определяется параметром pollTimeQuantMs. После каждой попытки получить сообщение
	//   функция "засыпает" на pollTimeQuantMs миллисекунд.
	// Returns:
	//   >0 - функция дождалась сообщения
	//   <0 - функция не дождалась сообщения
	//    0 - error
	//
	int    WaitForMessage(Envelope & rEnv, uint maxTimeMs, uint pollTimeQuantMs);
	//
	// Descr: Клиент отправляет подтверждение о получении сообщения с меткой deliveryTag. Эта метка
	//   берется из поля Envelope::DeliveryTag.
	//
	int    Ack(uint64 deliveryTag, long flags /*mqofMultiple*/);
	int    Reject(uint64 deliveryTag, long flags /*mqofRequeue*/);
	// 
	// Descr: Специальные флаги статусов
	//
	enum {
		extsfTryToReconnect = 0x0001 // Соединение "мертвое" - необходимо попытаться восстановить
	};
	void   SetExtStatusFlag(uint f);
	bool   GetExtStatusFlag(uint f) const;
private:
	static int  FASTCALL ProcessAmqpRpcReply(const amqp_rpc_reply_t & rR);
	int    VerifyRpcReply();
	void * P_Conn;
	void * P_Sock;
	uint16 ChannelN; // amqp_channel_t
	uint16 ExtStatusFlags; // @v11.3.12 extsfXXX Специальные флаги статусов, устанавливаемые из-вне.
	SString Host;
	int    Port;
	SStrCollection ConsumeTagList; // @v11.2.2
	StringSet AutoDeleteDeclaredQueues; // @v11.3.10 Список созданных auto-delete-очередей, которые надо удалить.
		// Сам rabbit-mq почему-то не удаляет их :(
};

class MqbEventResponder {
public:
	MqbEventResponder();
	~MqbEventResponder();
	bool   IsConsistent() const;
private:
	static int AdviseCallback(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
	static int ResponseByAdviseCallback(const SString & rResponseMsg, const PPMqbClient::Envelope * pEnv, MqbEventResponder * pSelf, SString &rDomainBuf);
	enum {
		cmdNone = 0,
		cmdGetGlobalAccountList = 1,
		cmdVerifyGlobalAccount = 2,
	};
	struct Command {
		Command();
		int    Cmd;
		long   IdVal;
		S_GUID GuaGuid;
		SString Hash;
	};
	int    ParseCommand(const char * pCmdText, Command & rCmd) const;

	uint32 Signature;
	long   AdvCookie_Msg;
	PPMqbClient * P_Cli;
};
//
// Descr: Идентификаторы функций системного обслуживания.
//   Ассоциируются с системными событиями PPACN_SYSMAINTENANCE в виде дополнительного значения.
//
enum { // @persistent
	sysmntncfuncGetCommonMqsConfig = 1 // Получение общей конфигурации брокера сообщений
};

class SysMaintenanceEventResponder {
public:
	SysMaintenanceEventResponder();
	~SysMaintenanceEventResponder();
	bool   IsConsistent() const;
private:
	static int AdviseCallback(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
	static int ResponseByAdviseCallback(const SString & rResponseMsg, const PPMqbClient::Envelope * pEnv, SysMaintenanceEventResponder * pSelf, SString &rDomainBuf);

	uint32 Signature;
	long   AdvCookie;
};

struct PPAdviseEvent {
	void   Clear();
	PPAdviseEvent & FASTCALL operator = (const SysJournalTbl::Rec & rSjRec);
	int    SetupAndAppendToVector(const PhnSvcChannelStatus & rS, int32 action, PPID phnSvcID, PPAdviseEventVector & rAev);
	int    SetupAndAppendToVector(const PPMqbClient::Envelope & rS, PPAdviseEventVector & rAev);
	int    ConvertToMqbEnvelope(const PPAdviseEventVector & rAev, PPMqbClient::Envelope & rE) const;

	class ExtObject {
	public:
		virtual ~ExtObject()
		{
		}
	};
	enum {
		fMqbExtraIdxIsValid = 0x0001 // Если установлен, то поле MqbExtraIdx является валидным индексом элемента в PPAdviseEventVector::MqbExtraList
	};
	int64  Ident;
    LDATETIME Dtm;
	LDATETIME MqbTimeStamp;   // @v10.5.7
    int32  Action;
    PPObjID Oid;
    int32  UserID;
    int32  SjExtra;
    long   Flags;
	int32  Priority;          // Phn, Mqb
	int32  Duration;          // Phn
	uint16 MqbChannelN;       //
	uint16 MqbReserve;        //
	uint64 MqbDeliveryTag;    //
	uint   MqbEnvFlags;       //
	uint   MqbMsgFlags;       //
	int    MqbContentType;    //
	int    MqbEncoding;       //
	uint   MqbDeliveryMode;   //
	uint   MqbExtraIdx;       // Индекс блока расширения в PPAdviseEventVector::MqbExtraList [0..]. Валиден только если Flags & fMqbExtraIdxIsValid
	//
	// Следующие поля являются позициями соответствующих строк в пуле PPAdviseEventVector
	//
	uint   ChannelP;          // Символ телефонного канала
	uint   CallerIdP;         // Вызывающий номер
	uint   ConnectedLineNumP; // Номер линии
	uint   ContextP;          // Контекст события
	uint   ExtenP;            // @? Добавочный номер
	uint   BridgeP;           // Ид моста (BridgeId) для телефонного события
	uint   OuterCallerIdP;    // Внешний вызывающий номер (полученный через Bridge, если вызова перенаправлен из внутреннего канала)
	uint   MqbConsumerTagP;   // 
	uint   MqbExchangeP;      // 
	uint   MqbRoutingKeyP;    //
	uint   MqbCorrelationIdP; //
	uint   MqbReplyToP;       //
	uint   MqbExpirationP;    //
	uint   MqbMessageIdP;     //
	uint   MqbTypeP;          //
	uint   MqbUserIdP;        //
	uint   MqbAppIdP;         //
	uint   MqbClusterIdP;     //
	//
    ExtObject * ExtraObj; // @notowned
};
//
// Descr: Вспомогательный класс для управления очередью событий
//
class PPAdviseEventVector : public TSVector <PPAdviseEvent>, public SStrGroup {
public:
	struct MqbExtra {
		LAssocArray PropsPosList;
		SBuffer Body;
	};
	PPAdviseEventVector();
	void   Clear();
	uint   FASTCALL MoveItemTo(uint pos, PPAdviseEventVector & rDest) const;
	MqbExtra * CreateNewMqbExtra(uint * pPos);
	const  MqbExtra * FASTCALL GetMqbExtra(uint pos) const;
protected:
	int    Pack();
	TSCollection <MqbExtra> MqbExtraList;
};
//
// Descr: Реализует очередь системных событий, заполняемую в отдельном потоке.
//   Поток-источник пишет новые события в очередь методом Push который блокирует
//   очередь с ожиданием. То есть, если кто-то читает очередь, то поток ждет
//   окончания чтения.
//
//   Реципиенты же, наоборот, забирают данные из очередь только после успешной блокировки
//   без ожидания - с целью избежать задержки.
//
class PPAdviseEventQueue : private PPAdviseEventVector {
public:
	PPAdviseEventQueue();
    int    FASTCALL Push(const PPAdviseEventVector & rList);
	uint   GetCount();
	int    Get(int64 lowIdent, PPAdviseEventVector & rList);
	int    Purge();

	class Client {
	public:
		friend class PPSession;

		~Client();
		bool  IsConsistent() const;
		int64 GetMarker() const;
		int   Register(long dbPathID, PPAdviseEventQueue * pQueue);
	protected:
        Client();

		uint32 Sign;
		int64  Marker;
		PPAdviseEventVector EvqList;
		LongArray RegDbList; // Список идентификаторов путей баз данных, в чьих очередях
			// клиент зарегистрирован. Необходим для ускорения процесса регистрации.
	};
	struct Stat {
		Stat();
		enum {
			stPhnSvcInit = 0x0001,
			stMqbCliInit = 0x0002
		};
        int64  LivingTime;       // Время жизни очереди (ms)
        int64  StartClock;       // Стартовое значение Clock() для отмеривания времени жизни очереди
        uint32 Push_Count;       // Количество запросов Push
        uint32 Get_Count;        // Количество запросов Get
        uint32 GetDecline_Count; // Количество отклоненных запросов Get по причине блокировки
        uint32 MaxLength;        // Максимальная длина очереди
		uint   State;            // Флаги состояния очереди
		uint   SjPrcCount;       // Количество обращений к системному журналу
		uint   SjMsgCount;       // Количество событий, поступивщих от системного журнала
		uint   PhnSvcPrcCount;   // Количество обращений к телефонному сервису
		uint   PhnSvcMsgCount;   // Количество событий поступивших от телефонного сервиса
		uint   MqbPrcCount;      // Количество обращений к брокеру сообщений
		uint   MqbMsgCount;      // Количество сообщений поступивших от брокера сообщений
	};

	int    FASTCALL RegisterClient(const Client * pCli);
	void   FASTCALL SetStatFlag(uint f);
	void   FASTCALL AddStatCounters(const Stat & rAddendum);
	int    GetStat(Stat & rStat);
private:
	int64  LastIdent;
	Stat   S;
	SMtLock SLck; // Критическая секция для блока статистики S
	ReadWriteLock Lck;
	SMtLock ClLck; // Критическая секция для списка клиентов
	SCollection CliList; // Список указателей на клиентов очереди (без владения объектами)
		// Необходим для определения маркера, ниже которого записи очереди уже не нужны.
};
//
//
//
class PPRevolver_StringSetSCD : public TSRevolver <PPStringSetSCD> {
public:
	explicit PPRevolver_StringSetSCD(uint c);
	StringSet & Get();
};
//
// Descr: Класс, обеспечивающий хранение глобальных данных, привязанных к потоку.
//
class PPThreadLocalArea {
public:
	friend class PPSession;
	PPThreadLocalArea();
	~PPThreadLocalArea();
	void * FASTCALL GetPtr(uint idx) const;
	void * FASTCALL GetPtrNonIncrement(uint idx) const;
	int    CreatePtr(uint idx, void *);
	int    FASTCALL ReleasePtr(uint idx);
	void   PushErrContext();
	void   PopErrContext();
	bool   IsConsistent() const;
	long   GetId() const { return Id; }
	//
	// Descr: Возвращает !0 если поток авторизован в базе данных Papyrus
	//
	int    IsAuth() const;
	ThreadID GetThreadID() const { return TId; }
	PPView * GetPPViewPtr(int32 id) const;
	int32  CreatePPViewPtr(PPView *);
	int    ReleasePPViewPtr(int32 id);
	//
	// Descr: Идентификаторы event-responder'ов - автономных объектов, привязанных к потоку и отвечающих
	//   за высокоуровневую реакцию на различные внешние события.
	//
	enum {
		eventresponderPhoneService   = 1, // респондер для событий телефонного сервиса
		eventresponderMqb            = 2, // респондер для событий брокера сообщений
		eventresponderSysMaintenance = 3  // респондер для событий evQuartz, изредка осуществляющий вызов функций системного обслуживания
	};

	int    SetupEventResponder(int eventResponderId);
	void   ReleaseEventResponder(int eventResponderId);
	//
	// Descr: До версии 8.6.1 некоторые атрибуты, связанные с текущим значением главной
	//   организации инициализировались при открытии сессии (PPSession::Login).
	//   Однако, выяснилось, что это - достаточно тяжелая операция. В связи с этим
	//   теперь инициализация указанных атрибутов выполняется при необходимости после
	//   чего в поле PPThreadLocalArea::State устанавливается флаг stMainOrgInit.
	//   Наличие этого флага означает, что все атрибуты правильно инициализированы,
	//   отсутствие - надо инициализировать.
	//   Функция InitMainOrgData, если reset == 0 проверяет установку флага stMainOrgInit
	//   и, если он не стоит, инициализирует атрибуты. Если флаг установлен, то ничего
	//   не делает.
	//   Если аргумент reset != 0, то функция сбрасывает флаг stMainOrgInit (это может
	//   быть необходимо, например, при изменении главной организации).
	//
    int    InitMainOrgData(int reset);
    int    SetIfcConfigParam(const char * pParam, const char * pValue);
    int    GetIfcConfigParam(const char * pParam, SString & rValue) const;
    SrDatabase * GetSrDatabase();
	PPEgaisProcessor * GetEgaisProcessor();
private:
	int    RegisterAdviseObjects();
	void   OnLogout();

	struct PtrEntry {
		void * Ptr;
		int    RefCounter;
		int    InUse;
	};
	struct ErrContext {
		int    Err;
		int    CrwErr;
		int    BtrErr;
		int    SlErr;
		PPObjID LastErrObj;
		SString AddedMsgString;
		SString DbFileName;
	};
	struct PrivateCart {
	public:
		PrivateCart();
		~PrivateCart();
		int    operator !() const;
		int    Is(PPID basketID) const;
		int    Set(const PPBasketPacket * pPack, int use_ta);
		PPBasketPacket * Get();
	private:
		PPBasketCombine * P;
	};
	uint32 Sign;           // Если Sign == PPConst::Signature_PPThreadLocalArea, то данный объект является валидным (в частности, не разрушен деструктором)
	long   Id;             // @id
	ThreadID TId;          // Идентификатор потока
	uint   PtrVectDim;
	PtrEntry * P_PtrVect;
	ErrContext * P_ErrCtx;
	PPThread * P_AeqThrd;
	SrDatabase * P_SrDb;
	PhoneServiceEventResponder * P_PhnSvcEvRespr;
	MqbEventResponder * P_MqbEvRespr;
	SysMaintenanceEventResponder * P_SysMntnc;
	PPEgaisProcessor * P_EgPrc_; // @v12.2.11
public:
	class WaitBlock {
	public:
		WaitBlock();
		~WaitBlock();
		bool   IsValid() const;
		HWND   GetWindowHandle() const;
		int    Start();
		int    Stop();
		int    Hide();
		int    Show();
		void   FASTCALL SetMessage(const char *);
		void   STDCALL  SetPercent(ulong p, ulong t, const char * msg);
	private:
		enum {
			stValid = 0x0001,
			stHide  = 0x0002,
		};
		long   State;
		HWND   hwndPB;  // Progress Bar
		HWND   hwndST;  // Static Text
		HWND   WaitDlg;
		HCURSOR WaitCur;
		HCURSOR OrgCur;
		TView * PrevView;
		ulong  PrevPercent;
		ulong  PrevPromille; // @v11.4.4
		SString Text;
		SString PrevMsg;
		SCycleTimer IdleTimer;
	};
	int    LastErr;        // Last error code //
	int    LastCrwErr;     // Last Crystal Report Error Code
	PPConfig     Lc;       // Текущая локальная конфигурация //
	PPCommConfig Cc;       // Текущая общая конфигурация     //
	//
	// Следующие три поля извлекаются из общих условий соглашений с поставщиками
	// PPObjArticle::GetSupplAgreement(0, PPSupplAgreement *)
	//
	PPID   SupplDealQuotKindID;  // Вид котировки, определяющий контрактные цены поставщиков
	PPID   SupplDevUpQuotKindID; // Вид котировки, определяющий верхние отклонения от контрактных цен поставщиков
	PPID   SupplDevDnQuotKindID; // Вид котировки, определяющий нижние отклонения от контрактных цен поставщиков
	int16  InvalidSupplDealQuotAction; // действие при неверной контрактной цене
	int16  Reserve;              // @alignment
	PPID   GlobAccID;            // Текущий ИД глобальной учетной записи
	PPID   AgentAccSheetID;      // 0 - не инициализирован, -1 - не удалось идентифицировать, >0 - валидное значение
	PPID   DefPhnSvcID;          // Ид телефонного сервиса по умолчанию (PPEquipConfig::PhnSvcID)
	//
	// Descr: Флаги состояния State
	//
	enum {
		stExpTariffTa    = 0x0001,
		stMainOrgInit    = 0x0002,
		stAuth           = 0x0004, // Поток авторизован в базе данных Papyrus
		stNonInteractive = 0x0008  // Поток не-интерактивный: всякие окна, диалоги и виджеты запрещены
	};
	int    State;                // @Muxa Флаги
	SysJournal * P_SysJ;
	ObjSyncCore * P_ObjSync;     // Откроем таблицу при входе в сеанс что бы не приходилось ее открывать при каждом удалении объекта (в транзакции)
	GtaJournalCore * P_GtaJ;     //
	Reference  * P_Ref;
	PPObjBill  * P_BObj;
	// Следущие два экземпляру инициализируются нулями и используются только в специальных случаях
	// (на текущий момент - для генерации последовательностей) {
	PPObjWorld * P_WObj;
	PPObjWorkbook * P_WbObj;
	// }
	PPObjPrjTask * P_TodoObj;    //
	PPObjID  LastErrObj;         // Object's ID, by last generated error
	PPLastInputData Lid;
	int    PrnDirId;
	SCodepageIdent DL600XmlCp;    // Кодовая страница для стандартного экспорта DL600 в XML
	DlContext * P_ExpCtx;         // Контекст экспортных структур данных
	DlContext * P_IfcCtx;         // Контекст COM-интерфейсов
	DlContext * P_UiViewCtx;      // @v12.3.6 Контекст описания диалогов и прочих объектов UI в формате DL600
	DlContext * P_UiViewLocalCtx; // @v12.3.6 Контекст описания диалогов и прочих объектов UI в формате DL600 (локальный по отношению к инсталляции)
	//
	// Далее идут поля, типы данных которых имеют конструкторы
	//
	PPRights Rights;             // @anchor Rights for object's access
	ACount  RightsUpdateCounter; // Счетчки, предписывающий обновить права доступа экземплярам объектов.
		// Необходим для уведомления экземпляров PPObject о том, что флаги доступа были изменены посредством
		// включения или отключения PPObjSecur::Exclusion
	PPPaths Paths;               // Текущие пути доступа к файлам  //
	SString PrintDevice;         //
	SString UserName;            // @*PPSession::Login @.Имя текущего пользователя //
	SString GlobAccName;         // @Muxa Имя глобальной учетной записи
	SString AddedMsgString;
	SString AddedMsgStrNoRights; // Дополнительная строка контекста сообщения PPERR_NORIGHTS
	SString TempLogFile;         // Имя временного файла журнала, в котором дублируются все записи в журналы.
		// Используется для формирования файла отчета, который будет отправлен администратору по e-mail
	SString DL600XMLEntityParam; // Строка ограничения трансляции символов строк в сущности XML при экспорте в XML
	SStringTag SCardPatterns;    // Образцы разбора номеров дисконтных карт.
		// Загружаются из файла конфигурации pp.ini ([config] SCardPatterns).
		// Если SCardPatterns.Id != 0, то строка не загружена из конфигурации.
	//
	// Текущие наименования главной организации и раздела БД.
	// Используются для быстрого обновления строки статуса.
	//
	SStringTag MainOrgName;
	SString MainOrgCountryCode;  // Код страны главной организации. Используется для идентификации собственной страны в адресах
	SStringTag CurDbDivName;
	SString PaperlessCheque_FakeEAddr; // @v11.3.7 Фейковый электронный адрес для отправки безбумажного чека.
		// Загружаются из файла конфигурации pp.ini ([config] paperlesscheque_fakeeaddr).
	BarcodeArrangeConfig Bac;
	SurKeyArray    SurIdList;    // Массив динамически идентифицируемых записей, используемых
		// для параметризации структур DL600, не имеющих естественного идентификатора (например SysJournalEntry).
	PPSync Sync;                 // Синхронизатор сетевых пользователей
	PPJobSrvClient SrvSess;      // Сессия связи с JobServer
	WaitBlock WD;
	Profile Prf;                 // Локальный по отношению к потоку профайлер
	PPUserFuncProfiler UfpSess;  // Точка профилирования длительности жизни потока (от Login до Logout)
private:
	PrivateCart Cart;            // Персональная корзина пользователя //

	class IdleCommand : public SCycleTimer {
	public:
		explicit IdleCommand(long repeatEachSeconds);
		virtual ~IdleCommand();
		virtual int FASTCALL Run(const LDATETIME & rPrevRunTime);
	};
	TSCollection <IdleCommand> IdleCmdList;
	TSCollection <PPView> SrvViewList;
	StrStrAssocArray IfcConfig; // Параметры конфигурации интерфейсов. Устанавливаются вызовом PPUtil::SetConfigParam
	PPRevolver_StringSetSCD RvlSsSCD; // Револьверная коллекция shortlived-stringset'ов для использования в кэшах
};

class __PPThrLocPtr {
public:
	__PPThrLocPtr();
	int    IsOpened();
protected:
	void * FASTCALL Helper_Open(SClassWrapper &);
	void   FASTCALL Helper_Close(SClassWrapper &, void * ptr);
	uint   Idx;
};

template <class T> class PPThrLocPtr : public __PPThrLocPtr {
public:
	PPThrLocPtr() : __PPThrLocPtr() {}
	T *  Open() { return static_cast<T *>(Helper_Open(Cw)); }
	void   Close(T * p) { Helper_Close(Cw, p); }
	TSClassWrapper <T> Cw;
};

#define TLP(M)            __##M
#define TLP_MEMB(T,M)     static PPThrLocPtr<T> __##M; T * M
#define TLP_IMPL(C,T,M)   PPThrLocPtr <T> C::__##M
#define TLP_OPEN(M)       M=__##M.Open()
#define TLP_CLOSE(M)      __##M.Close(M)
//
//
//
struct PPNotifyEvent : public PPExtStrContainer {
	enum {
		extssMessage  = 1,
		extssChannel  = 2,
		extssCallerId = 3,
		extssConnectedLineNum = 4,
		extssContext  = 5,
		extssExten    = 6,
		extssBridgeId = 7
	};
	PPNotifyEvent();
	~PPNotifyEvent();
	void   Clear();
	PPNotifyEvent & Finalize(const LDATETIME & rExtDtm, long extInt);
	int    IsFinish() const;

	long   Action;
	PPID   ObjType;
	PPID   ObjID;
	long   ExtInt_;
	LDATETIME ExtDtm;
	PPMqbClient::Envelope * P_MqbEnv;
};
//
// Descr: callback-функция, вызываемая в ответ на событие.
//
typedef int (*PPAdviseProc)(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
//
// Descr: Блок установки требования на оповещение о событии
//
struct PPAdviseBlock {
	PPAdviseBlock();

	enum {
		evDirtyCacheBySysJ = 1, // Оповещать о событии в системном журнале в функции сбора событий для установки "грязных" элементов кэша.
		evPPObjMsg,             // Оповещать о сообщении, инициированном для объектов PPObject
		evTodoChanged,          // Оповещать об изменении задач
		evBillChanged,          // Оповещать об изменении документов
		evSysJournalChanged,    // Оповещать об изменении в системном журнале
		evLogsChanged,          // Оповещать об изменениях выбранных журналов
		evBizScoreChanged,      // Оповещать об изменениях бизнес-показателей
		evWaitMsg,              // Оповещать о вызове PPWaitMsg или PPWaitPercent
		evQuartz,               // Оповещать через секундные интервалы
		evTSessChanged,         // Оповещать об изменениях технологических сессий
		evPsnEvChanged,         // Оповещать об изменениях персональных операций
		evPhoneRinging,         // Телефонный сервис: звонит телефон
		evPhoneUp,              // Телефонный сервис: поднята телефонная трубка
		evConfigChanged,        // Оповещать об изменениях конфигураций
		evMqbMessage,           // Принято сообщение от брокера сообщений
		evEventCreated          // Сформировано событие, на которое подписан пользователь
	};
	long   Cookie;     // for internal use
	int    Kind;       // PPAdivseBlock::evXXX Тип извещения, для которого сформирован этот блок.
	ThreadID TId;      // Если !0, то сообщения передаются только потоку с этим ИД.
	long   DbPathID;   // Если !0, то сообщения передаются только потокам, авторизованным в базе данных с этим ИД.
	long   Action;     // Событие, о котором необходимо провести оповещение. Зависит от Kind:
		// Если Kind==evDirtyCacheBySysJ, то Action = ACN_XXX, если Kind==evPPObjMsg, то Action = DBMSG_XXX
	PPID   ObjType;    // Тип объекта PPObject, которому соответствует событие Action
	long   Flags;
	void * ProcExtPtr; // Значение, передаваемое функции Proc при извещении о возникновении события //
	PPAdviseProc Proc; // Процедура, которая должна быть вызвана в ответ на событие Action с типом объекта ObjType.
};
//
// @todo Нужна "lite" версия PPAdviseList без RwL, возвращаемая функцией CreateList. Для того, чтобы обойти
// неоправданное создание блокировок.
//
class PPAdviseList : private SArray {
public:
	friend class PPSession;

	PPAdviseList();
	//
	// Descr: Перебирает элементы списка.
	// Attention: Этот метод не-блокируемый. Его можно использовать
	//   только на локальной по отношению к потоку копии списка.
	//
	int    FASTCALL Enum(uint * pI, PPAdviseBlock *) const;
	uint   GetCount(); // @sync_wr
private:
	int    Advise(long *, const PPAdviseBlock *); // @sync_wr
	int    CreateList(int kind, ThreadID tId, long dbPathID, PPID objType, PPAdviseList & rList); // @sync_wr
	long   LastCookie; // Последний использованный идентификатор для AdviseList
	ReadWriteLock RwL;
};
//
//
//
struct ObjCacheEntry { // size=16
	//
	// Attention: Классы, порожденные от ObjCache могут использовать поле F
	//   для собственных флагов.
	//
	enum {
		fDirty = 0x0001,
		fUndef = 0x0002
	};
	PPID   ID;
	uint   NameIdx;
	uint16 F;       // Флаги ObjCacheEntry::fXXX
	uint16 __PadF;  // @alignment Ради быстродействия теряем два байта на каждом элементе
	ACount Counter; // Счетчик обращений к этому элементу
};

struct ObjCacheStat {
	void   Init();

	long   DbPathID;
	long   ObjType;
	long   Hits;          // Количество попаданий
	long   Misses;        // Количество промахов
	long   Count;         // Количество обращений
	long   Collisions;    // Количество коллизий при нахождении слота (для ObjCacheHash)
	long   NumEntries;    // Общее количество слотов в хранилище кэша
	long   UnusedEntries; // Количество неиспользуемых слотов (для ObjCacheHash)
	long   DirtyEntries;  // Количество "грязных" элементов
	long   MaxCounter;    // Максимальный счетчик
	long   MinCounter;    // Минимальный счетчик
	uint32 SsSize;        // Количество байт в this->Ss (this->Ss.Size)
	uint32 SsDataLen;     // Полезное количество байт в this->Ss (this->Ss.DataLen)
	SString DbPath;
	SString ObjTypeName;
};

class ObjCache {
public:
	enum {
		fOwnerArray   = 0x0001, // Порожденный кэш самостоятельно инициализирует массив P_Ary
		fUseUndefList = 0x0002  // Кэш поддерживат список неопределенных идентификаторов.
			// Если флаг установлен, и функция FetchEntry возвращает -100, то считается, что
			// заданный идентификатор не определен и должен быть вставлен в список неопределеннх
			// идентификаторов. При извлечении в дальнейшем элемента с таким идентификатором
			// функция ObjCache::Get возвращает указатель на ObjCacheEntry с полем ID равным
			// запрошенному идентификатору, полем F с флагом ObjCacheEntry::fUndef.
			// Остальные поля при этом могут иметь непредсказуемые значения.
	};
	ObjCache(PPID objType, size_t entrySize, long flags = 0);
	virtual ~ObjCache();
	virtual int    Get(PPID, void * pDataRec, void * extraData = 0); // @sync_wr // @v12.2.2 (long extraData = 0)-->(void * extraData = 0)
	//
	// Desr: Помечает элемент с идентификатором id как недостоверный ("грязный")
	// Returns:
	//   >0 - элемент с идентификатором id найден и помечен
	//   <0 - элемент с идентификатором id не найден
	//   0  - ошибка
	//
	virtual void FASTCALL Dirty(PPID id); // @sync_w
	//
	// Descr: Должна возвратить количество элементов в хранилице.
	//   Внутренние методы класса полагаются на эту функцию при определении валидности
	//   индекса элемента.
	//
	virtual uint GetCount() const;
	//
	// Descr: Ищет в кэше запись по ключу pKey с помощью функции f.
	//   Если такая запись найдена, то возвращает ее по указателю pDataRec.
	//   Если запись не найдена, то возвращает управление вызывающей функции.
	//   В отличии от ObjCache::Get эта функция не пытается самостоятельно
	//   занести требуемую запись в кэш (для этого просто нет механизма).
	//   То есть вызывающая функция должна самостоятельно извлечь не найденную
	//   в кэше запись из базы данных.
	// Perf: Поиск осуществляется линейно (SArray::lsearch). По этому для классов //
	//   со значительным количеством записей эта функция может оказаться медленней,
	//   чем какой-либо иной механизм.
	//
	int    GetBySrchFunc(const void * pKey, CompFunc f, void * pDataRec); // @sync_r
	PPID   GetObjType() const { return ObjType; }
	size_t GetEntrySize() const { return EntrySize; }
	int    GetStat(ObjCacheStat *);
protected:
	//
	// Descr: Эта функция должна заполнить буфер pEntry значениями, взятыми из базы данных.
	//   Функция вызывается в том случае, когда кэш не содержит элемента, соответствующего
	//   идентификатору id или этот элемент необходимо обновить.
	// ARG(id         IN): идентификатор объекта, информацию о котором необходимо извлечь из БД
	// ARG(pEntry    OUT): указатель на буфер размером ObjCache::EntrySize, который должен быть
	//   заполнен полями, соответствующими объекту с идентификатором id. Вызывающая функция //
	//   обязательно распределяет пространство под этот указатель и заполняет его нулями.
	// ARG(extraParam IN): произвольное значение, переданное в функцию ObjCache::Get.
	// Returns:
	//   >0 - буфер pEntry успешно заполнен
	//   <0 - функция не выполнила контракт по "уважительным причинам" (например, объект
	//        с идентификатором id не существует.
	//   0  - ошибка
	//
	virtual int  FetchEntry(PPID id, ObjCacheEntry * pEntry, void * extraData) = 0;
	virtual void EntryToData(const ObjCacheEntry * pEntry, void * pDataRec) const = 0;
	//
	// Descr: Эта функция должна найти элемент с идентификатором id и вернуть его позицию
	//   в хранилище. Если элемент не найден, то функция должна присвоить по указателю
	//   pPos значение UNDEFPOS.
	// Returns:
	//   >0 - элемент с идентификатором id найден и не имеет признака ObjCacheEntry::fDirty
	//        по указателю pPos возвращается номер позиции, в которой находится элемент
	//   0  - элемент с идентификатором id не найден. По указателю pPos возвращается //
	//        значение UNDEFPOS
	//
	virtual int FASTCALL Search(PPID id, uint * pPos) const;
	//
	// Descr: Должна получить указатель на элемент кэша с индексом pos.
	//   Если incr != 0, то после извлечения элемента обязана уведичить счетчик обращений к нему.
	//
	virtual ObjCacheEntry * FASTCALL SearchByPos(uint pos, int incr) const; // @<<ObjCache::Helper_GetByPos
	//
	// Descr: Все, что должна сделать эта функция - вставить новый элемент в хранилище
	//   и по адресу pPos вернуть позицию в которой оказался новый элемент. Больше ничего
	//   делать не следует. Все операции по синхронизации выполняют вызывающие функции.
	// ARG(pEntry     IN): адрес, по которому находится буфкр данных для вставки
	// ARG(pPos   IN/OUT): адрес позиции, по которой следует добавить запись. Если
	//   *pPos == UNDEFPOS,  то добавляется новая запись, если
	//   *pPos != UNDEFPOS && *pPos < GetCount() то функция должна обновить запись в
	//   позиции *pPos.
	// Returns:
	//   >0 - элемент pEntry успешно добавлен в хранилище, по указателю pPos содержится //
	//        позиция, в которой находится этот элемент.
	//   0  - ошибка. В этом случае вызывающая функция не пытается интерпретировать значение
	//        по указателю pPos.
	//
	virtual int AddItem(const ObjCacheEntry * pEntry, uint * pPos);
	int    STDCALL  PutName(const char * pName, ObjCacheEntry *); // @<<(X:ObjCache)::FetchEntry
	void   STDCALL  GetName(const ObjCacheEntry *, char * buf, size_t buflen) const; // @<<(X:ObjCache)::EntryToData
	//
	// Descr: реализация удаления элемента кэша с идентификатором id.
	//   Если порожденный класс самостоятельно реализует
	//   функцию Dirty, то для наследования родительской реализации следует использовать
	//   Helper_Dirty, а не Remove, поскольку критическая секция должна охватывать всю
	//   реализацию Dirty.
	//
	void   FASTCALL Helper_Dirty(PPID id); // @<<ObjCache::Remove, @>>ObjCache::Helper_RemoveByPos

	class MultTextBlock {
	public:
		friend class ObjCache;

		MultTextBlock();
		MultTextBlock(const ObjCache * pCache, const ObjCacheEntry * pEntry);
		int    FASTCALL Add(const char *);
		int    STDCALL  Get(char * pBuf, size_t bufLen);
		int    FASTCALL Get(SString & rBuf);
	private:
		const  int RdMode;
		uint   CurPos;
		StringSet & R_Ss; // Инициализируется DS().AcquireRvlSsSCD()
	};

	int    STDCALL  PutTextBlock(const MultTextBlock & rBlk, ObjCacheEntry * pEntry);

	struct ExtTextBlock {
		void   FASTCALL Dirty(PPID id);
		int    Fetch(PPID id, SString & rBuf, void * extraPtr);
		virtual int Implement_Get(PPID id, SString & rBuf, void * extraPtr);

		UintHashTable MissingList; // Список идентификаторов, для которых нет текста
		StrAssocArray List;
		ReadWriteLock Lock;  // Блокировка списка ExtMemoList
	};

	StringSet Ss;
	ReadWriteLock RwL; // Блокировка "Один писатель - много читателей"
	//
	// Descr: Специализированный подкласс, реализующий кэширование объектов, хранящихся в
	//   Reference по символам.
	//
	class RefSymbArray : public StrAssocArray {
	public:
		RefSymbArray(PPID objType);
		void   FASTCALL Dirty(PPID id); // @sync_w
		int    FetchBySymb(const char * pSymb, PPID * pID);
	private:
		PPID   ObjType;
		int    Inited;
		PPIDArray DirtyTable;
		ReadWriteLock SlLock;
	};
protected:
	struct Stat {
		ACount Hits;
		ACount Misses;
		ACount Count;
		ACount Collisions;    // Количество коллизий при нахождении слота (для ObjCacheHash)
		long   UnusedEntries; // Количество неиспользуемых слотов (для ObjCacheHash)
		long   MaxCounter;    // Максимальный счетчик
		long   MinCounter;    // Минимальный счетчик
	};
	int    Put(PPID id, uint *, void * extraData); // @<<ObjCache::Get // @v12.2.2 (long extraData)-->(void * extraData)
	//
	// Descr: Извлекает запись из хранилища по позиции pos.
	// Returns:
	//   >0 - запись по позиции pos успешно извлечена
	//   <0 - запись по позиции pos имеет признак ObjCacheEntry::fDirty
	//   0  - ошибка
	//
	int    FASTCALL Helper_GetByPos(uint pos, void * pDataRec);
	int    FASTCALL Helper_Get(PPID id, void * pDataRec); // @v12.2.2 (private:)-->(protected:)
	int    PackNames(); // @<<ObjCache::Remove

	PPID   ObjType;
	long   Flags;    // OBJCHF_XXX
	size_t EntrySize;
	size_t UnusedNameSpace; // Размер неиспользуемого пространства массива строк ss
	Stat   StatData;
	SArray * P_Ary;
	SString StatLogMsg;
	mutable int EntryToDataFailed; // Специальный индикатор, позволяющий виртуальному методу EntryToData
		// просигналить о том, что что-то пошло не так и надо обновить запись в кэше. Это - костыль, добавленный
		// из-за того, что EntryToData - void-метод и весь обложен константными ограничениями.
private:
	int64  LastPackNamesClock; // Момент последнего вызова PackNames()
	UintHashTable UndefList;   // Используется если (Flags & fUseUndefList)
};
//
//
//
#define DEF_OBJCACHEHASH_SIZE     SKILOBYTE(256U)
#define DEF_OBJCACHEHASH_MAXTRIES 4

class ObjCacheHash : public ObjCache {
public:
	ObjCacheHash(PPID objType, size_t entrySize, size_t cacheSize, uint maxTries, long flags = 0);
	~ObjCacheHash();
protected:
	int    Init(size_t cacheSize, uint maxTries);
	virtual uint GetCount() const;
	virtual int  FASTCALL Search(PPID id, uint * pPos) const;
	virtual ObjCacheEntry * FASTCALL SearchByPos(uint pos, int incr) const; // @<<ObjCache::Helper_GetByPos
	virtual int AddItem(const ObjCacheEntry * pEntry, uint * pPos);
private:
	uint   FASTCALL Hash(PPID id, uint n) const;

	uint   Size;
	uint   MaxItems;
	uint   MaxTries;
	ObjCacheEntry * P_Items;
};
//
//
//
struct DbLocalCacheEntry {
	long   DbPathID;
	long   ObjType; // == P_Cache->ObjType
	void * P_Cache; // if ObjType==PPOBJ_ADVEVENTQUEUE then (PPAdviseEventQueue *) else (ObjCache *)
};

class DbLocalCacheMng : private TSArray <DbLocalCacheEntry> {
public:
	DbLocalCacheMng();
	~DbLocalCacheMng();
	int    CreateDbEntry(long dbPathID);
	int    HasDbEntry(long dbPathID);
	ObjCache * FASTCALL GetCache(long dbPathID, PPID objType);
	int    AddCache(long dbPathID, ObjCache *);
	int    GetCacheStat(uint pos, ObjCacheStat *);
	int    LogCacheStat();
	LDATETIME FASTCALL GetLastUpdate(long dbPathID);
	int    SetLastUpdate(long dbPathID, LDATETIME dtm);
	int    SetDeferredState(long dbPathID, int set);
	int    FASTCALL IsDeferredState(long dbPathID);
	//
	// Descr: Возвращает очередь системных событий, ассоциированную с базой данных dbPathID.
	//   Если такая очередь не существует, то функция пытается ее создать.
	//
	PPAdviseEventQueue * FASTCALL GetAdviseEventQueue(long dbPathID);
private:
	virtual void FASTCALL freeItem(void *);
	void * Helper_GetEntry(long dbPathID, PPID objType, int lock);
	//
	// Descr: Флаги состояния кэша
	//
	enum {
		stDeferred = 0x0001 // Включен отложенный режим актуализации
	};
	struct CDbEntry {
		long   DbPathId;
		long   State;              //
		LDATETIME LastCacheUpdate; // Время последнего обновления кэшей по системному журналу
	};
	SArray DbEntryList;
	ReadWriteLock RwL;
};

class PPVerHistory {
public:
	struct Info {
		Info();

		SVerT MinVer;
		SVerT CurVer;
		S_GUID DbUUID;
	};
	static int Log();
	static int Log(const char * pDataPath, const char * pLogPath);
	PPVerHistory();
	int    Read(const char * pDataPath, Info * pInfo);
	int    Write(const char * pDataPath, const Info * pInfo);
private:
	struct Header {
		uint32 Signature;
		uint32 CRC;
		SVerT CurVer;
		SVerT MinVer;
		S_GUID DbUUID;
		uint32 Reserved[7];
	};
	struct Record {
		LDATETIME Dtm;
		SVerT Ver;
		char   Machine[32];
		char   Reserved[20];
	};
};
//
// Descr: Структура с информацией о зарезервированном файле.
//
class PPRFile {
private:
	uint32 Sign;
public:
	PPRFile();
	~PPRFile();
	PPRFile & Z();
	bool   IsConsistent() const;

	PPID   ID;
	PPID   PathID;
	PPID   SrcPathID;
	long   Flags;
	SString Name;
	SString Descr;
};
//
//
//
class PPThread : public SlThread {
public:
	//
	// Descr: Структура, используемая для извлечения информации о потоках сервера.
	//
	struct Info {
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		enum {
			stLocalStop = 0x0004
		};
		int32   Id;            // Thread ID
		int32   Kind;          // PPThread::kXXX
		int32   Status;        // Состояние потока PPThread::Info::stXXX
		PPID    JobID;         // Идент задачи (Kind==kJob)
		LDATETIME StartMoment; // Время запуска
		SString Text;          // Текстовое обозначение потока (зависит от Kind)
		SString LastMsg;       //
		int32   UniqueSessID;  //
	};
	//
	// Descr: Вид потоков
	//
	enum {
		kUnknown = 0,    // Неопределенный
		kJobServer,      // Серверный поток
		kNetServer,      //
		kJob,            // Исполняемое задание сервера
		kNetSession,     // Серверная сессия, свяазанная с удаленной клиентской сессией
		kDbDispatcher,   // Диспетчерский поток (в режиме JobServer один на каждую базу данных)
		kEventCollector, // Сборщик событий
		kLogger,         // Поток для вывода сообщений в журналы
		kDllSession,     // Поток созданный в DLL-модуле
		kPpppProcessor,  // Поток, обеспечивающий обработку входящих данных на стороне автономного кассового узла
		kNginxServer,    // Поток сервера NGINX
		kWorkerSession,  // Рабочий поток для исполнения команд (также является базовым для kNetSession)
		kNginxWorker,    // Рабочий поток сервера NGINX (запускается потоком kNginxServer)
		kStyloQServer,   // @v11.0.9 Поток сервера, принимающего запросы StyloQ
		kStyloQSession,  // @v11.0.0 Поток, получающий управление сеансом обмена от сервера StyloQ
		kCasualJob,      // @v11.4.2 Поток для исполнения утилитарной функции
		kWsCtl           // @v11.7.1 Поток подсистемы ws-ctl, реализующий асинхронные запросы к серверу
	};
	static int FASTCALL GetKindText(int kind, SString & rBuf);
	PPThread(int kind, const char * pText, void * pInitData);
	int    GetKind() const { return Kind; }
	void   FASTCALL SetText(const char * pTxt);
	void   FASTCALL SetMessage(const char * pMsg);
	void   FASTCALL GetInfo(PPThread::Info & rInfo) const;
	void   FASTCALL LockStackToStr(SString & rBuf) const;
	int32  GetUniqueSessID() const { return UniqueSessID; }

	enum SignatureAttr {
		sattrOuterSignature = 0x0001,
		sattrSvcIdent       = 0x0002
	};
	//
	// Descr: Возвращает true если в потоке задана внешняя сигнатура.
	//
	bool   HasSignatureAttr(uint orSignatureAttrFlags) const;
	void   FASTCALL SetOuterSignature(const char * pSignature); // @v11.1.12
	void   FASTCALL SetSvcIdent(const void * pIdent, size_t identSize); // @v12.3.1
	//
	// Descr: Если !isempty(pS) и сигнатура потока равена pS, то возвращает true.
	//   Если isempty(pS) и сигнатура потока пустая, то возвращает true.
	//   В остальных случаях возвращает false.
	//
	bool   FASTCALL CheckOuterSignature(const char * pS) const; // @v11.1.12
	bool   FASTCALL CheckSvcIdent(const void * pIdent, size_t identSize) const; // @v12.3.1
	//
	// Descr: Если время жизни сигнатуры в секундах превысило таймаут, заданный параметром timeoutSec,
	//   то значение сигнатуры обнуляется. Таким образом, поток теряет привязку к сигнатуре.
	//   Ради ускорения обработки множества потоков текущее время передается параметром currentEpochTime
	// 
	//   Функция не сбрасывает значение идентификатора сервиса, ассоциированного с потоком, поскольку
	//   этот идентификатор важен при переназначении потока задаче, связанной с тем же сервисом.
	//
	void   FASTCALL ResetOuterSignatureByTimeout(int64 currentEpochTime, int timeoutSec);
	virtual int SubstituteSock(TcpSocket & rSock, PPJobSrvReply * pReply) { return -1; }
protected:
	//
	// Descr: Вспомогательный класс, используемый для отмера времени опроса очередного источника событий
	//
	class EvPollTiming {
	public:
		EvPollTiming(int periodMs, bool registerImmediate);
		void   Register();
		bool   IsTime() const;
	private:
		const  int64 PeriodMks;
		int64  LastPollClock;
	};
	virtual void Startup();
	void   FASTCALL SetJobID(PPID jobID);
public: // Метод Shutdown вызывается из функции DllMain
	virtual void Shutdown();
private:
	int    Kind;
	PPID   JobID;
	int32  UniqueSessID; // Фактически, идентификатор потока. Инициируется функцией PPThread::Startup() как {UniqueSessID = DS.GetTLA().GetId();}
	LDATETIME StartMoment;
	//
	// @v11.1.12 Сигнатура потока, заданная внешним актором. Назначение ее в том, чтобы при
	//   повторном обращении с этой же сигнатурой можно было бы найти поток, который "занимался вопросом" ранее.
	//   Текущая мотивация заключается в асинхронной обработке запросов к серверу.
	//   Важно: в общем случае нелья гарантировать, что эта сигнатура уникальна, поскольку эмитирована
	//   актором, который нами не контролируется.
	// 
	// @v12.3.1 Начиная с этого релиза в блоке так же хранится идентификатор сервиса Stylo-Q, обслуживаемого 
	//   этим потоком.
	//
	struct SignatureBlock {
		SignatureBlock() : Tm(0)
		{
			Signature[0] = 0;
			SvcIdent[0] = 0;
		}
		char   Signature[64]; // Собственно, сигнатура. Реализована в виде плоского массива символов
			// с целью снизить накладные расходы на обработку.
		char   SvcIdent[64];  // @v12.3.1 Идентификатора сервиса Stylo-Q, обслуживаемого этим потоком
		mutable SMtLock Lck; // Блокировка (возможно, правильнее будет read-write, но пока сделаем по-проще)
		int64 Tm; // Epoch-time время установки. Используется для сброса, если время жизни превысило
			// допустимый таймаут (другими словами, для освобождения потока, чтобы он мог заняться иной работой).
	};
	SignatureBlock OtrSigntr;

	SString Text;
	SString LastMsg_;
};

class PPWorkerSession : public PPThread {
public:
	explicit PPWorkerSession(int threadKind);
	virtual ~PPWorkerSession();
	virtual void Shutdown();
protected:
	//
	// Descr: Коды возврата функции ProcessCommand
	//
	enum CmdRet {
		cmdretError          = 0,
		cmdretOK             = 1,
		cmdretQuit           = 100, // После обработки команды следует завершить сеанс.
		cmdretResume         = 101, // Команда восстановления сеанса. Необходимо завершить текущий сеанс и не посылать клиенту ответ, поскольку это сделает восстновленная сессия.
		cmdretSuspend        = 102, // Была обработана команда SUSPEND.  Сеанс входит в режим ожидания восстановления (timeout = SuspendTimeout)
		cmdretStyloBhtIIMode = 103, // Сессия должна войти в режим обмена с устройством StyloBHT II
		cmdretUnprocessed    = 104  // Команда не обработана. Базовый класс может вернуть этот результат, предполагая,
			// что порожденный класс или вызывающая функция обработает команду самостоятельно.
	};
	virtual CmdRet ProcessCommand_(PPServerCmd * pEv, PPJobSrvReply & rReply);
	CmdRet Helper_QueryNaturalToken(PPServerCmd * pEv, PPJobSrvReply & rReply);
	int    SetupTxtCmdTerm(int code);
	SString & GetTxtCmdTermMnemonic(SString & rBuf) const;
	void   FASTCALL RealeasFtbEntry(uint pos);
	enum {
		tfvStart,
		tfvNext,
		tfvFinish,
		tfvCancel
	};
	//
	// Descr: Типы контента, передаваемые функции TransmitFile
	//
	enum {
		tfctUnused = -1, // Это значение следует передавать функции TransmitFile при обработке всех фаз, кроме tfvStart (только
			// с этим значением vert параметр contentType имеет значение).
		tfctFile   =  0, // Файл. Параметр pParam - имя файла. 
		tfctBuffer =  1  // Буфер. Параметр pParam - указатель на SBaseBuffer. Если размер буфера более размера одной
			// порции передачи, то будет сделана копия буфера и передана в FTB-блок. Буфер по указателю pParam не
			// изменится, однако понадобится дополнительный объем памяти равный размеру этого буфера.
	};
	//
	// Descr: Реализует передачу больших данных клиенту. 
	// ARG(verb IN):
	// ARG(contentType IN):
	// ARG(pParam IN):
	// ARG(rReply, OUT):
	//
	CmdRet TransmitFile(int verb, int contentType /*tfctXXX*/, const void * pParam, PPJobSrvReply & rReply);
	int    FinishReceivingFile(const PPJobSrvReply::TransmitFileBlock & rBlk, const SString & rFilePath, PPJobSrvReply & rReply);
	enum {
		stLoggedIn  = 0x0001,
		stDebugMode = 0x0002  // Отладочный режим (вывод дополнительных данных в журналы)
	};
	long   State_PPws; //
	long   Counter; // Счетчик, используемый для получения уникального значения, с помощью которого
		// можно синхронизировать действия с клиентом
	CPosNodeBlock * P_CPosBlk;
	WsCtlSrvBlock * P_WsCtlBlk; // @v11.7.3
	//
	// Descr: Управляющая структура для сохранения состояния пересылки файла
	//
	struct FTB {
		FTB();
		~FTB();

		enum {
			kGeneric = 0,
			kObjImage
		};
		int32  Cookie;
		int32  ContentType; // tfctXXX
		int32  Kind;
		int64  Offs;
		PPID   ObjType;
		PPID   ObjID;
		PPJobSrvProtocol::TransmitFileBlock Tfb;
		SFile * P_F;
		SBaseBuffer * P_B; // @v11.4.0
	};
	TSCollection <FTB> FtbList;
	SString HelloReplyText; // @fastreuse (команда HELLO)
	const char * P_TxtCmdTerminal;
};
//
//
//
struct PPLogMsgItem {
	void   Clear();
	long   Options;
    SString FileName;
    SString DupFileName; // Имя дублирующего файла (опционально)
	SString Text;
	SString Prefix;
};

class PPLogMsgQueue : public SStrGroup {
public:
	struct Stat { //
		Stat();

		uint32  PushCount;       // Количество запросов Push
		uint32  PopCount;        // Количество запросов Pop
		uint32  MaxLenght;       // Максимальное количество сообщений в очереди
		size_t  MaxStrPoolSize;  // Максимальный объем пула строк
		uint32  NonEmptyEvCount; // Количество установок события NonEmptyEv
	};

	PPLogMsgQueue();
	~PPLogMsgQueue();
    int    FASTCALL Push(const PPLogMsgItem & rItem);
    int    FASTCALL Pop(PPLogMsgItem & rItem);
    void   FASTCALL GetStat(Stat & rS);

    Evnt   NonEmptyEv;
private:
	struct InnerItem {
		long    Options;
		uint    FileNameP;
		uint    DupFileNameP;
		uint    TextP;
		uint    PrefixP;
	};
	SQueue Q;
    SMtLock L;
    Stat   S;
};

class PPLogMsgSession : public PPThread {
public:
	struct Stat : public PPLogMsgQueue::Stat {
		Stat();

		uint32  MaxSingleOutputCount;       // Максимальное количество сообщений в очереди обработанное по одному событию PPLogMsgQueue::NonEmptyEv
		uint32  OutputCount;                // Количество выведенных сообщений
		uint32  FalseNonEmptyEvSwitchCount; // Количество срабатываний события PPLogMsgQueue::NonEmptyEv при которых очередь была пуста
	};
	PPLogMsgSession(PPLogMsgQueue * pQueue);
	int   FASTCALL GetStat(Stat & rS);
private:
	virtual void Run();
	PPLogMsgQueue * P_Queue;
	Stat   S;
};
//
//
//
class PPSession {
public:
	enum {
		fInitPaths                 = 0x0001, // Инициализировать пути (извлекает из pp.ini)
		fDenyLogQueue              = 0x0002, // Не инициализировать очередь журнальных сообщений (вывод прямо в файл)
		fWsCtlApp                  = 0x0004, // @v11.7.1 Объект инициализирован для отдельного приложения WsCtl
		fNoInstalledInfrastructure = 0x0008, // @v11.9.4 Процесс запускается вне предустановленной инфраструктуры (ресурсы строк, конфигурационные файлы и т.д.)
	};
	enum {
		cmdlHelp = 0,  // ?
		cmdlCash,      // CASH
		cmdlExport,    // EXP
		cmdlImport,    // IMP
		cmdlIn,        // IN
		cmdlOut,       // OUT
		cmdlBatch,     // BATCH
		cmdlSyncPut,   // SYNCPUT
		cmdlSyncGet,   // SYNCGET
		cmdlDB,        // DB
		cmdlBackup,    // BACKUP
		cmdlBillCash,  // BILLCASH
		cmdlPrc,       // PRC
		cmdlTSess,     // TSESS
		cmdlGoodsInfo, // GOODSINFO
		cmdlVerHist,   // VERHIST
		cmdlRecoverTransfer,  // RECOVERTRANSFER @temp
		cmdlConvertRbcBnk,    // CONVERTRBCBNK
		cmdlNoLogin,   // NOLOGIN
		cmdlPPOS,      // PPOS
		cmdlExportDialogs, // EXPORTDIALOGS
		cmdlSelfBuild,     // SELFBUILD
			// subcommand (selfbuild:subcmd)
			//   parsewinrcfornativetext - разбор файла ресурсов с целью извлечения русских текстов подлежащих формализации
			//   buildmanualstaff        - генерация материалов для вставки в документацию (зарезервированные объекты, в основном). Файлы формируются в каталоге OUT
		cmdlSartrTest,     // SARTRTEST
		cmdlAutoTranslate, // AUTOTRANSLATE
		cmdlConvertCipher, // CONVERTCIPHER
		cmdlPpIniSubst,     // PPINISUBST
		cmdlUhttGoodsToGitHubExport, // UHTTGOODSTOGITHUBEXPORT
		cmdlUiLang,         // UILANG
		cmdlWsControl,      // @v11.6.7 WSCONTROL @construction Управление рабочим сеансом Windows
		cmdlDevelop,        // @v12.2.1 DEVELOP Режим разработки (для wsctl)      
	};
	struct LoggerIntermediateBlock {
		explicit LoggerIntermediateBlock(const PPSession & rS);

		const   long CfgMaxFileSize;
		SString MsgBuf;
		SString TempBuf; // @allocreuse
		SString NewFileName;
	};
	static const char * P_JobLogin; // "$SYSSERVICE$"
	static const char * P_EmptyBaseCreationLogin; // "$EMPTYBASECREATION$"

	static int Helper_Log(PPLogMsgItem & rMsgItem, PPSession::LoggerIntermediateBlock & rLb);
	static int FASTCALL GetStartUpOption(int o, SString & rArgBuf);
	//
	// Descr: Создает конфигурационную базу данных BDB если видит, что каталог отсутствует
	//
	static int EnsureExtCfgDb();

	PPSession();
	~PPSession();
	int    Init(long flags /* PPSession::fInitXXX */, HINSTANCE hInst, const char * pUiDescriptionFileName);
	int    InitThread(const PPThread * pThread);
	void   ReleaseThread();
	PPThreadLocalArea & GetTLA(); // { return *(PPThreadLocalArea *)TlsGetValue(TlsIdx); }
	const PPThreadLocalArea & GetConstTLA() const; // { return *(PPThreadLocalArea *)TlsGetValue(TlsIdx); }
	//
	// Descr: Возвращает !0 если текущий поток является интерактивным.
	//
	int    IsThreadInteractive() const;

	enum {
		stntText = 1,
		stntMessage
	};
	int    SetThreadNotification(int type, const void * pData);
	int    GetThreadInfoList(int type, TSCollection <PPThread::Info> & rList);
	int    GetThreadInfo(ThreadID tId, PPThread::Info & rInfo);
	int    GetThreadListByKind(int kind, LongArray & rList);
	void   LogLocStk();
	//
	// Descr: Останавливает поток с идентификатором tId.
	// Note: Могут быть остановлены только потоки видов PPThread::kJob, PPThread::kNetSession, PPThread::kStyloQServer, PPThread::kWsCtl
	//
	int    StopThread(ThreadID tId);
	//
	// Descr: Возвращает !0 если текущий поток получил требование остановиться.
	//
	bool   IsThreadStopped();
	int    DispatchNgxRequest(void * pReq, const void * pCfg); // @cs // @construction

	enum {
		ldsLock      = 1,
		ldsUnlock    = 2,
		ldsCanUnload = 3
	};
	int    LockingDllServer(int cmd);
	//
	// Descr: Перечисление внутренних идентификаторов контекстов DL600, возвращаемых функцией GetInterfaceContext()
	//
	enum {
		ctxtExportData = 1,
		ctxtInterface,
		ctxDatabase,
		ctxUiView,      // @v12.3.6 Контекст описаний диалогов и других объектов пользовательского интерфеса в формате DL600
		ctxUiViewLocal, // @v12.3.6 Контекст описаний диалогов и других объектов пользовательского интерфеса в формате DL600 (локальный по отношению к инсталляции)
	};
	//
	// Descr: Возвращает контекст управления интерфейсными структурами или интерфейсными
	//   COM-объектами в зависимости от параметра ctxType.
	//   Вызывающие модули не должны делать никаких предположений о том, в каких файлах
	//   и как храняться возвращаемые контексты. Это требование формулируется для того,
	//   чтобы иметь возможности для оптимизации хранения и загрузки контекстов (их размер
	//   весьма внушителен, и, следовательно, в дальнейшем понадобятся меры для такой оптимизации).
	// ARG(ctxType IN): Тип контекста. Если ctxType == PPSession::ctxtExportData, то
	//   возвращает контекст управления структурами экспорта, если ctxType == PPSession::ctxtInterface,
	//   то возвращает контекст управления COM-объектами системы.
	//
	DlContext * GetInterfaceContext(int ctxType);
	int    GetUsedLicCount(int32 * pUsedLicCount);
	int    LoadDriveMapping(PPIniFile *);
	int    GetDriveMapping(int drive, SString & rMapping) const;
	int    ConvertPathToUnc(SString & rPath) const;
	int    CheckSystemAccount(DbLoginBlock * pDlb, PPSecur * pSecur);
	//
	// Descr: Результат выполнения функции LimitedOpedDatabase()
	//
	class LimitedDatabaseBlock {
	public:
		friend class PPSession;

		~LimitedDatabaseBlock();
		Reference * P_Ref;
		SysJournal * P_Sj;
		StyloQCore * P_Sqc;
	private:
		LimitedDatabaseBlock();
		uint32 State; // flag 0x0001 - dictionary was opened
	};
	//
	// Descr: Флаги функции LimitedOpedDatabase()
	//
	enum {
		lodfReference  = 0x0001,
		lodfSysJournal = 0x0002,
		lodfStyloQCore = 0x0004
	};
	//
	// Descr: Специальная функция, открывающая базу данных с символом pDbSymb в ограниченном режиме без авторизации.
	//   Фактически, открывается несколько таблиц для сервисного доступа на чтение.
	//
	LimitedDatabaseBlock * LimitedOpenDatabase(const char * pDbSymb, long flags);

	enum {
		loginfSkipLicChecking   = 0x0001,
		loginfInternal          = 0x0002,  // @v11.1.8 Авторизация осуществляется внутренним потоком - некоторые действия делать не следует
		loginfCheckOnetimePass  = 0x0004,  // @v11.1.9 Авторизация по одноразовому пропуску
		loginfAllowAuthAsJobSrv = 0x0008,  // @v11.2.0 Флаг используется специальным образом во-вне функции Login
	};
	int    Login(const char * pDbSymb, const char * pUserName, const char * pPassword, long flags);
	int    Logout();
	//
	// Descr: Флаги функции OpenDictionary2
	//
	enum {
		odfDontInitSync = 0x0001 // Не открывать файл синхронизации Sync
	};
	int    OpenDictionary2(DbLoginBlock * pBlk, long flags);
	int    SetPath(PPID pathID, const char * pBuf, short flags, int replace);
	int    GetPath(PPID pathID, SString & rBuf);
	//
	// Descr: Возвращает максимальный размер файла журнала в Kb.
	//
	long   GetMaxLogFileSize() const;
	//
	// Descr: Возвращает информацию о зарезервированном файле с идентификатором fileId.
	//
	int    GetRFileInfo(PPID fileId, PPRFile & rInfo);
	//
	// Descr: Возвращает енумератор для перечисления зарезервированных файлов.
	//
	SEnum::Imp * EnumRFileInfo();
	int    SetLocation(PPID locID, int notInteractive = 0);
	void   SetOperDate(LDATE);
	void   SetCurCashNodeID(PPID);
	void   SetDefBillCashID(PPID);
	void   SetMenu(short);
	int    SetDemoMode(int);
	long   SetLCfgFlags(long);
	short  SetRealizeOrder(short);
	int    SetMainOrgID(PPID mainOrgID, int enforce);
	//
	// Descr: Устанавливает или снимает биты поля флагов ExtFlags.
	// ARG(f   IN): параметр, содержащие битовые флаги, которые необходимо установить или сбросить.
	//   ВСЕ БИТЫ, которые установлены в f будут, в зависимости от аргументы set, установлены или сброшены в ExtFlags.
	// ARG(set IN): параметр определяющий следует ли установить (set > 0) или сбросить (set == 0)
	//   биты ExtFlags маска которых задана аргументом f.
	// Returns:
	//   Значение ExtFlags предшествующее вызову SetExtFlags()
	// Note:
	//   Поле ExtFlags защищено критической секцией, применяемой в функциях SetExtFlags и CheckExtFlags.
	//   Не следует модифицировать или проверять значения 'того поля в обход этих функций.
	//
	long   SetExtFlag(long f, int set);
	bool   FASTCALL CheckExtFlag(long) const;
	void   SetStateFlag(long, int set);
	bool   CheckStateFlag(long) const;
	ObjCache * FASTCALL GetDbLocalObjCache(PPID objType);
	int    SetDbLocalObjCache(ObjCache * pCache);
	int    DirtyDbCache(long dbPathID, /*int64 * pAdvQueueMarker*/PPAdviseEventQueue::Client * pCli);
	int    SetDbCacheDeferredState(long dbPathID, int set);
	int    FASTCALL IsDbCacheDeferredState(long dbPathID);
	PPAdviseEventQueue * GetAdviseEventQueue(PPAdviseEventQueue::Client * pCli);
	//
	// Descr: устанавливает флаг проверки остатков по счетам в соответствии с параметром и возвращает
	//   предыдущее значение. Если параметр (< 0), то просто возвращает текущее значение
	//
	int    RestCheckingStatus(int = -1);
	int    FetchConfig(PPID obj, PPID objID, PPConfig * pCfg);
	const  PPConfig & LCfg() const { return GetConstTLA().Lc; }
	const  PPCommConfig & CCfg() const { return GetConstTLA().Cc; }
	//
	// Descr: Извлекает через кэш конфигурацию глобального обмена PPAlbatrossConfig.
	// ARG(pCfg INOUT): Если pCfg != 0, то извлекает через кэш конфигурацию. Если pCfg == 0,
	//   то удаляет кэш конфигурации (dirty).
	//
	int    FetchAlbatrosConfig(PPAlbatrossConfig * pCfg); // @cs
	//
	// Really const function: don't modify result object
	//
	const  PPVersionInfo & GetVersionInfo() const { return Ver; }
	SVerT  GetVersion() const;
	//
	// Descr: Возвращает номер версии системы, минимально допустимый для совместимости
	//   на уровне сериализации бинарных объектов данных.
	//   Это значение важно для синхронизации данных между разделами и для правильного
	//   извлечения версий удаленных и изменненных объектов данных из таблицы ObjVer
	//
	SVerT  GetMinCompatVersion() const;
	PPSync & GetSync();
	int    LogAction(PPID action, PPID obj, PPID id, long extData, int use_ta);
	int    GetMachineID(MACAddr * pMachineID, int forceUpdate);
	GtaJournalCore * GetGtaJ();
	void   ProcessIdle();
	int    Advise(long * pCookie, const PPAdviseBlock * pBlk);
	int    Unadvise(long cookie);
	int    GetAdviseList(int kind, PPID objType, PPAdviseList & rList);
	//
	// Descr: Получает револьверный экземпляр PPStringSetSCD для использования в кэшах
	//   (для ускорения работы путем обхода необходимости в динамическом выделении памяти).
	//
	StringSet & AcquireRvlSsSCD();
	int    GetObjectTitle(PPID objType, SString & rBuf);
	PPID   GetObjectTypeBySymb(const char * pSymb, long * pExtraParam);
	int    GetObjectTypeSymb(PPID objType, SString & rBuf);
	//
	// Descr: Устанавливает имя файла, в котором будут дублироваться все сообщения, //
	//   заносимые в любой из журналов.
	// ARG(pFileName IN): @#{vptr0} Если pFileName != 0, то это должно быть имя файла, возможно
	//   не существующего, но обязательно доступное для создания/записи. После вызова
	//   этой функции, все вызовы PPLogMessage() будут дублировать сообщения в этот файл.
	//   Вызов с параметром pFileName = 0 останавливает дублирование записи.
	//
	void   SetTempLogFileName(const char * pFileName);
	int    SetPrivateBasket(PPBasketPacket * pPack, int use_ta);
	PPBasketPacket * GetPrivateBasket();
	PPJobSrvClient * GetClientSession(bool dontReconnect);
	int    SetThreadSock(int32 uniqueSessID, TcpSocket & rSock, PPJobSrvReply * pReply);
	//
	// Функции профилирования //
	//
	// Descr: Фиксирует начало профилирования участка кода файла pFileName строки lineNo.
	// Note: использует глобальный объект PPSession::GPrf
	//
	void   GProfileStart(const char * pFileName, long lineNo, const char * pAddedInfo = 0);
	//
	// Descr: Фиксирует завершение профилирования участка кода файла pFileName строки lineNo.
	// Note: испольует глобальный объект PPSession::GPrf
	//
	void   GProfileFinish(const char * pFileName, long lineNo);
	//
	// Descr: Структура регистрации сессии в системном реестре
	//
	struct RegSessData { // @persistent
		RegSessData();

		enum {
			fExtraUUID = 0x0001 // Структура получена по внешнему UUID (не связанному с регистрацией сессий в локальном реестре)
		};
		S_GUID Uuid; // Поле включается в реестр Windows как ключ параметра
		//
		// В значение параметра вносятся данные, начиная со следующего поля //
		//
		uint32 ReserveStart; // @anchor
		LDATETIME InitTime;
		SVerT  Ver;
		long   Flags;
		uint8  Reserve[28];
	};
	//
	// Функции регистрации сессий в системном реестре
	//
	int    Register();
	int    Unregister();
	int    GetRegisteredSess(const S_GUID & rUuid, PPSession::RegSessData * pData);
	const  SrSyntaxRuleSet * GetSrSyntaxRuleSet(); // @cs
	const  SrUedContainer_Rt * GetUedContainer(); // @cs // @v11.8.4 @construction 
	int    FASTCALL PushLogMsgToQueue(const PPLogMsgItem & rItem);
	int    Log(const char * pFileName, const char * pStr, long options);
	int    GetStringHistory(const char * pKey, const char * pSubUtf8, long flags, StringSet & rList);
	int    GetStringHistoryRecent(const char * pKey, uint maxItems, StringSet & rList);
	int    AddStringHistory(const char * pKey, const char * pTextUtf8);
	int    SaveStringHistory();
	//
	// Descr: Возвращает >0 если известно что на момент запуска сеанса адрес хоста был доступен.
	//   0 - если известно что на момент запуска сеанса адрес хоста не был доступен.
	//   <0 - ничего сказать нельзя.
	// Note: Функция использует данные сформированные вызовом CheckRemoteHosts(), осуществленным
	//   в начале сеанса по заданному списку имен хостов.
	//
	int    GetHostAvailability(const char * pHost); // @v11.1.2
	int    Stq_GetBlob(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, StyloQBlobInfo & rBi);
	int    Stq_PutBlob(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, StyloQBlobInfo & rBi);
	//
	// Descr: Функция копирует список адресов прослушивания сервера либо в this (dir>0), либо из this во внешний
	//   источник (dir<0).
	// Note: Функция не разделена на set/get для того, чтобы избежать создания отдельного mutex'а.
	//   Используется эта функция пару раз и городить огород смысла нет.
	// Returns:
	//   >0 - скопирован по крайней мере один элемен
	//   <0 - nothing to do
	//    0 - error
	//
	int    TransferIpServerListeningList(int kind/* 1 - papyrus, 2 - nginx */, int dir/* >0 - set, <0 - get*/, TSCollection <IpServerListeningEntry> & rList);
	bool   RunNginxServerThread(bool forceReboot);
	const  TWhatmanToolArray & GetVectorTools() const { return DvToolList_; } // @v11.9.2
	SPaintToolBox & GetUiToolBox() { return UiToolBox_; } // @v11.9.2
private:
	int    Helper_SetPath(int pathId, SString & rPath);
	int    MakeMachineID(MACAddr * pMachineID);
	int    CheckLicense(MACAddr * pMachineID, int * pIsDemo);
	int    SetupConfigByOps();
	//
	// Descr: Возвращает путь для локальных по отношению к данному компьютеру данных.
	//   Сейчас этот подкаталог с именем, совпадающим с именем комьпютера, в каталоге BIN.
	//   Путь формируется в кодировке ANSI.
	//
	int    GetLocalPath(SString & rBuf);
	DlContext * Helper_GetInterfaceContext(DlContext ** ppCtx, uint fileId, int crit);
	int    SetExtFlagByIniIntParam(PPIniFile & rIniFile, uint sect, uint param, long extFlags, int reqValue);
	void   FASTCALL MoveCommonPathOnInitThread(long pathID);
	int    InitExtCfgDb();
	void   CheckRemoteHosts(const StringSet & rHostList); // @v11.1.2
	//
	// query:
	//   -1 - request availability
	//    1 = set availability
	//    0 = set unavailability
	//
	int    Helper_Process_HostAvailability_Query(const char * pHost, int query);

	struct ObjIdentBlock {
		ObjIdentBlock();
		StrAssocArray TitleList;
		const SymbHashTable * P_ShT;
	};

	long   TlsIdx;         // Ид локальной области потока    //
	long   Id;
	ACount LastThread;
	ACount DllRef;         // Счетчик активных клиентов для DLL-сервера
	long   MaxLogFileSize; // Максимальный размер файлов журналов в Kb. По умолчанию - 32768.
	PPVersionInfo Ver;
	SString BinPath;       // @*PPSession::Init()
	PPPaths CommonPaths;
	StringSet AvailableHostList; // @v11.1.2
	StringSet UnavailableHostList; // @v11.1.2
	PPDriveMapping DrvMap;
	ObjIdentBlock * P_ObjIdentBlk;
	PPLogMsgQueue * P_LogQueue;
	// Следущие 2 поля заведены для нужд авто-мониторинга
	TSCollection <IpServerListeningEntry> SleList_Nginx; // @v11.9.1 Адреса прослушивания серверного потока nginx
	TSCollection <IpServerListeningEntry> SleList_Server; // @v11.9.1 Адреса прослушивания серверного потока Papyrus (по факту - не более одного)
	//
	enum {
		stSrStxInvalid = 0x0001 // Флаг, сигнализирующий о том, что при первой попытке инициализировать
			// экземпляр P_SrStxSet выяснилось, что либо нет соответствующего файла, либо он инвалиден.
			// Соответственно, последующие попытки будут автоматом возвращать 0.
	};
	long   State;
	long   ExtFlags_;      // ECF_XXX
	mutable SMtLock ExtFlagsLck;   // Блокировка доступа к ExtFlags
	SMtLock ExtCfgDbLock;  // Блокировка доступа к P_ExtCfgDb
	//
	DbLocalCacheMng CMng;  // Менеджер локальных по отношению к базе данных объектных кэшей
	PPAdviseList AdvList;  // Подписка на извещения о событиях.
	DlContext * P_DbCtx;   // Контекст структуры базы данных. Контекст глобальный (не привязан к потокам)
	PPAlbatrossConfig * P_AlbatrosCfg; // Кэшированная конфигурация глобального обмена
		// Единственная точка прямого доступа к этому указателю - FetchAlbatrosConfig()
	SrSyntaxRuleSet * P_SrStxSet;      // Глобально доступный скомпилированный набор синтаксических правил
		// Единственная точка прямого доступа к этому указателю - PPSession::GetSrSyntaxRuleSet()
	SrUedContainer_Rt * P_UedC; // @v11.8.4 @construction Глобально доступный экземпляр для работы с коллекцией объектов UED
	Profile GPrf; // Глобальный профайлер для всей сессии. Кроме него в каждом потоке есть собственный профайлер PPThreadLocalArea::Prf
	PPConfigDatabase * P_ExtCfgDb; // Экспериментальный вариант экземпляра дополнительной конфигурационной базы данных
	TWhatmanToolArray DvToolList_; // @v11.9.2 (moved from the class TProgram) Векторные изображения, загружаемые из внешнего файла 
	SPaintToolBox UiToolBox_;      // @v11.9.2 (moved from the class TProgram) Набор инструментов для отрисовки компонентов пользовательского интерфейса.

	class ThreadCollection : private TSCollection <PPThread> {
	public:
		ThreadCollection();
		int    FASTCALL Add(const PPThread * pThread);
		int    FASTCALL Remove(ThreadID id);
		//
		// ARG(id   IN): Идентификатор потока, для которого передается сообщение
		// ARG(kind IN):
		//   0 - устанавливает PPThread::Text
		//   1 - устанавливает PPThread::LastMsg
		// ARG(pMsg IN): @#{vptr0} Указатель на текст сообщения.
		//
		int    STDCALL  SetMessage(ThreadID id, int kind, const char * pMsg);
		uint   GetCount();
		int    STDCALL  GetInfoList(int type, TSCollection <PPThread::Info> & rList);
		int    STDCALL  GetInfo(ThreadID tId, PPThread::Info & rInfo);
		void   FASTCALL LocStkToStr(SString & rBuf);
		int    FASTCALL StopThread(ThreadID tId);
		//
		// Descr: "Грубо" останавливает поток с идентификатором tId
		//
		int    FASTCALL AbortThread(ThreadID tId);
		PPThread * FASTCALL SearchById(ThreadID tId);
		PPThread * FASTCALL SearchBySessId(int32 sessId);
		//
		// Descr: Ищет поток вида kind с сигнатурой pSignature.
		//   Если isempty(pSignature), то ищет первый свободный (статус SlThread::stIdle) поток, не имеющий сигнатуры.
		//   Если !isempty(pSignature), то ищет поток с заданной сигнатурой.
		//   Если поток с заданной сигнатурой не найден, то ищет первый поток, имеющий
		//   пустую сигнатуру и имеющий статус SlThread::stIdle.
		// Returns:
		//   !0 - указатель на поток, отвечающий перечисленным выше критериям
		//    0 - поток по заданаым критериям не найден.
		//
		PPThread * STDCALL  SearchByOuterSignature(int kind, const char * pSignature, const SBinaryChunk & rSvcIdent);
		//
		// Descr: Находит первый попавшийся поток вида kind, имеющий статус SlThread::stIdle.
		//
		PPThread * FASTCALL SearchIdle(int kind);
		//
		// Descr: Возвращает количество потоков вида kind
		//
		uint   FASTCALL GetCount(int kind);
		int    STDCALL  GetListByKind(int kind, LongArray & rList);
	private:
		ReadWriteLock RwL;
	};
	ThreadCollection ThreadList; // Список потоков. Конструктор снимает флаг aryEachItem с этого экземпляра поскольку он не владеет указателями на потоки.

	class StyloQ_Cache {
	public:
		StyloQ_Cache();
		~StyloQ_Cache();
		int    GetBlob(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, StyloQBlobInfo & rBi);
		int    PutBlob(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, const StyloQBlobInfo & rBi);
	private:
		struct SvcEntry : public SStrGroup {
			struct BlobInnerEntry {
				PPObjID Oid;        // @firstmember
				uint   BlobN;       // [0..] Номер BLOB'а в "обойме" объекта Oid
				SFileFormat Ff;     // Идентификатор формата данных
				uint   SignatureP;  // Сигнатура, используемая для идентификации BLOB'а сервисами и клиентами Stylo-Q
			};
			SBinaryChunk OwnIdent;
			TSVector <BlobInnerEntry> BlobList; // Отсортирован по Oid
		};
		TSCollection <SvcEntry> L;
		ReadWriteLock RwL; // Блокировка списка L
	};

	StyloQ_Cache StQCache; // @v11.4.5
};

extern PPSession DS;

#ifdef LOCAL_PPERRCODE
	extern int PPErrCode;
#else
	#define PPErrCode (DS.GetTLA().LastErr)
#endif
#define LConfig   (DS.LCfg())
#define CConfig   (DS.CCfg())
#define CrwError  (DS.GetTLA().LastCrwErr)
#define BillObj   (DS.GetTLA().P_BObj)
#define PPRef     (DS.GetTLA().P_Ref)
#define PPMaster  (DS.LCfg().State & CFGST_MASTER)
#define ObjRts    (DS.GetConstTLA().Rights)
// @v12.2.8 #define CS_SERVER (DS.CheckExtFlag(ECF_SYSSERVICE))
// @v10.1.4 #define CS_CLIENT (DS.CheckExtFlag(ECF_CLIENT))

void   PPSaveErrContext();
void   PPRestoreErrContext();
int    FASTCALL dbl_cmp(double, double);
//
// Descr: Набор точек входа в базы данных.
//   Описание точек входа в БД хранится в файле BIN\PP.INI в разделе [dbname]
//   В наборе одна из точек входа может быть активной (текущей). Эта характеристика
//   используется при выборе базы данных в диалогах и т.д.
//
class PPDbEntrySet2 : public DbLoginBlockArray {
public:
	PPDbEntrySet2();
	//
	// Descr: Считывает набор точек входа в БД из ini-файла pIniFile.
	// ARG(pIniFile IN): @#{vptr0} INI-файл, из которого следует считать данные.
	//   Если pInitFile == 0, то функция открывает файл BIN\PP_INI и считывает
	//   данные из него.
	// ARG(existsPathOnly  IN): Если этот параметр !0, то точки входа, каталоги
	//   хранения данных для которых не найдены, не считываются.
	// ARG(dontLoadDefDict IN): Если !0, то не в точку входа не загружается путь к словарю по умолчанию.
	//   Этот параметр используется при редактировании списка точек входа в базы данных
	//
	int    ReadFromProfile(PPIniFile * pIniFile, int existsPathOnly = 1, int dontLoadDefDict = 0);
	int    RegisterEntry(PPIniFile * pIniFile, const DbLoginBlock * pBlk);
	long   SetDefaultSelection();
private:
	int    MakeProfileLine(const DbLoginBlock * pBlk, SString & rBuf) const;
	int    ParseProfileLine(const char * pLine, DbLoginBlock * pBlk) const;
};
//
//
//
enum PPDbTransactionUsage {
	pputSmart = -1,
	pputYes = 1,
	pputNo = 0
};
//
// Пример использования следующих трех функций:
// int proc(int use_ta)
// {
//     int ok = 1, ta = 0;
//	   THROW(PPStartTransaction(&ta, use_ta));
//     .
//     .
//     .
//     THROW(PPCommitWork(&ta));
//     CATCH
//         PPRollbackWork(&ta);
//         ok = 0;
//     ENDCATCH
//     return ok;
// }
//
int    FASTCALL PPStartTransaction(int * ta, int use_ta);
int    FASTCALL PPCommitWork(int * ta);
int    FASTCALL PPRollbackWork(int * ta);

enum PPDbDependTransaction {
	ppDbDependTransaction = 1
};

class PPTransaction {
public:
	//
	// Descr: Конструктор вызывает Start(dbDepended, use_ta)
	//
	PPTransaction(PPDbDependTransaction dbDepend, int use_ta);
	PPTransaction(int use_ta);
	~PPTransaction();
	int    operator !();
	//
	// Descr: Запускает транзакцию в зависимости от параметров dbDepended и use_ta.
	// Returns:
	//   >0 - транзакция была успешно запущена этой функцией
	//   <0 - транзакция до вызова функции уже запущена внутри этого экземпляра, либо условия {dbDepended, use_ta}
	//      и состояние менеджера базы данных не требуют запуска транзакции.
	//   0  - ошибка. Может быть связана либо с текущим состоянием экземлпяра (Err != 0), либо
	//      возникла в процессе запуска транзакции.
	//
	int    Start(int use_ta);
	int    Start(PPDbDependTransaction dbDepend, int use_ta);
	int    Commit();
	int    Rollback();
private:
	int    Ta;
	int    Err;
};
//
// Descr: Ищет запись в таблице pTbl по идентификатору id.
//   Полагает, что первый (0) индекс подходит для этой цели. В случае успешного поиска
//   найденная запись копируется по адресу pBuf
//   Параметр objType необходим только для инициализации информации об
//   объекте, который не найден, для сообщения об ошибке.
// Returns:
//   <0 - запись не найдена
//   >0 - запись найдена
//   0  - ошибка
//
int    STDCALL  SearchByID(DBTable * pTbl, PPID objType, PPID id, void * pBuf);
int    STDCALL  SearchByID_ForUpdate(DBTable * pTbl, PPID objType, PPID id, void * pBuf);
int    STDCALL  SearchByKey(DBTable * pTbl, int idx, void * pKey, void * pData);
int    STDCALL  SearchByKey_ForUpdate(DBTable * pTbl, int idx, void * pKey, void * pData);
int    PPSetDbRecordByKey(DBTable * pTbl, int idx, void * pKey, const void * pData, int use_ta);
//
// Descr: Функцию следует использовать только в очень редких случаях.
//
int    STDCALL  AdjustNewObjID(DBTable * pTbl, PPID objType, void * b);
int    STDCALL  AddByID(DBTable *, PPID *, void *, int use_ta);
int    STDCALL  AddObjRecByID(DBTable * pTbl, PPID objType, PPID * pID, void * b, int use_ta);
//
// Descr: Изменяет запись таблицы pTbl, найдя ее по идентификатору objID.
// ARG(pTbl    IN): @#{vptr} Указатель на экземпляр таблицы, в которой неободимо изменить запись.
// ARG(objType IN): Опциональный тип объекта. Используется для вывода сообщения об
//   ошибке, если запись по идентификатору objID не найдена.
// ARG(objID   IN): Идентификатор записи, которую необходимо изменить.
// ARG(pRec    IN): @#{vptr} Указатель на буфер записи, который должен заместить
//   существующую запись.
// ARG(use_ta  IN): Если !0 то операция выполняется в рамках собственной транзакции.
// Returns:
//   >0 - запись изменена успешно
//   0  - ошибка.
//
int    STDCALL  UpdateByID(DBTable * pTbl, PPID objType, PPID objID, const void * pRec, int use_ta);
//
// Descr: Изменяет запись таблицы pTbl, найдя ее по идентификатору objID. Отличается от
//   функции UpdateByID тем, что перед изменением сравнивает найденную запись в базе данных
//   с записью pRec и, если они равны, то не осуществляет изменения и возвращает -1.
//   Сравнение реализуется функцией BNFieldList::IsEqualRecords().
// ARG(pTbl    IN): @#{vptr} Указатель на экземпляр таблицы, в которой неободимо изменить запись.
// ARG(objType IN): Опциональный тип объекта. Используется для вывода сообщения об
//   ошибке, если запись по идентификатору objID не найдена.
// ARG(objID   IN): Идентификатор записи, которую необходимо изменить.
// ARG(pRec    IN): @#{vptr} Указатель на буфер записи, который должен заместить
//   существующую запись.
// ARG(use_ta  IN): Если !0 то операция выполняется в рамках собственной транзакции.
// Returns:
//   >0 - запись изменена успешно
//   <0 - запись не была изменена поскольку pRec не отличается от записи в базе данных.
//   0  - ошибка.
//
int    STDCALL  UpdateByID_Cmp(DBTable * pTbl, PPID objType, PPID id, void * pRec, int use_ta);
int    STDCALL  RemoveByID(DBTable *, PPID objID, int use_ta);
//
// Descr: находит первый доступный номер для члена oprno ключа вида
//   { LDATE date; long oprno; } за дату date. Параметр idx указывает номер индекса
//   в таблице pTbl. Используется функция DBTable::searchKey, поэтому на установку
//   позиции и заполнение буфера данных расчитывать нельзя.
//
int    STDCALL  IncDateKey(DBTable * pTbl, int idx, LDATE dt, long * pOprno);
inline int IncDateKey(DBTable * pTbl, int idx, LDATE dt, int * pOprno) { return IncDateKey(pTbl, idx, dt, reinterpret_cast<long *>(pOprno)); }
int    FASTCALL CheckTblPtr(const DBTable *);
int    FASTCALL CheckQueryPtr(const DBQuery *);
TempOrderTbl * CreateTempOrderFile();

DBQ  & FASTCALL ppidlist(DBItem &, const PPIDArray *);
DBQ  * STDCALL  ppcheckfiltid(DBQ *, DBItem &, PPID);
DBQ  * STDCALL  ppcheckfiltidlist(DBQ *, DBItem &, const PPIDArray *);
//
// Descr: Добавляет к ограничению pDbq терм запроса, содержащий утверждение относительно
//   значения флага rItem. Если терм добавляется, то в конец выражения со связкой AND.
// ARG(pDbq  IN): Выражение ограничения, которому необходимо добавить терм
// ARG(rItem IN): Поле или выражение, к которому применяется проверка флага
// ARG(mask  IN): Значение маски флага, на которую проверяется выражение rItem
// ARG(test  IN): Параметр, определяющий способ сравнения выражения rItem с маской mask
//   >0 - Значение поля rItem проверяется на наличие флага mask:    (rItem & mask) == mask
//   <0 - Значение поля rItem проверяется на отсутствие флага mask: (rItem & mask) == 0
//   0  - Значение поля не проверяется и функция возвращает оригинальное выражение pDbq
// Returns:
//   Возможно модифицированное значение pDbq.
//
DBQ  * STDCALL  ppcheckflag(DBQ * pDbq, DBItem & rItem, long mask, int test);
DBQ  * STDCALL  ppcheckweekday(DBQ * pDbq, DBItem & rItem, int dayOfWeek);

SString & FASTCALL GetMainOrgName(SString &);
//
// Descr: Присваивает по указателю pID идентификатор текущей главной организации.
//   Если текущая главная организация определена, то возвращает 1, иначе 0.
// Returns:
//   >0 - текущая главная организация определена и присвоена по указателю pID
//    0 - error. По указателю pID присвоен 0.
//
int    FASTCALL GetMainOrgID(PPID * pID);
//
// Descr: Возвращает идентификатор текущей главной организации.
// Returns:
//   <0 - идентификатор текущей главной организации
//   0  - ошибка.
//
PPID   FASTCALL GetMainOrgID();
int    FASTCALL GetMainEmployerID(PPID *);
//
// Descr: Определяет город, в котором находится главная организация.
//   Город определяется по фактическому или (если нет фактического) юридическому
//   адресу главной организации.
// Returns:
//   <0 - не удалось идентифицировать город
//   1  - город идентифицирован по фактическому адресу
//   2  - город идентифицирован по юридическому адресу
//
int    FASTCALL GetMainCityID(PPID * pCityID);
int    GetUserByPerson(PPID psnID, PPID * pUserID);
int    FASTCALL GetLocationName(PPID locID, SString &);
int    SearchDlvrAddr();
int    EditDlvrAddrExtFields(LocationTbl::Rec * pData);
//
// Функция GetExtLocationName отличается от GetLocationName тем,
// что при locID == 0 копирует в буфер строку "Все объекты"
//
int    FASTCALL GetExtLocationName(PPID locID, SString &);
//
// Descr: Заносит в буфер rBuf наименования складов из списка rLocList.
// ARG(rLocList IN): список идентификаторов складов. Если rLocList.IsEmpty(), то
//   в буфер rBuf заносится строка "Все склады"
// ARG(maxItems IN): максимальное количество складов из списка, чьи наименовани
//   необходимо занести в буфер rBuf. Если список rLocList содержит более maxItems
//   элементов, то после наименования последнего склада ставится разделить ';' и
//   две точки '..'. Если maxItems == 0, то список не ограничивается.
// ARG(rBuf    OUT): Буфер, в который заносятся наименования складов. Наименования //
//   разделяются символами '; '. Кодировка символов в буфере - OEM.
// Returns: ссылку на буфер rBuf
//
SString & GetExtLocationName(const ObjIdListFilt & rLocList, size_t maxItems, SString & rBuf);
//
// Descr: Копирует в буфер rBuf имя текущего пользователя. Имя извлекается из
//   из локальной по отношению потоку переменной.
//   Обращений к базе данных при этом не происходит.
//   Глобальное состояние системы никак не меняется.
//
SString & FASTCALL GetCurUserName(SString & rBuf);
int    FASTCALL GetPersonName(PPID id, SString & rBuf);
int    FASTCALL GetGoodsNameR(PPID goodsID, SString & rBuf);
SString & FASTCALL GetGoodsName(PPID goodsID, SString & rBuf);
int    FASTCALL GetAcctName(const Acct *, PPID curID, long fmt, SString & rBuf);
int    FASTCALL GetAcctIDName(const AcctID & rAci, long fmt, SString & rBuf);
int    FASTCALL GetArticleName(PPID arID, SString & rBuf);
int    FASTCALL GetArticleSheetID(PPID arID, PPID * pAccSheetID, PPID * pLnkObjID = 0);
int    FASTCALL GetRegisterTypeName(PPID rtID, SString & rBuf);

enum PPArticleType {
	artypUnknown = 0,
	artypSuppl,
	artypBuyer,
	artypPayer,
	artypCntragnt
};

int    GetArticleText(PPID, PPArticleType, SString & rBuf);
int    AccIDToAcct(PPID id, int ord, Acct *);
int    IsAccBelongToList(const Acct *, int side, const char * pList);
//
// Descr: конвертирует ид аналитической статьи в
//   ид персоналии, на которую эта статья ссылается. Если статья   //
//   ссылается не на персоналию, либо вообще не ссылается ни на
//   какой иной объект, то возвращает 0.
//
PPID   FASTCALL ObjectToPerson(PPID articleID, PPID * pAccSheetID = 0);
//
// Descr: Округляет значение v с точностью prec в направлении dir.
// ARG(v    IN): Значение, которое необходимо округлить
// ARG(prec IN): Точность округления. Например: 1.0 - до целых, 0.01 - два знака после точки, 50.0 - с точностью до 50
//   Если prec == 0.0, то принимается значение по умолчанию (0.01)
// ARG(dir  IN): Направление округления: <0 - до ближайшего меньшего, >0 - до ближайшего большего, 0 - просто до ближайшего по бухгалтерскому правилу.
// Returns:
//   Округленное значение.
//
double PPRound(double v, double prec, int dir);
//
// Descr: return (!flt || flt == id)
// Note: Провел небольшое исследование насчет inline-варианта этой функции.
//   Вывод такой: суммарный код с учетом вызовов становится чуть больше.
//     Выигрыш в производительности точно будет за inline-вариантом, но с моей точки зрения он не дотягивает
//     по весу что бы делать эту функцию инлайновой (fastcall'а достаточно).
//
int    FASTCALL CheckFiltID(PPID flt, PPID id);
//
// Descr: Класс, унаследованный от STokenRecognizer с целью реализации дополнительного функционала. В частности,
//  проверки на номер телефона с помощью SLibPhoneNumber (libphonenumber).
//
class PPTokenRecognizer : public STokenRecognizer {
public:
	PPTokenRecognizer();
private:
	virtual int PostImplement(ImplementBlock & rIb, const uchar * pToken, int len, SNaturalTokenArray & rResultList, SNaturalTokenStat * pStat);
#if(_MSC_VER >= 1900)
	SLibPhoneNumber PhnL;
#endif
};
//
//
//
class PPExtStringStorage {
public:
	PPExtStringStorage();
	int    Put(SString & rLine, int fldID, const char * pBuf);
	int    Put(SString & rLine, int fldID, const SString & rBuf);
	//
	// Descr: Извлекает из пула-хранилища rLine строку с идентификатором fldID и
	//   присваивает ее буферу rBuf.
	// Note: буфер rBuf предварительно очищается функцией.
	// Returns:
	//    >0 - строка с идентификатором fldID найдена в пуле и присвоена буферу rBuf
	//     0 - строка с идентификатором fldID не найдена в пуле
	//    -2 - пул rLine пуст или же в нем нет ни одного тега (плоская строка)
	//
	int    Get(const SString & rLine, int fldID, SString & rBuf);
	int    Enum(const SString & rLine, uint * pPos, int * pFldID, SString & rBuf);
private:
	int    Excise(SString & rLine, int fldID);
	const SRegExp2 Re;
};
//
// Descr: Извлекает из пула-хранилища строк rLine строку с идентификатором fldID и присваивает
//   ее буферу rBuf.
// Note: буфер rBuf предварительно очищается функцией.
// Returns:
//   >0 - строка с идентификатором fldID найдена в пуле и присвоена буферу rBuf
//    0 - строка с идентификатором fldID не найдена в пуле
//   -2 - пул rLine пуст или же в нем нет ни одного тега (плоская строка)
//
int    STDCALL PPGetExtStrData(int fldID, const SString & rLine, SString & rBuf);
//
// Descr: Извлекает из пула-хранилища строк rLine строку с идентификатором fldID и присваивает
//   ее буферу rBuf. Если в пуле строка с идентификатором fldID не найдена, но пул не
//   содержит ни одного формального тега (плоская строка) и defFldID == fldID, то
//   функция считает, что вся строка преставляет искомую и возвращает ее в rBuf
//   (функция используется для обеспечения обратной совместимости для некоторых типов объектов данных).
// Note: буфер rBuf предварительно очищается функцией.
// Returns:
//   >0 - строка с идентификатором fldID найдена в пуле и присвоена буферу rBuf
//    0 - строка с идентификатором fldID не найдена в пуле
//   -2 - пул rLine пуст или же в нем нет ни одного тега (плоская строка)
//
int    STDCALL PPGetExtStrData_def(int fldID, int defFldID, const SString & rLine, SString & rBuf);
//
// Descr: Сравнивает значения тегированных подстрок с идентификатором fldID в строке rLine1 и rLine2.
// ARG(fldID   IN): Идентификатор тега подстроки
// ARG(rLine1  IN): Первая строка, содержащая тегированную подстроку
// ARG(rLine2  IN): Вторая строка, содержащая тегированную подстроку
// ARG(options IN): Опции сравнения. Если установлен флаг srchNoCase (0x0200 slib.h)
//   то сравнение осуществляется без учета регистра символов.
// Returns:
//   0 - строки эквивалентны
//  <0 - строка из rLine1 лексикографически меньше, чем из rLine2
//  >0 - строка из rLine1 лексикографически больше, чем из rLine2
//
int    STDCALL PPCmpExtStrData(int fldID, const SString & rLine1, const SString & rLine2, long options);
int    STDCALL PPPutExtStrData(int fldID, SString & rLine, const char * pBuf);
int    STDCALL PPPutExtStrData(int fldID, SString & rLine, const SString & rBuf);
//
// Descr: преобразует период *pPeriod в пересечение с периодом документов, определенным в правах
//   пользователя. Если результат является пустым, то возвращает 0 и устанавливает код ошибки (PPERR_NORTPERIOD).
//
int    FASTCALL AdjustPeriodToRights(DateRange & rPeriod, int checkOnly);
int    FASTCALL CalcBarcodeCheckDigit(const char * pBarcode);
char * FASTCALL AddBarcodeCheckDigit(char * pBarcode);
SString & FASTCALL AddBarcodeCheckDigit(SString & rBarcode);
//
// Descr: Формирует строку штрихкода, пригодную для печати на обычном принтере
//   с использованием специализированных шрифтов.
// ARG(pBarcode IN): Символьная строка, содержащая штрихкод в формате, непосредственно редактируемом пользователем.
//   Функция принимает не более 63 символов из этого буфера.
// ARG(codeType IN): Тип кода.
//   0  - один из розничных штрихкодов (EAN13, EAN8, UPC-A, UPC-E). Исходя из длины кода pBarcode и символов, из
//        которых он состоит функция автоматически идентифицирует к какому из этих четырех типов принадлежит штрихкод.
//   39 - Code39. Этот код может содержать произвольное количество символов, включающих цифры и латинские заглавные буквы.
// ARG(pBuf    OUT): Указатель на буфер, в который функция запишет печатаемую версию штрихкода.
// ARG(bufLen   IN): Длина буфера pBuf. Функция не допускает переполнения буфера, если этот параметр не нулевой.
// Returns:
//   >0 - функция успешно конвертировала штрихкод
//   0  - ошибка. Переданный штрихкод не удовлетворяет ограничениям, накладываемым на заданный тип штрихкода.
//
int    CreatePrintableBarcode(const char * pBarcode, int codeType, char * pBuf, size_t bufLen);
//int    CreateBarcodeImage(const char * pBarcode, int codeType, int outpFormat, const char * pFileName);

class PPBarcode {
public:
	struct Entry {
		int    BcStd;
		SString Code;
	};
	struct BarcodeImageParam {
		BarcodeImageParam();
		enum {
			fWithCheckDigit = 0x0001 // Код содержит контрольную цифру
		};
		int   Std;               // BARCSTD_XXX Стандарт штрихкода
		long  Flags;
		int   OutputFormat;      // Формат вывода изображения:
			// 0 - в буфер Buffer, SFileFormat::Png, SFileFormat::Svg, SFileFormat::Gif, SFileFormat::Bmp
			// Остальные значения считаются инвалидными.
		int   Angle;             // Угол поворота изображения. Допустимы следующие значения: 0, 90, 180, 270
		int   Margin;            // @v11.9.2 Поля вокруг изображения штрихкода (в пикселях)
		SPoint2S Size;           // Размеры изображения в пикселах. Если 0, то используются размеры по умолчанию.
		SColor ColorFg;          // Цвет штрихов. Если ColorFg == ZEROCOLOR, то - черный
		SColor ColorBg;          // Цвет фона. Если ColorBg == ZROCOLOR, то - белый
		SString Code;            // Текстовое представление кода, который необходимо отобразить
		SString OutputFileName;  // Если oneof(OutputFormat, SFileFormat::Png, SFileFormat::Svg,
			// SFileFormat::Gif, SFileFormat::Bmp),
			// то изображение формируется в файле с этим именем. Расширение файла форсированно
			// заменяется на каноническое для соответствующего формата.
		SImageBuffer Buffer;     // Если OutputFormat == 0, то изображение формируется в этом буфере
	};
	static int FASTCALL GetStdName(int bcstd, SString & rBuf);
	static int FASTCALL RecognizeStdName(const char * pText);
	static int FASTCALL CreateImage(/*const char * pCode, int bcstd, int outpFormat, const char * pOutpFileName*/BarcodeImageParam & rParam);
	static int FASTCALL RecognizeImage(const char * pInpFileName, TSCollection <PPBarcode::Entry> & rList);
	static int ZXing_RecognizeImage(const char * pInpFileName, TSCollection <PPBarcode::Entry> & rList);
	//
	// Descr: Конвертирует штрихкод в формате UPC-E в формат UPC-A
	// Note: Не проверяет входящий параметр pUpce на корректное представление UPC-E
	//
	static SString & FASTCALL ConvertUpceToUpca(const char * pUpce, SString & rUpca);
};
//
// Символьные обозначения и их транслятор
//
enum {
	PPSYM_NONE = 0,
	PPSYM_LINK,        // @link       Связанный (документ и пр.)
	PPSYM_BILLNO,      // @billno     Номер документа
	PPSYM_DATE,        // @date       Дата
	PPSYM_PAYDATE,     // @paydate    Дата оплаты
	PPSYM_AMOUNT,      // @amount     Номинальная сумма
	PPSYM_LOCATION,    // @loc        Локация //
	PPSYM_OBJECT,      // @obj        Объект
	PPSYM_PAYER,       // @payer      Плательщик
	PPSYM_AGENT,       // @agent      Агент
	PPSYM_REGNAM,      // @regname    Наименование типа регистра
	PPSYM_REGSN,       // @regsn      Серия регистра
	PPSYM_REGNO,       // @regno      Номер регистра
	PPSYM_REGORG,      // @regorg     Регистрирующий орган
	PPSYM_TRADELIC,    // @tradelic   Торговая лицензия //
	PPSYM_BILLMEMO,    // @billmemo   Примечание к документу
	PPSYM_OBJ2INN,     // @v10.7.3 @obj2inn ИНН персоналии, ассоциированной со дополнительной статьей документа
	PPSYM_OBJ2KPP,     // @v10.7.3 @obj2kpp КПП персоналии, ассоциированной со дополнительной статьей документа
	PPSYM_BILLOBJ2,    // @obj2       Дополнит объект по документу
	PPSYM_GC_NAME,     // @gcname     Наименование класса товара
	PPSYM_GC_KIND,     // @gckind     Вид товара
	PPSYM_GC_GRADE,    // @gcgrade    Сорт товара
	PPSYM_GC_ADDPROP,  // @gcaddprop  Доп свойство товара
	PPSYM_GC_DIMX,     // @gcdimx     Размерность X
	PPSYM_GC_DIMY,     // @gcdimy     Размерность Y
	PPSYM_GC_DIMZ,     // @gcdimz     Размерность Z
	PPSYM_ADVLNACC,    // @alacc      Счет из строки расширения бух. документа
	PPSYM_ADVLNAR,     // @alar       Статья из строки расширения бух. документа
	PPSYM_ADVLNAMT,    // @alamt      Сумма из строки расширения бух. документа
	PPSYM_RECKON,      // @rckn       Ссылка на зачетный документ из зачитывающего
	PPSYM_CLIENTADDR,  // @clientaddr Адрес контрагента
	PPSYM_GRNAME,      // @grname     Наименование группы товаров
	PPSYM_PHPERU,      // @phpu       Соотношение физ.ед/торг.ед в товаре
	PPSYM_BRAND,       // @brand      Торговая марка
	PPSYM_CLIENT,      // @client     Наименование клиента
	PPSYM_PARENT,      // .parent     Родительский объект, по отношению к предыдущему терму
	PPSYM_GC_ADD2PROP, // @gcadd2prop Доп 2 свойство товара
	PPSYM_GC_DIMW,     // @gcdimw     Размерность W
	PPSYM_TSESS,       // .tsess      Списываемая этим документом техн сессия //
	PPSYM_PRC,         // @prc        Наименование процессора
	PPSYM_TECH,        // @tech       Код технологической сессии
	PPSYM_MEMO,        // @memo       Примечание
	PPSYM_EXPIRY,      // @expiry     Дата окончания срока действия //
	PPSYM_AGTCODE,     // @agtcode    Номер соглашения с контрагентом
	PPSYM_AGTDATE,     // @agtdate    Дата соглашения с контрагентом
	PPSYM_AGTEXPIRY,   // @agtexpiry  Дата истечения срока действия соглашения с контрагентом
	PPSYM_MODEL,       // @model      (транспорт) Наименование модели
	PPSYM_CODE,        // @code       (транспорт) Регистрационный номер
	PPSYM_SUBCODE,     // @subcode    (транспорт) Регистрационный номер прицепа
	PPSYM_OWNER,       // @owner      (транспорт) Имя владельца
	PPSYM_CAPTAIN,     // @captain    (транспорт) Имя капитана (водителя)
	PPSYM_INVOICEDATE, // @invoicedate Дата счета-фактуры документа
	PPSYM_INVOICENO,   // @invoiceno   Номер счета-фактуры документа
	PPSYM_DLVRLOCCODE, // @dlvrloccode Код адреса доставки документа
	PPSYM_FGDATE,      // @fgdate      Дата в 'плоском' представлении (25032015)
	PPSYM_INN,         // @inn         ИНН персоналии.
	PPSYM_KPP,         // @kpp         КПП персоналии
	PPSYM_LOCCODE,     // @loccode     Код склада/адреса и т.д.
	PPSYM_DLVRLOCID,   // @dlvrlocid   ИД адреса доставки документа
    PPSYM_DUMMY,       // @dummy       Пустое значение
    PPSYM_CSESS,       // .csess       Списываемая этим документом кассовая сессия //
    PPSYM_POSNODE,     // @posnode     Наименование кассового узла
	PPSYM_DLVRLOCTAG,  // @dlvrloctag.tagsymb Символ тега, идентифицирующего адрес доставки
	PPSYM_DUEDATE,     // @duedate Дата исполнения документа
	PPSYM_FGDUEDATE,   // @fgduedate Дата исполнения документа в 'плоском' представлении (25032015)
	PPSYM_OBJINN,      // @objinn ИНН персоналии, ассоциированной со основной статьей документа
	PPSYM_OBJKPP,      // @objkpp КПП персоналии, ассоциированной со основной статьей документа
	PPSYM_CLIENTEXTNAME // @v11.1.10 @CLIENTEXTNAME расширенное наименование персоналии клиента
};
//
class PPSymbTranslator {
public:
	explicit PPSymbTranslator(uint strID = PPSSYM_SYMB);
	bool   operator !() const;
	//
	// Descr: пытается распознать слово по адресу (pString + (*pNextPos))
	//   и, если ей это удается, возвращает опознанный код (константа PPSYM_XXX).
	//   Индекс, на который указывает pNextPos, принимает значение следующего за
	//   распознанным словом символа. В случае неудачи этот индекс также может
	//   сместиться, так как функция самостоятельно пропускает пробелы и
	//   табуляции (' ', '\t'). Если pNextPos == 0, то полагается (*pNextPos == 0).
	//
	long   Translate(const char * pString, size_t * pNextPos, uint flags = 0);
	long   Translate(SStrScan & rScan);
	//
	// Descr: возвращает одну (первую) форму слова, соответствующего символу sym.
	//
	int    Retranslate(long sym, char *, size_t bufLen) const;
	int    Retranslate(long sym, SString & rBuf) const;
private:
	char * NextStr(size_t * pPos, char * pBuf) const;

	int    ErrorCode;
	SString Coll;
};
//
//
//
class OptimalAmountDamper {
public:
    OptimalAmountDamper();
    int    GetOptimal(long & rPos, long * pExtPos, double * pOptQtty, double * pMaxPrice) const;
    int    Probe(double qtty, double price, long pos, long extPos = -1);
private:
    long   Pos;
    long   ExtPos;
    double OptQtty;
    double MaxPrice;
};
//
// Interobject message codes
//
#define DBMSG_OBJDELETE          1
#define DBMSG_OBJUPDATE          2
#define DBMSG_PERSONLOSEKIND     3
#define DBMSG_PERSONACQUIREKIND  4 // Посылается объектом PPOBJ_PERSON в ответ на изменении персоналии для каждого вида, которой персоналия принадлежит.
	// Сообщение посылается целенаправленно объектам PPOBJ_PROCESSOR и PPOBJ_ARTICLE
#define DBMSG_OBJNAMEUPDATE      5
#define DBMSG_COMPUTERACQUIRECAT 6 // @v12.0.1 Посылается объектом PPOBJ_COMPUTER при изменении категории компьютера.
	// Сообщение посылается целенаправленно объекту PPOBJ_PROCESSOR 
#define DBMSG_COMPUTERLOSECAT    7 // @v12.0.1 Посылается объектом PPOBJ_COMPUTER при изменении категории компьютера (для предотвращения появления 'висячего' процессора) 
//
// Запрос на существование ссылок. Если существуют, то DBRPL_REFSFOUNDED иначе DBRPL_OK
// (пока работает лишь для избранных объектов. Полагаться на это сообщение в общем случае не следует).
//
#define DBMSG_CHECKREFS          6
//
// Запрос на существование ограничителей прав доступа. Если объект каким-либо образом
// квалифицирует права доступа, то в ответ на сообщение должен вернуть DBRPL_OK.
// Если объект полностью открыт, то должен вернуть DBRPL_CANCEL. Если объект возвращает
// DBRPL_OK, то он должен вернуть и количество байт, необходимых ему для хранения информации
// о правах. Это значение должно быть присвоено по адресу, передаваемому параметром extra
// функции HandleMsg как size_t.
//
#define DBMSG_SECURITY           7
//
// Извещение о том, что один объект замещается другим. Если объект, получивший это сообщение
// ссылается на замещаемый объект, то он должен либо заменить все ссылки новым идентификатором,
// либо, если не может этого сделать, вернуть код ошибки.
//
#define DBMSG_OBJREPLACE         8
//
// Добавлен склад.
// Частное сообщение, посылаемое объектом PPOBJ_LOCATION объекту
// PPOBJ_ARTICLE при создании нового склада для того, чтобы объект
// PPOBJ_ARTICLE мог создать статью, соответствующую этому складу.
//
#define DBMSG_WAREHOUSEADDED     9
#define DBMSG_DUMMY             10 // Пустое сообщение, необходимое для того, чтобы все объекты данных создали необходимые таблицы в БД.
#define DBMSG_GLOBALACCADDED    11 // Посылается при создании новой глобальной учетной записи
#define DBMSG_PROCESSORADDED    12 // @v11.3.12 Посылается при создании нового процессора
//
// Object message reply codes
//
#define DBRPL_ERROR              0
#define DBRPL_OK                 1
#define DBRPL_CANCEL             2
#define DBRPL_REFSFOUNDED        3
//
// Special object ident substitutes
//
#define ROBJID_CONTEXT           0x08000000L // Реальное значение идентификатора определяется из контекста
//
// Замечание по приоритетам приема данных из других разделов (Priority):
// Приоритет по умолчанию:         1000
// Наивысший применяемый приоритет: 100 (для определений динамических объектов PPOBJ_DYNAMICOBJS)
// Приоритет тегов (PPOBJ_TAG):     120 (теги должны быть приняты до того, как начнут приниматься использующие их объекты)
// Остальные объекты должны выставлять приоритеты не ниже 121. При этом следует иметь в виду, что
// подавляющее большинство объектов будут иметь DefaultPriority (1000).
// Настоятельно рекомендуется использовать значения, кратные 10 для того, чтобы оставались
// зарезервированные "окна", которые можно будет использовать при необходимости.
//
// Приоритет 5000 используется для зависимых объектов, то есть тех, которые не должны
// акцептироваться в базе-приемнике самостоятельно (без объекта, от которого зависят).
//
struct PPObjPack {
	PPObjPack();
	enum {
		fDefinedHeader        = 0x0001, //
		fCreationDtTm         = 0x0002, // Значение Mod является датой/временем создания (но не изменения) объекта
		fUpdate               = 0x0004, // Объект должен быть обновлен в разделе-получателе если его версия старше
		fForceUpdate          = 0x0008, // Объект должен быть безусловно обновлен в разделе-получателе
		fProcessed            = 0x0010, // internal use only
		fDispatcher           = 0x0020, // Раздел, в который принимается объект является диспетчером
		fSyncCmpObj           = 0x0040, // Пакет содержить только информацию о синхронизации
		fNoObj                = 0x0080, // Запись синхронизации виртуального объекта (например, лота)
		fRecover              = 0x0100, // Восстанавливающая передача объектов
		fLateUpdatingDecision = 0x0200  // @v11.3.0 Решение об изменении объекта в разделе-получателе должен принять 
			// управляющий объектом класс на этапе акцепта виртуальной функцией PPObject::Write().
			// Флаг вводится из-за необходимости анализа вложенных компонентов объекта для принятия решения.
	};
	void * Data;                 // Данные пакета. Если (Flags & fSyncCmpObj) то данных нет
	SVerT  SrcVer;               // Версия системы, сформировавшей пакет
	LDATETIME Mod;               // Дата/время модификации объекта в разделе-отправителе
	long   Priority;             // Приоритет обработки объекта при приеме данных
	long   Flags;                // Флаги (PPObjPack::fXXX)
};
//
// Классы семейства PPObject организованы так, что если в некоторый
// момент времени существует несколько объектов одного класса, то они
// используют один экземпляр открытой таблицы данных. Это реализуется //
// либо через глобальный постоянно открытый объект таблицы данных, либо с
// помощью семафора. При этом, функции или классы создающие объекты классов
// семейства PPObject должны позаботиться о том, чтобы своевременно
// уничтожать созданные объекты.
//
// Любой экземпляр класса из семейства PPObject может иметь public-ссылку (или указатель)
// на соответствующую ему таблицу данных для использования извне. Из этого следует, что ни одна
// функция (внутренняя или внешняя по отношению к классу) не может полагаться на то, что позиция
// таблицы данных сохранит свое значение сколько-нибудь продолжительное время.
//
// Функции-члены классов, порожденных от PPObject, должны быть терминальными в смысле обработки
// ошибок. То есть, в случае ошибки, они должны выдавать сообщения. Все вызовы этих
// функций обязаны полагаться на это их свойство.
//
class PPObject {
public:
	//
	// Descr: Создает сигнатуру объекта данных, хранящегося вне базы данных. Сигнатура формируется как текст base32
	//   бинарной конкатенации некоего глобального идентификатора rGlobalIdent, идентификатора объекта данных и 
	//   порядкового номера относительно обеъекта данных (например, в случае если с одним объектом ассоциировано несколько blob'ов)
	//
	static SString & MakeBlobSignature(const SBinaryChunk & rGlobalIdent, PPObjID oid, uint itemNumber, SString & rBuf);
	//
	// Descr: Создает сигнатуру объекта данных, хранящегося вне базы данных. Сигнатура формируется как текст base32
	//   бинарной конкатенации некоего глобального идентификатора rGlobalIdent и текстового представления имени ресурса pResourceName.
	//
	static SString & MakeBlobSignature(const SBinaryChunk & rGlobalIdent, const char * pResourceName, SString & rBuf);
	//
	// Descr: Сигнатура сериализации для объектных пакетов. Вводится начиная с версии @v11.1.12
	//   для обратной совместимости при считывании старых версий пакетов. Важный элемент применения
	//   заключается в том, чтобы можно было отличить пакеты, которые не имеют такой сигнатуры.
	//
	struct SerializeSignature { // @v11.1.12
		//
		// Descr: Конструктор, создающий пустую сигнатуру (S == 0 && V == 0)
		//
		SerializeSignature();
		//
		// Descr: Конструктор, создающий экземпляр с заданным типом объекта objType
		//   и текущим номером версии.
		//
		explicit SerializeSignature(PPID objType);
		//
		// Descr: Комплексный конструктор, реализующий логику препроцессинга
		//   сериализации общего пакета объекта.
		// ARG(objType  IN): Тип объекта данных
		// ARG(dir      IN): Направление сериализации #{-1||+1}
		// ARG(rBuf IN/OUT): Буфер сериализации.
		//
		SerializeSignature(PPID objType, int dir, SBuffer & rBuf);
		bool   IsValid() const;
		//
		// Descr: Пытается считать из буфера rBuf предполагаемую сигнатуру. Если
		//   сигнатура является валидной, то возвращает >0. Если нет, то
		//   откатывает текущую позицию чтения буфера назад и возвращает 0.
		//   В случае неудачи содержимое this обнуляется - то есть становится инвалидным.
		//
		int    Read(SBuffer & rBuf);
		//
		// Descr: Записывает содержимое экземпляра this в буфер сериализации rBuf.
		//   Если содержимое this инвалидно, то в возвращает 0. В отладочном
		//   варианте сборки в этом случае возникает исключение assert.
		// Returns:
		//   >0 - запись осуществлена успешно
		//    0 - error.
		//
		int    Write(SBuffer & rBuf) const;

		uint32 S; // (0xaaaa & ObjType)
		SVerT  V; // Версия Papyrus, создавшая пакет
	};
	static int ReplaceObj(PPID objType, PPID dest, PPID src, uint options /*= user_request*/);
	//
	// Descr: Открывает диалог объединения объектов типа objType.
	//   Если пользователь выбрал объекты для объединения и подтвердил выбор,
	//   то вызывается PPObject::ReplaceObj()
	//
	static int ReplaceObjInteractive(PPID objType, PPID srcID = 0);
	//
	// Descr: Флаги функций MakeReserved и CreateReservedObjects
	//
	enum {
		mrfInitializeDb      = 0x0001, // Функция MakeReserved должна создать объекты для пустой базы данных.
		mrfCreateMqbDefaults = 0x0002  // @v11.0.10 Функция MakeReserved должна по возможности создать зарезервированные объекты для брокера сообщений
	};
	static int CreateReservedObjects(long flags);
	static SString & GetAcceptMsg(PPID objType, PPID objID, int upd, SString & rBuf);
	static int Helper_PutConfig(PPID cfgPropID, PPID cfgObjType, int isNew, const void * pData, size_t sz, int use_ta);
	//
	// Descr: Идентифицирует объект данных по символу типа pObjType и
	//   идентификатору или символу pObjIdent.
	// Note: Функция пока очень не совершенна: умеет идентифицировать только
	//   некоторые типы объектов.
	//
	static int  Identify(const char * pObjType, const char * pObjIdent, PPObjID * pIdent);
	static void FASTCALL SetLastErrObj(PPID objType, PPID objID);
	static int  IndexPhones();
	//
	// Если aObj != 0, то конструктор считывает поля Flags и OprFlags
	// записи прав доступа в поля Rt и ORt. Если при считывании прав
	// доступа произошла ошибка, то происходит Logout и выход из программы.
	// Если конкретный класс семейства PPObject требует дополнительных полей
	// из структуры прав доступа, то он должен их извлечь самостоятельно.
	//
	explicit PPObject(PPID aObj = 0);
	virtual ~PPObject();
	//
	// Descr: Проверяет наличие у текущего пользователя прав, заданных флагами
	//   rt для данного экземпляра объекта данных.
	//   Если в параметре rt задано более одного флага, то функция возвращает
	//   положительный ответ только если все эти права у пользователя есть.
	//
	int    CheckRights(long rt, int oprRights);
	//
	// Descr: == CheckRight(rt, 0)
	//
	int    FASTCALL CheckRights(long rt);
	//
	// Descr: Утилитная функция, текст которой выглядит так:
	//   {return pID ? CheckRights(*pID, PPR_MOD : PPR_INS) : (PPErrCode = PPERR_INVPARAM, 0);}
	//   Используется исключительно для уменьшения размера кода, так как эта конструкция //
	//   очень часто встречается.
	//   Кроме того, эта функция защищает вызывающую функцию от нулевого указателя pID.
	//
	int    FASTCALL CheckRightsModByID(const  PPID * pID);
	int    GetLastModifEvent(PPID objID, LDATETIME *, int * pCr, SysJournalTbl::Rec * = 0);
	//
	// Descr: используя виртуальные функции Search и GetNamePtr находит и возвращает
	//   в буфере pBuf имя объекта с идентификатором id.
	//
	int    GetName(PPID id, char * pBuf, size_t bufLen = 0);
	int    GetName(PPID id, SString  * pBuf);
	//
	// Descr: определяет происходили ли с объектом с момента,
	//   определенного параметрами по указателям dt, tm, события,
	//   перечисленные в списке actions. Если да, то возвращает > 0,
	//   устанавливает указатель retAction в ID события, а значения по
	//   указателям dt, tm в соответствии с моментом события.
	//   Если возвращается (< 0), то такие события не происходили. 0 - error.
	//   Если параметр actions == 0, то засекаются любые события по заданному объекту.
	//
	int    IsLogged(PPID, PPIDArray * actions, LDATE * dt, LTIME * tm, PPID *);
	virtual int    Browse(void * extraPtr);
	//
	// Descr: Функция редактирования нового либо существующего объекта данных.
	//   Если *pID != 0, должна самостоятельно извлечь объект из базы данных и вызывать
	//   диалог редактирования, чтобы пользователь смог изменить то, что ему надо.
	//   Если пользователь подтвердил сделанные изменения, функция должна сохранить
	//   запись объекта в базе данных.
	//   Если *pID == 0, то функция должна самостоятельно инициализировать запись объекта,
	//   возможно, с учетом параметра extraParam. После этого, вызывается диалог редактирования //
	//   и, если пользователь, подтвердил введенные данные, то функция должна создать
	//   новую запись объекта в базе данных и идентификатор созданной записи вернуть по адресу pID.
	//   Ошибка функция обрабатывает и сообщает о них пользователю самостоятельно.
	// Returns:
	//   cmOK -     пользователь что-то изменял и его работа была успешно зафиксирована в БД.
	//   cmCancel - пользователь отказался от изменения данных либо просто их не далал.
	//   0 - error (функция сама должна сообщить пользователю о ней, если требуется).
	//
	virtual int    Edit(PPID * pID, void * extraPtr);
	//
	// Descr: должна возвратить (> 0) если удаление состоялось без ошибок.
	//   Если была ошибка, то 0. Если пользователь не подтвердил удаление
	//   или оно не состоялось по какой-либо иной, не требующей дополнительной
	//   обработки, причине, то (<0). PPObject::Remove довольно развитая функция.
	//   Использует виртуальные методы Search и DeleteObj.
	//
	enum { // Remove's options
		use_transaction   = 0x0001, // Осуществляеть операцию внутри транзакции
		user_request      = 0x0002, // Запрашивать подтверждение на удаление и выводить сообщение об ошибке
		no_wait_indicator = 0x0004, // Не выводить окно "Подождите"
		rmv_default       = (use_transaction | user_request),
		not_addtolog      = 0x0008, // Не добавлять в журнал (для временных товарных групп)
		not_checkrights   = 0x0010, // Не проверять права (для временных товарныхгрупп)
		not_repl_remove   = 0x0020, // PPObject::ReplaceObj не удалять объединяемый объект
		not_objnotify     = 0x0040  // Удалять объект без посылки сообщений другим объектам (без проверки ссылочной целостности)
	};
	virtual int RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
		// @>>PPObject::Search
		// @>>PPObject::DeleteObj
	//
	// Descr: должна физически удалить запись с идентификатором id
	//   и возможно другие связанные с ней записи (подотчетные данному объекту)
	//   без транзакции. Уведомления PPObjMessage посылать не следует. Перед
	//   вызовом DeleteObj функция PPObject::Remove устанавливает позицию в
	//   файле методом Search. В случае ошибки, DeleteObj должна установить
	//   PPErrCode. Никаких сообщений на экран выдавать не должна.
	//
	virtual int DeleteObj(PPID id); // @<<PPObject::Remove
	//
	// Descr: Очищает элемент с идентификатором id в кэше
	//   Общая реализация обрабатывает этот вызов, обращаясь к централизованному
	//   менеджеру объектных кэшей (see PPSession).
	// Returns:
	//   >0 - если объект id содержался в кэше и был очищен.
	//   <0 - если объекта id в кэше не было
	//   0  - ошибка
	//
	virtual void FASTCALL Dirty(PPID id);
	//
	// Если порожденный класс определяет виртуальную функцию MakeStrAssocList
	// и устанавливает в переменную ImplementFlags флаг implStrAssocMakeList,
	// то методы PPObject::Selector и PPObject::UpdateSelector реализуются автоматически
	// через использование этой функции.
	//
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	//
	// Descr: Метод PPObject::UpdateSelector по умолчанию вызывает
	//   функцию ListBoxDef::refresh. Это подходит для селекторов,
	//   использующих выборку с использованием DBQuery
	//
	// @v11.1.10 virtual int    UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr); // @>>ListBoxDef::refresh()
	//
	// Descr: Метод ValidateSelection вызывается функцией PPObjListWindow::valid
	//   в ответ на команду cmOK. Если ValidateSelection возвращает
	//   (> 0) то все проходит как и должно пройти. Если 0, то команда
	//   отменяется. Если (< 0), то окно должно быть перерисовано в связи
	//   с какими-то изменениями, произведенными этой функцией. Этот
	//   код может быть использован для переопределения клавиши Enter
	//   или двойного нажатия мыши.
	//
	virtual bool   ValidateSelection(PPID, uint olwFlags, void * extraPtr); // @<<PPObjListWindow::valid()
	//
	// Descr: должна найти запись по идентификатору. Если запись найдена, то возвращает (>0).
	//   Если не найдена, то (<0). Ошибка - 0.
	//   Эта функция должна обязательно вернуть полную запись из таблицы и
	//   установить позицию записи (другими словами, использование кэширования для этой функции весьма ограничено).
	//
	virtual int    Search(PPID id, void * = 0);
	//
	// Descr: Если эта функция реализована, то конструктор объекта должен установить в ImplementFlags
	//   бит implStrAssocMakeList. Функция должна создать список наименований объектов с учетом
	//   дополнительного параметра extraParam.
	//   В случае успешного завершения, функция должна вернуть указатель на созданный список
	//   StrAssocArray. Список разрушается вызывающей функцией.
	// Returns:
	//   !0 - указатель на созданный объект StrAssocArray
	//   0  - ошибка. Функция должна корректно установить значение PPErrCode
	//
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	//
	// Descr: реализует диалог редактирования прав доступа. Никаких модификаций в БД
	//   она делать не должна. Так как структура ObjRights имеет переменную длину, параметр
	//   bufSize передает размер буфера данных buf в пределах которого можно работать.
	//   Если объект не может уложиться в заданный размер он должен вернуть ошибку и
	//   установить PPErrCode = PPERR_OBJRTBUFSIZ.
	//   Для практических целей размер 32 байта будет более чем достаточен.
	//   Реальный размер записи прав доступа должен быть установлен функцией
	//   в поле ObjRights::Size.
	//   Эта функция не должна вызывать функцию интерактивного сообщения об ошибке.
	// Returns:
	//   >0 - Пользователь подтвердил редактирование прав
	//   <0 - Пользователь отменил или каким-либо иным образом редактирование не было
	//        подтверждено, но без ошибки
	//   0  - Ошибка
	// Note: Функция не обязана устанавливать поле ObjRights::ObjType,
	//   и не обязана проверять права пользователя на администрирование
	//   (то есть на изменение прав доступа).
	//
	virtual int  EditRights(uint bufSize, ObjRights * buf, EmbedDialog * pDlg = 0);
	//
	// Descr: создает зарезервированные записи.
	// ARG(flags IN): 0 или один из флагов PPObject::mrfXXX
	//
	virtual int  MakeReserved(long flags);
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	//
	// Descr: Функция должна извлечь из потока (stream) или из базы данных (stream == 0)
	//   пакет объекта с идентификатором id.
	//   Если объект извлекается из базы данных и приоритет обработки объекта отличается //
	//   от обычного (1000), то в поле pPack->Priority функция должна установить требуемое значение.
	//
	virtual int  Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	//
	// Descr: функция записи в поток или в базу данных бинарного представления объекта
	//   Извлеченное из базы данных или из потока представление храниться по указателю pPack->Data.
	//   Класс PPObjXXX сам определяет способ хранения представления объекта.
	// ARG(pPack IN) - Пакет, содержащий данные объекта (pPack->Data) и служебную информацию
	//   об условиях перемещения объекта (версия системы, создавшей объект, время последней
	//   модификации в разделе, передающем объект, флаги)
	// ARG(pID   IN/OUT) - Указатель на значение идентификатора объекта в принимающем разделе БД.
	//   Если *pID != 0, то вызывающая процедура, обрабатывающая прием объектов, идентифицировала
	//   объект (по таблице синхронизации), в противном случае, объект не был идетифицирован.
	//   Функция Write может самостоятельно идентифицировать объект по контекстным параметрам
	//   и вернуть по этому указателю измененное значение идентификатора.
	//   В любом случае, если функция Write создала или изменила объект, она обязана вернуть
	//   правильный идентификатор по этому указателю.
	// ARG(stream IN) - Если stream == 0, то функция должна записать объект в базу данных.
	//   В противном случае, stream - это указатель на структуру FILE, идентифицирующую файл,
	//   в который следует записать бинарное представление объекта.
	// ARG(reserve IN) - зарезервированный параметр. Должен быть 0.
	// Returns:
	//   0 -       Ошибка. Прием данных следует прервать.
	//   <0 -      Ошибка приема объекта. Прием данных следует продолжить.
	//   1 -       Объект успешно принят в базу данных или успешно записан в файловый поток.
	//   101 -     В окне журнала необходимо поместить сообщение о том, что объект успешно создан
	//   102 -     В окне журнала необходимо поместить сообщение о том, что объект успешно изменен
	//
	virtual int  Write(PPObjPack * pPack, PPID * pID, void * stream, ObjTransmContext *);
	//
	// Returns:
	//   >0 - OK
	//   0  - Error
	//   -1 - OK ?
	//   -2 - Caller must skip receiving object
	//
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	static  int STDCALL ProcessObjRefInArray(PPID, long *, PPObjIDArray *, int replace);
	static  int STDCALL ProcessObjRefInArray(PPID objTypeID, int * pObjID, PPObjIDArray * pArray, int replace)
		{ return ProcessObjRefInArray(objTypeID, reinterpret_cast<long *>(pObjID), pArray, replace); }
	static  int STDCALL ProcessObjRefInArray_NoPreprocess(PPID objTypeID, PPID * pObjID, PPObjIDArray * pArray, int replace);
	static  int ProcessObjListRefInArray(PPID, PPIDArray &, PPObjIDArray * pArray, int replace);
	// Возвращает PPObjListWindow
	virtual void * CreateObjListWin(uint aFlags, void * extraPtr);

	enum {
		implTaggedStrMakeList = 0x0001, // Класс реализует виртуальную функцию TaggedStringArray * PPObject::MakeList_(long)
		implStrAssocMakeList  = 0x0002, // Класс реализует виртуальную функцию StrAssocArray * PPObject::MakeSStrAssocList(long)
		implTreeSelector      = 0x0004, // Класс реализует метод MakeSStrAssocList, возвращающий
			// древовидный список (функции Selector и UpdateSelector должна инициализировать StdTreeListBoxDef).
		implCharry    = 0x0008  // Объект поддерживает обмен по CHARRY
	};
	long   GetImplementFlags() const { return ImplementFlags; }

	PPID   Obj;
	ObjFilterProc FiltProc;
private:
	long   Rt_;  // Флаги доступа
	long   ORt_; // Операционные флаги доступа
	long   RightsUpdateCounter; // Значение счетчика PPThreadLocalArea::RightsUpdateCounter на момент получения значений Rt и ORt
protected:
	//
	// Descr: устанавливает идентификатор objID объекта objType как
	//   объект, на котором возникла ошибка (SetLastErrObj).
	//   Устанавливает код ошибки PPERR_REFSEXISTS и возвращает DBRPL_ERROR.
	//   Используется в функциях проверки наличия ссылок на объект.
	// Returns:
	//   DBRPL_ERROR
	//
	static int  FASTCALL RetRefsExistsErr(PPID objType, PPID objID);
	static int  STDCALL  ReadBlk(void * pBlk, size_t blkSize, void * stream);
	static int  STDCALL  WriteBlk(const void * pBlk, size_t blkSize, void * stream);
	static int  FASTCALL ReadSBuffer(SBuffer & rBuf, void * stream);
	static int  FASTCALL WriteSBuffer(SBuffer & rBuf, void * stream);
	virtual const char * GetNamePtr();
	int    RemoveSync(PPID);
	int    EditSpcRightFlags(uint dlgID, uint flCtlID, uint sflCtlID, uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
	int    EditPrereq(PPID * pID, TDialog * pDlg, bool * pIsNew);
	void   FASTCALL Helper_GetRights(int onStartUp);

	long   ImplementFlags;
};
//
// Конфигурация обмена данными между разделами БД
//
#define DBDXF_SKIPINCOMPLBILL      0x00000001L // Не принимать неполные документы
#define DBDXF_CALCTOTALDEFICITE    0x00000002L // Расчитывать итоговый дефицит товаров
#define DBDXF_TURNTOTALDEFICITE    0x00000004L // Приходовать дефицит
#define DBDXF_LINKRETBILLS         0x00000008L // Связывать возвратные документы
#define DBDXF_IGNOREACK            0x00000010L // Не принимать пакеты подтверджений
#define DBDXF_TWOPASSRCV           0x00000020L // Автоматический двухпроходной прием с приходованием дефицита
#define DBDXF_SENDINVWROFFBILLS    0x00000040L // Передавать документы списания ревизии
#define DBDXF_NOUPDGOODS           0x00000080L // Не принимать изменения товаров
#define DBDXF_IMPOPSYNC            0x00000100L // Контекстная синхронизация видов
	// операций по наименованию, типу операции и таблице статей
#define DBDXF_SYNCSCARDWOCHECKS    0x00000200L // Синхронизировать пластиковые карты без чеков
#define DBDXF_DONTCVTTOTALDIS      0x00000400L // Не конвертировать общую скидку на документы. Если этот флаг
	// не установлен, то система преобразует общую скидку, установленную по документу, в общую абсолютную скидку
	// (PPObjBill::ConvertILTI [ILTICVT.CPP]). В этом случае могут возникнуть затруднения при модификации
	// документа, на который в разделе-отправителе выставлена скидка в процентах, одновременно в обоих разделах -
	// суммы не совпадут, по-скольку в разделе получателе скидка будет выражена в сумме.
#define DBDXF_SENDCSESSION         0x00000800L // Передавать кассовые сессии.
	// Если этот флаг установлен, то при передаче изменений будут передаваться //
	// сессии, зафиксированные событием PPACN_CSESSCLOSED. Насильственная передача
	// сессий (PPViewCSess::Transmit) возможна независимо от этого флага.
	//
	// Если этот флаг установлен, то документы списания кассовых сессий не передаются.
	// @v4.6.4 Исключением является случай, когда в разделе-приемнике установлен флаг
	// DBDIVF_RCVCSESSANDWROFFBILLS. [см. функцию PPObjectTransmit::PutObjectToIndex()]
#define DBDXF_CHARRY_PRICEQCOST    0x00001000L // При приеме документов Charry цена реализации
	// равна цене поступления. В противном случае - если лоты такого товара уже существуют, то
	// цена берется из последнего из этих лотов, если же таких лотов нет, то цена реализации
	// опять же равна цене поступления.
#define DBDXF_PACKFILES            0x00002000L // Упаковывать файлы перед отправкой
#define DBDXF_IGNOBJUNIFY          0x00004000L // Игнорировать объединение объектов при разрешении идентификаторов
	// В функции PPObjectTransmit::NeedRestoreObj() не будет проверяться факт объединения объекта, если
	// в БД такой объект не найден (в некоторых случаях такая проверка приводит к неверному разрешению
	// синхронизации объектов).
#define DBDXF_UNITEINVDUPREC       0x00008000L // Объединять дублирующиеся строки инвентаризации
#define DBDXF_NOCOMMITBYDEF        0x00010000L // По умолчанию, при приеме данных не устанавливается признак "Непосредственная фиксация транзакции"
#define DBDXF_DESTROYQUEUEBYDEF    0x00020000L // По умолчанию, при приеме данных устанавливать признак "Разрушать очередь после акцепта"
#define DBDXF_DONTLOGOBJUPD        0x00040000L // Не показывать в журнале информацию об изменении объектов
#define DBDXF_SUBSTDEFICITGOODS    0x00100000L // подставлять дефицитные товары
#define DBDXF_CHARRY_GIDASARCODE   0x00200000L // При приеме документов по CHARRY идентификатор товара трактовать как код товара по контрагенту.
#define DBDXF_SENDTAGATTCHM        0x00400000L // Передавать файлы, прикрепленные к тегам
#define DBDXF_SYNCUSRANDGRPS       0x00800000L // Синхронизировать пользователей и группы
#define DBDXF_USEMQB               0x01000000L // @v11.0.1 Использовать брокер сообщений для обмена

struct PPDBXchgConfig { // @transient (Для сохранения транслируется в __PPDBXchgConfig)
	PPID   OneRcvLocID;        // Единственная локация, на которую должны приниматься все документы, независимо от того, какой локации они принадлежали в разделе-отправителе
	long   PctAdd;             // Процент наценки при доприходовании дефицита. В сотых долях процента (250 = 2.5%)
	int16  RealizeOrder;       // RLZORD_XXX Порядок использования лотов при приеме документов (переопределяет PPConfig::RealizeOrder на приеме документов из другого раздела)
	uint16 PadRo;              // @alignment
	long   CharryOutCounter;   // Счетчик исходящих файлов Charry
	long   Flags;              // @flags
	PPID   DfctRcptOpID;       // Вид операции приходования дефицита.
	PPID   SpcSubstGoodsGrpID; // Товарная группа для специальной подстановки при дефиците
};
//
// Descr: Контекст обмена данными. Передается в виртуальные методы
//   PPObject::Write, PPObject::Read.
//
struct ObjTransmContext {
	friend class PPObjectTransmit;
	enum {
		ctrfDisableLogWindow = 0x0001
	};
	//
	// Descr: Конструктор.
	// ARG(pLogger IN): @#{vptr0} Если указатель !0, то объект получает в качестве логгера внешний экземпляр,
	//   жизненный цикл которого управляется вызывающим кодом. В противном случае объект создает
	//   собственный экземпляр PPLogger, который будет разрушен деструктором.
	// Note: Для освобождения ссылки на внешний логгер и создания собственного экземпляра следует
	//   использовать метод ResetOuterLogger()
	//
	ObjTransmContext(uint ctrFlags, PPLogger * pLogger);
	~ObjTransmContext();
	int    ResetOuterLogger();
	int    Output(const char * pText);
	int    OutputLastError();
	int    OutReceivingMsg(const char * pMsg);
	int    OutputAcceptErrMsg(uint msgID, PPID objID, const char * pObjName);
	int    OutputAcceptObjErrMsg(PPID objType, PPID objID, const char * pObjName);
	int    OutputAcceptMsg(PPID objType, PPID objID, int upd);
	int    OutputString(uint strId, const char * pAddedInfo);
	operator SSerializeContext & () { return SCtx; }
	int    GetPrevRestoredObj(PPObjID * pOi) const;
	int    ForceRestore(PPObjID);
	int    IsForced(PPObjID) const;
	int    GetPrimaryObjID(PPID objType, PPID foreignID, PPID * pPrimID);
	int    RegisterDependedNonObject(PPObjID objid, PPCommSyncID & rCommID, int use_ta);
	int    ResolveDependedNonObject(PPID objType, PPID foreignID, PPID * pPrimID);
	int    AcceptDependedNonObject(PPObjID foreignObjId, PPID primaryID, const LDATETIME * pModDtm, int use_ta);

	LDATETIME TransmitSince;            // Момент, начиная с которого должны передаваться изменения //
	PPDBXchgConfig Cfg;                 // Конфигурация обмена
	BillTransmDeficit * P_Btd;          //
	GoodsReplacementArray * P_Gra;      //
	enum {
		fNotTrnsmLots = 0x0001,         // Не передавать товарные строки
		fConsolid     = 0x0002,         // Принимающий раздел является консолидирующим
		fRecover      = 0x0004          // Восстанавливающая передача
	};
	long   Flags;                       // ObjTransmContext::fXXX
	const  DBDivPack * P_ThisDbDivPack; // Пакет текущего раздела БД
	const  DBDivPack * P_SrcDbDivPack;  // Пакет раздела БД, из которого принимаются данные (в режиме передачи - 0)
	const  DBDivPack * P_DestDbDivPack; // Пакет раздела-получателя данных (в режиме приема - 0)
	PPID   Extra;        // Дополнительный параметр. В случае передачи документов, содержит id операции в которую требуется преобразовать текущую операцию
	long   LastStreamId; // Идентификатор последнего потока, из которого извлекались данные. Необходим для правильного переключения состояний контекстов сериализации данных (SCtx)
	SSerializeContext  SCtx;            // Контекст сериализации данных
private:
	const void * P_Rb;                  // @*PPObjectTransmit::CommitQueue Указатель на блок восстановления.
	enum {
		stOuterLogger = 0x0001
	};
	long   State;
	PPObjIDArray * P_ForceRestoreObj;   // Список объектов, которые должны быть изменены обязательно.
		// Список формируется в процессе приема данных. Некоторые объекты при приеме могут потребовать
		// обязательной модификации объекта, от которого они зависят.
		// Идентификаторы объектов здесь храняться в терминах раздела-отправителя (ссылки неразрешенные).
	PPObjectTransmit * P_Ot;            // @notowned
	PPLogger * P_Logger;                // Журнал, в который записывается информация о процессе
};

template <class ObjType, class ObjPackType> int Implement_ObjReadPacket(ObjType * pObj, PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx)
{
	int    ok = 1;
	ObjPackType * p_pack = new ObjPackType;
	p->Data = p_pack;
	THROW_MEM(p->Data);
	if(stream == 0) {
		THROW(pObj->GetPacket(id, p_pack) > 0);
	}
	else {
		SBuffer buffer;
		THROW_SL(buffer.ReadFromFile(static_cast<FILE *>(stream), 0))
		THROW(pObj->SerializePacket(-1, p_pack, buffer, &pCtx->SCtx));
	}
	CATCHZOK
	return ok;
}

#define IMPL_DESTROY_OBJ_PACK(obj, typ) \
	void FASTCALL obj::Destroy(PPObjPack * p) { if(p && p->Data) { delete (static_cast<typ *>(p->Data)); p->Data = 0; } }
#define IMPL_OBJ_FETCH(obj_cls, obj_rec, cache_cls) \
	int FASTCALL obj_cls::Fetch(PPID id, obj_rec * pRec) \
	{ cache_cls * p_cache = GetDbLocalCachePtr <cache_cls> (Obj); return p_cache ? p_cache->Get(id, pRec) : Search(id, pRec); }
#define IMPL_OBJ_DIRTY(obj_cls, cache_cls) \
	void FASTCALL obj_cls::Dirty(PPID id) { cache_cls * p_cache = GetDbLocalCachePtr <cache_cls> (Obj, 0); CALLPTRMEMB(p_cache, Dirty(id)); }
//
// Descr: Проверяет наличие прав для конфигурации cfgID.
//
int FASTCALL CheckCfgRights(PPID cfgID, ushort rt, int oprRights);
//
//
//

//
//
//
struct PPGeoTrackItem { // @flat
	PPGeoTrackItem();
	PPGeoTrackItem & FASTCALL operator = (const PPGeoTrackItem & rS);
	PPGeoTrackItem & FASTCALL operator = (const GeoTrackTbl::Rec & rS);
	int    FASTCALL Get(GeoTrackTbl::Rec & rD) const;

	enum {
        fNetworkProvider = 0x0001
	};

	PPObjID Oid;
	PPObjID ExtOid;
	LDATETIME Dtm;
	long   ExtEvent;
	long   Flags;
	double Latitude;
	double Longitude;
	double Altitude;   // Высота (м)
	double Speed;      // Скорость (м/с)
};

class GeoTrackCore : public GeoTrackTbl {
public:
	static LDATE FASTCALL ConvertStorageDate(int16 sd);
	static int16 FASTCALL GetStorageDate(LDATE dt);

    GeoTrackCore();
    int    Search(PPObjID oid, LDATETIME dtm, PPGeoTrackItem * pItem);
    int    PutItem(const PPGeoTrackItem & rItem, int use_ta);
    int    PutChunk(const TSVector <PPGeoTrackItem> & rList, int use_ta);
};
//
// RegisterCore (Implemented in REGISTER.CPP)
//
// @v12.0.0 (replaced with !RegisterCore::IsEqualRec() && r1.ID != r2.ID) int FASTCALL operator != (const RegisterTbl::Rec &, const RegisterTbl::Rec &);

#pragma pack(push, 1)
struct PPBankAccount { // @#=sizeof(RegisterTbl::Rec) @flat
	PPBankAccount();
	PPBankAccount(const RegisterTbl::Rec & rS);
	PPBankAccount & FASTCALL operator = (const RegisterTbl::Rec & rS);
	void   FASTCALL GetRegisterRec(RegisterTbl::Rec & rRec) const;

	PPID   ID;          // @# !0
	long   ObjType;     // Const=PPOBJ_PERSON
	long   PersonID;    //
	long   UnusedZero;  //
	long   RegTypeID;   // Const=PPREGT_BANKACCOUNT
	LDATE  OpenDate;    //
	long   BankID;      // ->Person.ID
	char   UnusedZ2[32]; // @v12.0.0 [12]-->[32]
	char   Acct[128];    // Номер счета @v12.0.0 [32]-->[128]
	LDATE  Expiry;       // Дата окончания действия счета
	long   UniqCntr;     // Счетчик, делающий индекс (RegTypeID, Serial, Number, UniqCntr) уникальным
	long   Flags;        //
	long   AccType;      //
};
#pragma pack(pop)

class RegisterArray : public SVector {
public:
	RegisterArray();
	RegisterArray(const RegisterArray & s);
	RegisterTbl::Rec & FASTCALL at(uint pos) const;
	int    FASTCALL IsEq(const RegisterArray & rS) const;
	int    FASTCALL HasEqual(const RegisterTbl::Rec & rRec) const;
	//
	// Descr: Ищет регистр типа regTyp начиная с позиции *pPos или 0 если pPos == 0.
	//   Если dt != ZERODATE, тогда проверяет чтобы дата истечения срока действия найденного
	//   регистра была либо нулевой либо больше или равна dt.
	// Returns:
	//   >0 - найдена запись удовлетворяющая условиям функции.
	//        По адресу pPos при этом присваивается позиция найденной записи +1,
	//        а по адресу pRec найденная запись.
	//   <0 - требуемая запись не найдена.
	//
	int    GetRegister(PPID regTypeID, LDATE dt, uint * pPos, RegisterTbl::Rec * pRec) const;
	//
	// Descr: Ищет регистр типа regTyp начиная с позиции *pPos или 0 если pPos == 0.
	// Returns:
	//   >0 - найдена запись удовлетворяющая условиям функции.
	//   <0 - требуемая запись не найдена.
	//
	int    GetRegister(PPID regType, uint * pos, RegisterTbl::Rec * pRec) const;
	int    GetListByType(PPID regTypeID, LDATE dt, RegisterArray * pList) const;
	int    GetListByPeriod(PPID regTypeID, const DateRange & rPeriod, RegisterArray * pList) const;
	int    GetBankAccountList(TSVector <PPBankAccount> * pList) const;
	int    CheckDuplicateBankAccount(const PPBankAccount * pRec, long pos) const;
	//
	// Descr: Вносит в массив банковский счет pRec. Если pos >= getCount(),
	//   то добавляет новую запись, в противном случае - модифицирует существующую
	//
	int    SetBankAccount(const PPBankAccount * pRec, uint pos);
	int    GetRegNumber(PPID regTyp, LDATE dt, SString & rBuf) const;
	int    GetRegNumber(PPID regTyp, SString & rBuf) const;
	//
	// Descr: Возможные результаты выполнения функции SelectRegister
	//
	enum {
		srrNothing       = -1, // Нет ни одного подходящего регистра
		srrError         =  0, // Ошибка
		srrEmptyDateCrit =  1, // Критерий даты не задан (dt == ZERODATE)
		srrSingle        =  2, // Есть только один регистр, удовлетворяющий критериям
		srrMinStartDist  =  3, // Выбран регистр с минимальным расстоянием от даты начала действия
		srrMaxExpiryDist =  4, // Выбран регистр с максимальным расстоянием до даты истечения срока действия
		srrAmbig         =  5  // Есть более одного регистра, удовлетворящего критериям, с параметрами, не позволяющими
			// выбрать наиболее оптимальный вариант - выбран самый первый.
	};
	//
	// Descr: Выбирает из списка регистр максимально удовлетворяющий критерию даты dt.
	//   Правила отбора следующие:
	//   -- если dt == ZERODATE, то выбирается первый регистр, имеющий тип regType
	//   -- если есть более одного регистра с типом regType и dt != ZERODATE, то выбирается
	//      регистр с наименьшим не отрицательным расстоянием от даты dt до RegisterTbl::Rec::Dt (dt >= RegisterTbl::Rec::Dt)
	//   -- если нет регистра с не отрицательным расстоянием (dt - RegisterTbl::Rec::Dt), то выбирается регистр
	//      с наибольшим не отрицательным расстоянием от RegisterTbl::Rec::Expiry до dt (RegisterTbl::Rec::Expiry >= dt)
	//   В любом случае отбираются только регистры, дата начала и дата окончания которых не противоречат dt:
	//   (!dt || ((!RegisterTbl::Rec::Dt || dt >= RegisterTbl::Rec::Dt) && (!RegisterTbl::Rec::Expiry || dt <= RegisterTbl::Rec::Expiry)))
	// ARG(regType IN): Тип регистрационного документа
	// ARG(dt      IN): Дата актуальности искомого регистрационного документа
	// ARG(pPos   OUT): @#{vptr0} Опциональный указатель, по которому присваивается позиция найденного регистра.
	//  Позиция относительно 1. То есть, для получения по значению *pPos записи из массива необходимо
	//  уменьшить ее на 1
	//  {
	//     uint pos = 0;
	//     if(SelectRegister(reg_type_id, dt, &pos, 0) > 0)
	//         const RegisterTbl::Rec & r_rec = at(pos-1);
	//  }
	//  Если функцию вернула <= 0, то значение по указателю не изменяется.
	// ARG(pRec,  OUT): @#{vptr0} Опциональный указатель по которому присваивается найденная запись.
	//  Если функцию вернула <= 0, то запись по указателю обнуляется.
	// Returns:
	//   <0 - нет ни одного подходящего регистра
	//   0  - ошибка
	//   >0 - выбран регистр.
	//   Варианты возврата функции определены перечислением RegisterArray::srrXXX (см. выше)
	//
	int    SelectRegister(PPID regTyp, LDATE dt, uint * pPos, RegisterTbl::Rec * pRec) const;
	//
	// Descr: Возвращает номер регистра, выбранного по правилам, определенным для метода SelectRegister()
	//
	int    SelectRegNumber(PPID regTyp, LDATE dt, SString & rBuf) const;
	int    Merge(const RegisterArray & rS);
	//
	// Descr: Сортирует массив {RegTypeID, Dt, Expiry}
	//
	void   Sort();
	int    ProcessObjRefs(PPObjIDArray * ary, int replace);
};
//
// Флаги записи RegisterTbl::Rec
//
#define PREGF_DUPNUMBER      0x0001L // {Серия,Номер} регистра могут дублироваться.
#define PREGF_INHERITED      0x0002L // @transient Наследуемый регистр
#define PREGF_BACC_PREFERRED 0x0004L // Предпочтительный банковский счет. Замещает старый флаг BACCTF_PREFERRED который перехлестывается с PREGF_DUPNUMBER

class RegisterCore : public RegisterTbl {
public:
	static int FASTCALL IsEqualRec(const RegisterTbl::Rec & rRec1, const RegisterTbl::Rec & rRec2);
	static int FASTCALL GetText(const RegisterTbl::Rec & rRec, SString & rBuf);
	static int FASTCALL CheckRecForFilt(const RegisterTbl::Rec & rRec, const RegisterFilt * pFilt);

	RegisterCore();
	int    Search(PPID id, RegisterTbl::Rec * = 0);
	int    Add(PPID *, RegisterTbl::Rec *, int use_ta);
	int    Update(PPID, RegisterTbl::Rec *, int use_ta);
	int    Remove(PPID, int use_ta);
	//
	// - Если pRec != 0, то функция устанавливает для персоналии personID регистр pRec.
	//   В этом случае параметр regTypeID игнорируется.
	// - Если pRec == 0, то функция удаляет регистры с типом regTypeID, принадлежащие персоналии.
	//   Если regTypeID == 0, удаляются все регистры, принадлежащие указанной персоналии.
	//
	int    SetByPerson(PPID personID, PPID regTypeID, const RegisterTbl::Rec * pRec, int use_ta);
	//
	// Descr: Извлекает из БД список регистров, принадлежащих персоналии personID.
	// Returns:
	//   >0 - Найден по крайней мере один регистр
	//   <0 - Персоналия не содержит ни одного регистра
	//   0  - Ошибка
	//
	int    GetByPerson(PPID personID, RegisterArray * pList);
	int    GetByLocation(PPID locID, RegisterArray * pList);
	int    GetByEvent(PPID eventID, RegisterArray * pList);
	int    PutByEvent(PPID eventID, RegisterArray * pList, int use_ta);
	int    PutByPerson(PPID personID, RegisterArray * pList, int use_ta);
	int    PutByLocation(PPID locID, RegisterArray * pList, int use_ta);
	int    SearchByNumber(PPID * pID, PPID regTypeID, const char * pSerial, const char * pNumber, RegisterTbl::Rec *);
	//
	// Descr: Ищет список регистров, соответствующих фильтру pFilt.
	// ARG(pFilt IN): Фильтр с набором критериев поиска
	// ARG(pResList OUT): @#{vptr) Указатель на вектор, в который заносятся идентификаторы регистров, соответствующих фильтру.
	// ARG(pObjList OUT): @#{vptr) Указатель на вектор, в который заносятся идентификаторы объектов, которым соответствуют найденные регистры.
	//
	int    SearchByFilt(const RegisterFilt * pFilt, PPIDArray * pResList, PPIDArray * pObjList);
	//
	// Descr: Ищет первый встреченный регистр типа regID по объекту oid.
	// Note: Конкретному объекту может принадлежать более одного регистра заданного типа. Эта функция вернет только первый из них.
	//   Справедливости ради надо сказать, что множественные комбинации такого вида встречаются не часто.
	//
	int    SearchByObj(PPObjID oid, PPID regTypeID, RegisterTbl::Rec * pRec);
	//
	// Descr: Функция аналогичная Add(), но с безусловным разрешением на дублирование номеров.
	// Note: @really private Не следует использовть иначе, как в экстренных случаях, требущих
	//   низкоуровневого вмешательства в управляемую уникальность нумерации в обход PPObjRegisterType
	//
	int    Add_ForceDup(PPID * pID, RegisterTbl::Rec * pRec, int use_ta);
private:
	int    GetUniqCntr(RegisterTbl::Rec * pRec, int forceDup);
	int    _Get(PPID, PPID, RegisterArray *);
	int    _Put(PPID, PPID, RegisterArray *, int use_ta);
};
//
//
//
class PPPerson { // Managed by class PersonCore
public:
	friend class PersonCore; // function PersonCore::Get need to have access to RelList

	PPPerson();
	PPPerson(const PPPerson & rS);
	PPPerson & FASTCALL operator = (const PPPerson & rS);
	PPPerson & Z();
	int    AddRelation(PPID personID, PPID relTypeID, uint * pPos);
	int    AddRelations(const PPIDArray * pPersonList, PPID relTypeID, uint * pPos);
	int    RemoveRelation(PPID personID, PPID relTypeID);
	//
	//     Descr: Удаляет отношения с персоналиями из списка pPersonList и типом отношения relTypeID
	//     Если pPersonList = 0, то будут удалены все отношения с типом отношения relTypeID
	//
	int    RemoveRelations(PPIDArray * pPersonList, PPID relTypeID);
	int    RemoveRelationByPos(uint pos);
	const  LAssocArray & GetRelList() const;
	int    GetRelList(PPID relTypeID, PPIDArray * pList) const;

	PersonTbl::Rec Rec;
	SString SMemo; // @v11.1.12
	PPIDArray Kinds;
private:
	//
	// Descr: Список отношений с другими персоналиями.
	//   Каждое отношение храниться как {Key = PersonID, Val = PersonRelTypeID}
	//   В базе данных список отношений храниться в таблице ObjAssoc где:
	//   AsscType = PPASS_PERSONREL, PrmrObjID = this->Rec.ID, ScndObjID = RelList[].Key,
	//   Val1 = RelList[].Val
	//
	LAssocArray RelList;
};
//
// Флаги персоналий
//
#define PSNF_NOVATAX              0x00000001L // Освобожден от уплаты НДС (поставщики)
#define PSNF_CTRBANK              0x00000002L // Центральный банк страны (только банки)
#define PSNF_HASIMAGES            0x00000004L // К объекту присоединены картинки
#define PSNF_NONOTIFICATIONS      0x00000008L // Запрет на рассылку для этой персоналии
#define PSNF_GENDER_MALE          0x00000010L // Физическое лицо мужского пола
#define PSNF_GENDER_FEMALE        0x00000020L // Физическое лицо женского пола
#define PSNF_DONTSENDCCHECK       0x00000040L // @v11.3.5 Запрет на отправку чека по электронной почте или SMS

#define MAXSAMEPSNREL  4 // Максимальное число отношений между одинаковыми персоналиями

class PersonCore : public PersonTbl {
public:
	static int    PutELinks(PPID id, PPELinkArray *, int use_ta);
	static int    GetELinks(PPID id, PPELinkArray &);
	static void   SetGender(PersonTbl::Rec & rRec, int gender);
	static int    GetGender(const PersonTbl::Rec & rRec);
	PersonCore();
	//
	// Descr: Определяет, принадлежит ли персоналия personID виду kindID.
	// Returns:
	//   >0 - персоналия personID принадлежит виду kindID
	//   0  - персоналия personID не принадлежит виду kindID
	//
	int    IsBelongsToKind(PPID personID, PPID kindID);
	int    GetListByKind(PPID kindID, PPIDArray * pList);
	int    Put(PPID * pID, PPPerson * pPack, int use_ta);
	int    Get(PPID id, PPPerson * pPack);
	int    Search(PPID id, PersonTbl::Rec * pRec = 0);
	int    SearchByName(const char * pName, PPID * pID, PersonTbl::Rec * pRec = 0);
	int    SearchByName(const char * pName, PPIDArray & rList);
	SString & GetItemMemo(PPID id, SString & rBuf); // @v11.1.12
	int    SearchMainOrg(PersonTbl::Rec * pRec);
	int    GetKindList(PPID personID, PPIDArray * pList);
	int    AddKind(PPID id, PPID kind, int use_ta);
	int    RemoveKind(PPID id, PPID kind, int us_ta);
	int    GetVATFreePersonList(PPIDArray *);
	int    PutRelList(PPID id, const LAssocArray *, int use_ta);
	//
	// Descr: Извлекает список отношений персоналии id с другими персоналиями.
	// ARG(id      IN): ИД персоналии
	// ARG(pList  OUT): список связей персоналии id с другими персоналиями
	// ARG(reverse IN): если !0, то функция извлекает список связей, идущих от других
	//   персоналий к той, которая имеет ИД = id.
	// Returns:
	//   >0 - функция отработала успешно
	//   <0 - нет ни одной связи
	//   0  - ошибка
	//
	int    GetRelList(PPID id, LAssocArray * pList, int reverse = 0);
	int    UpdateFlags(PPID id, long setF, long resetF, int use_ta);
	int    GetELinkList(int elnkrt, PPID personKindID, StrAssocArray & rList);

	PersonKindTbl Kind;
	//
	// Descr: Структура отношения персоналия-персоналия //
	//   Является проекцией на записись таблицы БД ObjAssocTbl
	//
	struct RelationRecord { // @#size=sizeof(ObjAssocTbl::Rec)
		long   ID;             // @id
		long   AsscType;       // Const=PPASS_PERSONREL Тип ассоциации
		long   PrmrObjID;      // ИД первичного объекта
		long   ScndObjID;      // ИД вторичного объекта
		long   InnerNum;       // Номер вторичного объекта по внутренней классификации
		uint8  Reserve[48];    // @reserve
		long   RelTypeID;      // Тип отношения //
		long   Reserve2[3];    // @reserve
	};

	static int Helper_GetELinksFromPropRec(const PropertyTbl::Rec * pRec, const size_t recLen, PPELinkArray * pList);
protected:
	int    _SearchKind(PPID id, PPID kind);
	int    PutKinds(PPID, PPPerson *);
};
//
// Типы локаций
//
#define LOCTYP_WAREHOUSE       1L // Склад | магазин
#define LOCTYP_WAREPLACE       2L // Складская зона хранения товара
#define LOCTYP_WHZONE          2L // Складская зона хранения товара
#define LOCTYP_ADDRESS         3L // Адрес персоналии
#define LOCTYP_DIVISION        4L // Структурное подразделение организации
#define LOCTYP_WAREHOUSEGROUP  5L // Группа складов
#define LOCTYP_WHCOLUMN        6L // Колонка зоны хранения //
#define LOCTYP_WHCELL          7L // Ячейка зоны хранения //
#define LOCTYP_WHAISLE         8L // Складской проход
#define LOCTYP_WHCELLAUTOGEN 100L // Специальное значение, используемое для выбора функции автоматической генерации ячеек для колонны.
//
// Флаги локаций
//
#define LOCF_VATFREE           0x00000001L // Операции по складу освобождены от НДС
#define LOCF_MANUALADDR        0x00000002L // Полный адрес задается в ручную //
#define LOCF_VOLUMEVAL         0x00000004L // Объем места хранения задается одним значением
#define LOCF_COMPARABLE        0x00000008L // Сравниваемый склад (обычно применяется в отношении магазинов для анализа данных)
#define LOCF_ADJINTRPRICE      0x00000010L // При поступлении товара на этот склад через внутреннюю передачу
	//  с другого склада выравнивать учетную цену реализации по последенму лоту.
#define LOCF_WHAUTONAME        0x00000020L // Автоматическое наименование для складской зоны/колонны/ячейки (и для дочерних объектов)
#define LOCF_WHCODEPREFIX      0x00000040L // В коды складских объектов добавлять как префикс код склада
#define LOCF_SEQCOLCODE        0x00000080L // Сквозная нумерация колонн (не зависимо от принадлежности зоне)
#define LOCF_DISPOSEBILLS      0x00000100L // Применять функции складского размещения для документов, принадлежащих этому складу
#define LOCF_STANDALONE        0x00000200L // Автономный адрес. То есть, может быть не привязан ни к какому объекту.
	// Одновременно, если такой адрес привязан к объекту, то удаление объекта не влечет удаление адреса.
#define LOCF_PASSIVE           0x00000400L // @v11.9.9 Пассивная запись (не отображается в списках) 
#define LOCF_INTERNAL_DISABLED 0x80000000L // @internal @transient Флаг, ассоциированный со складом, на который у пользователя нет прав

struct LocationFilt : public PPBaseFilt {
	explicit LocationFilt(PPID locType = 0, PPID ownerID = 0, PPID parentID = 0);
	LocationFilt & FASTCALL operator = (const LocationFilt & rS);
	int    GetExField(int fldId, SString & rBuf) const;
	int    SetExField(int fldId, const char * pBuf);
	//
	// Descr: Идентификаторы дополнительных строк фильтрации
	//
	enum {
		exfPhone = 1 // Номер телефона
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   LocType;        // Тип локации (LOCTYP_XXX)
	PPID   Owner;          // Персоналия-владелец     ->Person.ID
	PPID   Parent;         // Локация верхнего уровня ->LocationID
	PPID   CurrID;         // Используется при создании нового элемента - ИД текущей записи в списке
	PPID   GoodsID;        // Товар, по наличию которого следует отбирать ячейки.
	uint8  Reserve[4];     // @anchor
	ObjIdListFilt ExtLocList; //
	SString ExtString;        //
 };
//
// Descr: Структура, описывающая особенности типа записи Location
//
struct LocTypeDescr {
	enum {
		fParentRequired = 0x0001, // Тип требует обязательного родительского объекта
		fParentDisabled = 0x0002, // Тип не может иметь родительского объекта
		fCodeRequired   = 0x0004  // Локация этого типа обязательно должна иметь не пустой код
	};
	int    LocType;        // Собственно, тип, который описывается данным дескриптором
	int    ParentLocType;  // Тип родительского объекта
	long   Flags;          // @flags
	SString Name;          // Строковое описание типа (извлекается из группирующей строки PPTXT_LOCTYPE)
};
//
// Идентификаторы строковых полей, хранящихся в хвостовой части записи LocationTbl
//
#define MAX_DLVRADDRFLDS      40 // Максимальное кол-во дополнительных полей адреса доставки
#define MAX_DLVRADDRFLDLEN    64 // Максимальная длина дополнительного поля адреса доставки

#define LOCEXSTR_ZIP           1
#define LOCEXSTR_SHORTADDR     2
#define LOCEXSTR_FULLADDR      3
#define LOCEXSTR_PHONE         4   // Специальная опция для непривязанных (к персоналиям) адресов
#define LOCEXSTR_CONTACT       5   // Имя контактного лица, ассоциированного с адресом. Необходимость
	// в этом теге может быть обусловлена теми же причинами, что и LOCEXSTR_PHONE: адрес не связан с персоналией.
#define LOCEXSTR_EMAIL         6   // Специальная опция для непривязанных (к персоналиям) адресов
#define LOCEXSTR_INITID
#define LOCEXSTR_EXTFLDSOFFS 100 // смещение для ид дополнительных полей адресов доставки

class LocationCore : public LocationTbl {
public:
	friend class PPTblEnum <LocationCore>;

	static int STDCALL  GetAddress(const LocationTbl::Rec &, uint, SString & rBuf);
	static int FASTCALL IsEmptyAddressRec(const LocationTbl::Rec & rRec);
	static int FASTCALL IsEqualRec(const LocationTbl::Rec & rRec1, const LocationTbl::Rec & rRec2);
	//
	// Descr: Извлекает из записи локации pRec строку расширения с идентификатором fldID (LOCEXSTR_XXX)
	//   и присваивает ее буферу rBuf.
	// Note: буфер rBuf предварительно очищается функцией.
	// Returns:
	//   >0 - строка с идентификатором fldID найдена в пуле и присвоена буферу rBuf
	//    0 - строка с идентификатором fldID не найдена в пуле
	//   -2 - пул rLine пуст или же в нем нет ни одного тега (плоская строка)
	//
	static int STDCALL GetExField(const LocationTbl::Rec * pRec, int fldID, SString & rBuf);
	//
	// Descr: То же, что и LocationCore::GetExField, но всегда возвращает rBuf.
	//
	static SString & STDCALL GetExFieldS(const LocationTbl::Rec * pRec, int fldId, SString & rBuf);
	static int STDCALL SetExField(LocationTbl::Rec * pRec, int fldId, const char * pBuf);
	//
	// Descr: Возвращает описатель типа локации locType.
	//
	static int GetTypeDescription(int locType, LocTypeDescr * pDescr);

	LocationCore();
	~LocationCore();
	int    Search(PPID id, LocationTbl::Rec * = 0);
	int    SearchCode(PPID locType, const char * pCode, PPID * pID, LocationTbl::Rec * = 0);
	int    GetListByCode(PPID locTyp, const char * pCode, PPIDArray * pIdList);
	int    GetCodeByTemplate(const char * pTempl, SString & rBuf);
	int    SearchMaxLike(const LocationTbl::Rec * pRec, long flags, PPID * pID, LocationTbl::Rec * pLikeRec = 0);
	//
	enum {
		eoParentAsOwner = 0x0001, // ИД родительского элемента (parentID) трактуется как LocationTbl::Rec::OwnerID
		eoIgnoreParent  = 0x0002  // parentID не трактуется как ограничение выборки.
	};
	SEnum::Imp * Enum(PPID locTyp, PPID parentID, int options);
	int    Add(PPID * pID, LocationTbl::Rec *, int use_ta);
	int    SearchRef(PPID locType, PPID objType, PPID objID, PPID *);
	int    SearchPersonRef(PPID locType, PPID personID, PPID *);
	int    GetAddress_(PPID locID, uint flags, SString & rBuf);
	int    IndexPhone(const char * pPhone, const PPObjID * pObjId, int doRemove, int use_ta);
	int    SearchPhoneIndex(const char * pPhone, long options, PPIDArray & rResultList);
	int    SearchPhoneObjList(const char * pPhone, long options, PPObjIDArray & rList);
	int    GetEAddr(PPID id, EAddrTbl::Rec * pRec);
    int    SearchEAddrByLink(PPID objType, PPID objID, PPIDArray & rResultList);
    int    SearchEAddrMaxLikePhone(const char * pPhonePattern, long options, LongArray & rResult);
    int    GetFullEaList(StrAssocArray & rList);
	int    DumpEaList(const char * pFileName);
private:
	static int FASTCALL Helper_IsEqExField(const LocationTbl::Rec & rRec1, const LocationTbl::Rec & rRec2, int fldId, SString & rBuf1, SString & rBuf2);
	int    InitEnum(PPID locTyp, PPID parentID, int flags, long * pHandle);
	int    Helper_GetCodeByTempl(const char * pPrfx, const char * pSfx, int len, long low, long upp, int addChkDig, SString & rCode);

	PPTblEnumList EnumList;
	EAddrCore * P_Eac;
};
//
//
//
struct PPEAddr { // @persistent @flat size=16
	DECL_INVARIANT_C();
	int    FASTCALL Init(int type = tUndef);
	int    FASTCALL Set(uint32 ip4);
	int    Set(uint32 ip4Low, uint32 ip4Upp);
	int    FASTCALL SetPhone(const char * pPhone);
	int    FASTCALL GetPhone(SString & rBuf) const;
	int    FASTCALL operator == (const PPEAddr & rS) const;
	bool   IsEmpty() const;

	enum {
		tUndef = 0,
		tIpV4,
		tIpV4Range,
		tIpV6,
		tIpV6Range,
		tPhone
	};
	struct IpV4 {
		uint32 A;
	};
	struct IpV4Range {
		uint32 Low;
		uint32 Upp;
	};
	struct IpV6 {
		uint8 A[6];
	};
	struct IpV6Range {
		uint8 Low[6];
		uint8 Upp[6];
	};
	struct Phone {
		enum {
			nsfPlus = 0x0001, // Префикс "8" заменять на "+7"
		};
		static SString & FASTCALL NormalizeStr(const char * pOrgPhone, long flags, SString & rResult);
		static uint FASTCALL GenerateCheckNumber(const char * pOrgPhone, const char * pAddedumCode);
		static int  VerifyCheckNumber(const char * pOrgPhone, const char * pAddedumCode, uint checkedNumber);

		DECL_INVARIANT_C();
		SString & FASTCALL ToStr(long fmt, SString & rBuf) const;
		int    FASTCALL FromStr(const char * pStr);
		//
		// Телефон кодируется в упакованном BCD формате. Т.е. каждые две цифры укладываются в один байт.
		// Символ 't' (тональный сигнал) кодируется как 0x0A, символ '+' кодируется как 0x0B,
		// Символ 'x' (добавочный номер) кодируется как 0x0C.
		// Цифры от '0' до '9' кодируются как 0x00..0x09 соответственно.
		// Перед упаковкой номер освобождается от пробелов, тире и прочих символов отличных от 13-ти перечисленных.
		//
		uint8 A[12];
	};
	uint8  Type;       // Тип адреса (PPEAddr::tXXX)
	uint8  Flags;      // @reserve
	uint16 Reserve;    // @reserve
	union {
		IpV4 I4;
		IpV4Range I4R;
		IpV6 I6;
		IpV6Range I6R;
		Phone P;
	} U;
};

class PPEAddrArray : public TSVector <PPEAddr> {
public:
	PPEAddrArray();
	int    FASTCALL AddPhone(const char * pPhone);
	int    SearchPhone(const char * pPhone, long options, LongArray * pPosList) const;
};

class EAddrCore : public EAddrTbl {
public:
	EAddrCore();
	int    Search(PPID id, EAddrTbl::Rec * pRec);
	int    Search(const PPEAddr & rAddr, const PPObjID * pObjId, PPID * pID);
	int    SearchLink(PPID objType, PPID objID, LongArray & rResult);
	int    SearchIpV4(uint32 ip, long options, LongArray & rResult);
	int    SearchPhone(const char * pPhone, long options, LongArray & rResult);
	int    SearchMaxLikePhone(const char * pPhonePattern, long options, LongArray & rResult);
	int    Put(PPID * pID, const PPEAddr * pAddr, const PPObjID * pObjId, int use_ta);
};
//
// @v11.2.0
// Descr: Параметры множественной печати документов.
//
class BillMultiPrintParam { // @persistent
public:
	BillMultiPrintParam();
	bool   IsEmpty() const;
	bool   FASTCALL IsEq(const BillMultiPrintParam & rS) const;
	BillMultiPrintParam & Z();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Сохраняет экземпляр в локальном реестре.
	//   Если экземпляр пустой, тогда, если в реетсре что-то было - будет удалено.
	// Returns:
	//   >0 - экземпляр успешно сохранен в реестре (или удален, если this->IsEmpty())
	//   0  - ошибка
	//
	int    LocalSave();
	//
	// Descr: Пытается восстановить экземпляр объекта из локального реестра.
	// Returns:
	//   >0 - объект найден в локальном реестре и успешно восстановлен
	//   <0 - объект не найден в локальном реестре
	//    0 - error
	//
	int    LocalRestore();
	//
	// Descr: Вызывает диалог редактирования экземпляра this.
	// Returns:
	//  >0 - пользователь подтвердил результаты редактирования.
	//  <0 - пользователь отказался от изменений
	//   0 - error
	//
	static int EditDialog(PPID opTypeID, BillMultiPrintParam * pData);
	//
	// Descr: Перечисление печатных форм по документам.
	// Note: Значения используются как смещения битовой маски поля FormBits //
	//
	enum { // @persistent (не менять значения элементов ни в коем случае!)
		pbBill           =  0,
		pbQCert          =  1,
		pbInvoice        =  2,
		pbCashOrder      =  3,
		pbWayBill        =  4, // Товарно-транспортная накладная
		pbWayBillFreight =  5, // Товарно-транспортная накладная (транспортный раздел)
		pbSrvcAct        =  6, // Акт выполненных работ
		pbPriceTag       =  7, // Ценники
		pbPaymPlan       =  8, // План платежей
		pbTareSaldo      =  9, // Сальдо по возвратной таре
		pbLocDisp        = 10, // Наряд на складскую сборку
		pbLotTagImage    = 11, // Изображения из тегов лотов
		pbUniBill        = 12, // Универсальный передаточный документ
		// Следующий вариант вставлять сюда
		pb__Count              // Общее количество вариантов
	};
	enum {
		fMakeOutCopies     = 0x0001, // Разобрать по копиям
		fUpdatedPricesOnly = 0x0002  // Печатать только позиции с изменившимися ценами (специализированный флаг)
	};
	uint32 Reserve[16];
	uint32 FormBits;
	uint32 Flags;
	uint16 CopyCounter[32];
	// Если какой-либо отчет должен использовать кастомизированную форму, то
	// наименование этой формы хранится в StringSet с префиксом енумератора pbXXX + 1.
	StringSet CustomFormNames;
};
//
// Descr: Структура соглашения с клиентом об условиях торговли
//   Хранится в таблице Property с координатами {PPOBJ_ARTICLE, ArtID, ARTPRP_CLIAGT}
//
//
#define AGTF_DEFAULT             0x0001L // @transient Default agreement. @*PPObjArticle::GetClientAgreement()
#define AGTF_LOADED              0x0002L // @transient Если этот флаг установлен, то структура извлечена из БД.
#define AGTF_DONTCALCDEBTINBILL  0x0004L // Не рассчитывать долг по клиенту в документах
#define AGTF_PRICEROUNDING       0x0008L // Округлять окончательную цену реализации в документах
#define AGTF_PRICEROUNDVAT       0x0010L // Окончательную цену округлять до значения, кратного ставке НДС
#define AGTF_USEMARKEDGOODSONLY  0x0020L // Для этого контрагента в товарный документ можно вставлять только товары, имеющие код, связанный со статьей.
#define AGTF_SUBCOSTONSUBPARTSTR 0x0040L // При распределении по документу частичной структуры
	// с уменьшением начального количества, уменьшать себестоимость документа. Если этот
	// флаг не установлен, тогда себестоимость уменьшаемого товара ложится на компенсирующие
	// компоненты структуры.
	// @seealso GSIF_SUBPARTSTR
#define AGTF_AUTOORDER           0x0080L // Рассчитывать для данного поставщика заказ автоматически
#define AGTF_DDLIST715           0x0100L // Установленный флаг означает, что в БД запись сохранена с форматом списка DebtLimitList v7.1.5
#define AGTF_USESDONPURCHOP      0x0200L // Применять ограничение контрактных цен на операции закупки
#define AGTF_DONTUSEMINSHIPMQTTY 0x0400L // Не следует применять минимальное отгружаемое количество (GoodsStockExt;:MinShippmQtty)
#define AGTF_DEFAGENTLOCTODBDIV  0x0800L // @v11.0.10 Агент по умолчанию в соглашениях с поставщиками локален по отношению к разделу базы данных.
	// То есть, при акцепте в разделе базы данных соглашения из другого раздела, поле агент-по-умолчанию не меняется.
#define AGTF_PREPAYEDSALESONLY   0x1000L // @v11.3.2 @construction Отгрузка клиенту допускается только по предоплате
#define AGTF_INHSUPPLTAXGRPINLOT 0x2000L // @v12.2.1 (только общее соглашение) При создании строки приходного документа налоговую группу поставщика (PPTAG_PERSON_SPCTAXGROUP) наследовать в лоте

struct PPClientAgreement { // @persistent
	PPClientAgreement();
	PPClientAgreement(const PPClientAgreement &);
	PPClientAgreement & Z();
	bool   IsEmpty() const;
	int    FASTCALL IsEq(const PPClientAgreement & rS) const;
	PPClientAgreement & FASTCALL operator = (const PPClientAgreement &);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Возвращает кредитный лимит контрагента, возможно, привязанный к долговой размерности debtDimID.
	//
	double FASTCALL GetCreditLimit(PPID debtDimID) const;
	//
	// Desecr: Если с (не нулевой) долговой размерностью debtDimID ассоциирован
	//   признак Stop, то возвращает 1, иначе 0.
	//   Если соглашение не содержит элемента, ассоциированного с debtDimID,
	//   то функция возвращает -1 (признак Stop должен быть определен из аналитической статьи).
	//
	int    FASTCALL IsStopped(PPID debtDimID) const;

	struct DebtLimit { // @flat
		enum {
			fStop = 0x00000001L
		};
		PPID   DebtDimID;
		double Limit;
		long   Flags;
		LDATE  LockPrcBefore;  // Дата, до которой процессинг должников не меняет параметры размерности //
	};

	PPClientAgreement::DebtLimit * FASTCALL GetDebtDimEntry(PPID debtDimID) const;

	PPID   ClientID;       //
	long   Flags;          //
	LDATE  BegDt;          //
	LDATE  Expiry;         //
	double MaxCredit;      // Максимальный кредит
	double MaxDscnt;       // Максимальная скидка в %% (>= 100% - неограниченная)
	double Dscnt;          // Обычная скидка в %%
	int16  DefPayPeriod;   // Количество дней от отгрузки до оплаты по умолчанию
	int16  PriceRoundDir;  // Направление округления окончательной цены в документах
	int16  RetLimPrd;      // @v11.2.0 (moved up) Период ограничения доли возвратов от суммы товарооборота
	uint16 RetLimPart;     // @v11.2.0 (moved up) Макс доля возвратов от суммы товарооборота за период RetLimPrd (в промилле)
	PPID   DefAgentID;     // Агент, закрепленный за клиентом
	PPID   DefQuotKindID;  // Вид котировки, закрепленный за клиентом
	PPID   ExtObjectID;    // Дополнительный объект (таблица дополнительных объектов для общего соглашения)
	LDATE  LockPrcBefore;  // Дата, до которой процессинг должников не меняет параметры соглашения //
	// @v11.2.0 uint8  Reserve2[12];
	float  PriceRoundPrec; // Точность округления окончательной цены в документах
	// @v11.2.0 (moved up) int16  RetLimPrd;      // Период ограничения доли возвратов от суммы товарооборота
	// @v11.2.0 (moved up) uint16 RetLimPart;     // Макс доля возвратов от суммы товарооборота за период RetLimPrd (в промилле)
	//
	// Descr: Значения базы определения даты оплаты по документу
	//
	enum {
		pdbMain   = 0, // Основная дата документа
		pdbInvoice        = 1, // Дата счет-фактуры
		pdbFreightIssue   = 2, // Дата отправления (фрахт)
		pdbFreightArrival = 3, // Дата прибытия (фрахт)

		pdbTagBias        = 1000 // Если значение PaymDateBase выше pdbTagBias, то базовая дата извлекается из тэга
	};
	long   PaymDateBase;   // База для определения даты оплаты по документу.
	PPID   EdiPrvID;       // ->Ref(PPOBJ_EDIPROVIDER)
	// @v11.2.0 char   Code2[24];      // Номер соглашения
	uint8  Reserve3_[22];     // @v11.2.0 Переведено в резерв. Номер соглашения - в поле Code_ // @v11.4.8 [24]-->[22]
	uint16 DefDuePeriodHour; // @v11.4.8 Номинальное количество часов от формирования заказа до отгрузки (срок доставки).
	TSVector <DebtLimit> DebtLimList; // @anchor долговые ограничения по командам агентов
	SString Code_;            // @v11.2.0 Номер соглашения //
	BillMultiPrintParam Bmpp; // @v11.2.0 Параметры множественной печати документов. Позволит быстро установить эти параметры для документа
		// по конкретному контрагенту.
};

class PPSupplAgreement {    // @persistent @store(PropertyTbl)
public:
	PPSupplAgreement();
	PPSupplAgreement & Z();
	bool   IsEmpty() const;
	int    FASTCALL IsEq(const PPSupplAgreement & rS) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	void   FASTCALL RestoreAutoOrderParams(const PPSupplAgreement & rS);

	enum {
		invpaRestrict  = 0,
		invpaWarning   = 1,
		invpaDoNothing = 2,
	};
	//
	// Descr: Параметры обмена данными с поставщиком.
	//   Вводится как замена структуры PPSupplExchangeCfg
	//
	class ExchangeParam {
	public:
		// Только этому классу дадим доступ к Serialize_ так как PPSupplAgreement контролирует
		// версию формата обмена
		friend class PPSupplAgreement;

		ExchangeParam();
		ExchangeParam & FASTCALL operator = (const ExchangeParam & rS);
		//
		// Descr: Функция, преобразующая конфигурацию формата до v8.5.0 в текущую
		//
		ExchangeParam & FASTCALL operator = (const PPSupplExchangeCfg & rS);
		int    FASTCALL Copy(const ExchangeParam & rS);
		int    FASTCALL IsEq(const ExchangeParam & rS) const;
		ExchangeParam & Z();
		bool   IsEmpty() const;
		int    GetExtStrData(int fldID, SString & rBuf) const;
		int    PutExtStrData(int fldID, const char * pStr);

		enum {
			extssClientCode   = 1, // Код данного клиента на сервере поставщика
			extssEDIPrvdrSymb = 2, // Символ провайдера EDI
			extssRemoteAddr   = 3, // Адрес для обмена данными (это может быть e-mail, url иди каталог)
			extssAccsName     = 4, // Имя аккаунат для доступа к обмену данными
			extssAccsPassw    = 5, // Пароль для доступа к обмену данными
			extssTechSymbol   = 6  // Символ технологии обмена
		};
		//
		// Descr: Способы идентификации товаров
		//
		enum {
			wareidentUndef     = 0, // Не определено (по ситуации)
			wareidentById      = 1, // По внутреннему идентификатору
			wareidentByCommId  = 2, // По общему идентификатору из таблицы синхронизации между разделами
			wareidentByArCode  = 3, // По коду товара, ассоциированному со статьей
			wareidentByTag     = 4, // По тегу (тип тега указан в FlatBlock::GoodsTagID)
			wareidentByBarcode = 5  // По штрихкоду (есть неоднозначность в выборе штрихкода: пока полагаемся на GetSingleBarcode)
		};
		LDATE  LastDt;         // Дата последнего обмена
		PPID   GoodsGrpID;     // Группа товаров
		PPID   ExpendOp;       // Вид операции отгрузки
		PPID   RcptOp;         // Операция прихода
		PPID   SupplRetOp;     // Операция возврата поставщику
		PPID   RetOp;          // Операция возврата от покупател
		PPID   MovInOp;        // Перемещение со склада (расход)
		PPID   MovOutOp;       // Перемещение на склад (приход)
		PPID   PriceQuotID;    // Котировка по которой будем назначать цену в документах
		uint32 ProtVer;        // Версия протокола обмена
		struct FlatBlock {
			PPID   DefUnitID;      // 
			PPID   SequenceID;     // Внутренний счетчик для автоматической нумерации запросов
			PPID   CliCodeTagID;   // Тег персоналии для кода в терминах поставщика
			PPID   LocCodeTagID;   // Тег локации для кода в терминах поставщика
			PPID   StyloPalmID;    // Ссылка на запись группы устройств для получения некоторых атрибутов
				// Не смотря на то, что обмен с поставщиком не задействует непосредственно устройства StyloAgent,
				// функцинонально он может обеспечивать аналогичных набор сервисов. Соответственно, логично будет
				// не дублировать здесь атрибуты аналогичные StyloAgent, но сделать специальную запись StyloAgent
				// и администрировать такие атрибуты там.
			PPID   BillAckTagID;   // Тег документа, свидетельствующий о том, что он был передан поставщику.
				// Имеется в виду, как правило, документ продажи покупателю (возврата от покупателя) подукции
				// этого поставщика. Тип этого тега - строка или GUID. В качестве значения - какой-либо идентификатор,
				// присвоенный системой поставщика документу.
			PPID   GoodsTagID;     // Тег идентификации товара у контрагента
			uint8  NativeGIdType;  // wareidentXXX Наша идентификации товара
			uint8  ForeignGIdType; // wareidentXXX Идентификации товара для контрагента
			uint8  FbReserve[2];   // @reserve
		} Fb;                      // @anchor
        InetAddr ConnAddr;         // Адрес для соединения с сервером
        ObjIdListFilt DebtDimList; // Список долговых размерностей, по которым необходимо отчитываться о долгах контрагентов
		ObjIdListFilt WhList;      // Список складов, по которым строятся отчеты
	private:
		int    Helper_SerializeCommon(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    Serialize_(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    Serialize_Before_v9103_(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    Serialize_Before_v9905_(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		SString ExtString;
	};
	//
	// Descr: Параметры расчета заказа поставщику
	//
	struct OrderParamEntry { // @flat
		OrderParamEntry();
		int    FASTCALL IsEq(const OrderParamEntry & rS) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		PPID   GoodsGrpID;       // ->Goods2.ID
		PPID   LocID;            // ->Location.ID
		PPID   MngrID;           // ->Person.ID Менеджер, закрепленный за этой группой закупки
		int16  OrdPrdDays;       // Период для расчета заказа поставщику при автоматическом формировании документов заказа поставщику (дней)
		int16  Reserve;          // @alignment
		DateRepeating Dr;        // Периодичность заказа
		struct FlatBlock {
			int16  DuePrdDays;    // Период исполнения заказа поставщиком (дней)
			uint8  FbReserve[30]; // @reserve
		} Fb;                     // @anchor
	};

	int    SearchOrderParamEntry(const PPSupplAgreement::OrderParamEntry & rKey, int thisPos, uint * pFoundPos) const;
	int    SetOrderParamEntry(int pos, PPSupplAgreement::OrderParamEntry & rEntry, uint * pResultPos);

	SVerT  Ver;             // Версия системы, создавшей экземпляр
	PPID   SupplID;
	long   Flags;
	LDATE  BegDt;
	LDATE  Expiry;
	int16  DefPayPeriod;     // Количество дней от отгрузки до оплаты по умолчанию
	int16  InvPriceAction;   // Действие при неверной цене
	int16  DefDlvrTerm;      // Срок доставки товара в днях, начиная с даты документа закупки
	int16  PctRet;           // Максимальный объем возврата товара по накладной в процентах от суммы накладной //
	int16  Reserve_opd;      //
	int16  Reserve;          //
	PPID   DefAgentID;       // Агент, закрепленный за поставщиком
	PPID   CostQuotKindID;   // ! Вид котировки, управляющей контрактными ценами поставщиков
	PPID   PurchaseOpID;     // ! Вид операции закупки (драфт-приход)
	PPID   DevUpQuotKindID;  // ! Вид котировки, ограничивающий верхнюю границу отклонения фактических цен от контрактных
	PPID   DevDnQuotKindID;  // ! Вид котировки, ограничивающий нижнюю границу отклонения фактических цен от контрактных
	PPID   MngrRelID;        // ! Тип отношения, определяющий привязку поставщиков к менеджерам
	DateRepeating Dr;
	struct FlatBlock {
		uint8  FbReserve[32]; // @reserve
	} Fb;
	ExchangeParam Ep;        // @anchor
	TSVector <OrderParamEntry> OrderParamList;
};
//
//
//
class ArticleCore : public ArticleTbl {
public:
	ArticleCore();
	int    Add(PPID * pID, void *, int use_ta);
	int    Update(PPID, const void * pRec, int use_ta);
	int    Remove(PPID, int use_ta);
	int    Search(PPID, void * = 0);
	int    SearchName(PPID accSheetID, const char * pName, void * = 0);
	int    EnumBySheet(PPID sheetID, long * pArticleNo, void * = 0);
	int    GetListBySheet(PPID accSheetID, PPIDArray * pList, long * pCount);
	int    GetListByGroup(PPID grpArID, PPIDArray * pList);
	int    Count(PPID accSheetID, long * pCount);
	//
	// Descr: Если в функции SearchNum параметр articleNo равен 0, то
	//   ищется первая статья для таблицы accSheetID.
	//
	int    SearchNum(PPID accSheetID, long articleNo, ArticleTbl::Rec * pRec = 0);
	int    SearchFreeNum(PPID accSheetID, long * pArticleNo, ArticleTbl::Rec * pRec = 0);
	int    SearchObjRef(PPID accSheetID, PPID objID, ArticleTbl::Rec * pRec = 0);
	bool   PersonToArticle(PPID personID, PPID accSheetID, PPID * pArID);
	int    LocationToArticle(PPID personID, PPID accSheetID, PPID * pArID);
private:
	int    _SearchNum(PPID accSheetID, long articleNo, int spMode, ArticleTbl::Rec * pRec = 0);
};
//
// Descr: Вспомогательная структура для обработки сумм документа
//
struct AmtEntry { // @persistent
	AmtEntry();
	explicit AmtEntry(PPID amtTypeID);
	AmtEntry(PPID amtTypeID, PPID curID);
	AmtEntry(PPID amtTypeID, PPID curID, double amt);
	bool   FASTCALL IsEq(const AmtEntry & rS) const;

	PPID   AmtTypeID; // ->Ref(PPOBJ_AMOUNTTYPE)
	PPID   CurID;     // ->Ref(PPOBJ_CURRENCY)
	double Amt;
};

class AmtList : public TSVector <AmtEntry> { // @persistent
public:
	AmtList();
	AmtList & FASTCALL operator = (const AmtList &);
	bool   Search(PPID amtTypeID, PPID curID, uint * pPos) const;
	bool   FASTCALL HasAmtTypeID(PPID amtTypeID) const;
	bool   FASTCALL HasVatSum(const TaxAmountIDs * pTai) const;
	bool   FASTCALL IsEq(const AmtList &) const;
	//
	// Descr: возвращает список валют, для которых существует
	//   сумма amtTypeID в списке сумм. Если amtTypeID < 0, то возвращаетс
	//   список всех валют, которые присутствуют в списке сумм.
	//
	int    GetCurList(PPID amtTypeID, PPIDArray *) const;
	int    GetAmtTypeList(PPIDArray *) const;
	int    Get(PPID amtTypeID, PPID curID, double *) const;
	double Get(PPID amtTypeID, PPID curID) const;
	int    Put(PPID amtID, PPID curID, double, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    Put(const AmtEntry *, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    Put(const AmtList  *, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    Add(PPID amtID, PPID curID, double, int ignoreZero = 1);
	int    Add(const AmtEntry *, int ignoreZero = 1);
	int    Add(const AmtList  *, int ignoreZero = 1);
	int    Sub(const AmtEntry *, int ignoreZero = 1);
	int    Sub(const AmtList  *, int ignoreZero = 1);
	//
	// If curID < 0, then removed amounts with id amtTypeID by all currencies
	//
	int    Remove(PPID amtTypeID, PPID curID);
};
//
// Descr: Сумма, связанная со штатной должностью либо штатным назначением.
//   Отличается от AmtEntry наличием периода действия.
//
struct StaffAmtEntry { // @flat
	DECL_INVARIANT_C();
	explicit StaffAmtEntry(PPID amtTypeID = 0, PPID curID = 0, double amt = 0.0);
	int    FASTCALL IsEq(const StaffAmtEntry & rS) const;

	PPID   AmtTypeID; // ->Ref(PPOBJ_AMOUNTTYPE)
	PPID   CurID;     // ->Ref(PPOBJ_CURRENCY)
	DateRange Period; // Период действия суммы
	double Amt;
};
//
// Descr: Список штатных сумм
//
class StaffAmtList : public TSVector <StaffAmtEntry> {
public:
	StaffAmtList();
	int    FASTCALL IsEq(const StaffAmtList & rS) const;
	int    Search(PPID amtTypeID, PPID curID, LDATE dt, uint * pPos) const;
	int    Search(PPID amtTypeID, uint * pPos) const;
	//
	// Descr: Ищет в списке запись по критериям {amtTypeID, curID, dt}. Если находит,
	//   то по адресу pAmount присваивает значение суммы из найденного элемента.
	//   Если не находит, то по указателю pAmount присваивает 0.
	// Returns:
	//   >0 - искомый элемент найден
	//   <0 - искомый элемент не найден (*pAmount = 0)
	//   0  - ошибка (*pAmount = 0)
	//
	int    Get(PPID amtTypeID, PPID curID, LDATE dt, double * pAmount) const;
	int    CheckDup(int pos, const StaffAmtEntry *) const;
	int    Add(const StaffAmtEntry *);
	int    Put(uint pos, const StaffAmtEntry *);
};
//
// CCheckPacket
//
class CCheckLineArray : public TSVector <CCheckLineTbl::Rec> { // @v12.3.4 typedef-->class
public:
	CCheckLineArray();
	int   EvaluateVatAmounts(BVATAccmArray & rResult) const;
};

class CTableOrder {
public:
	struct Packet {
		Packet();
		void   Init(PPID posNodeID, LDATETIME initDtm, long initDuration);
		//
		PPID   PosNodeID;     // Ид кассового узла
		PPID   ChkID;         // Ид чека заказа
		long   CcNo;          // Номер чека заказа
		LDATETIME CcDtm;      // Дата/время чека заказа
		int16  TableNo;       // Номер стола
		int16  Status;        // 0 - открытый заказ, -1 - отмененный заказ, 1 - закрытый заказ
		PPID   SCardID;       // Ид кредитной карты, на которую начисляется сумма предоплаты
		double PrepayAmount;  // Сумма предоплаты
		STimeChunk Chunk;     // Период начала и завершения заказанного посещения.
		SString Memo;         // @memo
	};
	struct Param { // @persistent
		Param();
		int    Serialize(int dit, SBuffer & rBuf, SSerializeContext * pCtx);

		enum {
			fShowTimeGraph = 0x0001
		};

		long   Ver;
		PPID   PosNodeID;
		LDATETIME StartTime;
		long   InitDuration;
		long   Flags;
		long   TableNo;
		uint8  Reserve[32];
	};

	static int ShowTimeGraph(PPID posNodeID, int modeless);

	CTableOrder();
	~CTableOrder();
	int    HasRight(long rt);
	int    Edit(Packet * pPack);
	int    EditParam(Param * pParam);
	int    Create(const Param * pParam);
	int    Update(const Packet * pPack, int use_ta);
	int    Cancel(PPID ordCheckID);
	int    Print(const Packet * pPack);
	int    CheckTableBusyStatus(long tableNo, const STimeChunk & rChunk);
	int    GetCheck(PPID chkID, Packet * pPack);
	int    GetCheck(const CCheckTbl::Rec * pCcRec, const CCheckExtTbl::Rec * pCcExtRec, Packet * pPack);
	int    GetSCard(PPID scardID, SCardTbl::Rec * pScRec);
	int    SetupGrid(PPID posNodeID);
	int    UpdateGridItem(long tableNo, PPID checkID, const STimeChunk & rNewChunk);
private:
	int    MakeCCheckPacket(const Packet * pPack, CCheckPacket * pCcPack);
	enum {
		stRtUndef = 0x0001,
		stRtAll   = 0x0002
	};
	Packet P;
	long   State;
	PPObjSCard * P_ScObj;
	PPObjCashNode * P_CnObj;
	STimeChunkGrid * P_Grid;
};
//
// Descr: Смещение значения CCheckLineTbl::Rec::DivID, индицирующее признак того, что строка
//   была уже отправлена на кухонный принтер.
//
#define CHECK_LINE_IS_PRINTED_BIAS   10000
//
// Descr: Флаги элемента CCheckItem
//
enum {
	cifIsPrinted     = 0x0001, // Строка напечатана
	cifGift  = 0x0002, // Товар в строке является подарком
	cifUsedByGift    = 0x0004, // По строке был предоставлен подарок
	cifQuotedByGift  = 0x0008, // Подарок по строке был предоставлен в виде котировочной цены
		// @#{!cifQuotedByGift || cifUsedByGift}
	cifGrouped       = 0x0010, // Строка сгруппирована с предыдущей в списке
	cifPartOfComplex = 0x0020, // Строка является частью комплексного товара
	cifBySCard       = 0x0040, // Строка сгенерирована автоматически по факту установки карты.
		// (Карта имеет ненулевое значение SCardTbl::Rec::AutoGoodsID)
	cifPriceBySerial = 0x0080, // Цена на строку установлена по серийному номеру.
	cifGiftDiscount  = 0x0100, // Строка предоставляет подарочную суммовую скидку (по котировке PPQUOTK_GIFT).
		// При формировании окончательного чека сумма по этой строке полностью обнуляется а скидка разносится на весь чек.
	cifMainGiftItem  = 0x0200, // @#{!cifMainGiftItem || cifUsedByGift} Строка соответствует основному
		// компоненту подарочной структуры
	cifModifier      = 0x0400,  // Элемент является модификатором предшествующего элемента, не имеющего
		// такого признака (элемент может иметь несколько модификаторов, следующих один за другим).
	cifManualGift    = 0x0800, // @#{!cifManualGift || cifGift} Подарочная позиция была выбрана в ручную.
		// Позиции с таким признаком обрабатываются специальным образом, дабы не заставлять пользователя по-новой
		// выбирать один и тот же подарок много раз.
	cifHasModifier   = 0x1000, // Специальный избыточный флаг, идентифицирующий позицию, к которой привязан модификатор
		// Устанавливается при печати во временную структуру.
	cifFixedPrice    = 0x2000, // Цена по строке не должна пересчитываться при общем пересчете чека
		// Флаг введен в ответ на новую технику обработки чеков при которой все цены по строкам пересчитываются
		// по текущим ценам при внесении каких-либо изменений в чек.
	cifCzMarkCode    = 0x4000  // Товар идентифицирован по марке ЧестныйЗнак
};
//
// Descr: Специализированная структура, используемая для унифицированного
//   представления строки чека в коде системы.
//
struct CCheckItem { // @transient
	CCheckItem();
	CCheckItem & Z();
	CCheckItem & FASTCALL operator = (const CCheckItem & rS);
	CCheckItem & FASTCALL operator = (const CCheckLineTbl::Rec & rS);
	CCheckItem & FASTCALL operator = (const CCheckLineExtTbl::Rec & rS);
	void   GetRec(CCheckLineTbl::Rec & rRec, bool isReturn) const;
	int    GetRec(CCheckLineExtTbl::Rec & rRec) const;
	int    SplitByQtty(double restQtty, CCheckItem & rNewItem);
	double NetPrice() const;
	double GetAmount() const;
	int    SetupGiftQuot(double quot, int forceZero);
	int    ResetGiftQuot();
	bool   CanMerge(const CCheckPacket * pPack, const CCheckItem & rItem) const;

	PPID   GoodsID;         //
	double Quantity;        //
	double PhQtty;          //
	double Price;           //
	double Discount;        //
	double BeforeGiftPrice; // Цена строки, до того как к ней была применена подарочная котировка.
		// Поле имеет значение только в том случае, если Flags & cifQuotedByGift.
	PPID   GiftID;          // Если строка - подарочная, то это - идентификатор структуры, по которой подарок предоставлен.
	long   Flags;           // cifXXX
	int16  Division;        // Номер отдела
	int16  LineGrpN;        // Номер группы строк (используется только для печати и инициируется функцией CheckPaneDialog::InitIteration
	int8   Queue;           // Очередность подачи
	int8   Reserve[1];      // @alignment // @v11.5.8 [3]-->[1]
	int16  RByCheck;        // @v11.5.8 Проекция поля CCheckLineTbl::Rec::RByCheck
	S_GUID ChZnPm_ReqId;        // @v12.1.1 ответ разрешительного режима чзн: уникальный идентификатор запроса
	int64  ChZnPm_ReqTimestamp; // @v12.1.1 ответ разрешительного режима чзн: дата и время формирования запроса
	char   BarCode[24];     //
	char   GoodsName[128];  //
	char   Serial[32];      // 
	char   ChZnGtin[16];    // Gtin код товара, считанный из марки 'честный знак'
	char   ChZnSerial[24];  // Серийный номер маркировки 'честный знак'.
	char   ChZnMark[156];   // Марка 'честный знак'
	char   EgaisMark[156];  // Марка алкогольной продукции ЕГАИС
	char   RemoteProcessingTa[64]; // Идентификатор, подтверджающий удаленную обработку строки
};

typedef TSVector <CCheckItem> CCheckItemArray;
//
// Типы сумм кассовых чеков
//
#define CCAMTTYP_AMOUNT      1 // Общая сумма чека
#define CCAMTTYP_DISCOUNT    2 // Сумма скидки
#define CCAMTTYP_FISCAL      3 // Фискальная сумма
#define CCAMTTYP_NONFISCAL   4 // Нефискальная сумма
#define CCAMTTYP_CASH        5 // Сумма наличными
#define CCAMTTYP_BANK        6 // Сумма, уплаченная через банк
#define CCAMTTYP_CRDCARD     7 // Сумма, зачтенная по корпоративной кредитной карте
#define CCAMTTYP_ADDCRDCARD  8 // Сумма, зачтенная по дополнительной корпоративной кредитной карте
#define CCAMTTYP_COUNT       9 // Количество чеков (используется для итогового суммирования выборки чеков)
#define CCAMTTYP_BANKDSCNT  11 // Скидка по безналичному чеку (используется для итогового суммирования выборки чеков)
#define CCAMTTYP_CSCCHARGE  12 // Специальная сумма, идентифицирующая начисление на кредитную карту по строкам
	// чека, содержащим товар для начисления. Такая сумма не включается в список оплат чека, сохраняемый вместе с чеком
#define CCAMTTYP_NOTE       13 // Сумма, полученная от покупателя (без учета сдачи)
#define CCAMTTYP_DELIVERY   14 // Сумма сдачи, возвращенная покупателю
#define CCAMTTYP_MANDIS     15 // @v11.0.9 Скидка на чек в абсолютном выражении, предоставленная вручную
#define CCAMTTYP_MANPCTDIS  16 // @v11.0.9 Скидка на чек в процентах, предоставленная вручную
	// @#{Один чек не может одновременно иметь ненулевые значения CCAMTTYP_MANDIS и CCAMTTYP_MANPCTDIS}
//
// Invariants:
// CCAMTTYP_FISCAL+CCAMTTYP_NONFISCAL=CCAMTTYP_AMOUNT
// CCAMTTYP_CASH+CCAMTTYP_BANK+CCAMTTYP_CRDCARD=CCAMTTYP_AMOUNT
// CCAMTTYP_ADDCRDCARD < CCAMTTYP_CRDCARD
//

//
// Descr: Сумма по чеку
//
struct CcAmountEntry {
	CcAmountEntry();
	bool   FASTCALL IsEq(const CcAmountEntry & rS) const;
	int    GetTypeText(SString & rBuf) const;

	PPID   CheckID;    // Идентификатор чека. Важен, если собираются однотипные суммы по выборке чеков
	int32  Type;       // CCAMTTYP_XXX
	int32  AddedID;    // Дополнительный идент. Для PaymType == CCAMTTYP_CRDCARD - ид карты
	PPID   CurID;      // Валюта платежа
	double CurAmount;  // Сумма в валюте CurID. Если CurID == 0, то CurAmount == 0.0
	double Amount;     // Величина суммы
};
//
//
//
class CcAmountList : public TSVector <CcAmountEntry> {
public:
	CcAmountList();
	CcAmountList & Z();
	int    GetSign() const;
	int    Search(int type, int32 addedID, uint * pPos) const;
	int    SearchAddedID(int32 addedID, uint * pPos) const;
	int    Set(int type, double amt, int32 addedID = 0);
	int    Add(int type, double amt, int32 addedID = 0);
	int    Normalize();
	int    InvertSign();
	double ScaleTo(double targetAmount);
	double Replace(int type, double amt, int32 addedID, int r1, int r2);
	double ReplaceDontRemove(int type, double amt, int32 addedID, int r1, int r2);
	double FASTCALL Get(int type) const;
	double Get(int type, LongArray * pAddedIdList) const;
	double Get(int type, int32 addedID) const;
	//
	// Descr: Возвращает сумму оплат по бонусным картам.
	// ARG(pScObj IN): Указатель на 'кземпляр объекта PPObjSCard, используемый
	//   для получения информации о приндалежности платежных карт бонусным сериям.
	//   Если pScObj == 0, то функция создаст собственный 'кземпляр PPObjSCard, однако такой
	//   вариант скажется на производительности (создание объекта PPObjSCard может быть дорогим).
	//
	double GetBonusAmount(PPObjSCard * pScObj) const;
	double GetTotal() const;
private:
	int    Implement_Set(int type, double amt, int32 addedID, int replace, int dontRemove);
	double Implement_Replace(int type, double amt, int32 addedID, int dontRemove, int r1, int r2);
};
//
// Descr: Идентификатор текстовых свойств чека, по которому хранятся текстовые расширения строк чека.
// <101>......<202>......<1001>.....<1003>..<1302>
// 1-я строка 2-я строка 10-я строка        13-я строка
// Значение, деленное на 100 - номер свойства строки
//
#define PPTRPROP_CC_LNEXT (PPTRPROP_USER+1)

class CCheckPacket : public PPExtStrContainer {
public:
	struct LineExt { // @transient
		enum {
			fGroup         = 0x01,
			fModifier      = 0x02,
			fPartOfComplex = 0x04,
			fQuotedByGift  = 0x08,
			fFixedPrice    = 0x10
		};
		LineExt();
		bool   IsEmpty() const;

		uint32 ItemIdx;    // Индекс позиции (+1) в Items_
		int8   Queue;
		uint8  Flags;      // @flags
		uint8  Reserve[2]; // @alignment
	};
	struct BuersEAddr_ { // @v11.8.11
		BuersEAddr_();
		BuersEAddr_(const BuersEAddr_ & rS);
		BuersEAddr_ & FASTCALL operator = (const BuersEAddr_ & rS);
		BuersEAddr_ & Z();
		bool   IsEmpty() const;
		int    SetEMail(const char * pEAddr);
		int    SetPhone(const char * pEAddr);
		int    GetEMail(SString & rBuf) const;
		int    GetPhone(SString & rBuf) const;

		int    AddrType;  // Тип электронного адреса покупателя BuyersEAddr (0 || SNTOK_PHONE || SNTOK_EMAIL)
		SString EAddr;    // Электронный адрес покупателя (email or phone)
	};
	//
	// Признаки способа расчета. Используются для печати чека, собственно в Papyrus'е не применяются.
	// Тупость классификации полностью обусловленна тупостью российских органов власти.
	// Числовая идентификация признаков совпадает с таковой для кассовых аппаратов ДримКас (Пирит, Viki-Print)
	// и для драйвера торгового оборудования АТОЛ на 12 апреля 2019 года.
	//
	enum PaymentTermTag {
		pttUndef          = 0, // PTT_UNDEF
		pttFullPrepay     = 1, // PTT_FULL_PREPAY    Предоплата 100% (Полная предварительная оплата до момента передачи предмета расчета)
		pttPrepay         = 2, // PTT_PREPAY         Предоплата (Частичная предварительная оплата до момента передачи предмета расчета)
		pttAdvance        = 3, // PTT_ADVANCE        Аванс
		pttFullPayment    = 4, // PTT_FULLPAYMENT    Полный расчет (Полная оплата, в том числе с учетом аванса (предварительной оплаты) в момент передачи предмета расчета)
		pttPartial        = 5, // PTT_PARTIAL        Частичный расчет и кредит (Частичная оплата предмета расчета в момент его передачи с последующей оплатой в кредит)
		pttCreditHandOver = 6, // PTT_CREDITHANDOVER Передача в кредит (Передача предмета расчета без его оплаты в момент его передачи с последующей оплатой в кредит)
		pttCredit         = 7  // PTT_CREDIT         Оплата кредита (Оплата предмета расчета после его передачи с оплатой в кредит (оплата кредита))
	};

	enum SubjTermTag { // @erik
		sttUndef                  = 0, // STT_UNDEF
		sttGood                   = 1, // STT_GOOD    о реализуемом товаре, за исключением подакцизного товара(наименование и иные сведения, описывающие товар)
		sttExcisableGood          = 2, // STT_EXCISABLEGOOD    о реализуемом подакцизном товаре(наименование и иные сведения, описывающие товар)
		sttExecutableWork         = 3, // STT_EXECUTABLEWORK   о выполняемой работе(наименование и иные сведения, описывающие работу)
		sttService                = 4, // STT_SERVICE   об оказываемой услуге(наименование и иные сведения, описывающие услугу)
		sttBetting                = 5, // STT_BETTING   о приеме ставок при осуществлении деятельности по проведению азартных игр
		sttPaymentGambling        = 6, // STT_PAYMENTGAMBLING   о выплате денежных средств в виде выигрыша при осуществлении деятельности по проведению азартных игр
		sttBettingLottery         = 7, // STT_BETTINGLOTTERY   о приеме денежных средств при реализации лотерейных билетов, электронных лотерейных билетов, приеме лотерейных ставок при осуществлении деятельности по проведению лотерей
		sttPaymentLottery         = 8, // STT_PAYMENTLOTTERY   о выплате денежных средств в виде выигрыша при осуществлении деятельности по проведению лотерей
		sttGrantRightsUseIntellectualActivity = 9,	// STT_GRANTSRIGHTSUSEINTELLECTUALACTIVITY   о предоставлении прав на использование результатов интеллектуальной деятельности или средств индивидуализации
		sttAdvance                = 10, // STT_ADVANCE   об авансе, задатке, предоплате, кредите, взносе в счет оплаты, пени, штрафе, вознаграждении, бонусе и ином аналогичном предмете расчета
		sttPaymentsPayingAgent    = 11, // STT_PAYMENTSPAYINGAGENT   о вознаграждении пользователя, являющегося платежным агентом(субагентом), банковским платежным агентом(субагентом), комиссионером, поверенным или иным агентом
		sttSubjTerm               = 12, // STT_SUBJTERM   о предмете расчета, состоящем из предметов, каждому из которых может быть присвоено значение от «0» до «11»
		sttNotSubjTerm            = 13, // STT_NOTSUBJTERM   о предмете расчета, не относящемуся к предметам расчета, которым может быть присвоено значение от «0» до «12»
		sttTransferPropertyRights = 14, // STT_TRANSFERPROPERTYRIGHTS   о передаче имущественных прав
		sttNonOperatingIncome     = 15, // STT_NONOPERATINGINCOME    о внереализационном доходе(Название товара может принимать значения 1 - 25)
		sttExpensesReduceTax      = 16, // STT_EXPENSESREDUCETAX    о суммах расходов, уменьшающих сумму налога(авансовых платежей) в соответствии с пунктом 3.1 статьи 346.21 Налогового кодекса Российской Федерации(Название товара может принимать значения 26 - 31)
		sttAmountMerchantFee      = 17, // STT_AMOUNTMERCHANTFEE   о суммах уплаченного торгового сбора
		sttResortFee              = 18, // STT_RESORTFEE       о курортном сборе
		sttDeposit                = 19, // STT_DEPOSIT  Залог
	};

	enum { // @persistent
		extssMemo               =  1, // @reserved Примечание
		extssSign               =  2, // Строка подписи чека (ЕГАИС)
		extssEgaisUrl           =  3, // Текст URL информации о чеке ЕГАИС
		extssRemoteProcessingTa =  4, // Символ транзакции удаленной обработки чека
		extssChZnProcessingTag  =  5, // Символ признака передачи чека на сервер честный знак
		extssBuyerINN           =  6, // ИНН покупателя (при формировании чека по документу)
		extssBuyerName          =  7, // Наименование покупателя (при формировании чека по документу)
		extssBuyerPhone         =  8, // Телефон покупателя //
		extssBuyerEMail         =  9, // @v11.3.6 Адрес электронной почты покупателя //
		extssUuid               = 10, // @v11.5.2 UUID чека. Применяется в ограниченном наборе сценариев. Введен ради взаимодействия со Stylo-Q.
		extssPrescrDate         = 11, // @v11.7.12 Дата медицинского рецепта. Сохраняется в формате DATF_ISO8601 без разделителей, eg 20230821
		extssPrescrSerial       = 12, // @v11.7.12 Серия медицинского рецепта
		extssPrescrNumber       = 13, // @v11.7.12 Номер медицинского рецепта
		extssEgaisProcessingTag = 14, // @v11.8.2  Внутренний символ обработки для списания товаров по чеку в ЕГАИС. 
			// Не путать с extssEgaisUrl, являющегося признаком того, что чек отправлен на-прямую в ЕГАИС.
		extssSourceSymb         = 15, // @v11.8.5 Символ внешнего источника происхождения чека
		extssOuterIdent         = 16, // @v11.8.5 Идентификатор чека во внешнем источнике
		extssOuterExtTag        = 17, // @v11.8.5 Дополнительный текстовый тег, поступивший из внешнего источника.
			// Как правило, система трактовать такой тег формальным образом не способна.
		extssLinkBillUuid       = 18, // @v11.8.8 UUID документа, по которому сформирован чек 
		extssFiscalSign         = 19, // @v12.2.8 Фискальный признак чека, присваиваемый ему в ОФД. На текущий момент предполагается, 
			// что этот признак будет по необходимости устанавливаться в чеке в ручную, поскольку механизма автоматического получения //
			// этого признака нет.
		// @attention: После вставки очередного элемента в enum добавьте этот элемент в 
		//   таблицы CCheckExtSsList и CCheckExtNameSymbList ccheck.cpp). 
		//   Иначе этот атрибут не будет сохраняться в чеке.

		// @todo Фискальный признак чека
	};
	//
	// Descr: Идентификаторы текстовых расширений строк чека
	//
	enum { // @persistent
		lnextSerial              = 1, // Серийный номер
		lnextEgaisMark           = 2, // Марка ЕГАИС
		lnextRemoteProcessingTa  = 3, // Символ транзакции удаленной обработки строки. Имеет специальное назначение,
			// сопряженное с предварительной обработкой чека перед проведением через удаленный сервис.
		lnextChZnSerial          = 4, // Серийный номер 'честный знак'
		lnextChZnGtin            = 5, // GTIN считанный из кода 'честный знак'
		lnextChZnMark            = 6, // Марка 'честный знак'
		lnextChZnPm_ReqId        = 7, // @v12.1.1 ответ разрешительного режима чзн: уникальный идентификатор запроса
		lnextChZnPm_ReqTimestamp = 8, // @v12.1.1 ответ разрешительного режима чзн: дата и время формирования запроса
	};
	struct PreprocessChZnCodeResult { // @flat
		PreprocessChZnCodeResult();
		PreprocessChZnCodeResult & Z();
		uint   LineIdx;          // [1..] Индекс строки в чеке
		int    CheckResult;      // tag 2106 Результат проверки КМ в ФН (ofdtag-2106)
			// Номер бита Состояние бита в зависимости от результата проверки КМ и статуса товара
			// 0 "0" - код маркировки не был проверен ФН и (или) ОИСМ
			//   "1" - код маркировки проверен
			// 1 "0" - результат проверки КП КМ отрицательный или код маркировки не был проверен
			//   "1" - результат проверки КП КМ положительный
			// 2 "0" - сведения о статусе товара от ОИСМ не получены
			//   "1" - проверка статуса ОИСМ выполнена
			// 3 "0" - от ОИСМ получены сведения, что планируемый статус товара некорректен или сведения о статусе товара от ОИСМ не получены
			//   "1" - от ОИСМ получены сведения, что планируемый статус товара корректен
			// 4 "0" - результат проверки КП КМ и статуса товара сформирован ККТ, работающей в режиме передачи данных
			//   "1" - результат проверки КП КМ сформирован ККТ, работающей в автономном режиме
			//
		int    Reason;           // Причина того, что КМ не проверен в ФН
			// 0 - КМ проверен в ФН;
			// 1 - КМ данного типа не подлежит проверке в ФН;
			// 2 - ФН не содержит ключ проверки кода проверки этого КМ;
			// 3 - переданный код маркировки не соответствует заданному формату (проверка невозможна, так как отсутствуют теги 91 и/или 92 или их формат неверный, согласно GS1)
			// 4 - внутренняя ошибка в ФН при проверке этого КМ.
		int    ProcessingResult; // tag 2005 Результаты обработки запроса (ofdtag-2005)
			// Номер бита Состояние бита в зависимости от результата проверки КМ и статуса товара
			// 1 "0" - результат проверки КП КМ отрицательный
			//   "1" - результат проверки КП КМ положительный
			// 3 "0" - статус товара некорректен (если реквизит "ответ ОИСМ о статусе товара" (ofdtag-2109) принимает значение "2" или "3")
			//   "1" - статус товара корректен (если реквизит "ответ ОИСМ о статусе товара" (ofdtag-2109) принимает значение "1")
			// 0, 2    Заполняются единицами
			// 4 - 7   Заполняются нулями
		int    ProcessingCode;   // tag 2105 Код обработки запроса (ofdtag-2105)
			// 0 Запрос имеет корректный формат, в том числе корректный формат кода маркировки
			// 1 Запрос имеет некорректный формат
			// 2 Указанный в запросе код маркировки имеет некорректный формат (не распознан)
		int    Status;           // tag 2109 Сведения о статусе товара (ofdtag-2109)
			// 1 Планируемый статус товара корректен
			// 2 Планируемый статус товара некорректен
			// 3 Оборот товара приостановлен
	};
	//
	// Descr: Структура интерфейсного представления параметром фармацевтического рецепта
	//
	struct Prescription { // @v11.7.12
		Prescription();
		Prescription & Z();
		bool   IsValid() const;

		LDATE Dt;
		SString Serial;
		SString Number;
	};
	//
	// Двум следующим классам необходим открытый доступ к полям Items_ и SerialList
	// для сериализации объекта CCheckPacket
	//
	friend class CCheckCore;
	friend class CSessTransmitPacket;
	//
	DECL_INVARIANT_C();
	//
	// Descr: Функция, обеспечивающая централизованный механизм распаковки текстовых расширений чека и его строк.
	//
	static int  Helper_UnpackTextExt(const SString & rBuf, PPExtStrContainer * pSc, StrAssocArray * pList);
	static int  Helper_SetLineTextExt(int pos /*[1..]*/, int lnextId, StrAssocArray & rList, const char * pText);
	static int  Helper_GetLineTextExt(int pos /*[1..]*/, int lnextId, const StrAssocArray & rList, SString & rBuf);
	static int  CopyExtStrContainer(PPExtStrContainer & rDest, const PPExtStrContainer & rSrc, uint flags);
	static int  GetPrescription(const PPExtStrContainer & rEss, Prescription & rP);
	static int  SetPrescription(PPExtStrContainer & rEss, const Prescription & rP);
	static bool GetExtssMnemonic(int extss, SString & rBuf);
	static int  RecognizeExtssMnemonic(const char * pSymb);
	static const SIntToSymbTabEntry * GetExtssNameSymbTab(uint * pTabEntryCount);

	CCheckPacket();
	CCheckPacket(const CCheckPacket & rS);
	~CCheckPacket();
	CCheckPacket & FASTCALL operator = (const CCheckPacket & rS);
	CCheckPacket & Z();
	int    IsEq(const CCheckPacket & rS, long options) const;
	int    FASTCALL Copy(const CCheckPacket & rS);
	//
	// Descr: Возвращает !0 если есть не пустые поля расширения чека (Ext).
	//
	bool   HasExt() const;
	//
	// Descr: Возвращает ид чековой операции CCOP_XXX
	//
	int    GetCcOp() const;
	bool   IsCorrection() const; // @>>GetCcOp
	uint   GetCount() const;
	int    GetGuid(S_GUID & rUuid) const; 
	int    SetGuid(const S_GUID * pUuid);
	int    GenerateGuid(S_GUID & rUuid);
	//
	// Descr: Возвращает параметры рецепта, хранящиеся в чеке.
	// Returns:
	//   > - чек содержит по крайней мере номер рецепта.
	//   0 - чек не содержит параметро рецепта (rP обнуляется вызвом rP.Z())
	//
	int    GetPrescription(Prescription & rP) const;
	int    SetPrescription(const Prescription & rP);
	//
	// Descr: Упаковывает все строки расширения чека и его строк в общую строку для сохранения в базе данных.
	//
	int    PackTextExt(SString & rResult) const;
	CCheckLineTbl::Rec & FASTCALL GetLine(uint pos);
	const  CCheckLineTbl::Rec & FASTCALL GetLineC(uint pos) const;
	bool   EnumLines(uint * pPos, CCheckLineTbl::Rec * pItem, SString * pSerial = 0) const;
	bool   EnumLines(uint * pPos, CCheckItem * pItem) const;
	void   InitLineIteration();
	int    NextLineIteration(CCheckLineTbl::Rec * pItem, SString * pSerial = 0);
	int    RemoveLine_(uint pos);
	int    CopyLines(const CCheckPacket & rS);
	bool   SearchLine(int rByCheck, uint * pPos) const;
	int    SetLineTextExt(int pos/*[1..]*/, int lnextId, const char *);
	int    GetLineTextExt(int pos/*[1..]*/, int lnextId, SString & rBuf) const;
	bool   HasAnyLineTextExt(int pos/*[1..]*/) const;
	int    SetLineExt(int pos /*[1..]*/, const LineExt & pExt);
	int    GetLineExt(int pos /*[1..]*/, LineExt & rExt) const;
	int    SetLineChZnPreprocessResult(int pos /*[1..]*/, const PreprocessChZnCodeResult * pResult); // @v11.1.11
	const  PreprocessChZnCodeResult * GetLineChZnPreprocessResult(int pos /*[1..]*/) const; // @v11.1.11
	//
	// Descr: Объединяет позиции, у которых одинаковые идентификаторы товаров
	// Note: В дальнейшем критерии объединения будут усложнены.
	//
	int    MergeLines(long /*options*/);
	void   ClearLines();
	int    InsertItem_(const CCheckLineTbl::Rec *, const char * pSerial = 0, const char * pEgaisMark = 0);
	int    InsertItem(PPID goodsID, double qtty, double price, double dscnt, short div = 0, int isPrinted = 0);
	int    InsertItem(const CCheckItem & rItem);
	double FASTCALL GetItemAmount(const CCheckLineTbl::Rec & rItem) const;
	double FASTCALL GetItemDiscount(const CCheckLineTbl::Rec & rItem) const;
	int    SetupPaymList(const CcAmountList * pList);
	//
	// Descr: Флаги функции SetTotalDiscount
	//
	enum {
		stdfPctDis      = 0x0001, // Параметр dis задает размер скидки в процентах. Иначе - абсолютное значение.
		stdfPlus        = 0x0002  // Скидка увеличивает сумму чека
	};
	void   SetTotalDiscount__(double dis, long flags);
	void   CalcAmount(double * pAmt, double * pDscnt) const;
	//
	// Descr: Расчитывает суммы чека по строкам и устанавливает их в поля Rec.Amount и Rec.Discount.
	//   Если вызывающая функция нуждается в значениях рассчитанных сумм, то она
	//   может передать указатели pAmt и (или) pDscnt.
	//
	void   SetupAmount(double * pAmt, double * pDscnt);
	double GetFiscalAmount() const;
	int    HasNonFiscalAmount(double * pFiscal, double * pNonFiscal) const;
	int    SetDlvrAddr(const LocationTbl::Rec * pRec);
	const  LocationTbl::Rec * GetDlvrAddr() const;

	struct BarcodeIdentStruc {
		int    Prefix;
		long   PosId;
		long   CcCode;
	};

	SString & MakeBarcodeIdent(SString & rBuf) const;
	static int ParseBarcodeIdent(const char * pIdent, BarcodeIdentStruc * pResult);
	CcAmountList & AL() { return CcAl; }
	const CcAmountList & AL_Const() const { return CcAl; }
	int   EvaluateVatAmounts(BVATAccmArray & rResult) const { return Items_.EvaluateVatAmounts(rResult); } // @v12.3.4
	//
	// Descr: Специальный метод, обходящий приватность строк с целью корректировки идентификатора товара в записи строки.
	//
	int    _SetLineGoodsID(uint lineIdx/*[0..]*/, PPID goodsID);
	int    SetSCardSpecialTreatmentIdentifyReplyBlock(const void * pStirb);
	int    GetSCardSpecialTreatmentIdentifyReplyBlock(void * pStirb) const;

	enum {
		ufCheckInvariant = 0x0001, // Функция CCheckCore::TurnCheck не допускает проведение пакета,
			// если он не проходит тест CCheckPacket::InvariantC.
			// @v8.4.2 Начиная с релиза 8.4.2 блокировка на проведение чека снимается, но в журнале pperror.log
			// отмечается информация об ошибке в чеке.
		//ufSkipUhtt       = 0x0002  // Функция CCheckCore::TurnCheck не проводит операции по картам через сервер Universe-HTT
		ufSkipScSpcTrt   = 0x0002, // Функция CCheckCore::TurnCheck не проводит операции по картам через внешние сервисы
	};
	long   UpdFlags;       // @transient ufXXX Флаги, определяющие правила изменения пакета
	int    PrintPtt;       // @transient pttXXX Признак способа расчета, применяемый при печати чека (отдельные строки могут переопределять это значение).
	int    PctDis;         // @transient if !0 - then Discount in percent
	double Discount;       // @transient
	double _Cash;          // @transient Сумма, уплаченная наличными
	double _OrdPrepay;     // @transient @!CheckPaneDialog::GetCheckInfo() Сумма предоплаты по заказу. Заполняется для чека заказа и для чека, связанного с заказом.
	CCheckExtTbl::Rec Ext; // @transient Расширение записи чека
	CCheckTbl::Rec Rec;    //
private:
	int    Helper_PackLineTextExt(SString & rResult) const;
	int    UnpackTextExt(const SString & rBuf);

	CCheckLineArray Items_; //
	TSVector <LineExt> ExtList;
	CcAmountList CcAl;      // Список оплат по чеку. Используется только, если по чеку было более одного типа оплаты. Например: безналичная оплата + доплата наличными.
	//
	// Серийные номера храняться в виде ассоциаций {position, serial}.
	// position - позиция соответствующей строки в Items_ плюс 1.
	// То есть, серия для первой строки (индекс 0) хранится с номером 1.
	//
	StrAssocArray LnTextList;
	LocationTbl::Rec * P_DlvrAddr; // @transient
	void * P_Stirb; // @transient (SCardSpecialTreatment::IdentifyReplyBlock *)
	TSVector <PreprocessChZnCodeResult> * P_PpChZnCodeResultList; // @v11.1.11 @transient
};
//
// Package Declarations
//
#define PCKGF_UNIQUECODE 0x0001 // Код пакета, в соответствии с типом пакета, должен быть уникальным
#define PCKGF_MOUNTED    0x0002 // Пакет собран из существующих лотов
	// В этом случае используются сдвоенные операции перемещения товара, аналогичные межскладской передаче.
#define PCKGF_SERIALCODE 0x0004 // Серийный номер лота. Пакет привязан к одному лоту и не содержит элементов.
#define PCKGF_MIRROR     0x0008

class LPackage : private SVector {
public:
	LPackage();
	LPackage & FASTCALL operator = (const LPackage &);
	void   Init();
	int    FASTCALL Copy(const LPackage &);
	int    GetLotIDList(PPIDArray *) const;
	int    SearchByID(PPID, int * pIdx) const;
	int    SearchByIdx(int, PPID *) const;
	int    AddLotIDList(const PPIDArray *);
	int    AddItem(PPID lotID, int idx);
	int    RemoveByID(PPID lotID);
	int    RemoveByIdx(int idx);
	int    EnumItems(uint * pI, int * pIdx, PPID * pID) const;
	int    UpdateItem(uint i, int, PPID);
	int    FASTCALL ShiftIdx(int idx);

	PPID   ID;         //
	//
	// При передаче пакета на другой склад меняется его идентификатор
	// (так как он становится собственностью лота, образованного в результате межскладской передачи).
	// Для правильной идентификации пакета, при изменении его функцией PackageCore::PutPckg,
	// используется поле PrevID. Поле PrevID инициализируется функцией PPBillPacket::InitPckg.
	//
	PPID   PrevID;     //
	PPID   PckgTypeID;
	PPID   LocID;
	char   Code[16];
	int16  Closed;
	int16  UniqCntr;
	long   Flags;
	int16  PckgIdx;
	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
};

class LPackageList : public SCollection {
public:
	LPackageList();
	~LPackageList();
	int    Add(const LPackage *);
	int    ShiftIdx(int16);
	int    RemoveByIdx(int16);
	LPackage * GetByID(PPID);
	LPackage * GetByIdx(int16);
	int    EnumItems(uint *, LPackage **);
	int    CheckCodeUnique(PPID pckgTypeID, const char *, int pos);
private:
	virtual	void FASTCALL freeItem(void *);
};

struct PckgFilt {
	PPID   PckgTypeID;
	PPID   GoodsID;
	PPID   LocID;
};

class PackageCore : public PackageTbl {
public:
	PackageCore();
	int    Search(PPID, PackageTbl::Rec *);
	int    SearchPrev(PPID prevID, PackageTbl::Rec *);
	int    GetPckg(PPID, LPackage *);
	int    PutPckg(PPID, const LPackage *, int use_ta);
	int    SetClosedTag(PPID, int, int use_ta);
	int    GetPckgLinkList(PPID, PPIDArray *);
	int    GetLotLink(PPID lotID, PPID * pPckgID, PackageTbl::Rec * = 0);
	int    AddPckgLink(PPID pckgID, PPID lotID);
	int    RemovePckgLink(PPID pckgID, PPID lotID);
	int    SearchByCode(PPID pckgTypeID, const char * pCode, PPIDArray *);
	int    CheckCodeUnique(PPID pckgTypeID, PPID pckgID, const char *, long * pCntr);
	int    AdjustUniqCntr(PackageTbl::Rec *);
private:
	PackageLinkTbl PL;
};
//
// Флаги товарных проводок
//
#define PPTFR_RECEIPT      0x00000001L // Строка генерирует запись лота
#define PPTFR_UNITEINTR    0x00000002L // Межскладскую передачу проводить одним документом по обоим складам
#define PPTFR_SELLING      0x00000004L // Операция в ценах реализации, иначе в ценах поступления //
#define PPTFR_CORRECTION   0x00000008L // Строка принадлежит корректирующему документу
//
// Временный флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
// изменить признак Closed лота и установить (снять) флаг LOTF_CLOSEDORDER
//
#define PPTFR_CLOSEDORDER  0x00000010L
#define PPTFR_LOTSYNC      0x00000020L // Строка документа, принятого из другого раздела и синхронизированная с ним по LotID
#define PPTFR_REVAL        0x00000040L // Признак переоценки
//
// Флаг PPTFR_ONORDER проставляется в строке товарного документа на продажу товара если эта строка покрывает
// (частично, полностью, либо перекрывает) строку ордера. При этом в структуре PPTransferItem
// используется поле OrdLotID (CorrLoc считается равным нулю).
//
#define PPTFR_ONORDER      0x00000080L
#define PPTFR_ORDER        0x00000100L // Строка заказа. При этом GoodsID < 0 и строка порождает лот (Flags & PPTFR_RECEIPT).
#define PPTFR_SHADOW       0x00000200L // Проставляется в строках теневого документа. При этом GoodsID < 0.
#define PPTFR_PARTSTRUSED  0x00000400L // К строке была применена частичная структура
//
// Флаг PPTFR_FORCESUPPL при определении поставщика для генерируемого лота
// заставляет считаться с полем PPTransferItem::Suppl, установленным до
// вызова PPObjBill::TurnPacket или PPObjBill::UpdatePacket. Если этот
// флаг не установлен, то функция PPTransferItem::InitBillConstrains, при определенных условиях,
// может инициализировать поле PPTransferItem::Suppl в значение BillTbl::Rec::Object.
//
#define PPTFR_FORCESUPPL   0x00000800L
#define PPTFR_UNLIM        0x00001000L // Неограниченный ресурс
#define PPTFR_ODDGOODS     0x00002000L // Товар нестандартного типа
//
// Два взаимоисключающих флага. Соответствуют приходу и расходу товара
// соответственно. До @v1.10.1 знак поля Quantity однозначно определялс
// видом операции (т.е. все строки одного документа имели это поле одного
// знака). С вводом операции модификации товаров один документ может
// содержать строки с положительным и отрицательным полем Quantity.
// Ради сохранения обратной совместимости придется обрабатывать ситуацию,
// когда оба флага не установлены, однако, начиная с @v1.10.1 эти флаги
// обязательно будем устанавливать во всех строках (если конечно строка
// влечет изменение остатка).
//
// Устанавливаться эти флаги должны только функциями инициализации:
//  PPTransferItem::PPTransferItem, PPTransferItem::Init,
//  PPTransferItem::InitShadow.
// Правильнее всего для выяснения знака будет пользоваться функцией
// PPTransferItem::GetSign().
//
#define PPTFR_PLUS         0x00004000L // Поступление товара
#define PPTFR_MINUS        0x00008000L // Расход товара
//
// @v1.10.1 Модификация товара.
// @v3.9.10 См. примечание к PPTFR_PCKG
// @v4.0.11 См. примечание к PPTFR_ASSETEXPL
//
#define PPTFR_MODIF        0x00010000L
#define PPTFR_AUTOCOMPL    0x00020000L // Автокомплектация //
//
// Флаг PPTFR_QUOT устанавливается тогда, когда цена (вместе со скидкой)
// строки указана по котировке. В этом случае установка общей скидки на
// документ не влечет изменение чистой цены (Price - Discount) по этой строчке.
//
#define PPTFR_QUOT         0x00040000L // Цена установлена по котировке
	// Если установлены одновременно флаги PPTFR_QUOT | PPTFR_RECEIPT, то это означает,
	// что на строку установлена цена реализации по расценке
#define PPTFR_RMVEXCISE    0x00080000L // Со строчки скидкой снят акциз
#define PPTFR_ACK          0x00100000L // Подтверждение
#define PPTFR_NODISCOUNT   0x00200000L // На строку не распространяется общая скидка
#define PPTFR_COSTWOVAT    0x00400000L // Цена поступления задана без НДС
#define PPTFR_COSTWSTAX    0x00800000L // Цена поступления задана с налогом с продаж
//
// @v3.3.4  Package operation (if PPTFR_RECEIPT, then generates package)
// @v3.9.10:
// Если флаги PPTFR_PCKG и PPTFR_MODIF установлены одновременно, то
// это означает операцию формирования пакета из существующих остатков
// (то есть в расходной операции). При этом функция PPTransfer::Init()
// устанавливает флаг PPTFR_RECEIPT и (посредством функции PPTransferItem::SetSignFlags) PPTFR_PLUS.
// В этом случае компоненты пакета получают признак PPTFR_UNITEINTR
// и генерируют зеркальные операции для присвоения пакету лотов.
//
#define PPTFR_PCKG         0x01000000L
#define PPTFR_PCKGGEN      0x02000000L // Row of component of package
#define PPTFR_FIXMODIFCOST 0x04000000L // Цена поступления строки модификации фиксирована.
	// Для такой строки не осуществляется пересчет цены поступления //
#define PPTFR_INDEPPHQTTY  0x08000000L // Строка учитывает операцию в торговых и в физических единицах независимо
#define PPTFR_PRICEWOTAXES 0x10000000L // Цена реализации задана без налогов
#define PPTFR_DRAFT        0x20000000L // Строка draft-операции
//
// Ввод в экплуатацию основных фондов.
// Может присутствовать только в:
// - приходе основных средств (PPOPT_GOODSRECEIPT; subtype = OPSUBT_ASSETRCV)
// - переоценке (PPOPT_GOODSREVAL; subtype = OPSUBT_ASSETEXPL).
// Если одновременно установлены флаги (PPTFR_REVAL | PPTFR_ASSETEXPL | PPTFR_MODIF)
// то это означает вывод из эксплуатации объекта основных средств
//
#define PPTFR_ASSETEXPL    0x40000000L
//                         0x80000000L // Reserved
//
//
// Будем различать следующие виды сумм элемента PPTransferItem
//
#define TIAMT_UNDEF              0 // @v12.2.4 undefined 
#define TIAMT_COST               1 // Cost * Quantity
#define TIAMT_PRICE              2 // NetPrice() * Quantity
#define TIAMT_AMOUNT             3 // CalcAmount()
#define TIAMT_ASSETEXPL          4 // Ввод основных средств в эксплуатацию (используется в функции PPTransferItem::CalcTI)
//
// Флаги функции PPTransferItem::SetupLot
//
#define TISL_IGNCOST        0x0001 // Не присваивать цену поступления лота
#define TISL_IGNPRICE       0x0002 // Не присваивать цену реализации лота
#define TISL_ADJPRICE       0x0004 // Выравнивать скидкой существующую цену реализации
#define TISL_IGNPACK        0x0008 // Не присваивать емкость упаковки
#define TISL_IGNQCERT       0x0010 // Не присваивать сертификат
#define TISL_IGNEXPIRY      0x0020 // Не присваивать срок годности
//
// Флаги функции PPTransferItem::SetupGoods
//
#define TISG_SETPWOTF       0x0001 // Выставлять при необходимости флаг PPTFR_PRICEWOTAXES
//
// Значения параметра forceSign функции PPTransferItem::SetSingFlags (а также,
// PPTransferItem::PPTransferItem, PPTransferItem::Init).
//
#define TISIGN_PLUS          1
#define TISIGN_MINUS        -1
#define TISIGN_UNDEF         0
#define TISIGN_RECOMPLETE 1000
#define TISIGN_ASIS       2000 // Знак количества такой, какой установлен в поле PPTransferItem::Quantity_
//
//
//
class PPTransferItem { // @size=128
public:
	static bool   FASTCALL IsRecomplete(long flags);
	static int    FASTCALL GetSign(PPID op, long flags);

	enum {
		initfForceSign  = 0x0001,
		initfPlus       = 0x0002,
		initfMinus      = 0x0004,
		initfRecomplete = 0x0008,
		initfAsIs       = 0x0010
	};
	//
	// Descr: Транспортная упаковка товара.
	//   Структура сжимается в строку и хранится в зарезервированном теге PPTAG_LOT_FREIGHTPACKAGE.
	//   Семантически аналогична Acceptance
	//   @todo Шаблонизировать методы ToStr и FromStr для совместного использования с Acceptance
	//
	struct FreightPackage {
		static int Edit(PPTransferItem::FreightPackage * pData);
		FreightPackage();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
        int    ToStr(SString & rBuf);
        int    FromStr(const SString & rBuf);

		uint32 Ver;
        PPID   FreightPackageTypeID; // Тип упаковки
        double Qtty;                 // Количество упаковок
	};
	//
	// Descr: Параметры приемки строки входящего документа.
	//   Структура сжимается в строку и хранится в зарезервированном теге PPTAG_LOT_ACCEPTANCE.
	//   Семантически аналогична FreightPackage
	//   @todo Шаблонизировать методы ToStr и FromStr для совместного использования с FreightPackage
	//
	struct Acceptance { // @v11.7.0
		static int Edit(const PPTransferItem * pTi, PPTransferItem::Acceptance * pData);
		Acceptance();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
        int    ToStr(SString & rBuf);
        int    FromStr(const SString & rBuf);

		uint32 Ver;
		uint32 Flags;
		PPObjID SrcOid; // Источник формирования подтверждения (пользователь, сторонний агент etc)
		double Qtty;
		double Cost;
		double Price;
	};

	PPTransferItem();
	PPTransferItem(const PPTransferItem & rS);
	PPTransferItem(const BillTbl::Rec * pBillRec, int forceSign /*= TISIGN_UNDEF*/);
	PPTransferItem & FASTCALL operator = (const PPTransferItem &);
	//
	// Descr: Если параметр forceSign < 0, тогда функция устанавливает флаг PPTFR_MINUS
	//   в поле Flags. Если forceSign > 0, тогда устанавливает флаг PPTFR_PLUS.
	//   Если forceSign = 0, то функция пытается самостоятельно определить какой знак у
	//   операции и, если ей это не удается (обычно для модификации), выдает ошибку
	//   PPERR_GMODIFITEMFLAG.
	//
	int    Init(const BillTbl::Rec * pBillRec, int zeroRByBill = 1, int forceSign = TISIGN_UNDEF);
	int    PreprocessCorrectionExp();
	double GetEffCorrectionExpQtty() const;
	void   InitShadow(const BillTbl::Rec *, const PPTransferItem * pOrder);
	//
	// Descr: инициирует элемент PPTransferItem с товаром GoodsID, определенным кодом
	//   PPCommConfig::PrepayInvoiceGoodsCode, Quantity = 1, Cost = pPack->Amount,
	//   Price = pPack->Amount. Если инициализация прошла успешно, то возвращается (>0).
	//   Эта функция используется при формировании счетов-фактур по бухгалтерским
	//   документам и оплатам, а также при заполнении книги продаж/покупок.
	//
	int    InitAccturnInvoice(const PPBillPacket * pPack);
	bool   FASTCALL IsEq(const PPTransferItem & rS) const;
	static bool IsCorrectionRcpt(long trfrFlags) { return (trfrFlags & PPTFR_CORRECTION && trfrFlags & PPTFR_REVAL); }
	static bool IsCorrectionExp(long trfrFlags) { return (trfrFlags & PPTFR_CORRECTION && !(trfrFlags & PPTFR_REVAL)); }
	//
	// Descr: Возвращает !0 если строка является корректировкой прихода.
	// Note: Признаком такой корректировки является одновременно установленные флаги PPTFR_CORRECTION и PPTFR_REVAL.
	//
	bool   IsCorrectionRcpt() const { return IsCorrectionRcpt(Flags); }
	//
	// Descr: Возвращает !0 если строка является корректировкой расхода.
	// Note: Признаком такой корректировки является установленный флаг PPTFR_CORRECTION
	//   при одновременной отключенным флагом PPTFR_REVAL.
	//
	bool   IsCorrectionExp() const { return IsCorrectionExp(Flags); }
	//
	// Descr: Реализует установку параметров структуры в зависимости от идентификатора товара goodsID.
	//
	int    SetupGoods(PPID goodsID, uint = 0);
	int    SetupLot(PPID, const ReceiptTbl::Rec * pLotRec, uint fl/* TISL_XXX */);
	//
	// Descr:
	// Returns:
	//   TISIGN_PLUS  - если приход товара
	//   TISIGN_MINUS - если расход
	//   0            - если строка не влияет на остаток.
	//
	int    FASTCALL GetSign(PPID op) const;
	//
	// Descr: Функция SetupSign работает только тогда, когда структура
	//   инициализирована. Необходимость в этой функции обусловлена тем, что
	//   диалоговые процедуры работают с абсолютным значением поля Quantity,
	//   а все остальные требуют корректно установленного знака.
	//
	void   FASTCALL SetupSign(PPID op);
	//
	// Descr: устанавливает флаги структуры, соответствующие знаку
	//   операции (приход, расход, рекомплектация и т.д.).
	//   Если вид операции относится к типу PPOPT_GOODSMODIF, то флаги выставляются в
	//   соответствии с параметром forceSign, в противном случае вид операции полностью
	//   определяет установку флагов.
	//   Если forceSign == TISIGN_RECOMPLETE (1000), то строка соответствует рекомплектуемому лоту.
	//
	int    SetSignFlags(PPID op, int forceSign = TISIGN_UNDEF);
	bool   IsReceipt() const { return LOGIC(Flags & PPTFR_RECEIPT); }
	//
	// Descr: Возвращает !0, если строка относится к нелимитируемому товару и
	//   не требует создания (привязке) к лоту.
	//   Для плавного перехода на технику учета заказов нелимитируемых позиций по лотам,
	//   в системной конфигурации PPCommConfig предусмотрен флаг CCFLG_GENLOTONUNLIMORDER.
	//   Если этот флаг не установлен, функция возвращает !0 если (Flags & (PPTFR_UNLIM|PPTFR_ACK)).
	//   Если же этот флаг установлен, то функция возвращает !0 если
	//     (Flags & PPTFR_ACK) || (Flags & PPTFR_UNLIM && !(Flags & (PPTFR_ORDER|PPTFR_SHADOW)))
	//
	bool   IsUnlimWoLot() const;
	bool   IsLotRet() const;
	bool   IsRecomplete() const;
	double FASTCALL SQtty(PPID op) const;
	//
	// Descr: Возвращает номинальную сумму элемента.
	// ARG(zeroCost IN): если !0, то заставляет возвращать нулевой результат если по
	//   правильному значению можно вычислить цену поступления. Эта опция необходима
	//   для ограничени доступа к ценам поступления.
	//
	double FASTCALL CalcAmount(int zeroCost = 0) const;
	double CalcCurAmount() const;
	double NetPrice() const;
	double Qtty() const;
	void   FASTCALL ConvertMoney(TransferTbl::Rec * pRec) const;
	int    FASTCALL SetupByRec(const TransferTbl::Rec *);
	int    FASTCALL SetupByRec(const LocTransfTbl::Rec * pTr);
	int    SetupQuot(double, int set);
	enum {
		valfRoundVat = 0x0001,
		valfCalcOnly = 0x0002
	};
	//
	// Descr: Расценивает строку в соответствии с видом котировки quotKindID и дополнительными
	//   параметрами округления.
	// Note: Функция создает экземпляр класса PPObjGoods. Во избежании замеделния работы следует
	//   позаботиться о том, чтобы вне этой функции уже существовал инициализированный экземпляр
	//   PPObjGoods.
	// ARG(quotKindID IN):
	// ARG(roundPrec  IN):
	// ARG(roundDir   IN):
	// ARG(flags      IN): PPTransferItem::valfXXX
	// ARG(pResult   OUT): @#{vptr0}
	// Returns:
	//   >0 - значение цены реализации успешно рассчитано.
	//   <0 - для товара не определена котировка либо значение цены получилось меньше или равное нулю.
	//   0  - ошибка
	//
	int    Valuation(const PPBillConfig & rCfg, int calcOnly, double * pResult);
	double RoundPrice(double price, double roundPrec, int roundDir, long flags) const;
	double GetOrgCost() const;
	void   SetOrgCost(double c);
	void   SetZeroCost();

	LDATE  Date;
	PPID   BillID;
	int16  RByBill;
	int16  SrcIltiPos; // Номер позиции в пакете ILBillPacket, из которого была создана данная строка.
		// Необходим для трансляции идентификаторов лотов при синхронизации между разделами.
	PPID   CurID;      // ->Ref(PPOBJ_CURRENCY).ID Валюта
	PPID   LocID;      // ->Location.ID Для складских операций - ИД ячейки
	PPID   GoodsID;
	PPID   LotID;
	union {
		PPID CorrLoc;  // Корреспондирующая позиция //
		//
		// Если this является внутренним пакетом автокомплектации, то
		// поле ACLinkLotID используется во время проводки пакета функциями
		// PPObjBill::TurnPacket и PPObjBill::UpdatePacket для сохранени
		// на время транзакции временного значения лота, связывающего
		// строки внешнего и внутреннего пакетов. При сбое в проводке
		// документов новые значения лотов, присвоенные функциями
		// Transfer::AddItem или Transfer::UpdateItem, откатываются в
		// значения, сохраненные в этом поле. В функции
		// Transfer::AddItem и Transfer::UpdateItem это поле не может
		// попасть с ненулевыми значениями.
		//
		PPID ACLinkLotID;
	};
	//
	// При загрузке строки теневого документа в пакет поле CorrLoc получает идентификатор этого теневого документа, а поле
	// BillID получает идентификатор документа заказа. Перед проводкой такой строки поле CorrLoc обнуляется.
	//
	PPID   OrdLotID;    // @transient Лот ордера (Flags & PPTFR_ONORDER) (В БД не заносится)
	double UnitPerPack; // Емкость упаковки (количество торговых единиц в одной упаковке)
	double Quantity_;   // Количество товара (до v7.8.10 при переоценке - старая цена поступления)
	double WtQtty;      // Независимо учитываемое количество в физических единицах
	struct LinkBillRow { // @flat @size=8
		PPID   ID;
		int32  RByBill;
	};
	union {
		// @v10.5.8 double SpoilQtty;   // Количество товара, вычтенное из поступившего количества, как бракованное.
			// Поле Quantity содержит значение, поправленное на величину SpoilQtty. Таким образом,
			// изначально поступившее от поставщика количество равно Quantity+SpoilQtty.
			// Расчет SpoilQtty осуществляется по частичным структурам в документах прихода от поставщика.
		double RevalCost;   // Старая цена поступления при переоценке
			// До версии v7.8.10 для этой цели использовалось поле Quanitity.
			// При корректировке расхода - старая цена реализации
		LinkBillRow Lbr; // Для документов котировочных запросов - ссылка на связанную строку другого документа
	};
	double Rest_;       // Остаток после операции (при проводке игнорируется)
	double Cost;        // Цена поступления (при переоценке - новая цена поступления)
	double ExtCost;     // Величина накладных расходов, включенная в Cost (хранится в ReceiptTbl)
		// Положительное значение увеличивает Cost, отрицательное - уменьшает.
		// Таким образом, оригинальное значение Cost_Orig = Cost - ExtCost;
	double Price;       // Цена реализации (при переоценке - новая цена реализации)
	double Discount;    // Скидка (при переоценке - старая цена реализации)
	double CurPrice;    // Валютная цена
	double QuotPrice;   // Фиксированная цена по котировке (при корректировке - оригинальное количество)
	PPID   LotTaxGrpID; // ->Ref(PPOBJ_GOODSTAX).ID Входящая налоговая группа по лоту
	PPID   QCert;       // ->QualityCert.ID Серитфикат качества
	PPID   Suppl;       // ->Article.ID     Поставщик
	long   Flags;       // PPTFR_XXX
	enum {
		tfDirty        = 0x0001, // Признак того, что элемент был успешно добавлен в БД во время транзакции.
			// По этому признаку в случае сбоя проводки других строк можно будет
			// определить, что элемент фактически добавлен не был, хотя и имеет признаки
			// проведенного (RByBill != 0). PPTransferItem::tfDirty
			//
		tfForceLotID    = 0x0002,
		tfLocTransf     = 0x0004,  // Складская операция //
		tfForceRemove   = 0x0008,  // При изменении документа строка должна быть удалена в форсированном порядке
			// то есть, даже не смотря на остатки и прочие препятствия //
		tfOrdReserve    = 0x0010,  // Флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem установить флаг LOTF_ORDRESERVE для создаваемого лота.
		tfForceReplace  = 0x0040,  // Флаг, используемый внутри функции PPObjBill::UpdatePacket() для //
			// индикации необходимости полностью обновить строку в БД (удалить и добавить снова).
			// Флаг введен вместо обнуления поля RByBill так как создание новой строки может осуществляться и
			// при ненулевом значении RByBill (см флаг tfForceRByBill выше).
		tfForceNew      = 0x0080,  // Не смотря на то, что RByBill != 0 строка является новой (создана
			// в рамках акцепта документа, поступившего из другого раздела).
		tfForceNoRcpt   = 0x0100,  // Корректировочный флаг, блокирующий установку признака PPTFR_RECEIPT
			// функцией PPTransferItem::Init ради дополнения остатка существующего лота
		tfProblemQuot   = 0x0200,  // Строка имеет проблемную котировку, выявленную при расценке либо при назначении цены по котировке
		tfQrSeqAccepted = 0x0400,  // Последовательный котировочный запрос подтвержден поставщиком
		tfQrSeqRejected = 0x0800,  // Последовательный котировочный запрос отклонен поставщиком
	};
	long   TFlags;      // @transient tfXXX Не сохраняемые в БД признаки строки.
	LDATE  Expiry;      // Дата завершения пригодности товара к использованию
	union {
		LDATE  LotDate;     // Дата поступления товара.
		LTIME  LocTransfTm; // Для складской операции - время операции.
	};
};

bool FASTCALL IsUnlimWoLot(const TransferTbl::Rec & rRec);
//
// Intermediate Level Transfer Item
// Структура строки товарного документа промежуточного уровня //
// Предназначена для:
// - интерфейса с другими системами;
// - перемещения документов в рамках распределенной базы данных;
// - сохранения непроведенных документов
// - и др.
// Главная особенность этой структуры в сравнении с PPTransferItem
// в том, что она хранит строку товарного документа без ссылки на конкретный лот.
// Еще одно полезное свойство структуры ILTI заключается в способности
// аккумулировать множество строк PPTransferItem в том числе из многих
// документов.
//
struct ILTI { // @persistent(DBX) @size=80
	explicit ILTI(const PPTransferItem * = 0);
	void   FASTCALL Init(const PPTransferItem * pTi);
	void   Setup(PPID goodsID, int sign, double qtty, double cost, double price);
	//
	// Descr: Устанавливает поля Qtty и Rest в значение qtty с поправкой на флаги.
	// ARG(qtty   IN): Количество товара (в торговый единицах) устанавливаемое в поля//
	//   Qtty и Rest. Если в параметре flags не установлены флаги PPTFR_MINUS и PPTFR_PLUS,
	//   то qtty используется с тем же знаком, с которым передан от вызывающей функции.
	//   Если flags & PPTFR_PLUS, то функция форсирует положительное значение,
	//   Если flags & PPTFR_MINUS, то функция форсирует отрицательное значение.
	// ARG(wtQtty IN): Не используется.
	// ARG(flags  IN): Установленные в этом параметре флаги добавляются в поле Flags
	//   (this->Flags |= flags). Кроме того, эти флаги используются для установки знака
	//   полей Qtty и Rest (see ARG(qtty))
	//
	void   SetQtty(double qtty, double wtQtty = 0.0, long flags = 0);
	bool   HasDeficit() const;

	PPID   BillID;      // ->Bill.ID   Ссылка на заголок документа
	PPID   GoodsID;     // ->Goods2.ID ИД товара
	PPID   LotSyncID;   // @synclot
	PPID   LotMirrID;   // @synclot Лот зеркальной записи для внутренней передачи
	double UnitPerPack; // Количество в упаковке
	double Quantity;    // Количество
	double Rest;        // Непроведенный остаток [0..Quantity]
	double Cost;        // Цена поступления (одной торговой единицы)
	double Price;       // Цена реализации  (одной торговой единицы)
	double CurPrice;    // Валютная цена
	double QuotPrice;   // Цена по котировке
	long   Flags;       // Флаги (PPTFR_XXX)
	long   Suppl;       // ->Article.ID Поставщик
	long   QCert;       // ->QualityCert.ID Сертификат
	LDATE  Expiry;      // Срок годности (только для элементов товарных корзин)
	PPID   InTaxGrpID;  // ->Ref(PPOBJ_GOODSTAXGROUP) Налоговая группа прихода
	int16  RByBill;     //
	uint8  Reserve[10]; // @reserve
};
//
// Флаги документов (BillTbl::Rec.Flags)
//
#define BILLF_TOTALDISCOUNT  0x00000001L // Скидка задана на весь документ
#define BILLF_FREIGHT        0x00000002L // Документ содержит данные по фрахту
#define BILLF_NEEDPAYMENT    0x00000004L // Требует платежного документа
#define BILLF_PAYOUT         0x00000008L // Документ оплачен
#define BILLF_GRECEIPT       0x00000010L // Приход товара
#define BILLF_GEXPEND        0x00000020L // Расход товара
#define BILLF_SHIPPED        0x00000040L // Товар по документу отгружен
#define BILLF_NOLOADTRFR     0x00000080L // @transient При загрузке и обработке документа не следует загружать товарные строки
#define BILLF_CLOSEDORDER    0x00000100L // Закрытый заказ
#define BILLF_WRITEDOFF      BILLF_CLOSEDORDER // Списанный драфт
#define BILLF_GREVAL         0x00000200L // Переоценка товара
#define BILLF_CASH           0x00000400L // Кассовый документ
#define BILLF_CHECK          0x00000800L // Признак пробитого чека
#define BILLF_NOATURN        0x00001000L // Док без бух. проводок
#define BILLF_WHITELABEL     0x00002000L // Спец. метка
#define BILLF_EXTRA          0x00004000L // Существует дополнительная запись
#define BILLF_GMODIF         0x00008000L // Модификация товара
	// @#{BILLF_GRECEIPT^BILLF_GEXPEND^BILLF_GREVAL^BILLF_GMODIF}
// @v9.4.3 (следует использовать функцию IsGoodsDetail) #define BILLF_GOODS          (BILLF_GRECEIPT|BILLF_GEXPEND|BILLF_GREVAL|BILLF_GMODIF)
#define BILLF_NEGINVOICE     0x00010000L // Этот флаг используется только в структуре PPALDD GoodsBillBase и
	// порожденных для внутренней индикации того, что счет-фактуру следует печатать с отрицательными суммами
#define BILLF_RMVEXCISE      0x00020000L // Скидкой снят налог с продаж
#define BILLF_RENT           0x00040000L // С документом ассоциирован договор ренты
#define BILLF_RECKON         0x00080000L // Зачетный документ оплаты
#define BILLF_BANKING        0x00100000L // Банковский платежный документ
#define BILLF_FIXEDAMOUNTS   0x00200000L // Суммы по документу зафиксированы и не пересчитываются по товарным строкам
#define BILLF_CSESSWROFF     0x00400000L // Документ списания кассовой сессии
#define BILLF_PRINTINVOICE   0x00800000L // @transient Спец флаг, информирующий функцию заполнения данных для печати
	// документа, что печаться будет счет-фактура. Видимо в дальнейшем этот флаг будет упразднен.
#define BILLF_ADVANCEREP     0x01000000L // Авансовый отчет
#define BILLF_TGGLEXCSNPRICE 0x02000000L // Налог с продаж по документу установлен без изменения цены
#define BILLF_RECOMPLETE     0x04000000L // @#{BILLF_RECOMPLETE&BILLF_GMODIF} Рекомплектация  //
	// Этот флаг устанавливается, если в документ модификации вставляется товарная строка, имеющая    //
	// признак рекомплектации (PPTFR_MODIF|PPTFR_ACK|PPTFR_REVAL). Такая строка может быть удалена из //
	// документа только последней, после чего флаг BILLF_RECOMPLETE снимается                         //
#define BILLF_TSESSWROFF     0x08000000L // Документ списания технологической сессии
#define BILLF_CDFCTWROFF     0x10000000L // Документ сформирован на основе дефицита по кассовой сессии
#define BILLF_TDFCTWROFF     0x20000000L // Документ сформирован на основе дефицита по техн сессии
	// @#{BILLF_CDFCTWROFF^BILLF_CSESSWROFF^BILLF_TSESSWROFF^BILLF_TDFCTWROFF}
#define BILLF_SCARDOP        0x40000000L // По документу сформирована операция по кредитной карте
	// Флаг необходим для того, чтобы быстро принять решение (не обращаясь к таблице операций по карте) об удалении или изменении операции.
//
//
//
#define BILLF2_BHT           0x00000001L // Документ создан с BHT-терминала
#define BILLF2_FULLSYNC      0x00000002L // Признак того, что документ был принят из другого раздела с полным соответствием.
	// В результате такой документ потенциально сможет принять изменения исходного документа в последующем.
	// Важно: наличие данного флага является необходимым, но не достаточным условием для того, чтобы раздел
	// мог бы акцептировать изменение документа из другого раздела.
#define BILLF2_TSESSPAYM     0x00000004L // Документа платежа по технологической сессии
#define BILLF2_DONTCLOSDRAFT 0x00000008L // @transient Специализированный флаг, уведомляющий функцию PPObjBill::ProcessLink
	// о том, что не следует закрывать связанный драфт-документ.
#define BILLF2_DECLINED      0x00000010L // Документ (драфт), принятый нами по EDI-каналу нами же полностью отклонен
#define BILLF2_ACKPENDING    0x00000020L // Документ находится в состоянии ожидания завершения процедуры подтверждения //
	// То есть, отправлен запрос на подтверждение, но ответ еще не получен. У документа при этом может быть установлен
	// тег типа PPTAG_BILL_EDIACK. Если BILLF2_ACKPENDING установлен и в документе есть такой тег, то это означает,
	// что подтверждение уведомления об еще не было подтверждено со стороны сервиса EDI.
#define BILLF2_EDI_ACCP      0x00000040L // На документ отправленный через EDI-канал получено подтверждение о получении покупателем
#define BILLF2_EDI_DECL      0x00000080L // Документ отправленный через EDI-канал получено уведомление об отказе в приеме
	// Если установлены оба флага BILLF2_EDI_ACCP и BILLF2_EDI_DECL, то к документу привязывается драфт-документ приемки покупателем
	// Флаги BILLF2_EDI_ACCP и BILLF2_EDI_DECL могут быть установлены на документы edi-класса DESADV и ORDER. 
	// В случае ORDER флаги устанавливаются при поступлении ответного документа ORDRSP. При этом один BILLF2_EDI_ACCP означает,
	// что заказ полностью принят, BILLF2_EDI_DECL - заказ полностью отклонен, оба установленных флага означают частичное
	// подтверждение заказа с корректировками со стороны поставщика.
#define BILLF2_EDIAR_AGR     0x00000100L // Ответ на подтверждение нашей отгрузки покупателем (согласны)
#define BILLF2_EDIAR_DISAGR  0x00000200L // Ответ на подтверждение нашей отгрузки покупателем (не согласны)
#define BILLF2_EDIREPEALREQ  0x00000400L // Для документа получен запрос на отмену в проведении на сервере EDI
	// Если этот флаг установлен, то смысл флагов BILLF2_EDIAR_AGR и BILLF2_EDIAR_DISAGR переключается на реакцию на
	// запрос об отмене проведения.
#define BILLF2_ROWLINKBYRBB  0x00000800L // @internal
#define BILLF2_REVERSEDEBT   0x00001000L // Документ работает как реверсивная оплата или зачет: имеет отрицательную номинальную сумму оплачивает ее модулем другой документ
#define BILLF2_FORCEDRECEIPT 0x00002000L // @v11.1.12 Документ прихода товара, сформированный с целью форсированной компенсанции дефицита
	// при приеме данных из другого раздела. До версии 11.1.12 такие документы индицировались специальным примечанием N2. Далее это примечание использоваться не будет.
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_EXTRA)
//
struct PPBillExt { // @persistent @store(PropertyTbl)
	PPBillExt();
	bool   IsEmpty() const;
	//
	// Descr: Сравнивает перманентные поля экземпляра структуры this с экземпляром pS.
	//   Перманентные поля не отмечены признаком @transient
	// Returns:
	//   !0 - экземпляры this и pS одинаковы
	//   0  - экземпляры this и pS не одинаковы
	//
	bool   FASTCALL IsEq(const PPBillExt & rS) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	PPID   PayerID;            // ->Article.ID Плательщик
	PPID   AgentID;            // ->Article.ID Агент
	char   InvoiceCode[24];    //
	LDATE  InvoiceDate;        //
	char   PaymBillCode[24];   // Номер платежного документа (для печати в счете-фактуре)
	LDATE  PaymBillDate;       // Дата  платежного документа (для печати в счете-фактуре)
	int16  IsShipped;          // @transient Признак отгруженного документа (проецируется на BillTbl::Rec.Flags как BILLF_SHIPPED)
	int16  Ft_STax;            // @transient (0 - ignored, <0 - off, >0 - on)
	int16  Ft_Declined;        // @transient (0 - ignored, <0 - off, >0 - on)
	int16  Ft_CheckPrintStatus; // @erik статус печати чека( <0 - не печатанные чеки, >0 - печатанные чеки, 0 - все равно)
	int16  EdiRecadvStatus;     // @transient Статус RECADV по каналу EDI
	int16  EdiRecadvConfStatus; // @transient Статус подтверждения на RECADV по каналу EDI
	int16  OrderFulfillmentStatus; // @v11.1.8 @transient Статус выполнения заказа (-1) unused (0) ignored, (1) полностью не исполнен, (2) - полностью исполнен, (3) - исполнен частично
	int16  Reserve;            // @v11.1.8 @alignment
	PPID   CliPsnCategoryID;   // @v11.1.9 @transient Категория персоналий-контрагентов
	PPID   CreatorID;          // @transient Критерий фильтрации по пользователю, создавшему документ
	PPID   ExtPriceQuotKindID; // Вид котировки, используемый для печати дополнительной цены в накладных
	PPID   SCardID;            // @transient Персональная карта, к которой привязан документ. Проекция поля BillTbl::Rec::SCardID
	DateRange DuePeriod;       // @transient Период даты исполнения документа. Проекция BillFilt::DuePeriod
	PPID   AgtBillID;          // @transient. Проекция BillTbl::Rec::AgtBillID
	PPID   CcID;               // Ид чека, сформированного по этому документу для печати
	PPID   GoodsGroupID;       // @v11.0.11 @transient Проекция BillFilt::GoodsGroupID. Ид товарной группы, товары принадлежащие которой должны содержаться в документах.
	PPID   TradePlanLocID;     // @v12.1.12 Склад, возможно группирующий, по которому строится и анализируется торговый план.
		// Поле введено из-за того, что склад, к которому привязан документ не может быть группирующим.
};
//
// Descr: Массив движения по кредиту. Используется при начислении процентов по договору ренты.
//   Извлекается из БД функцией BillCore::GetCreditList(PPID billID, PctChargeArray *);
//
struct PctChargeEntry { // @flat
	LDATE  Dt;
	double Rest;
};

class PctChargeArray : private SVector {
public:
	PctChargeArray();
	int    Add(LDATE, double amount);
	LDATE  GetFirstDate() const;
	double GetRest(LDATE);
	int    EnumItems(uint * pIdx, PctChargeEntry *) const;
	int    ChargePercent(LDATE since, LDATE end, double percent, double * pResult) const;
protected:
	PctChargeEntry & FASTCALL at(uint) const;
};
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_RENT)
//
#pragma pack(push,1)
struct PPRentCondition {   // @size=48 @persistent @store(PropertyTbl[PPOBJ_BILL, @id, BILLPRP_RENT])
	PPRentCondition(); // @v11.9.6
	bool   IsEmpty() const;
	int    FASTCALL IsEq(const PPRentCondition & rS) const;
	int    GetCycleList(PPCycleArray *) const;
	int    GetChargeDate(const PPCycleArray *, uint cycleNo, LDATE *) const;
	int    CalcRent(LDATE chargeDt, double * pAmount) const;
	//
	// Descr: Рассчитывает начисляемый процент за период [begDt..chargeDt].
	//   При расчете используется список pCreditList, хранящий информацию о движении по кредиту.
	//   Результат возвращается по указателю pAmount.
	//
	double CalcPercent(LDATE begDt, LDATE chargeDt, const PctChargeArray * pCreditList) const;
	enum {
		fClosed  = 0x0001, // Закрытый договор
		fPercent = 0x0010  // Процентные начисления по ренте
	};
	DateRange Period;      // Период действия ренты
	int16  Cycle;          // Период цикла начисления PRD_XXX (SLIB.H)
	int16  Reserve;        // @reserve
	double Percent;        // Годовой процент начисления (используется если Flags & RENTF_PERCENT) //
	double PartAmount;     // Частичная сумма начисления (на каждый период) //
	long   Flags;          // RENTF_XXX
	long   ChargeDayOffs;  // Смещение даты начисления (в днях)
	uint8  Reserve2[16];   // @reserve
};
#pragma pop
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_BANKING)
//
#define BNKPAYMMETHOD_UNDEF      0 // Неопределенный
#define BNKPAYMMETHOD_MAIL       1 // Почтой
#define BNKPAYMMETHOD_TELEGRAPH  2 // Телеграфом
#define BNKPAYMMETHOD_EMAIL      3 // Электронно
#define BNKPAYMMETHOD_URGENTLY   4 // Срочно
#define BNKPAYMMETHOD_DEFAULT    BNKPAYMMETHOD_EMAIL // По умолчанию

#define BNKQUEUEING_DEFAULT      5 //

#define BNKPAYMF_REQ        0x0001L // Платежное требование (иначе поручение)
#define BNKPAYMF_WOACCEPT   0x0002L // Без акцепта (иначе с акцептом)

#pragma pack(push,1)
struct PPTaxPeriod {       // @persistent @size=6
	SString & Format(SString & rBuf) const;
	enum {
		eEmpty = 0,
		eYear,
		eSemiyear1,
		eSemiyear2,
		eQuart1,
		eQuart2,
		eQuart3,
		eQuart4,
		eMonth,
		eDec1,
		eDec2,
		eDec3,
		eDate
	};
	int16  Year;           //
	int8   Month;          // @#{1..12}
	int8   Day;            //
	int16  P;              // PPTaxPeriod::eXXX
};
#pragma pop

#pragma pack(push,1)
struct PPBankingOrder { // @persistent @store(PropertyTbl)
	PPBankingOrder();
	//
	// Requirements:
	//   Dt != 0
	//   AckDt == 0 || AckDt >= Dt
	//   PayerID == PayerBnkAccID.PersonID
	//   RcvrID == RcvrBnkAccID.PerosnID;
	//   BnkQueueing == (1..10)
	//   Amount > 0
	//
	struct TaxMarkers { // @size=90
		bool   IsEmpty() const;
		char   TaxClass[12];  // Код бюджетной классификации налога (7 знаков)
		char   OKATO[16];     // Код муниципального образования по ОКАТО (11 знаков)
		char   Reason[8];     // Код основания платежа
		PPTaxPeriod Period;   // Налоговый период
		char   DocNumber[12]; // Номер документа, согласно которому осуществляется оплата
		LDATE  DocDate;       // Дата подписи декларации
		char   PaymType[8];   // Тип платежа
		char   TaxClass2[24]; // Код бюджетной классификации налога с 2005 года (20 знаков)
		char   UIN[24];       // Код УИН
	};
	PPID   Tag;              // const = PPOBJ_BILL
	PPID   BillID;           // ИД документа
	PPID   PropID;           // const = BILLPRP_PAYMORDER
	LDATE  Dt;               // Дата платежа
	LDATE  AckDt;            // Дата подтверждения платежа
	char   Code[10];         // Номер документа @todo [10]-->[24]
	PPID   PayerKindID;      // Helper field for selecting payer
	PPID   RcvrKindID;       // Helper field for selecting receiver
	PPID   PayerID;          // ->Person.ID      Плательщик
	PPID   PayerBnkAccID;    // ->BankAccount.ID Банковский счет плательщика
	PPID   RcvrID;           // ->Person.ID      Получатель
	PPID   RcvrBnkAccID;     // ->BankAccount.ID Банковский счет получател
	short  BnkPaymMethod;    // Способ банковского платежа (BNKPAYMMETHOD_XXX)
	short  BnkQueueing;      // Очередность банковского платежа (1..)
	long   Flags;            // Флаги (BNKPAYMF_XXX)
	double Amount;           // Сумма платежа
	long   VATRate;          // Ставка НДС
	double VATSum;           // Сумма НДС
	int16  PayerStatus;      // Статус плательщика (1..7, default 1)
	// Part stored in variable tail of record
	TaxMarkers Txm;
	int16  FormalPurpose;    // Формальное назначение платежа (4byte-aligned with Txm)
	uint8  Reserve[24];      // @reserve
};
#pragma pop
//
// Descr: Информация по фрахту документа
//
#pragma pack(push,1)
struct PPFreight { // @persistent @store(PropertyTbl)
	PPFreight();
	PPFreight & Z();
	bool   IsEmpty() const;
	bool   FASTCALL IsEq(const PPFreight &) const;
	int    FASTCALL CheckForFilt(const FreightFilt & rFilt) const;
	int    SetupDlvrAddr(PPID dlvrAddrID);

	PPID   Tag;            // Const=PPOBJ_BILL
	PPID   ID;             // ->Bill.ID
	PPID   PropID;         // Const=BILLPRP_FREIGHT
	char   Name[20];       //
	PPID   StorageLocID;   // Место хранения. Если весь документ (например, инвентаризация) ассоциирован с одним местом хранения, то здесь оно может быть указано
	char   Reserve[2];     // @reserve
	PPID   DlvrAddrID__;   // ->Location.ID Адрес разгрузки. @v12.1.11 Я добавил __ в качестве суффикса имени для того, чтобы можно было быстро
		// найти использование этой member. Цель - усложнение идентификации адреса доставки по документу из-за того, что для документа передачи 
		// на другой склад адрес доставки это - контрагент. see PPObjBill::GetDlvrAddrID() и PPBill::GetDlvrAddrID().
		// На момент выхода версии @v12.1.11 унификация сделана лишь в нескольких местах: требуется дальнейшая работа.
	int16  NmbOrigsBsL;    // Количество печатаемых оригиналов коносаментов
	long   TrType;         // PPTRTYP_XXX
	PPID   PortOfLoading;  // ->City.ID
	PPID   PortOfDischarge; // ->City.ID
	LDATE  IssueDate;      // Дата отправления из пункта погрузки
	LDATE  ArrivalDate;    // Дата прибытия на конечный пункт
	PPID   CaptainID;      // ->Person.ID (Командиры транспортных средств)
	double Cost;           // Стоимость фрахта
	PPID   AgentID;        // ->Person.ID (Транспортные агентства)
	PPID   ShipID;         // ->Ship.ID
	PPID   Captain2ID;     // 2-й командир транспорта
	uint8  Reserve2[16];   // @reserve
};
#pragma pop
//
// Descr: Заголовок авансового отчета
//
struct PPAdvanceRep {      // @persistent @store(PropertyTbl)
	struct Rcpt {          // Size=48
		char   Text[28];   // Описание источника полученной суммы @todo Увеличить длину поля //
		PPID   BillID;     // Ассоциированный документ
		PPID   ObjectID;   // ->Article.ID Ассоциированных объект
		LDATE  Dt;         // Дата получения суммы
		double Amount;     // Сумма
	};
	PPID   Tag;            // const=PPOBJ_BILL
	PPID   BillID;         // ИД документа
	PPID   PropID;         // const=BILLPRP_ADVANCEREP
	double InRest;         // Остаток от предыдущего аванса
	double RcpAmount;      // Полученная сумма
	double ExpAmount;      // Израсходованная сумма
	double OutRest;        // Остаток
	int16  NumAddedBills;  // Количество прилагаемых первичных документов
	int16  NumAddedSheets; // Количество листов прилагаемых первичных документов
	Rcpt   Rcp[2];         // Информация о полученных суммах // @todo Увеличить количество элементов //
};

class PayPlanArray : public TSVector <PayPlanTbl::Rec> {
public:
	PayPlanArray();
	bool   FASTCALL IsEq(const PayPlanArray & rS) const;
	int    GetLast(LDATE * pDt, double * pAmount, double * pInterest) const;
	//
	// Descr: Ищет запись с датой dt. Если запись найдена, то возвращает !0
	//   и присваивает по указателю pPos позицию найденной записи, а по указателю
	//   pRec - саму запись. Если запись с датой dt не найдена, то данные по
	//   указателям pPos и pRec не меняются.
	//
	int    SearchDate(LDATE dt, uint * pPos, PayPlanTbl::Rec * pRec) const;
	void   SetBillID(PPID);
	int    Update(const PayPlanTbl::Rec * pItem, uint * pPos);
	void   Sort();
	int    AutoBuild(const PPBillPacket * pPack);
};
//
// Descr: Контейнер, хранящий элементы расширения бухгалтерского документа.
//   Такие элементы используются для управления специальными многострочными нетоварными операциями.
//   Например: авансовыми отчетами, доверенностями
//
class PPAdvBillItemList : private SArray {
public:
	//
	// Descr: Элементы расширения бухгалтерского документа
	//
	struct Item {     // @persistent @flat @store(AdvBillItem)
		Item();
		int    FASTCALL IsEq(const Item & rS) const;
		enum {
			fWritedOff = 0x0001 // Строка документа списана (для долговой инвентаризации)
		};
		PPID   BillID;
		int16  RByBill;
		int16  Reserve2;        // @alignment
		char   AdvCode[24];
		LDATE  AdvDt;
		PPID   AdvBillKindID;
		//
		// Граф операций над связанным документом:
		// 1. Ссылка нулевая (или висячая)
		//    1.1 Операция "Редактировать"
		//       1.1.1 Добавить новый документ -->2.
		//       1.1.2 Добавить документ по фильтру -->2.
		// 2. Ненулевая ссылка на существующий док
		//    2.1 Операция "Редактировать"
		//       2.1.1 Редактировать связанный документ -->2.
		//       2.1.2 Заместить ссылку на связанный документ -->1.1
		//    2.2 Операция "Удалить"
		//       2.2.1 Разорвать ссылку на документ (документ остается, связь исчезает) -->1.
		//       2.2.2 Удалить связанный документ -->1.
		//
		PPID   AdvBillID;
		PPID   AccID;
		PPID   ArID;
		long   Flags;      // PPAdvBillItem::fXXX
		double Amount;     //
		double ExtAmt;     //
		char   Memo[128];  //
	};
	PPAdvBillItemList();
	int    FASTCALL IsEq(const PPAdvBillItemList & rS) const;
	uint   GetCount() const;
	Item & FASTCALL Get(uint) const;
	int    SearchBillLink(PPID billID, uint * pPos) const;
	int    GetStorageForm(uint, AdvBillItemTbl::Rec *) const;
	int    AddStorageForm(const AdvBillItemTbl::Rec *);
	int    Add(const Item *);
	int    Remove(uint);
	void   Clear();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
};
//
// Descr: Список тегов, ассоциированных с товарными строками документа.
//   В качестве объекта привязки тегов - лоты. То есть, список
//   формируется и сохраняется в БД приходными документами, но может
//   использоваться любыми товарными документами, строки которых
//   ссылаются на лоты.
//
class PPLotTagContainer : private SArray {
public:
	PPLotTagContainer();
	PPLotTagContainer(const PPLotTagContainer & rS);
	PPLotTagContainer & FASTCALL operator = (const PPLotTagContainer & rS);
	int    FASTCALL Copy(const PPLotTagContainer & rS);
	void   Release();
	uint   GetCount() const;
	ObjTagList * FASTCALL Get(int rowIdx /*0..*/) const;
	int    Set(int rowIdx /*0..*/, const ObjTagList *);
	const ObjTagItem * GetTag(int rowIdx, PPID tagID) const;
	bool   SearchString(const char * pPattern, PPID tagID, long flags, LongArray & rRowIdxList) const;
	int    GetTagStr(int rowIdx, PPID tagID, SString & rBuf) const;
	void   RemovePosition(int rowIdx);
	int    ReplacePosition(int rowIdx, int newRowIdx);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    ProcessObjRefs(PPObjIDArray * ary, int replace);
	int    SetString(PPID tagID, int rowIdx, const char * pString);
	//
	// ARG(pValue IN): Если pValue == 0, то удаляет тег tagID для строки rowIdx, в противном случае
	//   присваивает строке rowIdx значение тега tagID равное *pValue.
	//
	int    SetReal(PPID tagID, int rowIdx, const double * pValue);
	int    GetReal(PPID tagID, int rowIdx, double * pValue) const;
	int    SetString(PPID tagID, const LongArray * pRows, const char * pString);
	int    GetString(PPID tagID, int rowIdx, SString & rBuf) const;
private:
	struct Item {
		int32  RowIdx;
		ObjTagList List;
	};
	virtual void FASTCALL freeItem(void * pItem);
};
//
// Descr: Контейнер для хранения ЕГАИС-кодов, ассоциированных со строками документа
//   Образ этого контейнера хранится в таблице LotExtCode.
//
// Специализированный экземпляр контейнера предназначен для проверки поступивших кодов.
// В таком контейнере все элементы хранятся со значением RowID == -1 (то есть не ассоциируются со строками документа).
// В базе данных валидирующий контейнер сохраняется в сериализованном виде в таблице PropertyTbl.
//
class PPLotExtCodeContainer : private SVector, private SStrGroup {
	friend class LotExtCodeCore;
public:
	//
	// Descr: Флаги элементов списка марок
	//
	enum { // @persistent
		fBox       = 0x0001,
		fSignMinus = 0x0002, // ???
		fSignPlus  = 0x0004, // ???
	};
	struct Item2 {
		int16  RowIdx;
        int16  Flags;
		int32  BoxId;
		SString Num;
	};
	struct MarkSet : public SStrGroup {
	public:
		struct Entry {
			long   BoxID;
			long   Flags;
			SString Num;
		};
		MarkSet();
		MarkSet & Z();
		long   AddBox(long id, const char * pNum, int doVerify);
		int    AddNum(long boxId, const char * pNum, int doVerify);
		uint   GetCount() const;
		bool   GetByIdx(uint idx, Entry & rEntry) const;
		int    GetBoxNum(long boxId, SString & rNum) const;
		int    GetByBoxID(long boxId, StringSet & rSs) const;
		int    SearchCode(const char * pNum, uint * pIdx) const;
		//
		// Descr: Ищет предыдущий бокс начиная с позиции currentPos вверх.
		//   Если (currentPos < 0 || currentPos >= GetCount()) то ищет начания с последней позиции вверх.
		// Returns:
		//   >0 - идентификатор найденного бокса если таковой найден
		//    0 - бокс не найден
		//
		long   SearchLastBox(int currentPos) const;
	private:
		struct InnerEntry { // @flat
			long   BoxID;
			long   Flags;
			uint   NumP;
		};
		TSVector <InnerEntry> L;
	};
	PPLotExtCodeContainer();
	PPLotExtCodeContainer(const PPLotExtCodeContainer & rS);
	PPLotExtCodeContainer & FASTCALL operator = (const PPLotExtCodeContainer & rS);
	int    FASTCALL Copy(const PPLotExtCodeContainer & rS);
	void   Release();
	int    FASTCALL IsEq(const PPLotExtCodeContainer & rS) const;
	uint   GetCount() const;
	int    Add(int rowIdx, long boxId, int16 flags, const char * pCode, uint * pIdx);
	int    AddValidation(long boxId, int16 flags, const char * pCode, uint * pIdx);
	int    Delete(int rowIdx, uint itemIdx);
	int    Add(int rowIdx, const MarkSet & rS);
	int    AddValidation(const MarkSet & rS);
	int    Set_2(int rowIdx, const MarkSet * pS);
	int    Get(int rowIdx, LongArray * pIdxList, MarkSet & rS) const;
	//
	// Descr: Находит все марки в контейнере, ассоциированные с боксом boxId и возвращает их в
	//   StringSet'е rSs.
	//   rSs предварительно очищается функцией.
	//   Сам номер бокса в сет не заносится.
	// Returns:
	//   >0 - найдена по крайней мере одна марка, ассоциированная с боксом boxId
	//   <0 - не найдено ни одной марки, ассоициированной с boxId
	//
	int    GetByBoxID(long boxId, StringSet & rSs) const;
	int    GetByIdx(uint idx, Item2 & rItem) const;
	//
	// Descr: Ищет код pCode среди всех кодов контейнера.
	//   В случае успешного поиска по указателю pRowIdx (если pRowIdx != 0) присваивает индекс строки документа,
	//   которой принадлежит марка (для validation-кодов это - -1). По указателю pInndrIdx, если не нулевой,
	//   присваивается внутренний индекс элемента (в векторе SVector::this).
	// Returns:
	//   >0 - код найден
	//    0 - код не найден
	//
    int    Search(const char * pCode, int * pRowIdx, uint * pInnerIdx) const;
	int    ValidateCode(const char * pCode, const char * pBox, int * pErr, int * pRowId, SString * pBoxCode) const;
    void   RemovePosition(int rowIdx);
	int    ReplacePosition(int rowIdx, int newRowIdx);
	int    Serialize_Before10209(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
    int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	int    Helper_Add(int rowIdx, long boxId, int16 flags, const char * pCode, int doVerifyUniq, uint * pIdx);
    struct InnerItem { // @persistent
		int16  RowIdx;
        int16  Flags;
		int32  BoxId;
        uint   CodeP;
    };
};

class PPBill : public ObjTagContainerHelper {
public:
	PPBill();
	PPBill(const PPBill & rS);
	PPBill & FASTCALL operator = (const PPBill & rS);
	void   BaseDestroy();
	int    FASTCALL Copy(const PPBill & rS);
	int    FASTCALL IsEq(const PPBill & rS) const;
	int    FASTCALL GetLastPayDate(LDATE *) const;
	int    AddPayDate(LDATE, double amount);
	//
	// Descr: Очищает список плана платежей и затем вызывает функцию PPBill::AddPayDate
	//
	int    SetPayDate(LDATE dt, double amount);
	//
	// Descr: Присваивает по указателю pFreight блок данных о фрайхте документа.
	// ARG(pFreight IN): @#{vptr0}
	// Returns:
	//   >0 - this->P_Freight != 0
	//   <0 - this->P_Freight == 0 (блок по указателю pFreight инициализируется как пустой)
	//
	int    FASTCALL GetFreight(PPFreight * pFreight) const;
	int    FASTCALL SetFreight(const PPFreight * pFreight);
	int    FASTCALL SetFreight_DlvrAddrOnly(PPID dlvrAddrID);
	PPID   GetDlvrAddrID() const;

	BillTbl::Rec Rec;
	SString SMemo; // @v11.1.12 replacemnt for the BillTbl::Rec::Memo
	AmtList Amounts;
	PayPlanArray Pays;
	PPBillExt    Ext;
	PPRentCondition  Rent;
	PPBankingOrder * P_PaymOrder;
	PPFreight * P_Freight;
	PPAdvanceRep   * P_AdvRep;
	//
	// @v9.8.11 Следующие компоненты перенесены из PPBillPacket и из ILBillPacket
	// с целью избежать дублирования функционала, управляющего этими компонентами и в обоих контейнерах.
	// Замечу, что нахождение здесь LTagL и XcL не совсем правильно, поскольку эти компоненты
	// связаны с коллекциями товарных строк документа, которые в PPBillPacket и ILBillPacket представлены
	// по-разному.
	//
	TSVector <PPAccTurn> Turns;
	PPAdvBillItemList AdvList; // Элементы расширения бух документа
	PPLotTagContainer LTagL;   // Список тегов лотов
	ObjTagList BTagL;          // Список тегов документа
	PPLotExtCodeContainer XcL; // Контейнер, содержащий спецкоды (в частности, марки ЕГАИС) ассоциированные со строками.
		// Особенность такой ассоциации заключается в том, что с одной строкой может быть связано от нуля до множества кодов.
		// Кроме того, коды привязываются не к лотам, а именно к строкам документа.
		// Списки кодов привязываются по индексу строки с базой 1 [1..]
	PPLotExtCodeContainer _VXcL; // Валидирующий контейнер спецкодов. Применяется для проверки
		// кодов, поступивших с документом в XcL
	SVerT  Ver; // Версия системы, которая создала сериализованную копию объекта
	//
	// Descr: Блок, содержащий данные о договоре на поставку/продажу. Используется в документах, относящихся к
	//   типу операции PPOPT_AGREEMENT.
	//
	struct Agreement { // @persistent
		Agreement();
		Agreement(const Agreement & rS);
		Agreement & FASTCALL operator = (const Agreement & rS);
		bool   IsEmpty() const;
		bool   FASTCALL IsEq(const Agreement & rS) const;
		int    FASTCALL Copy(const Agreement & rS);

		long   ObjType;          // Const=PPOBJ_BILL
		long   ObjID;            // BillID
		long   Prop;             // Const=BILLPRP_AGREEMENT
		// start Text {
		long   Flags;            // @flags
		LDATE  Expiry;           // Дата истечения срока действия договора
		double MaxCredit;        // Максимальный кредит
		double MaxDscnt;         // Максимальная скидка в %% (>= 100% - неограниченная)
		double Dscnt;            // Обычная скидка в %%
		PPID   DefAgentID;       // Агент, закрепленный за клиентом
		PPID   DefQuotKindID;    // Вид котировки, закрепленный за клиентом
		long   PaymDateBase;     //
		int16  DefPayPeriod;     // Количество дней от отгрузки до оплаты по умолчанию
		int16  RetLimPrd;        // Период ограничения доли возвратов от суммы товарооборота
		uint16 RetLimPart;       // Макс доля возвратов от суммы товарооборота за период RetLimPrd (в промилле)
		int16  DefDlvrTerm;      // Срок доставки товара в днях, начиная с даты документа закупки
		int16  PctRet;           // Максимальный объем возврата товара по накладной в процентах от суммы накладной //
		uint16 Reserve;          // @alignment
		uint8  ReserveEnd[8];
		// } end Text
		int32  ReserveVal1;
		int32  ReserveVal2;
	};
	Agreement * P_Agt;
};
//
// Пакет документа
// Содержит всю необходимую информацию о товарном либо бухгалтерском документе.
// Основная структура, используемая в операциях с документами.
//
// Опции загрузки пакета из БД.
// Используются функцией PPObjBill::ExtractPacket.
//
#define BPLD_SKIPTRFR     0x0001 // Не загружать товарные строки
#define BPLD_LOCK         0x0002 // Устанавливать логич блокировку на документ
#define BPLD_FORCESERIALS 0x0004 // Обязательная загрузка серийных номеров по всем товарных строкам
	// Если этот флаг не установлен, то серийные номера загружаются только для строк, генерирующих лоты
#define BPLD_LOADINVLINES 0x0008 // Загружать строки инвентаризации
//
// Опции обработки недостаточного количества составляющих комплектации
//
#define PCUG_USERCHOICE        0 // Предлагать диалог выбора способа обработки
#define PCUG_BALANCE           1 // Сбалансировать количество результирующего продукта
#define PCUG_ASGOODAS          2 // Включить в комплект столько комплектующих, сколько есть в наличии
#define PCUG_EXCLUDE           3 // Полностью исключить недостающий комплектующий товар
#define PCUG_CANCEL            4 // Отменить операцию комплектации
//
// Descr: Шаблон транзитной валютной операции
//
struct PPCurTransit {      // @transient
	PPID   BillID;         // Идентификатор документа
	char   BillCode[48];   // Код документа // @v11.1.12 [24]--[48]
	LDATE  Date;
	PPID   OpID;
	PPID   AccSheetID;
	PPID   ObjectID;
	long   Flags;
	PPID   InCurID;
	double InCurAmount;
	double InCRate;
	PPID   OutCurID;
	double OutCurAmount;
	double OutCRate;
	double TransitCRate;
	char   Memo[160];
};
//
//
//
struct BillVatEntry {
	BillVatEntry() : Rate(0.0), VatSum(0.0), BaseAmount(0.0), AmountByVat(0.0)
	{
	}
	bool   FASTCALL IsEq(const BillVatEntry & rS) const
	{
		return (Rate == rS.Rate && VatSum == rS.VatSum && BaseAmount == rS.BaseAmount && AmountByVat == rS.AmountByVat);
	}
	double Rate;
	double VatSum;      // Сумма НДС
	double BaseAmount;  // Сумма налогооблагаемой базы (без НДС)
	double AmountByVat; // Сумма документа, соответствующая ставке НДС Rate.
		// Теоретически, AmountByVat = BaseAmount + VatSum, однако, из-за ошибок округления может
		// иногда возникать разница в пределах нескольких копеек.
};

class BillVatArray : public TSVector <BillVatEntry> {
public:
	BillVatArray();
	bool   IsEq(const BillVatArray & rS) const;
	int    Add(double rate, double sum, double base, double amtByVat);
	const  BillVatEntry * GetByRate(double rate) const;
};
//
// Флаги функции PPBillPacket::CalcTotal
//
#define BTC_CALCSALESTAXES  0x0001L // Рассчитывать налоги
#define BTC_CALCOUTAMOUNTS  0x0002L // Рассчитывать суммы для вывода (В этом случае расчитывается только номинальная сумма и налоги по номинальной сумме).
#define BTC_EXCLUDEVAT      0x0004L // При расчете налогов считать, что НДС отсутствует (if BTC_CALCOUTAMOUNTS only)
#define BTC_ONLYUNLIMGOODS  0x0008L // Рассчитывать суммы только для нелимитирумых товаров
#define BTC_CALCNOMINALGVAT 0x0010L // Рассчитывает суммы налогов исходя из номинальной
	// ставки НДС, определенной для товаров (не принимает во внимание налоговую группу по лоту
	// и признак освобождения поставщика от НДС).
	// Флаг действителен только если установлен BTC_CALCSALESTAXES.

struct BillTotalData {
	enum {
		fAllGoodsUnlim = 0x0001, // Все товары в документе - нелимитированные
		fExtCost       = 0x0002, // Документ содержит распределенную себестоимость
		fInitialized   = 0x0004  // Структура инициализирована рассчетом PPBillPacket::CalcTotal
	};
	BillTotalData();
	BillTotalData & Z();
	bool   IsEq(const BillTotalData & rS) const;

	long   LinesCount;
	long   GoodsCount;
	long   Flags;         // @flags (BillTotalData::fXXX)
	double UnitsCount;
	double PhUnitsCount;
	double PackCount;
	double Brutto;         // Масса брутто входящего в документ товара, кг
	double Volume;         // Объем брутто входящего в документ товара, м*м*м
	double Amt;            // Номинальная сумма
	double CurAmt;         // Номинальная сумма в валюте
	double VAT;            // НДС в номинальных ценах
	double CVAT;           // НДС в ценах поступления //
	double PVAT;           // НДС в ценах реализации  //
	double Excise;         // Акциз
	double CExcise;        // Акциз в ценах поступления //
	double STax;           // Налог с продаж
	double CSTax;          // Налог с продаж в ценах поступления //

	AmtList Amounts;       // @anchor
	BillVatArray VatList;
	BillVatArray CostVatList;  //
	BillVatArray PriceVatList; //
};
//
// Флаги слияния товарных строк документа для функции EnumTItemsExt
//
#define ETIEF_UNITEBYGOODS    0x0001L // Объединять строки с одинаковым товаром
#define ETIEF_DIFFBYCOST      0x0002L // Не объединять, если различаются Cost
#define ETIEF_DIFFBYPRICE     0x0004L // Не объединять, если различаются Price
#define ETIEF_DIFFBYINTAXGRP  0x0008L // Не объединять, если различаются LotTaxGrpID
#define ETIEF_DIFFBYPACK      0x0010L // Не объединять, если различаются UnitPerPack
#define ETIEF_DIFFBYQCERT     0x0020L // Не объединять, если различаются QCert
#define ETIEF_DIFFBYNETPRICE  0x0040L // Не объединять, если различаются NetPrice()
#define ETIEF_DIFFBYLOT       0x0080L // Не объединять, если различаются лоты
#define ETIEF_SORTBYNAME      0x0100L // Сортировать по наименованию товара
#define ETIEF_SORTBYCODE      0x0200L // Сортировать по коду
#define ETIEF_SALDOFILTGRP    0x0400L // Перечислять также те товары из группы FiltGrpID
	// которые не представлены в документе, но по которым есть ненулевое сальдо в разрезе контрагента по документу.
#define ETIEF_LABELQUOTPRICE  0x0800L // @internal
#define ETIEF_DISPOSE         0x1000L // Включить в итерацию информацию о размещении строк по складским ячейкам
#define ETIEF_DONTUNITE       0x2000L // Безусловный запрет на объединение строк
#define ETIEF_FORCEUNITEGOODS 0x4000L // Форсированное объединение строк с одинаковым товаром (без оглядки на дополнительные условия). ETIEF_DONTUNITE приоритетнее, чем ETIEF_FORCEUNITEGOODS

#define SALDOLIST_POS_BIAS    100000

class TiIter {
public:
	enum Order {
		ordDefault = 0,
		ordByGoods,
		ordByGrpGoods,
		ordByBarcode,
		ordBySuppl,             //
		ordByLocation,          //
		ordByPLU,               //
		ordByQCert,             //
		ordByStorePlaceGrpGoods //
	};
	//
	// ARG(pPack     IN):
	// ARG(flags     IN): флаги перечисления ETIEF_XXX
	// ARG(filtGrpID IN): ид фильтрующей товарной группы
	// ARG(Order     IN): порядок сортировки строк
	//
	TiIter(PPBillPacket * pPack, long flags, long filtGrpID, Order = ordDefault);
	int    Init(const PPBillPacket *, long flags, long filtGrpID, Order = ordDefault);
	int    FASTCALL IsPassedIdx(int idx) const;
	int    IsAccsCost() const { return AccsCost; }
private:
	struct IndexItem {
		IndexItem(long tiPos, long ext, long disposePos);
		long   TiPos;
		long   Ext;
		long   DisposePos;
	};

	int    OrderRows_Mem(const PPBillPacket *, Order);

	friend class PPBillPacket;
	long   Flags;
	uint   I, PckgI, PckgItemI;
	int    UseIndex;
	int    AccsCost;       // Если 0, то доступ к ценам поступления запрещен
	PPID   FiltGrpID;      // Товарная группа, ограничивающая выборку.
	LongArray Seen;        // Список позиций документа, которые уже были обработаны
	TSVector <IndexItem> Index; //
	RAssocArray SaldoList; // Список товаров, принадлежащих группе FiltGrpID и ассоциированных с величной сальдо по контаргенту.
	TSVector <LocTransfTbl::Rec> DispList; //
};
//
//
//
struct PUGI { // @transient
	PUGI();
	enum {
		fTerminal = 0x0001 // Позиция является терминальной (не зависит от комплектации). Может быть установлен при формировании элемента по MRP-таблице.
	};
	uint   Pos;
	PPID   GoodsID;
	PPID   LocID;        // Location of deficit occurence
	long   Flags;        //
	double Cost;         //
	double Price;        //
	double NeededQty;
	double DeficitQty;
};

class PUGL : public SArray {
public:
	//
	// Descr: Дескриптор подстановки поставщика при списании дефицита
	//
	struct SupplSubstItem { // @flat
		explicit SupplSubstItem(uint pos);
		SString & FASTCALL QttyToStr(SString & rBuf) const;

		enum {
			uAbs = 0,
			uPct = 1
		};
		uint   Position; // Номер позиции [1..] в PUGL к которой относится данный дескриптор. Нуль означает, что дескриптор используется как шаблон
		PPID   SupplID;  // ->Article.ID ИД поставщика
		long   Unit;     // SupplSubstItem::uXXX
		double Qtty;     // Количество
	};
	//
	// Descr: Параметры установки времени производства для лотов, компенсирующих дефицит
	//
	struct SetLotManufTimeParam {
		SetLotManufTimeParam();
		int    FixedTimeToString(SString & rBuf) const;
		int    FixedTimeFromString(const char * pStr);
		enum {
			fEnable = 0x0001
		};
		long   Flags;
		int    DateOffsDays;
		int    FixedTime;
	};
	PUGL();
	PUGL & FASTCALL operator = (const PUGL & s);
	void   FASTCALL SetHeader(const BillTbl::Rec *);
	int    Add(const ILTI * pItem, PPID locID, uint itemPos, LDATE = ZERODATE);
	int    Add(const PUGI *, LDATE = ZERODATE);
	int    Add__(const PUGL *);
	int    FASTCALL Log(PPLogger * pLogger) const;
	void   FASTCALL GetItemsLocList(PPIDArray & rList) const;
	int    GetSupplSubstList(uint pos /*[1..]*/, TSVector <PUGL::SupplSubstItem> & rList) const;
	//
	// Descr: возвращает !0 если все элементы имеют признак PUGI::fTerminal
	//
	int    IsTerminal() const;
	int    SearchGoods(PPID goodsID, uint * pPos, PUGI * pItem = 0) const;
	void   Clear();
	void   ClearActions();
	int    AddAction(int16);

	int    OPcug;
	PPID   LocID;
	LDATE  Dt;           // Date of the earliest deficit bill
	PPID   SupplAccSheetForSubstID; // Идент таблицы статей для подстановки поставщиков. Если 0, то подстановка поставщиков не может быть применена.
	uint16 ActionsCount; //
	int16  Actions[9];   //
	int    CostByCalc;
	double CalcCostPct;
	TSVector <SupplSubstItem> SupplSubstList; // Список определителей подстановки поставщиков,
		// применяемый для оприходования дефицита с привязкой к конкретным поставщикам.
	SetLotManufTimeParam Slmt; // Параметры установки времени производства для лотов дефицита
	static int BalanceSupplSubstList(TSVector <SupplSubstItem> & rList, double neededeQtty);
};
//
//
//
struct CompleteItem { // @flat
	CompleteItem();
	enum {
		fExclude = 0x0001, // Этот лот исключен операцией рекомплектации
		fBranch  = 0x0002, // Лот, произведенный из исходного лота (выход)
		fSource  = 0x0004  // Источник (расход)
	};
	PPID   GoodsID;
	PPID   LotID;
	PPID   BillID;         // Ид документа, сформировавшего строку
	LDATE  Dt;             // Дата документа, сформировавшего эту строку
	LDATE  Expiry;         // Срок годности, лота, соответствующего строке
	PPID   ArID;           // Контрагент по документу, сформировавшему эту строку
	char   Serial[24];
	double Qtty;
	double Cost;
	double Price;
	long   Flags;
};

class CompleteArray : public TSVector <CompleteItem> {
public:
	CompleteArray();
	CompleteArray(const CompleteArray &);
	CompleteArray & FASTCALL operator = (const CompleteArray &);
	int    IsExcludedLot(PPID lotID) const;
	int    RemoveExludedItems(PPID exclLotID);
	int    SearchLotID(PPID lotID, uint * pPos, CompleteItem *) const;
	int    SearchGoodsID(PPID goodsID, uint * pPos, CompleteItem *) const;

	PPID   LotID;  // Лот, по которому строится массив
	PPID   BillID;
};
//
//
//
// @v12.2.11 (replaced with PPLinkFile::fIsNew) #define PPLNKFILE_ISNEW 0x00000001L

struct PPLinkFile {
	PPLinkFile();
	int    Init(const char * pPath);
	size_t Size() const;
	int    FASTCALL CopyFrom(const void * pBuf);
	int    CopyTo(void ** ppBuf);

	enum { // @v12.2.11
		fIsNew = 0x00001
	};
	PPID   Id;
	long   Flags;
	SString Ext;
	SString Path;
	SString Description;
};

class PPLinkFilesArray : public TSCollection <PPLinkFile> {
public:
	explicit PPLinkFilesArray(const char * pStoreDir = 0);
	PPLinkFilesArray & FASTCALL operator = (const PPLinkFilesArray & s);
	int    Init(const char * pStoreDir);
	int    Add(PPLinkFile * pLink, uint * pPos);
	int    AddNewByExt(const char * pExt, const char * pDescr, uint * pPos);
	int    Remove(uint pos);
	int    RemoveByAry(const PPLinkFilesArray * pAry);
	int    GetFilePath(PPID id, const char * pExt, SString & rFilePath) const;
	int    GetFilePath(uint pos, SString & rFilePath) const;
	int    Edit(uint pos);
	int    EditDescr(uint pos);
	int    ReadFromProp(PPID billID);
	int    WriteToProp(PPID billID, int useTa);
private:
	int    CreateWordFile(const char * pPath);
	int    CreateExcelFile(const char * pPath);
	PPID   GetNewId() const;
	struct _Entry {
		PPID   Tag;            // Const=PPOBJ_BILL
		PPID   ID;             // BillID
		PPID   Prop;           // Const=BILLPRP_LINKFILES
		int16  ItemsCount;
		int16  Size;
	};
	SString StoreDir;
};

typedef TSVector <PPTransferItem> PPTrfrArray;
typedef TSVector <InventoryTbl::Rec> InventoryArray;
//
// Descr: Варианты распределения дополнительной себестоимости на себестоимость
//   отдельных строк товарного документа.
//
enum {
	ecalgCost = 1, // Пропорционально сумме в ценах поступления (без учета дополнительной себестоимости)
	ecalgPrice,    // Пропорционально сумме в ценах реализации
	ecalgQtty,     // Пропорционально количеству
	ecalgPhQtty,   // Пропорционально физическому количеству
	ecalgBrutto,   // Пропорционально массе брутто
	ecalgVolume,   // Пропорционально объему
};
//
// @todo @dbd_exchange Увеличить длину поля примечания //
//
class PPBillPacket : public PPBill {
public:
	enum PoolKind {
		bpkNone  = -1,    // Отсутствует принадлежность пулу
		bpkOpBill = 0,    // Управляемый пул документов (принадлежит документу)
		bpkReckon = 1,    // Зачитывающие документы
		bpkCSess,         // Документы списания кассовой сессии
		bpkTSess,         // Документы списания технологической сессии
		bpkCSessDfct,     // Документы покрытия дефицита по кассовым сессиям
		bpkTSessDfct,     // Документы покрытия дефицита по технологическим сессиям
		bpkTodo,          // Документы, привязанные к задачам
		bpkPrj,           // Документы, привязанные к проектам
		bpkPrjPhase,      // Документы, привязанные к фазма проектов
		bpkTSessPaym,     // Документы оплаты технологической сессии. Проецируется в тот же тип ассоциации пулов документов, что и bpkTSess.
		bpkOrdAccomplish, // @v12.0.11 Сопутствующие документы списания товарного заказа в отгрузку
	};

	static PPBillPacket::PoolKind ObjAssocToPoolKind(PPID assocID);
	static PPID PoolKindToObjAssoc(PPBillPacket::PoolKind kind);

	PPBillPacket();
	PPBillPacket(const PPBillPacket & rS);
	~PPBillPacket();
	PPBillPacket & FASTCALL operator = (const PPBillPacket & rS);
	void   destroy();
	int    FASTCALL Copy(const PPBillPacket & rS);
	int    CreateBlank(PPID opID, PPID linkBill, PPID locID, int use_ta);
	int    CreateBlank_WithoutCode(PPID opID, PPID linkBill, PPID locID, int use_ta);
	int    CreateBlank2(PPID opID, LDATE dt, PPID locID, int use_ta);
	//
	// Descr: пытается из элементов массива ShLots создать теневой пакет. Если ей удается это сделать,
	//   то возвращает >0, если больше ни одного теневого пакета создать невозможно, то возвращает <0.
	//   В случае ошибки - 0. Те строки, которые уже использовались для создания теневых пакетов отмечаются //
	//   флагом TFlags & PPTransferItem::tfDirty. Поэтому перед первым вызовом следует сбросить этот флаг для всех элементов
	//   массива ShLots (если, конечно, он не нулевой) либо предварительно вызвать ее с нулевым параметром
	//   shadow. Эта функция самостоятельно инициализирует пакет shadow.
	//
	int    CreateShadowPacket(PPBillPacket * pShadow);
	int    CreateBlankBySample(PPID sampleBillID, int use_ta);
	int    CreateBlankByFilt(PPID opID, const BillFilt * pFilt, int use_ta);
	//
	struct SetupObjectBlock {
		SetupObjectBlock();
		//
		// Note: Функция не обнуляет поле Flags так как оно задается как параметр для PPBillPacket::SetupObjectBlock.
		//
		SetupObjectBlock & Z();

		enum {
			fEnableStop = 0x0001 // Допускается устанавливать контрагента с признаком STOP
		};
		long   Flags; // [IN] Флаги вызова функции PPBillPacket::SetupObject
		enum {
			stHasCliAgreement   = 0x0001,
			stHasSupplAgreement = 0x0002
		};
		long   State;
		PPID   PsnID;
		SString Name;
		LAssocArray RegInfoList; // Список регистров, с которыми у контрагента существует проблема.
			// Поле Key каждого элемента хранит ID типа регистрационного документа,
			// а поле Val либо ID просроченного регистра персоналии, либо 0, если
			// контаргент должна иметь такой регистр, но не имеет.
		PPClientAgreement CliAgt;
		PPSupplAgreement  SupplAgt;
	};
	//
	// Descr: Устанавливает статью контрагента в пакет документа (Rec.Object). Выполняет все необходимые проверки.
	//
	int    SetupObject(PPID arID, SetupObjectBlock & rRet);
	//
	// Descr: Устанавливает дополнительную статью в пакет документа (Rec.Object2). Выполняет все необходимые проверки.
	//
	int    SetupObject2(PPID arID);
	int    SetupDlvrAddr(PPID dlvrAddrID);
	//
	// Descr: Устанавливает в пакете специальные атрибуты, зависящие от EDI-источника документа:
	//   -- вид EDI операции (PPEDIOP_XXX)
	//   -- дескриптор EDI-канала (PPTAG_BILL_EDICHANNEL)
	//   -- EDI-идентификатор документа (PPTAG_BILL_EDIIDENT)
	//
	void   SetupEdiAttributes(int ediOp, const char * pEdiChannel, const char * pEdiIdent);
	LDATE  CalcDefaultPayDate(int paymTerm, long paymDateBase) const;
	int    SetupDefaultPayDate(int paymTerm, long paymDateBase);
	//
	// Descr: Возвращает адрес электронной почты, наиболее близко
	//   согласующийся с контекстом документа. Чаще всего, это - адрес
	//   контрагента, но не обязательно.
	//   Функция реализована с целью автоматизации пересылки
	//   результатов экспорта отчетов.
	//
	int    GetContextEmailAddr(SString & rBuf) const;
	//
	// Descr: Заносит в массив rList список идентификаторов документов заказа, которые
	//   обслуживаются данным пакетом.
	//   Массив rList очищается в начале выполнения этой функции //
	// Returns:
	//   >0 - данный документ обслуживает как минимум один документ заказа
	//   <0 - данный документ не обслуживает документы заказов
	//   0  - ошибка
	//
	int    FASTCALL GetOrderList(PPIDArray & rList) const;
	//
	// Descr: Возвращает статус синхронизации документа.
	// Note: Аналогичный (но более подробный) результат можно получить
	//   используя функцию ObjSyncCore::GetSyncStatus() однако данная  функция //
	//   сохраняет результат первого вызова ObjSyncCore::GetSyncStatus() во внутреннем
	//   состоянии this с тем, чтобы ускорить последующие аналогичные вызовы.
	// Returns:
	//     >0 - документ синхронизирован с другим разделом
	//     <0 - документ не синхронизирован
	//
	int    GetSyncStatus();
	int    FASTCALL EnumTItems(uint *, PPTransferItem **) const;
	int    GetNextPLU(TiIter * pI, long * pPLU, SString & rObjAsscName);
	//
	// Descr: перечисляет товарные строки документа с одновременным слиянием,
	//   определяемым флагами flags. Если pIter == 0, то используется внутренний
	//   итератор, который должен быть предварительно инициализирован вызовом InitExtTIter.
	//
	void   InitExtTIter(long flags, long filtGrpID = 0, TiIter::Order = TiIter::ordDefault);

	struct TiItemExt {
		TiItemExt();
		void   Clear();

		SString Clb;
		SString Pckg;
		LocTransfTbl::Rec LctRec;
		LongArray MergePosList; // Список позиций Lots (0..), слитых в одну в результате вызова MergeTI
	};
	int    EnumTItemsExt(TiIter * pIter, PPTransferItem * pTi, TiItemExt * pExt = 0);
	//
	// Descr: Возвращает количество товарных строк пакета
	//
	uint   GetTCount() const;
	//
	// Descr: Возвращает количество товарных строк пакета в виде целого числа со знаком (просто удобно если необходимо сравнение со знаковым числом)
	//
	int    GetTCountI() const; 
	int    FASTCALL SetTPointer(int);
	int    GetTPointer() const;
	int    FASTCALL ChkTIdx(int) const;
	PPTransferItem & FASTCALL TI(uint) const;
	const  PPTransferItem & FASTCALL ConstTI(uint) const;
	const  PPTrfrArray & GetLots() const;
	//
	// Descr: Функция устанавливает список строк документа пакета из источника rS.
	// Note: Ни в коем случае не используйте эту функцию, она предназначена только для аварийного
	//   восстановления пакета после ошибки в проведении.
	//
	void   SetLots(const PPTrfrArray & rS);
	bool   FASTCALL SearchTI(int rByBill, uint * pPos) const;
	//
	// Descr: Возвращает идентификатор предпочтительного поставщика по строке.
	//   Значение извлекается из зарезервированного тега PPTAG_LOT_PREFSUPPL.
	//
	PPID   GetPrefSupplForTi(uint tiIdx/*0..*/) const;
	int    SetupPrefSupplForTi(uint tiIdx/*0..*/, PPID supplID);
	bool   UsesDistribCost() const;
	//
	// Descr: заносит элемент pItem в список товарных строк документа
	// ARG(pItem   IN): @#{ptr} указатель на элемент для вставки в список
	// ARG(pClb    IN): @#{vptr0} номер ГТД, ассоциированный со строкой
	// ARG(pSerial IN): @#{vptr0} серийный номер, ассоциированный со строкой
	// Returns:
	//   !0 - элемент успешно добавлен в список
	//   0  - ошибка при добавлении элемента
	//
	int    LoadTItem(const PPTransferItem * pItem, const char * pClb, const char * pSerial);
	int    FASTCALL AddShadowItem(const PPTransferItem *);
	int    AddShadowItem(const PPTransferItem * pOrdItem, uint * pPos);
	int    InitACPacket();
	void   CreateAccTurn(PPAccTurn & rAt) const;
	int    UngetCounter();
	void   FASTCALL SetQuantitySign(int minus /*= -1*/);
	//
	// Descr: Сортирует строки по параметру PPTransferItem::RByBill
	// Note: Использовать очень аккуратно, поскольку существуют привязки к позициям строк в массиве Lots
	//
	void   SortTI();
	//
	// Descr: Факторы различий строк пакетов при сравнении
	//
	enum {
		tidfQtty               = 0x0002, // Отличается количество
		tidfCost               = 0x0004, // Отличается цена поступления
		tidfPrice              = 0x0008, // Отличается учетная цена реализации
		tidfNetPrice           = 0x0010, // Отличается чистая цена (Price-Discount)
		tidfThisAbsent         = 0x0020, // В пакете this отсутствует строка, соответствующая строке в other
		tidfOtherAbsent        = 0x0040, // В пакете other отсутствует строка, соответствующая строке в this
		tidfRByBillPrec        = 0x0080, // Сравнение документов осуществляется с точностью до номера строки
			// (имеется в виду внутренний идентификатор позиции RByBill)
		tidfIgnoreGoods        = 0x0100, // Игнорировать отличие товаров в сравниваемых строках
		tidfStrictEgaisCodeTag = 0x0200, // Сопоставлять код ЕГАИС в теге лота
		tidfIgnoreSign         = 0x0400  // При сопоставлении игнорировать знаки операци (приход/расход)
	};
	struct TiDifferenceItem {
		TiDifferenceItem(long flags, const LongArray * pThisPList, const LongArray * pOtherPList);
		LongArray ThisPList;  // Список позиций строки в this
		LongArray OtherPList; // Список позиций строки в сравниваемом пакете
		long   Flags;     // Факторы расхождений
		double ThisQtty;
		double OtherQtty;
		double ThisCost;
		double OtherCost;
		double ThisPrice;
		double OtherPrice;
		double ThisNetPrice;
		double OtherNetPrice;
	};
	//
	// Descr: Функция сравнения товарных строк пакета this с пакетом rS.
	// ARG(rS         IN): Пакет документа, с которым сравнивается this
	// ARG(tidFlags   IN): PPBillPacket::tidfXXX Опции сравнения. Определяет флаги, соответствующие критериям сравнения строк.
	// ARG(filtGrpID  IN): Фильтрующая товарная группа ограничивающая перечисляемые строки пакетов.
	// ARG(rDiffList OUT): Результат сравнения - список элементов TiDifferenceItem определяющих рассогласование строк пакетов.
	//   Если при завершении функции список пуст, значит пакеты в пределах заданных критериев эквивалентны.
	//
    int    CompareTI(PPBillPacket & rS, long tidFlags, long filtGrpID, TSCollection <TiDifferenceItem> & rDiffList);
    int    CompareTIByCorrection(long tidFlags, long filtGrpID, TSCollection <TiDifferenceItem> & rDiffList);
	void   SetPoolMembership(PoolKind billPoolKind, PPID poolID);
	//
	// Descr: Возвращает номинальную сумму из записи документа.
	//   Если параметр minus != 0, то возвращается значение с инвертированным знаком.
	//
	double FASTCALL GetAmount(int minus = 0) const;
	//
	// Descr: Возвращает номинальную сумму документа в базовой валюте.
	//   Если Rec.CurID, то результат эквивалентен GetAmount(int),
	//   в противном случае возвращается GetAmount(minus) * Amounts.Get(PPAMT_CRATE, Rec.CurID).
	//
	double FASTCALL GetBaseAmount(int minus = 0) const;
	int    GetQuotKindList(PPIDArray * pList);
	int    GetQuotExt(const PPTransferItem & rTi, double * pPrice);
	//
	// Descr: распределяет заданную на весь документ скидку по товарным строкам пакета.
	// ARG(dis       IN): значение скидки. Если dis == 0, то во всех строках значение скидки обнуляется.
	// ARG(pctdis    IN): если !0, то скидка задана в процентах (не в долях
	//   от единицы, а именно в процентах).
	// ARG(rmvexcise IN): указывает на необходимость снятия со всех строк налога с продаж.
	//   Скидка в этом случае рассчитывается на сумму без налога с продаж.
	//
	void   SetTotalDiscount(double dis, int pctdis, int rmvexcise);
	void   SumAmounts(AmtList & rList);
	void   SumAmounts_ComparingWithOrgPack(AmtList & rList, const PPBillPacket * pOrgPack, int * pFirstDiffRowN);
	void   FASTCALL InitAmounts(const AmtList &);
	void   FASTCALL InitAmounts();
	//
	// Descr: Идентифицирует долговую размерность, которой принадлежи документ.
	//   Идентификатор размерности возвращается по указателю pDebtDimID.
	// Returns:
	//   1 - найдена единственная размерность, соответствующая пакету.
	//   2 - существует более одной размерности, соответствующей пакету. Однако, по указателю
	//       pDebtDimID присвоено значение одной из них (порядок не документирутеся, такио образом,
	//       существует неопределенность).
	//  <0 - не найдено ни одной размерности, которой соответствова бы пакет.q
	//  0  - ошибка.
	//
	int    GetDebtDim(PPID * pDebtDimID) const;
	void   CalcModifCost();
	int    CalcTotal(BillTotalData & rTotal, long btcFlags /* BTC_XXX */);
	int    CalcTotal(BillTotalData & rTotal, PPID goodsTypeID, long btcFlags /* BTC_XXX */);
	bool   SearchGoods(PPID goodsID, uint * pPos) const;
	int    HasOneOfGoods(const ObjIdListFilt & rList) const;
	//
	// Descr: Опции функции CheckGoodsForRestrictions()
	//
	enum {
		cgrfAll              = 0xffffffff, // Полная проверка
		cgrfObject           = 0x00000001, // Проверять по статье документа
		cgrfObject2          = 0x00000002, // Проверять по дополнительной статье документа
		cgrfMatrix           = 0x00000004, // Проверять соответствие товарной матрице
		cgrfGoodsGrpRestrict = 0x00000008, // Проверять соответствие ограничению пользователя по товарным группам
		cgrfShipmControl     = 0x00000010, // Проверять на согласованность с предыдущими отгрузками/возвратами
		cgrfModifCmplmnry    = 0x00000020, // Проверять на комплементарность товаров в документе модификации
		cgrfQtty             = 0x00000040  // Проверять критерии в которых фигурирует количество товара
	};
	struct CgrRetBlock {
		CgrRetBlock();

		long   ScpDuration;
		long   ScpShipmBillCount;
		long   ScpRetBillCount;
		double ScpShipmQtty;
		double ScpRetQtty;
		double ScpResult;
		RealRange ScpRange;
	};
	//
	// Descr: Проверяет товар goodsID на допустимость нахождения в документе this.
	// ARG(rowIdx   IN): @[0..] Индекс строки документа, в которой находится проверяемый товар.
	//   Если rowIdx < 0, то проверяемый товар еще не в документе
	// ARG(goodsID  IN): ИД товара
	// ARG(sign     IN): @#{TISIGN_MINUS || TISIGN_PLUS || TISIGN_UNDEF} Знак операции.
	//   Имеет значение только при rowIdx < 0, в противном случае знак опредяляется из параметров существующей строки
	// ARG(qtty     IN): Количество товара
	// ARG(flags    IN): Флаги PPBillPacket::cgrfXXX
	// ARG(pRetBlk OUT): Указатель на блок, в который записывается информация о проверке
	//
	int    CheckGoodsForRestrictions(int rowIdx, PPID goodsID, int sign, double qtty, long flags, CgrRetBlock * pRetBlk);
	bool   SearchLot(PPID lotID, uint * pPos) const;
	bool   SearchShLot(PPID lotID, uint * pPos) const;
	//
	// Следующие две функции определяют остаток по заданному лоту и заказному лоту соответственно
	// в контексте пакета. Вместе с идентификатором лота и указателем на остаток им необходимо
	// передать указатель на один элемент и его позицию в пакете. Это используется в диалоге
	// редактирования элемента пакета. Если передаваемый элемент не является членом пакета, то
	// его позиция должна быть равна -1. В этом случае можно вместо указателя на элемент передать
	// нулевой указатель. Функции RestByOrderLot передается элемент ShLots.
	// Нулевой ид лота обрабатывается нормально. Если rest == 0, то
	// возвращается 0.
	//
	int    RestByLot(PPID, const PPTransferItem * pTi, int pos, double *) const; // @>>BillObj->trfr->GetRest
	int    RestByOrderLot(PPID, const PPTransferItem *, int pos, double *) const;
	//
	// Descr: аналогична Transfer::GetBounds, но в контексте пакета.
	//   Относительно 2-го и 3-го параметров см. предыдущие комментарии.
	//
	int    BoundsByLot(PPID lotID, const PPTransferItem * pTi, int pos, double * pDown, double * pUp) const;
		// @>>Transfer::GetBounds
	//
	// Descr: вычисляет остаток товара, перебирая все открытые лоты и вызывая RestByLot
	//   или RestByOrderLot в зависимости от знака goods. Если goodsID < 0, то по указателю pReserve
	//   возвращается зарезервированное количество товара (лоты заказов, имеющие признак LOTF_ORDRESERVE).
	//
	int    GoodsRest(PPID goodsID, const PPTransferItem *, int pos, double * pRest, double * pReserve = 0);
	int    CalcShadowQuantity(PPID lot, double * pQtty) const;
	int    InsertRow(const PPTransferItem *, LongArray *, int pcug = PCUG_CANCEL);
	int    RemoveRow(uint *);
	int    RemoveRow(uint);
	int    RemoveRows(LongArray * pPositions, int lowStop = 0);
	int    ShrinkTRows(long fl = (ETIEF_DIFFBYLOT | ETIEF_UNITEBYGOODS));
	int    InsertComplete(PPGoodsStruc & rGs, uint pos, PUGL *, int pcug, const GoodsReplacementArray * pGra, bool recursive);
	int    InsertPartitialStruc();
	int    InsertAutoComplRow(uint pos, int pcug = PCUG_CANCEL);
	int    UpdateAutoComplRow(uint pos, int pcug = PCUG_CANCEL);
	int    RemoveAutoComplRow(uint pos);
	int    GetComplete(PPID lotID, CompleteArray * pList);
	//
	// Descr: возвращает true если пакет относится к операции модификации и содержит
	//   как минимум одну товарную строку, помеченную признаками PPTFR_PLUS и
	//   PPTFR_RECEIPT (независимый выход). Такие строки недопустимы в пакете рекомплектации.
	//
	bool   HasIndepModifPlus() const;
	//
	// Descr: используется в диалоге TrfrItemDialog. Это весьма развитая функция.
	//   Она добавляет новую или изменяет существующую товарную строку, одновременно обрабатывая все
	//   служебные данные, связанные с этой строкой (заказ, автокомплект, дополнительное количество
	//   расходуемого товара сверх остатка текущего лота).
	//
	int    SetupRow(int itemNo, PPTransferItem * pItem, const PPTransferItem * pOrdItem, double extraQtty);
	int    AttachRowToOrder(int itemNo, const PPBillPacket * pOrdPack);
	int    AttachToOrder(const PPBillPacket * pOrdPack);
	int    SetupItemQuotInfo(int itemNo, PPID quotKindID, double quotValue, long flags);
	//
	// Descr: Проверяет размер документа и, если он слишком большой и genWarn != 0,
	//   то предупреждает об этом и рекомендует его сохранить, при этом
	//   возвращает !0. Если размер документа приемлем, то возвращает 0.
	//
	int    CheckLargeBill(int genWarn) const;

	struct ConvertToCCheckParam {
		ConvertToCCheckParam();
		bool SetBuyersEAddr(int addrType, const char * pAddr);
		enum { // @v11.1.5
			fCash      = 0x0001,
			fBank      = 0x0002,
			fPrepay    = 0x0004,
			fPaperless = 0x0008, // @v11.3.7
			fDoChZnPm  = 0x0010, // @v12.1.6 Осуществлять проверку марок разрешительным режимом чзн 
		};
		PPID   PosNodeID;
		int    PaymType;
		PPID   LocID;
		int    DivisionN;
		SString Info;
		double Amount; //@erik v10.5.9
		long   Flags_;  //@erik v10.5.9
		// @v11.8.11 int    BuyersEAddrType; // @v11.3.7 (0|SNTOK_EMAIL|SNTOK_PHONE)
		// @v11.8.11 SString BuyersEAddr; // @v11.3.7
		CCheckPacket::BuersEAddr_ EAddr;  // @v11.8.11 Электронный адрес покупателя (email or phone)
	};
	//
	// Descr: Преобразует пакет товарного документа в пакет кассового чека.
	//   Функция пригодна только для печати чека.
	//
	int    ConvertToCheck(CCheckPacket * pCheckPack) const;
	//
	// Descr: Расширенная процедура преобразования документа в кассовый чек.
	//   Реализована с целью включения в функцию печати чека по документу и для импорта документов
	//   в виде чеков в кассовой панели.
	// Note: Не формирует номер чека, поскольку для этого требуется доступ к CCheckCore и, кроме того,
	//   не известно время жизни созданного объекта CCheckPacket в памяти - номер последнего чека может
	//   оказаться не актуальным.
	//
	int    ConvertToCheck2(const ConvertToCCheckParam & rParam, CCheckPacket * pCheckPack, TSCollection <SCompoundError> * pErrList) const;
	int    SetCurTransit(const PPCurTransit * pTrans/*In*/);
	int    GetCurTransit(PPCurTransit * pTrans/*Out*/) const;
	int    AddPckg(LPackage *);
	int    CalcPckgTotals();
	//
	// Descr: инициализирует идентификаторы лотов пакета перед занесением пакета в базу данных.
	// @! Really PRIVATE function.
	//
	int    InitPckg(); // @<<PPObjBill::PutPackgList
	//
	// Returns:
	//   true  - вид операции (Rec.OpID), к которой относится данный пакет принадлежит
	//      одному из типов: {PPOPT_DRAFTRECEIPT, PPOPT_DRAFTEXPEND, PPOPT_DRAFTTRANSIT}
	//   false - в противном случае
	//
	bool   IsDraft() const; //
	bool   IsGoodsDetail() const;
	int    SetupVirtualTItems();
	int    RemoveVirtualTItems();
	//
	// Descr: Извлекает идентификатор главной организации в контектсе пакета документа.
	// Note: Чаще всего результат идентичен вызову функции ::GetMainOrgID(), однако,
	//   если (PPBillConfig::Flags & BCF_EXTOBJASMAINORG) и дополнительная статья документа
	//   ссылается на главную организацию, то результатом будет эта главная организация.
	//
	int    GetMainOrgID_(PPID * pID) const;
	int    AddTSessCip(PPID tsessID, const char * pPlaceCode, PPID personID);
	int    SerializeLots(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Поля ErrCause & ErrLine служат для диагностики ошибок при проводке документа.
	// Их значения существенны только в случае, если произошла ошибка в методах
	// PPObjBill::TurnPacket, PPObjBill::UpdatePacket и /PPObjBill::RemovePacket/. Если
	// ErrCause принимает значение err_on_line, то ошибка произошла при проводке (изменении/, удалении/)
	// товарной строки, при этом ErrLine содержит номер строки в массиве Lots. Если ErrCause
	// принимает значение err_on_accturn, то ошибка произошла в одной из бух. проводок документа.
	// Тогда ErrLine принимает номер этой проводки. ErrLine == -1 означает, что невозможно точно
	// указать строку с ошибкой.
	//
	enum {
		err_on_line = 1,
		err_on_accturn,
		err_on_advline
	};
	int    ErrCause;
	int    ErrLine;
	PPIDArray TiErrList; // Список номеров [0..] позиций строк, содержащих ошибки
	//
	// Следующее поле используется для указания того, в каких ценах
	// следует выводить документ на печать или на экспорт.
	// 1 - в ценах поступления (cost),
	// 2 - в ценах реализации (price-discount),
	// other - в обеих ценах (номинал по умолчанию)
	//
	int    OutAmtType;
	PPID   QuotKindID;    // @transient Вид котировки, применяемый в документе. Актуально только во время одной сессии редактирования документа.
	PPID   AgtQuotKindID; // @transient Вид котировки из соглашения с клиентом. Используется в диалогах товарных строк документов для выбора котировки.
	PPID   OpTypeID;      //
	PPID   AccSheetID;    //
	long   Counter;
	//
	// P_ShLots - теневые строки, отражающие исполнение заказов.
	// Строки Lots ссылаются на P_ShLots как OrdLotID->LotID.
	// Отношение типа многие-к-одному. То есть ShLots содержит
	// не более одного элемента с заданным лотом, на который
	// могут ссылаться более одного элемента из Lots.
	//
	PPTrfrArray * P_ShLots;
	PPBillPacket * P_ACPack;   // Агрегированный пакет автокомплектации
	PPBillPacket * P_Outer;    // @notowned Внешний (агрегирующий) пакет
	PPBillPacket * P_LinkPack; // @transient Пакет связанного документа
	LPackageList * P_PckgList; //

	struct QuotSetupInfoItem { // @flat
		QuotSetupInfoItem();

		enum {
			fMissingQuot = 0x0001,
			fInvalidQuot = 0x0002
		};
		uint   TiPos;
		long   Flags;
		PPID   QkID;
		double Value;
	};
	TSVector <QuotSetupInfoItem> * P_QuotSetupInfoList;
	PPLotTagContainer * P_MirrorLTagL; // Список тегов зеркальных лотов (созданных при межскладском перемещении)
	PPID   PaymBillID;         // @*PPObjBill::ExtractPacket Платежный документ (зачеты).
	PPID   OrderPoolBillID;    // @v12.0.11 @*PPObjBill::ExtractPacket Документ заказа, для которого данный документ является членом пула сопутствующих документов списания //
	PPID   CSessID;            // Кассовая или технологическая сессия, которую списывает документ
	PPID   SampleBillID;       // Документ, по образцу которого создается this документ
	//
	// Descr: Флаги обработки документа
	//
	enum { // @transient
		pfHasVirtualTI          = 0x00000001, // Пакет содержит виртуальные товарные строки
		pfPrintOnlyUnlimGoods   = 0x00000002, // Вывод на печать только нелимитируемых товаров
		pfPrintPLabel           = 0x00000004, // Печатать ценник
		pfPrintQCertList        = 0x00000008, // Серификаты к документу печатать списком "для каждого товара - все серитфикаты"
		pfViewPercentOnTurn     = 0x00000010, // Показывать проценты при проведении документа
		pfErrOnTiLoading        = 0x00000020, // Признак ошибки загрузки товарных строк документа
			// Устанавливается функцией Transfer::LoadItems
		pfPrintTareSaldo        = 0x00000040, // Печатать сальдо по отгрузке тары
		pfAllGoodsUnlim         = 0x00000080, // @*PPBillPacket::CalcTotal() Все товары в документе - нелимитированные
		pfHasExtCost            = 0x00000100, // @*PPBillPacket::SumAmounts() Товарный документ содержит
			// распределенную себестоимость. Флаг используется при редактировании строк документа с целью быстро
			// определить необходимость пересчета себестоимости.
		pfPrintChangedPriceOnly = 0x00000200, // Печать только тех товаров, цены на которые изменились в сравнении с последним лотом
		pfRestrictByArCodes     = 0x00000400, // Запрет на добавление в документ товаров, не имеющих
			// кода, связанного с основной статьей документа.
		pfSubCostOnSubPartStr   = 0x00000800, // При распределении частичной структуры, вычитающей количество
			// из основного товара, уменьшать себестоимость документа.
			// @seealso AGTF_SUBCOSTONSUBPARTSTR
		pfChargeSCard           = 0x00001000, // С документом связана карта и есть сумма, по которую
			// необходимо начислить на кредитную карту.
		pfForeignSync           = 0x00002000, // Пакет создан в рамках приема данных из другого раздела
		pfIgnoreStatusRestr     = 0x00004000, // При изменении документа игнорировать ограничения статуса
		pfForceRByBill          = 0x00008000, // Для новых строк документа использовать тот RByBill, который указан (не обнулять)
		pfUpdateProhibited      = 0x00020000, // Проведение этого пакета функцией PPObjBill::UpdatePacket запрещено (например, по причене не полной загрузки).
		pfIgnoreOpRtList        = 0x00040000, // При изменении документа игнорировать ограничения списка доступных операций.
			// Флаг устанавливается при рекурсивном вызове PPObjBill::UpdatePacket
		pfZombie                = 0x00080000, // Документ восстановлен из истории версий (прямое изменение запрещено)
		pfDetectModificDetails  = 0x00100000, // @v12.2.8 При редактировании пакета программа (всего лишь) пытается четко локализовать отличия редактированного
			// пакета от оригинального.
	};
	long   ProcessFlags;       // @transient
	PPLinkFilesArray LnkFiles;
	InventoryArray InvList; // Список строк инвентаризации (введен исключительно для сериализации строк удаляемой инвентаризации - дальше будет видно)
	//
	// Список персональных регистраций, ассоциированных с документом.
	// Note: Здесь нельзя использовать высокоуровневый класс PPCheckInPersonArray
	//   поскольку он полностью ассоциирован с одной техсессией в то время как
	//   с документом может быть связано несколько регистраций, принадлежащих разным сессиям.
	//
	struct CipBlock {
		CipBlock();
		CipBlock(const CipBlock & rS);
		~CipBlock();
		CipBlock & FASTCALL operator = (const CipBlock & rS);
		int    FASTCALL Copy(const CipBlock & rS);
		void   destroy();

		TSVector <PPCheckInPersonItem> * P_CipList;
		PPObjTSession * P_TSesObj;
	};
	CipBlock CipB;
	LDATETIME LoadMoment; // @transient Момент загрузки пакета из базы данных.
private:
	void   Helper_Init();
	int    _CreateBlank(PPID oprKind, PPID linkBill, PPID locID, int dontInitCode, int use_ta);
	void   AdjustLotQtty(PPID lot, const PPTransferItem *, int, double *) const; // @>>BillObj->trfr->SubtractBillQtty()
	int    MergeTI(PPTransferItem * pItem, int idx, long flags, LongArray & rTotalMergeList, LongArray * pMergePosList);
	int    Helper_DistributeExtCost(double extCostSum, int alg);
	int    DistributeExtCost();
	void   Implement_SumAmounts(AmtList & rList, const PPBillPacket * pOrgPack, int * pFirstDiffRowN);

	PPTrfrArray Lots;
	TiIter * P_Iter;
	PPObjBill * P_BObj;
	LAssocArray * P_GoodsGrpRestrict; // @transient Список товарных групп, с которыми ассоциированы
		// опции ограничений на вставку соответствующих товаров в документ.
	int16  SyncStatus; // Статус синхронизации документа с другими разделами. -2 - состояние не определено
	int16  Reserve;    // @alignment
};

class PPBillPacketCollection : public TSCollection <PPBillPacket> {
public:
	PPBillPacketCollection();
	PPBillPacketCollection(const PPBillPacketCollection & rS);
	PPBillPacketCollection & FASTCALL operator = (const PPBillPacketCollection & rS);
	bool FASTCALL Copy(const PPBillPacketCollection & rS);
	PPBillPacket * SearchByObject(PPID arID) const;
	//
	// Descr: Ищет среди пакетов коллекции товарную строку, содержащую значение поля PPTransferItem::SrcIltiPos == srcIltiPos
	//   В случае, если искомая строка найдена, то возвращает указатель на пакет документа, а по указателю pItIdx 
	//   присваивает индекс строки [0..]
	// Note: не зависимо от того, сколько пакетов и сколько их строк содержит искомое значение PPTransferItem::SrcIltiPos
	//   функция найдет только первую встреченную строку и вернет ссылку на нее. Порядок перебора - естественный порядок
	//   пакетов в коллекции и строк в пакете.
	// ARG(srcIltiPos IN): Искомое значение PPTransferItem::SrcIltiPos [1..]
	//
	const PPBillPacket * Search_SrcIltiPos(uint srcIltiPos, uint * pTiIdx) const;
};
//
// Intermediate Level Bill Packet
// Пакет документа, хранящий товарные строки в формате ILTI.
//
#define ILBPF_LOADAMTNOTLOTS  0x0001   // Загружать список сумм Amounts, а не товарные строки (функция Load)

struct ILBillPacket : public PPBill {
	ILBillPacket();
	~ILBillPacket();
	void   destroy();
	//
	// Descr: конвертирует пакет this в пакет документа PPBillPacket.
	//   Параметр *pWarnLevel получает значение 1 если не сошлась номинальная //
	//   сумма исходного и полученного пакетов, значение 2 если хотя бы в одной строчке исходного
	//   пакета осталось ненулевым поле ILTI::Rest. Если таковых проблем не встретилось, то
	//   параметр *warnlevel получает значение 0. Указатель pWarnLevel может быть нулевым
	//   (тогда, естественно, он и не инициализируется в функции).
	//
	int    ConvertToBillPacket(PPBillPacket & rPack, int * pWarnLevel, ObjTransmContext * pCtx, int use_ta);
		// @<<PPObjBill::Write
	int    ConvertRow(ILTI *, PPBillPacket *);
	int    SearchGoodsID(PPID goodsID, uint * pPos) const;
	int    SearchRByBill(int rbb, uint * pPos) const;
	int    Load__(PPID billID, long flags /* ILBPF_XXX */, PPID cvtToOpID = 0);
	int    SerializeLots(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		ilbfConvertedIntrExp = 0x0001 // Внутренняя передача конвертированная в межскладской приход.
			// Признак необходим для правильной синхронизации лотов.
	};
	//
	// Так как таблица складов тесно взаимодействует с соответствующей аналитической таблицей,
	// то для переноса документа между разделами базы данных необходимо перенести и ссылку на
	// аналитическую статью, соответствующую складу, которому соответствует документ.
	//
	PPID   LocObj;
	long   IlbFlags;
	TSVector <ILTI> Lots;
	PPIDArray OrderBillList;   // Список документов заказа, которые "закрываются" данным документом
	InventoryArray InvList;    // Список строк инвентаризации
};
//
// Descr: Абстрактный класс-контейнер. Реализация этого интерфейса должна обеспечивать
//   хранение списка выходных дней раздельно по каждому складу (locID).
//   Формат представления выходного дня следующий {DD/MM/YYYY}:
//   1. День недели: {[1..7]/00/0000}
//   2. Календарный день: {DD/MM/0000}
//   3. Дата: {DD/MM/YYYY}
//
class PPHolidays {
public:
	//
	// Возвращает вид выходного дня:
	// 1 - Дата
	// 2 - Календарный день
	// 3 - День недели
	//
	static int    FASTCALL GetKind(LDATE);
	static SString & Format(LDATE, SString & rBuf);
	//
	// Descr: должна добавить в контейнер новое значение выходного дня или,
	//   если параметр rmv != 0, то удалить указанное значение.
	//   В случае, если rmv != 0 и указанное значение для заданного склада уже существует,
	//   функция должна вернуть -1.
	//   Если rmv == 0 и указанное значение для заданного склада не существует,
	//   функция также должна вернуть -1.
	//   Если добавление или удаление элемента прошло успешно, функция возвращает 1.
	//   В случае ошибки, следует вернуть 0 и инициализировать переменную PPErrCode.
	//
	virtual int SetHoliday(PPID locID, LDATE, int rmv) = 0;
	//
	// Descr: должна вернуть !0 если указанная дата для списка складов pLocList
	//   является выходным днем. В противном случае функция должна вернуть 0.
	//
	virtual int IsHoliday(const ObjIdListFilt * pLocList, LDATE) = 0;
	virtual int EnumHolidays(PPID locID, LDATE *) = 0;
};
//
// Виды связей от зависимого документа к связывающему
//
#define BLNK_ALL        0xffff // Все связанные документы
#define BLNK_SHADOW     0x0001 // Теневые документы
#define BLNK_PAYMENT    0x0002 // Оплаты
#define BLNK_RETURN     0x0004 // Возвраты
#define BLNK_CHARGE     0x0008 // Начисления //
#define BLNK_ACK        0x0010 // Acknowledge
#define BLNK_CHARGEPAYM 0x0020 // Начисление с признаком отрицательной оплаты (OPKF_CHARGENEGPAYM)
#define BLNK_WROFFDRAFT 0x0040 // Документы списания драфт-документа
#define BLNK_PAYMRETN   (BLNK_PAYMENT|BLNK_RETURN)
#define BLNK_EDIRECADV  0x0080 // Документы подтверждения получения товара от контрагента, полученные по канала EDI
#define BLNK_CORRECTION 0x0100 // Корректирующие документы
//
// Descr: Функция подстановки в метод BillCore::PayPlanEnumerator()
//
typedef int (*PayPlanEnumProc)(PayPlanTbl::Rec *, void *);
//
// Descr: реализует общие механизмы работы с документами
//
class BillCore : public BillTbl {
public:
	friend class PPTblEnum <BillCore>;

	// @v11.1.12 static char * FASTCALL SetCode(char * code, long f);
	// @v11.1.12 static char * FASTCALL GetCode(char * code);
	// @v11.1.12 static SString & FASTCALL GetCode(SString & rCode);
	static double GetQttyEpsilon();
	//
	// Descr: Возвращает значение статуса ответа (RECADV) на уведомление об отгрузке (DESADV)
	// Returns:
	//    PPEDI_RECADV_STATUS_UNDEF || PPEDI_RECADV_STATUS_ACCEPT || PPEDI_RECADV_STATUS_PARTACCEPT || PPEDI_RECADV_STATUS_REJECT
	//
	static int FASTCALL GetRecadvStatus(const BillTbl::Rec & rRec);
	static int FASTCALL SetRecadvStatus(int recadvStatus, BillTbl::Rec & rRec);
	static int FASTCALL GetRecadvConfStatus(const BillTbl::Rec & rRec);
	static int SetRecadvConfStatus(int recadvConfStatus, BillTbl::Rec & rRec);

	BillCore();
	int    Search(PPID id, BillTbl::Rec * pRec = 0);
	int    PutItemMemo(PPID id, SString * pBuf, int use_ta); // @v11.1.12
	SString & GetItemMemo(PPID id, SString & rBuf); // @v11.1.12
	int    GetAmountList(PPID billID, AmtList * pList);
	int    GetAmount(PPID billID, PPID amtTypeID, PPID curID, double *);
	//
	// Descr: Проверяет наличие ссылки на тип суммы amtTypeID в таблице Amounts
	//   (BillAmountTbl).
	// ARG(amtTypeID IN): ИД типа суммы, ссылки на который следует проверить.
	// ARG(pBillID  OUT): @#{vptr0} указатель, по которому функция присвоит ИД документа,
	//   ссылка на который обнаружена в таблице
	// Returns:
	//   >0 - ссылка существует
	//   <0 - ссылок не существует
	//   0  - ошибка
	//
	int    CheckAmtTypeRef(PPID amtTypeID, PPID * pBillID);
	int    UpdateAmount(PPID, const AmtEntry *, int removeZero);
	int    GetPayPlan(PPID billID, PayPlanArray * pList);
	int    PutPayPlan(PPID billID, const PayPlanArray *, int use_ta);
	int    PayPlanEnumerator(const DateRange *, PayPlanEnumProc, void * extraPtr);
	int    GetLastPayDate(PPID, LDATE *);
	//
	// Descr: Находит последний в хронологическом порядке документ оплаты по документу billID,
	//   сумма которого (оплата) больше нуля.
	// Returns:
	//   >0 - искомый документ оплаты найден
	//   <0 - не найдено ни одного документа оплаты, привязанного к billID и такого, чтобы
	//        сумма была больше нуля и тип операции был PPOPT_PAYMENT.
	//   0  - ошибка
	//
	int    GetLastPayment(PPID billID, BillTbl::Rec * pRec);
	int    GetExtraData(PPID id, PPBillExt *);
	int    PutExtraData(PPID id, const PPBillExt * pExt, int use_ta);
	int    Extract(PPID id, PPBill * pPack);
	int    EditRec(PPID * pID, BillTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет поле Flags записи документа так, что если set != 0
	//   то флаг flag устанавливается, в противном случае - снимается.
	// Note: функция рассчитана на то, что в аргументе flag установлен только один бит.
	// Returns:
	//   >0 - запись изменена
	//   <0 - флаг в записи уже имеет заданное значение - ничего не изменялось.
	//   0  - ошибка.
	//
	int    SetRecFlag(PPID billID, long flag, int set, int use_ta);
	//
	// Descr: Функция аналогична SetRecFlag, но модифицирует поле BillTbl::Flags2
	//
	int    SetRecFlag2(PPID billID, long flag2, int set, int use_ta);
	int    Edit(PPID * pID, PPBill * pPack, int use_ta);
	//
	// Descr: Изменяет сумму текущей оплаты по документу (PPAMT_PAYMENT) и, если
	//   документ после этого стал полностью оплаченным, выставляет
	//   флаг BILLF_PAYOUT в поле BillTbl::Rec.Flags.
	//   Новая сумма текущей оплаты становится равной payment + newAmt - orgAmt,
	//   где
	//     payment - сумма текущей оплаты до вызова функции (используется вызов
	//               GetAmount(billID, PPAMT_PAYMENT, curID, &payment)
	//     newAmt  - новое значение суммы частичной оплаты
	//     orgAmt  - предыдущее значение суммы частичной оплаты
	//     Если функция вызывается по факту добавления новой частичной оплаты, то
	//     orgAmt = 0.
	// @attention: Функция работает без транзакции
	//
	int    UpdatePaymAmount(PPID billID, PPID curID, double newAmt, double orgAmt);
	int    Remove(PPID, int use_ta);
	//
	// Descr: разрывает связь от документа linkBillID к документу baseBillID.
	// ARG(linkKind IN): 1 - link, 2 - pool
	//
	int    BreakOffLink(PPID linkBillID, PPID baseBillID, int linkKind, int use_ta);
	int    EnumLinks(PPID billID, DateIter *, uint blnk /* BLNK_XXX flags */, BillTbl::Rec * = 0);
	int    EnumByObj(PPID arID, DateIter *, void * = 0);
	int    EnumByOpr(PPID opID, DateIter *, void * = 0);
	int    EnumByDate(DateIter *, BillTbl::Rec * pRec = 0);
	SEnum::Imp * EnumByOp(PPID opID, const DateRange * pPeriod, int options);
	//
	// Descr: Находит список документов заказа, по которым отгружен документ billID.
	// Returns:
	//   >0 - существует по крайней мере один документ заказа, к которому привязана отгрузка billID
	//   <0 - не существует ни одного документа заказа, к которому был бы привязан документ billID
	//    0 - error
	//
	int    GetListOfOrdersByLading(PPID billID, PPIDArray & rOrderBillList);
	int    GetListOfActualAgreemts(PPID arID, LDATE dt, int maxDays, int maxItems, PPIDArray & rList);
	int    GetTrnovrBySCard(PPID cardID, const DateRange * pPeriod, PPID restrGoodsGrpID, double * pDbt, double * pCrd);
	int    CreateSCardsTurnoverList(const DateRange *, RAssocArray *);
	int    CalcPayment(PPID billID, int byLinks, const DateRange *, PPID curID, double * pPaymentAmount);
	int    CalcPaymentSieve(PPID id, PPID curID, const PPCycleArray * pSieve, RAssocArray * pList, double * pPaym);
	int    GetCreditList(PPID id, PctChargeArray * pList);
	//
	// Descr: Ищет документ, имеющий код pCode. Если задан ненулевой аргумент opID, то ищет только документы с кодом pCode
	//   и имеющие указанный вид операции. Если задан ненулевой аргумент dt, то дополнительно ограничивает поиск
	//   соответствующей датой.
	//   Если аргумент pCode пустой (pCode == 0 || pCode[0] == 0), то функция сразу возвращает -1.
	// Returns:
	//   >0 - найден документ, соответствующий критериям.
	//   <0 - не найден документ, удовлетворяющий заданным критериям.
	//    0 - ошибка
	//
	int    SearchByCode(const char * pCode, PPID opID, LDATE dt, BillTbl::Rec * pRec);
	enum {
		safDefault    = 0x0000,
		safIgnoreOp   = 0x0001,
		safCheckEdiOp = 0x0002,
		safIgnoreDate = 0x0004  // @v11.4.2 Не принимать во внимание дату документа (только номер и, возможно, вид операции)
	};
	int    SearchAnalog(const BillTbl::Rec * pSample, long flags, PPID * pID, BillTbl::Rec * pRec);
	int    GetRentCondition(PPID, PPRentCondition *);
	int    SetFreight(PPID id, const PPFreight * pFreight, int use_ta);
	int    GetFreight(PPID, PPFreight * pFreight);
	int    GetDlvrAddrList(LAssocArray * pList);
	int    GetListByFreightFilt(const FreightFilt & rFilt, UintHashTable & rList);
	//
	// Descr: Возвращает дату первого документа в базе данных.
	//   Если opID != 0, то ищет первый документ, относящийся //
	//   к указанному виду операции.
	//
	int    GetFirstDate(PPID opID, LDATE *);
	//
	// Descr: Возвращает дату последнего документа в базе данных.
	//   Если opID != 0, то ищет последний документ, относящийся //
	//   к указанному виду операции.
	//
	int    GetLastDate(PPID opID, LDATE *);
	//
	// mode > 0   то установить метку;
	// mode == 0  снять метку
	// mode < 0   переключить метку
	//
	int    SetWLabel(PPID billID, int mode, int use_ta);
	int    HasWLabel(PPID);
	//
	// mode > 0   - установить флаг BILLF_SHIPPED
	// mode == 0  - снять флаг BILLF_SHIPPED
	// mode < 0   - переключить флаг BILLF_SHIPPED
	//
	int    SetShippedTag(PPID billID, int mode);
	int    _GetBillNo(LDATE, long * billno);
	int    EnumMembersOfPool(PPID poolType, PPID poolOwnerID, PPID * pMemberID, ObjAssocTbl::Rec * = 0);
	int    GetPoolMembersList(PPID poolType, PPID poolOwnerID, PPIDArray * pList);
	//
	// Descr: Извлекает список идентификаторов владельцев пулов типа poolType, которым
	//   принадлежит документ billID.
	// ARG(billID   IN): идентификатор докумумента-члена пула
	// ARG(poolType IN): тип пулов документов, принадлежность которым документа billID выясняется //
	// ARG(pList   OUT): @#{vptr0} Указатель на массив, в который вносятся идентификаторы владельцев
	//   пулов, которым принадлежит billID.
	// Returns:
	//   >0 - документ billID принадлежит по крайней одному пулу типа poolType
	//   <0 - документ billID не принадлежит ни одному пулу типа poolType
	//
	int    GetPoolOwnerList(PPID billID, PPID poolType, PPIDArray * pList);
	int    GetPoolList(PPID poolType, LAssocArray * pAry);
	int    IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID);
	int    UpdatePool(PPID billID, PPID poolType, PPID poolOwnerID, int use_ta);
	int    RemoveFromPool(PPID billID, PPID poolType, PPID poolOwnerID, int use_ta);
	int    CalcPoolAmounts(PPID poolType, PPID poolOwnerID, AmtList *);
	//
	// Descr: Возвращает список идентификаторов документов, чьи расширения соответствую критериям фильтрации
	//   по агенту (agentID) и плательщику (payerID). Если значение какого-либо из критериев нулевое,
	//   то этот критерий игнорируется.
	// Note: Функция предварительно очищает список rList а после заполнения сортирует его и удаляет дубликаты.
	// Returns:
	//   >0 - в список добавлен по крайней мере один идентификатор
	//   <0 - не найдено ни одного документа, удовлетворяющего критериям
	//   0  - ошибка
	//
	int    GetBillListByExt(PPID agentID, PPID payerID, PPIDArray & rList);
	int    GetAdvanceBillList(PPID objID, PPID exclBillID, const DateRange * pPeriod, double * pAdvRest, PPIDArray *);
	//
	// Descr: Находит список локаций ассоциированных с документами, относящимися к виду операции opID.
	// ARG(opID IN): Идентификатор вида операции. Обобщенные операции не разворачиваются.
	//   Нулевое значение не обрабатывается - результат будет пустым.
	// ARG(rList OUT): Массив, в который заносятся идентификаторы всех найденных локаций. Функция
	//   предварительно очищает список вызовом LongArray::clear()
	// Note: При значительном количестве документов функция может выполняться длительное время.
	//
	int    GetLocListByOp(PPID opID, PPIDArray & rList);
	//
	// Descr: пытается обнаружить дни, в течении которых не проведено
	//   ни одного документа операции opID по складу locID. Обнаруживая такие дни,
	//   функция заносит их в контейнер PPHolidays, используя виртуальный метод
	//   PPHolidays::SetHoliday().
	//   Перебирая дни, фукция сверяется с виртуальным методом PPHolidays::IsHoliday.
	//   Если этот метод возвращает положительное значение, то не рассматривает такой
	//   день. Период, который перебирается функцией, определяется параметром pPeriod.
	//   Если нижняя граница периода не определена, то используется дата, выясняемая //
	//   вызовом метода BillCore::GetFirstDate. Если верхняя граница периода не
	//   определена, то используется дата, выясняемая вызовом метода BillCore::GetLastDate.
	//
	//   Если locID == 0, то функция вызывает себя рекурсивно для каждого склада, полученного //
	//   вызовом функции PPObjLocation::GetWarehouseList().
	//
	int    ScanHolidays(PPID locID, PPID opID, const DateRange * pPeriod, PPHolidays * pHld);

	struct Extra_Strg {      // sizeof(Extra_Strg) == PROPRECFIXSIZE
		Extra_Strg()
		{
			THISZERO();
		}
		PPID   ObjType;            // const=PPOBJ_BILL
		PPID   ObjID;              // -> Bill.ID
		PPID   PropID;             // const=BILLPRP_EXTRA
		PPID   ExtPriceQuotKindID; //
		char   InvoiceCode[24];    //
		LDATE  InvoiceDate;        //
		char   PaymBillCode[24];   // Номер платежного документа (для печати в счете-фактуре)
		LDATE  PaymBillDate;       // Дата  платежного документа (для печати в счете-фактуре)
		uint8  CvtTag;             // 1 - признак конвертации v6.4.6
		char   Reserve[3];         // @reserve
		PPID   AgentID;            // Агент      ->Article.ID
		PPID   PayerID;            // Плательщик ->Article.ID
		PPID   CcID;               // Ид чека, сформированного по этому документу для печати
		PPID   TradePlanLocID;     // @v12.1.12 Склад, возможно группирующий, по которому строится и анализируется торговый план.
	};
private:
	//
	// Descr: предназначена для перечисления записей по индексам вида { id, date, billno }.
	//
	int    _Enum(int key, PPID, DateIter *, void * b);
	void   _PrepareWriting(const BillTbl::Rec * pRec);
	int    PutBillProp(PPID billID, PPID propID, long isThere, void *, size_t);
	//
	// Функция IsThereBill выясняет существует ли по складу locID за день dt
	// хотя бы один документ относящийся к одной из операций в списке pOpList.
	// Если pOpList == 0 или pOpList->getCount() == 0, тогда функция пытаетс
	// обнаружить документ по любой операции.
	// Returns:
	// 	> 0 - найден по крайней мере один документ, удовлетворяющий условию
	//  < 0 - не найдено ни одного документа
	//    0 - error
	//
	int    IsThereBill(PPID locID, const PPIDArray * pOpList, LDATE dt);
	int    Helper_CalcPayment(PPID id, PPID curID, const PPCycleArray * pSieve, RAssocArray * pList, double * pPaym);
	int    InitEnumByOp(PPID opID, const DateRange * pPeriod, int flags, long * pHandle);
	int    NextEnum(long enumHandle, BillTbl::Rec * pRec);
	int    DestroyIter(long enumHandle);

	BillAmountTbl AmtT;
	PayPlanTbl    Pays;
	PPTblEnumList EnumList;
};
//
// История документов
//
#define HISTBILL_MAXVER 100000L

class PPHistBillPacket {
public:
	PPHistBillPacket();
	~PPHistBillPacket();
	void   destroy();
	PPHistBillPacket & FASTCALL operator = (const PPHistBillPacket & aPack);
	int    Init(const PPBillPacket * pPack);
	int    ConvertToBillPack(PPBillPacket * pPack);
	uint   GetCount() const;
	HistTrfrTbl::Rec & FASTCALL Item(uint);
	int    EnumItems(uint *, HistTrfrTbl::Rec **) const;
	int    InsertRow(HistTrfrTbl::Rec *);
	int    RemoveRow(uint);
	int    RemoveRows(LongArray * pPositions);

	HistBillTbl::Rec Head;
private:
	TSVector <HistTrfrTbl::Rec> Items;
};

class HistBillCore : public HistBillTbl {
public:
	HistBillCore();
	int    Search(PPID id, HistBillTbl::Rec * pRec);
	int    SearchOpenBill(PPID billID, HistBillTbl::Rec * pRec);
	int    PutPacket(PPID * pID, PPHistBillPacket * pPack, int close, int use_ta);
	int    GetPacket(PPID id, PPHistBillPacket * pPack);
	static int HBRecToBRec(const HistBillTbl::Rec * pHBRec, BillTbl::Rec * pBRec);
	int    DoMaintain(LDATE toDt, int recover, PPLogger * pLogger);
		// @>>DoDBMaintain
	int    Remove(PPID id, int useTa);
private:
	int    GetIdx(PPID billID, PPID * pVer, PPID * pInnerID);
	int    LoadItems(PPID histBillID, PPHistBillPacket *);

	HistTrfrTbl ItemsTbl;
};
//
// Значения, передаваемые в качестве опций, а также возвращаемые функцией
// ReceiptCore::GetCurrentGoodsPrice
//
#define GPRET_NOLOTS      -0x0100 // В системе нет ни одного лота с заданным товаром
#define GPRET_ERROR             0 // Ошибка
#define GPRET_OTHERLOC     0x0004 // На заданном складе лотов нет, но есть на других складах
#define GPRET_CLOSEDLOTS   0x0002 // На заданном складе есть только закрытые лоты
#define GPRET_PRESENT      0x0001 // На заданном складе имеется ненулевой остаток товара
#define GPRET_MOSTRECENT   0x0100 // Возвращать самый последний лот до текущей
	// операционной даты (включительно) независимо от того, есть на нем остаток или нет
#define GPRET_FORCELOTID   0x0200 // По указателю pRec в функцию передана структура в поле
	// ID которой установлен идентификатор лота, который следует использовать в первую очередь.
	// Функция ReceiptCore::GetCurrentGoodsPrice проверяет этот лот на принадлежность товару
	// и складу, переданными соответствующими аргументами фукнции и, если они удовлетворительны
	// то применяет именно этот лот.
#define GPRET_INDEF        (GPRET_MOSTRECENT|GPRET_PRESENT|GPRET_CLOSEDLOTS) // Наиболее популярное сочетание флагов, используемое для нахождения последнего лота
//
// Флаги ReceiptTbl::Rec::Flags
//
#define LOTF_COSTWOVAT     0x0001L // Цена поступления задана без НДС
#define LOTF_COSTWSTAX     0x0002L // Цена поступления задана с налогом с продаж
#define LOTF_PCKG          0x0004L // Лот пакета
#define LOTF_PRICEWOTAXES  0x0008L // Цена реализации без всех налогов
#define LOTF_CLOSEDORDER   0x0010L // Закрытый ордер // if Receipt.Closed == 0 and Receipt.Flags & LOTF_CLOSEDORDER then Receipt.Rest > 0 is valid
#define LOTF_ORDRESERVE    0x0020L // Резервирующий заказ
#define LOTF_COMPLETE      0x0040L // Скоплектованный лот
#define LOTF_CLOSED        0x0080L // @transient Закрытый лот (применяется в кэше для замены признака ReceiptTbl::Rec::Closed)
#define LOTF_SURROGATE     0x0100L // Суррогатный лот, созданный без привязки к документу для отображения
	// текущих остатков и прочих атрибутов товаров. В частности, для автономного кассового узла.
//
// Специальные флаги временной таблицы TempLotTbl::SFlags
//
#define LOTSF_FIRST        0x0001 // Лот является первым по этому товару на этом складе
#define LOTSF_COSTUP       0x0002 // Цена поступления лота выше, чем у предыдущего
#define LOTSF_COSTDOWN     0x0004 // Цена поступления лота ниже, чем у предыдущего
#define LOTSF_PRICEUP      0x0008 // Цена реализации лота выше, чем у предыдущего
#define LOTSF_PRICEDOWN    0x0010 // Цена реализации лота ниже, чем у предыдущего
#define LOTSF_LINKCOSTUP   0x0020 // Цена поступления выше, чем цена в документе заказа, на основании которого вводится данный док
#define LOTSF_LINKCOSTDN   0x0040 // Цена поступления ниже, чем цена в документе заказа, на основании которого вводится данный док
#define LOTSF_RESTRBOUNDS  0x0080 // Цена выходит за границы диапазона, определяемого ограничениями товарных величин

typedef TSVector <ReceiptTbl::Rec> LotArray;
//
// Декларация функций сортировки записей лотов (receipt.cpp)
//
DECL_CMPFUNC(Receipt_DtOprNo_Asc); // Дата/Номер_операции по возрастанию
DECL_CMPFUNC(Receipt_DtOprNo_Desc); // Дата/Номер_операции по убыванию
DECL_CMPFUNC(Receipt_DtOprNo_FEFO_Asc); // По возрастанию срока годности, либо (если сроки равны), Дата/Номер_операции по возрастанию
DECL_CMPFUNC(Receipt_DtOprNo_FEFO_Desc); // По возрастанию срока годности, либо (если сроки равны), Дата/Номер_операции по убыванию

class ReceiptCore : public ReceiptTbl {
public:
	struct LotDimensions {
		static int EditTag(const PPGdsClsPacket * pGcPack, ObjTagItem * pItem);
		LotDimensions();
		void   Clear();
		SString & FASTCALL ToStr(SString & rBuf) const;
		int    FASTCALL FromString(const char * pBuf);

		double X;
		double Y;
		double Z;
		uint8  Reserve[64];
	};

	static SString & FASTCALL MakeCodeString(const ReceiptTbl::Rec * pRec, int options, SString & rBuf);
	ReceiptCore();
	int    Search(PPID id, ReceiptTbl::Rec * pRec = 0);
	//
	// Descr: ищет по связанным лотам, начиная с *pLot цикл,
	//   замкнутый на локацию locID.
	// Returns:
	//   > 0 - найдено (*pLot равен ид-ру замыкающего лота)
	//   < 0 - не найдено (*pLot = 0)
	//   0   - ошибка (*pLot не определен).
	//
	int    SearchLoop(PPID * pLotID, PPID locID);
	//
	// Descr: ищет самый первый лот по цепочке lotID - PrevLot.
	//   По указателю pOrgRec возвращается запись найденного оригинального лота.
	//   По указателю pThisRec возвращается запись лота и ИД lotID.
	//   Оба указателя могут быть нулевыми.
	// Returns:
	//   > 0 - идентифицирован первый лот в цепочке. По указателю pOrgLotID
	//       присваивается ИД найденного лота (возможно *pOrgLotID == lotID),
	//       по указателю pRec присваивается запись, соответствующая этому лоту.
	//   0 - error. Это либо цепочка разорвана (нет записи, соответствующей одному
	//       из идентификаторов в цепи), либо цепочка лотов зациклена
	//       (PPErrCode = PPERR_LOTLOOP), либо ошибка выборки записи
	//       (PPErrCode = PPERR_DBENGINE).
	//
	int    SearchOrigin(PPID lotID, PPID * pOrgLotID, ReceiptTbl::Rec * pThisRec, ReceiptTbl::Rec * pOrgRec);
		// @<<ReceiptCore::GetOriginDate
		// @<<Transfer::EnumItems,Transfer::LoadItems,Transfer::EnumAssetOp,Transfer::IsCompletedLot
		// @<<PPObjBill::MakeAssetCard,PPObjBill::GetComplete
		// @<<PPViewGoodsOpAnalyze::PutBillToTempTable
		// @<<PPViewTrfrAnlz::Add
	//
	// Descr: по записи pLotRec извлекает лот, по которому изначально в
	//   систему поступил товар, и возвращает дату и ИД документа оригинального лота.
	//   Для определения оригинального лота используется функция ReceiptCore::SearchOrigin.
	//   Если поле pLotRec->PrevLotID == 0, то возвращает информацию из этой записи.
	//
	int    GetOriginDate(const ReceiptTbl::Rec * pLotRec, LDATE * pDate, PPID * pBillID = 0);
	//
	// Descr: Флаги функции Receipt::GetList
	//
	enum {
		glfOpenedOnly      = 0x0001, // Возвращать только открытые лоты
		glfNzRestOnly      = 0x0002, // Возвращать только лоты с ненулевым остатком
		glfWithExtCodeOnly = 0x0004  // Возвращать только лоты, с которыми ассоциированы коды маркировки (неважно, егаис или чезн)
	};
	//
	// ARG(pRecList OUT): указатель на вектор, в который будет заносится записи найденных лотов. Функция предварительно не очищает вектор.
	//
	int    GetList(PPID goodsID, PPID locID, PPID supplID, LDATE beforeDt, /*int openedOnly, int nzRestOnly*/uint flags, LotArray * pRecList);
	int    EnumLots(PPID goodsID, PPID locID, DateIter *, void * = 0);
	int    EnumLastLots(PPID goodsID, PPID locID, LDATE *, long * oprno, ReceiptTbl::Rec * pRec = 0);
	int    GetLastLot(PPID goodsID, PPID locID, LDATE date, ReceiptTbl::Rec * pLotRec);
		// @>>ReceiptCore::EnumLastLots(goodsID, locID, &date, &(o = MAXDATE), pLotRec)
	int    GetLastOpenedLot(PPID goodsID, PPID locID, LDATE, void * = 0);
		// @<<ReceiptCore::GetCurrentGoodsPrice
	int    GetFirstLot(PPID goodsID, PPID locID, ReceiptTbl::Rec * pLotRec);
	//
	// Descr: Возвращает лот, предшествующий паре {dt, oprNo} и относящийся к товару goodsID
	//   и складу locID. Если locID <= 0, то принадлежность к складу не учитывается.
	//
	int    GetPreviousLot(PPID goodsID, PPID locID, LDATE dt, long oprNo, ReceiptTbl::Rec * pRec);
	int    EnumByGoods(PPID goodsID, DateIter *, ReceiptTbl::Rec *);
	//
	// Descr: возвращает зарезервированное количество товара goodsID.
	//   Если locID != 0, тогда возвращается резерв на складе с таким идентификатором,
	//   иначе, по всем складам.
	//   Величина резерва определяется как сумма текущих остатков по лотам заказов
	//   (GoodsID < 0), имеющим признак (Flags & LOTF_ORDRESERVE).
	//   Признак резервирующего заказа устанавливается на лот при его создании,
	//   если документ, создавший его относится к виду операции, имеющей признак OPKF_ORDRESERVE.
	// Returns:
	//   > 0 - OK
	//   < 0 - нет резервирующих заказов на товар (*pValue = 0)
	//   0   - Error (*pValue unpredictable)
	//
	int    GetReserve(PPID goodsID, PPID locID, double * pValue);
	int    Add(PPID * pID, ReceiptTbl::Rec * pRec, int use_ta);
	int    Update(PPID id, ReceiptTbl::Rec * pRec, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    EnumRefs(PPID prev, LDATE *, long * oprno, void * = 0);
	int    GetListOfOpenedLots(int dir, PPID goodsID, PPID locID, LDATE beforeDt, LotArray * pList);
	//
	// ARG(rGoodsList IN): список идентификаторов товаров, для которых необходимо найти открытые лоты.
	//   !Список обязательно должен быть отсортирован.
	//
	int    GetListOfOpenedLots(const PPIDArray & rGoodsList, PPID locID, LotArray * pList);
	//
	// Descr: Извлекает список идентификаторов лотов, срок годности которых истекает с expiredSice (включительно).
	//   Может так же вернуть список идентификаторов товаров, соответствующих таким лотам.
	// ARG(expiredSince IN): Дата, начиная с которой истекает срок годности искомых лотов. Если значение даты ZERODATE 
	//   либо инвалидно, то функция не пытается делать чего-то полезного, просто вернет -1 (ну и очистит предварительно pLotIdList и pGoodsIdList)
	// ARG(openedOnly   IN): Если true, то функция ищет только открытые лоты.
	// ARG(enumSince    IN): Так как таблица Receipt не проиндексирована по полю Expiry то для улучшения производительности
	//   этим аргументом можно указать дату, с которой функция должна начать сканирование записей.
	//   Если enumSince == ZERODATE или инвалидная, то сканируется вся таблица.
	// ARG(pLotIdList   OUT): @vptr0 Указатель на вектор, в которых складываются идентификаторы найденных лотов.
	//   Список предварительно очищается функцией.
	// ARG(pGoodsIdList OUT): @vptr0 Указатель на вектор, в который складываются идентификаторы товаров, которым соответствуют найденные лоты.
	//   Список предварительно очищается функцией.
	// Returns:
	//   >0 - найден по крайней мере интересующий лот.
	//   <0 - не найдено ни одного интересующего лота.
	//    0 - error
	//
	int    GetListOfLotsExpiredSince(LDATE expiredSince, bool openedOnly, LDATE enumSince, PPIDArray * pLotIdList, PPIDArray * pGoodsIdList);
	//
	// Descr: Находит лот товара goodsID по складу locID с наименьшим сроком годности.
	//
	int    GetMostCriticalExpiryDate(PPID goodsID, PPID locID, PPID * pLotID, LDATE * pExpiryDate);
	//
	// Descr: собирает все лоты, порожденные от parent и удовлетворяющие функции test
	//   в массив ary. Если test == 0, то полагается (test() != 0)
	//   Лот parent в массив не попадет ни при каких условиях.
	//   Массив ary не упорядочивается по каким-либо критериям.
	//   Случай ary == 0 обрабатывается нормально (функция отрабатывает
	//   все лоты, удовлетворяющие test, но их идентификаторы не сохраняет).
	//   Параметр extra передается функции test.
	//
	int    GatherChildren(PPID parent, PPIDArray * ary, int (*test)(const ReceiptTbl::Rec *, void *), void * extraPtr);
	//
	// Descr: возвращает текущую цену товара goodsID
	//   по складу locID. Если остаток товара по складу больше нуля, то
	//   возвращается GPRET_PRESENT, если нулевой остаток, но есть закрытые лоты,
	//   то возвращается GPRET_CLOSEDLOTS и устанавливается цена последнего лота.
	//   Если на складе нет ни одного лота по заданному товару, то возвращается //
	//   GPRET_OTHERLOC и цена последнего лота по любому из складов.
	//   Если в базе данных вообще нет лотов такого товара, то возвращается     //
	//   GPRET_NOLOTS и цена 0.
	//   В случае ошибки возвращается GPRET_ERROR (0).
	//
	//   Параметр flags позволяет указать, какие возвращаемые значения являются //
	//   допустимыми. Это может быть комбинация флагов GPRET_PRESENT,
	//   GPRET_OTHERLOC, GPRET_CLOSEDLOTS. Указав комбинацию первого и (или)
	//   второго флага, можно добиться некоторого ускорения работы функции.
	//
	//   Если в параметре flags установлен флаг GPRET_MOSTRECENT, то в первую очередь
	//   функция ищет самый последний лот по заданному складу независимо от, того, есть
	//   на нем остаток или нет.
	//
	//   Некоторые подробности использования флагов см выше в декларации самих флагов GPRET_XXX
	//
	int    GetCurrentGoodsPrice(PPID goodsID, PPID locID, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	//
	// Descr: То же, что и GetCurrentGoodsPrice только ищет лоты, которые пришли не позднее чем date.
	//
	int    GetGoodsPrice(PPID goodsID, PPID locID, LDATE date, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	//
	// Descr: Находит наиболее новый сертификат качества для товара goodsID до даты beforeDate (включительно).
	//   Если аргумент locID не нулевой, то в первую очередь ограничивает поиск сертификата только теми лотами, которые относятся к
	//   складу с заданным идентификатором, если же по заданному складу нет лота с сертификатом, то в таком случае
	//   ищет требуемый лот по любому из складов.
	// Returns:
	//   >0 - найден лот с не пустым сертификатом
	//   <0 - не найдено ни одного лота по заданным критериям и с не пустым сертификатом
	//    0 - error
	//
	int    GetLastQCert(PPID goodsID, LDATE beforeDate, PPID locID, PPID * pQCertID, PPID * pLotID);
	int    IsThereOpenedLotForQCert(PPID qcertID);
	//
	// Descr:
	//   Возвращает список поставщиков данного товара. В списке не встречаются повторящиеся ID поставщиков.
	//   Извлекается список лотов до даты lastDate за период не более 90 дней до последнего прихода или не
	//   менее 3 лотов.
	//
	int    GetSupplList(PPID goodsID, const PPIDArray * pLocList, LDATE lastDate, PPIDArray * pSupplList);
protected:
	int    _SearchLot(int closed, PPID goods, PPID loc, LDATE, long oprno, int spMode);
private:
	int    Helper_GetLastLot(PPID goodsID, PPID locID, LDATE dt, ReceiptTbl::Rec * pRec);
	int    Helper_GetCurrentGoodsPrice(PPID goodsID, PPID locID, LDATE date, uint flags, double * pPrice, ReceiptTbl::Rec * pRec);
	int    Helper_GetList(PPID goodsID, PPID locID, PPID supplID, LDATE beforeDt, /*int closedTag, int nzRestOnly,*/uint flags, LotArray * pRecList);
	int    Helper_SearchOrigin(const ReceiptTbl::Rec * pInitLotRec, PPID lotID, PPID * pOrgLotID, ReceiptTbl::Rec * pThisRec, ReceiptTbl::Rec * pOrgRec);

	int    IgnoreGpretMostRecentFlags; // В функции GetCurrentGoodsPrice игнорировать флаг
		// GPRET_MOSTRECENT. Проекция флага (PPGoodsConfig::Flags | GCF_RETAILPRICEBYMOSTRECENTLOT)
		// Изначально инициализируется в -1 (что означает неопределенность и необходимость извлечь конфигурацию товаров).
};

int FASTCALL GetCurGoodsPrice(PPID goodsID, PPID locID, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	// @<<BillObj->trfr->Rcpt.GetCurrentGoodsPrice

class LotExtCodeCore : public LotExtCodeTbl {
public:
	LotExtCodeCore();
	int    RemoveAllByBill(PPID billID, int use_ta);
	int    PutContainer(PPID billID, const PPLotExtCodeContainer * pC, int use_ta);
	int    GetContainer(PPID billID, PPLotExtCodeContainer & rC);
	int    GetMarkListByLot(PPID lotID, const StringSet * pExcludeList, StringSet & rSsExtCodes, uint * pExtCodeCount);
	int    GetRecListByMark(const char * pCode, TSVector<LotExtCodeTbl::Rec> & rList);
	int    GetListByBillRow(PPID billID, int rbb, bool firstOnly, StringSet & rSs, uint * pCount);
	int    FindMarkToTransfer(const char * pCode, PPID goodsID, PPID lotID, PPLotExtCodeContainer::MarkSet & rResult);
};
//
//
//
struct GoodsRestVal {
	explicit GoodsRestVal(const ReceiptTbl::Rec * = 0, double = 0.0);
	void   Init(const ReceiptTbl::Rec * = 0, double = 0.0);

	enum {
		fCostByQuot  = 0x0001,
		fPriceByQuot = 0x0002
	};
	int    Count;
	double UnitsPerPack;
	double Rest;
	double Cost;
	double Price;
	PPID   LocID;
	PPID   LotID;
	LDATE  Expiry;
	double Deficit;
	double DraftRcpt;
	uint   Flags; // @v11.7.11
	char   Serial[24];
	char   LotTagText[128];
};

class GoodsRestParam : public TSVector <GoodsRestVal> {
public:
	GoodsRestParam();
	GoodsRestParam(const GoodsRestParam & rS);
	GoodsRestParam & FASTCALL operator = (const GoodsRestParam &);
	void   FASTCALL Copy(const GoodsRestParam & rS);
	void   Init();
	void   InitVal();
	void   Set(const GoodsRestFilt & rF, RetailPriceExtractor * pRpe);
	PPID   DiffByTag() const;
	bool   CanMerge(const GoodsRestVal *, const GoodsRestVal *) const;
	int    AddToItem(int p, LDATE dt, long opn, GoodsRestVal *);
	int    AddLot(Transfer *, const ReceiptTbl::Rec *, double rest, LDATE orgLotDate);
	void   DivRestPrices();
	int    CheckBill(const ReceiptTbl::Rec *, LDATE * pOrgDate) const;
	double FASTCALL GetRestByLoc(PPID locID) const;
	enum { // calcMethod (Метод расчета цен)
		pcmAvg        = 0, // По среднему
		pcmFirstLot   = 1, // По первому лоту
		pcmLastLot    = 2, // По последнему лоту
		pcmSum        = 3, // Суммарное значение
		pcmDiff       = 4, // Возвращать все лоты с ненулевым остатком
		pcmMostRecent = 5, // По самому последнему лоту (не смотря на остаток)
	};
	enum { // flags (Опции)
		fLabelOnly    = 0x00000040, // Только лоты, созданные помеченными документами
		fPriceByQuot  = 0x00000080, // Цены по котировке
		fCostByQuot   = 0x00000100, // Цены поступления по котировке
		fRetailPrice  = 0x00000200, // Цены реализации рассчины по правилам, применяемым для определения розничных цен
		fCWoVat		  = 0x00004000, // Цены поступления без НДС
		fPWoVat		  = 0x00008000, // Цены реализации без НДС
		fZeroAgent    = 0x00010000, // Только с нулевым агентом поставщика
	};
	enum {
		_diffNone     = 0,
		_diffCost     = 0x0001,
		_diffPrice    = 0x0002,
		_diffPack     = 0x0004,
		_diffSerial   = 0x0008,
		_diffLoc      = 0x0010,
		_diffLotTag   = 0x0020,
		_diffLotID    = 0x0040,
		_diffExpiry   = 0x0080
	};
	uint   CalcMethod;
	uint   Flags_;
	uint32 DiffParam;      // Флаги дифференциации записей (GoodsRestParam::_diffXXX)
	LDATE  Date;
	long   OprNo;          // Если Dt != 0 и OprNo > 0, то остаток по лотам брать до {Date, OprNo}
	PPID   LocID;          //
	PPID   GoodsID;
	PPID   SupplID;
	PPID   AgentID;        // ->Article.ID Агент, связанный с документом прихода товара (агент поставщика)
	PPID   QuotKindID;     //
	PPID   DiffLotTagID;   // Тип тега лотов, по значениям которого следует дифференцировать отчет
	PPIDArray LocList;
	GoodsRestVal Total;
	//
	// Указатель на массив идентификаторов (id) документов, имеющих атрибут PPBillExt(id)::AgentID == this->AgentID.
	// Структура GoodsRestParam не является владельцем объекта, на который ссылается этот указатель.
	// Конструктор GoodsRestParam::GoodsRestParam инициализирует этот указатель в NULL, а деструктор
	// не разрушает его. Вызывающая процедура обязана сама заботиться об указателе P_SupplAgentBillList.
	// Функция Transfer::GetRest и вызываемые ею используют указываемый список для быстрого определени
	// принадлежности лота агенту поставщика AgentID. Если AgentID != 0 && P_SupplAgentBillList == 0,
	// то эти функции отработают правильно, но медленнее. Функции, использующие список, на который
	// ссылается P_SupplAgentBillList не полагаются на то, что он отсортирован.
	//
	const  PPIDArray * P_SupplAgentBillList;
private:
	LDATE  Md_;
	long   Mo_;
	PPID   GoodsTaxGrpID;
	RetailPriceExtractor * P_Rpe; // @notowned
};
//
//
//
struct UhttGoodsRestVal { // @flat
	PPID   GoodsID;
	PPID   LocID;
	double Rest;
	LDATE  RestBillDt;
};
//
//
//
struct PPLotFault { // @flat
	enum {
		Ok = 0,
		// Первая операция по лоту (создание лота)
		NoOps,                // !?
		FirstBillID,          // !
		FirstDt,              // !
		FirstCost,            //
		FirstPrice,           //
		Quantity,             // !
		// Целостность ссылок
		RefGoods,             // Висячая ссылка на товара в лоте
		RefGoodsZero,         // Нулевой идентификатор товара в лоте
		RefQCert,             //
		RefPrevLot,           //
		RefSuppl,             //
		RefPrevEqID,          // !
		// Операции по лоту
		OpGoodsID,            // !?
		OpLocation,           // !?
		OpRest,               // !
		OpCost,               //
		OpPrice,              //
		OpFlagsCWoVat,        // Неверно установлено значение флага PPTFR_COSTWOVAT
		// Итоговые значения и признаки лота
		Rest,                 // !
		CloseTag,             // !
		CloseDate,            // !
		OrdReserveFlag,       // Неверно установлен либо не установлен флаг "Резервирующий заказ"
		CyclicLink,           // Циклическая ссылка в лотах
		LinkNotFound,         // Лот ссылается на несуществующий родительский лот
		WtRest,               // Неправильный текущий остаток по лоту в физ единицах
		OpWtRest,             // Неправильный остаток после операции в физ единицах
		NoPack,               // Отсутствует емкость упаковки
		PrevLotGoods,         // Товар в лоте не соответствует товару в лоте-предшественнике
		PrevLotLoc,           // Склад в лоте тот же, что и в лоте предшественнике
		PrevLotFlagsCWoVat,   // Не эквивалентная установка флага LOTF_COSTWOVAT с лотом-предшественником
		LcrInvRest,           // Неверный остаток в записи таблицы остатков по лотам
		LcrAbsence,           // Отсутствует запись в таблице остатков по лотам
		LcrWaste,             // Лишняя запись в таблице остатков по лотам
		LcrDb,                // Ошибка извлечения записи из таблицы остатков по лотам
		RevalOldCost,         // Неверная старая цена поступления в переоценке
		RevalOldPrice,        // Неверная старая цена поступления в переоценке
		NonUniqSerial,        // Неуникальный в пределах товара серийный номер лота
		OrdOpOnSimpleLot,     // Операия заказа привязана к обыкновенному лоту
		NegativeRest,         // Отрицательный текущий остаток по лоту
		InadqIndepPhFlagOn,   // В строке Transfer установлен флаг PPTFR_INDEPPHQTTY в то время как товара не имеет флага GF_USEINDEPWT
		InadqIndepPhFlagOff,  // В строке Transfer не установлен флаг PPTFR_INDEPPHQTTY в то время как товара имеет флаг GF_USEINDEPWT
		NonSingleRcptOp,      // К лоту привязано более одной строки, имеющей флаг PPTFR_RECEIPT
		PackDifferentGSE,     // Емкость упаковки лота отличается от ненулевой емкости упаковки поставки товара
		InadqLotWoTaxFlagOn,  // В лоте установлен флаг LOTF_PRICEWOTAXES в то время как товар не имеет флага GF_PRICEWOTAXES
		InadqTrfrWoTaxFlagOn, // В строке Transfer устанолен флаг PPTFR_PRICEWOTAXES в то время как товар не имеет флага GF_PRICEWOTAXES
		EgaisCodeAlone,       // Лот содержит тег кода продукции ЕГАИС, но ни один товар не имеет такого кода
		NoEgaisCode,          // Лот не содержит тега кода алкогольной продукции в то время как товар содержит такой код
		NoEgaisCodeAmbig,     // Лот не содержит тега кода алкогольной продукции в то время как товар содержит более одного ЕГАИС-кода
		ThereIsQCert          // У лота нет сертификата в то время как можно унаследовать сертификат от предыдущей партии
	};
	int    Fault;
	LDATE  Dt;
	LDATE  EndDate;         // Для групповых ошибок Lcr (LcrAbsence, LcrWaste)
	long   OprNo;
	double ActualVal;
	double ValidVal;
	//
	// Пара лотов, идентифицирующая циклическую связь.
	// Как правило, рвать необходимо связку ChildLotID->ParentLotID
	//
	PPID   ChildLotID;
	PPID   ParentLotID;
};

// Класс для работы с ЭЦП

class PPEds {
public:
	//
	// Descr: Подписывает документ. Подпись отсоединенная, то есть документ никак не меняетс
	//		и остается таким же доступным, как и до подписания.
	//	ARG(pSignerName		   IN): Имя подписанта
	//	ARG(pFileName		   IN): Имя документа, который надо подписать
	//	ARG(rSignFileName  IN/OUT): Если передана пустая строка, то создается файл с подписью
	//								"имя_документа.p7s". Если передано имя уже существующего
	//								файла с подписью/подписями, то оусуществляется операци
	//								добавления подписи
	// Returns:
	//		0 - error
	//		1 - подпись создана
	//
	int    SignData(const char * pSignerName, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Заверяет указанную подпись в документе
	// ARG(pCountersignerName	IN): Имя заверителя подписи
	// ARG(signerNumber			IN): Номер подписи, котороую нужно заверить. Список подписей
	//								можно получить с помощью функции GetSignersInDoc(). Каждой
	//								подписи соответствует номер, пока что начиная с единицы
	//								(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//								Этот номер и нужно указать
	// ARG(pFileName			IN): Имя подписанного документа
	// ARG(pSignFileName		IN): Имя файла с подписью
	// Returns:
	//		0 - error
	//		1 - подпись заверена
	int CountersignData(const char * pCountersignerName, int signerNumber, const char * pFileName, const char * pSignFileName);
	// Descr: Удаляет подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signNumber		IN): Номер подписи в документе. Список подписей
	//						можно получить с помощью функции GetSignersInDoc(). Каждой
	//						подписи соответствует номер, пока что начиная с единицы
	//						(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//						Этот номер и нужно указать
	// Returns:
	//		0 - error
	//		1 - подпись успешно удалена
	int DeleteSign(const char * pSignFileName, int signNumber);
	// Descr: Удаляет заверяющую подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер заверенной подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соответствует номер, пока что начиная с единицы
	//							зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - нет заверяющей подписи
	//		 0 - error
	//		 1 - подпись удалена
	int DeleteCountersign(char * pSignFileName, int signerNumber);
	// Descr: Шифрует документ. При шифровании создается документ с именем "имя_документа_encoded".
	//		При этом можно оставить оба файла (исходный и получившийся зашифрованный),
	//		можно оставить только зашифрованный вариант, тогда он будет называться как исходный
	// ARG(pOwnerName		IN): Имя владельца сертификата, чьим закрытым ключом будет зашифровн документ
	// ARG(pFileName		IN): Имя документа
	// ARG(sameFile			IN): Указывает, перезаписать документ или сохранить закодированные данные
	//						в файл "имя_документа_encoded"
	//						0 - записать закодированные данные в отдельный файл
	//						1 - перезаписать документ
	// Returns:
	//		0 - error
	//		1 - документ зашифрован
    int EncodeData(const char * pOwnerName, const char * pFileName, int sameFile = 1);
	int DecodeData(const char * pOwnerName, const char * pFileName/*, int sameFile = 1*/);

	// Descr: Получает из файла список подписей
	// ARG(pFileName	IN): Имя подписанного документа
	// ARG(rSignersArr OUT): Список имен владельцев подписей, содержащихся в документе.
	// Returns:
	//		-1 - документ не подписан
	//		 0 - error
	//		 1 - список имен получен
	//int GetSignersInDoc(const char * pFileName, StrAssocArray & rSignersArr);


	// Descr: Проверяет подпись
	// ARG(pFileName		IN): Имя подписанного документа
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер подписи для проверки. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соответствует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - подпись не верна
	//		 0 - error
	//		 1 - подпись верна
	int    VerifySign(const char * pFileName, const char * pSignFileName, int signerNumber);
	//
	// Descr: Проверяет заверяющую подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер заверенной подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соответствует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - нет заверяющей подписи
	//		 0 - error
	//		 1 - заверяющая подпись верна
	//
	int    VerifyCountersign(const char * pSignFileName, int signerNumber);
	//
	// Descr: Возвращает всех владельцев сертификатов подписей в хранилище сертификатов "My"
	//
	int    GetSignerNamesInStore(StrAssocArray & rStrArray);
	//
	// Descr: Возвращает список файлов с подписями, связанные с указанным документом.
	//		Вообще-то нет регламента, который указывал бы, как должны называться файлы,
	//		все зависит от конкретного оператора ЭДО, если речь об этом. Поэтому
	//		пока что зададим условие, что имя файла с подписью должно начинаться с "имя_документа" + "_"
	// ARG(pFileName	 IN): Имя документа, для которого надо найти файлы с подписями
	// ARG(rFilesLis	OUT): Массив имен файлов с подписями
	// Returns:
	//		 0 - error
	//		 1 - хотя бы один файл найден
	//
	int    GetSignFilesForDoc(const char * pFileName, StrAssocArray & rFilesLis);
	//
	// Descr: Получает имя владельца пописи по ее порядковому номеру в файле подписи
	// ARG(pSignFileName	IN): Имя файла с подписями
	// ARG(signNumber		IN): Номер подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соответствует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// ARG(rSignerName OUT): Имя владельца подписи
	// Returns:
	//		-1 - подписи с таким номером нет
	//		 0 - error
	//		 1 - имя владельца подпсии получено
	int GetSignerNameByNumber(const char * pSignFileName, int signNumber, SString & rSignerName);
private:
	//
	// Descr: Возвращает число подписей в документе
	// ARG(pSignFileName	 IN): Имя файла с подписями
	// ARG(rCount			OUT): Число подписей в документе
	// Returns:
	//		  -1 - ошибка
	//		>= 0 - число подписей
	//
	int    GetSignsCount(const char * pSignFileName, int & rCount);
	//
	// Descr: Получает указатель на структуру типа HCRYPTPROV (информация о криптопровайдере)
	// ARG(cert			IN): Указатель на структуру CERT_CONTEXT с информацией о сертификате подписи
	// ARG(rCryptoProv OUT): Указатель на структуру с инфоомацией о криптопровайдере
	// ARG(rKeySpec	   OUT): Тип пары ключей подписи (AT_KEYEXCHANGE или AT_SIGNATURE)
	// Returns:
	//		0 - error
	//		1 - криптопровайдер получен
	//
	int    GetCryptoProv(PCCERT_CONTEXT & cert, HCRYPTPROV & rCryptoProv, DWORD & rKeySpec);
	//
	// Будем работать с отсоединенной (detached) подписью
	// Descr: Ставит первую подпись в документе
	// ARG(pSgnerName			IN): Имя владельца пописи
	// ARG(pFileName			IN): Имя документа
	// ARG(pSignFileName	IN/OUT): Если передается пустая строка, создается файл "имя_документа.p7s",
	//								в который сохранится созднаная подпись. Если передается имя уже
	//								существующего файла с подписью, то он будет перезаписан.
	// Returns:
	//	   -1 - пользователь отменил действие
	//		0 - error
	//		1 - подпись поставлена
	//
	int    FirstSignData(const char * pSignerName, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Добавляет подпись в документ
	// ARG(pCosignerName	IN): Имя владельца подписи
	// ARG(pFileName		IN): Имя документа
	// ARG(pSignFileName	IN): Имя файла с подписями
	// Returns:
	//	   -1 - пользователь отменил действие
	//		0 - error
	//		1 - подпись успешно добавлена
	//
	int    CoSignData(const char * pCosignerName, const char * pFileName, const char * pSignFileName);
	//
	// Descr: Проверяет цепочку сертификатов, начиная с сертификата, указанного во входном параметре
	//
	int CheckCertChain(PCCERT_CONTEXT & cert);
	//
	// Descr: Возвращает указатели на хранилище сертификатов и на сертификат по имени его владельца
	// ARG(rCertStore	OUT): Указатель на хранилище сертификатов
	// ARG(rCert		OUT): Указатель на структуру CERT_CONTEXT, содержащую информацию о сертификате
	// ARG(pOwnerName	 IN): Имя владельца сертификата
	// Returns:
	//		0 - error
	//		1 - сертификат найден
	//
	int GetCert(HCERTSTORE & rCertSore, PCCERT_CONTEXT & rCert, const char * pOwnerName);
	//
	// Descr: Возвращает сертификат владельца через диалог выбора контейнера ключей
	//
	int GetCert(PCCERT_CONTEXT & rCert);
	//
	// Descr: При подписании документа сохраняется не только подпись, но и некоторая инфа о сертификате
	//		владельца подписи. Если подписей несколько, то не факт, что порядковый номер подписи
	//		в файле совпадает с порядковым номером сертификата. Эта функция позволяет по имени
	//		владельца подписи найти номер соответствующего ей сертификата.
	// ARG(pSignFileName	IN): Имя файла с подписями
	// ARG(pSignerName	IN): Имя владельца подписи
	// ARG(rCert	   OUT): Номер сертификата
	// Returns:
	//		0 - error
	//		1 - номер сертификата определен
	//
	int GetCertIndexBySignerName(const char * pSignerFileName, const char * pSignerName, int & rCertIndex);
	//
	// Descr: Включает кеширование провайдера ключей. Чтобы при подписании документа окно ввода
	//		пароля появилось только один раз
	// ARG(cert	IN): Сертификат, для которого устанавливается кеширование
	//
	int CashOn(PCCERT_CONTEXT & cert);
	int CashOff(PCCERT_CONTEXT & cert);
	//
	// Descr: Возвращает имя заверителя, который заверил подпись с указанным номером в указанном файле
	//		с подписями
	// ARG(pSignFileName		 IN): Имя файла с подписями
	// ARG(signerNumber			 IN): Порядковый номер заверенной подписи
	// ARG(rCounterSignerName	OUT): Имя заверител
	//
	int GetCountersignerNameBySignerNumber(const char * pSignFileName, int signerNumber, SString & rCounterSignerName);
	//
	// Descr: Преобразует имя подписываемого документа, изменяя его расширение на ".p7s".
	//		В итоге получается файл для хранения подписей для данного документа.
	// ARG(pDocName		  IN): Имя документа, который будет подписан или уже содержит подписи
	// ARG(rSignFileName OUT): Имя файла подписей
	//
	void GetSignFileName(const char * pFileName, SString & rSignFileName);
	//
	// Descr: Получает от сервера штампов времени штамп на указанную подпись и сохраняет его
	//			в атрибутах подписи
	// ARG(pSignFileName	 IN): Имя файла с подписями
	// ARG(signerNumber		 IN): Номер подписи в файле с подписями
	// ARG(rResponse		OUT): Структура, содержащая разобранный ответ от сервера штампов времени
	// Returns:
	//		0 - error
	//		1 - штамп времени получен
	//
	int GetTimeStamp(const char * pSignFileName, int signerNumber, StTspResponse & rResponse);
	//
	// Descr: Возвращает хеш, расчитанный для указанной подписи. Функцию необходимо
	//		вызвать дважды. В первый раз параметр pHashedData должен быть равен NULL, тогда
	//		в rSizeHashedData вернется размер данных. После чего надо выделить память под
	//		pHashedData и вызвать функцию во второй раз. В итоге в pHashedData будут
	//		храниться данные о хеше.
	// ARG(pData				 IN): Данные, считанные из файла с подписями
	// ARG(dataSize				 IN): Размер данных из файла с подписями
	// ARG(signNumber		 	 IN): Номер подписи, для чей хеш надо получить
	// ARG(pHashedData			OUT): Данные о хеше
	// ARG(rSizeHashedData	 IN/OUT): Размер данных о хеше
	//
	int GetHash(void * pData, DWORD dataSize, int signNumber, BYTE * pHashedData, DWORD & rSizeHashedData);
	//
	// Descr: Кодирует объектные идентификаторы в der-кодировку. Используется в
	//		функции получения штампа времени.
	// ARG(objIdfr		 IN): Строка, содержащая объектный идентификатор
	// ARG(rEncodedStr	OUT): Объектный идентификатор в der-кодировке
	//
	int ObjIdfrDerEncode(const char * objIdfr, SString & rEncodedStr);
	//
	// Descr: Возвращает имя закодированного документа. Имя зависит от параметра sameFile.
	//		Используется при кодировании файла. Если параметр sameFile = 0, то закодированные
	//		данные сохраняться в отдельный файл. Если sameFile = 1, то закодированные данные
	//		сохранятся в файл "имя_документа_1", который потом будет переименован в "имя_документа",
	//		то есть исходный документ будет перезаписан.
	// ARG(pFileName		 IN): Исходное имя документа
	// ARG(rEncryptFileName	OUT): Имя закодированного документа
	// ARG(sameFile			 IN): Параметр, определяющий, каким будет имя документа.
	//							0 - "имя_документа_encoded"
	//							1 - "имя_документа_1"
	//
	void GetEncryptedFileName(const char * pFileName, SString & rEncryptFileName, int sameFile = 1);
	//
	// Descr: По заданному номеру выбранной позиции из списка диалога и имени документа возвращает
	//			имя файла подписи, которой принадлежит выбранная подпись
	// ARG(posInList		 IN): Номер выбранной позиции в списке диалога
	// ARG(pFileName		 IN): Имя документа, который надо подписать
	// ARG(rSignFileName	OUT): Имя файла подписи
	//
	int GetSignFileAndSignNames(int posInList, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Разбирает ответ, полученный от сервера штапма времени
	// ARG(pResponse		 IN): Ответ (последовательность байт), полученный от сервера штампа времени
	// ARG(rResponseFmtd	OUT): Разобранный ответ
	// Returns:
	//		0 - error разбора
	//		1 - ответ разобран
	//
	int ParseTSAResponse(const char * pResponse, StTspResponse & rResponseFmtd);
};

class PPLotFaultArray : public SVector {
public:
	PPLotFaultArray(PPID lotID, PPLogger & rLogger);
	int    AddFault(int fault, const TransferTbl::Rec *, double act, double valid);
	int    AddFault(int fault, const ReceiptTbl::Rec * pRec, PPID childID, PPID parentID);
	PPLotFault & FASTCALL at(uint p) const;
	int    AddMessage();
	SString & Message(uint p, SString &);
	int    HasFault(int faultId, PPLotFault *, uint * pPos) const;
	int    HasCostOpFault(LDATE, long, uint * p) const;
	int    HasPriceOpFault(LDATE, long, uint * p) const;
	int    HasLcrFault() const;
	int    _HasOpFault(int fault, LDATE dt, long oprno, uint * p) const;
	PPID   LotID;
private:
	PPLogger * P_Logger; // @notowned
};
//
//
//
#define CPTFREXSTR_SERIAL          1
#define CPTFREXSTR_CLB             2
#define CPTFREXSTR_LINKBILLROW     3
#define CPTFREXSTR_QRSEQACKSTATUS  4

struct CpTrfrExt {
	CpTrfrExt();
	char   PartNo[24];
	char   Clb[24];
	PPID   LinkBillID; // (PPOPT_DRAFTQUOTREQ) Ид связанного документа
	int    LinkRbb;    // (PPOPT_DRAFTQUOTREQ) Номер строки связанного документа
	int    QrSeqAckStatus; // Статус ответа поставщика на запрос: 1 - accepted, 2 - rejected
		// Транслируется во флаги PPTransferItem::TFlags (tfQrSeqAccepted, tfQrSeqRejected)
};

class CpTransfCore : public CpTransfTbl {
public:
	static int FASTCALL PutExt__(CpTransfTbl::Rec & rRec, const CpTrfrExt * pExt);
	static int FASTCALL GetExt__(CpTransfTbl::Rec & rRec, CpTrfrExt * pExt);
	CpTransfCore();
	int    PutItem(PPTransferItem * pTi, int16 forceRByBill, const CpTrfrExt * pExt, int use_ta);
	int    RemoveItem(PPID billID, int rByBill, int use_ta);
	int    EnumItems(PPID billID, int * pRByBill, PPTransferItem *, CpTrfrExt *);
	//
	// Descr: Загружает в пакет документа pPack строки из таблицы, соответствующие документу с идентификатором billID.
	//   Если pGoodsList != 0, то загружаются только те строки, в которых идентификатор товара содержится в списке
	//   по указателю.
	//   Если pPack == 0, то все что функция делает, это определяет есть ли хоть одна строка для документа billID
	//   по заданным условиям.
	// Return:
	//   >0 - в пакет (может быть) загружена по крайней мере одна строка.
	//   <0 - не существует ни одной строки для документа billID (возможно, с учетом органичений, заданных pGoodsList)
	//    0 - error
	//
	int    LoadItems(PPID billID, PPBillPacket * pPack, const PPIDArray * pGoodsList);
	int    Search(PPID billID, int rByBill, CpTransfTbl::Rec * pRec = 0);
	int    SearchGoodsRef(PPID goodsID, CpTransfTbl::Rec * pRec = 0);
	int    ReplaceGoods(PPID destGoodsID, PPID srcGoodsID, int use_ta);
};
//
// Флаги функции Transfer::RecoverLot
//
#define TLRF_REPAIR            0x0001 // Общий флаг, предписывающий запускать корректировку. Если этот флаг
	// не установлен, то никакая корректировка запускаться не будет.
#define TLRF_REPAIRPACK        0x0002 // Корректировать емкости упаковок
#define TLRF_REPAIRCOST        0x0004 // Исправлять цены поступления //
#define TLRF_REPAIRPRICE       0x0008 // Исправлять цены реализации  //
#define TLRF_RMVLOST           0x0010 // Удалять лоты, не имеющие ни одной операции
#define TLRF_CHECKUNIQSERIAL   0x0020 // Проверять серийные номера на уникальность в пределах товара
#define TLRF_ADJUNUQSERIAL     0x0040 // Исправлять неуникальные в пределах товара серийные номера
	// (доступно только если в конфигурации документов определен суффикс уникальности серий).
#define TLRF_INDEPHQTTY        0x0080 // Корректировать флаг PPTFR_INDEPPHQTTY в записях Transfer в соответствии
	// с флагом GF_USEINDEPWT установленным в товаре
#define TLRF_REPAIRPACKUNCOND  0x0100 // Безусловно корректировать емкости упаковок в лотав по значению, заданному в карточке товара
#define TLRF_REPAIRWOTAXFLAGS  0x0200 //
#define TLRF_SETALCCODETOGOODS 0x0400 // Если лот содержит тег PPTAG_LOT_FSRARLOTGOODSCODE то добавлять такой код
	// в список кодов товара, если ни один из товаров не содержит такой код
#define TLRF_SETALCCODETOLOTS  0x0800 // Если товар содержит код алкогольной продукции, а лот - нет, то в тег лота
	// PPTAG_LOT_FSRARLOTGOODSCODE переносить этот код.
#define TLRF_SETINHQCERT       0x1000 // Устанавливать на лоты, у которых нет сертификатов, унаследованные от
	// предыдущих приходов сертификаты.
#define TLRF_SETALCOMANUF      0x2000 // Устанавливать импортера/производителя ЕГАИС по справкам А из внутренней базы данных
//
// Флаги функции Transfer::MoveLotOps
//
#define TMLOF_RMVSRCLOT        0x0001 // Удалить донора
#define TMLOF_RMVREVAL         0x0002 // Удалять переоценки по донору (подразумевается если TMLOF_RMVSRCLOT)
#define TMLOF_ADDLOTS          0x0004 // Прибавить количество донора к акцептору
#define TMLOF_AVGCOST          0x0010 // Усреднить цены поступления акцептора по ценам донора
	// (если !TMLOF_ADDLOTS то игнорируется)
#define TMLOF_AVGPRICE         0x0020 // Усреднить цены реализации акцептора по ценам донора
	// (если !TMLOF_ADDLOTS то игнорируется)
#define TMLOF_NORECALCDESTBILL 0x0040 // Не пересчитывать суммы и проводки документа акцептора
	// (если !TMLOF_ADDLOTS то игнорируется)

//
// Параметр и флаги функции Transfer::UpdateCascadeLot
//
struct TrUCL_Param {
	PPID   GoodsID;
	PPID   SupplID;
	PPID   LotTaxGrpID;
	double Cost;
	double Price;
	double LotCost;  // Out
	double LotPrice; // Out
};

#define TRUCLF_UPDGOODS  0x0001U
#define TRUCLF_UPDSUPPL  0x0002U
#define TRUCLF_UPDCOST   0x0004U
#define TRUCLF_UPDPRICE  0x0008U
#define TRUCLF_UPDTAXGRP 0x0010U
#define TRUCLF_UPDCP     (TRUCLF_UPDCOST | TRUCLF_UPDPRICE)
//
// Коды операций над основными средствами
//
#define ASSTOPC_UNDEF    0 // Неопределенная операция //
#define ASSTOPC_RCPT     1 // Приход с вводом в эксплуатацию
#define ASSTOPC_RCPTEXPL 2 // Приход без ввода в эксплуатацию
#define ASSTOPC_EXPL     3 // Ввод в эксплуатацию
#define ASSTOPC_EXPLOUT  4 // Вывод из эксплуатации
#define ASSTOPC_MOV      5 // Перемещение на другой склад
#define ASSTOPC_DEPREC   6 // Начисление амортизации
#define ASSTOPC_REVAL    7 // Переоценка
#define ASSTOPC_EXPEND   8 // Расход
//
// Параметр функции Transfer::GetGoodsIdList
//
struct GoodsByTransferFilt {
	explicit GoodsByTransferFilt(const GoodsFilt * pGoodsFilt = 0);
	bool   IsEmpty() const;
	enum {
		fNoZeroRestOnLotPeriod = 0x0001,
		fIncludeIntr   = 0x0002,
		fNewLots       = 0x0004
	};
	PPID   SupplID;
	DateRange LotPeriod;
	long   Flags;
	ObjIdListFilt LocList;
};
//
// Descr: Класс, реализующий низкоуровневые функции работы с таблицей товарных операций //
//
class Transfer : public TransferTbl {
public:
	Transfer();
	~Transfer();
	int    SearchByBill(PPID billID, int reverse, short rByBill, TransferTbl::Rec * pRec);
	int    SearchMirror(LDATE dt, long oprno, TransferTbl::Rec *);
	int    SearchReval(PPID lotID, LDATE, long oprno = 0, TransferTbl::Rec * = 0);
	//
	// Descr: По указателю pOprNo присваивает номер операции для новой записи.
	//
	int    GetOprNo(LDATE, long * pOprNo);
	//
	// Если EnumItems возвращает значение > 0 (найдена очередная запись),
	// то в таблице Rcpt запись установлена по идентификатору PPTransferItem::LotID
	//
	int    EnumItems(PPID billID, int * rByBill, PPTransferItem *);
	int    EnumByLot(PPID lotID, LDATE *, long *, TransferTbl::Rec * = 0);
	int    EnumByLot(PPID lotID, DateIter *, TransferTbl::Rec * = 0);
	int    GetLastOpByGoods(PPID goodsID, LDATE beforeDt, long beforeOprNo, TransferTbl::Rec * pRec);
	int    EnumAssetOp(PPID lotID, DateIter * pIter, int * pOpCode /* ASSTOPC_XXX */, PPID * pDestLotID, TransferTbl::Rec * pRec);
	int    EnumAssetOp(PPID * pLotID, DateIter * pIter, int * pOpCode, TransferTbl::Rec * pRec);
	//
	// Descr: Возвращает списко идентификаторов товаров, которые когда-либо были на складе locID.
	//
	int    GetLocGoodsList(PPID locID, UintHashTable & rList);
	//
	// Descr: Возвращает значение >0, если по лоту lotID нет ни одной операции
	//   кроме операции, создавшей этот лот.
	//
	int    IsDeadLot(PPID lotID);
	//
	// Descr: Определяет является ли лот lotID скоплектованным документом модификации.
	// Returns:
	//   >0 - оригинальный лот был скомплектован документом модификации
	//   <0 - ни сам лот, ни его предки не были скомплектованы
	//   0  - ошибка
	//
	int    IsCompletedLot(PPID lotID);
	//
	// Descr: Определяет статус исполнения товарного заказа.
	//   Делается это так: по каждому лоту документа billID определяется текущий остаток.
	//   -- если по всем лотам остаток нулевой, то документ заказа исполнен полностью,
	//   -- если по всем лотам остаток равен начальному, то документ заказа не выполнен вообще
	//   -- если хотя бы часть лотов имеет остаток меньше начального, то заказ выполнен частично
	//   Предполагается, что документ billID имеет вид, относящийся к типу PPOPT_GOODSORDER
	//   Техника работы функции опирается на принцип учета заказов в Papyrus'е в соответствии с которым
	//   каждый элемент заказа формирует лот и отрицательным идентификатором товара. При выполнении
	//   заказа строки отгрузки связываются с лотом заказа теневыми (shadow) записями и расходуют заказ.
	// ARG(billID IN): Идентификатор документа заказа
	// ARG(pStatus OUT): По этому указателю присваивается статус заказа:
	//   0 - документ не содержит ни одной строки заказа (возможно, это вообще не заказ и т.п.)
	//   1 - заказ полностью не выполнен
	//   2 - заказ полностью выполнен
	//   3 - заказ выполнен частично
	// Returns:
	//   >0 - документ найден, он является документом заказа и по указателю pStatus присвоен статус исполнения //
	//   <0 - документ либо не найден, либо не является документом заказа, либо не имеет строк и т.д. В общем, нет объекта для идентификации
	//    0 - error (что-то очень плохое: сбой в базе данных, нет памяти и т.д.)
	//
	int    GetOrderFulfillmentStatus(PPID billID, int * pStatus);
	//
	// Descr: Загружает товарные строки документа из таблицы Transfer.
	// ARG(billID     IN): Идентификатор документа, для которого необходимо загрузить строки
	// ARG(pPack  IN/OUT): Пакет документа, в который загружаются строки (PPBillPacket::Lots)
	// Returns:
	//   1 - строки успешно загружены
	//   0 - error
	//
	int    LoadItems(PPBillPacket & rPack, const PPIDArray * pGoodsList); // @<<PPObjBill::ExtractPacket
	int    SetupItemByLot(PPTransferItem *, ReceiptTbl::Rec * pLotRec, int checkLotPrices, long oprno);
	struct BillTotal {
		long   LineCount; // Количество строк в документе
	};
	//
	// Descr: Рассчитывает итоги по документу billID.
	//   Если pGoodsIdList != 0, то заносит в этот массив все встреченные в документе идентификаторы товаров.
	// Note: В массив pGoodsIdList идентификаторы товаров вносятся без контроля дублирования (ради ускорения).
	//   В связи с этим, после вызова функции (серии вызовов) следует применить метод LongArray::sortAndUndup() к pGoodsIdList.
	//
	int    CalcBillTotal(PPID billID, BillTotal * pTotal, PPIDArray * pGoodsIdList);
	//
	// Descr: Возвращает список товаров, соответствующих фильтру pFilt.
	//
	int    GetGoodsIdList(const GoodsByTransferFilt & rFilt, PPIDArray & rList);
	//
	// В следующих двух функциях если первый параметр предписывает давать
	// разбивку по лотам (GoodsRestParam::calcMethod == GoodsRestParam::pcmDiff),
	// и два последних параметра не равны нулю, параметру *count присваивается //
	// количество лотов с ненулевыми остатками, а по адресу, заданному
	// последним параметром присваивается динамическая область памяти
	// со значениями для этих лотов. При этом структура, заданная первым
	// параметром получает значения такие как если бы calcMethod был бы
	// равен GoodsRestParam::pcmSum.
	//
	int    GetRest(GoodsRestParam & rP);
	int    GetCurRest(GoodsRestParam & rP);
	int    EvaluateAverageRestByLot(PPID lotID, const DateRange & rPeriod, double * pAvgQtty); // @v12.1.11 @construction
	int    FixUpPeriodForAverageRestEvaluating(const PPIDArray & rLocList, const PPIDArray & rGoodsList, DateRange & rPeriod); // @v12.1.12
	int    EvaluateAverageRestByGoods(const PPIDArray & rLocList, const PPIDArray & rGoodsList, DateRange & rPeriod, RAssocArray & rList); // @v12.1.12
	int    GetLcrList(LDATE dt, UintHashTable * pLotList, RAssocArray * pRestList);
	int    CalcAssetDeprec(PPID lotID, const DateRange *, double * pDeprec);
	//
	// Descr: Берет остаток по лоту на заданную дату сразу после (!) операции oprno.
	//   Т.е. если операция {dt, oprno} относится к лоту lot, то берется остаток по этой операции.
	//
	int    GetRest(PPID lotID, LDATE, long oprno, double * pRest, double * pPhRest = 0);
	int    GetRest(PPID lotID, LDATE, double * pRest, double * pPhRest = 0);
	//
	// Descr: Вычисляет предельно допустимые изменения количества товара по
	//   лоту lotID на заданнуе дату и номер операции, следующий за oprno.
	//   Если oprno < 0, то это все равно, что {dt+1, 0} (точнее {dt, MAXLONG}).
	//   Указатели down и up могут быть нулевыми. Если up == 0, то функция //
	//   отработает несколько быстрее.
	//
	int    GetBounds(PPID lotID, LDATE, long oprno, double * down, double * up);
	//
	// Descr: Рассчитывает доступный остаток товара goodsID по складу locID.
	//   Рассматриваются только открытые лоты, попадающие в период rPeriod.
	//   Если аргумент ignoreEpsilon > 0, то игнорируются лоты, имеющие остаток меньший чем ignoreEpsilon.
	//
	int    GetAvailableGoodsRest(PPID goodsID, PPID locID, const DateRange & rPeriod, double ignoreEpsilon, double * pRest);
	//
	// Descr: Опции функции GetOriginalValuesForCorrection
	//
	enum {
		govcoVerifyGoods = 0x0001 // Сверять идентичность товаров между строкой корректирующего документа и основного.
	};
	//
	// Descr: Получает оригинальные значения количества и цены для строки корректирующего документа rTi.
	// ARG(rTi IN): Строка корректирующего документа
	// ARG(rBillChain IN): Цепочка идентификаторов документов, начинающаяся от оригинального и включающая
	//   все документы коррекции, предшествующие rTi.BillID. Эта цепочка формируется функцией
	//   PPObjBill::GetCorrectionBackChain.
	// ARG(pOrgQtty OUT): Результирующая величина оригинального количества
	// ARG(pOrgPrice OUT): Результирующая величина оригинальной цены (включает скидку).
	// Returns:
	//   <0 - строка rTi не является строкой корректировки либо не найдено даже
	//     оригинального корректируемого документа
	//    1 - найдена строка, относящаяся к оригинальному корректируемому документу
	//    2 - найдена строка, относящаяся к оригинальному корректируемому документу, а также
	//      одна или более строк, принадлежащих другим документам коррекции.
	//
	int    GetOriginalValuesForCorrection(const PPTransferItem & rTi, const PPIDArray & rBillChain, long options, double * pOrgQtty, double * pOrgPrice);
	//
	// Descr: Аналог функции GetOriginalValuesForCorrection(const PPTransferItem &, const PPIDArray &, long, double *, double *) но в качестве
	//   первого аргумента принимает TransferTbl::Rec (то есть, сырую запись базы данных, а не внутренний объект PPTransferItem).
	//
	int    GetOriginalValuesForCorrection(const TransferTbl::Rec & rRec, const PPIDArray & rBillChain, long options, double * pOrgQtty, double * pOrgPrice); // @v11.5.9
	int    AddLotItem(PPTransferItem * pTi, PPID forceID = 0);
	int    AddItem(PPTransferItem * pTi, int16 & rByBill, int use_ta);
	enum {
		fUpdEnableUpdChildLot = 0x0001
	};
	int    UpdateItem(PPTransferItem * pTI, int16 & rByBill, long flags, int use_ta);
	int    RemoveItem(PPID billID, int rByBill, int force, int use_ta);
	int    CorrectReverse();
	int    CorrectIntrUnite();
	//
	// Функция CorrectByLot проверяет и исправляет следующие ошибки:
	// 1. Неверное начальное количество в записи лота
	// 2. Неверные остатки в записях операций по лоту
	// 3. Неправильно установленный флаг Closed в записи лота
	// 4. Ошибочную цену поступления в операции
	// 5. Ошибочную цену реализации в операции
	//
	// При обнаружении ошибки вызывается пользовательская функци
	// MsgProc с параметрами:
	// err - Номер ошибки (см. список выше)
	// lot - Ид. лота
	// rec - Запись из таблицы Transfer с ошибкой. Для ошибки 3 эта
	//       запись будет содержать бессмысленное значение.
	//
	// Если необходимо исправить ошибку, MsgProc должна вернуть
	// значение > 0. 0 означает пропуск ошибки. < 0 - прервать процесс.
	// MsgProc == 0 - означает безусловное исправление всех найденных ошибок.
	//
	// Функция CorrectByLot все исправления делает внутри транзакции.
	//
	int    CorrectByLot(PPID, int (*MsgProc)(int err, PPID, const TransferTbl::Rec *));
	//
	// Descr: проверяет записи таблицы CurRest. Обнаруженные ошибки она записывает в файл с именем, заданным
	//   параметром pLogName. Параметр correct предписывает исправлять обнаруженные ошибки.
	//
	int    CorrectCurRest(const char * pLogName, int correct);
	int    CorrectCurRest(PPID goodsID, const PPIDArray * pLocList, PPLogger * pLogger, int correct);
	int    CorrectLotTaxGrp();
	//
	// Descr: Если в функции GetLotPrices параметр oprno равен нулю, то ищется //
	//   переоценка, начиная со следующего за date дня, иначе ищется переоценка
	//   начиная с даты date и операции (oprno + 1)
	//
	int    GetLotPrices(ReceiptTbl::Rec * pLotRec, LDATE, long oprno = 0);
	int    UpdateForward(PPID lotID, LDATE dt, long oprno, int check, double * pAdd, double * pPhAdd);
	int    RecByBill(PPID billID, short * rByBill);
	int    UpdateCascadeLot(PPID lotID, PPID ownBillID, TrUCL_Param * p, uint flags, int use_ta);
	//
	// Descr: Используется для расчета текущего свободного остатка по лоту в контексте
	//   пакета PPBillPacket. Задача этой функции - быстро найти все товарные строки,
	//   принадлежащие пакету с ид billID и относящиеся к лоту lotID и вычесть из остатка
	//   *pRest поле Quantity каждой из таких строк.
	//
	int    SubtractBillQtty(PPID billID, PPID lotID, double * pRest);
	int    PreprocessCorrectionExp(PPTransferItem & rTi, const PPIDArray & rBillChain);
	int    CheckLot(PPID lotID, const ReceiptTbl::Rec *, long flags, PPLotFaultArray & rResultList);
	int    RecoverLot(PPID lotID, PPLotFaultArray *, long flags /* TLRF_XXX */, int use_ta);
	int    RecalcLcr();
	int    MoveLotOp(PPID srcLotID, LDATE dt, long oprno, PPID destLotID, int use_ta);
	int    MoveLotOps(PPID srcLotID, PPID destLotID, long flags /* TMLOF_XXX */, int use_ta);
	int    Cutting(LDATE endDate, int use_ta);

	class GetLotPricesCache {
	public:
		GetLotPricesCache(LDATE dt, const PPIDArray * pLocList);
		int    FASTCALL Get(ReceiptTbl::Rec * pLotRec);
	private:
		LDATE  Date;
		PPIDArray RLotList; // Список лотов, по которым были переоценки после Date
	};
private:
	class LcrBlockBase {
	public:
		enum {
			opTest = 1, // Проверка правильности заполнения данных
			opRecalc,   // Полный пересчет записей текуших остатков
			opUpdate    // Пересчет в ответ на изменение записи Transfer
		};
		enum {
			statusAddRec = -3, // Запись необходимо добавить
			statusUpdRec = -2, // Запись необходимо изменить
			statusRmvRec = -1, // Запись необходимо удалить
			statusNone   = 0,  // Запись верная //
			statusInvRest,     // Неверный остаток
			statusAbsence,     // Отсутствующая запись
			statusWaste,       // Лишняя запись
			statusDb           // Ошибка извлечения записи
		};
	protected:
		LcrBlockBase(int op, BExtInsert * pBei);

		int    Op;
		PPID   LotID;
		LDATE  LastDate;
		double LastRest;
		double CurTrfrRest; //
		BExtInsert * P_Bei;
	};
	//
	// Descr: Блок обработки текущих остатков по лотам
	//   Все изменения в базе данных методами класса делаются без
	//   транзакции. Ergo: вызывающие функции должны позаботиться о транзактивности.
	//
	class LcrBlock : public LcrBlockBase {
	public:
		LcrBlock(int op, LotCurRestTbl * pTbl, BExtInsert * pBei);
		int    InitLot(PPID lotID);
		//
		// Descr: Изменяет актуальное состояние таблицы в ответ на изменение
		//   остатка по лоту lotID на дату dt и на величину addendum.
		//
		int    Update(PPID lotID, LDATE dt, double addendum);
		int    FASTCALL Process(const TransferTbl::Rec & rTrfrRec);
		int    FinishLot();
		int    TranslateErr(PPLotFaultArray * pLfa) const;
		int    HasError() const;
	private:
		int    AddItem(int status, LDATE dt, double exRest, double newRest);
		//
		// Descr: Определитель записи. Используется как для обновления состояния таблицы,
		//   так и для диагностики ошибок.
		//
		struct Item {
			LDATE  Dt;         // Дата записи
			int    Status;     // Статус записи
			double ExRest;     // Значение остатка в текущем состоянии записи
			double ValidRest;  // Правильное или новое значение остатка.
		};
		TSVector <Item> List;
		LotCurRestTbl * P_Tbl;
	};
	class LcrBlock2 : public LcrBlockBase {
	public:
		LcrBlock2(int op, LotCurRest2Tbl * pTbl, BExtInsert * pBei);
		int    InitLot(PPID lotID);
		//
		// Descr: Изменяет актуальное состояние таблицы в ответ на изменение
		//   остатка по лоту lotID на дату dt и на величину addendum.
		//
		int    Update(PPID lotID, LDATE dt, long addendumF);
		int    FASTCALL Process(const TransferTbl::Rec & rTrfrRec);
		int    FinishLot();
		int    TranslateErr(PPLotFaultArray * pLfa) const;
		int    HasError() const;
	private:
		int    AddItem(int status, LDATE dt, long exRestF, long newRestF);
		//
		// Descr: Определитель записи. Используется как для обновления состояния таблицы,
		//   так и для диагностики ошибок.
		//
		struct Item {
			LDATE  Dt;         // Дата записи
			int    Status;     // Статус записи
			long   ExRestF;    // Значение остатка в текущем состоянии записи
			long   ValidRestF; // Правильное или новое значение остатка.
		};
		TSVector <Item> List; //
		LotCurRest2Tbl * P_Tbl;
	};
	struct LotOpMovParam {
		PPID   SrcLotID;
		PPID   DestLotID;
		ReceiptTbl::Rec  SrcLot;
		ReceiptTbl::Rec  DestLot;
		TransferTbl::Rec TrRec;
	};
	int    ProcessLotFault(PPLotFaultArray & rList, int fault, double act, double valid);
	int    UpdateFwRevalCostAndPrice(PPID lotID, LDATE dt, long oprno, double cost, double price, uint * pUF /* TRUCLF_UPDCOST || TRUCLF_UPDPRICE */);
	int    UpdateFwRevalCostAndPrice2(PPID lotID, LDATE dt, long oprno, double cost, double price, uint * pUF);
	int    Search(PPID lot, LDATE, long oprno, int spMode);
	int    GetLotOprNo(LDATE, long * oprno);
	int    UpdateForward(const TransferTbl::Rec &, double addendum, double phAdd);
	int    UpdateCurRest(PPID goodsID, PPID loc, double addendum);
	int    RemoveItem(PPID bill, int rvrs, short rByBill, int force, int use_ta);
	int    UpdateItem(PPTransferItem *, int16 & rByBill, int rvrs, long flags, int use_ta);
	int    UpdateReceipt(PPID lotID, PPTransferItem *, PPID prevLotID, long flags);
		// @<<Transfer::UpdateItem(PPTransferItem *, int, long, int)
	int    EnumIncorrectReverse(PPID * billID, short * rByBill, TransferTbl::Rec * orgRec);
	int    InitLotOpMovParam(PPID srcLotID, PPID destLotID, LotOpMovParam *, int = 0);
	int    MoveOp(LotOpMovParam *, int use_ta);
	int    MergeLots(LotOpMovParam *, uint flags, int use_ta);
	int    CuttingLotOperations(PPID lotID, LDATE endDate, double * pEndQtty);
	int    Helper_RecalcLotCRest(PPID lotID, BExtInsert * pBei, int forceRebuild);
	int    Helper_RecalcLotCRest2(PPID lotID, BExtInsert * pBei, int forceRebuild);

	LotCurRestTbl  * P_LcrT;  //
	LotCurRest2Tbl * P_Lcr2T; //
public:
	ReceiptCore  Rcpt;
	CurRestTbl   CRest;
	// Realy private
	int    __DontCheckQttyInUpdateTransferItem__;
};
//
//   GoodsSaldoCore
//
class GoodsSaldoCore : public GoodsDebtTbl {
public:
	GoodsSaldoCore();
	//
	// Функция GetLastSaldo возвращает в pDt дату последнего рассчитаного сальдо <= *pDt.
	// Если *pDt == ZERODATE, то возвращает дату самого последнего рассчитаного сальдо.
	// Если код возврата < 0 - нет ни одного рассчитаного сальдо, *pDt = ZERODATE.
	//
	int    GetLastSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, LDATE * pDt, GoodsDebtTbl::Rec * pRec);
	int    GetLastCalcDate(PPID gdsGrpID, PPID gdsID, PPID arID, PPID dlvrLocID, LDATE * pDt);
	int    Add_(PPID gdsID, PPID artID, LDATE dt, double qtty, double amt, int use_ta);
	int    DeleteRecsByPeriod_(PPID gdsID, PPID artID, const DateRange * pPeriod, int use_ta);
};
//
//
//
struct PriceLineIdent {
	PriceLineIdent();
	PPID   PListID;
	PPID   GoodsID;
	PPID   QuotKindID;
	int16  LineNo;
};

class PriceListCore : public PriceListTbl {
public:
	PriceListCore();
	int    Search(PPID id, void * b = 0);
	int    Add(PPID * pID, void *, int use_ta);
	int    Update(PPID id, void *, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    SearchLine(const PriceLineIdent *, void * = 0);
	int    SearchGoodsLine(PriceLineIdent * pIdent, void * = 0);
	int    EnumLines(const PriceLineIdent * pIdent, PriceLineIdent * pIter, void * = 0);
	int    AddLine(PPID listID, void *, PriceLineIdent *, int useSubst, int use_ta); // AHTOXA
	int    UpdateLine(const PriceLineIdent *, PriceLineTbl::Rec *, int useSubst, int use_ta); // AHTOXA
	int    RemoveLine(const PriceLineIdent *, int use_ta);
private:
	int    GetLineNo(const PriceLineIdent *, short * pLineNo);
	PriceLineTbl::Key0 * IdentToKey0(const PriceLineIdent *, PriceLineTbl::Key0 *);
public:
	PriceLineTbl Lines;
};
//
// Системный журнал
//
enum SubstGrpSysJournal {
	sgsjNone    = 0,
	sgsjOp      = 1,
	sgsjUser    = 2,
	sgsjObjType = 3
};

class SysJournal : public SysJournalTbl {
public:
	SysJournal();
	~SysJournal();
	int    LogEvent(PPID action, PPID obj, PPID id, long extData, int use_ta = 0);
	//
	// Descr: Находит запись события action
	// ARG(action     IN): Системное событие (PPACN_XXX), которое следует найти
	// ARG(mode       IN): Режим поиска события //
	//   -1 - до момента *pDtm
	//    1 - после момента *pDtm
	// ARG(pDtm   IN/OUT): @#{vptr0}
	//    Если функция нашла требуемую запись, то по этому указателю присваивается //
	//    дата и время найденной записи.
	// ARG(maxDays    IN): Если параметр >0, то функция ограничивает просмотр событий периодом
	//   [pDtm->d-maxDays..pDtm] (mode = -1) и [pDtm..pDtm->d+maxDays] (mode = 1)
	// ARG(pRec      OUT): @#{vptr0} По этому указателю, если он не нулевой, функция //
	//   возвращает первую найденную запись.
	//
	int    GetEvent(PPID action, long extraVal, int mode, LDATETIME * pDtm, int maxDays, SysJournalTbl::Rec * pRec = 0);
	int    GetLastEvent(PPID action, long extraVal, LDATETIME * pDtm, int maxDays, SysJournalTbl::Rec * = 0);
	int    GetLastUserEvent(PPID action, PPID userID, PPID sessID, const DateRange * pSrchPeriod, LDATETIME *, SysJournalTbl::Rec * pRec = 0);
	int    GetObjCreationEvent(PPID objType, PPID objID, SysJournalTbl::Rec * pRec);
	int    GetLastObjModifEvent(PPID objType, PPID objID, LDATETIME *, int * pCreation, SysJournalTbl::Rec * pRec = 0);
	int    GetLastObjEvent(PPID objType, PPID objID, const PPIDArray * pActAry, LDATETIME * pDtm, SysJournalTbl::Rec * pRec = 0);
	int    GetLastObjUnifyEvent(PPID objType, PPID objID, PPID * pDestID, SysJournalTbl::Rec * pRec);
	//
	// Descr: Находит событие по объекту {objType; objID}, следующее за моментом времени rSince (не включая его).
	//   Если pActAry != 0 и pActAry->getCount(), то принимает в расчет только события, относящиеся к этому списку.
	//   Результат возвращается по указателю pRec.
	// Returns:
	//   >0 - найдено искомое событие
	//   <0 - не найдено ни одного события
	//   0  - ошибка
	//
	int    GetNextObjEvent(PPID objType, PPID objID, const PPIDArray * pActAry, const LDATETIME & rSince, SysJournalTbl::Rec * pRec);
	int    GetObjListByEventSince(PPID objType, const PPIDArray * pActList, const LDATETIME & rSince, PPIDArray & rObjList, TSVector <SysJournalTbl::Rec> * pRecList);
	int    GetObjListByEventPeriod(PPID objType, PPID userID, const PPIDArray * pActList, const DateRange * pPeriod, PPIDArray & rObjList);
	int    GetObjRemovingEventListByPeriod(PPID objType, PPID userID, const DateRange * pPeriod, TSVector <SysJournalTbl::Rec> & rList);
	int    GetUpdatedConfigListSince(PPID cfgType, const LDATETIME & rSince, PPIDArray & rCfgIdList);
	int    IsEventExists(PPID objType, PPID objID, PPID userID, const PPIDArray * pActList);
	int    CheckObjForFilt(PPID objType, PPID objID, const SysJournalFilt * pFilt);
	int    DoMaintain(LDATE toDt, int recover, PPLogger * pLogger);
	void   Subst(SubstGrpSysJournal sgsj, PPID opID, PPID prmrID, PPID scndID, PPID * pID);
	void   GetSubstName(SubstGrpSysJournal sgsj, PPID id, char * pBuf, size_t bufLen);
	void   GetSubstName(SubstGrpSysJournal sgsj, PPID id, SString & rBuf);
private:
	int    GetObjEventList(PPID objType, PPID objID, const PPIDArray * pActList, SArray * pResultList);
	SjRsrvTbl * P_RsrvT;
	//
	// Что бы при ошибке регистрации события не тратить лишнее время на формирования сообщений журнала
	// используем постоянные буферы.
	//
	SString FmtBuf;
	SString MsgBuf;
	SString AddedBuf;
	SString TempBuf; // @allocreuse
};
//
// Класс ObjSync управляет синхронизацией объектов в распределенной БД
//
struct PPCommSyncID { // @persistent @size=6
	PPCommSyncID();
	PPCommSyncID(const PPCommSyncID & rS);
	explicit PPCommSyncID(const ObjSyncTbl::Rec & rRec);
	explicit PPCommSyncID(const ObjSyncQueueTbl::Rec & rRec);
	explicit PPCommSyncID(const TempSyncCmpTbl::Rec & rRec);
	int    FASTCALL operator == (const PPCommSyncID s) const;
	int    FASTCALL operator != (const PPCommSyncID s) const;
	bool   IsZero() const;
	PPCommSyncID & Z();
	PPCommSyncID FASTCALL operator = (const PPCommSyncID s);
	PPCommSyncID FASTCALL operator = (const ObjSyncTbl::Rec & rRec);
	PPCommSyncID FASTCALL operator = (const ObjSyncQueueTbl::Rec & rRec);
	PPCommSyncID FASTCALL operator = (const TempSyncCmpTbl::Rec & rRec);
	void   FASTCALL Get(ObjSyncTbl::Rec * pRec) const;
	void   FASTCALL Get(ObjSyncQueueTbl::Rec * pRec) const;
	void   FASTCALL Get(TempSyncCmpTbl::Rec * pRec) const;
	SString & ToStr(long fmt, SString &) const;
	int    FASTCALL FromStr(const char *);

	int16  P;
	int32  I;
};

struct ObjSyncIdent {
	int16  fComm;     // ObjID - is Common ID, otherwise - Private ID
	PPCommSyncID CommID;
	PPID   ObjType;
	PPID   ObjID;
	PPID   DBID;
};
//
// Флаги записей таблицы ObjSync
//
#define OBJSYNCF_DELETED 0x0001 // Объект, соответствующий записи, удален

class ObjSyncCore : public ObjSyncTbl {
public:
	ObjSyncCore();
	int    SearchPrivate(PPID objType, PPID id, PPID dbid, ObjSyncTbl::Rec * = 0);
	int    SearchCommon(PPID objType, PPCommSyncID id, PPID dbid, ObjSyncTbl::Rec * = 0);
	int    SearchSync(PPID obj, PPID privateID, PPID dbID, int foreign, ObjSyncTbl::Rec * pRec);
	int    GetSyncStatus(PPID objType, PPID privID, PPCommSyncID * pCommId, PPIDArray * pDbDivList);
	//
	// Descr: Возвращает список идентификаторов объектов в собственной базе данных, соответствующих
	//   чужому идентификатору foreignID. Предполагается, что вызывающая функция не знает какому
	//   разделу принадлежит foreignID.
	//
	int    GetPrivateObjectsByForeignID(PPID objType, PPID foreignID, PPIDArray * pPrivateIdList);
	int    Search(const ObjSyncIdent * pIdent, ObjSyncTbl::Rec * pRec);
	int    Remove_S(const ObjSyncIdent * pIdent, int use_ta);
	int    Update(const ObjSyncIdent *, const ObjSyncTbl::Rec * pRec, int use_ta);
	int    AddRawRecord(ObjSyncTbl::Rec * pRec, int use_ta);
	int    TransmitObj(PPObjID obj, PPCommSyncID * pCommID, int use_ta);
	int    SearchCommonObj(PPID, PPCommSyncID commID, PPID * pID, ObjSyncTbl::Rec * = 0);
	int    AckObj(PPID objType, PPID foreinID, PPCommSyncID commID, PPID dbid, const LDATETIME * pDtm, int use_ta);
	int    SelfSync(PPID obj, PPID id, PPID destDbID, int use_ta);
	int    RemoveByCommID(PPID objType, PPCommSyncID commID, PPID dbid, int use_ta);
	int    RemoveByPrivateID(PPID objType, PPID objID, int use_ta);
	int    _RcvObj(PPID obj, PPID id, PPCommSyncID commonID, PPID dbid, const LDATETIME * pDtm, int use_ta);
private:
	int    GetFreeCommonID(PPID, PPCommSyncID * pCommID);
};
//
//
//
class ObjSyncQueueCore : public ObjSyncQueueTbl {
public:
	struct FileInfo {
		FileInfo();
		long   QueueID;        // Идентификатор записи о файле в очереди
		SString InnerFileName; // Имя внутреннего файла (возможно, с путем)
		SString OrgFileName;   // Имя оригинального файла (возможно, с путем)
		LDATETIME Mod;         // Время модификации файла OrgFileName
		SVerT  Ver;           // Версия системы, создавшая OrgFileName
		long    Flags;         // Флаги из заголовка OrgFileName
	};
	ObjSyncQueueCore();
	int    Search(PPID queueID, ObjSyncQueueTbl::Rec * pRec);
	int    SearchObject_(PPID objType, PPID objID, PPID dbID, ObjSyncQueueTbl::Rec * pRec);
	//
	// Descr: Возвращает список идентификаторов записей, содержащих информацию о необработанных объектах.
	// Returns:
	//   >0 - есть по крайней мере один необработанный объект
	//   <0 - нет ни одного необработанного объекта
	//    0 - error
	//
	int    GetUnprocessedList(PPIDArray * pList);
	int    AddFileRecord(PPID * pID, const ObjSyncQueueCore::FileInfo & rInfo, int use_ta);
	int    GetFileRecord(PPID id, ObjSyncQueueCore::FileInfo & rInfo);
	int    SearchRefToOrgFile(const char * pFileName, ObjSyncQueueCore::FileInfo * pInfo);
	int    MarkAsProcessed(PPID queueID, PPID primaryID, int use_ta);
	//
	// Descr: Полностью очищает очередь приема объектов и удаляет файлы из
	//   каталога очереди
	// Returns:
	//   !0 - функция успешно выполнена
	//   0  - ошибка
	//
	int    Clear();
	//
	// Descr: Отладочная функция, выводящая в журнал информацию об объектах типа objType в очереди.
	//
	int    PrintDebugObjList(PPID objType);
};
//
// Специальные серии (брак, ...)
//
#define SPCSERIK_SPOILAGE 1L

#define SPCSELIF_FALSIFICATION 0x00000001L // Товар фальсифицирован
#define SPCSELIF_ALLOW         0x00000002L // Товар разрешен к продаже
//
// Идентификаторы строковых полей, хранящихся в хвостовой части записи SpecSeries2Tbl
//
#define SPCSNEXSTR_GOODSNAME        1 // Текстовое наименование товара (может отличаться от GoodsID.Name)
#define SPCSNEXSTR_MANUFNAME        2 // Текстовое наименование производителя (может отличаться от ManufID.Name)
#define SPCSNEXSTR_LABNAME          3 // Текстовое наименование лаборатории, осущетсвлявшей анализ
#define SPCSNEXSTR_MANUFCOUNTRYNAME 4 // Текстовое наименование страны происхождения (может отличаться от ManufCountryID.Name)
#define SPCSNEXSTR_DESCRIPTION      5 // Текстовое описание серии (характер дефекта и т.д.)

class SpecSeriesCore : public SpecSeries2Tbl {
public:
	static int GetExField(const SpecSeries2Tbl::Rec * pRec, int fldId, SString & rBuf);
	static int SetExField(SpecSeries2Tbl::Rec * pRec, int fldId, const char * pBuf);
	SpecSeriesCore();
	int    Search(PPID id, SpecSeries2Tbl::Rec *);
	int    Put(PPID * pID, SpecSeries2Tbl::Rec *, int use_ta);
	int    ClearAll();
	int    SearchBySerial(PPID infoKind, const char * pBuf, SpecSeries2Tbl::Rec * = 0);
	int    GetListBySerial(PPID kind, const char * pSerial, StrAssocArray * pList);
};
//
// Descr: Вектор занятости процессора
//
struct PrcBusy : public STimeChunk {
	void   Init(const LDATETIME &, const LDATETIME &, int status, int idle = 0);
	void   Init(const LDATETIME &, long cont, int status, int idle = 0);
	//
	// Descr: Находит пересечение векторов *this и rTest.
	// ARG(rTest    IN): Вектор, на пересечение с которым проверяется *this.
	// ARG(pResult OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается //
	//   результат пересечения *this и rTest.
	// Returns:
	//   !0 - вектора *this и rTest пересекаются //
	//   0  - вектора *this и rTest не пересекаются //
	//
	int    Intersect(const PrcBusy & rTest, PrcBusy * pResult) const;

	PPID   TSessID; // ИД сессии, которая занимает процессор в это время //
	int16  Status;  // PPSESST_XXX
	int16  Idle;    // Если !0 - период простоя //
};

class PrcBusyArray : public STimeChunkArray {
public:
	PrcBusyArray();
	int    Add(const PrcBusy &, int checkForFree);
	int    IsFreeEntry(const PrcBusy & entry, PPID * pTSessID) const;
	int    IsFreeEntry(const LDATETIME &, long cont, PPID * pTSessID) const;
	//
	// Descr: Получает список доступных периодов процессора
	//   До вызова этой функции массив this должен быть отсортирован функцией PrcBusyArray::Sort.
	//
	int    GetFreeList(PrcBusyArray * pList) const;
};
//
// Технологические сессии
// Класс, управляющий таблицами технологических сессий.
//
struct TSessGoodsTotal {
	TSessGoodsTotal();
	long   Count;
	double Qtty;
	double PhQtty;
	double Amount;
};

class TSessLineCore : public TSessLineTbl {
public:
	PPTblEnumList EnumList;
};

class TSessionCore : public TSessionTbl {
public:
	friend class PPTblEnum <TSessLineCore>;

	TSessionCore();
	int    Search(PPID id, TSessionTbl::Rec * pRec);
	int    SearchByPrcTime(PPID prcID, int kind, const LDATETIME & rDtm, TSessionTbl::Rec * pRec);
	//
	// Descr: Флаги функции GetChildIDList
	//
	enum {
		gclfSubSess   = 0x0001,
		gclfRecursive = 0x0002
	};
	//
	// Descr: возвращает список дочерних по отношению к superSessID сессий
	//   (rec.ParentID == superSessID).
	//   Массив pList предварительно не очищается.
	//   Новые элементы добавляются функцией pList->addUnique - то есть,
	//   вызов этой функции не приведет к появлению в массиве дублируемых элементов.
	//   Если pList == 0, то функция отработает корректно, специф Returns остается в силе.
	// Returns:
	//   >0 - найдена как минимум одна дочерняя сесси
	//   <0 - не найдено ни одной дочерней сессии
	//   0  - ошибка
	//
	int    GetChildIDList(PPID superSessID, long flags, PPIDArray * pList);
	int    SearchLine(PPID sessID, long oprNo, TSessLineTbl::Rec *);
		// @>>TSessionCore::SearchOprNo
	int    SearchLineByTime(PPID sessID, const LDATETIME & rDtm, TSessLineTbl::Rec *);
	//
	//
	//
	enum {
		sserLast = 0x0001, // Брать только самую последнюю строку
		sserRest = 0x0002  // Брать только строки остатков
	};
	int    SearchSerial(const char * pSerial, PPID sessID, int sign, long flags, TSessLineTbl::Rec * pRec);
	//
	// Descr: ищет первую (в хронологическом порядке) работающую сессию
	//   (Status == TSESST_INPROCESS) на процессоре prcID.
	//   Если параметр kind == TSESK_IDLE, то ищет сессию простоя,
	//   если kind == TSESK_PLAN, то ищет сессию плана,
	//   в противном случае ищет обычную активную сессию.
	// Returns:
	//   <0 - работающих сессий на процессоре prcID нет
	//   >0 - найдена работающая сессия на процессоре prcID. В буфер pRec
	//        копируется запись найденной сессии
	//   0  - ошибка
	// Remark: спецификация не допускает существование одновременно двух
	//   или более работющих сессий на одном процессоре.
	//
	int    GetProcessed(PPID prcID, int kind, TSessionTbl::Rec * pRec);
	void   InitPrcEntry(const TSessionTbl::Rec & rRec, PrcBusy & rEntry) const;
	//
	// Descr: Заполняет список периодов, в течении которых процессор prcID занят.
	//   При нахождении этого списка пропускаются техн сессии со статусом TSESST_CANCELED.
	// ARG(prcID      IN): ИД процессора, для которого заполняется список периодов занятости
	// ARG(exclTSesID IN): ИД сессии, которую не следует принимать во внимание. Если вызывающая //
	//   функция хочет определить допустимый диапазон для какао-либо сессии, то ИД этой сессии
	//   следует передать этим параметром.
	// ARG(kind       IN): @#{TSESK_SESSION || TSESK_PLAN || TSESK_IDLE} Вид сессий, которые
	//   необходимо рассматривать при заполнении массива. Система допускает пересечение обычных
	//   сессий с сессиями простоя и с сессиями плана. В тоже время сессии одного вида друг с другом
	//   пересекаться не могут.
	// ARG(pPeriod    IN): @#{vptr0} Указатель на период, которым должен быть ограничен загружаемый
	//   массив. Если какой-либо элемент массива пересекает границу периода, то его продолжительности
	//   обрезается по границе этого периода.
	// ARG(pList     OUT): Указатель на массив, в который функция заносит периоды занятости.
	// Returns:
	//   >0 - функция успешно выполнена
	//   0  - ошибка
	//
	int    LoadBusyArray(PPID prcID, PPID exclTSesID, int kind, const STimeChunk * pPeriod, PrcBusyArray * pList);
		// @<<TSessionCore::InitPrcEntry
	//
	// Descr: Опции функции TSessionCore::Put_
	//
	enum {
		putfSkipSjRegistration = 0x0001
	};
	int    Put_(PPID * pID, TSessionTbl::Rec * pRec, long options, int use_ta);
	int    UpdateFlags(PPID id, long setF, long resetF, int use_ta);
	int    UpdateSuperSessCompleteness(PPID sessID, int use_ta);
	int    AdjustLineTime(TSessLineTbl::Rec * pRec);
	int    InitLineEnum(PPID sessID, long * pHandle);
	int    InitLineEnumBySerial(const char * pSerial, int sign, long * pHandle);
	//
	// Descr: Вызов с параметром pRec == 0 разрушает итератор с хандлером enumHandle
	//
	int    NextLineEnum(long enumHandle, TSessLineTbl::Rec * pRec);
	int    DestroyIter(long enumHandle);
	SEnum::Imp * EnumLines(PPID sessID);
	SEnum::Imp * EnumLinesBySerial(const char * pSerial, int sign);
	//
	// Descr: Подсчитывает итоги по технологической сессии sessID.
	//   Если параметр goodsID != 0, то подсчитывает итоги только по строкам, соответствующим этому товару.
	//   Если goodsID ялвяется обобщенным товаром либо группой, то суммирование ведется по строкам,
	//   товар в которых относится к этому обобщению либо группе.
	//
	int    CalcGoodsTotal(PPID sessID, PPID goodsID, TSessGoodsTotal * pTotal);
	int    SearchOprNo(PPID sessID, long * pOprNo, TSessLineTbl::Rec *);
	int    SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	//
	// Descr: Заменяет все ссылки на статью dest ссылками на статью src.
	// @attension Функция выполняется без транзакции.
	// Returns:
	//   >0 - найдена и заменена по крайней мере одна ссылка
	//   <0 - не найдено ни одной ссылки на статью dest
	//   0  - ошибка
	//
	int    ReplaceArticle(PPID dest, PPID src);
	//
	// Descr: Заменяет все ссылки на товар dest ссылками на товар src.
	// @attension Функция выполняется без транзакции.
	// Returns:
	//   >0 - найдена и заменена по крайней мере одна ссылка
	//   <0 - не найдено ни одной ссылки на товар dest
	//   0  - ошибка
	//
	int    ReplaceGoods(PPID dest, PPID src);

	TSessLineCore Lines;
private:
	int    SearchSessNumber(PPID prcID, long * pNumber, TSessionTbl::Rec * pRec);
	//
	// Descr: Если pRec->StDt == 0, то увеличивает время pRec->StTm на одну сотую секунды
	//   до тех пор, пока запись не станет уникальной по ключу {PrcID, StDt, StTm}.
	//   Это необъодимо, поскольку pRec->StDt == 0 является признаком неопределенности времени
	//   начала работы сессии. Следовательно проверка на уникальность ключа {PrcID, StDt, StTm}
	//   становится избыточной.
	// ARG(pRec IN/OUT): @#{vptr} указатель на запись перед добавлением ее в таблицу.
	// Returns:
	//   >0 - Поле pRec->StTm было изменено
	//   <0 - Функция не изменила состояния записи pRec
	//   0  - Ошибка
	// @attention: при массовом добавлении записей в таблицу (BExtInsert)
	//   эта функция не поможет: вероятно возникновение ошибки "Дублирование значения индекса"
	//
	int    AdjustTime(TSessionTbl::Rec * pRec);
		// @<<TSessionCore::Put
	int    Helper_GetChildIDList(PPID superSessID, long flags, PPIDArray * pList);
};
//
// Управление задачами
//
//
// Виды записей таблицы PrjTask (PrjTaskTbl::Rec.Kind)
//
#define TODOKIND_TASK        1 // Собственно задача
#define TODOKIND_TEMPLATE    2 // Шаблон задач
//
// Приоритеты задач (PrjTaskTbl::Rec.Priority)
// Строки соответствий: {PPSTR_TEXT; PPTXT_TODO_PRIOR}
//
#define TODOPRIOR_HIGHEST    1 // Максимальный
#define TODOPRIOR_HIGH       2 // Высокий
#define TODOPRIOR_NORMAL     3 // Нормальный
#define TODOPRIOR_LOW        4 // Низкий
#define TODOPRIOR_LOWEST     5 // Минимальный
//
// Статусы задач (PrjTaskTbl::Rec.Status)
// Строки соответствий для задач:    {PPSTR_TEXT; PPTXT_TODO_STATUS}
// Строки соответствий для шаблонов: {PPSTR_TEXT; PPTXT_TODOTEMPL_STATUS}
//
#define TODOSTTS_NEW         1 // Новая       (для шаблона - нормальный)//
#define TODOSTTS_REJECTED    2 // Отменена    (для шаблона - отменен)   //
#define TODOSTTS_INPROGRESS  3 // Выполняется (для шаблона не используется) //
#define TODOSTTS_ONHOLD      4 // В ожидании  (для шаблона не используется) //
#define TODOSTTS_COMPLETED   5 // Завершена   (для шаблона не используется) //

class PrjTaskCore : public PrjTaskTbl {
public:
	friend class PPTblEnum <PrjTaskCore>;

	static int FASTCALL IsValidStatus(int s);
	static int FASTCALL IsValidPrior(int p);

	PrjTaskCore();
	int    Search(PPID id, PrjTaskTbl::Rec * pRec);
	SEnum::Imp * EnumByClient(PPID cliPersonID, const DateRange * pPeriod, int options);
	SEnum::Imp * EnumByEmployer(PPID emplPersonID, const DateRange * pPeriod, int options);
	int    SearchByTime(const LDATETIME &, PPID * pID, PrjTaskTbl::Rec *);
	int    SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	int    ReplaceRefs(PPID objType, PPID replacedID, PPID newID, int use_ta);
	//
	// Descr: Ищет первую запись, сформированную по шаблону tempID и
	//   имеющую дату начала работ startDt
	//
	int    SearchByTemplate(PPID templID, LDATE startDate, PrjTaskTbl::Rec *);
	int    GetSingleByCode(long kind, const char * pCode, PPID * pID);
	int    Add(PPID * pID, PrjTaskTbl::Rec *, int use_ta);
	int    Update(PPID id, PrjTaskTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет статус задачи id на значение newStatus.
	// Returns:
	//   >0 - Статус задачи успешно изменен
	//   <0 - Задача id уже имеет статус newStatus - ничего не изменилось
	//   0  - Ошибка
	//
	int    UpdateStatus(PPID id, int newStatus, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    RemoveByProject(PPID prjID, int use_ta);
private:
	BExtQuery * StartupEnumQuery(int idx, int options);
	int    NextEnum(long enumHandle, PrjTaskTbl::Rec * pRec);
	int    DestroyIter(long enumHandle);

	PPTblEnumList EnumList;
};
//
// PredictSalesCore
//
// Максимальные значения параметров модели
//
#define MAX_ARMA_P 30
#define MAX_ARMA_Q 30
//
// Флаги записей таблицы PredictSalesTbl
//
#define PRSALF_ZERO     0x0001 // Нулевое значение
#define PRSALF_HOLE     0x0002 // Отсутствует реальная информация о продажах
//
// Типы записей таблицы PredictSalesTbl (RType)
//
#define PSRECTYPE_DAY        1 // Дневные продажи
#define PSRECTYPE_AVERAGE    2
#define PSRECTYPE_LAST_DAY   5 // Последний заполненный день
#define PSRECTYPE_LOCTAB     6 // Элемент таблицы соответствия склад-индекс
#define PSRECTYPE_HOLIDAY    7 // Запись соответствует выходному дню. GoodsID == 0, Quantity == 0, Amt == 0.
//
// Так как таблица PredictSalesTbl содержит очень много записей, для снижения размера
// файла и ускорения доступа к данным используются следующие трюки:
// 1. Идентификаторы складов заменяются на двухбайтовые индексы в таблице складов.
//    Эта таблица хранится в виде записей с типом PSRECTYPE_LOCTAB (6).
//    Для преобразования идентификатора склада в его индекс используется функция ShinkLoc
//    Для обратного преобразования - ExpandLoc
// 2. Даты хранятся в виде смещения в днях от 31/12/1995.
//    Для преобразования даты в смещение используется функция ShrinkDate
//    Для обратного преобразования - ExpandDate
//
struct PredictSalesItem {
	PredictSalesItem();
	LDATE  Dt;
	double Qtty;
	double Amount;
};

class PsiArray : public TSVector <PredictSalesItem> {
public:
	PsiArray();
	int    Add(const PredictSalesItem *);
	int    ShrinkByCycleList(const PPCycleArray *, PsiArray *) const;
};
//
// Параметр pssValType, передаваемый в функции расчета значений PredictSalesStat::xxx()
//
#define PSSV_QTTY            1 // Рассчитать значение в количественных терминах
#define PSSV_AMT             2 // Рассчитать значение в суммовых терминах

#define PSSF_USELSSLIN  0x0001 // Рассчитывать параметры линейной аппроксимации

struct PredictSalesStat {
	PredictSalesStat(PPID coeffQkID = 0, const PPQuotArray * pCoeffQList = 0);
	~PredictSalesStat();
	PredictSalesStat & FASTCALL operator = (const PredictSalesStat &);
	void   Init();
	int    FASTCALL Step(const PredictSalesItem *);
	int    Step(const PsiArray *, const DateRange * = 0);
	int    Finish();
	//
	// Descr: Возвращает среднее арифметическое продаж товара
	//
	double FASTCALL GetAverage(int pssValType) const;
	//
	// Descr: Возвращает стандартное отклонение продаж товара
	//
	double FASTCALL GetSigma(int pssValType) const;
	//
	// Descr: Возвращает коэффициент вариации продаж товара
	//
	double FASTCALL GetVar(int pssValType) const;
	//
	// Descr: Возвращает оборачиваемость товара в днях (1 / GetAverage(int pssValType))
	//
	double FASTCALL GetTrnovr(int pssValType) const;
	double Predict(int pssValType, LDATE, double * pYErr) const;

	PPID   LocID;          // @anchor
	PPID   GoodsID;
	LDATE  LastDate;
	LDATE  FirstPointDate; //
	long   Count;
	double QttySum;
	double QttySqSum;
	double AmtSum;
	double AmtSqSum;
	LssLin QttyLss;        // Параметры линейной аппроксимации по количеству
	LssLin AmtLss;         // Параметры линейной аппроксимации по сумме
	long   Flags;          // @anchor PSSF_XXX
private:
	struct LsEntry { // @flat
		int16  Day;
		int16  Reserve; // @alignment
		double Qtty;
		double Amt;
	};
	const  PPID  CoeffQkID;            //
	const  PPQuotArray * P_CoeffQList; // @notowned
	SVector * P_List;
};

typedef int (FASTCALL * EnumPredictSalesProc)(PredictSalesItem *, void * extraPtr);

class PredictSalesCore : public PredictSalesTbl, public PPHolidays {
public:
	PredictSalesCore();
	~PredictSalesCore();
	//int    MakeSalesRec(PPID locID, PPID goodsID, LDATE dt, double qtty, double amount, PredictSalesTbl::Rec * pRec);
	int    Remove(const PredictSalesTbl::Rec * pRec);
	int    SetValue(PPID locID, PPID goodsID, LDATE dt, double qtty, double amount);
	virtual int IsHoliday(const ObjIdListFilt * pLocList, LDATE);
	virtual int EnumHolidays(PPID locID, LDATE *);
	int    IsHoliday(PPID locID, LDATE dt) const;
	int    IsHolidayByLocIdx(int16 locIdx, LDATE dt) const;
	//
	// После одного или нескольких вызовов одной из следующих трех функций следует
	// вызвать Finish() для сохранения изменений в базе данных.
	//
	virtual int SetHoliday(PPID locID, LDATE, int rmv = 0);
	int    SetWeekdayAsHoliday(PPID locID, int dayOfWeek, int rmv = 0);
	int    SetDayOfYearAsHoliday(PPID locID, int day, int month, int rmv = 0);
	int    ClearHolidays();
	//
	// Пара функция SaveHolidays и RestoreHolidays используется при заполнении таблицы
	// продаж. С целью временной идентификации дней, в которых не было документов как выходных.
	// При использовании таблицы для прогнозирования такие дни, поскольку они были в прошлом,
	// не учитываются.
	//
	int    SaveHolidays();
	int    RestoreHolidays();
	//
	// Descr: Удаляет все содержимое таблиц PredictSales и GoodsStat
	//
	int    ClearAll();
	int    ClearByPeriod(DateRange period, PPID gGrpID, int use_ta);
	//
	// Descr: Завершает обновление таблицы.
	//
	int    Finish(int locTabOnly, int use_ta);
	int    SearchItem(int recType, PPID locID, PPID goodsID, LDATE, void * = 0);
	//
	// Descr: Функция оптимизированного перебора записей таблицы. На каждую найденную запись
	//   вызывается процедура proc со структурой PredictSalesItem и параметром extraParam.
	// ARG(locID      IN): ИД склада, по которому осуществляется поиск. Если locID < 0, тогда
	//   функция вызывается рекурсивно для всех складов по которым
	//   сформирована хотя бы одна запись в таблице.
	// ARG(goodsID    IN): ИД товара, по которому осуществляется поиск.
	// ARG(pPeriod    IN): Период, в который должны попадать найденные записи.
	//   Если pPeriod == 0, то выбираются записи независимо от даты.
	// ARG(maxItems   IN): Максимальное количество элементов, которые необходимо получить.
	//   Если maxItems < 0, то перебор начинается с более поздних дат, во всех остальных
	//   случаях перебор идет по возрастанию дат. Если maxItems != 0 и locID < 0, функция //
	//   вызывается рекурсивно для каждого склада. В связи с этим фактически может быть
	//   возвращено значительно больше записей, чем |maxItems|. В этом случае вызывающая  //
	//   функция должна будет самостоятельно разобраться с полученными значениями.
	// ARG(proc       IN): Callback-процедура, вызываемая для каждой найденной записи. Процедура имеет
	//   два параметра: указатель на структуру PredictSalesItem и extraParam,
	//   переданный изначально функции Enumerate в виде одноименного параметра.
	//   Реакция функции Enumerate на значение, возвращаемое из proc:
	//     > 0 - продолжает работу
	//     <= 0 - завершает работу и возвращает значение, возвращенное процедурой proc
	// ARG(extraPtr IN): Произвольный параметр, передаваемый функцией Enumerate callback-процедуре proc.
	//
	int    Enumerate(PPID goodsID, const ObjIdListFilt & rLocList, const DateRange * pPeriod, int maxItems, EnumPredictSalesProc proc, void * extraPtr);
	void   FASTCALL GetLocList(PPIDArray & rList) const;
	//
	// Descr: Удаляет все записи по складу locID и товару goodsID за период pPeriod.
	//   Если locID < 0, то удаляются записи по всем складам, зарегистрированным в таблице P_LocTab.
	//
	int    RemovePeriod(PPID locID, PPID goodsID, const DateRange * pPeriod, int use_ta);
	int    GetFirstDate(PPID locID, PPID goodsID, LDATE *);
	int    GetPeriod(const ObjIdListFilt * pLocList, PPID goodsID, DateRange *);
	int    GetPeriod(const ObjIdListFilt * pLocList, const PPIDArray * pGoodsList, DateRange *);
	int    GetTblUpdateDt(LDATE *);
	int    SetTblUpdateDt(LDATE);
	//
	// Descr: Рассчитывает статистику товара на складе locID по таблице PredictSales
	//
	int    CalcStat(PPID goodsID, const ObjIdListFilt & rLocList, const DateRange *, int maxItems, PredictSalesStat *);
	int    CalcStat(const PPIDArray & rGoodsIdList, const ObjIdListFilt rLocList, const DateRange * pPeriod, PredictSalesStat * pStat);
	int    GetSeries(const PPIDArray & rGoodsIDList, const ObjIdListFilt & rLocList, const DateRange * pPeriod, PsiArray * pList);
	//
	// Извлекает статистику по товару goodsID на складе locID из таблицы GoodsStat
	//
	int    GetStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);
	int    GetLastUpdate(PPID goodsID, const ObjIdListFilt & rLocList, LDATE * pLastDate);
	//
	// Descr: хранит максимальную ошибку, возникающую из за различных
	//  форматов хранения данных в таблице базы данных.
	//
	struct StatStoreErr {
		long   Count;
		double QttySum;
		double QttySqSum;
		double AmtSum;
		double AmtSqSum;
	};
	int    StoreStatByGoodsList(const PPIDArray & rGoodsList, LDATE commonLastDate, StatStoreErr * pErr, int use_ta);
		// @<<PrcssrPrediction::ProcessGoods
	//
	// Descr: Проверяет соответствие таблиц данных текущей версии системы.
	//
	int    CheckTableStruct();
	static int FASTCALL ShrinkDate(LDATE dt, int16 * pSDt);
	static int FASTCALL ExpandDate(int16 sdt, LDATE * pDt);
	int    AddLocEntry(PPID locID, int16 * pLocIdx);
	int    FASTCALL ShrinkLoc(PPID locID, int16 * pLocIdx) const;
	int    FASTCALL ExpandLoc(int16 locIdx, PPID * pLocID);
	void * SetKey(PredictSalesTbl::Key0 *, int typ, PPID locID, PPID goodsID, LDATE);

	GoodsStatTbl StT;
private:
	struct LocTabEntry { // @flat
		PPID   LocID;
		int16  LocIdx;
	};
	struct HldTabEntry { // @flat
		int16  LocIdx;
		int16  Day;
	};
	//
	// Descr: Добавляет продажи по товару goodsID на складе locID на дату dt.
	// Returns:
	//   1 - запись успешно добавлена
	//   2 - запись с таким ключом уже существовала, но была изменена
	//   0 - error
	//
	int    AddItem(long typ, PPID locID, PPID goodsID, LDATE dt, double qtty, double amount, long f);
	int    WriteLocTab(int use_ta);
	int    ReadLocTab();
	int    WriteHolidays(int use_ta);
	int    ReadHolidays();
	int    SearchHoliday(int16 locIdx, int16 day, uint * pPos) const;
	int    FASTCALL SearchHoliday(HldTabEntry) const;
	int    SetHldEntry(const HldTabEntry *, int rmv);
	int    ShrinkHoliday(LDATE, int16 *);
	int    ExpandHoliday(int16, LDATE *);
	int    SearchStat(PPID goodsID, PPID locID, GoodsStatTbl::Rec * pRec);
	int    SearchStat(PPID goodsID, const ObjIdListFilt & rLocList, GoodsStatTbl::Rec * pRec);
	int    Helper_Enumerate(PPID goodsID, PPID locID, const DateRange * pPeriod, int maxItems, EnumPredictSalesProc proc, void * extraPtr);

	TSVector <LocTabEntry> LocTab;
	int    IsLocTabUpdated;
	int    IsHldTabUpdated;
	//
	// Descr: Таблица P_HldTab содержит записи выходных дней по каждому складу.
	//   Если запись имеет индекс склада равный нулю, то соответствующий ей выходной
	//   соответствует всем складам.
	//   Записи, содержащие индекс дня меньший нуля и больший -100, относятся к дням недели.
	//   Например запись {3, -6} означает, что склад с индексом (не идентификатором) 3 имеет
	//   выходной день субботу.
	//   Записи, содержащии индекс дня меньший или равный -100, относятся к датам, не
	//   зависящим от года. Например {2, -101} означает, что склад с индексом 2 имеет
	//   выходной 2 января во все года.
	//   Алгорим выяснения является ли некоторый день выходным следующий:
	//   1. Ищется запись {склад, дата}
	//   2. Если предыдущий пункт не привел к успеху, то ищется запись {склад, -день недели}
	//   3. Если предыдущий пункт не привел к успеху, то ищется запись {склад, -(день/месяц/1996)-100}
	//   4. Если предыдущий пункт не привел к успеху, то ищется запись {0, дата}
	//   5. Если предыдущий пункт не привел к успеху, то ищется запись {0, -день недели}
	//   6. Если предыдущий пункт не привел к успеху, то ищется запись {0, -(день/месяц/1996)-100}
	//   7. Если предыдущий пункт не привел к успеху, заданный день - рабочий
	//
	SVector * P_HldTab;
	SVector * P_SaveHldTab;
};
//
// Descr: Флаги операция по персональным картам
//
#define SCARDOPF_FREEZING      0x0004 // Операция приостановки действия карты
#define SCARDOPF_NOTIFYSENDED  0x0008 // Связанному с картой контрагенту отправлено уведомление об операции (флаг нужен во избежании повторной рассылки)
#define SCARDOPF_LEVELING      0x0010 // Технологическая операция выравнивания остатка по карте

class SCardCore : public SCardTbl {
public:
	//
	// Descr: Структура, определяющая операцию по кредитной карте.
	//
	struct OpBlock { // @flat
		static int CheckFreezingPeriod(const DateRange & rPeriod, LDATE expiry);

		OpBlock();
		OpBlock & Init(SCardOpTbl::Rec * pRec = 0);
		int    CheckFreezingPeriod(LDATE expiry) const;

		enum {
			fEdit     = 0x0001, // @transient Признак операции, уже отраженной в БД. Для такой
				// операции недопустимо изменене даты/времени и установка карты-приемника (DestSCardID)
			fRemove   = 0x0002, // @transient Признак требования удалить записи
			fFreezing = 0x0004, // @persistent Операция приостановки действия карты
			fLeveling = 0x0008  // @persistent Специальная операция выравнивания остатка по карте
		};
		PPID   SCardID;
		PPID   DestSCardID;
		PPObjID LinkOi;
		LDATETIME Dtm;
		DateRange FreezingPeriod;
		long   Flags;
		PPID   CtGoodsID;    // @v12.0.6 Если по карте действует количественный учет, то здесь - операционный идентификатор товара
		double Amount;
		long   CtAmount;     // @v12.0.6 Если по карте действует количественный учет, то здесь - операционное количество 
		double PrevRest;     // @*SCardCore::GetOp() Остаток по карте SCardID перед операцией (Flags & fEdit)
		double PrevDestRest; // @*SCardCore::GetOp() Остаток по карте DestSCardID перед операцией (Flags & fEdit)
		long   PrevCtRest;   // @v12.0.6 Если по карте действует количественный учет, то здесь - остаток по карте SCardID перед операцией
		long   PrevDestCtRest; // @v12.0.6 Если по карте действует количественный учет, то здесь - остаток по карте DestSCardID перед операцией
	};
	//
	struct UpdateRestNotifyEntry { // @flat
		PPID   SCardID;
		LDATETIME OpDtm;
		double PrevRest;
		double NewRest;
	};
	//
	// Descr: Определяет диапазон префиксов карт, которые могут быть сгенерированы
	//   по шаблону pTemplate.
	//
	static int GetCodeRange(const char * pTemplate, SString & rLow, SString & rUpp);
	SCardCore();
	int    Search(PPID, SCardTbl::Rec * = 0);
	int    SearchCode(PPID seriesID, const char * pCode, SCardTbl::Rec *);
	//
	// Descr: Находит все карты, имеющие код pCode. Как правило, в базе данных есть только одна или ни одной
	//   карты с заданным кодом. Однако, если не применяется правило сквозной уникальности номеров карт,
	//   то возможно (не ошибочное, но намеренное) существование более одной карты с заданным номером.
	// Returns:
	//   -1 - не найдено ни одной карты с номером pCode
	//   >0 - количество карт, имеющих код pCode
	//    0 - error. Если возинк сбой при чтении из таблицы, но найдена одна или более
	//       записей, то все равно будет возвращен 0, но в массив pList (если pList != 0) будут занесены
	//       все найденные идентификаторы.
	//
	int    GetListByCode(const char * pCode, PPIDArray * pList);
	//
	// Descr: Находит все карты, связанные с персоналией personID. Если seriesID != 0, то
	//   ищет только те карты, которые принадлежат серии seriesID.
	// Note: Результирующий список pList не очищается при вызове функции, таким образом,
	//   идентификаторы найденных карт будут добавлены в конец списка.
	//
	int    GetListByPerson(PPID personID, PPID seriesID, PPIDArray * pList);
	int    GetListByLoc(PPID locID, PPID seriesID, PPIDArray * pList);
	int    GetListByText(int textFldId, const char * pKey, PPIDArray * pList);
	int    AutoFill(const PPSCardSerPacket & rScsPack, const char * pPattern, int use_ta);
	int    SearchOp(PPID cardID, LDATE, LTIME, SCardOpTbl::Rec * pRec);
	int    SearchOpByLinkObj(PPID objType, PPID objID, SCardOpTbl::Rec * pRec);
	//
	// Descr: Находит последнюю операцию по карте cardID на дату, предшествующую dt.
	//   Если dt == 0, тогда находит абсолютно последнюю операцию.
	// Returns:
	//  >0 - searching is successfull
	//  <0 - nothing found
	//  0  - error
	//
	int    GetLastOpByCard(PPID cardID, LDATE dt, SCardOpTbl::Rec *);
	int    EnumOpByCard(PPID cardID, LDATETIME *, SCardOpTbl::Rec *);
	int    PutOpByBill(PPID billID, PPID scardID, LDATE dt, double amount, int use_ta);
	int    PutOpRec(const SCardOpTbl::Rec * pRec, TSVector <UpdateRestNotifyEntry> * pNotifyList, int use_ta);
	int    GetOp(PPID cardID, const LDATETIME & rDtm, OpBlock * pBlk);
	int    PutOpBlk(const OpBlock & rBlk, TSVector <UpdateRestNotifyEntry> * pNotifyList, int use_ta);
	int    GetOpByLinkObj(PPObjID oid, TSVector <OpBlock> & rList);
	int    GetFreezingOpList(PPID cardID, TSVector <OpBlock> & rList);
	int    RemoveOp(PPID cardID, LDATE, LTIME, int use_ta);
	int    RemoveOpByLinkObj(PPID objType, PPID objID, int use_ta);
	int    RemoveOpAll(PPID cardID, int use_ta);
	int    RecalcForwardRests(PPID cardID, LDATE, LTIME, double * pRest, int use_ta);
	int    RecalcRests(PPID cardID, double * pRest, int use_ta);
	//
	// Descr: Возвращает остаток по кредитной карте на дату dt. Если dt == ZERODATE или dt == MAXDATE,
	//   то возвращается текущий остаток по карте.
	//
	int    GetRest(PPID cardID, LDATE dt, double * pRest);
	int    Update(PPID id, SCardCore::Rec * pRec, int useTa);
	int    UpdateDiscount(PPID, double discount, int use_ta);
	int    AddTurnover(PPID, double add, int use_ta);
	int    AddTurnover_Test(PPID id, double add, int use_ta); // @test
	int    RecalcRestsBySeries(PPID serID, int use_ta);
	int    MakeCodeByTemplate(PPID seriesID, const char * pPattern, SString & rCode);

	struct PrefixRange {
		uint   Len;
        SString Low;
        SString Upp;
	};

	int    GetPrefixRanges(PPID seriesID, uint maxLen, TSCollection <PrefixRange> & rRanges);

	SCardOpTbl ScOp;
private:
	int    UpdateRest_(PPID scID, const LDATETIME * pOpDtm, double rest, TSVector <UpdateRestNotifyEntry> * pNotifyList, int use_ta);
	int    UpdateExpiryDelta(PPID id, long delta, int use_ta);
};
//
// Descr: Конфигурация оборудования //
//
struct PPEquipConfig { // @persistent @store(PropertyTbl)
	PPEquipConfig();
	PPID   GetCashierTabNumberRegTypeID() const;

	enum {
		fCheckScaleInput            = 0x00000001, // Сканировать весы при вводе документов
		fComplDeficit               = 0x00000002, // Компенсировать дефицит по кассовым сессиям за счет
			// комплектации недостающих товаров (для товаров, имеющих коплектуемую структуру)
		fCloseSessTo10Level         = 0x00000004, // Закрывать кассовые сессии до 10-го уровня //
		fIgnAcsReadyTags            = 0x00000008, // Не проверять признаки готовности асинхронных
			// кассовых машин к экспорту данных из Papyrus'а. Если этот флаг установлен,
			// то функция PPAsyncCashSession::OpenSession игнорирует результат вызова
			// функции PPAsyncCashSession::IsReadyForExport (но все равно вызывает ее).
		fIgnGenGoodsOnDeficit       = 0x00000010, // Не использовать обобщенные товары для компенсации дефицита по кассовым сессиям
		fUseQuotAsPrice             = 0x00000020, // Для определения цены на товар с приоритетом
			// используется базовая котировка. Если котировка для заданных условий не определена,
			// тогда используется учетная цена реализации. Если этот флаг не установлен, то
			// для определения цены всегда используется учетная цена реализации
		fIntrPriceByRetailRules     = 0x00000040, // При формировании драфт-документа покрытия   //
			// дефицита для другого склада, цену реализации рассчитывать по правилам определения //
			// розничной цены продажи для своего склада.
		fValidateChecksOnSessClose  = 0x00000080, // При закрытии асинхронной кассовой сессии проверять чеки.
		fWriteToChkOpJrnl           = 0x00000100, // Вести журнал чековых операций
		fRecognizeCode              = 0x00000200, // В кассовой панели распознавать назначение кода.
		fUnifiedPayment             = 0x00000400, // Унифицированный расчет в кассовой панели
		fIgnoreNoDisGoodsTag        = 0x00000800, // В кассовой панели игнорировать признак товара "Без скидки"
		fRestrictQttyByUnitRnd      = 0x00001000, // В кассовой панели ограничивать ввод количества
			// признаком целочисленности единицы измерения и ее параметром точности округления //
		fDisableManualSCardInput    = 0x00002000, // Запрет ввода номера дисконтной карты в ручную
		fUncondAsyncBasePrice       = 0x00004000, // Безусловная базовая цена для асинхронных узлов
		fDisableAdjWrOffAmount      = 0x00008000, // Запрет на корректировку суммы документов списания для уравнивания с кассовой сессией
		fUnifiedPaymentCfmBank      = 0x00010000, // Дополнительное подтверждение для оплаты по банку после унифицированной панели оплаты
		fAutosaveSyncChecks         = 0x00020000, // Автоматически сохранять синхронные чеки при каждом изменении
		fWrOffPartStrucs            = 0x00040000, // При списании кассовых сессий досписывать частичные структуры
		fSkipPrintingZeroPrice      = 0x00080000, // В кассовых чеках не печатать строки с нулевой суммой
		fAttachBillChecksToCSess    = 0x00100000, // При проведении чеков по документам привязывать эти чеки к текущей кассовой сессии
		fDisableSellSpoiledSeries   = 0x00200000, // @v11.1.8 Запрет выбора бракованной серии при продаже через кассовую панель
		fPreferBankingPayment       = 0x00400000, // @v12.1.10 При интерактивном выборе способа оплаты предпочтительной считать оплату банковской картой (by-default)
		fDontShowInfoPaneBeforXZRep = 0x00800000, // @v12.2.4 Не показывать информационную панель с отчетными суммами перед снятием Z- или X-отчета.
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_EQUIPCFG
	PPID   CshrsPsnKindID;  // Код вида персоналий - кассиры
	PPID   DefCashNodeID;   // Код кассового узла по умолчанию
	PPID   ScaleID_unused;  // Код весов // @v9.0.4 @unused (заменен на DefCashNode::ScaleID)
	long   Flags;           //
	PPID   OpOnDfctThisLoc; // Операция формирования документа по дефициту для своего склада
	PPID   OpOnDfctOthrLoc; // Операция формирования документа по дефициту для другого склада
	PPID   OpOnTempSess;    // Операция формирования документа по временным сессиям
	PPID   QuotKindID;      // Вид котировки
	//
	// Если AgentCodeLen && AgentPrefix[0] != 0, тогда в кассовой панели
	// ввод строки длиной AgentCodeLen начинающейся с AgentPrefix воспринимается //
	// как ввод агента.
	//
	// В противном случае код агента распознается по префиксу SAL
	//
	int16  AgentCodeLen;    // Длина кода агента.
	char   AgentPrefix[6];  // Префикс кода агента
	PPID   FtpAcctID;       // Ид ftp-аккаунта
	PPID   SalesGoodsGrp;   // Группа-папка содержащая группы продаж
	IntRange DeficitSubstPriceDevRange; // Диапазон отличия цены подстановки товара от фактической цены продажи дефицитного товара. хранится в промилле.
	PPID   WrOffAccOpID;      // Вид операции для бухгалтерского документа списания кассовых сессий.
    long   BHTRngLimWgtGoods; // Предел изменения для весового товара
	long   BHTRngLimPrice;    // Предел изменения цены для терминала BHT (от цены в документе образца)
	long   LookBackPricePeriod; // Количество дней для обзора назад для поиска фиксированных цен на товар
		// Используется для товаров, относящихся к типу, имеющему флаг GTF_LOOKBACKPRICES.
		// До v9.8.4 аналогичный параметр определялся в pp.ini ([config] AcgiPriceLookBackPeriod) и
		// применялся только для асинхронных кассовых узлов.
		// Начиная с v9.8.4, если указан PPEquipConfig::LookBackPricePeriod > 0, то AcgiPriceLookBackPeriod игнорируется.
	char   SuspCcPrefix[8];    // Префикс номера отложенного чека для быстрого восстановления чека по номеру в кассовой панели
	PPID   PhnSvcID;           // Телефонный сервис, опрашиваемый сессией
	PPID   ChkPanImpOpID;      // @v11.8.6 Вид операции документов, которые могут быть импортированы в кассовую панель для преобразования в кассовые чеки.
	PPID   ChkPanImpBillTagID; // @v11.8.6 Тег документа, позволяющий импортировать документ в кассовую панель
	long   LookBackBillPeriod; // @v11.8.9 Количество дней обзора назад для выбора документов импорта
};

int  ReadEquipConfig(PPEquipConfig * pCfg);
int  EditEquipConfig();
PPID GetCashiersPsnKindID();
//
//
//
struct CSessTotal {
	CSessTotal();
	void   FASTCALL Add(const CSessTotal * pSubTotal);

	PPID   SessID;         // Для выборки сессий - 0
	long   SessCount;      // Для итога по выборке сессий
	long   CheckCount;     // Количество чеков
	double Amount;         // Сумма по чекам
	double Discount;       // Скидка по чекам
	long   AggrCount;      // Количество агрегирующих строк
	double AggrAmount;     // Сумма по агрегирующим строкам
	double AggrRest;       // Сумма излишков по агрегирующим строкам
	long   WrOffBillCount; // Количество документов списания //
	double WrOffAmount;    // Списанная сумма
	double WrOffCost;      //
	double Income;         //
	double BnkAmount;      // Безналичная оплата
	double RetAmount;      // Общая сумма возвратов
	double RetBnkAmount;   // Сумма возвратов с оплатой через банк
	double WORetAmount;    // Сумма по чекам без чеков возврата
	double WORetBnkAmount; // Сумма безнал оплат без чеков возврата
	double BnkDiscount;    // Сумма безналичных скидок
	double CSCardAmount;   // Сумма по корпоративным кредитным картам
	double FiscalAmount;   // Фискальная сумма чеков
	double AltRegAmount;   // Сумма чеков, проведенных через альтернативный регистратор
	long   SaleCheckCount; // Количество чеков продаж
	long   SaleBnkCount;   // Количество чеков продаж с оплатой через банк
	long   RetCheckCount;  // Количество чеков возврата
	long   RetBnkCount;    // Количество чеков возврата с оплатой через банк
	long   AltRegCount;    // Количество чеков, проведенных через альтернативный регистратор
};

struct CSessInfo {
	CSessionTbl::Rec Rec;
	CSessTotal Total;
};
//
// Степени незавершенности кассовых сессий
//
#define CSESSINCMPL_CHECKS   10 // Чеки приняты, но не сгруппированы суперсессии и товарные строки
#define CSESSINCMPL_GLINES    5 // Не полностью сформированы документы
#define CSESSINCMPL_COMPLETE  0 // Сессия полностью обработана, кроме, возможно, не поступивших в систему извне чеков и излишков по сессии.

class CSessionCore : public CSessionTbl {
public:
	//
	// Descr: Возвращает период объединения сессий в суперсессии в секундах.
	//
	static long GetUnitingPeriodSec();

	CSessionCore();
	int    Search(PPID id, CSessionTbl::Rec * pRec = 0);
	int    SearchByNumber(PPID * pID, PPID cashNodeID, long cashN, long sessN, LDATE);
	//
	// Descr: Находит последнюю сессию по кассовому узлу cashNodeID с уровнем завершенности
	//   меньшим или равным, чем incompl.
	// Note: Термин "последняя сессия" интерпретируется как сессия, имеющая максимальную
	//   валидную пару { Dt, Tm } и не имеющая признака 'Временная'.
	//   Искомая сессия считается удовлетворяющей условиям поиска не зависимо от того,
	//   является ли она простой или супер-сессией.
	// ARG(cashNodeID IN): ИД кассового узла
	// ARG(incompl    IN): Максимальное значение уровня завершенности искомой сессии.
	//   Note: специальное смещение 1000 позволяет пропустить сессию, являющуюся текущей
	//     для кассового узла cashNodeID (если это - синхронный узел).
	// ARG(pID       OUT):
	// ARG(pRec      OUT):
	// Returns:
	//   >0 - найдена искомая сессия
	//   <0 - искомая сессия не найдена. Значения по указателям pID и pRec не присваиваются.
	//   0  - ошибка
	//
	int    SearchLast(PPID cashNodeID, int incompl, PPID * pID, CSessionTbl::Rec * pRec);
	int    SearchSuperCandidate(PPID nodeID, const LDATETIME & rDtm, PPIDArray * pList);
	int    HasChildren(PPID sessID);
	int    GetSubSessList(PPID superSessID, PPIDArray *);
	int    GetLastNumber(PPID cashNodeID, long cashNumber, long * pNumber, CSessionTbl::Rec * pRec = 0);
	int    GetIncompleteSessList(int grade /* CSESSINCMPL_XXX */, PPID cashNodeID, PPIDArray *);
	int    CreateSess(PPID *, PPID cashNodeID, long cashN, long sessN, LDATETIME, int temporary);
	int    CreateSuperSess(PPID * pSuperSessID, PPID cashNodeID, const PPIDArray & rSessList, int use_ta);
	int    AttachToSuperSess(PPID superSessID, const PPIDArray & rSessList, int use_ta);
	int    UpdateTotal(PPID id, const CSessTotal * pTotal, int wrOffSum, int completness, int use_ta);
	int    SetSessIncompletness(PPID, int grade /* CSESSINCMPL_XXX */, int use_ta);
	int    SetSessDateTime(PPID sessID, const LDATETIME & rDtm, int use_ta);
	int    ResetTempSessTag(PPID, int use_ta);
	//
	// Descr: Заносит в массив pSessList список активных (не закрытых) на данный момент
	//   временных (CSessionTbl::Rec::Temporary != 0) асинхронных кассовых сессий по кассовому узлу nodeID.
	//   Массив pSessList предварительно функцией не очищается.
	// Returns:
	//   >0 - обнаружена по крайней мере одна подходящая сессия //
	//   <0 - нет ни одной подходящей сессии
	//   0  - ошибка
	//
	int    GetTempAsyncSessList(PPID nodeID, const DateRange * pPeriod, PPIDArray * pSessList);
	int    GetActiveSessList(PPID locID, ObjIdListFilt * pActiveSessList);
	//
	// Descr: Проверяет уникальность сочетания {cashNodeID, *pDt, *pTm}
	//   Если запись с таким сочетанием уже существует, то увеличивает на одну
	//   миллисекунду время, и проверяет уникальность снова. И так до тех пор, пока
	//   не будет найдено подходящее значение.
	// Returns:
	//   1 - значения по указателям pDt и pTm не были изменены
	//   2 - значения по указателям pDt и pTm были изменены
	//
	int    CheckUniqueDateTime(PPID cashNodeID, LDATE * pDt, LTIME * pTm);
	int    CheckUniqueDateTime(PPID superSessID, long posNumber, LDATE * pDt, LTIME * pTm);
	long   GetCcGroupingFlags(const CSessionTbl::Rec & rCsRec, PPID subSessID);
};
//
// @ModuleDecl(CCheckCore)
//
//
// Классы, управляющие кассовыми чеками
//
//
// Флаги записей CCheckTbl
//
#define CCHKF_PREPRINT     0x00000001L // По чеку распечатан счет
#define CCHKF_ORDER        0x00000002L // Чек заказа стола
#define CCHKF_CLOSEDORDER  0x00000004L // Закрытый заказ стола (на этот чек заказа есть как минимум одна ссылка от чека продажи).
// @v12.0.12 #define CCHKF_ADDINCORPCRD 0x00000008L // В оплату чека включена дополнительная кредитная карта.
	// ИД этой карты хранится в поле CCheckExtTbl::AddCrdCardID, а сумма, списываемая с нее - в поле CCheckExtTbl::AddCrdCardPaym.
	// Доп кредитная карта никогда не применяется для начисления на нее денег.
#define CCHKF_DELIVERY     0x00000010L // Чек с опцией доставки (в расширении может быть введен адрес и указано время доставки)
#define CCHKF_BONUSCARD    0x00000020L // Чек проведен по бонусной карте. Этот флаг (кроме всего прочего) влияет на интерпретацию сумм оплаты.
#define CCHKF_PAYMLIST     0x00000040L // Чек имеет список оплат.
	// Если этот флаг установлен, флаги CCHKF_BANKING, CCHKF_ADDPAYM, /*CCHKF_ADDINCORPCRD*/ и поля CCheckExt::AddPaym, CCheckExt::AddCrdCardID, CCheckExt::AddCrdCardPaym
	// утрачивают смысл (не принимаются в рассмотрение).
#define CCHKF_TEMPREPLACE  0x00000080L // Пометка временного чека, который должен заместить чек с таким же номером в кассовой сессии
#define CCHKF_IMPORTED     0x00000100L // Обозначает синхронный чек, импортированный из внешней системы
#define CCHKF_FIXEDPRICE   0x00000200L // Цены по строкам чека зафиксированы. Если этот флаг не установлен,
	// то строка чека все равно может иметь зафиксированную цену, если в ней установлен флаг CCheckPacket::LineExt::fFixedPrice
#define CCHKF_ABSTRACTSALE 0x00000400L // Абстрактный товар (продажа по цене)
#define CCHKF_ALTREG       0x00000800L // Чек отпечатан на альтернативном регистраторе
// @v9.7.5 #define CCHKF_NOTICE       0x00001000L // Специальный вид чека, используемый только для пометки некоторого события с одним или
	// несколькими товарами. Чек с таким флагом автоматически получает флаги CCHKF_SKIP, CCHKF_SUSPENDED
#define CCHKF_SPFINISHED   0x00001000L // Специальный признак окончательного финиширования чека. Применяется, например,
	// для пометки факта доставки и(или) окончательной оплаты по чеку со стороны покупателя.
	// @v9.7.8 @fix 0x00000800L-->0x00001000L
#define CCHKF_TOREPRINT    0x00002000L // Флаг, устанавливаемый на чек, который не был правильно отпечатан и выбран для перепечатки.
	// При таком выборе чек получает флаги (CCHKF_SUSPENDED|CCHKF_TOREPRINT) после завершения перепечатки остается только флаг CCHKF_TOREPRINT.
#define CCHKF_PAPERLESS    0x00004000L // @v11.3.6 Кассовый регистратор не должен печатать бумажный чек по этой записи
#define CCHKF_CORRECTION   0x00008000L // @v12.2.8 Чек коррекции. Исключает CCHKF_RETURN.
#define CCHKF_SYNC         0x00010000L // Чек сформирован синхронной сессией
#define CCHKF_NOTUSED      0x00020000L // Чек не просуммирован в таблице CGoodsLine
#define CCHKF_PRINTED      0x00040000L // Чек был отпечатан (пробит на ККМ)
#define CCHKF_RETURN       0x00080000L // Чек возврата. Исключает CCHKF_CORRECTION.
#define CCHKF_ZCHECK       0x00100000L // Чек Z-отчета (для некоторых кассовых аппаратов)
#define CCHKF_TEMPSESS     0x00200000L // @transient Чек создан по временной сессии
#define CCHKF_TRANSMIT     0x00400000L // @transient Признак перемещения чека из другого раздела БД
#define CCHKF_BANKING      0x00800000L // Чек оплачен банковской кредитной картой
#define CCHKF_INCORPCRD    0x01000000L // Чек оплачен корпоративной кредитной картой
#define CCHKF_SKIP         0x02000000L // Чек не обрабатывается процедурой списания сессии.
	// Если это чек заказа (CCHKF_ORDER) то наличие этого флага означает отмененный заказ.
#define CCHKF_SUSPENDED    0x04000000L // Отложенный чек. При установке этого флага следует установить и флаг
	// CCHKF_SKIP, при сбросе этого флага следует сбросить признак CCHKF_SKIP если нет других причин для того,
	// чтобы его оставить.
#define CCHKF_EXT          0x08000000L // Для чека есть запись расширения //
#define CCHKF_JUNK         0x10000000L // Отложенный чек, который загружен в чековую панель. Чек с этим
	// признаком не должен загружаться в чековую панель (нарушение синхронизации). При повторном акцепте
	// отложенного чека, соответствующий ему JUNK-чек удаляется.
#define CCHKF_LINEEXT      0x20000000L // По крайней мере одна строка чека имеет расширение в таблице CCheckLineExt
#define CCHKF_ADDPAYM      0x40000000L // @deprecated Чек имеет ненулевую сумму доплаты в расширении записи чека CCheckExt
	// Вспомогательный флаг, используемый для быстрого определения (не обращаясь к доп записи) есть ли у чека сумма доплаты.
#define CCHKF_HASGIFT      0x80000000L // По чеку был предоставлен подарок  (не уточняется какой именно)
//
// Чековые операции 
// @persistent
//
#define CCOP_GENERAL               0 // @persistent Что-то общее (продажа скорее всего, но черт его знает что там еще может быть). Возможна трактовка как неопределенная операция.
#define CCOP_RETURN                1 // @persistent Возврат
#define CCOP_CORRECTION_SELL       2 // @persistent Коррекция продажи
#define CCOP_CORRECTION_SELLSTORNO 3 // @persistent Коррекция сторно продажи
#define CCOP_CORRECTION_RET        4 // @persistent Коррекция возврата
#define CCOP_CORRECTION_RETSTORNO  5 // @persistent Коррекция сторно возврата
//
//
//
struct CCheckGoodsEntry { // @flat @size=32
	enum {
		fAdj = 0x0001 // Элемент использован для выравнивания суммы агрегации с суммой по чекам
	};
	LDATE  Dt;
	int16  Sign;           // @#{-1;+1}
	int16  Flags;          //
	PPID   GoodsID;        //
	PPID   SerialID;       // Идентификатор серийного номера
	double Qtty;
	double Sum;
};

class CCheckGoodsArray : public TSVector <CCheckGoodsEntry> {
public:
	CCheckGoodsArray();
	int    Add(LDATE dt, const CCheckLineTbl::Rec *, PPID serialID = 0);
	LDATE  GetMaxDate() const;
	int    AdjustToSess(double sessAmount);
private:
	double Sum;
};

struct DraftRcptItem { // @flat
	DraftRcptItem();
	PPID   GoodsID;
	PPID   LocID;
	double Qtty;
};

typedef TSVector <DraftRcptItem> DraftRcptArray;
//
// Descr: Дескриптор статуса стола кафе.
//
struct CTableStatus { // @flat
	explicit CTableStatus(const CCheckViewItem * pCcItem = 0);
	int    FASTCALL Displace(const CTableStatus & rNewItem);
	enum {
		sUnkn = 0,  // Не удалось определить статус стола
		sFree = 1,  // Стол свободен
		sBusy,      // Стол занят
		sOnPayment, // Стол занят, но по чеку распечатан счет
		sOrder      // Стол заказан
	};
	long   TableNo;
	int    Status;
	PPID   CheckID;
	LDATETIME CheckDtm;
	STimeChunk OrderTime;
};

//
class CCheckCore : public CCheckTbl {
public:
	//
	// Descr: Опции функции CCheckCore::MakeCodeString
	//
	enum {
		mcsDefault      = 0x0000,
		mcsID           = 0x0001,
	};
	static SString & FASTCALL MakeCodeString(const CCheckTbl::Rec *, uint options, SString &);
	static int FASTCALL FetchCTableStatus(long tableNo, CTableStatus * pStatus);
	static int FASTCALL FetchCTableOrderList(TSVector <CTableStatus> & rList);
	static int Helper_GetPaymList(CCheckPaymTbl * pCpTbl, PPID id, CcAmountList & rList);
	static int FASTCALL IsExtRecEq(const CCheckExtTbl::Rec & r1, const CCheckExtTbl::Rec & r2);

	CCheckCore();
	~CCheckCore();
	//
	// Descr: возвращает константную ссылку на конфигурацию оборудования, считанную
	//   при создании экземпляра объекта.
	// Note: В течении жизни объекта этот экземпляр конфигурации не меняется.
	//
	const  PPEquipConfig & GetEqCfg() const;
	CheckOpJrnl * GetOpJrnl(); // @v11.6.2
	int    Search(PPID, CCheckTbl::Rec * pRec = 0);
	int    Search(PPID cashID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    SearchByTimeAndCard(PPID cardID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    SearchByDateAndCode(long code, LDATE dt, int unprintedOnly, TSVector <CCheckTbl::Rec> * pRecList);
	int    SearchForwardZCheck(PPID cashID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    GetExt(PPID id, CCheckExtTbl::Rec * pExt);
	int    GetPaymList(PPID id, CcAmountList & rList);
	int    GetListByExtFilt(const CCheckFilt & rFlt, ObjIdListFilt & rList);
	int    GetListByCode(long cashN, long code, TSVector <CCheckTbl::Rec> * pRecList);
	int    GetListByUuid(const S_GUID & rUuid, const LAssocArray * pCcDate2MaxIdIndex, uint backDays, PPIDArray & rCcList);
	int    GetListBySess(PPID sessID, long flags, PPIDArray & rList);
	//
	// Descr: Возвращает список идентификаторов чеков, обслуживающих чек заказа orderCheckID.
	// Note: В подавляющем большинстве случаев список  будет либо пустым, либо будет содержать
	//   только один элемент.
	// Returns:
	//   >0 - чек заказа обслужен по крайней мере одним чеком.
	//   <0 - заказ не обслуживался.
	//   0  - ошибка
	//
	int    GetOrderServersCheckList(PPID orderCheckID, PPIDArray & rList);

	struct ValidateCheckParam {
		explicit ValidateCheckParam(double tolerance);
		enum {
			efInvAmount       = 0x0001,
			efInvDiscount     = 0x0002,
			efHandgedGoods    = 0x0004,
			efZeroGoods       = 0x0008,
			efInvAmtEntrySign = 0x0010,
			efHandedSCard     = 0x0020,
			efLoadingFault    = 0x0040,
			efUnassignedCSess = 0x0080
		};
		const  double Tolerance; // Максимальное допустимое различие между суммой чека и суммами по строкам
			// (суммой скидки и суммами скидки по строкам), при превышении которого функция рапортует об ошибке.
		long   ErrorFlags;
		PPIDArray HangedGoodsList;
		PPIDArray HangedSCardList;
		PPIDArray CcListWithUnresolvedGoods;
	};
	//
	// Descr: Проверяет правильность чека.
	// ARG(id        IN): Идентификатор чека
	// ARG(tolerance IN): Максимальное допустимое различие между суммой чека и суммами по строкам
	//   (суммой скидки и суммами скидки по строкам), при превышении которого функция рапортует об ошибке.
	// ARG(rLogger   IN): Журнал вывода сообщений об ошибках.
	// Returns:
	//   !0 - ошибок в чеке не обнаружено.
	//    0 - чек содержит по крайней мере одну ошибку.
	//
	int    ValidateCheck(PPID id, ValidateCheckParam & rParam, PPLogger & rLogger);
	//
	// Descr: Возвращает ИД кассового узла, которому принадлежит чек checkID.
	//   Так как непосредственно чек на кассовый узел (в общем случае) не ссылается,
	//   то процесс состоит в следующем: функция извлекает чек с ИД = checkID,
	//   далее, извлекается кассовая сессия, которой принадлежит этот чек, и, наконец,
	//   из записи кассовой сессии извлекается ИД кассового узла.
	// Attension:
	//   Функция создает экземпляр PPObjCSession. Если вверху по стеку не было создано
	//   экземпляра этого объекта, то функция будет потреблять неадекватно много времени.
	// Returns:
	//   >0 - кассовый узел, которому принадлежит чек успешно определен.
	//   <0 - либо чек, либо сессия, которой он принадлежит не найдены.
	//   0  - ошибка
	//
	int    GetNodeID(PPID checkID, PPID * pNodeID);
	int    LineByCheck(PPID, int16 *);
	int    EnumLines(PPID, int *, CCheckLineTbl::Rec * = 0);
	int    RemoveZeroLinkLines(int use_ta);
	//
	// Descr: Загружает строки чека checkID в массив pList. Если параметр goodsID != 0,
	//   то загружает только строки, ссылающиеся на товар goodsID.
	// Note: Не очищает массив строк чека перед загрузкой.
	//
	int    LoadLines(PPID checkID, PPID goodsID, CCheckPacket * pPack);
	int    LoadChecksByList(const ObjIdListFilt * pSessList, const PPIDArray * pCashIDList, ObjIdListFilt * pCheckList, LDATETIME * pLastCheckDt);
	int    LoadLinesByList(PPID goodsID, const ObjIdListFilt * pCheckList, CCheckLineArray * pLinesList);
	//
	// Descr: Вызывает сначала LoadChecksByList, а уже затем LoadLinesByList
	//
	int    LoadLinesBySessList(PPID goodsID, const PPIDArray * pSessList, const PPIDArray * pCashList, CCheckLineArray * pLinesList, LDATETIME * pLastCheckDt);
	//
	// Descr: Находит последний (по дате/времени) чек по критериям:
	//   CCheckTbl::Rec.SessID == sessID && CCheckTbl::Rec.CashN == cashN && !(CCheckTbl::Rec.Flags & CCHKF_SKIP)
	// Returns:
	//   >0 - найден последний чек, соответствующий критерию
	//   <0 - база данных не содержит ни одного чека по критерию
	//   0  - ошибка
	//
	int    GetLastCheck(PPID sessID, long cashN, CCheckTbl::Rec * pRec);
	//
	// Descr: Находит безусловно самый последний (по дате/времени) чек в базе данных
	// Returns:
	//   >0 - найден безусловно последний чек
	//   <0 - база данных не содержит ни одного чека
	//   0  - ошибка
	//
	int    GetLastCheck(CCheckTbl::Rec * pRec);
	int    GetLastCheckByCode(long cashN, CCheckTbl::Rec * pRec);
	//
	// Descr: Если в базе данных присутствует чек по тому же кассовому узлу и с тем же
	//   временем, что и rRec, то функция корректирует сотые доли секунды времени для того,
	//   чтобы избежать ошибки дублирования индекса.
	//
	int    AdjustRecTime(CCheckTbl::Rec & rRec);
	int    Add(PPID * pID, const CCheckTbl::Rec * pRec, int use_ta);
	//
	// Descr: Кассовые чеки нельзя править. Их можно только добавлять или, в крайнем случае, удалять.
	//
	int    TurnCheck(CCheckPacket * pPack, int use_ta);
	//
	// Descr: Функция изменения пакета кассового чека (sik! опровергающая утверждение в описании функции TurnCheck)
	//
	int    UpdateCheck(CCheckPacket * pPack, int use_ta);
	//
	// Descr: Специализированный метод, позволяющий изменить текст расширения чека непосредственно в базе данных, не трогая все остальные
	//   записи и атрибуты чека.
	//
	int    UpdateExtText(PPID id, int fldId, const char * pText, int use_ta);
	//
	// Descr: Опции функции TurnSCardPayment
	//
	enum {
		//tscpfSkipUhtt     = 0x0001, // Не проводить операции с картами Universe-HTT
		tscpfSkipScSpcTrt = 0x0001, // Не проводить операции с картами через внешние сервисы
		tscpfCorrection   = 0x0002  // Специальный флаг обозначающий вызов функции с целью корректировки
	};
	//
	// Descr: Функция проведения платежей по чеку кредитными картами.
	//   Используется в составе функции TurnCheck и для аварийных целей.
	//
	int    TurnSCardPayment(CCheckPacket * pPack, long flags, int use_ta);
	int    RemovePacket(PPID, int use_ta);
	//
	// Descr: Опции функции CCheckCore::LoadPacket
	//
	enum {
		lpfNoLines     = 0x0001, // Не загружать строки чека
		lpfNoStrExt    = 0x0002, // @v12.0.5 Не загружать строки расширения // 
	};
	//
	// Descr: Загружает из базы данных пакет чека
	//
	int    LoadPacket(PPID id, long flags, CCheckPacket *);
	int    GetLineExt(PPID checkID, int rByCheck, CCheckLineExtTbl::Rec * pRec);
	//
	// Descr: Флаги функций GroupingToGoodsLines(), GetSessTotal(), GetListBySess().
	//
	enum {
		gglfUpdChecks   = 0x0001, // Снять признак CCHKF_NOTUSED после группировки
		gglfSkipUnprintedChecks = 0x0002, // Пропускать чеки без флага CCHKF_PRINTED
		gglfUseFullCcPackets    = 0x0004  //
	};
	int    GetSessTotal(PPID sessID, long flags, CSessTotal *, BVATAccmArray * pVatList);
	int    GroupingToGoodsLines(PPID sessID, CSessTotal *, CCheckGoodsArray *, long flags, int use_ta);
	int    RemoveSess(PPID sessID, int use_ta);
	//
	// Descr: Изменяет значение поля Flags записи с идентификатором checkID.
	//   Не проверяет права доступа (это обязана сделать вызывающая функция, если
	//   она находится на уровне слоя PPObject или выше).
	//
	int    UpdateFlags(PPID checkID, long flags, int use_ta);
	//
	// Descr: Изменяет некоторые параметры чека. Функция должна вызываться с максимальной отсорожностью.
	//
	int    UpdateRec(PPID checkID, const CCheckTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет запись расширения чека. Изменены могут быть только следующие поля:
	//     TableNo, CreationDtm, StartOrdDtm, EndOrdDtm, Memo, GuestCount.
	//     Если переданная параметром pExt запись не содержит изменений в перечисленных
	//     полях, то изменение в базе данных не фиксируется.
	// Returns:
	//     >0 - запись изменена.
	//     <0 - запись не изменена либо по тому, что конфигруация не предусматривает
	//        расширений чеков, либо по тому, что ни одно из полей, которое можно
	//        изменить в базе данных не отличается от тех, что в записи, переданной
	//        параметром pExt.
	//     0  - ошибка.
	//
	int    UpdateExt(PPID id, const CCheckExtTbl::Rec * pExt, int use_ta);
	int    PutExt(const CCheckTbl::Rec * pRec, CCheckExtTbl::Rec * pExt, int useTa);
	//
	// Descr: Изменяет значение поля SCardID записи с идентификатором checkID.
	//   Не проверяет права доступа (это обязана сделать вызывающая функция, если
	//   она находится на уровне слоя PPObject или выше).
	//
	int    UpdateSCard(PPID checkID, PPID newSCardID, int use_ta);
	//
	// Descr: Изменяет признак закрытой доставки по чеку.
	//
	int    ToggleDeliveryCloseTag(PPID checkID, const LDATETIME & rDtm, int set, int use_ta);
	//
	// Descr: заменяет ссылки на карты destCardID на ссылки на карты srcCardID.
	//
	int    ReplaceSCard(PPID destCardID, PPID srcCardID, int use_ta);
	int    GetTrnovrBySCard(PPID cardID, int alg /*PPObjSCard::gtalgXXX*/, const DateRange * pPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	int    CreateSCardsTurnoverList(const DateRange *, RAssocArray *);
	int    GetListByCard(PPID cardID, const LDATETIME * pMoment, PPIDArray * pList);
	int    RecalcSCardsTurnover(int use_ta);
	int    UpdateSCardOpsBySess(PPID sessID, int use_ta);
	int    SetFlagsBySess(PPID sessID, long setFlags, long resetFlags, int use_ta);
	int    IsCheckWFlags(PPID sessID, long chkFlags);
	//
	// Descr: Утилитная функция, позволяющая (с некоторой вероятностью) определить
	//   используются ли в базе данных записи расширения чеков. Если установлен флаг
	//   (CConfig.Flags & CCFLG_USECCHECKEXT) и таблица CCheckExt содержит более 10 записей,
	//   то функция возвращает 1, иначе - 0.
	//
	int    HasExt();
	int    CalcActiveExpendByGoods(PPID goodsID, PPID locID, const char * pSerial, double * pResult);
	int    GetActiveExpendByLocList(const ObjIdListFilt * pLocList, DraftRcptArray * pList);
	//
	// Descr: Рассчитывает остаток товара goodsID на дату dt по складу locID.
	//   Расчет осуществляется следующим образом: извлекается остаток по учетным
	//   товарным операциям (Transfer::GetRest) и из него вычитается количество,
	//   проданное по всем активным синхронным кассовым сессиям, принадлежащим складу locID
	//   (CCheckCore::CalcActiveExpendByGoods).
	//
	int    CalcGoodsRest(PPID goodsID, LDATE dt, PPID locID, double * pRest);
	int    AddRecToSessTotal(const CCheckTbl::Rec * pRec, CSessTotal * pTotal);
	//
	// Descr: Функция выясняет принадлежал ли чек с признаком CCHKF_JUNK потерянной сессии.
	// Note: Фактически, чек id может принадлежать сессии, которая еще работает на данном компьютере под
	//   текущей системной учетной записью.
	//
	int    IsLostJunkCheck(PPID id, const S_GUID * pExtUuid, PPSession::RegSessData * pSessData);
	//
	// Descr: Типы сообщений, записываемых в файл журнала ccheck.log
	//   в отладочном режиме (CConfig.Flags & CCFLG_DEBUG)
	//
	enum { // @persistent
		logPrinted      = 0,  // Чек отпечатан
		logWrited       = 1,  // Чек записан в БД
		logRestored     = 2,  // Отложенный чек восстановлен из БД
		logRemoved      = 3,  // Чек удален из БД
		logCleared      = 4,  // Чек очищен в чековой панели
		logSuspended    = 5,  // Чек отложен
		logRowCleared   = 6,  // Строка чека удалена в чековой панели
		logRowDiscount  = 7,  // Скидка на строку чека
		logAgentChanged = 8,  // Изменен текущий агент в чеке
		logJunkRemoved  = 9   // Junk-чек удален из БД
	};

	int    SerializePacket(int dir, CCheckPacket * pPack, SBuffer & rBuf, SSerializeContext * pCtx);
	void   WriteCCheckLogFile(const CCheckPacket * pPack, const CCheckLineTbl::Rec * pLineRec, int action /* CCheckCore::logXXX */, int use_ta);
	void   WriteCCheckLogFile(const CCheckTbl::Rec * pRec, int action /* CCheckCore::logXXX */, int use_ta);
	int    CorrectCCLineProblem01();
	//
	// Descr: Строит индекс соответствий {дата чека}->{максимальный идентификатор}.
	//   Индекс нужен для быстрой фильтрации дополнительных текстов чека по дате так как строки расширения 
	//   хранят только идентификаторы чеков.
	//   Реальный кейс из-за которого вводится эта функция: ускорение поиска марок егаис или честный знак при продаже товара
	//   с целью предотвращения повторной продажи отдной и той же марки.
	//
	int    MakeDate2MaxIdIndex(LAssocArray & rIndex);
	//
	// Descr: Элемент информации о маркировке товара, с которой ассоциирована строка кассового чека
	//
	struct CcMarkedEntry { // @flat
		CcMarkedEntry();
		enum {
			fSent = 0x0001 // Марка отправлена на учетный сервер (для егаис)
		};
		PPID   CcID;       // Идентификатор чека
		int16  LineNo;     // Номер строки чека 
		uint16 Flags;      // @flags
		double Qtty;       // Количество. Qtty > 0 - продажа; Qtty < 0 - возврат (в торговых единицах)
	};
	//
	// Descr: Список строка кассовых чеков, ассоциированных с маркированным товаром
	// 
	struct ListByMarkEntry {
		ListByMarkEntry();
		PPID   OrgLotID;    // IN  Ид начального лота, с которым пришла марка 
		LDATE  OrgLotDate;  // IN  Дата начального лота, с которым пришла марка
		double OrgLotQtty;  // IN  Количество товара, поступившего с лотом (в торговых единицах).
		uint   Flags;       // IN  @flags 
		char   Mark[256];   // IN  Код маркировки
		double TotalOpQtty; // OUT Суммарное операционное количество по всем встреченным строкам чеков (с учетом знака - see CcMarkedEntry::Qtty)
		TSVector <CcMarkedEntry> CcList;
		void * P_Extra;     // IN @v12.0.12 Указатель, используемый для привязки внешних данных к этому элементу. 
		//SBitArray SentList__ToRemove; // @todo Это поле будет удалено в пользу флага CcMarkedEntry::fSent
	};

	// really private (used by PPObjCSession)
	//
	// Descr: Извлекает список идентификаторов чеков, хотя бы одна строка которых содержит код маркировки pText.
	//   Код маркировки определяется по идентификатору строки расширения markLnextTextId.
	//   Если задан дополнительный идентификатор строки расширения sentLnextTextId и ненулевой указатель pSentList
	//   на битовый массив, то в массив pSentList заносится бит 1 в случае, если для строки чека, к которой привязана
	//   искомая марка так же задана не пустая строка расширения sentLnextTextId. 
	//   Этот трюк сделан ради марок егаис, информация о продаже которых была отправлена серверу егаис.
	//
	// @v12.0.5 int    Helper_GetListByMark(const char * pText, int markLnextTextId, const LAssocArray * pCcDate2MaxIdIndex, uint backDays, int sentLnextTextId, PPIDArray & rCcList, SBitArray * pSentList);
	int    Helper_GetListByMark2(TSCollection <ListByMarkEntry> & rList, int markLnextTextId, const LAssocArray * pCcDate2MaxIdIndex, uint backDays, int sentLnextTextId); // @v12.0.5

	CCheckLineTbl Lines;
	CCheckPaymTbl PaymT;    // Таблица платежей по чекам
	SCardCore     Cards;
	CCheckLineExtTbl * P_LnExt; // Таблица расширения строк чеков private->public
private:
	int    Helper_TurnSCardPayment(CCheckPacket * pPack, long flags, double * pUfpFactor, double * pUfpFactorUhtt, int use_ta);
	int    PreprocessPacket(CCheckPacket * pPack);
	int    PreparePacketForWriting(PPID id, CCheckPacket * pPack, double & rUfpFactor);
	int    Update(PPID id, const CCheckTbl::Rec * pRec, int use_ta);

	CCheckExtTbl * P_Ext;
	CheckOpJrnl * P_ChkOpJrnl;
	PPEquipConfig EqCfg; // Коль скоро конструктор все равно читает конфигурацию, оставим ее здесь.
};
//
// Descr: Вспомогательная структура, используемая для быстрого извлечения и
//   анализа дефицита по кассовым сессиям
//
struct CSessDfctItem { // @flat
	PPID   GoodsID;      // Товар, по которому возник дефицит
	PPID   SessID;       // Кассовая сессия, в которой возник дефицит
	LDATE  Dt;           // Дата возникновения дефицита
	double Qtty;         // Проданное количество товара GoodsID
	double Dfct;         // Количество не списанное из-за дефицита
	double Sum;          // Сумма продажи товара (для количества Qtty)
	PPID   AltGoodsID;   // Альтернативный товар
	double AltGoodsQtty; // Количество списанное по альтернативному товару
};

class CSessDfctList : public TSVector <CSessDfctItem> {
public:
	enum {
		uniteNone = 0,
		uniteByGoods,
		uniteByDateGoods
	};
	CSessDfctList();
	int    Add(const CSessDfctItem *, int unite);
	int    SearchByDateGoods(LDATE dt, PPID goodsID, uint * pPos, CSessDfctItem *) const;
private:
	int    Search(const CSessDfctItem *, int unite, uint * pPos) const;
};
//
//
//
struct CSessDfctGoodsItem {
	CSessDfctGoodsItem();
	double GetPrice() const;
	PPID   GoodsID;
	double Qtty;
	double Sum;
};

class CSessDfctGoodsList : public TSArray <CSessDfctGoodsItem> {
public:
	int    Search(PPID goodsID, CSessDfctGoodsItem * pItem);
	int    Add(const CSessDfctGoodsItem * pItem);
};
//
//
//
#define CGOODSLINESIGN_ALTGOODSREC 100 // Если в поле Sign данное значение,
	// то эта запись соответствия дефицитный товар/альтернативный товар

class CGoodsLine : public CGoodsLineTbl {
public:
	explicit CGoodsLine(char * pFileName = 0);
	int    Add(PPID sessID, const CCheckGoodsArray * pList, int use_ta);
	int    Update(const CGoodsLineTbl::Rec & rRec, int use_ta);
	int    UndoWritingOff(PPID);                       // Without transaction
	int    RemoveSess(PPID sessID);                    // Without transaction
	int    HasAnyLineForSess(PPID sessID);
	int    CalcSessTotal(PPID sessID, CSessTotal *);
	int    GetDfctList(int sign, PPID sessID, PPID goodsID, const DateRange *, int unite,
		CSessDfctList *, PPIDArray * pDateList);
	int   GetDfctGoodsList(int sign, PPID sessID,
		const DateRange * pPeriod, CSessDfctGoodsList * pList);
	int   GetDfctSubstList(PPID sessID, LAssocArray * pList);
	int   SetDfctSubstList(PPID sessID, const LAssocArray * pList, int use_ta);
private:
	int    Search_ForUpdate(PPID sessID, LDATE dt, PPID goodsID, int sign, PPID serialID, CGoodsLineTbl::Rec * pRec);
};
//
// Descr: Класс, реализующий группировку строк кассовых чеков для сохранения в
//  таблице CGoodsLine и конвертации этой группировки в товарные документы
//
class CSessGrouping {
public:
	CSessGrouping();
	int    GetSess(PPID sessID, CSessionTbl::Rec * pRec);
	int    Grouping(PPID sessID, CSessTotal * pTotal, const LAssocArray * pSubstList, int use_ta);
	int    UndoGrouping(PPID sessID, LAssocArray * pSubstList, int use_ta);
	int    ConvertToBills(PPID sessID, PPID locID, const char * pMsg, uint sessNo, uint sessCount, int use_ta);
	int    TurnAccBill(PPID sessID, PPID locID, int use_ta);
	int    ConvertTempSessToBills(const PPIDArray * pSessList, PPID locID, PPID * pBillID, int use_ta);
	int    AttachSessToSupersess(PPID nodeID, PPID sessID, PPID * pSuperSessID, int use_ta);
	int    CompleteSession(PPID sessID);
	int    ConvertSessListToBills(const PPIDArray * pSessList, PPID locID, int use_ta);
	int    GroupingSessList(PPID nodeID, const PPIDArray * pList, PPIDArray * pOutList, PPIDArray * pOutTempList, int use_ta);
	//
	// Descr: Реализует удаление или откат списания по кассовой сессии sessID.
	//   уровень отката определяется параметром grade.
	// ARG(sessID IN): Идентификатор кассовой сессии, которая должна быть удалена
	// ARG(grade  IN):
	//   CSESSINCMPL_GLINES   - Undo writing off
	//   CSESSINCMPL_CHECKS   - Nothing
	//   CSESSINCMPL_COMPLETE - Totaly removes session with checks and write off bills
	//
	int    RemoveSession(PPID sessID, int grade);
protected:
	CSessionCore CS;
	CCheckCore   CC;
	CGoodsLine   GL;
private:
	int    TurnBill(PPBillPacket * pPack, CSessTotal * pTotal, int isRet, OptimalAmountDamper * pOad);
	int    ConvertSign(const int sign, const  PPID sessID, const  PPID locID, const void * pData, CSessTotal * pTotal, OptimalAmountDamper * pOad);
	int    Convert(PPID sessID, PPID locID, const void * pData, CSessTotal * pTotal, int use_ta);
	int    ConvertDeficit(PPID sessID, PPID locID, CSessTotal * pTotal);

	int    ComplDfct;
	int    IgnGenGoods;
	PPID   SellOpID;
	PPID   RetOpID;
	PPLogger Logger;
	SString WMsg;
};
//
// Класс генерации соответствий {id, string} для подстановки в запросы DBQuery
//
#if 0 // @snippet {
void foo()
{
	// Массив содержит 5 элементов
	static DbqStringSubst subst(5); // @global @threadsafe
	XTbl * t = new XTbl;
	DBE * dbe = 0;
	// PPTXT_XXX - ид строки (PPSTR_TEXT) формата "1,string 1;2,string 2;3,string 3"
	dbe = & enumtoa(t->IntField, 5, subst.Get(PPTXT_XXX));
	q = & select(t->ID, *dbe, 0L).from(t, 0L);
	delete dbe;
}
#endif // } @snippet

class DbqStringSubst {
public:
	explicit DbqStringSubst(size_t numItems);
	~DbqStringSubst();
	char ** FASTCALL Get(uint strID);
private:
	void   FASTCALL Init(uint strID);
	struct Subst {
		int16  Id;
		char   Str[32];
	};
	size_t NumItems;
	Subst * Items;
	Subst ** P_Items;
	int    IsInited;
};

DBTable * FASTCALL __PreprocessCreatedDbTable(DBTable * pT);
//
// Макрос для генерации функции создания временного файла
//
#define PP_CREATE_TEMP_FILE_PROC(proc,nam)                 \
	static nam##Tbl * proc() { return static_cast<nam##Tbl *>(__PreprocessCreatedDbTable(new nam##Tbl(DBTable::CrTempFileNamePtr))); }

template <class T> inline T * CreateTempFile()
{
	return static_cast<T *>(__PreprocessCreatedDbTable(new T(DBTable::CrTempFileNamePtr)));
}

template <class T> int SerializeDbTableByFileName(int dir, T ** ppT, SBuffer & rBuf, SSerializeContext * pCtx)
{
	int    ok = 1;
	SString temp_buf;
	if(dir > 0) {
		if((*ppT) != 0)
			temp_buf = (*ppT)->GetName();
		else
			temp_buf.Z();
		THROW_SL(pCtx->Serialize(dir, temp_buf, rBuf));
	}
	else if(dir < 0) {
		ZDELETE(*ppT);
		THROW_SL(pCtx->Serialize(-1, temp_buf, rBuf));
		if(temp_buf.NotEmptyS()) {
			THROW_MEM((*ppT) = new T(temp_buf));
		}
	}
	CATCHZOK
	return ok;
}
//
// @ModuleDecl(PPView)
//
// Descr: Базовый класс для контроллеров анализа данных
//
class PPView {
public:
	//
	// Descr: Параметры запуска PPView по именованному фильтру
	//
	struct ExecNfViewParam {
		ExecNfViewParam();
		int    Write(SBuffer & rBuf, long);
		int    Read(SBuffer & rBuf, long);
		uint8  ReserveStart[32];
		long   Flags;
		SString NfSymb;
		SString Dl600_Name;
		SString FileName;
	};
	static int FASTCALL CreateInstance(int viewID, PPView ** ppV);
	static int FASTCALL CreateFiltInstance(int filtID, PPBaseFilt ** ppF);
	static int FASTCALL CreateFiltInstanceBySymb(const char * pSymb, PPBaseFilt ** ppF);
	static int FASTCALL WriteFiltPtr(SBuffer & rBuf, const PPBaseFilt * pFilt);
	static int FASTCALL ReadFiltPtr(SBuffer & rBuf, PPBaseFilt ** ppFilt);
	static int EditExecNfViewParam(ExecNfViewParam & rData);

	enum {
		exefModeless     = 0x0001,
		exefDisable3Tier = 0x0002
	};
	static int FASTCALL Execute(int viewID, const PPBaseFilt * pFilt, int flags /* exefXXX */, void * extraPtr);
	static int FASTCALL Execute(int viewID, const PPBaseFilt * pFilt, int flags /* exefXXX */, PPView ** ppResult, void * extraPtr);
	static int ExecuteServer(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int Destroy(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int Refresh(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int ExecuteNF(const char * pNamedFiltSymb, const char * pDl600Name, SString & rResultFileName);
	static int ExecuteNF(const PPNamedFilt * pNf, const char * pDl600Name, SString & rResultFileName);
	//
	// Descr: Экспортирует результат вычисления фильтра pNf в буфер rResult.
	// ARG(pDl600Name IN): имя экспортной структуры DL600, которая должна использоваться для формирования данных.
	//   Если этот параметр пустой (isempty(pDl600Name)), то функция пытается извлечь имя структуры
	//   из pNf->VD.GetStrucSymb(). Если и этот вариант оказывается безуспешным, то из объекта PPView,
	//   соответствующего описанию PPNamedFilt извлекается отчет по умолчанию (DefReportId). В случае,
	//   если такой отчет существует, то применяется его структура данных.
	//   При безуспешности получения имени экспортной структуры функция возвращает 0 (ошибка).
	// ARG(format IN): либо SFileFormat::Xml, либо SFileFormat::Json.
	//   Возможен вариант 0 (SFileFormat::Unkn) - трактуется как SFileFormat::Xml.
	//
	static int ExecuteNF(const PPNamedFilt * pNf, const char * pDl600Name, int format, SBuffer & rResult);

	struct Rc {
		Rc();
		Rc & Z();
		long   Id;
		SString Symb;
		SString Descr;
		const  void * P_ExtraParam; // @v11.4.4
	};
	//
	// Descr: Загружает из ресурсов описание объекта PPView или PPBaseFilt
	// ARG(kind  IN): 0 - PPView, 1 - PPBaseFilt
	// ARG(id    IN): Идентификатор ресурса
	// ARG(rRc  OUT): Структура дескриптора ресурса
	//
	// @v11.4.4 static int LoadResource(int kind, int id, PPView::Rc & rRc);
	// @v11.4.4 static int GetResourceLists(bool includeSpecialItems, StrAssocArray * pSymbList, StrAssocArray * pTextList);
	static int InitializeDescriptionList();
	static int GetFilterById(long id, PPView::Rc & rEntry);
	static int GetDescriptionById(long id, PPView::Rc & rEntry);
	static int GetDescriptionBySymb(const char * pSymb, PPView::Rc & rEntry);
	static int GetDescriptionList(bool includeSpecialItems, TSCollection <Rc> & rResult);
	static int GetDescriptionList(bool includeSpecialItems, StrAssocArray * pSymbList, StrAssocArray * pTextList);
	static const void * GetDescriptionExtra(long id);

	virtual ~PPView();
	bool   IsConsistent() const;
	enum {
		implChangeFilt          = 0x0001, // Порожденный класс самостоятельно обрабатывает команду PPVCMD_CHANGEFILT
		implOnAddSetupPos       = 0x0002, // Базовый класс PPView должен установить позицию по новому идентификатору после обработки PPVCMD_ADDITEM.
		implDontDelTempTables   = 0x0004, // Не удалять файлы временных данных
		implDontSetupCtColumnsOnChgFilt = 0x0008, // Не устанавливать кросс-таб столбцы в функции PPView::ChangeFilt
			// (порожденный класс самостоятельно сделает это функцией PreprocessBrowser).
		implBrowseArray         = 0x0010, // Данные для броузера поcтавляются массивом SArray а не запросом DBQuery
		implUseServer           = 0x0020, // Объект может делегировать инициализацию серверу
		implDontEditNullFilter  = 0x0040, // Если указатель на фильтр равен 0, то использовать пустой фильтр и не вызывать диалог редактирования фильтра
		implUseQuickTagEditFunc = 0x0080  // @v11.2.8 Если установлен, то в таблице применяется функция быстрого редактирования тега
			// по нажанию клавишь '/' и горячей клавиши, заданной в теге.
	};
	long   GetImplementFlags() const { return ImplementFlags; }
	//
	// Descr: Создает экземпляр класса PPBaseFilt. Дополнительный параметр extraPtr
	//   позволяет задать специфичную информацию для инициализации фильтра.
	//   Полученный указатель после использования должен быть разрушен вызывающей функцией
	//   обращением к "delete p_flt;"
	//
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	//
	// Descr: Инициализирует экземпляр класса в соответствии с фильром pFilt.
	//
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	virtual const IterCounter & GetCounter() const;
	//
	// Descr: Функция вызывается из функции PPViewBrowser::execute до запуска броузера если
	//   броузер модальный, если же броузер немодальный, то функция вызывается непосредственно после
	//   запуска броузера на выполнение (при этом возвращаемое функцией значение игнорируется).
	// Returns:
	//   <0  - PPViewBrowser::execute должен реализовать свое исполнение в обычном режиме
	//   >=0 - PPViewBrowser::execute должен прекратить исполнение и вернуть это значение (ushort)
	//
	virtual int   OnExecBrowser(PPViewBrowser *);
	virtual int   Browse(int modeless);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	//
	// Протокол передачи серверу задания на формирование PPView:
	// 1. Клиент передает серверу команду CREATEVIEW view_name filter (filter - в бинарном виде)
	// 2. Сервер создает экземпляр PPView и вызывает PPView::Init_(filter)
	// 3. Сервер упаковывает состояние объекта вызовом PPView::SerializeState(+1, buf, 0)
	// 4. Сервер передает клиенту состояние объекта
	// 5. Клиент получает состояние объекта PPView вызовом PPView::SerializeState(-1, buf, 0)
	// 6. Клиент отправляет серверу подтверждение акцепта состояния.
	// 7. Сервер разрушает собственный объект PPView. Если было получено подтверждение акцепта
	//    состояния клиентом, то сервер предпринимает меры для того, чтобы временные таблицы,
	//    ссылки на которые были переданы клиенту, не были бы разрушены.
	//
	virtual int   SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	const  PPBaseFilt * GetBaseFilt() const;
	//
	// Descr: Высокоуровневая helper-функция, реализующая инициализацию экземпляра PPView
	//   фильтром pBaseFilt. Практически аналогична вызову ::Init_(pBaseFilt), но дополнительно
	//   выводит в user-profile-log описание фильтра.
	//
	int    InitLocal(const PPBaseFilt * pBaseFilt);
	int    GetOuterChangesStatus() const;
	//
	// Descr: Отправляет данные на экспорт в формате XML. Функция реализует тот же самый
	//   экспорт, который может быть выполнен пользователем при вызове функции печати
	//   с ручным вызовом экспорта в XML.
	// @nointeract
	//
	int    ExportXml(uint rptId, int ord = 0);
	PPObject * GetObj() const;
	const  char * GetSymb() const;
	const  char * GetDescr() const;
	bool   IsCrosstab() const;
	//
	// Descr: Устанавливает заголовок отображаемой таблицы. Эта функция должна быть вызвана после метода
	//   PPView::Init_ поскольку он очищает внешний заголовок.
	//   Если внешний заголовок не определен (пустой), то порожденный класс сам устанавливает
	//   заголовок отображаемой таблицы.
	//
	void   SetOuterTitle(const char * pOuterTitle);
	int    GetOuterTitle(SString * pBuf) const;
	long   GetViewId() const { return ViewId; }
	long   GetDefReportId() const { return DefReportId; }
private:
	uint32 Sign; // Подпись экземпляра класса. Используется для идентификации инвалидных экземпляров.
	int    ExecFlags; // Флаги, с которыми была вызвана функция PPView::Execute()
	LongArray * P_LastUpdatedObjects; // Список идентификаторов объектов, созданных, измененных
		// или удаленный при последнем вызове PPView::ProcessCommand. Необходим для того,
		// что бы порожденный класс мог отреагировать на обработку событий базовым классом.
	static int FASTCALL CreateInstance(int viewID, int32 * pSrvInstId, PPView ** ppV);
	static int FASTCALL Helper_Execute(int viewID, const PPBaseFilt * pFilt, int flags, PPView ** ppResult, void * extraPtr);
	int    Helper_Init(const PPBaseFilt * pFilt, int flags /* exefXXX */);
protected:
	static DBQuery * CrosstabDbQueryStub; // realy const (bad ptr)
	//
	// Returns:
	//   1 - функция отработала успешно
	//   100 - функция отработала успешно. В буфере  хранился пустой экземпляр DBTable:
	//     вызывающая функция должна разрушить pTbl.
	//   0 - error
	//
	static int SerializeTableSpec(int dir, DBTable * pTbl, SBuffer & rBuf, SSerializeContext * pCtx);
	PPView(PPObject * pObj, PPBaseFilt * pFilt, int viewId, long implFlags, long defReportId);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	//
	// Descr: callback функция, вызываемая из функции PPView::Browse после создания //
	//   таблицы pBrw и перед ее показом. Может быть переопределена порожденным классом
	//   для добавления дополнительных столбцов или удаления ненужных, а также для других установок.
	// Returns:
	//   <0 - функция ничего не делает
	//   >0 - были сделаны какие-либо изменения в таблице pBrw
	//   0  - ошибка. В этом случае функция PPView::Browse прерывает исполнение.
	//
	virtual void PreprocessBrowser(PPViewBrowser * pBrw); // @<<PPView::Browse
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual void * GetEditExtraParam();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int32  GetServerInstId() const { return ServerInstId; }
	//
	// Descr: Вспомогательная функция, обеспечивающая верификацию и установку
	//   фильтра в функции Init_().
	// Returns:
	//   >0 - фильтр верифицирован и инициализирован
	//   0  - ошибка
	//
	int    FASTCALL Helper_InitBaseFilt(const PPBaseFilt *);
	int    DefaultCmdProcessor(uint ppvCmd, const void *, PPViewBrowser *);
	int    FASTCALL Helper_Print(uint rptId, int ord = 0);
	int    ChangeFilt(int refreshOnly, PPViewBrowser * pW);
	void   SetExtToolbar(uint toolbarId);
	//
	// Descr: Изменяет данные во временной диаграмме, связанной с этим объектом.
	//   Функция должна быть вызвана при разрушении объекта, а также при существенном изменении
	//   данных, по которым строится связанная диаграмма
	// ARG(pGrid   IN): Указатель на управляющий объект временной диаграммы
	// ARG(pTitle  IN): Если !0 и !destroy, то функция установит окну диаграммы заголовок pTitle
	// ARG(destroy IN): Если !0, то диаграмма разрушается.
	// Returns:
	//   >0 - связанная диаграмма обнаружена и над ней произведены указанные действия //
	//   <0 - нет связанной диаграммы
	//
	int    UpdateTimeBrowser(const STimeChunkGrid * pGrid, const char * pTitle, int destroy);
	int    GetLastUpdatedObjects(long extId, LongArray & rList) const;
	void   Helper_FormatCycle(const PPCycleFilt & rCf, const PPCycleArray & rCa, LDATE dt, char * pBuf, size_t bufLen);
	int    Implement_CmpSortIndexItems_OnArray(PPViewBrowser * pBrw, const void * pItem1, const void * pItem2);
	int    Helper_ProcessQuickTagEdit(PPObjID oid, const void * pHdrPtr /*(LongArray *)*/);

	IterCounter Counter;
	BExtQuery * P_IterQuery;
	Crosstab  * P_Ct;
	long   ImplementFlags;
	enum {
		bsOuterChangesStatus = 0x0001, // Реализация класса PPView может установить этот флаг, если считает,
			// что сделала изменения в данных, существенные для вызывающего метод Browse() модуля.
		bsServerInst         = 0x0002, // Экземпляр является серверным (созданным в ответ на запрос клиента).
			// Если это состояние установлено, то ServerInstId является идентификатором, с котороым
			// связан указатель в PPThreadLocalArea (PPThreadLocalArea::GetPtr)
		bsServerInstDestr    = 0x0004, // Устанавливается деструктором PPView::~PPView если
			// серверный экземпляр (если существовал) был нормально разрушен.
		bsUserChangedData    = 0x0008  // @v11.4.3 Реализация класса PPView самостоятельно поддерживает и использует
			// этот флаг. Он означает, что пользователь внес изменения в данные и их, вероятно, надо обновить в хранилище.
	};
	long   BaseState;
	long   DefReportId;         // Базовая функция Print() вызывает Helper_Print(DefReportId, 0)
		// если это поле не нулевое. Таким образом, если реализация Print() в унаследованном классе
		// сводится только к такому вызову, этому классу достаточно в конструкторе инициализировать
		// поле DefReportId и не реализовывать Print().
		// В более сложных случаях придется самостоятельно определять этот метод.
private:
	// @v11.4.4 {
	class DescriptionList : private SStrGroup {
		friend class PPView;
	public:
		enum {
			kView = 1,
			kFilt = 2
		};
		bool   IsValid() const { return !Fail; }
		int    GetById(long id, PPView::Rc & rEntry) const;
		int    GetBySymb(const char * pSymb, PPView::Rc & rEntry) const;
		int    GetList(bool includeSpecialItems, TSCollection <Rc> & rResult) const;
	private:
		explicit DescriptionList(int kind);
		struct InnerEntry {
			long   Id;
			uint   SymbP;
			uint   DescrP;
			const  void * P_ExtraParam;
		};
		TSVector <InnerEntry> L;
		const  int Kind; // kXXX
		int    Fail;
	};
	static const DescriptionList * P_DL;
	static const DescriptionList * P_FL;
	// } @v11.4.4
	uint   ExtToolbarId; // Идентификатор тулбара, который следует загрузить в броузер
		// при выполнении функции Browse
	int32  ViewId;       // Идентификатор объекта (PPVIEW_XXX)
	int32  ServerInstId; // Идентификатор серверного экземпляра объекта.
	SString Symb;        // @*PPView::CreateInstance Строка символа объекта (например Processor для PPViewProcessor)
	SString Descr;       // @*PPView::CreateInstance Строка описания объекта
	SString OuterTitle;  // @*PPView::Init_, PPView::SetOuterTitle
	PPBaseFilt * P_F;    // not owned by base class
	PPObject * P_Obj;    // not owned by base class
};
//
// RegisterFilt
//
struct RegisterFilt : public PPBaseFilt {
	RegisterFilt();
    virtual bool IsEmpty() const;

	uint8  ReserveStart[20]; // @anchor
	PPObjID Oid;             //
	PPID   ExclLocID;        //
	PPID   ExclPersonID;
	PPID   RegTypeID;
	DateRange RegPeriod;
	DateRange ExpiryPeriod;
	SString SerPattern;      // @anchor
	SString NmbPattern;
};
//
// @ModuleDecl(PPCommand)
//
typedef int (*CmdItemIterFunc)(const PPCommandItem *, long parentID, void * extraPtr);
//
// @todo Объединить на уровне базового класса с PPJobDescr
//
struct PPCommandDescr {
	enum {
		fNoParam = 0x0001 // Команда не имеет параметров
	};
	static const char * P_FactoryPrfx;

	static int   GetResourceList(int loadText, StrAssocArray & rList);
	static int   GetResourceList(LAssocArray & rList);
	PPCommandDescr();
	PPCommandDescr & Z();
	int    LoadResource(long cmdDescrID);
	SString & FASTCALL GetFactoryFuncName(SString &) const;
	int    Write(SBuffer &, long) const;
	int    Read(SBuffer &, long);
	PPCommandHandler * CreateInstance(long cmdDescrID);
	int    DoCommand(PPCommand * pCmd, void * extraPtr);
	int    DoCommandSimple(PPID cmdDescrID, int allowEditParam, const char * pTextFilt, void * extraPtr);
	int    EditCommandParam(PPID cmdDescrID, long cmdID, SBuffer * pParam, void * extraPtr);

	long   CmdID;
	long   Flags;
	long   MenuCm;
	long   IconId;
	long   ToolbarId;
	long   ViewId;         //
	long   FiltId;         //
	long   FiltExtId;      //
	long   Reserve;        // @reserve
	SString Symb;
	SString Text;
};

enum PPCommandGroupCategory {
	cmdgrpcUndef   = 0,
	cmdgrpcDesktop = 1,
	cmdgrpcMenu    = 2
};

class PPCommandItem {
public:
	enum {
		kUndef     = 0,
		kCommand   = 1,
		kFolder    = 2,
		kGroup     = 3,
		kSeparator = 4,
	};
	enum {
		fBkgndGradient    = 0x0001,
		fNotUseDefDesktop = 0x0002,
		fAllowEditFilt    = 0x0004, // При вызове команды по иконке пользователю будет предлагаться изменить фильтр.
		fBkgndImage       = 0x0008, // Элемент имеет привязанный файл изображения. Только для kGroup //
		fBkgndImageLoaded = 0x0010  // @transient Признак того, что при загрузке из хранилища объект содержал изображение. Только для kGroup //
	};
	explicit PPCommandItem(int kind/*= kUndef*/);
	PPCommandItem(const PPCommandItem & rS);
	PPCommandItem & FASTCALL operator = (const PPCommandItem & rS);
	long   GetID() const { return ID; }
	int    GetKind() const { return Kind; }
	bool   IsKind(int k) const { return (static_cast<int>(Kind) == k); }
	virtual ~PPCommandItem();
	virtual int    Write_Deprecated(SBuffer &, long) const;
	virtual int    Read_Deprecated(SBuffer &, long);
	virtual int    Write2(void * pHandler, const long rwFlag) const; // @erik v10.6.1
	virtual int    Read2(const void * pHandler, const long rwFlag); // @erik v10.6.1
	virtual bool   IsEq(const void * pCommand) const; // @erik v10.6.1
	virtual const  PPCommandItem * Next(uint * pPos) const;
	virtual PPCommandItem * Dup() const;
	virtual void   FASTCALL SetUniqueID(long * pID);
	int    FASTCALL Copy(const PPCommandItem &);
	int    Enumerate(CmdItemIterFunc func, long parentID, void * extraPtr) const;
// @todo Теоретически, следующие поля надо бы сделать protected, но первая попытка "захлебнулась" - много неочевидных присваиваний.
// частично я закрыл прямой доступ посредством конструкторов и getter'ов (GetID(), GetKind(), IsKind())
	int16  Kind;
	int16  Flags;
	long   ID;
	SString Name;
	SString Icon;
};

class PPCommand : public PPCommandItem {
public:
	PPCommand();
	virtual int    Write_Deprecated(SBuffer &, long) const;
	virtual int    Read_Deprecated(SBuffer &, long);
	virtual int    Write2(void * pHandler, const long rwFlag) const; // @erik v10.6.1
	virtual int    Read2(const void * pHandler, const long rwFlag); // @erik v10.6.1
	virtual bool   IsEq(const void * pCommand) const; // @erik v10.6.1
	virtual PPCommandItem * Dup() const;
	int    FASTCALL Copy(const PPCommand &);
	long   CmdID;         // Идентификатор дескриптора команды (PPCommandDescr)
	SPoint2S P;             // Позиция левого верхнего угла иконки на рабочем столе
	uint8  Reserve[4];    // @reserve
	mutable SUiLayout::Result LoR; // @v11.0.0 @transient. Функция ранжирования меняет это значение, потому mutable
	SBuffer Param;
};

class PPCommandFolder : public PPCommandItem {
public:
	//
	// Descr: Специализированный список командных групп (меню и/или рабочих столов),
	//   состоящий и ассоциаций GUID'ов и наименований, скомбинированных с 4-байтовым идентификаторами
	//   Проблема, которую призван решить этот контейнер, состоит в том, что многие меню и рабочие
	//   столы имеют дублированные целочисленные идентификаторы наряду с GUID'ами, и до релиза
	//   @v10.9.3 идентификация осуществлялась исключительно по этим идентификаторам, что порождало серьезные проблемы.
	//
	class CommandGroupList : SStrGroup {
	public:
		struct Entry {
			long   SurrID; // Суррогатный гарантированно уникальный ИД
			long   NativeID; // ИД, полученный из источника
			S_GUID Uuid;
			SString Name;
		};

		CommandGroupList();
		uint   GetCount() const;
		CommandGroupList & Z();
		int    Add(long nativeId, const S_GUID & rUuid, const char * pName, long * pSurrID);
		int    Get(uint idx, Entry & rEntry) const;
		long   GetSurrIdByUuid(const S_GUID & rUuid) const;
		S_GUID GetUuidBySurrId(long surrId) const;
		int    SearchByUuid(const S_GUID & rUuid, uint * pIdx) const;
		//
		// Descr: Функция ищет все записи, соответствующие native-ключу id.
		//  Индексы всех найденных записей возвращаются в списке rIdxList.
		// Returns:
		//   >0 - найдена 1 или более записей с native-ключом id
		//   0  - не найдено ни одной записи
		//
		int    SearchByNativeID(long id, LongArray & rIdxList) const;
		int    SearchBySurrID(long id, uint * pIdx) const;
		//
		// Descr: Возвращает список элементов, составленных из суррогатных ключей и идентификаторов.
		// Note: Так как суррогатные ключи имеют значение лишь в области действия текущего экземпляра
		//   объекта CommandGroupList, то для последующего сопоставления суррогатного ключа с другими
		//   атрибутами необходимо сохранить этот экземпляр.
		//
		void   GetStrAssocList(StrAssocArray & rResult) const;
	private:
		struct InnerEntry {
			long   SurrID; // Суррогатный гарантированно уникальный ИД
			long   NativeID; // ИД, полученный из источника
			S_GUID Uuid;
			uint   NameP;  // Ссылка на имя объекта
		};
		PPCommandGroupCategory Kind; // cmdgrpcUndef: everything
		TSVector <InnerEntry> L;
		long   LastSurrID;
	};
	static int GetCommandGroupList(const PPCommandGroup * pGrp, PPCommandGroupCategory kind, CommandGroupList & rResult);

	enum Direction {
		nextUp = 0,
		nextDown,
		nextLeft,
		nextRight
	};
	PPCommandFolder();
	PPCommandFolder(const PPCommandFolder & rS);
	PPCommandFolder & FASTCALL operator = (const PPCommandFolder & rS);
	virtual int    Write_Deprecated(SBuffer &, long) const;
	virtual int    Read_Deprecated(SBuffer &, long);
	virtual int    Write2(void * pHandler, const long rwFlag) const; // @erik v10.6.1
	virtual int    Read2(const void * pHandler, const long rwFlag); // @erik v10.6.1
	virtual bool   IsEq(const void * pCommand) const; // @erik v10.6.1
	virtual const  PPCommandItem * Next(uint * pPos) const;
	virtual PPCommandItem * Dup() const;
	int    FASTCALL Copy(const PPCommandFolder &);
	uint   GetCount() const;
	const  PPCommandItem * Get(uint pos) const;
	const  PPCommandItem * SearchByUuid(const S_GUID & rUuid, uint * pPos) const;
	const  PPCommandItem * SearchByID(long id, uint * pPos) const;
	PPCommandItem * SearchByIDRecursive(long id, long * pParentID);
	const  PPCommandItem * SearchByIDRecursive_Const(long id, long * pParentID) const;
	const  PPCommandItem * SearchByName(const char * pName, const char * pDbSymb, uint * pPos) const;
	const  PPCommandItem * SearchByCoord(SPoint2S coord, const PPDesktop & rD, uint * pPos) const;
	int    SearchFreeCoord(RECT r, const PPDesktop & rD, SPoint2S * pCoord) const;
	const PPCommandItem * SearchNextByCoord(POINT coord, const PPDesktop & rD, Direction next, uint * pPos);
	const PPCommandItem * SearchFirst(uint * pPos);
	int    GetIntersectIDs(SPoint2S coord, const PPDesktop & rD, PPIDArray * pAry);
	int    GetIntersectIDs(const TRect & rR, const PPDesktop & rD, PPIDArray * pAry);
	int    GetIconRect(long id, const PPDesktop & rD, TRect * pRect) const;
	int    Add(int pos, const PPCommandItem * pItem);
	int    AddSeparator(int pos);
	int    Remove(uint pos);
	int    Update(uint pos, const PPCommandItem * pItem);
	long   GetUniqueID() const;
	int    GetCommandList(StrAssocArray * pList, int onlyFolders);
	virtual void FASTCALL SetUniqueID(long * pID);

	TSCollection <PPCommandItem> List;
protected:
	PPCommandFolder(int kind);
};

class PPCommandGroup : public PPCommandFolder {
public:
	PPCommandGroup();
	//
	// Descr: Конструктор создает новый экземпляр объекта с заданными атрибутами.
	//   При этом генерируется новый UUID, то есть этот конструктор нужен именно для
	//   создания нового объекта.
	//   Если cmdgrpc == cmdgrpcDesktop && isempty(pDbSymb) то новый экземпляр
	//   получает символ текущей базы данных (если таковая имеется).
	//
	PPCommandGroup(PPCommandGroupCategory cmdgrpc, const char * pDbSymb, const char * pName);
	PPCommandGroup(const PPCommandGroup &);
	PPCommandGroup & FASTCALL operator = (const PPCommandGroup &);
	virtual int    Write_Deprecated(SBuffer &, long) const;
	virtual int    Read_Deprecated(SBuffer &, long);
	virtual int    Write2(void * pHandler, const long rwFlag) const; // @erik v10.6.1
	virtual int    Read2(const void * pHandler, const long rwFlag); // @erik v10.6.1
	virtual bool   IsEq(const void * pCommand) const; // @erik v10.6.1
	virtual PPCommandItem * Dup() const;
	void   FASTCALL SetDbSymb(const char * pDbSymb);
	int    FASTCALL IsDbSymbEq(const char * pDbSymb) const;
	int    FASTCALL IsDbSymbEq(const PPCommandGroup & rGrp) const;
	int    SetLogo(const char * pPath);
	void   GenerateGuid(); // @erik v10.6.6
	const  S_GUID & FASTCALL GetGuid() const;  // @erik v10.7.3
	const  SString & GetLogo() const;
	int    FASTCALL Copy(const PPCommandGroup &);
	PPCommandGroup * GetGroup(PPCommandGroupCategory kind, const S_GUID & rUuid);
	//void   InitDefaultDesktop(const char * pName);
	int    LoadLogo();
	int    StoreLogo();

	SString DbSymb;
	SString Logo_;
	//
	// GUID - это идентификатор рабочего стола в файловой системе. В рабочих столах, которые хранятся в ppdesk.bin их нет.
	// Генерируются при создании нового рабочего стола и при выгрузке рабочих столов из ppdesk.bin(В функции PPCommandGroup::Read)
	//
	S_GUID Uuid; // @erik v10.6.4
	PPCommandGroupCategory Type; // cmdgrpcDesktop || cmdgrpcMenu @erik v10.7.6
};
//
// Descr: Интерфейс, реализующий функции команд
//
class PPCommandHandler {
public:
	PPCommandHandler(const PPCommandDescr * pDescr);
	virtual ~PPCommandHandler();
	virtual int EditParam(SBuffer * pParam, long iconID, void * extraPtr);
	virtual int Run(SBuffer * pParam, long iconID, void * extraPtr);
protected:
	int    CheckParamBuf(const SBuffer *, size_t neededSize) const;
	PPCommandDescr D;
};

extern "C" typedef PPCommandHandler * (*FN_CMD_FACTORY)(PPCommandDescr *);

#define CMD_HDL_FACTORY(cmdSymb)  CFF_##cmdSymb
#define IMPLEMENT_CMD_HDL_FACTORY(cmdSymb) \
	extern "C" __declspec(dllexport) PPCommandHandler * CFF_##cmdSymb(const PPCommandDescr * pDescr) \
	{ return new CMD_HDL_CLS(cmdSymb)(pDescr); }
#define CMD_HDL_CLS(cmdSymb)      CmdHandler_##cmdSymb
//
// @todo Объединить на уровне базового класса с PPJobDescr
//
class PPCommandMngr {
public:
	//@erik v10.6.1
	// rwFlag - флаг типа документа, в котором должен хранится десктоп
	//
	enum {
		fRWByXml = 1,
		fRWByTxt
	};
	//
	// Descr: Опции создания экземпляра класса
	//
	enum {
		ctrfReadOnly     = 0x0001, // Только для чтения
		ctrfSkipObsolete = 0x0002  // Не открывать устаревший бинарный файл хранения объектов
	};
	PPCommandMngr(const char * pFileName, uint ctrFlags, PPCommandGroupCategory kind);
	~PPCommandMngr();
	int    IsValid_() const;
	int    Load_Deprecated(PPCommandGroup *);
	int    Save__2(const PPCommandGroup *, const long rwFlag); // @erik v10.6.1
	int    Load__2(PPCommandGroup *, const char * pDbSymb, const long rwFlag); // @erik v10.6.1
	int    SaveFromAllTo(const long rwFlag); // @erik v10.7.1
	int    ConvertDesktopTo(const long rwFlag); //@erik v10.7.4
	int    DeleteGroupByUuid(PPCommandGroupCategory kind, const S_GUID & rUuid);
	//
	// Descr: Находит максимальное значение идентификатора среди всех элементов,
	//   доступных для загрузки.
	// Note: Функция очень медленная - вынуждена загружать все, что есть для перебора.
	//
	int    GetMaxEntryID(long * pMaxId);
	static int GetDesksDir(SString & rPath); // @erik v10.6.7
	static int GetMenuDir(SString & rPath); // @erik v10.7.6
private:
	static const SString & InitStoragePath(int kind);
	struct Hdr {
		long   Signature;
		uint32 Crc;
		uint32 IndexOffset;
		char   Reserve[48];
		uint32 Locking;
	};
	const  SString XmlDirPath;
	const  uint CtrFlags;
	enum {
		stError = 0x0001
	};
	uint   Status;
	SFile  F_Obsolete; // @v10.9.3 F-->F_Obsolete
};

PPCommandMngr * GetCommandMngr(uint ctrFlags, PPCommandGroupCategory kind, const char * pPath = 0);
//
// @ModuleDecl(PPJob)
//

//
// Descr: Дескриптор задачи.
//   Определяет задачу ВНЕ КОНТЕКСТА базы данных, времени исполнения и параметров.
//
struct PPJobDescr { // @persistent
	enum {
		fNoParam = 0x0001, // Задание не имеет параметров
		fNoLogin = 0x0002  // Для выполнения задания не требуется авторизоваться в базе данных
	};
	static const char * P_FactoryPrfx;

	PPJobDescr();
	SString & FASTCALL GetFactoryFuncName(SString &) const;
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);
	int    FASTCALL Write2(xmlTextWriter * pXmlWriter) const; //@erik v10.7.1
	int    FASTCALL Read2(const xmlNode * pParentNode); //@erik v10.7.1

	long   CmdID;
	long   Flags;
	char   Reserve[32];
	SString Symb;
	SString Text;
};
//
// Descr: Задача, конкретизированная относительно базы данных и расписания.
//
class PPJob : public PPExtStrContainer { // @persistent
public:
	PPJob();
	PPJob(const PPJob & rS);
	PPJob & FASTCALL operator = (const PPJob &);
	// @v12.3.1 (@obsolete) int    FASTCALL Write(SBuffer & rBuf);
	// @v12.3.1 (@obsolete) int    FASTCALL Read(SBuffer & rBuf);
	int    FASTCALL Write2(xmlTextWriter * pXmlWriter) const; //@erik v10.7.1
	int    FASTCALL Read2(const xmlNode * pParentNode); //@erik v10.7.1
	enum {
		fV579          = 0x0001,
		fNotifyByMail  = 0x0002, //
		fDisable       = 0x0004, // Задача не должна запускаться //
		fOnStartUp     = 0x0008, // Задачу запускать при запуске сервера
		fPermanent     = 0x0010, // Перманентая задача (запускается один раз и постоянно работает)
		fUnSheduled    = 0x0020, // Непланируемая по времени задача. Такая задача исполняется либо при запуске,
			// либо после другой задачи, либо вообще не исполняется.
		fSkipEmptyNotification = 0x0040  // Не отсылать уведомления, если журналы пустые
	};
	enum {
		extssEMailAddrList  = 1, // Список e-mail адресов для отсылки почтовых извещений о состоянии выполнения задачи
		extssEMailSubj      = 2  // Тема e-mail сообщения. Если пусто, то формируется автоматически
	};
	PPID   ID;
	SString Name;
	SString DbSymb;
	PPJobDescr Descr;
	DateTimeRepeating Dtr;     // План повторений запуска
	long   Flags;              //
	long   EstimatedTime;      // Ожидаемое время исполнения (sec).
	LDATETIME LastRunningTime; // Время последнего запуска работы (0 - не запускалась)
	long   Ver;                // Номер версии хранимой копии задачи
	PPID   NextJobID;          // Задача запускаемая в случае успешного выполнения текущей задачи
	char   Symb[20];           // Уникальный (или пустой) символ задачи
	PPID   EmailAccID;         // Учетная запись электронной почты
	LTIME  ScheduleBeforeTime; // Время, после которого задачу выполнять не следует
	char   Reserve[4];         // @reserve
	SBuffer Param;
};
//
// Descr: Интерфейс, реализующий функции задачи
//
class PPJobHandler {
public:
	PPJobHandler(const PPJobDescr * pDescr);
	virtual ~PPJobHandler();
	virtual int EditParam(SBuffer * pParam, void * extraPtr);
	virtual int Run(SBuffer * pParam, void * extraPtr);
	virtual const PPJobDescr & GetDescr();
	void   SetJobDbSymb(const char * pJobDbSymb);
protected:
	int    CheckParamBuf(const SBuffer *, size_t neededSize) const;
private:
	PPJobDescr D;
protected:
	SString JobDbSymb; // @v11.0.0 @transient @crutch Символ базы данных, к которой привязана задача,
		// передаваемый перед вызовом EditParam() и Run().
		// Включен ради единственной (возможно, пока) задачи резервного копирования, в которой иногда возникает
		// коллизия, связанная с тем, что параметры задачи редактируются из сеанса, авторизованного не в той базе
		// которая должна копироваться.
};

extern "C" typedef PPJobHandler * (*FN_JOB_FACTORY)(PPJobDescr *);

#define JOB_HDL_FACTORY(jobSymb)  JFF_##jobSymb
#define IMPLEMENT_JOB_HDL_FACTORY(jobSymb) \
	extern "C" __declspec(dllexport) PPJobHandler * JFF_##jobSymb(PPJobDescr * pDescr) { return new JOB_HDL_CLS(jobSymb)(pDescr); }
#define JOB_HDL_CLS(jobSymb)      JobHandler_##jobSymb
//
// Descr: Пул задач. Хранит задачи, конкретизированные относительно базы данных
//   и расписания.
//
class PPJobPool : private TSCollection <PPJob> {
public:
	friend class PPJobMngr;

	PPJobPool(PPJobMngr * pMngr, const char * pDbSymb, int readOnly);
	const  SString & GetDbSymb() const;
	bool   FASTCALL IsJobSuited(const PPJob *) const;
	uint   GetCount() const;
	int    CheckUniqueJob(const PPJob * pJob) const;
	//
	// Descr: Извлекает задачу с идентификатором, следующим за *pID.
	//   Используется для перечисления задач в цикле.
	// ARG(pID      IN/OUT): @#{vptr} Указатель на идентификатор задачи,
	//   непосредственно предшествующий тому, который будет извлечен функцией.
	//   Если требуемая задача найдена, то по этому указателю присваивается значение идентификатора такой задачи.
	// ARG(pJob        OUT): @#{vptr0} Указатель по которому будет присвоено найденное задание.
	// ARG(ignoreDbSymb IN): Если этот аргумент равен нулю, то перечисляются только
	//   те задания, которые принадлежат базе данных с символом DbSymb. В противном
	//   случае проверка на символ базы данных не осуществляется.
	// Returns:
	//   >0 - найдено очередное задание.
	//   0  - нет больше ни одного задания, идентификатор которого был бы более
	//      *pID и удловлеворяющего необходимым критериям.
	//
	int    Enum(PPID * pID, PPJob * pJob, bool ignoreDbSymb = false) const;
	const  PPJob * GetJobItem(PPID id, bool ignoreDbSymb = false) const; // @v10.8.3 GetJob-->GetJobItem с целью исключить совпадение по имени с функцией WinAPI GetJob
	int    PutJobItem(PPID * pID, const PPJob * pJob);
private:
	enum {
		fReadOnly = 0x0001 // пул только для чтения //
	};
	long   Flags;
	SString DbSymb; // база данных, к которой относятся задачи пула
	PPJobMngr * P_Mngr; // @notowned
};
//
// Descr: Управляет ресурсами задач и пулами задач
//
class PPJobMngr {
public:
	//@erik v10.7.1
	// rwFlag - флаг типа документа, в котором должен хранится десктоп
	//
	//enum {
	//	fRWByXml = 1,
	//	fRWByTxt
	//};

	PPJobMngr();
	~PPJobMngr();
	int    LoadResource(PPID jobID, PPJobDescr * pJob);
	int    GetResourceList(int loadText, StrAssocArray & rList);
	// @v12.3.1 (@obsolete) int    SavePool(const PPJobPool *);
	int    LoadPool2(const char * pDbSymb, PPJobPool *, bool readOnly); //@erik v10.7.4
	int    SavePool2(const PPJobPool *); //@erik v10.7.4
	int    IsPoolChanged() const;
	DirChangeNotification * CreateDcn();
	PPJobHandler * CreateInstance(PPID jobID, const PPJobDescr * pDescr);
	int    DoJob(PPJob & rJob);
	int    EditJobParam(PPJob & rJob); // @v11.0.0 Изменился список параметров
	long   AcquireNewId();
	void   FASTCALL UpdateLastId(long id);
	const  SString & GetFileName() const { return XmlFilePath; }
private:
	// @v12.3.1 (@obsolete) int    LoadPool(const char * pDbSymb, PPJobPool *, int readOnly); // @obsolete function. Used only for convertation.
	// @v12.3.1 (@obsolete) int    Helper_ReadHeader(SFile & rF, void * pHdr, int lockMode);
	// @v12.3.1 (@obsolete) int    CreatePool();
	void   CloseFile();
	int    GetXmlPoolDir(SString & rXmlPoolPath); //@erik v10.7.4
	// Выполняется если ни одна задача еще не была сохранена в xml формате
	// @v12.3.1 (@obsolete) int    ConvertBinToXml();

	TVRez  * P_Rez;
	// Путь к файлу, в котором хранится пул задач. Мы сохраняем этот
	//   путь в переменной потому что при обработке задач все нужно делать очень быстро.
	// @v12.3.1 (@obsolete) SString FilePath; // @*PPJobMngr::PPJobMngr
	SString XmlFilePath; //@erik v10.7.4
	LDATETIME LastLoading; // Время последнего вызова функции LoadPool. Используется для определения факта изменения файла пула с момена последней загрузки
	long   LastId; // @persistent Используется для присвоения уникального идентификатора новым задачам
	int    LckH;   // @transient  Дескриптор блокировки заголовка файла
	// @v12.3.1 (@obsolete) SFile * P_F;   // Файл, из которого считаны данные в режиме 'на запись'. Если данные извлекаются только для чтения,
	PPSync Sync;//@erik v10.7.4
};
//
// @ModuleDecl(PPNamedFilt)
//
class PPNamedFilt {
public:
	class ViewDefinition : public SStrGroup {
	public:
		friend class PPNamedFilt;
		struct Entry { // @transient
			Entry();
			Entry & Z();
			bool   FASTCALL IsEq(const Entry & rS) const;

			SString Zone;
			SString FieldName;
			SString Text;
			int32  TotalFunc; // AGGRFUNC_XXX
			TYPEID DataType;  // @v11.4.2 0 или автоматически извлекается из DL600
			int32  Format;    // @v11.4.2 Если DataType определен, то формат задается пользователем
			int32  Format2;   // @v11.4.2 Если DataType определен, то в этом поле задается дополнительное значение формата 
				// Сейчас, это формат времени для TIMESTAMP (формат даты при этом идет в Format)
		};
		ViewDefinition();
		bool   FASTCALL IsEq(const ViewDefinition & rS) const;
		uint   GetCount() const;
		const  SString & GetStrucSymb() const;
		void   SetStrucSymb(const char * pSymb);
		int    GetEntry(uint pos, Entry & rE) const;
		int    SetEntry(const Entry & rE);
		int    XmlRead(const xmlNode * pParentNode); //@erik v10.7.5
		int    XmlWrite(xmlTextWriter * pXmlWriter) const; //@erik v10.7.5
		int    RemoveEntryByPos(uint pos);
		int    XmlWriter(void * param);
		int    Swap(uint p1, uint p2);
	private:
		struct InnerEntry { // @persistent
			uint32 ZoneP;
			uint32 FieldNameP;
			uint32 TextP;
			int32  TotalFunc;
			TYPEID DataType;  // @v11.4.2 0 или автоматически извлекается из DL600
			int32  Format;    // @v11.4.2 Если DataType определен, то формат задается пользователем
			int32  Format2;   // @v11.4.2 Если DataType определен, то в этом поле задается дополнительное значение формата 
				// Сейчас, это формат времени для TIMESTAMP (формат даты при этом идет в Format)
			uint8  Reserve[4]; // @reserve // @v11.4.2 [16]-->[4]
		};
		int    SearchEntry(const char * pZone, const char * pFieldName, uint * pPos, InnerEntry * pInneEntry) const;
		TSVector <InnerEntry> L;
		SString StrucSymb; // Наименование структуры DL600 для формирования данных
	};

	static int EditRestrictedViewDefinitionList(PPNamedFilt::ViewDefinition & rData);

	PPNamedFilt();
	~PPNamedFilt();
	PPNamedFilt & FASTCALL operator = (const PPNamedFilt &);
	//
	// Descr: Записать данные класса в буфер
	//
	int    Write(SBuffer & rBuf, long);// @erik v10.5.0 const -> notConst
	//
	// Descr: Прочитать из буфера данные и спроецировать на класс
	//
	int    Read(SBuffer & rBuf, long);
	int    Write2(xmlTextWriter * pXmlWriter);//@erik v10.7.5
	int    Read2(const xmlNode * pParentNode);//@erik v10.7.5
	int    XmlWriteGuaList(xmlTextWriter * pXmlWriter); //@erik v10.7.5
	int    ReadGuaListFromStr(SString & rGuaListInStr);//@erik v10.7.5

	enum {
		fDontWriteXmlDTD = 0x0001, // В исходящий XML-файле на писать DTD
		fCompressXml     = 0x0002  // Сжимать создаваемый xml-файл
	};
	PPID   ID;          // Уникальный идентификатор фильтра внутри пула
	long   Ver;         // Номер версии хранимой копии именованного фильтра
    long   ViewID;      // Идентификатор обьекта PPView, по которому строится фильтр
    long   Flags;       // @flags
	char   Reserve[28]; // @reserve
	SString Name;       // Уникальная строка описания именованного фильтра
	SString DbSymb;     // Символ базы данных, относительно которой определен именованный фильтр
	SString Symb;       // Уникальная (непустая) строка символа именованного фильтра
	SString ViewSymb;   // Строка символа объекта PPView, по которому строится фильтр
	SBuffer Param;      // Хранит данные о настройках фильтра PPBaseFilt
	ViewDefinition VD;  //
	ObjIdListFilt DestGuaList; // Список идентификаторов глобальных учетных записей, которым следует отправлять отчеты
};
//
// Descr: Пул именованных фильтров. Хранит фильтры, конкретизированные относительно базы данных
//
class PPNamedFiltPool : private TSCollection <PPNamedFilt> {
public:
	friend class PPNamedFiltMngr;

	PPNamedFiltPool(const char * pDbSymb, int readOnly);
	const  SString & GetDbSymb() const;
	//
	// Descr: Проверяет, относится ли именованный фильтр к данной БД
	// Returns:
	//	>0	-	Фильтр относится к этой БД
	//	0	-	Фильтр относится к другой БД
	//
	int    IsNamedFiltSuited(const PPNamedFilt *) const;
	uint   GetCount() const;
	//
	// Descr: Проверяет пул на существование похожих фильтров
	// Returns:
	//	>0	-	В пуле нет фильтров, совпадающих по имени и/или символу
	//			с заданным и имеющих другой id
	//	0	-	Существует фильтр, совпадающий по имени и/или символу
	//			с заданным и имеющий другой id
	//
	int    CheckUniqueNamedFilt(const PPNamedFilt * pNamedFilt) const;
	//
	// Descr: Извлекает фильтр с идентификатором, следующим за *pID.
	//   Используется для перечисления фильтров в цикле.
	// ARG(pID      IN/OUT): @#{vptr} Указатель на идентификатор фильтра, непосредственно
	//   предшествующий тому, который будет извлечен функцией.
	//   Если требуемый фильтр найден, то по этому указателю присваивается значение
	//   идентификатора такого фильтра.
	// ARG(pNamedFilt        OUT): @#{vptr0} Указатель по которому будет присвоен
	//   найденный фильтр.
	// ARG(ignoreDbSymb IN): Если этот аргумент равен нулю, то перечисляются только
	//   те фильтры, которые принадлежат базе данных с символом DbSymb. В противном
	//   случае проверка на символ базы данных не осуществляется.
	// Returns:
	//   >0 - найден очередной фильтр.
	//   0  - нет больше ни одного фильтра, идентификатор которого был бы более
	//      *pID и удовлеворяющего необходимым критериям.
	//
	int    Enum(PPID * pID, PPNamedFilt * pNamedFilt, int ignoreDbSymb = 0) const;
	//
	// Descr: Получает фильтр с идентификатором *pID из пула
	// ARG(id			IN): идентификатор
	// ARG(ignoreDbSymb	IN): если !0 то игнорировать принадлежность к базе данных
	// Returns:
	//	0  - не найдено фильтров, удовлетворяющих необходимым критериям
	//
	const  PPNamedFilt * GetByID(PPID id, int ignoreDbSymb = 0) const;
	const  PPNamedFilt * GetBySymb(const char * pSymb, int ignoreDbSymb = 0) const;
	//
	// Descr: Помещает фильтр в пул
	//
	// Returns:
	//	>0	-	фильтр с таким id уже существовал и был успешно заменен
	//	0	-	произошла ошибка
	//	<0	-	фильтр была добавлен в пул
	//
	int    PutNamedFilt(PPID * pID, const PPNamedFilt * pNamedFilt);
private:
	enum {
		fReadOnly = 0x0001 // пул только для чтения //
	};
	long   Flags;
	SString DbSymb; // база данных, к которой относятся фильтры пула
};
//
// Descr: Управляет ресурсами фильтров, и пулами фильтров
//
class PPNamedFiltMngr {
public:
	PPNamedFiltMngr();
	~PPNamedFiltMngr();
	//
	// Descr: Получить данные об объекте PPView
	// ARG(viewId  IN): идентификатор объекта PPView
	// ARG(symb   OUT): строка символа
	// ARG(text   OUT): строка описани
	// ARG(pFlags OUT): флаги
	// Returns:
	//	>0 - успешно
	//  0  - ошибка
	//
	// @v11.4.4 int    LoadResource(PPID viewId, SString & symb, SString & text, /*long * pFlags,*/const void ** ppExtraInitPtr) const;
	//
	// Descr: Загрузить список ассоциаций обьектов PPView в два списка
	// ARG(pSymbList OUT): Список ассоциаций объектов PPView {id, строка символа}
	// ARG(pTextList OUT): Список ассоциаций объектов PPView {id, строка описания}, упорядочен по описанию
	// Returns:
	//  >0 - успешно
	//	0  - ошибка
	//
	// @v11.4.4 int    GetResourceLists(bool includeSpecialItems, StrAssocArray * pSymbList, StrAssocArray * pTextList) const;
	//
	// Descr: Прочитать пул фильтров из файла
	// ARG(pDbSymb	IN): символ базы данных, который будет присвоен прочитанному пулу
	// ARG(*	   OUT): пул фильтров
	// ARG(readOnly	IN): флаг "пул только для чтения", который будет присвоен прочитанному пулу
	// Returns:
	//  >0 - успешно
	//	0  - ошибка
	//
	int    LoadPool(const char * pDbSymb, PPNamedFiltPool *, int readOnly);
	//
	// Descr: Сохранить пул фильтров в файл
	// ARG(*	IN): пул для сохранени
	// Returns:
	//	>0 - успешно
	//  0  - ошибка
	//
	int    SavePool(const PPNamedFiltPool *) const;
	int    LoadPool2(const char * pDbSymb, PPNamedFiltPool *, bool readOnly); //@erik v10.7.5
	int    SavePool2(const PPNamedFiltPool *) const;  //@erik v10.7.5
	int    ConvertBinToXml(); //@erik v10.7.5
	int    GetXmlPoolDir(SString &rXmlPoolPath); //@erik v10.7.4
private:
	// @v11.4.4 TVRez  * P_Rez;
	// Путь к файлу, в котором хранится пул фильтров. Мы сохраняем этот
	// путь в переменной потому, что при обработке фильтров все нужно делать
	// очень быстро.
	SString FilePath; // @*PPNamedFiltMngr::PPNamedFiltMngr
	SString XmlFilePath; //@erik v10.7.4
	// Время последнего вызова функции LoadPool
	//  Используется для определения факта изменения файла пула
	//  с момента последней загрузки
	LDATETIME LastLoading;
};
//
// PPObjListWindow & PPObjBrowser flags
//
#define OLW_CANINSERT          0x0001
#define OLW_CANDELETE          0x0002
#define OLW_CANEDIT            0x0004
#define OLW_SORTBYTEXT         0x0008
#define OLW_CANSELUPLEVEL      0x0010 // Позволяет выбирать элемент, имеющий подуровни
#define OLW_SHOWPASSIVE        0x0020 // Показывать пассивные объекты (работает только для объектов, поддерживающих признак пассивности)
#define OLW_SETUPSINGLE        0x0040 // Если в списке всего один элемент, и вызывающая функция не указала явно, какой элемент устанавливать в комбо-бокс, то устанавливается единственный.
#define OLW_LOADDEFONOPEN      0x0080 // Загружает данные для списка при первом открытии
#define OLW_WORDSELECTOR       0x0100 // При поиске отображать список строк, удовлетворяющих строке поиска
#define OLW_OUTERLIST          0x0200 // Данные для списка были приложены к PPObjListWindow при создании экземпляра - не следует перестраивать список при изменении элемента.
#define OLW_INSCONTEXTEDITEMS  0x0400 // @v11.1.10 Добавить в список контекстные значения //
//
// Строки соответствующие SubstGrpPersonEvent: PPTXT_SUBSTPSNEVLIST
//
enum SubstGrpPersonEvent {
	sgpeNone = 0,
	sgpeOp,            // Операция   //
	sgpePerson,        // Персоналия //
	sgpeCntrAg         // Контрагент //
};

int    ShrinkSubstDate(SubstGrpDate sgd, LDATE orgDt, LDATE * pDestDt);
int    ShrinkSubstDateExt(SubstGrpDate sgd, LDATE orgDt, LTIME orgTm, LDATE * pDestDt, LTIME * pDestTm);
int    ExpandSubstDate(SubstGrpDate sgd, LDATE dt, DateRange *);
int    ExpandSubstDateExt(SubstGrpDate sgd, LDATE dt, LTIME tm, DateRange * pPeriod, TimeRange * pTmPeriod);
int    AdjustPeriodToSubst(SubstGrpDate sgd, DateRange *);
void   FormatSubstDate(SubstGrpDate sgd, LDATE dt, SString & rBuf, long fmt = 0);
void   FormatSubstDate(SubstGrpDate sgd, LDATE dt, char * pBuf, size_t bufLen, long fmt = 0);
void   FormatSubstDateExt(SubstGrpDate sgd, LDATE dt, LTIME tm, SString & rBuf, long dtFmt = 0, long tmFmt = 0);

struct PPCommObjEntry {
	enum {
		fPassive      = 0x0001,
		fHierarchical = 0x0002  // Только для типов динамических объектов: записи допускают иерархию
	};
	explicit PPCommObjEntry(PPID objType = 0, PPID id = 0, const char * pName = 0, const char * pSymb = 0, long flags = 0);

	PPID   ObjType;
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	long   Flags;      // Проецируется на Reference2Tbl::Rec::Val1
	long   ParentID;   // Проецируется на Reference2Tbl::Rec::Val2
};
//
//
//
class PPObjReference : public PPObject {
public:
	//
	// Descr: Диалог редактирования простого элемента справочника
	// Return:
	//   >0 - OK
	//   <0 - CANCEL
	//   0  - ERROR
	//
	static int EditCommObjItem(PPCommObjEntry *);
	PPObjReference(PPID aObj, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  Search(PPID id, void * pRec = 0);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual int  MakeReserved(long flags);
	int    EnumItems(PPID * pID, void * pRec = 0);
	//
	// Descr: Стандартный енумератор.
	// Note: Просто вызывает енумератор Reference::Enum(Obj, options)
	// ARG(options IN): Опции перечисления Reference::eoXXX
	//
	SEnum::Imp * FASTCALL Enum(int options);
	SEnum::Imp * EnumByIdxVal(int valN, long val);
	int    SearchByName(const char *, PPID *, void * = 0);
	int    SearchBySymb(const char * pSymb, PPID * pID, void * pRec = 0);
	int    CheckDupName(PPID objID, const char * pName);
	int    CheckDupSymb(PPID objID, const char * pSymb);
	//
	// Descr: Проверяет имя pName обекта id. Если имя пустое или в базе данных
	//   уже есть объект с таким именем, но идентификатором, отличным от id, то
	//   возвращает нулевое значение.
	// ARG(id     IN): идентификатор записи, которой принадлежит имя //
	//   Если id == 0, то это означает новую запись.
	// ARG(pName  IN): проверяемое имя.
	// ARG(silent IN): если этот параметр нулевой, то функция вызывает PPError().
	//   В противном случае просто устанавливается код ошибки в переменную PPErrCode.
	// Returns:
	//   !0 - наименование объекта является допустимым
	//   0  - наименование объекта недопустимое
	//
	int    CheckName(PPID id, const char * pName, int silent);
	PPID   GetSingle();
	int    UpdateItem(PPID id, const void * pRec, int use_ta);
	int    AddItem(PPID * pID, void * pRec, int use_ta);
protected:
	virtual const char * GetNamePtr();
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  ProcessReservedItem(TVRez &);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	//
	// Descr: Функция, идентифицирующая факт эквивалентности записей rR1 и rR2.
	//   Реализация по умолчанию сравнивает каждое поля ReferenceTbl::Rec. Однако, порожденные
	//   классы могут по разному использовать некоторые поля записи, по этому, должны реализовать
	//   метод для корректного определения являются ли записи равными.
	//   Используется в методах Write и UpdateItem
	// Returns:
	//   >0 - записи rR1 и rR2 эквивалентны
	//   0  - записи rR1 и rR2 не эквивалентны
	//
	virtual int  IsRecEq(const ReferenceTbl::Rec & rR1, const ReferenceTbl::Rec & rR2);
	int    StoreItem(PPID obj, PPID id, void * rec, int use_ta);
	int    LoadReservedItems(uint rezID);
	int    Serialize_(int dir, ReferenceTbl::Rec * pPack, void * stream, ObjTransmContext * pCtx);
public:
	void * ExtraPtr;
	Reference * P_Ref; // Equal to extern PPRef
};
//
// @ModuleDecl(PPObjDynamicObjs)
// Управляет динамически создаваемыми типами объектов данных
//
//
// Descr: Запись 'лемента динамического объекта
//
struct PPDynanicObjItem { // @persistent @store(Reference2Tbl+)
	long   ObjType;        // ->Ref(PPOBJ_DYNAMICOBJS)
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	uint8  ExtData[64];    //
	long   Flags;          //
	long   ParentID;       //
};

class PPObjDynamicObjs : public PPObjReference {
public:
	// static int ReplaceObjs(PPID srcID = 0);
	explicit PPObjDynamicObjs(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
private:
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
};
//
// @ModuleDecl(PPObjTag)
//
#define OBJTAG_ONLYGROUP -1L
#define OBJTAG_ONLYTAGS  -2L

struct ObjTagFilt {
	enum {
		fOnlyGroups   = 0x0001, // Только группы тегов
		fOnlyTags     = 0x0002, // Только терминальные теги
		// @#{fOnlyGroups^fOnlyTags}
		fAnyObjects   = 0x0004, // Исторически ObjTypeID == 0 трактуется как ObjTypeID = PPOBJ_PERSON,
			// по этому, чтобы получить теги по всем типам объектов необходимо установить данный флаг.
		fObjTypeRoots = 0x0008  // Добавить узлы, соответствующие типам объектов.
			// Идентификаторы узлов формируются по следующему правилу: ObjType * 100000
	};

#define TAG_OBJTYPEROOT_MULT 100000

	static long    FASTCALL MakeObjTypeRootIdent(PPID objType);
	static int     FASTCALL ObjTypeRootIdentToObjType(long rootIdent, PPID * pObjType);
	explicit ObjTagFilt(PPID objTypeID = 0, long flags = 0, PPID parentID = 0);
	ObjTagFilt & Z();

	PPID   ObjTypeID;  // Тип связанного объекта данных
	PPID   ParentID;   // Группа тегов
	long   Flags;      //
};

class PPObjTag : public PPObjReference {
public:
	static int     CheckForTagFilt(PPID objType, PPID objID, const TagFilt * pFilt);
	//
	// Descr: Вспомогательная функция для извлечения тега объекта {objType; objID}
	//   по символу типа тега pTagSymb и присвоения его суррогатному идентификатору,
	//   который и возвращается функцией.
	//   Используется только в методах PPALDD_XXX::EvaluateFunc().
	//
	static PPID    Helper_GetTag(PPID objType, PPID objID, const char * pTagSymb);
	static PPID    Helper_GetTagByID(PPID objType, PPID objID, PPID tagID);
	static int     RecoverLostUnifiedLinks();
	//
	// Descr: Удаляет теги, принадлежащие несуществующим объектам данных.
	//
	static int     RecoverHungedUpTags(); // @v12.2.5
	explicit PPObjTag(void * extraPtr = 0);
	~PPObjTag();
	virtual int  Edit(PPID *, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    CheckForFilt(const ObjTagFilt * pFilt, const PPObjectTag & rRec) const;
	int    GetObjListByFilt(PPID objType, const TagFilt * pFilt, UintHashTable & rList, UintHashTable & rExcludeList);
	int    GetPacket(PPID id, PPObjTagPacket *);
	int    PutPacket(PPID * pID, PPObjTagPacket *, int use_ta);
	//
	// Descr: создает список тегов с родителем parent. Если задан текущий элемент списка
	//   current, то значение parent замещается на элемент, являющийся родителем для current.
	//   Если parent < 0, то выбираются только группы, но не сами теги.
	//
	SArray * CreateList(long current, long parent);
	int    GetListByFlag(long mask, PPIDArray & rList);
	int    GetListByHotKey(uint32 keyCode, PPID objType, PPIDArray & rList); // @v11.2.8
	int    NormalizeTextCriterion(PPID tagID, const char * pCrit, SString & rNormCrit);
	//
	// Descr: Возвращает информацию о тегах, которые отсутствуют в списке pTagList либо
	//   имеют недопустимое значение. Типы тегов, для которых проверяется условие определяется //
	//   по наличию у тега флага OTF_WARNZERO.
	// ARG(pTagList     IN): @#{vptr0} Список тегов, для которых проверяеются условия //
	// ARG(pResultList OUT): @#{vptr0} Список ассоциация {tag, message} в котором перечиляются //
	//   отсутствующие или имеющие недопустимое значени теги и соответствующие им сообщения.
	// ARG(pInfoList   OUT): @#{vptr0} Список ассоциация {tag, value} в котором перечисляются //
	//   соответсвующие условиям проверки теги и их значения (в текстовом виде)
	// Returns:
	//   >0 - обнаружена по крайней мере одна проблема
	//   <0 - все теги удовлетворяют условиям
	//    0 - error
	//
	int    GetWarnList(const ObjTagList * pTagList, StrAssocArray * pResultList, StrAssocArray * pInfoList);
	int    Fetch(PPID, PPObjectTag *);
	//
	// Descr: Находит идентификатор типа тега по символу. Функция работает очень быстро благодаря кэшированию.
	//
	int    FetchBySymb(const char * pSymb, PPID * pID);
	//
	// Descr: Функция определяет является ли тег "неотражаемым" в контексте лотов.
	//   Под "неотражаемостью" подразумевается требование не переносить тег на
	//   заркальные лоты при внутреннем перемещении товара.
	// Returns:
	//   !0 - тег неотражаемый
	//   0  - тег отражаемый (может и должен быть перенесен на зеркальный лот при внутреннем перемещении товара)
	//
	bool   FASTCALL IsUnmirrored(PPID tagID) const
	{
		return oneof3(tagID, PPTAG_LOT_FSRARINFA, PPTAG_LOT_FSRARINFB, PPTAG_LOT_VETIS_UUID);
	}
	int    GetCurrTagVal(const ObjTagItem * pItem, SString & rBuf);
	int    FetchTag(PPID objID, PPID tagID, ObjTagItem * pItem);
	int    DirtyTag(PPID objType, PPID objID, PPID tagID);
protected:
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual int  Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
public: // MakeReserve этого класса необходима для конфигурационных функций
	virtual int  MakeReserved(long flags);
private:
	ObjTagFilt & InitFilt(void * extraPtr, ObjTagFilt & rFilt) const;
	int    Helper_CreateEnumObject(PPObjTagPacket & rPack);
};
//
// Descr: Объект данных, представляющий типы системных событий.
//   Объект фантомный. То есть, физически записи в базе данных не хранятся (начиная с v6.0.0).
//   Все записи извлекаются из ресурса строк PPSTR_ACTION.
//   Последняя запись имеет ID = PPACN_LAST
//
class PPObjSysAction : public PPObjReference {
public:
	PPObjSysAction(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr); // Ничего не делает
	virtual int  Search(PPID, void * = 0);
private:
	virtual int  Remove(PPID id, long, uint options); // Ничего не делает
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual const char * GetNamePtr();

	SString NameBuf; // Is returned by GetNamePtr
};
//
//
//
class PPEventCore : public EventTbl {
public:
	enum {
		statusUndef    = 0,
		statusActual   = 1,
		statusViewed   = 2,
		statusArchived = 3
	};
	struct Packet {
		Packet();
		Packet & Z();
		PPID   ID;
		LDATETIME Dtm;
		long   EventType;
		long   Status;
		PPID   UserID;
		PPID   GlobalUserID;
		PPID   EvSubscrID;
		PPObjID Oid;
		long   Flags;
		SString Text;
		SBuffer ExtData;
	};
	PPEventCore();
	int    Put(PPID * pID, const Packet * pPack, int use_ta);
	int    Get(PPID id, Packet * pPack);
private:
	void   PacketToRec(const Packet & rPack, EventTbl::Rec & rRec) const;
	void   RecToPacket(const EventTbl::Rec & rRec, Packet & rPack) const;
};
//
//
//
struct PPEventSubscription {
	PPEventSubscription();
	int    FASTCALL IsEq(const PPEventSubscription & rS) const;
	long   Tag;                  // Const=PPOBJ_EVENTSUBSCRIPTION
	long   ID;                   // @id
	char   Name[48];             // @name @!refname
	char   Symb[20];             //
	long   Flags;                //
	PPID   ObjType;              // Тип объекта, ассоциированный с событием (для некоторых типов событий)
	SColor NotifColor;           // Цвет мини-окна с уведомлением
	long   MinDetectionInterval; // Минимальный временной интервал между попытками детекта событий (sec).
	char   Reserve[48];          // @reserve
	PPID   EventType;            //
	PPID   Reserve2;             //
};

class PPEventSubscriptionPacket : public PPExtStrContainer {
public:
	enum {
		extssMessage  = 1,
	};
	PPEventSubscriptionPacket();
	PPEventSubscriptionPacket(const PPEventSubscriptionPacket & rS);
	~PPEventSubscriptionPacket();
	PPEventSubscriptionPacket & FASTCALL operator = (const PPEventSubscriptionPacket & rS);
	int    FASTCALL Copy(const PPEventSubscriptionPacket & rS);
	int    FASTCALL IsEq(const PPEventSubscriptionPacket & rS) const;
	PPEventSubscription Rec;
	PPBaseFilt * P_Filt;
	ObjIdListFilt GuaList;
	ObjIdListFilt UserList;
};

class PPObjEventSubscription : public PPObjReference { // PPOBJ_EVENTSUBSCRIPTION
public:
	explicit PPObjEventSubscription(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPEventSubscriptionPacket * pPack);
	int    EditDialog(PPEventSubscriptionPacket * pPack);
	int    SerializePacket(int dir, PPEventSubscriptionPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    PutPacket(PPID * pID, PPEventSubscriptionPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPEventSubscriptionPacket * pPack);
	int    Run();
private:
	int    SerializePacket_WithoutRec(int dir, PPEventSubscriptionPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Detect(PPID id, TSCollection <PPEventCore::Packet> & rEvpList);
};
//
//
//
struct EventFilt : public PPBaseFilt {
	EventFilt();

	uint8  ReserveStart[128]; // @anchor
	DateRange Period;
	long   EventType;
	PPID   UserID;
	PPID   GlobalUserID;
	PPID   ObjType;
	PPID   EventSubscrID;
	long   StatusFlags;
	long   Flags;
	long   SortOrd;
	long   Reserve;          // @anchor
};

struct EventViewItem { // @flat
	PPID   ID;
	LDATETIME Dtm;
	long   TimeUniqCntr;
	long   EventType;
	long   Status;
	long   UserID;         // 0 - for all
	long   GlobalUserID;   // 0 - for all
	PPID   EventSubscrID;
	PPObjID Oid;
	long   Flags;
};

class PPViewEvent : public PPView {
public:
	struct BrwItem : public EventViewItem { // @flat
		uint   TextP;
		uint   ObjNameP;
	};
	PPViewEvent();
	~PPViewEvent();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(EventViewItem *);
	int    CheckForFilt(const EventFilt * pFilt, EventTbl::Rec * pRec);
	int    CmpSortIndexItems(PPViewBrowser * pBrw, const PPViewEvent::BrwItem * pItem1, const PPViewEvent::BrwItem * pItem2);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList(PPViewBrowser * pBrw);
	int    EditObj(const PPObjID * pObjID);
	int    SelectStatus(PPID evID);

	PPEventCore T;
	PPObjEventSubscription EsObj;
	SArray * P_DsList;
	ObjCollection * P_ObjColl;
	ObjIdListFilt SubscrList;
	SStrGroup StrPool;
	EventFilt Filt;
	TSVector <PPObjNamePEntry> ObjNameList;
};
//
// Descr: Объект данных, представляющий типы системных событий.
//   Объект фантомный. То есть, физически записи в базе данных не хранятся.
//   Все записи извлекаются из ресурса строк PPSTR_GTA.
//   Последняя запись имеет ID = PPGTA_LAST
//
class PPObjGtaAction : public PPObjReference {
public:
	PPObjGtaAction(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr); // Ничего не делает
	virtual int  Search(PPID, void * = 0);
private:
	virtual int  Remove(PPID id, long, uint options); // Ничего не делает
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual const char * GetNamePtr();

	SString NameBuf; // Is returned by GetNamePtr
};
//
// @ModuleDecl(PPObjUnit)
// Единицы измерения //
//
#pragma pack(push,1)
struct PPUnit2 {           // @persistent @store(Reference2Tbl+)
	PPUnit2();
	int    ValidateQuantityFraction(double qtty) const;
	enum {
		SI       = 0x0001, // (S) Единица системы СИ
		Physical = 0x0002, // (P) Физическая единица
		Trade    = 0x0004, // (T) Торговая единица (может не иметь однозначного физ. эквивалента)
		Hide     = 0x0008, // (H) Единицу не следует показывать
		IntVal   = 0x0010, // (I) Единица может быть только целочисленной
		Common   = 0x0020, // Унифицированная единица измерения (имеет конкретные габариты и, возможно, массу и емкость) //
		Default  = 0x0040  // @transient Флаг только для передачи данных, информирующий о том, что единица измерения
			// применяется "по умолчанию" для товаров, у которых единица измерения не определена.
	};
	long   Tag;            // Const=PPOBJ_UNIT
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Abbr[20];       // Символьный код единицы измерения //
	char   Code[12];       // Цифровой код единицы измерения //
	char   Reserve[14];    // @reserve // @v11.2.4
	uint16 Fragmentation;  // @v11.2.4 Дробность единицы измерения. Позволяет оперировать количествами
		// меньшими единицы, но пропорционально величине Fragmentation (с поправкой на десятичное округление).
		// Например, если Fragmentation == 8, то допускается оперировать величинами 1, 0.125, 0.25, 0.5, 0.75, 0.875.
		// Если Fragmentation == 3, то допускаются значения 1, 0.3333.., 0.6666..
	double Rounding_;      // Округление величины. (0.001 - до трех знаков после точки, 1 - целое и т.д.)
	//
	// Следующие 4 поля будут использованы для унифицированной системы обработки атрибутов товарной логистики
	//
	long   X;              // Length (mm)
	long   Y;              // Width (mm)
	long   Z;              // Height (mm)
	long   Mass;           // Mass (g)
	double BaseRatio;      //
	long   Flags;          //
	PPID   BaseUnitID;     // ->Ref(PPOBJ_UNIT)
	long   Reserve2;       // @reserve
};
#pragma pack(pop)

class PPObjUnit : public PPObjReference {
public:
	explicit PPObjUnit(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи  //
	//   по идентификатору ID. Если pRec == 0, то запись содержится в буфере ref->data.
	//
	int    Fetch(PPID, PPUnit * pRec);
	int    IsPhisical(PPID);
	int    IsInteger(PPID);
	int    AddSimple(PPID * pID, const char * pName, long flags, int use_ta);
	int    SearchMaxLike(const PPUnit * pRec, PPID * pID);
	int    UniteMaxLike();
	int    TranslateToBase(PPID unitID, PPID baseUnitID, double * pRatio);
protected:
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessReservedItem(TVRez &);
};
//
// @ModuleDecl(RawMaterial) // @v12.0.10
//
#pragma pack(push,1)
struct PPRawMaterial {
	PPRawMaterial();
	long   Tag;            // Const=PPOBJ_RAWMATERIAL
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];
	double Density;        // Плотность kg/cbm 
	uint8  Reserve[56];    // @reserve
	int32  Val1;
	int32  Val2;
};
#pragma pack(pop)

class PPRawMaterialPacket {
public:
	PPRawMaterialPacket();
	PPRawMaterialPacket & Z();
	bool   FASTCALL IsEq(const PPRawMaterialPacket & rS) const;
	PPRawMaterial Rec;
	ObjTagList TagL;        // Список тегов
};

class PPObjRawMaterial : public PPObjReference {
public:
	PPObjRawMaterial(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPRawMaterialPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPRawMaterialPacket * pPack);
private:
	virtual int  MakeReserved(long flags);
};
//
// @ModuleDecl(PPObjNamedObjAssoc)
//
struct PPNamedObjAssoc2 {  // @persistent @store(Reference2Tbl+)
	PPNamedObjAssoc2();
	enum {
		fLocAsWarehouse = 0x0001,
		fLocAsWareplace = 0x0002
	};
	long   Tag;            // Const=PPOBJ_NAMEDOBJASSOC
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	long   ScndObjGrp;     //
	long   Flags;          //
	long   PrmrObjType;    // PPOBJ_GOODS ||
	long   ScndObjType;    // PPOBJ_WAREHOUSE || PPOBJ_WAREPLACE || PPOBJ_ARTICLE
};

class PPObjNamedObjAssoc : public PPObjReference {
public:
	static int MakeGoodsToWarehouseAssocList(StrAssocArray & rList);
	static int EditGoodsToObjAssoc(PPID assocID, PPID objType, LAssoc * pData, const LocationFilt * pLocF, void * extraPtr, bool isNewItem);

	explicit PPObjNamedObjAssoc(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjPersonKind)
//
// Descr: Вид персоналии //
//
struct PPPersonKind2 {     // @persistent @store(Reference2Tbl+)
	PPPersonKind2();
	//
	// Descr: флаги вида персоналии
	//
	enum {
		fUseShortPersonDialog = 0x0001 // При создании новой персоналии этого вида использовать сокращенный диалог
	};
	long   Tag;            // Const=PPOBJ_PERSONKIND
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	long   Flags;          // @flags
	PPID   DefStatusID;    // ->Ref(PPOBJ_PRSNSTATUS) Статус новой персоналии по умолчанию
	char   Reserve[56];    // @reserve
	long   CodeRegTypeID;  // Тип регистрационного документа, используемого для поиска
	PPID   FolderRegTypeID; // Тип регистра, идентифицирующего наименование каталога с документами по персоналии
};

class PPObjPersonKind : public PPObjReference {
public:
	explicit PPObjPersonKind(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    Fetch(PPID id, PPPersonKind * pRec);
protected:
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjPersonStatus)
// Юридические статусы персоналий
//
#define PSNSTF_PRIVATE   0x0001L // Физическое лицо, иначе юридическое

struct PPPersonStatus2 {   // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_PRSNSTATUS
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          // PSNSTF_XXX
	long   Reserve2[2];    // @reserve
};

class PPObjPersonStatus : public PPObjReference {
public:
	PPObjPersonStatus(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPPersonStatus * pRec);
};
//
// @ModuleDecl(PPObjPersonCat)
//
struct PPPersonCat {
	long   Tag;            // Const=PPOBJ_PRSNCATEGORY
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[64];    // @reserve
	long   Reserve2[2];    // @reserve
};

class PPObjPersonCat : public PPObjReference {
public:
	PPObjPersonCat(void * extraPtr = 0);
	int    FASTCALL Fetch(PPID id, PPPersonCat * pRec);
private:
	virtual int HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx); // @srlz
};
//
// Виды адресов электронной связи (PPOBJ_ELINKKIND)
//
//
// Типы адресов электронной связи (зарезервированы, не справочник)
//
#define ELNKRT_UNKNOWN         0L
#define ELNKRT_PHONE           1L
#define ELNKRT_FAX             2L
#define ELNKRT_PAGER           3L
#define ELNKRT_EMAIL           4L
#define ELNKRT_WEBADDR         5L
#define ELNKRT_INTERNALEXTEN   6L // Внутренний телефонный номер

#define ELNKF_PREF     0x0001L // Предпочтительный адрес (Flags)
#define MAXPREFELNKK        5  // Максимум предпочтительных адресов

struct PPELinkKind2 {      // @persistent @store(Reference2Tbl+)
	PPELinkKind2()
	{
		THISZERO();
	}
	PPID   Tag;            // Const=PPOBJ_ELINKKIND
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          //
	PPID   Type;           // ELNKRT_XXX
	long   Reserve2;       // @reserve
};

class PPObjELinkKind : public PPObjReference {
public:
	PPObjELinkKind(void * extraPTr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	//
	// 1. Проверяет, является ли *pID зарезервированным номером ?
	//    1.1 YES: проверяет существование объекта с таким идентификатором.
	//        1.1.1 EXISTS: return (> 0),
	//        1.1.2 NOT EXISTS: создает запись с таким ID, именем Name и типом ELNKRT_UNKNOWN
	//    1.2 NO: проверяет существование объекта с именем Name
	//        1.2.1 EXISTS: return ( > 0) и в *pID записывается идентификатор найденного объекта
	//        1.2.2 NOT EXISTS: создает объект с именем Name и типом ELNKRT_UNKNOWN.
	//              по указателю *pID присваивается ИД нового объекта. return (> 0)
	// On error: return (< 0)
	//
	int    AddSimple(PPID * pID, const char * pName, int use_ta);
	int    FASTCALL Fetch(PPID id, PPELinkKind * pRec);
private:
	virtual int  ProcessReservedItem(TVRez &);
};

struct PPELink {
	PPELink();
	PPID   KindID;    // ->Ref(PPOBJ_ELINKKIND)
	char   Addr[64];  //
};

class PPELinkArray : public TSArray <PPELink> {
public:
	static int SetupNewPhoneEntry(const char * pPhone, PPELink & rEntry);
	static int SetupNewEmailEntry(const char * pEmail, PPELink & rEntry);
	PPELinkArray();
	int    FASTCALL IsEq(const PPELinkArray & rS) const;
	int    AddItem(PPID kindID, const char * pAddr);
	int    GetItem(PPID kindID, SString & rBuf) const;
	int    SearchByText(const char * pText, uint * pPos) const;
	int    GetSinglePhone(SString & rBuf, uint * pPos) const;
	int    GetPhones(uint maxCount, SString & rBuf, long elinkType = ELNKRT_PHONE) const;
	int    GetListByType(PPID eLinkType, StringSet & rSs) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	static int Helper_SetupNewEntry(PPID elinkType, const char * pValue, PPELink & rEntry);
};
//
// @ModuleDecl(PPObjCurrency)
// Валюты
//
struct PPCurrency2 {       // @persistent @store(Reference2Tbl+)
	PPCurrency2()
	{
		THISZERO();
	}
	PPID   Tag;            // Const=PPOBJ_CURRENCY
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve1[60];   // @reserve
	long   Flags;          //
	long   Code;           // Numeric currency code
	long   Reserve2;       // @reserve
};

struct PPCurrencyConfig {  // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_CURRENCYCFG
	PPID   BaseCurID;      // Базовая валюта учета
	PPID   BaseRateTypeID; // Базовый тип курса
	char   Reserve1[36];
	long   Flags;
	char   Reserve2[24];
};

class PPObjCurrency : public PPObjReference {
public:
	PPObjCurrency(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    AddItem(PPID * pID, PPCurrency * pCurrency, int use_ta);
	StrAssocArray * CreateSelectorList(int asSymb, const PPIDArray * pInclList, const PPIDArray * pExclList);
	int    Select(int asSymb, PPIDArray * pInclList, const PPIDArray * pExclList, PPID * pID);
	int    FASTCALL Fetch(PPID id, PPCurrency * pRec);
	int    SearchSymb(PPID * pID, const char * pSymb);
	//
	// Descr: Ищет запись валюты по коду code.
	// Returns:
	//   1 - найдена единственная запись валюты с ненулевым значением Code == code
	//   2 - существует более одной записи валюты с ненулевым значением Code == code
	//      возвращается идентификатор первой найденной записи.
	//  <0 - не найдено ни одной записи валюты с кодом code, либо параметр code == 0
	//   0 - error
	//
	int    SearchCode(PPID * pID, long code);
};
//
// @ModuleDecl(PPObjCurRateType)
// Типы валютных курсов
//
struct PPCurRateType2 {    // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_CURRATETYPE
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};

class PPObjCurRateType : public PPObjReference {
public:
	PPObjCurRateType(void * extraPtr = 0);
	virtual int Browse(void * extraPtr);
};

class TsStakeEnvironment : public SStrGroup {
public:
	TsStakeEnvironment();
	TsStakeEnvironment(const TsStakeEnvironment & rS);
	TsStakeEnvironment & FASTCALL operator = (const TsStakeEnvironment & rS);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    FASTCALL Copy(const TsStakeEnvironment & rS);
	enum {
		tickfBid    = 0x0002, // TICK_FLAG_BID=2 – тик изменил цену бид
		tickfAsk    = 0x0004, // TICK_FLAG_ASK=4  – тик изменил цену аск
		tickfLast   = 0x0008, // TICK_FLAG_LAST=8 – тик изменил цену последней сделки
		tickfVolume = 0x0010, // TICK_FLAG_VOLUME=16 – тик изменил объем
		tickfBuy    = 0x0020, // TICK_FLAG_BUY=32 – тик возник в результате сделки на покупку
		tickfSell   = 0x0040  // TICK_FLAG_SELL=64 – тик возник в результате сделки на продажу
	};
	enum { // ENUM_ORDER_TYPE
		ordtBuy   = 0, // ORDER_TYPE_BUY             Рыночный ордер на покупку
		ordtSell  = 1, // ORDER_TYPE_SELL            Рыночный ордер на продажу
		ordtBuyLimit      = 2, // ORDER_TYPE_BUY_LIMIT       Отложенный ордер Buy Limit
		ordtSellLimit     = 3, // ORDER_TYPE_SELL_LIMIT      Отложенный ордер Sell Limit
		ordtBuyStop       = 4, // ORDER_TYPE_BUY_STOP        Отложенный ордер Buy Stop
		ordtSellStop      = 5, // ORDER_TYPE_SELL_STOP       Отложенный ордер Sell Stop
		ordtBuyStopLimit  = 6, // ORDER_TYPE_BUY_STOP_LIMIT  По достижении цены ордера выставляется отложенный ордер Buy Limit по цене StopLimit
		ordtSellStopLimit = 7, // ORDER_TYPE_SELL_STOP_LIMIT По достижении цены ордера выставляется отложенный ордер Sell Limit по цене StopLimit
		ordtCloseBy       = 8  // ORDER_TYPE_CLOSE_BY        Ордер на закрытие позиции встречной позицией
	};
	enum { // ENUM_TRADE_REQUEST_ACTIONS
		traDeal    =  1, // TRADE_ACTION_DEAL Установить торговый ордер на немедленное совершение сделки с указанными параметрами (поставить рыночный ордер)
		traPending =  5, // TRADE_ACTION_PENDING Установить торговый ордер на совершение сделки при указанных условиях (отложенный ордер)
		traSLTP    =  6, // TRADE_ACTION_SLTP Изменить значения Stop Loss и Take Profit у открытой позиции
		traModify  =  7, // TRADE_ACTION_MODIFY Изменить параметры ранее установленного торгового ордера
		traRemove  =  8, // TRADE_ACTION_REMOVE Удалить ранее выставленный отложенный торговый ордер
		traCloseBy = 10  // TRADE_ACTION_CLOSE_BY Закрыть позицию встречной
	};
	enum { // ENUM_ORDER_TYPE_FILLING
		ordtfFOK    = 0, // ORDER_FILLING_FOK Данная политика исполнения означает, что ордер может быть исполнен исключительно в указанном объеме.
			// Если на рынке в данный момент не присутствует достаточного объема финансового инструмента, то ордер не будет исполнен.
			// Необходимый объем может быть составлен из нескольких предложений, доступных в данный момент на рынке.
		ordtfIOC    = 1, // ORDER_FILLING_IOC Означает согласие совершить сделку по максимально доступному на рынке объему в пределах указанного в ордере.
			// В случае невозможности полного исполнения ордер будет исполнен на доступный объем, а неисполненный объем ордера будет отменен.
		ordtfReturn = 2 // ORDER_FILLING_RETURN Данный режим используется для рыночных (ORDER_TYPE_BUY и ORDER_TYPE_SELL), лимитных и стоп-лимитных ордеров
			// (ORDER_TYPE_BUY_LIMIT, ORDER_TYPE_SELL_LIMIT, ORDER_TYPE_BUY_STOP_LIMIT и ORDER_TYPE_SELL_STOP_LIMIT) и только в режимах
			// "Исполнение по рынку" и "Биржевое исполнение". В случае частичного исполнения рыночный или лимитный ордер с остаточным объемом
			// не снимается, а продолжает действовать.
			// Для ордеров ORDER_TYPE_BUY_STOP_LIMIT и ORDER_TYPE_SELL_STOP_LIMIT при активации будет создан соответствующий лимитный ордер
			// ORDER_TYPE_BUY_LIMIT/ORDER_TYPE_SELL_LIMIT с типом исполнения ORDER_FILLING_RETURN
	};
	enum { // ENUM_ORDER_TYPE_TIME
		ordttGTC  = 0, // ORDER_TIME_GTC Ордер будет находится в очереди до тех пор, пока не будет снят
		ordttDay  = 1, // ORDER_TIME_DAY Ордер будет действовать только в течение текущего торгового дня
		ordttSpecified    = 2, // ORDER_TIME_SPECIFIED Ордер будет действовать до даты истечения
		ordttSpecifiedDay = 3  // ORDER_TIME_SPECIFIED_DAY Ордер будет действовать до 23:59:59 указанного дня.
			// Если это время не попадает на торговую сессию, истечение наступит в ближайшее торговое время.
	};
	enum { // ENUM_TRADE_TRANSACTION_TYPE
		ttratOrderAdd      =  0, // TRADE_TRANSACTION_ORDER_ADD – добавление нового действующего ордера
		ttratOrderUpdate   =  1, // TRADE_TRANSACTION_ORDER_UPDATE – изменение действующего ордера
		ttratOrderDelete   =  2, // TRADE_TRANSACTION_ORDER_DELETE – удаление ордера из списка действующих
		ttratHistoryAdd    =  3, // TRADE_TRANSACTION_HISTORY_ADD – добавление ордера в историю в результате исполнения или отмены
		ttratHistoryUpdate =  4, // TRADE_TRANSACTION_HISTORY_UPDATE – изменение ордера, находящегося в истории ордеров
		ttratHistoryDelete =  5, // TRADE_TRANSACTION_HISTORY_DELETE – удаление ордера из истории ордеров
		ttratDealAdd       =  6, // TRADE_TRANSACTION_DEAL_ADD – добавление сделки в историю
		ttratDealUpdate    =  7, // TRADE_TRANSACTION_DEAL_UPDATE – изменение сделки в истории
		ttratDealDelete    =  8, // TRADE_TRANSACTION_DEAL_DELETE – удаление сделки из истории
		ttratPosition      =  9, // TRADE_TRANSACTION_POSITION – изменение позиции, не связанное с исполнением сделки
		ttratRequest       = 10  // TRADE_TRANSACTION_REQUEST – уведомление о том, что торговый запрос обработан сервером и результат его обработки получен.
	};
	struct Tick { // @flat
		PPID   TsID;    // ->Ref(PPOBJ_TIMESERIES)
		uint   SymbP;   //
		LDATETIME Dtm;  // Время последнего обновления цен
		double Bid;     // Текущая цена Bid
		double Ask;     // Текущая цена Ask
		double Last;    // Текущая цена последней сделки (Last)
		uint   Volume;  // Объем для текущей цены Last
		long   TmMsc;   // Время последнего обновления цен в миллисекундах
		long   Flags;   // tickfXXX
		double VolumeReal; // Объем для текущей цены Last c повышенной точностью
		double MarginReq;  // Требуемая величина маржи на минимальный объем сделки (исходя из цены Last)
	};
	struct TerminalInfo { // @flat
		TerminalInfo();
		int32  GmtOffset; // TimeGMT - TimeLocal Разница между временем GMT и локальным на терминале.
		uint8  Reserve[64];
	};
	struct AccountInfo {
		AccountInfo();
		int    ID;           // Ид счета в торговой системе
		LDATETIME ActualDtm; // Время актуальности данных
		double Balance;      // Текущий баланс счета
		double Profit;       // Текущее значение прибыли (убытка) по счету
		double Margin;       // Размер зарезервированных залоговых средств на счете  в валюте депозита
		double MarginFree;   // Объем текущей доступной маржи
	};
	struct Stake { // @flat
		Stake();
		PPID   TsID;
		long   Ticket;           // Тикет ордера. Уникальное число, которое присваивается каждому ордеру
		long   Magic;            // Идентификатор эксперта выставившего ордер
		LDATETIME SetupDtm;      // Время постановки ордера
		LDATETIME ExpirationDtm; // Время истечения ордера
		LDATETIME DoneDtm;       // Время исполнения или снятия ордера
		long   SetupMsc;         // Время установки ордера на исполнение в миллисекундах с 01.01.1970
		long   DoneMsc;          // Время исполнения/снятия ордера в миллисекундах с 01.01.1970
		long   TypeFilling;      // ordtfXXX Тип исполнения по остатку
		long   TypeTime;         // ordttXXX Время жизни ордера
		long   Type;             // ordtXXX Тип ордера
		long   State;            // Статус ордера
		long   Reason;           // Причина или источник выставления ордера
		long   PositionId;       // Идентификатор позиции, который ставится на ордере при его исполнении.
			// Каждый исполненный ордер порождает сделку, которая открывает новую или изменяет уже существующую позицию.
			// Идентификатор этой позиции и устанавливается исполненному ордеру в этот момент
		long   PositionById;     // Идентификатор встречной позиции для ордеров типа ORDER_TYPE_CLOSE_BY.
		uint   SymbP;
		uint   CommentP;
		uint   ExternalIdP;    // Идентификатор ордера во внешней торговой системе (на бирже)
		double VolumeInit;     // Первоначальный объем при постановке ордера
		double VolumeCurrent;  // Невыполненный объем
		double PriceOpen;      // Цена, указанная в ордере
		double PriceCurrent;   // Текущая цена по символу ордера
		double Profit;         // Текущая прибыль в валюте счета
		double SL;             // Уровень Stop Loss
		double TP;             // Уровень Take Profit
		double PriceStopLimit; // Цена постановки Limit ордера при срабатывании StopLimit ордера
	};

	class StakeRequestBlock : public SStrGroup {
	public:
		StakeRequestBlock(/*TsStakeEnvironment & rEnv*/);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		//
		// Позиции на текстовые строки в этом блоке ссылаются на головную структуру TsStakeEnvironment & R_Env
		//
		struct Req {
			Req();
			long   Action;           // traXXX Тип выполняемого действия
			ulong  Magic;            // Штамп эксперта (идентификатор magic number)
			ulong  Ticket;           // Тикет ордера
			PPID   TsID;             //
			uint   SymbolP;          // Имя торгового инструмента
			double Volume;           // Запрашиваемый объем сделки в лотах
			double Price;            // Цена
			double StopLimit;        // Уровень StopLimit ордера
			double SL;               // Уровень Stop Loss ордера
			double TP;               // Уровень Take Profit ордера
			ulong  Deviation;        // Максимально приемлемое отклонение от запрашиваемой цены
			long   Type;             // ordtXXX Тип ордера
			long   TypeFilling;      // ordtfXXX Тип ордера по исполнению
			long   TypeTime;         // ordttXXX Тип ордера по времени действия
			LDATETIME Expiration;    // Срок истечения ордера (для ордеров типа ORDER_TIME_SPECIFIED)
			uint   CommentP;         // Комментарий к ордеру
			ulong  PositionTicket;   // Тикет позиции
			ulong  PositionByTicket; // Тикет встречной позиции
		};
		struct Result {
			Result();
			uint   RetCode;         // Код результата операции
			ulong  DealTicket;      // Тикет сделки, если она совершена
			ulong  OrderTicket;     // Тикет ордера, если он выставлен
			double Volume;          // Объем сделки, подтверждённый брокером
			double Price;           // Цена в сделке, подтверждённая брокером
			double Bid;             // Текущая рыночная цена предложения (цены реквота)
			double Ask;             // Текущая рыночная цена спроса (цены реквота)
			uint   CommentP;        // Комментарий брокера к операции (по умолчанию заполняется расшифровкой кода возврата торгового сервера)
			uint   RequestId;       // Идентификатор запроса, устанавливается терминалом при отправке
			uint   RetCodeExternal; // Код ответа внешней торговой системы
		};

		TSVector <Req> L;
		TSVector <Result> RL;
	private:
		long   Ver;
	};
	class TransactionNotification : public SStrGroup {
	public:
		TransactionNotification();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		struct Ta {
			LDATETIME NotifyTime; // Время регистрации извещения
			uint   Deal;          // Тикет сделки
			uint   Order;         // Тикет ордера
			uint   SymbP;         // Символ инструмента
			long   TaType;        // Информация о типе транзакции содержится в поле type переменной trans.
			long   OrdType;       // Тип ордера
			long   OrdState;      // Состояние ордера
			long   DealType;      // Тип сделки
			long   OrdTypeTime;   // Тип ордера по времени действия
			LDATETIME Expiration; // Срок истечения ордера
			double Price;         // Цена
			double PriceTrigger;  // Цена срабатывания стоп-лимитного ордера
			double PriceSL;       // Уровень Stop Loss
			double PriceTP;       // Уровень Take Profit
			double Volume;        // Объем в лотах
			uint   Position;      // Тикет позиции
			uint   PositionBy;    // Тикет встречной позиции
		};

		TSVector <Ta> L;
	private:
		long   Ver;
	};

	const Tick * FASTCALL SearchTickBySymb(const char * pSymb) const;

	TerminalInfo Term;
	AccountInfo Acc;
	TSVector <Tick>  TL; // Список последних тиков по выбранному набору инструментов
	TSVector <Stake> SL; // Список текущих ордеров на счету Acc
private:
	long   Ver;
};

struct PPTssModel { // @persistent @store(Reference2Tbl)
	static const uint16 Default_OptRangeStep; // 288
	static const uint16 Default_OptRangeStepCount; // 1
	static const uint16 Default_OptRangeMultiLimit; // 250
	static const uint16 Default_CqaMatchPromille; // 18

	PPTssModel();
	int    FASTCALL IsEq(const PPTssModel & rS) const;
	PPID   Tag;            // Const=PPOBJ_TSSMODEL
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	enum {
		fBestSubsetTrendFollowing  = 0x0001,
		fOptRangeMulti     = 0x0004, // Для каждого триплета {frame; sl; tp} подбираются несколько оптимальных секторов (иначе - единственный)
		fOptRangeStepAsMkPart_     = 0x0008, // Параметр OptRangeStep задан в миллионных долях от мощности выборки
		fTrendErrLimitAsMedianPart = 0x0010, // Параметр InitTrendErrLimit задан в медианных долях
		fRemoveLowProfitStrategies = 0x0020, // Перед селекцией контейнера стратегий убирать тех кандидатов, чья доходность меньше лимита.
			// Методика вычисления лимита (предварительно) такая: среднее значение доходности всех кандидатов минус 3 дисперсии.
		fSeparateInpFrameSizes     = 0x0040  // Каждый элемент PPTssModelPacket::InputFrameSizeList расчитывается полным
			// циклом с последующим сравнением результатов и выбором лучшего набора стратегий.
			// При вводе такой список обрамляется скобками []. Например [240, 300, 360]
	};
	enum {
		tcAmount       = 0, // Абсолютный объем выигрыша
		tcVelocity     = 1, // Скорость выигрыша
		tcWinRatio     = 2, // Вероятность выигрыша (количество выигрышей деленных на количество точек в секторе)
		tcAngularRatio = 3, // Угловая вероятность выигрыша (количество выигрышей деленных на радианный угол сектора)
	};
	//
	// Descr: Варианты определения шага поиска оптимальных диапазонов
	//
	enum {
		orsUndef      = 0, //
		orsAbsolute   = 1, // Простое количество точек
		orsMkPart     = 2, // Микро-доли от общего количества точек в выборке
		orsLog        = 3, // Логарифм от общего количества точек в выборке, умноженный на параметр
		orsRadialPart = 4  // Микро-доли от общего углового сектора выборки
	};
	//
	// Descr: Варианты предварительной сортировки списка стратегий перед селекцией
	//
	enum {
		sppsResult     = 1,
		sppsProb       = 2,
		sppsVelocity   = 3,
		sppsCqaFactor  = 4, // Значение CQA
		sppsShuffle    = 5, // Случайное перемешивание
		sppsStakeCount = 6  // Количество ставок, полученных при генерации стратегии (критерий основывается на предположении, что
			// чем больше таких ставок, тем больше доверия вызывает стратегия).
	};
	uint16 BestSubsetDimention;
	uint16 BestSubsetMaxPhonyIters;
	uint8  BestSubsetOptChunk;      // 0 || 1 || 3 || 7 || 15
	uint8  MainFrameRangeCount;     // Количество сегментов, на которые разбивается все множество значений магистрального тренда для подбора стратегий
	uint16 Reserve5;                //
	uint16 OptRangeStep_;           //
	uint16 OptRangeMultiLimit;      //
	uint16 OptRangeStepCount;       //
	uint16 OptRangeMaxExtProbe;     // @default=1 Максимальное количество попыток расширения оптимального интервала значений регрессии
	int16  OptTargetCriterion;      // tcXXX
	uint16 Reserve3;                //
	LDATE  UseDataSince;            // Модель строить по данным, начиная с указанной даты включительно (если checkdate(UseDataSince))
	double InitTrendErrLimit_;      //
	double InitMainTrendErrLimit;   //
	double MinWinRate;              // Минимальное отношение выигрышей для стратегий, попадающих в финальную выборку
	double OverallWinRateLimit;     // Минимальное отношение выигрышей для всего множества отобранных стратегий
	uint8  OptRangeStep_Measure;    // orsXXX
	uint8  StrategyPoolSortOrder;   // Порядок сортировки пула стратегий перед селекцией
	uint8  Reserve4[2];             // 
	long   Flags;
	long   Reserve1;
	long   Reserve2;
};

class PPTssModelPacket {
public:
	PPTssModelPacket();
	int    FASTCALL IsEq(const PPTssModelPacket & rS) const;
	int    SerializeTail(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Output(SString & rBuf) const;

	PPTssModel Rec;
	struct Extension {
		Extension();
		int    FASTCALL IsEq(const Extension & rS) const;
		SVerT  Ver;               // Версия системы, создавшей запись
		//
		// 4 поля для финишной адаптивной подстройки лимитов стратегии.
		//
		uint8  AdoptSlShiftDn;
		uint8  AdoptSlShiftUp;
		uint8  AdoptTpFinishShiftUp;
		uint8  AdoptTpFixed;           //
		double MaxStakeCountVariation; // Максимальный коэфф вариации по количеству ставок для пула сессий.
		uint8  Reserve[56];
	};
	Extension E;
	LongArray MainFrameSizeList;    // Список дистанций магистрального тренда
	LongArray InputFrameSizeList;   // Список дистанций рабочих трендов (не включает период магистрального тренда)
	LongArray MaxDuckQuantList_Obsolete; // Список допустимых величин MaxDuck в квантах // @v10.8.4 Не используется (оставлен из-за персистентности)
	LongArray TargetQuantList_Obsolete;  // Список допустимых величин Target в квантах  // @v10.8.4 Не используется (оставлен из-за персистентности)
	LAssocArray StakeBoundList;     // Пары {TP, SL} работающие вместо списков MaxDuckQuantList, TargetQuantList.
		// То есть, если StakeBoundList не пустой, то MaxDuckQuantList, TargetQuantList не используются
};

class PPObjTssModel : public PPObjReference {
public:
	explicit PPObjTssModel(void * extraPtr = 0);
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPTssModelPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPTssModelPacket * pPack);
	int    SerializePacket(int dir, PPTssModelPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    ImportFromIni(PPID * pID);
private:
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
};

struct PPTimeSeries { // @persistent @store(Reference2Tbl)
	PPTimeSeries();
	enum {
		tUnkn   = 0,
		tForex  = 1,
		tStocks = 2,
		tCrypto = 3
	};
	int    FASTCALL IsEq(const PPTimeSeries & rS) const;
	PPID   Tag;            // Const=PPOBJ_TIMESERIES
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	double BuyMarg;
	double SellMarg;
	int16  Prec;
	char   CurrencySymb[12];
	double SpikeQuant_t;   //
	double AvgSpread;      //
	uint32 OptMaxDuck;     // Оптимальная глубина проседания (в квантах) при длинной ставке
	uint32 OptMaxDuck_S;   // Оптимальная глубина проседания (в квантах) при короткой ставке
	uint16 PeakAvgQuant;   //
	uint16 PeakAvgQuant_S; //
	uint16 TargetQuant;    //
	long   Flags;          //
	long   Type;           // PPTimeSeries::kXXX
	PPID   TssModelID;     // ->Reference(PPOBJ_TSSMODEL)
};
//
// Descr: Пакет временной серии. Содержит основную запись и дополнительные свойства.
//
class PPTimeSeriesPacket {
public:
	PPTimeSeriesPacket();
	bool   FASTCALL IsEq(const PPTimeSeriesPacket & rS) const;
	double GetMargin(int sell) const;
	const char * GetSymb() const;

	struct Extension {
		Extension();
		bool   IsEmpty() const;
		bool   FASTCALL IsEq(const Extension & rS) const;
		double MarginManual; // Торговая маржина, используемая для расчетов и устанавливаемая в ручную.
			// Требуется в случае, если необходимое для расчетов значение отличается от того, что возвращается торговым сервером.
		double FixedStakeVolume;  // Фиксированный размер ставки (не привязанный к доступному объему и коэффициенту запаса)
		double AvgLocalDeviation; // Среднее локальное отклонение для всей выборки. Локальное отклонение
			// считается по Config.E.LocalDevPtCount точкам как стандартное отклонение. Необходимо для идентификации
			// аномальных смещений где недопустимо делать ставки.
		LDATE  UseDataForStrategiesSince; // Дата, начиная с которой можно рассматривать данные для построения стратегий
		uint8  Reserve[40];
	};
	PPTimeSeries Rec;
	Extension E;
};

class PPObjTimeSeries : public PPObjReference {
public:
	struct Config { // @persistent
		enum {
			fTestMode    = 0x0001,
			fAllowReverse        = 0x0008, // Допускается реверс ставки при наличии предпочтительной стратегии в обратном направлении
			fVerifMode   = 0x0010, // Режим верификации данных
			fIgnoreStrangeStakes = 0x0020, // При расчете ставок игнорировать установленные ставки, сделанные не нами (то есть ручные или сделанные другим роботом)
			fLogStakeEvaluation  = 0x0040  // Выводить в журнал информацию о расчете ставок
		};
		enum {
			efLong = 0x0001,
			efShort        = 0x0002,
			efDisableStake = 0x0004
		};
		struct Entry { // @flat
			Entry();
			PPID   TsID;
			long   Flags;
			uint8  Reserve[32];
		};

		Config();
		Config & Z();
		int    FASTCALL IsEq(const Config & rS) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		const  Config::Entry * FASTCALL SearchEntry(PPID tsID) const;

		SVerT  Ver;
		long   Flags;
		uint   MaxStakeCount;
		double AvailableLimitPart;
		double AvailableLimitAbs;
		double MinPerDayPotential;
		struct ExtBlock {
			ExtBlock();
			uint32 MaxAvgTimeSec; // Предельное среднее время в секундах
			int32  TsFlashTimer;  // default(600) Период времени (секунд) по истечении которого необходимо сбросить накопленные серии в БД
			int32  MinLossQuantForReverse;  // Минимальное количество квантов потерь для реверса ставки
			int32  MinAgeSecondsForReverse; // Минимальный возраст ставки для реверса (в секундах)
			int32  TerminalTimeAdjustment;  // Поправка времени терминала для сравнения с текущим моментом (в секундах)
			int16  LocalDevPtCount;         // Количество точек, по которым считается локальная девиация исходных данных
			int16  LDMT_Factor;             // Фактор ограничения девиации при выставлении ставки: макс произведение
				// локальной девиации на ошибку магистрального тренда в промилле.
			uint32 Reserve3;
			float  MainTrendMaxErrRel; // Максимальная относительная ошибка магистрального тренда при выставлении ставки.
			uint16 TestCount;   // Количество повторных тестов, выполняемых функцией TsSimulateStrategyContainer()
			uint16 Reserve2;    // @alignment
			uint8  Reserve[28];
		};
		ExtBlock   E;
		TSVector <Entry> List;
	};
	struct QuoteReqEntry {
		enum {
			fAllowLong    = 0x0001,
			fAllowShort   = 0x0002,
			fDisableStake = 0x0004,
			fTestPurpose  = 0x0008  // Специальный флаг, указывающий на то, что серверу требуются данные для тестирония текущих значений.
		};
		PPID   TsID;
		char   Ticker[32];
		long   Flags;
		long   ExtraCount; // Дополнительное количество значение, затребованное сервером (главным образом, для тестирования)
		LDATETIME LastValTime;
	};
	struct TrendEntry {
		TrendEntry(uint stride, uint nominalCount);
		//
		// Descr: Замещает каждое значение ErrL величиной sqrt(ErrL.at(i))
		//   В общем случае, это - нормальное состояние вектора ErrL, но
		//   в некоторых случаях может пондобиться иметь оригинальный вектор ошибок.
		//
		void   SqrtErrList(StatBase * pS);
		int    Analyze(const PPTssModelPacket & rTssModel, SString & rOutBuf) const;

		const  uint Stride;
		const  uint NominalCount;
		double ErrAvg;        // Средняя ошибка регрессии
		double SpikeQuant_r;  // Квант расчета для периода NominalCount
		double ErrLimitByPel; // Локальный предел ошибки рассчитанный на основе частичного предела ошибки.
		RealArray TL;
		RealArray ErrL;       // Ошибки регрессии
	};
	struct CommonTsParamBlock {
		CommonTsParamBlock();
		int    Setup(const STimeSeries & rTs);
		LDATETIME GetLastValTime() const;
		DateTimeArray TmList;
		RealArray ValList;
		TSCollection <TrendEntry> TrendList;
	};
	struct StrategyResultValue { // @flat @persistent
		StrategyResultValue();
		StrategyResultValue & Z();
		double GetResultPerSec() const;
		double GetResultPerDay() const;
		void   FASTCALL Append(const StrategyResultValue & rV);

		double Result;
		uint64 TmCount;
		uint64 TmSec;
	};
	struct StrategyResultValueEx : public StrategyResultValue { // @transient
		StrategyResultValueEx();
		StrategyResultValueEx & Z();
		double SlVal;           // Абсолютное значение stop-limit
		double TpVal;           // Абсолютное значение take-profit
		double Peak;            // Максимальное значение, которого достигла котировка в течении сессии
		double Bottom;          // Минимальное значение, которого достигла котировка в течении сессии
		double Clearance;       // Минимальный зазор в течении сессии (квантов). При выигрыше это минимальная разница между sl и ближайшей точкой хода,
			// при проигрыше - минимальная разница между tp и ближайшей точкой хода
		uint   StartPoint;      // Точка ряда, на которой алгоритм TsCalcStrategyResult2 начал работу
		uint   LastPoint;       // Точка ряда, на которой алгоритм TsCalcStrategyResult2 закончил работу
		STimeChunk TmR;         // 
		int    StrategyIdx;     // [0..], (<0) - undefined. Strategy index at the StrategyContainer
		double OptFactor;       // 
		double OptFactor2;      // 
		double TrendErr;        // 
		double TrendErrRel;     // 
		double MainTrendErr;    // 
		double MainTrendErrRel; // 
		uint8  Reserve[16];
	};
	struct OptimalFactorRange : public RealRange { // @persistent @flat
		OptimalFactorRange();
		OptimalFactorRange & Z();
		double GetAngularRange() const;
		uint32 Count;      // Количество элементов исходного ряда, входящих в диапазон при тестировании
		uint32 Reserve;
		double Result;
	};
	struct OptimalFactorRange_WithPositions : public OptimalFactorRange { // @transient @flat
		OptimalFactorRange_WithPositions();
		OptimalFactorRange_WithPositions & Z();
		uint   LoPos;
		uint   UpPos;
		uint   GenSeq;     // Порядок генерации при поиске оптимального фактора регрессия/выигрыш
		uint   GenPtCount; // Количество точек в выборке, по которой генерируются диапазоны
	};
	struct TsDensityMapEntry { // @persistent
		TsDensityMapEntry();
		uint   FASTCALL GetFactorVector(double * pVec) const;
		enum {
			factorADF = 1,
			factorTrendErrRel = 2,
			factorUEF = 3,
			factorGenCount    = 4,
			factorGenTEA      = 5,
			factorGenTED      = 6,
			factorAngleMid    = 7, // Среднее значение углового диапазона AngleR
			factorAngular     = 8, // Угловая дуга диапазона AngleR
			factorCADF        = 9
		};
		enum {
			fShort = 0x0001
		};
		PPID   TsID;
		uint16 Flags;
		uint16 InputFrameSize;
		uint16 GenCount;
		uint16 StakeCount;
		uint16 WinCount;
		uint16 LossCount;
		double ADF;
		double UEF;
		double GenTEA;
		double GenTED;
		double CADF;
		double TrendErrRel;
		RealRange AngleR;
	};
	class TsDensityMap : public TSVector <TsDensityMapEntry> {
	public:
		struct ResultEntry {
			ResultEntry();
			RealRange FactorR;
			uint   Sc;
			uint   Wc;
			double Prob;
		};
		TsDensityMap();
		SString & EntryToStr(const TsDensityMapEntry * pEntry, const char * pSymb, SString & rBuf) const;
		int    Import(const char * pFileName);
		// ARG(edge IN): 0 - from low edge, 1 - from upp edge, <0 - no matter
		int    SearchBestRange(PPID tsID, int side, int edge, int factor, double minProb, ResultEntry & rResult) const;
		enum {
			knnfSameTS   = 0x0001,
			knnfSameSide = 0x0002
		};
		int    SearchKNN(uint idx, uint K, long flags, RAssocArray & rResult) const;

		SVerT  Ver;
		LDATETIME TmFirstEvEntry;
		LDATETIME TmLastEvEntry;
		LDATETIME TmLastSimEntry;
		uint32 EvEntryCount;
		uint32 SimEntryCount;
		uint8  Reserve[64];
	private:
		int    GetNextChunk(int factor, double minProb, uint firstIdx, uint * pLastIdx, ResultEntry * pResult) const;
		int    CalcProb(uint firstIdx, uint lastIdx, ResultEntry & rResult) const;
	};
	struct Strategy { // @flat @persistent // @v10.6.12 модифицирована структура; для обратной совместимости используется Ts_Strategy_Before10612
		// @v10.8.10 модифицирована структура; для обратной совместимости используется Ts_Strategy_Before10810
		static double CalcSL_withExternalFactors(double peak, bool isShort, int prec, uint maxDuckQuant, double spikeQuant, double averageSpreadForAdjustment);
		static double CalcTP_withExternalFactors(double stakeBase, bool isShort, int prec, uint targetQuant, double spikeQuant, double averageSpreadForAdjustment);
		static double CalcSlTpAdjustment(int prec, double averageSpreadForAdjustment);
		Strategy();
		void   Reset();
		bool   FASTCALL IsStakeSideEq(const Strategy & rS) const;
		double CalcSL(double peak, double averageSpreadForAdjustment) const;
		double CalcSL(double peak, double externalSpikeQuant, double averageSpreadForAdjustment) const;
		double CalcTP(double stakeBase, double averageSpreadForAdjustment) const;
		double CalcTP(double stakeBase, double externalSpikeQuant, double averageSpreadForAdjustment) const;
		double GetWinCountRate() const;
		//
		// Descr: Возвращает угловую величину сегмента OptDeltaRange в радианах
		//
		double GetAngularRange() const;
		double GetAngularDensity() const;
		double GetStakeDensity() const;
		double CalcConfidenceFactor() const;
		//
		// Descr: Возвращает средний катет (OptDeltaRange*InputFrameSize) / SpikeQuant
		//
		double GetOptDeltaRangeCQA() const;
		int    CalcResult2(/*const DateTimeArray & rTmList, const RealArray & rValList*/const PPObjTimeSeries::CommonTsParamBlock & rCtspb, uint valueIdx, PPObjTimeSeries::StrategyResultValueEx & rV) const;
		enum {
			bfShort        = 0x0001, // Стратегия для short-торговли
			bfBrokenRow    = 0x0002, // Флаг означающий, что при расчете последний результат стратегии оказался неопределенным из-за обрыва ряда
			bfDynMainTrend = 0x0004  // @v11.4.5 (construction-approach) Стратегия строится только по малому тренду с одновременным вычислением величины основного (большого) тренда.
				// После расчета наборы стратегий группируются по близости величины основного тренда.
		};
		enum {
			clsmodFullMaxDuck = 0, //
			clsmodAdjustLoss  = 1  //
		};
		uint32 ID;
		uint16 InputFrameSize;   // Количество периодов с отсчетом назад, на основании которых принимается прогноз
		uint16 MainFrameSize;    // Длина периода магистрального тренда
		int16  Prec;             // Точность представления значений (количество знаков после десятичной точки)
		uint16 TargetQuant;      // Максимальный рост в квантах SpikeQuant
		uint16 MaxDuckQuant;     // Максимальная величина "проседания" в квантах SpikeQuant
		uint16 OptDelta2Stride;  // Оптимальный шаг назад при расчете изменения тренда
		int16  StakeMode;        // Режим покупки: 0 - сплошной (случайный); 1 - по значению тренда; 2 - по изменению тренда, 3 - по значению и изменению тренда
		uint16 StakeCloseMode;   // clsmodXXX Режим закрытия
		uint16 BaseFlags;        // @flags
		uint16 PeakAvgQuant;
		uint16 BottomAvgQuant;
		uint16 PeakMaxQuant;
		uint16 GenSeq;           // Порядок генерации при поиске оптимального фактора регрессия/выигрыш
		uint16 GenPtCount;       // Общее количество точек, по которым рассчитывалась стратегия //
		uint32 StakeCount;       // Количество ставок при тестировании
		uint32 WinCount;         // Количество выигрышей в результате тестирования
		uint32 StakeCountAtFinalSimulation; //
		double Margin;           // Маржа
		double SpikeQuant_s;     // Минимальный квант относительного изменения котировки для дискретизации параметров
		double SpreadAvg;        // Среднее значение спреда между Ask и Bid
		double TrendErrAvg;      // Среднее значение ошибки регрессии по всему множеству расчетных точек
		float  TrendErrLim;      // Ограничение для ошибки регрессии, выше которого применять стратегию нельзя.
			// Эта величина умножается на TrendErrAvg для получения абсолютного значения лимита.
			// [0..]. 0 - не использовать ограничение, 1.0 - ограничение равно TrendErrAvg, 1.05 - (1.05 * TrendErrAvg)
		float  TrendErrLowLim;   // @experimental Если >0.0 то это - нижняя граница ошибки регрессии (очень спорно)
		double MainTrendErrAvg;  // Среднее значение ошибки регрессии для магистрального тренда
		float  MainTrendErrLim;  // Ограничение для ошибки регрессии магистрального тренда
		float  ADF;              // @experimental Adjusent-Density-Factor фактор плотности смежных зон
		float  UEF;              // Unevenness-Factor фактор неравномерности распределения точек в зоне OpeDeltaRange
		float  GenTEA;           // Trend-Err-Average at generating phase
		float  GenTED;           // Trend-Err-Deviation at generating phase
		float  CADF;             // Core-Angular-Deviation-Factor фактор отклонения протестированных результатов стратегии от центральной линии канала
		float  MRSF;             // Most-Recently-Stake-Factor фактор близости к текущему моменту последних расчетных ставок
		uint16 ATWC;             // @v11.1.11 Количество выигрышных срабатываний при тестировании после расчетного периода
		uint8  Reserve[14];      // @v11.1.11 [16]-->[14]
		OptimalFactorRange OptDeltaRange;
		OptimalFactorRange OptDelta2Range; // Если MainFrameSize > 0 то здесь хранится диапазон магистрального тренда для стратегии
		StrategyResultValue V;   // Результат тестирования
	};
	struct TrainNnParam : public Strategy {
		TrainNnParam(const char * pSymb, long flags);
		TrainNnParam(const PPTimeSeriesPacket & rTsPack, long flags);
		void   Reset();
		SString & MakeFileName(SString & rBuf) const;
		enum {
			afTrainNN  = 0x0001,
			afTest     = 0x0002,
			afAnalyzeFrame     = 0x0004,
			afTestStrategyNN   = 0x0008
		};
		const  SString Symb;     // Символ временной серии
		long   ActionFlags;      // @flags
		uint   Reserve4[4];      //
	};
	struct StrategyResultEntry : public Strategy { // @flat
		StrategyResultEntry();
		StrategyResultEntry(const PPObjTimeSeries::TrainNnParam & rTnnp, int stakeMode);
		StrategyResultEntry(const PPObjTimeSeries::Strategy & rS, int stakeMode);
		void   FASTCALL SetValue(const StrategyResultValue & rV);
		void   FASTCALL SetValue(const StrategyResultValueEx & rV);
		void   FASTCALL SetOuter(const StrategyResultEntry & rS); // @cs
		double GetPeakAverage() const;
		double GetBottomAverage() const;
		void   ToStr(long flags, int stakeSide, int optFactorSide, SString & rBuf);

		char   Symb[32];
		uint   LastResultIdx; // Последний индекс в тестируемом ряду, по которому еще можно получить адекватный результат
			// (далее ряд обрывается раньше, чем можно оценить результат ставки).
		double SumPeak;          //
		double SumBottom;        //
		double MaxPeak;          //
		uint64 TotalSec;         // Общее время теста (для симуляции контейнеров стратегий)
		uint   FactorRangeLo;    //
		uint   FactorRangeUp;    //
	};
	struct BestStrategyBlock {
		BestStrategyBlock();
		BestStrategyBlock & Z();
		void   SetResult(double localResult, uint strategyIdx, double tv, double tv2);

		double MaxResult;
		int    MaxResultIdx;
		double TvForMaxResult;
		double Tv2ForMaxResult;
		double TrendErr;
		double TrendErrRel;
		double MainTrendErr;
		double MainTrendErrRel;
		uint8  Reserve[16];
	};

	class StrategyContainer : public TSVector <Strategy> {
	public:
		StrategyContainer();
		StrategyContainer(const StrategyContainer & rS);
		StrategyContainer & FASTCALL operator = (const StrategyContainer & rS);
		int    FASTCALL Copy(const StrategyContainer & rS);
		StrategyContainer & Z();
		void   Setup(const PPTimeSeriesPacket & rTsPack, const PPTssModelPacket * pModel, LDATETIME lastValTm, LDATE useDataTill);
		void   SetupByTsPacket(const PPTimeSeriesPacket & rTsPack, const PPTssModelPacket * pModel);
		void   SetLastValTm(LDATETIME dtm);
		void   SetUseDataForStrategiesTill(LDATE dt);
		void   TrimByVariance(double bound);
		LDATETIME GetLastValTm() const { return LastValTm; }
		LDATETIME GetStorageTm() const { return StorageTm; }
		LDATE  GetUseDataForStrategiesTill() const { return Fb.UseDataForStrategiesTill; }
		uint32 GetVersion() const { return Ver; }
		int    GetInputFramSizeList(LongArray & rList, uint * pMaxOptDelta2Stride) const;
		int    Simulate(const CommonTsParamBlock & rCtspb, const Config & rCfg, uint insurSlDelta, uint insurTpDelta, StrategyResultEntry & rSre, TSVector <StrategyResultValueEx> * pDetailsList) const;
		void   AccumulateFactors(StrategyResultEntry & rSre) const;
		int    FindAngularIntersection(const Strategy & rS, uint * pPos) const;
		int    FindAngularNearestNeighbour(const Strategy & rS, uint * pPos) const;

		enum {
			scoreResult = 1,            // Сумма результата
			scoreEvStakeCountMean,      // Среднее по количеству ставок на этапе вычисления стратегий
			scoreEvStakeCountStdDev,    // Стандартное отклонение по количеству ставок на этапе вычисления стратегий
			scoreEvStakeCountVarCoeff,  // Коэффициент вариации по количеству ставок на этапе вычисления стратегий
			scoreSeStakeCountMean,      // Среднее по количеству ставок на этапе отбора стратегий
			scoreSeStakeCountStdDev,    // Стандартное отклонение по количеству ставок на этапе отбора стратегий
			scoreSeStakeCountVarCoeff,  // Коэффициент вариации по количеству ставок на этапе отбора стратегий
			scoreEvAngularStakeDensity, // Угловая плотность ставок на этапе вычисления стратегий
			scoreSeAngularStakeDensity, // Угловая плотность ставок на этапе отбора стратегий
			scoreEvAngularWinRate,      // Угловой коэффициент выигрышей
			scoreTotalAngle             // Суммарная величина угла по всем стратегиям контейнера
		};
		//
		// Descr: Рассчитывает значение показателя контейнера стратегий.
		//   Если аргумент pExceptIndices не равен 0, то из рассмотрения исключаются стратегии, находящиеся
		//   в позициях, перечисленных в этом списке.
		//
		double EvaluateScore(int scoreId, const LongArray * pOnlyIndices, const LongArray * pExceptIndices) const;
		const  Strategy * SearchByID(uint32 id, uint * pIdx) const;
		int    IsThereSimilStrategy(uint thisIdx, const LongArray & rSelectedIdxList, LongArray & rSimilIdxList) const;

		struct CritEntry {
			explicit CritEntry(uint idx);
			uint   Idx;
			double Crit1;
			double Crit2;
			double Crit3;
			uint   StakeCount;
		};
		//
		// Descr: Флаги функции GetBestSubset
		//
		enum {
			gbsfLong       = 0x0001,
			gbsfShort      = 0x0002,
			gbsfStakeMode1 = 0x0004,
			gbsfCritProfitMultProb = 0x0040, // В качестве критерия сортировки применять произведение доходности на отношение win/stake.
				// Если флаг не установлен, то - доходность.
			gbsfCritProb           = 0x0080, // В качестве критерия сортировки применять отношение win/stake.
			gbsfEliminateDups      = 0x0100, // Не включать в список дубликаты по StakeMode1 с идентичными
				// диапазонами и InputFrameSize (игнорируется то из двух, кто имеет наименьший целевой критерий)
			gbsfTrendFollowing     = 0x0200, // Отбирать только стратегии, идущие вдоль тренда
			gbsfCritTotalResult    = 0x0400, // В качестве критерия сортировки применять абсолютный доход по стратегии.
			gbsfOptDeltaRangeCQA   = 0x0800, // Специальный критерий сортировки по среднему катету угла регрессии в квантах (с дифференциацией по сегментам магистрального тренда)
			gbsfShuffle            = 0x2000, // Перед селекцией хаотизировать список стратегий
			gbsfCritStakeCount     = 0x8000  // В качестве критерия сортировки применять количество ставок стратегии.
		};
		int    MakeOrderIndex(long flags, TSArray <PPObjTimeSeries::StrategyContainer::CritEntry> & rIndex) const;
		int    GetBestSubset2(const PPTssModelPacket & rTssPacket, StrategyContainer & rScDest, StrategyContainer * pScSkipDueDup, LongArray * pToRemovePosList) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		struct IndexEntry1 {
			struct Range : public RealRange {
				Range(const RealRange & rR, uint idx);
				uint   Idx; // Позиция стратегии в контейнере
			};
			IndexEntry1();
			uint   Stride; // @firstmember Шаг тренда
			TSVector <Range> RangeList; // Упорядоченный по возрастанию список диапазонов
		};
		struct Index1 : public TSCollection <IndexEntry1> {
		};
		int    CreateIndex1(Index1 & rIndex) const;
		//
		// Descr: Критерии подбора стратегии
		//
		enum {
			selcritVelocity   = 1, // По скорости выигрыша
			selcritWinRatio   = 2, // По отношению числа выигрышей к ставкам
			selcritResult     = 3, // По абсолютной величине выигрыша
			selcritStakeCount = 4, // По количеству ставок стратегии
			selcritfSkipAmbiguous   = 0x0100, // Флаг, блокирующий выбор стратегии, если существует хотя бы одна иная стратегия с противоположным направлением
			selcritfSkipShort       = 0x0200, // Флаг, блокирующий выбор коротких стратегий
			selcritfSkipLong        = 0x0400, // Флаг, блокирующий выбор длинных стратегий
			selcritfWeightAmbiguous = 0x0800, // Флаг, предписывающий при наличии разнонаправленных стратегий выбирать то направление,
				// которому соответствует большее количество допустимых стратегий. Если количества равны, то не выбирать ничего
			selcritfSingle  = 0x1000  // В коллекции намеренно представлена единственная стратегия: не применять критерий MinSimilItems
		};
		struct SelectBlock : public BestStrategyBlock {
			SelectBlock(const TSCollection <TrendEntry> & rTrendList, const Index1 & rIndex, uint bucketQuantMin);
			SelectBlock & FASTCALL Init(int lastTrendIdx, const LDATETIME & rLastDtm);
			//
			// @v11.5.12
			// Descr: Накопительная структура, задача которой набирать потенциальные стратегии за небольшой 
			//   период времени. Идея заключается в том, чтобы применять стратегию только в том случае, если
			//   она подкреплена одной или несколькими иными стратегиями, действующими в том же направлении 
			//   и актуальными в течении заданного промежутка времени (скажем, 5-10 минут).
			//
			struct Bucket {
				Bucket(uint timeQuantMin);
				int    PutStrategy(const PPObjTimeSeries::Strategy * pS, const LDATETIME & rDtm);
				PPID   GetFinalStrategyID(uint minCount) const;
				struct Entry { // @flat
					Entry();
					enum {
						fShort = 0x0001
					};
					long   ID;     // Ид стратегии 
					LDATETIME Dtm; // Время возникновения //
					uint   Flags;
				};
				const uint TimeQuantMin;
				TSVector <Entry> Q;
			};
			const  TSCollection <TrendEntry> & R_TrendList; // IN
			const  STimeSeries * P_Ts;    // IN
			const  RealArray   * P_VList; // IN Если P_VList !0 то локальное отклонение отсчитывается по нему, в противном случае - по P_Ts (если P_Ts != 0)
			int    LastTrendIdx;          // IN
			LDATETIME LastDtm;            // IN @v11.6.2 Момент последнего значения, по которому выбирается стратегия //
			long   Criterion;             // IN
			long   Reserve;               // 
			long   DevPtCount;            // IN Количество точек P_Ts, по которым отсчитывать разброс (для анализа неустойчивости ряда)
			long   LDMT_Factor;           // IN
			float  MainTrendMaxErrRel;    // IN Максимальная относительная ошибка магистрального тренда при выставлении ставки
			const  Index1 & R_Index;      // IN
			LongArray AllSuitedPosList;   // OUT
			Bucket Bckt;                  // OUT @v11.6.1
		};
		int    SelectS2(SelectBlock & rBlk) const;
		int    AddStrategyToOrderIndex(uint pos, long flags, TSArray <PPObjTimeSeries::StrategyContainer::CritEntry> & rIndex) const;
		int    MakeConfidenceEliminationIndex(const PPTssModelPacket & rTssPacket, uint maxCount, const LongArray * pSrcIdxList, LongArray & rToRemoveIdxList) const;
	private:
		int    FinalizeStrategySelection(SelectBlock & rBlk, uint strategyIdx, int lastTrendIdx) const;

		uint32 Ver;
		LDATETIME StorageTm;
		LDATETIME LastValTm;
	public:
		struct CriterionRange { // @persistent @flat
			CriterionRange();
			uint8 Crit; // 0 - nothing, 1 - ADF, 2 - TrendErrRel
			int8  Side; // -1 - any, 0 - buy only, 1 - sell only
			float low;
			float upp;
		};
		struct FlatBlock { // @flat @persistent
			FlatBlock();
			double MainTrendErrAvg;   // Среднее значение ошибки регрессии для магистрального тренда
			double AvgLocalDeviation; // Среднее локальное отклонение по всей выборке
			LDATE  UseDataForStrategiesTill;
			uint8  Reserve2[10];
			double ExperimentalFactor; // @20200819 Экспериментальный фактор, рассчитываемый по ситуации (с целью нахождения устойчивых контейнеров)
			CriterionRange Cr[2];      // 
			uint8  Reserve[6];         // 
		} Fb;
	};
	static int EditConfig(const PPObjTimeSeries::Config * pCfg);
	static int WriteConfig(PPObjTimeSeries::Config * pCfg, int use_ta);
	static int ReadConfig(PPObjTimeSeries::Config * pCfg);
	static SString & StrategyOutput(const char * pSymb, const PPObjTimeSeries::Strategy * pSre, SString & rBuf);
	static SString & StrategyToString(const PPObjTimeSeries::Strategy & rS, const PPObjTimeSeries::StrategyContainer * pSc, const double * pOptFactor, const double * pOptFactor2, SString & rBuf);
	static SString & StrategyToString(const PPObjTimeSeries::StrategyContainer & rSc, uint sidx, const double * pOptFactor, const double * pOptFactor2, SString & rBuf);
	static int TryStrategies(PPID id);
	static int EvaluateOptimalMaxDuck(PPID id);

	explicit PPObjTimeSeries(void * extraPtr = 0);
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPTimeSeriesPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPTimeSeriesPacket * pPack);
	int    SerializePacket(int dir, PPTimeSeriesPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Типы наборов стратегий
	//
	enum StrategySetType {
		sstAll       = 0, // Все (отобранные по максимально широким критериям: как минимум не убыточные)
		sstSelection = 1, // Отобранные из выборки sstAll путем последовательной отбраковки тех стратегий, которые в общей выборки снижают доходность.
		//sstSelectionTrendFollowing = 2 // Отобранные из выборки sstAll путем последовательной отбраковки тех стратегий, которые в общей выборки снижают доходность,
			// и с дополнительным ограничением на попутность тренда: тренд, которому соответствует стратегия должен соответствовать прожаже/покупке.
	};
	static SString & FASTCALL GetStrategySetTypeName(StrategySetType sst, SString & rBuf);
	int    PutStrategies(PPID id, StrategySetType sst, StrategyContainer * pL, int use_ta);
	int    GetStrategies(PPID id, StrategySetType sst, StrategyContainer & rL);
	int    SetTimeSeries(PPID id, STimeSeries * pTs, int use_ta);
	int    GetTimeSeries(PPID id, STimeSeries & rTs);
	int    SetExternTimeSeries(STimeSeries & rTs);
	int    SetExternTimeSeriesProp(const char * pSymb, const char * pPropSymb, const char * pPropVal);
	int    SetExternStakeEnvironment(const TsStakeEnvironment & rEnv, TsStakeEnvironment::StakeRequestBlock & rRet);
	int    SetExternTransactionNotification(const TsStakeEnvironment::TransactionNotification & rEnv);
	int    GetReqQuotes(TSVector <PPObjTimeSeries::QuoteReqEntry> & rList);
	int    Export(PPID id);
	int    Test(); // @experimental

	struct FactorToResultRelation {
		FactorToResultRelation();
		FactorToResultRelation(uint factorQuant, double result);
		uint   FactorQuant;
		uint   PeakAvg;
		double Result;
	};
	//
	// ARG(what IN): 0 - maxduck, 1 - peak
	// ARG(entireRange IN): !0 - прогонять расчет для каждого шага не зависимо от результата, в проитвном случае - остановиться когда обнаружен перегиб, указывающий на экстремум.
	//
	int    FindOptimalFactor(/*const DateTimeArray & rTmList, const RealArray & rValList*/const CommonTsParamBlock & rCtspb, const TrainNnParam & rS, int what,
		const IntRange & rMdRange, int mdStep, int entireRange, TSVector <FactorToResultRelation> & rSet, FactorToResultRelation & rResult);
	//static int Helper_FindOptimalFactor(const DateTimeArray & rTmList, const RealArray & rValList, const TrainNnParam & rS, double & rResult, uint & rPeakQuant);
	static const TrendEntry * FASTCALL SearchTrendEntry(const TSCollection <PPObjTimeSeries::TrendEntry> & rTrendList, uint stride);
private:
	virtual int RemoveObjV(PPID id, ObjCollection * pObjColl, uint options/* = rmv_default*/, void * pExtraParam);
	virtual int HandleMsg(int, PPID, PPID, void * extraPtr);
	//virtual int  ProcessReservedItem(TVRez &);
	virtual int Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    EditDialog(PPTimeSeriesPacket * pEntry);
};

struct TimeSeriesFilt : public PPBaseFilt {
	TimeSeriesFilt();

	uint8  ReserveStart[128]; // @anchor
	long   Flags;
	long   SortOrd;
	long   Reserve;          // @anchor
};

typedef PPTimeSeries TimeSeriesViewItem;

class PPViewTimeSeries : public PPView {
public:
	struct BrwItem { // @persistent @store(Reference2Tbl)
		explicit BrwItem(const PPTimeSeriesPacket * pTs);
		PPID   ID;             // @id
		char   Name[48];       // @name @!refname
		char   Symb[20];
		double BuyMarg;
		double SellMarg;
		double ManualMarg;
		int16  Type;
		int16  Prec;
		char   CurrencySymb[12];
		double SpikeQuant_t;   //
		double AvgSpread;      //
		uint32 OptMaxDuck;     // Оптимальная глубина проседания (в квантах) при длинной ставке
		uint32 OptMaxDuck_S;   // Оптимальная глубина проседания (в квантах) при короткой ставке
		uint16 PeakAvgQuant;
		uint16 PeakAvgQuant_S;
		uint16 TargetQuant;
		long   Flags;
		long   CfgFlags;
	};
	PPViewTimeSeries();
	~PPViewTimeSeries();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(TimeSeriesViewItem *);
	int    CmpSortIndexItems(PPViewBrowser * pBrw, const PPViewTimeSeries::BrwItem * pItem1, const PPViewTimeSeries::BrwItem * pItem2);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList(PPViewBrowser * pBrw);
	int    DeleteItem(PPID id);
	int    DeleteAll();

	SArray * P_DsList;
	TimeSeriesFilt Filt;
	PPObjTimeSeries Obj;
	PPObjTimeSeries::Config Cfg;
	TimeSeries_OptEntryList_Graph_Param * P_OelgParam;
};
//
//
//
class TimSerDetailFilt : public PPBaseFilt {
public:
	TimSerDetailFilt();

	uint8  ReserveStart[128]; // @anchor
	long   Flags;             // @flags
	PPID   TsID;              // Идент временной серии
	DateRange Period;         //
	long   Reserve;           // @anchor
};

class TimSerDetailViewItem {
public:
	TimSerDetailViewItem();
	uint   ItemIdx;
	SUniTime T;
	RealArray VL;
};

class PPViewTimSerDetail : public PPView {
public:
	PPViewTimSerDetail();
	~PPViewTimSerDetail();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(TimSerDetailViewItem *);
	int    ViewGraph(const PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList(PPViewBrowser * pBrw);

	SArray * P_DsList;
	TimSerDetailFilt Filt;
	PPObjTimeSeries Obj;
	STimeSeries Ts;
};

#if 0 // @construction {

class TimSerStrategyContainerFilt : public PPBaseFilt {
public:
	TimSerStrategyContainerFilt();

	uint8  ReserveStart[128]; // @anchor
	long   Flags;
	PPID   TsID;             // Идент временной серии
	long   Reserve;          // @anchor
};

class PPViewTimSerStrategyContainer : public PPView {
public:
	PPViewTimSerStrategyContainer();
	~PPViewTimSerStrategyContainer();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PPObjTimeSeries::Strategy *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList(PPViewBrowser * pBrw);

	SArray * P_DsList;
	TimSerStrategyContainerFilt Filt;
	PPObjTimeSeries::StrategyContainer Sc;
	PPObjTimeSeries TsObj;
};
#endif // } 0 @construction
//
//
//
class PrcssrTsStrategyAnalyzeFilt : public PPBaseFilt { // @persistent
public:
	PrcssrTsStrategyAnalyzeFilt();
	PrcssrTsStrategyAnalyzeFilt & FASTCALL operator = (const PrcssrTsStrategyAnalyzeFilt & rS);

	enum {
		fFindOptMaxDuck    = 0x0001,
		fFindStrategies    = 0x0002,
		fForce     = 0x0004,
		fProcessLong       = 0x0008,
		fProcessShort      = 0x0010,
		fAutodetectTargets = 0x0020, // Автоматически идентифицировать серии, модели по которым следует пересчитать
		fSimulateAfter     = 0x0040, // Провести имитационный тест после построения моделей
		fAnalyzeModels     = 0x0080, // Анализ возможных параметров моделей
	};
	uint8  ReserveStart[32]; // @anchor
	long   Flags;            // @flags
	long   CloseMode;        // PPObjTimeSeries::Strategy::clsmodXXX
	LDATE  UseDataForStrategiesTill;
	LDATE  UseDataForStrategiesTill2;
	uint8  ReserveEnd[52];   // @reserve
	ObjIdListFilt TsList;    // @anchor
};

class TryStrategyContainerResultCollection;

class PrcssrTsStrategyAnalyze {
public:
	struct ModelParam {
		ModelParam();
		ModelParam & Z();
		enum {
			fBestSubsetTrendFollowing = 0x0001,
			fOptRangeMulti    = 0x0004, // Для каждого триплета {frame; sl; tp} подбираются несколько оптимальных секторов (иначе - единственный)
		};
		//
		// Descr: Целевая функция при нахождении оптимальных секторов
		//
		enum {
			tcAmount       = 0, // Абсолютный объем выигрыша
			tcVelocity     = 1, // Скорость выигрыша
			tcWinRatio     = 2, // Вероятность выигрыша (количество выигрышей деленных на количество точек в секторе)
			tcAngularRatio = 3  // Угловая вероятность выигрыша (количество выигрышей деленных на радианный угол сектора)
		};
		long   Flags;
		long   OptTargetCriterion;
		LongArray InputFrameSizeList;   // Список не включает период магистрального тренда
		LongArray MaxDuckQuantList_Obsolete; // Не используется (оставлен из-за персистентности)
		LongArray TargetQuantList_Obsolete;  // Не используется (оставлен из-за персистентности)
		LAssocArray StakeBoundList;     // Пары {TP, SL} работающие вместо списков MaxDuckQuantList, TargetQuantList.
			// То есть, если StakeBoundList не пустой, то MaxDuckQuantList, TargetQuantList не используются
		LongArray MainFrameSizeList;
		double InitTrendErrLimit;
		double PartitialTrendErrLimit;  // Ограничение ошибки тренда по максимальной части общей выборки ошибок тренда.
			// Так значение 0.90 означает, что для стратегии будет применена максимальная ошибка не превышающая величину которой
			// соответствует 90 процентов значений тренда, отсортированных по значению ошибки.
		double InitMainTrendErrLimit;
		uint   BestSubsetDimention;
		uint   BestSubsetMaxPhonyIters;
		uint   BestSubsetOptChunk;      // 0 || 1 || 3 || 7 || 15
		uint   OptRangeStep;
		uint   OptRangeStepMkPart;
		uint   OptRangeMultiLimit;
		uint   OptRangeMaxExtProbe;     // @default=1 Максимальное количество попыток расширения оптимального интервала значений регрессии
		LDATE  UseDataSince;            // Модель строить по данным, начиная с указанной даты включительно (если checkdate(UseDataSince))
		LDATE  UseDataTill;             // Модель строить по данным для указанной даты включительно (если checkdate(UseDataTill))
		uint8  Reserve2[4];
		uint   MainFrameRangeCount;     // Количество сегментов, на которые разбивается все множество значений магистрального тренда для подбора стратегий
		double MinWinRate;              // Минимальное отношение выигрышей для стратегий, попадающих в финальную выборку
		double OverallWinRateLimit;     // Минимальное отношение выигрышей для всего множества отобранных стратегий
		long   Reserve;
	};
	static int  ReadModelParam(ModelParam & rMp);
	PrcssrTsStrategyAnalyze();
	~PrcssrTsStrategyAnalyze();
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int    Init(const PPBaseFilt * pBaseFilt);
	int    GetTssModel(const PPTimeSeries * pTsRec, PPTssModelPacket * pTssModel);
	int    Run();
	int    TryStrategyContainers(const PPIDArray & rTsList);
	enum {
		tscfSkipOutput = 0x0001
	};
	int    TryStrategyContainer(const PPObjTimeSeries::Config & rCfg, PPID tsID,
		const STimeSeries * pTs, const PPObjTimeSeries::StrategyContainer * pSc, long flags, TryStrategyContainerResultCollection & rResultCollection);
	int    OutputTryStrategyContainerResult(TryStrategyContainerResultCollection & rRc);
	int    AnalyzeRegression(PPID tsID);
	//
	// Descr: Флаги функции FindOptimalMaxDuck
	//
	enum {
		fomdfShort       = 0x0001, // Продажа. Если не установлен - покупка.
		fomdfStoreResult = 0x0002, // При успешном завершении сохранить результат в базе данных (PPTimeSeriesPacket::Rec.OptMaxDuck_S или PPTimeSeriesPacket::Rec.OptMaxDuck)
		fomdfEntireRange = 0x0004  // Рассчитывать результаты для всего диапазона значений (медленно, но покажет все результаты)
	};
	int    FindOptimalMaxDuck(const PPTimeSeriesPacket & rTsPack,
		/*const DateTimeArray & rTsTmList, const RealArray & rTsValList,*/const PPObjTimeSeries::CommonTsParamBlock & rCtspb, uint flags, uint * pResult);
	//
	// Descr: Увеличивает внутренний счетчик идентификаторов и возвращает новое значение идентификатора для очередной стратегии.
	//
	long   GetNewStrategyId() const;
private:
	struct TsMainFrameRange {
		uint   MainFrameSize;
		RealRange R;
	};
	int    GetTimeSeries(PPID tsID, LDATE dateSince, LDATE dateTill, STimeSeries & rTs);
	int    FindStrategies(void * pBlk) const;
	int    SimulateStrategyResultEntries(void * pBlk, const TSVector <PPObjTimeSeries::StrategyResultEntry> & rList,
		uint firstIdx, uint lastIdx, uint maxDuckQuant, uint targetQuant, PPObjTimeSeries::StrategyResultEntry & rResult,
		TSVector <PPObjTimeSeries::StrategyResultValueEx> * pDetailList) const;
	int    FindStrategiesLoop(void * pBlk);
	struct ResonanceCombination {
		uint   MaxDuckQuant;
		uint   TargetQuant;
		uint   FrameSize;
	};
	uint   CalcStakeCountAtFinalSimulation(const TSVector <PPObjTimeSeries::StrategyResultValueEx> & rSreEx, uint scIdx) const;
	double CalcStakeResult(const TSVector <PPObjTimeSeries::StrategyResultValueEx> & rSreEx, uint scIdx) const;
	uint   CalcStakeDistanceMedian(const TSVector <PPObjTimeSeries::StrategyResultValueEx> & rSreEx, uint scIdx) const;
	enum {
		mavfDontSqrtErrList = 0x0001
	};
	int    MakeArVectors(const STimeSeries & rTs, const LongArray & rFrameSizeList, uint flags, double partitialTrendErrLimit, TSCollection <PPObjTimeSeries::TrendEntry> & rTrendListSet);
	int    MakeArVectors2(const STimeSeries & rTs, const LongArray & rFrameSizeList, const PPTssModelPacket * pTssModel, uint flags, TSCollection <PPObjTimeSeries::TrendEntry> & rTrendListSet);
	int    MakeTrendEntry(const DateTimeArray * pTimeVec, const RealArray & rValueList, uint flags, PPObjTimeSeries::TrendEntry * pEntry, RealArray * pTempCov00List);
	enum {
		esfDontFinish = 0x0001 // Не сохранять стратегии
	};
	int    EvaluateStrategies(void * pBlk, LDATE dateTill, long flags, SFile & rFOutTotal, PPObjTimeSeries::StrategyResultEntry * pResult);
	PrcssrTsStrategyAnalyzeFilt P;
	PPObjTimeSeries TsObj;
	mutable ACount LastStrategyId;
};
//
// @ModuleDecl(CurRateCore)
// Валютные курсы
//
struct CurRateIdent { // @flat
	PPID   CurID;
	PPID   BaseCurID;
	PPID   RateTypeID;
	LDATE  Dt;
};

struct UhttCurRateIdent { // @flat
	CurRateIdent Ident;
	double Rate;
};

class CurRateCore : public CurrencyRateTbl {
public:
	CurRateCore();
	int    SearchRate(const CurRateIdent *, CurrencyRateTbl::Rec * = 0);
	int    GetRate(PPID curID, PPID rateTypeID, PPID relCurID, LDATE *, double *);
	int    UpdateRate(const CurRateIdent *, double, int use_ta);
	int    RemoveRate(const CurRateIdent *, int use_ta);
};
//
// @ModuleDecl(PPObjAmountType)
// Типы сумм документов
//
struct PPAmountType2 {     // @persistent @store(Reference2Tbl+)
	PPAmountType2();
	bool   IsTax(PPID taxID  /* GTAX_XXX */) const;
	bool   IsComplementary() const;
	enum {
		fErrOnDefault        = 0x0001, // Если сумма в документе отсутствует, то генерировать сообщение об ошибке
		fManual              = 0x0002, // Сумма может быть введена в ручную.
			// Если флаг установлен, то допускается ручной ввод суммы.
			// Если нет, то сумма расчитывается автоматически по содержанию
			// документа. Исключение - номинальная сумма (PPAMT_MAIN).
			// Она может быть как автоматической так и устанавливаемой в
			// ручную в зависимости от вида операции.
		fTax                 = 0x0004, // Сумма налога. Если этот флаг установлен,
			// то значение суммы отражает сумму налога Tax со ставкой (TaxRate*100) %,
			// которым облагается данная операция.
		//
		// Назначение следующих трех флагов в том, чтобы можно было быстро определить итоговые
		// обобщенные суммы GenCost, GenPrice, GenDiscount по товарному документу.
		//
		fReplaceCost         = 0x0010, // Замещает сумму в ценах поступления (Cost)
		fReplacePrice        = 0x0020, // Замещает сумму в ценах реализациия (Price)
		fReplaceDiscount     = 0x0040, // Замещает скидку (Discount) @#{fReplaceCost^fReplacePrice^fReplaceDiscount}
		fInAmount            = 0x0080, // Входящая сумма, комплементарная сумме RefAmtTypeID
		fOutAmount           = 0x0100, // Исходящая сумма, комплементарная сумме RefAmtTypeID @#{fTax^fInAmount^fOutAmount}
		fReplaces            = (fReplaceCost | fReplacePrice | fReplaceDiscount),
		fStaffAmount         = 0x0200, // Штатная сумма (используется для расчета зарплаты)
		fFormula             = 0x0400, // С суммой ассоциирована формула.
			// Если такая сумма определена в виде операции, то для документа значение этой суммы автоматически рассчитывается по указанной формуле.
		fDistribCost         = 0x0800, // Распределять сумму на себестоимость строк товарного документа.
		fDcNeg               = 0x1000, // На себестоимость строк документа распределяется отрицательное значение суммы (уменьшает себестоимость).
		fEachTrfrItemFormula = 0x2000  // @v12.0.7 Если установлен, то формула суммы применяется к каждой товарной строке документа по-отдельности.
			// Флаг имеет смысл только если установлен флаг fFormula. 
	};
	long   Tag;            // Const=PPOBJ_AMOUNTTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ для представления в формулах
	char   Reserve[56];    // @reserve
	int16  EcAlg;          // Алгоритм распределения суммы на себестоимость строк документа.
	int16  Reserve2;       // @alignment
	long   Flags;          // Флаги
	long   Tax;            // Налог (GTAX_XXX)
	union {
		long   TaxRate;       // Ставка налога в сотых долях процента (Flags & fTax)
		PPID   RefAmtTypeID;  // Сумма, комплементарная данной (Flags & (fInAmount | fOutAmount))
	};
};

struct PPAmountTypePacket {
	PPAmountTypePacket();
	int    FASTCALL IsEq(const PPAmountTypePacket & rS) const;

	PPAmountType Rec;
	//
	// Замечание по использованию поля Formula:
	//   Функция PPObjBill::SetupSpecialAmounts ...
	//
	SString Formula;
};

struct TaxAmountIDs {
	TaxAmountIDs();
	TaxAmountIDs & Z();
	bool   HasAnyVatAmountTypes() const { return (VatAmtID[0] || VatAmtID[1] || VatAmtID[2] || VatAmtID[3] || VatAmtID[4]); }
	bool   HasAnyAmountTypes() const { return (STaxAmtID || HasAnyVatAmountTypes()); }

	PPID   VatAmtID[5]; // @v12.2.11 [3]--[5] Типы сумм для различных ставок НДС
	long   VatRate[5];  // @v12.2.11 [3]--[5] Значения различных ставок НДС
	PPID   STaxAmtID;   // Тип суммы для налога с продаж
	long   STaxRate;    // Ставка налога с продаж
};

class PPObjAmountType : public PPObjReference {
public:
	explicit PPObjAmountType(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    SearchSymb(PPID *, const char * pSymb);
	int    GetTaxAmountIDs(TaxAmountIDs &, int useCache);
	int    CheckDupTax(PPID, PPID tax, long taxRate);
	enum {
		selStaffOnly = 0x0001
	};
	StrAssocArray * CreateSelectorList(long options, const PPIDArray * pIncludeList);
	int    PutPacket(PPID * pID, PPAmountTypePacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPAmountTypePacket * pPack);
	int    SerializePacket(int dir, PPAmountTypePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    GetFormulaList(StrAssocArray * pList);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Symb, Flags, Tax, TaxRate, RefAmtTypeID}
	//
	int    FASTCALL Fetch(PPID id, PPAmountType * pRec);
	int    FetchByTax(PPID *, PPID tax, double rate);
	int    FetchCompl(PPID srcAmtID, PPID * pInAmtID, PPID * pOutAmtID);
	//
	// Descr: Если существует хотя бы один тип суммы, требующий распределения //
	//   по себестоимости строк приходного документа, то функция возвращает 1.
	//   В противном случае возвращает 0.
	//
	int    IsThereDistribCostAmounts();
private:
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  ProcessReservedItem(TVRez &);
	virtual void FASTCALL Dirty(PPID);
	int    GetFormula(PPID id, SString & rBuf);
};
//
// @ModuleDecl(PPObjOprType)
// Типы операций
//
struct PPOprType2 {        // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_OPRTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	char   Pict[8];        //
	long   Reserve2[2];    // @reserve
};

class PPObjOprType : public PPObjReference {
public:
	PPObjOprType(void * extraPtr);
	//virtual int Edit(PPID *, long);
};
//
// @ModuleDecl(PPObjOpCounter)
// @todo Создать отдельную таблицу Seq для хранения значений счетчиков (вместо PPOpCounter2::Counter)
//
#define OPCNTF_LOCKINCR    0x00000001L // Не изменять значение счетчика при получении очередной величины
#define OPCNTF_DIFFBYLOC   0x00000002L // Счетчики, рездельные по складам
#define OPCNTF_VERIFYUNIQ  0x00000004L // @v11.9.2 При создании документа проверять уникальность номера

struct PPOpCounter2 {      // @persistent @store(Reference2Tbl+)
	PPOpCounter2();
	long   Tag;            // Const=PPOBJ_OPCOUNTER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // @symb
	char   CodeTemplate[24]; // Шаблон нумерации
	char   Reserve[32];    // @reserve
	PPID   ObjType;        // Тип объекта, владеющего счетчиком. Если 0, то PPOBJ_OPRKIND
	long   Flags;          // OPCNTF_XXX
	long   Counter;        //
	long   OwnerObjID;     // Объект-владелец счетчика (если 0, то может принадлежать более чем одной операции)
		// Если OwnerObjID == -1, то счетчик принадлежит конфигурации объекта ObjType
};

class PPOpCounterPacket {
public:
	PPOpCounterPacket();
	~PPOpCounterPacket();
	PPOpCounterPacket & FASTCALL operator = (const PPOpCounterPacket &aPack);
	int    Init(const PPOpCounter *, const LAssocArray *);
	int    Init(const LAssocArray *);
	int    CopyUnnamed(const PPOpCounterPacket *);
	int    GetCounter(PPID locID, long * pCounter);
	int    SetCounter(PPID locID, long counter);
	int    CounterIncr(PPID locID, long * pCounter, int incr = 1);
	int    UngetCounter(PPID locID, long counter);
	int    ResetAll();

	PPOpCounter Head;
	LAssocArray * P_Items;
	enum {
		fDontLogUpdAction = 0x0001, // Функция PutPacket не фиксирует событие изменения объекта.
			// Эта опция используется при автоматическом увеличении счетчика функцией PPObjOpCounter::
		fDontUpdCounter   = 0x0002  // Функция PutPacket не изменяет значение счетчика
	};
	long   Flags;
};

class PPObjOpCounter : public PPObjReference {
public:
	static int ResetAll();

	PPObjOpCounter(void * extraPtr = 0);
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID *, void * extraPtr);
	int    CodeByTemplate(const char * pTempl, long counter, SString & rBuf);
	int    CheckCodeTemplate(const char * pTempl, size_t bufSize);
	int    UpdateCounter(PPID id, long counter, long flags, PPID locID, int use_ta);
		// @<<PPObjBill::UpdateOpCounter
	int    GetCounter(PPID id, PPID locID, long * pCounter, int use_ta);
	int    GetCode(PPID id, long * pCounter, char * pBuf, size_t buflen, PPID locID, int use_ta);
	int    UngetCounter(PPID id, long counter, PPID locID, int use_ta);
	int    PutPacket(PPID *pOpCntrID, const PPOpCounterPacket *, int use_ta);
	int    GetPacket(PPID opCntrID, PPOpCounterPacket *);
private:
	virtual int  MakeReserved(long flags);
	int    Helper_GetCounter(PPID id, PPID locID, long * pCounter, SString * pCodeBuf, int use_ta);
};
//
// @ModuleDecl(PPObjGoodsClass)
// Классы товаров
//
struct PPGdsClsProp {
	PPGdsClsProp();
	PPGdsClsProp & FASTCALL operator = (const PPGdsClsProp &);
	PPGdsClsProp & Z();

	char   Name[32];
	PPID   ItemsListID;
};

struct PPGdsClsDim {
	PPGdsClsDim();
	PPGdsClsDim & FASTCALL operator = (const PPGdsClsDim &);
	PPGdsClsDim & Z();
	SString & ToStr(SString & rBuf) const;
	int    FromStr(int, const char *);

	char   Name[32];
	long   Scale;
	LongArray ValList;
};

struct PPGdsCls2 {         // @persistent @store(Reference2Tbl+)
	static int   IsEqByDynGenMask(long mask, const GoodsExtTbl::Rec * p1, const GoodsExtTbl::Rec * p2);
	static long  FASTCALL UseFlagToE(long useFlag);
	static long  FASTCALL EToUseFlag(long e);

	PPGdsCls2();
	void   SetDynGenMask(int fld, int val);
	bool   FASTCALL GetDynGenMask(int fld) const;

	enum { // @persistent
		eKind  = 1,
		eGrade = 2,
		eAdd   = 3,
		eX     = 4,
		eY     = 5,
		eZ     = 6,
		eW     = 7,
		eAdd2  = 8
	};
	enum { // @persistent
		fUsePropKind    = 0x0001,
		fUsePropGrade   = 0x0002,
		fUsePropAdd     = 0x0004,
		fUseDimX        = 0x0008,
		fUseDimY        = 0x0010,
		fUseDimZ        = 0x0020,
		fStdEditDlg     = 0x0100, // Используется стандартный, а не редуцированный диалог редактирования товаров, относящихся к классу
		fDupCombine     = 0x0200, // Комбинации {PropKind, PropGrade, DimX, DimY, DimZ} могут дублироваться //
		fDisableFreeDim = 0x0400, // Запрет на ввод размерностей не перечисленных в списке
		fUseDimW        = 0x0800, // Использует размерность W
		fUsePropAdd2    = 0x1000, // Использует свойство Add2
		fPrintDiffLots  = 0x2000  // При печати разделять строки, относящиеся к разным лотам
	};

	long   Tag;            // Const=PPOBJ_GOODSCLASS
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	PPID   LotDimUnitID;   // Единица измерения для размерностей лота
	uint8  LotDimCount;    // Количество размерностей лота [0..3]
	uint8  Reserve3;       // @reserve
	uint16 Reserve4;       // @reserve
	PPID   DefGrpID;       // Группа товара по умолчанию. Используется в случае создания товара только по параметрам расширения.
	PPID   DefUnitID;      //
	PPID   DefPhUnitID;    //
	long   DefPhUPerU;     // @unused
	PPID   DefTaxGrpID;    //
	PPID   DefGoodsTypeID; //
	uint16 EditDlgID;      //
	uint16 FiltDlgID;      //
	long   Flags;          //
	long   Reserve2;       // @reserve
	long   DynGenMask;     // Маска динамического обобщения. Флаги маски соответствуют
		// элементам перечисления (1<<(PPGdsCls::eXXX-1)). Если система видит обобщенный товар G с
		// параметрами расширения, соответствующими маске, эквивалентными некоторому товару X,
		// то считает, что X принадлежит G.
};

struct PPGdsClsFormula {
	PPGdsClsFormula();
	PPGdsClsFormula & Z();
	int    FASTCALL PutToBuffer(SString & rBuf) const;
	int    FASTCALL GetFromBuffer(const char * pBuf);
	enum {
		fDefault = 0x0001 // Формула по умолчанию (в диалоге расчета, если существует более одной формулы, эта формула устанавливается автоматом //
	};
	SString Name;
	SString Symb;     // @v12.0.11 Символ для ссылки на формулу  
	SString Formula;
	SString Var1Name; // "@1"
	SString Var2Name; // "@2"
	SString Var3Name; // "@3"
	long   Flags;
};

struct PPGdsClsPacket {
	PPGdsClsPacket();
	PPGdsClsPacket(const PPGdsClsPacket & rS);
	PPGdsClsPacket & FASTCALL operator = (const PPGdsClsPacket &);
	PPGdsClsPacket & Z();
	int    FASTCALL Copy(const PPGdsClsPacket &);
	int    CompleteGoodsPacket(PPGoodsPacket *);
	int    GetPropName(int prop, SString & rBuf) const;
	int    FormatProp(const PPGdsClsProp *, PPID propVal, SString & rBuf) const;
	void   FormatDim(const PPGdsClsDim *, long dimVal, SString & rBuf) const;
	int    GetNameByTemplate(PPGoodsPacket *, const char * pTemplate, char * pBuf, size_t bufLen, SubstGrpGoods sgg = sggNone) const;
	int    PropNameToID(int prop, const char * pName, PPID * pID, int forceCreate, int use_ta);
	int    PropSymbToID(int prop, const char * pSymb, PPID * pID);
	int    GetExtDim(const GoodsExtTbl::Rec * pRec, int dim, double * pVal) const;
	int    GetExtProp(const GoodsExtTbl::Rec * pRec, int prop, long * pID, SString & rBuf) const;
	int    GetExtProp(const GoodsExtTbl::Rec * pRec, int prop, int * pID, SString & rBuf) const
		{ return GetExtProp(pRec, prop, reinterpret_cast<long *>(pID), rBuf); } // @v11.7.10
	int    GetExtProp(const GoodsExtTbl::Rec * pRec, int prop, SString & rBuf) const
		{ return GetExtProp(pRec, prop, reinterpret_cast<long *>(0), rBuf); } // @v11.7.10
	int    RealToExtDim(double realVal, int dim, long * pLongVal) const;
	int    RealToExtDim(double realVal, int dim, GoodsExtTbl::Rec & rExtRec) const;
	int    GetDynGenFilt(const GoodsExtTbl::Rec * pRec, ClsdGoodsFilt * pFilt) const;
	//
	// Формулы индексируются в списке от единицы (1..)
	//
	int    PutFormula(int * pIdx, const PPGdsClsFormula *);
	int    GetFormula(int idx, PPGdsClsFormula *) const;
	//
	// Descr: Находит в пакете формулу по символу pSymb.
	//   Если в пакете есть более одной формулы с искомым символом, то функция вернет только первую по порядку их расположения в списке FormulaList
	// Returns:
	//   true - формула по символу pSymb найдена
	//   false - формула не найдена
	//
	bool   GetFormulaBySymb(const char * pSymb, PPGdsClsFormula *) const;
	int    PutFormulaListToBuf(SString & rBuf) const;
	int    GetFormulaListFromBuf(const char *);
	//
	// Descr: Устанавливает у формулы, находящейся в позиции pos списка FormulaList
	//   флаг PPGdsClsFormula::fDefault. Одновременно снимает (если установлен) этот
	//   флаг у остальных формул списка.
	// ARG(idx IN): @#[1..FormulaList.getCount()] Индекс формулы в списке.
	//
	int    SetDefaultFormula(int idx);

	PPGdsCls Rec;
	SString NameConv;
	SString AbbrConv;
	SString PhUPerU_Formula;
	SString TaxMult_Formula;
	SString Package_Formula;
	SString Brutto_Formula; // @v12.0.10
	SString LotDimQtty_Formula; // Формула пересчета размерностей лота в количество
	PPGdsClsProp PropKind;
	PPGdsClsProp PropGrade;
	PPGdsClsProp PropAdd;
	PPGdsClsProp PropAdd2;
	PPGdsClsDim  DimX;
	PPGdsClsDim  DimY;
	PPGdsClsDim  DimZ;
	PPGdsClsDim  DimW;
	SStrCollection FormulaList; // Список формул
private:
	int    CheckForSgg(long sym, SubstGrpGoods sgg) const; // AHTOXA
		// @<<PPGdsClsPacket::GetNameByTemplate
};

class PPObjGoodsClass : public PPObjReference {
public:
	PPObjGoodsClass(void * extraPtr = 0);
	virtual int  Edit(PPID *, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    GetPacket(PPID, PPGdsClsPacket *);
	int    PutPacket(PPID *, PPGdsClsPacket *, int use_ta);
	int    SerializePacket(int dir, PPGdsClsPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Fetch(PPID id, PPGdsClsPacket *); // AHTOXA
	//
	// Descr: Печатает список классов по структуре GoodsClassView
	// ARG(id IN): Не используется //
	//
	int    Print(PPID /*id*/);
private:
	static int PutProp(SString & rLineBuf, uint fldID, PPGdsClsProp *);
	static int GetProp(const SString & rLineBuf, uint fldID, PPGdsClsProp *);
	static int PutPropsToLine(SString & rLine, PPGdsClsPacket * pPack);
	static int GetPropsFromLine(const SString & rLine, PPGdsClsPacket * pPack);
	static int SerializeDim(int dir, PPGdsClsDim * p, SBuffer & rBuf, SSerializeContext * pSCtx);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	int    PutDim(PPID gdsClsID, PPID propID, PPGdsClsDim *);
	int    GetDim(PPID gdsClsID, PPID propID, PPGdsClsDim *);
	int    ReplacePropRefList(PPID prevObjType, PPID newObjType, LAssocArray * pAssc, LAssocArray * pBadRefList);
		// @<<PPObjGoodsClass::UpdatePropObjType
	int    UpdatePropObjType(PPID clsID, int gcProp, PPID prevObjType, PPID newObjType, LAssocArray * pBadRefList);
		// @<<PPObjGoodsClass::Edit
};
//
// @ModuleDecl(PPObjAssetWrOffGrp)
// Группы списания основных средств
//
#define AWOGT_AMRTZ_LIN   1L // Линейное списание амортизации
#define AWOGT_AMRTZ_ACCEL 2L // Ускоренное списание амортизации
#define AWOGT_INDIRCOST   3L // Списание непрямых издержек как прямых

struct PPAssetWrOffGrp2 {  // @persistent @store(Reference2Tbl+)
	PPAssetWrOffGrp2(); // @v11.9.6
	PPID   Tag;            // Const=PPOBJ_ASSTWROFFGRP
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Code[20];       // Код нормы амортизационных отчислений
	char   Reserve[48];    // @reserve
	long   WrOffType;      // Тип списания (AWOGT_XXX)
	long   WrOffTerm;      // Months
	long   Limit;          // Предельная остаточная стоимость (% от начальной стоимости)
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};

class PPObjAssetWrOffGrp : public PPObjReference {
public:
	explicit PPObjAssetWrOffGrp(void * extraPtr = 0);
	virtual int Edit(PPID *, void * extraPtr);
	virtual int Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjOprKind)
// Виды операций
//
//
// Флаги видов операций
//
#define OPKF_NEEDPAYMENT       0x00000001L // Операция требует платежного документа
#define OPKF_GRECEIPT          0x00000002L // Приход товара
#define OPKF_GEXPEND           0x00000004L // Расход товара
#define OPKF_BUYING            0x00000008L // Номинал операции в ценах поступления //
#define OPKF_SELLING           0x00000010L // Номинал операции в ценах реализации  //
#define OPKF_NOUPDLOTREST      0x00000020L // Товарная операция, не изменяющая остаток по лоту
#define OPKF_ADVACC            0x00000040L // Бухгалтерская операция, позволяющая документу содержать строки расширения //
#define OPKF_PROFITABLE        0x00000080L // Операция доходная //
#define OPKF_ONORDER           0x00000100L // Операция продажи, допускающая продажу по заказу
#define OPKF_FREIGHT           0x00000200L // Операция поддерживает ввод данных фрахта
#define OPKF_PCKGMOUNTING      0x00000400L // Расходная операция только для формирования пакетов
#define OPKF_ORDEXSTONLY       0x00000800L // В заказах видны только те товары, которые есть на остатке
#define OPKF_ORDRESERVE        0x00001000L // Резервирующий заказ
#define OPKF_CALCSTAXES        0x00002000L // Считать налоги с продаж (НДС и акциз)
#define OPKF_CHARGENEGPAYM     0x00004000L // Начисление ренты интерпретировать как отрицательную оплату основного документа
#define OPKF_AUTOWL            0x00008000L // Автоматическая метка в документе
#define OPKF_ATTACHFILES       0x00010000L // Присоединять файлы к документам
#define OPKF_USEEXT            0x00020000L // Ввод расширенной информации по документу (агент, плательщик, etc) // @v12.3.4 OPKF_USEEXT-->OPKF_USEEXT
#define OPKF_ORDERBYLOC        0x00040000L // Заказ привязан к складу (заказ от подразделения)
#define OPKF_NEEDVALUATION     0x00080000L // Операция требует расценки @only(PPOPT_GOODSRECEIPT)
#define OPKF_OUTBALACCTURN     0x00100000L // Забалансовая бух проводка
#define OPKF_EXTACCTURN        0x00200000L // Расширенная бух проводка
#define OPKF_EXTAMTLIST        0x00400000L // Операция поддерживает список доп сумм
#define OPKF_DENYREVALCOST     0x00800000L // Не допускается переоценка цен поступления @only(PPOPT_GOODSREVAL)
#define OPKF_RENT              0x01000000L // С документом может быть ассоциирован договор ренты
#define OPKF_NEEDACK           0x02000000L // Документ требует подтверждения      //
#define OPKF_NOCALCTIORD       0x04000000L // Не расчитывать заказ товара в строках документа
#define OPKF_RECKON            0x08000000L // Операция используется как платежная //
#define OPKF_BANKING           0x10000000L // Банковский платежный документ
#define OPKF_PASSIVE           0x20000000L // Пассивная операция (не видна в списках выбора)
#define OPKF_CURTRANSIT        0x40000000L // Транзитная валютная операция        //
#define OPKF_RESTRICTBYMTX     0x80000000L // Ограничивать выбор товара по операции товарной матрицей
#define OPKF_GOODS             (OPKF_GRECEIPT|OPKF_GEXPEND)
//
// Расширенные флаги видов операций
//
#define OPKFX_RESTRICTPRICE    0x00000001L // Ограничивать цену реализации формулой
#define OPKFX_ALLOWPARTSTR     0x00000002L // Допускается распределение частичных структур по документам
#define OPKFX_UNLINKRET        0x00000004L // Непривязанный возврат (от покупателя или поставщику). Специализированный флаг, не используемый в учете, но лишь для расчета лимита возвратов.
#define OPKFX_USESUPPLDEAL     0x00000008L // (для драфт-приходов) При вводе строки применять контрактную цену поставщика как цену поступления.
#define OPKFX_CANBEDECLINED    0x00000010L // (для драфт-документов) Допускается функция отклонения документа
#define OPKFX_MCR_GROUP        0x00000020L // Ограничение комплементарности позиций в документе модификации (общая группа)
#define OPKFX_MCR_SUBSTSTRUC   0x00000040L // Ограничение комплементарности позиций в документе модификации (подстановочная структура)
#define OPKFX_MCR_EQQTTY       0x00000080L // Ограничение комплементарности позиций в документе модификации (одинаковое количество)
#define OPKFX_DSBLHALFMODIF    0x00000100L // Запрет "половинчатой" модификации. То есть, в документе модификации должны быть и вход и выход
#define OPKFX_DLVRLOCASWH      0x00000200L // Адрес доставки в приходных (и драфт-приходных) документах трактовать как склад-получатель
#define OPKFX_SOURCESERIAL     0x00000400L // (драфт-приходы и модификация)  Допускает выбор серийного номера исходного лота
#define OPKFX_IGNORECLISTOP    0x00000800L // Игнорировать признак STOP контрагента при создании документа
#define OPKFX_AUTOGENUUID      0x00001000L // Автоматически генерировать UUID документа при создании.
#define OPKFX_WROFFTODRAFTORD  0x00002000L // Специализированная операция заказа, списываемая в драфт-документ
#define OPKFX_PAYMENT_CASH     0x00004000L // @erik Наличный расчет по операции
#define OPKFX_PAYMENT_NONCASH  0x00008000L // @erik Безналичный расчет по операции
#define OPKFX_ACCAUTOVAT       0x00010000L // @v11.6.6 Для бухгалтерских документов автоматически расчитывать суммы налогов 
#define OPKFX_MNGPREFSUPPL     0x00020000L // @v12.0.8 (для заказов и, возможно, для драфт-документов) Применяется функционал 
	// администрирования предпочтительного поставщика для дозаказа товара поставщику.
#define OPKFX_SETCTXAGENT      0x00040000L // @v12.3.4 При создании документа присваивать ему агента в соответствии с контекстом (видимо, под контекстом пока
	// будем подразумевать пользователя, который создает документ - дальше посмотрим как пойдет).

#define OPKF_PRT_INCINVC       0x00000001L // Входящая счет-фактура на предоплату
#define OPKF_PRT_NEGINVC       0x00000002L // Счет-фактура с отрицательными суммами
#define OPKF_PRT_CHECK         0x00000004L // Печатать чек по документу
#define OPKF_PRT_CHECKTI       0x00000008L // Печатать чек по документу с товарными строками
#define OPKF_PRT_SRVACT        0x00000010L // Печатать акт выполненных работ
#define OPKF_PRT_BUYING        0x00000020L // Печатать в ценах поступления //
#define OPKF_PRT_SELLING       0x00000040L // Печатать в ценах реализации  //
#define OPKF_PRT_EXTOBJ2OBJ    0x00000080L // В структуре GoodsBillBase вместо object подставлять extobject
#define OPKF_PRT_TARESALDO     0x00000100L // Печатать сальдо по таре (только если определено PPGoodsConfig::TareGrpID)
#define OPKF_PRT_QCERT         0x00000200L // Печатать сертификаты
#define OPKF_PRT_NBILLN        0x00000400L // В первичном документе не печатать номер
#define OPKF_PRT_VATAX         0x00000800L // В накладной печатать колонки НДС
#define OPKF_PRT_INVOICE       0x00001000L // Печатать счет-фактуру
#define OPKF_PRT_QCG           0x00004000L // Печатать сертификаты с товаром
#define OPKF_PRT_SHRTORG       0x00010000L // Печатать сокращ. наименование гл. организации
#define OPKF_PRT_CASHORD       0x00080000L // Печатать кассовый ордер
#define OPKF_PRT_SELPRICE      0x00100000L // Печать цен в накладной на выбор
#define OPKF_PRT_NDISCNT       0x00800000L // Не печатать скидку в накладной
#define OPKF_PRT_LOCDISP       0x01000000L // @v11.3.11 Печатать наряд на складскую сборку (используется неявно для идентификации варианта выбора)
#define OPKF_PRT_PAYPLAN       0x02000000L // Печатать план платежей по документу
#define OPKF_PRT_LADING        0x04000000L // Печатать товарно-транспортную накладную
#define OPKF_PRT_MERGETI       0x08000000L // Объединять товарные строки
#define OPKF_PRT_PLABEL        0x10000000L // Печатать ценник
#define OPKF_PRT_BCODELIST     0x20000000L // Печатать в накладной список штрихкодов
#define OPKF_PRT_QCERTLIST     0x40000000L // Печатать список сертификатов
#define OPKF_PRT_LOTTAGIMG     0x80000000L // Печать изображений из тегов лотов

#define OPKF_PRT_EXTFORMFLAGS (OPKF_PRT_CASHORD|OPKF_PRT_INVOICE|OPKF_PRT_QCERT|OPKF_PRT_LADING|OPKF_PRT_SRVACT|OPKF_PRT_PLABEL|OPKF_PRT_TARESALDO|OPKF_PRT_LOTTAGIMG)

#define OPSUBT_COMMON                 0 // Без подтипа (поведение определяется по типу операции и по флажкам)
#define OPSUBT_ADVANCEREP             1 // PPOPT_ACCTURN      Авансовый отчет
#define OPSUBT_REGISTER               2 // PPOPT_ACCTURN      Регистровая общая проводка (автоматом снимает признак OPKF_EXTACCTURN)
#define OPSUBT_ASSETRCV               3 // PPOPT_GOODSRECEIPT Приобретение основных средств
#define OPSUBT_ASSETEXPL              4 // PPOPT_GOODSREVAL   Ввод в эксплуатацию основных средств
#define OPSUBT_WARRANT                5 // Доверенность
#define OPSUBT_ASSETMODIF             6 // Модификация основных средств
#define OPSUBT_DEBTINVENT             7 // Инвентаризация задолженности
#define OPSUBT_TRADEPLAN              8 // План торговли (драфт-операции)
#define OPSUBT_ACCWROFF               9 // PPOPT_ACCTURN Списание по бухгалтерским счетам
#define OPSUBT_POSCORRECTION         10 // Корректировка фискальных сумм по кассовому аппарату
#define OPSUBT_RETURNREQ             11 // PPOPT_DRAFTRECEIPT Запрос от покупателя на возврат ранее купленного товара.
	// Variant of [EDI 180 Return Merchandise Authorization and Notification]
//
// Descr: Заголовочная запись вида операций
//
struct PPOprKind2 {        // @persistent @store(Reference2Tbl+)
	PPOprKind2();
	long   Tag;            // Const=PPOBJ_OPRKIND
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	PPID   InitStatusID;   // Статус для новых документов
	long   ExtFlags;       // Расширенные флаги
	int16  Rank;           //
	int16  Reserve2;       // @reserve
	PPID   LinkOpID;       //
	PPID   AccSheet2ID;    //
	PPID   OpCounterID;    //
	long   PrnFlags;       //
	PPID   DefLocID;       //
	int16  PrnOrder;       //
	int16  SubType;        // OPSUBT_XXX
	long   Flags;          // OPKF_XXX
	PPID   OpTypeID;       //
	PPID   AccSheetID;     //
};
//
// Дополнительная информация об операции инвентаризации
//
#define INVOPF_COSTNOMINAL       0x0001L // Номинал в ценах поступления (иначе в ценах реализации)
#define INVOPF_ZERODEFAULT       0x0002L // Остаток по умолчанию нулевой
#define INVOPF_WROFFWODSCNT      0x0004L // Списание без скидки
#define INVOPF_USEPACKS          0x0008L // Использовать параметры упаковки при вводе
#define INVOPF_SELGOODSBYNAME    0x0010L // Выбирать товары по полному наименованию, а не по сокращению
#define INVOPF_USEANOTERLOCLOTS  0x0020L // При списании излишков использовать информацию о лотах с других складов
#define INVOPF_INVBYCLIENT       0x0040L // Инвентаризация по клиенту (не списывается)
#define INVOPF_ACCELADDITEMS     0x0080L // Ускоренное добавление позиций по штрихкоду
#define INVOPF_ASSET             0x0100L // Инвентаризация по основным средствам (в обычную инвентаризацию основные средства не входят)
#define INVOPF_USESERIAL         0x0200L // Использовать серийные номера в строках инвентаризации
#define INVOPF_ACCELADDITEMSQTTY 0x0400L // Ускоренное добавление позиций по штрихкоду с количеством

struct PPInventoryOpEx {   // @persistent @store(PropertyTbl)
	PPInventoryOpEx();
	static int FASTCALL Helper_GetAccelInputMode(long flags);
	int    GetAccelInputMode() const;
	void   SetAccelInputMode(int mode);

	enum { // Методы расчета цен
		acmLIFO     = 0,
		acmFIFO,
		acmAVG
	};
	enum { // Методы автозаполнения //
		afmPresents = 0,
		afmAll,
		afmPrev,
		afmByCurLotRest // По текущим остаткам лотов
	};
	enum { // Методы ускоренного ввода строк
        accsliNo = 0,      // Нет
        accsliCode,        // Ввод кода с автоматическим количеством равным 1
        accsliCodeAndQtty  // Ввод кода с дополнительным вводом количества
	};
	PPID   Tag;              // Const=PPOBJ_OPRKIND
	PPID   ID;               // ->Ref(PPOBJ_OPRKIND)
	PPID   Prop;             // Const=OPKPRP_INVENTORY
	PPID   WrDnOp;           // Операция списания недостач
	PPID   WrDnObj;          // Контрагент списания недостач
	PPID   WrUpOp;           // Операция списания излишков
	PPID   WrUpObj;          // Контрагент списания излишков
	int16  Reserve1;         //
	int16  AmountCalcMethod; // Метод расчета цен
	int16  AutoFillMethod;   // Метод автозаполнени
	int16  Reserve2;         //
	char   Reserve3[36];     // 
	long   OnWrOffStatusID;  // Статус, устанавливаемый при списании документа
	long   Flags;            // INVOPF_XXX
	long   Reserve4;         //
};
//
// Descr: Дополнительная запись инвентаризации задолженности
//
struct PPDebtInventOpEx {    // @persistent @store(PropertyTbl)
	PPID   Tag;              // Const=PPOBJ_OPRKIND
	PPID   ID;               // ->Ref(PPOBJ_OPRKIND)
	PPID   Prop;             // Const=OPKPRP_DEBTINVENT
	PPID   WrDnOp;           // Операция покрытия долга
	PPID   WrUpOp;           // Операция покрытия переплаты
	PPID   WrDnGoodsID;      // Товар, используемый для товарных документов покрытия долга
	PPID   WrUpGoodsID;      // Товар, используемый для товарных документов покрытия переплаты
	long   Reserve1[6];      // @reserve
	long   Flags;            // @flags
	long   Reserve2;         // @reserve
};
//
// Дополнительные опции зачетной операции
//
#define ROXF_BEGISBILLDT     0x0001L // Началом периода является дата платежного док-та
#define ROXF_ENDISBILLDT     0x0002L // Концом периода является дата платежного док-та
#define ROXF_AUTOPAYM        0x0004L // Автоматически зачитывать платежные док-ты
#define ROXF_CFM_PAYM        0x0008L // Подтверждать зачет платежного док-та
#define ROXF_AUTODEBT        0x0010L // Автоматически зачитывать долговые док-ты
#define ROXF_CFM_DEBT        0x0020L // Подтверждать зачет долгового документа
#define ROXF_THISLOCONLY     0x0040L // Зачитывать документы только по тому же складу
#define ROXF_BYEXTOBJ        0x0080L // Reckon by BillTbl::Object2 (forward reckoning only) if Object2 == 0, then use Object
#define ROXF_REQALTOBJ       0x0100L // If !automat then request user for alternate object for reckoning
#define ROXF_THISALTOBJONLY  0x0200L // Зачитывать документы только по той же дополнительной статье документа
	// Если доп статья нулевая, то зачитывать только на нулевые доп статьи
#define ROXF_RECKONNEGONLY   0x0400L // Операция трактуется как зачетная только при отрицательной номинальной сумме документа (сумма зачета при этом меняет знак на положительный)

#define ROX_HDR_DW_COUNT     8

struct PPReckonOpEx {
	PPReckonOpEx();
	PPReckonOpEx & Z();
	bool   IsEmpty() const;
	PPReckonOpEx & FASTCALL operator = (const PPReckonOpEx &);
	int    GetReckonPeriod(LDATE debtDate, DateRange & rPeriod) const;
	void   GetDebtPeriod(LDATE paymDate, DateRange & rPeriod) const;
	void   PeriodToStr(SString & rBuf) const;
	int    StrToPeriod(const char *);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	LDATE  Beg;
	LDATE  End;
	long   Flags;           // @flags ROXF_XXX
	PPID   PersonRelTypeID; // Тип персонального отношения, используемый для коллективного зачета
	long   Reserve[4];      // @reserve
	PPIDArray OpList;       // Список операций оплат, применяемых для зачета этой операции
};
//
// Дополнительные опции драфт-операций
//
#define DROXF_CREMPTYBILL      0x0001L // Вместо списания создавать пустой документ
#define DROXF_USEPARTSTRUC     0x0002L // Списывать частичные структуры в документах списания //
#define DROXF_WROFFCURDATE     0x0004L // Документ списания формировать текущей системной датой
#define DROXF_DONTINHEXPIRY    0x0008L // При списании драфт-документа в приходный документ не наследовать срок годности из строк драфт-документа.
#define DROXF_MULTWROFF        0x0010L // Документ допускает множественное списание (то есть, к одному драфт-документу может быть привязано несколько документов списания).
#define DROXF_MULTDRFTWROFF    0x0020L // Списание драфт-прихода в модификацию осуществляется таким образом, что
	// на каждую строку исходного документа генерируется отдельный документ модификации
#define DROXF_SELSUPPLONCOMPL  0x0040L // При компенсации дефицита запрашивать поставщиков приходуемого товара

struct PPDraftOpEx {
	PPDraftOpEx();
	void   Init();
	PPDraftOpEx & FASTCALL operator = (const PPDraftOpEx &);

	PPID   WrOffOpID;       // Операция списания                        //
	PPID   WrOffObjID;      // Контрагент для операции списания //
	PPID   WrOffComplOpID;  // Операция комплектации, для формирования остатков, списываемых операцией WrOffOpID
	long   Reserve[10];     //
	long   Flags;           // DROXF_XXX
};
//
// Дополнительные опции операции пула документов
//
#define BPOXF_ONEOP          0x0001L // Объединять только по одной операции
#define BPOXF_ONEDATE        0x0002L // Объединять только по одной дате
#define BPOXF_ONEOBJECT      0x0004L // Объединять только по одному контрагенту
#define BPOXF_UNITEACCTURNS  0x0008L // Объединять бухгалтерские проводки
#define BPOXF_UNITEPAYMENTS  0x0010L // Объединять оплаты
#define BPOXF_AUTOAMOUNT     0x0020L // @v11.8.0 Документ пула имеет автономную номинальную сумму (не суммирует входящие в пул документы)

#define BPOX_HDR_DW_COUNT    17

struct PPBillPoolOpEx {
	PPBillPoolOpEx();
	void   Init();
	PPBillPoolOpEx & FASTCALL operator = (const PPBillPoolOpEx &);

	long   Reserve[16];
	long   Flags;        // BPOXF_XXX
	PPIDArray OpList;
};
//
// Специфические флаги доступа PPObjOprKind (в дополнение к общим RT_XXX)
//
#define OPKRT_MODIFYATT      0x0100 // Право модификации шаблонов проводок
#define OPKRT_MODIFYOPTIONS  0x0200 // Право модификации опций
#define OPKRT_MODIFYCOUNTER  0x0400 // Право модификации счетчика
//
// Коды дополнительных строковых значений вида операции
//
// Дополнительные строковые поля вида операции хранятся в таблице Property
// с координатами {PPOBJ_OPRKIND; OpID; OPKPRP_EXTSTRDATA} в следующем формате:
// "<id1> string1 <id2> string2 ... "
// Если строка не содержит служебные коды <id>, то для совместимости с
// предыдущими версиями вся эта строка интерпретируется как шаблон примечания.
//
// Example: "<1>This is memo for bill of some op<2>Bank"
//
#define OPKEXSTR_MEMO        1 // Шаблон примечания //
#define OPKEXSTR_OBJ2NAME    2 // Наименование дополнительного объекта
#define OPKEXSTR_DEFPRNFORM  3 // Печатная форма документа по умолчанию
#define OPKEXSTR_AMTFORMULA  4 // Формула для вычисления номинальной суммы
#define OPKEXSTR_ATTCHFILEXT 5 // Расширения присоединяемых файлов
#define OPKEXSTR_EXPSYMB     6 // Символ вида операции, используемый при экспорте документов.
	// Papyrus не использует и никак не проверяет этот атрибут, но позволяет передать его внешним приложениям.
//
// Флаги элемента обобщенной операции
//
#define GOIF_NEGATIVE        0x0001 // В отчетах значения, соответствующие этой операции вычитаются //

typedef TSArray <PPAccTurnTempl> PPAccTurnTemplArray;

class PPOprKindPacket {
public:
	PPOprKindPacket();
	~PPOprKindPacket();
	PPOprKindPacket & Z();
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char *);
	PPOprKindPacket & FASTCALL operator = (const PPOprKindPacket & rSrc);

	PPOprKind2 Rec;
	PPIDArray Amounts;
	PPAccTurnTemplArray ATTmpls;
	SString ExtString;
	PPInventoryOpEx  * P_IOE;
	ObjRestrictArray * P_GenList;
	PPReckonOpEx * P_ReckonData;
	PPBillPoolOpEx   * P_PoolData;  //
	PPDraftOpEx * P_DraftData; //
	PPDebtInventOpEx * P_DIOE;      //
	PPOpCounterPacket OpCntrPack;   //
};
//
// Флаги функции PPObjOprKind::MakeOprKindList
//
#define OPKLF_OPLIST        0x0001 // В переданном списке перечислены виды операций, иначе - типы)
#define OPKLF_SHOWPASSIVE   0x0002 // Показывать пассивные операции
#define OPKLF_IGNORERIGHTS  0x0004 // Игнорировать права доступа по операциям
#define OPKLF_FIXEDLOC      0x0008 // Специальная опция для BillPrelude - блокирует возможность измененя склада

class PPObjOprKind : public PPObjReference {
public:
	static int GetATTemplList(PPID opID, PPAccTurnTemplArray * pList);
	static StrAssocArray * MakeOprKindList(PPID linkOp, const PPIDArray *, uint flags /* OPKLF_XXX */);
	//
	// Descr: Формирует список терминальных (не обобщенных) видов операций rResultList из идентификатора
	//   вида операции opID. Если opID не обобщенная операция, то в rResultList будет только она в противном
	//   случае - все члены обобщения.
	// Note: Функция предварительно очищает список rResultList и в конце работы сортирует вызовом sortAndUndup().
	// Returns:
	//   >0 - rResultList содержит хотя бы один элемент
	//   <0 - по-видимому, opID вообще не является идентификатором вида операции, либо ссылается на пустое обобщение.
	//
	static int FASTCALL ExpandOp(PPID opID, PPIDArray & rResultList);
	//
	// Descr: Формирует список терминальных (не обобщенных) видов операций rResultList из списка
	//   видов операций rBaseOpList. Если элемент rBaseOpList - не обобщенная операция, то в rResultList попадает она сама,
	//   в противном случае - все члены обобщения.
	// Note: Функция предварительно очищает список rResultList и в конце работы сортирует вызовом sortAndUndup().
	// Returns:
	//   >0 - rResultList содержит хотя бы один элемент
	//   <0 - rResultList не содержит ни одного элемента
	//
	static int FASTCALL ExpandOpList(const PPIDArray & rBaseOpList, PPIDArray & rResultList);

	explicit PPObjOprKind(void * extraPtr = 0);
	virtual int  Edit(PPID*, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	// @v11.1.11 (@construction) virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	int    Edit(PPID *, long opTypeID, long linkOpID);
	//
	// Descr: Вызывает диалог редактирования пакета вида операции.
	//   Может изменить поля пакета даже в том случае, если пользователь не нажал [OK]
	//   Проверяет уникальность имени пакета обращением к функции PPObjReference::CheckDupName.
	//
	int    EditPacket(PPOprKindPacket *);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    GetExtStrData(PPID opID, int fldID, SString & rBuf);
	int    GetExAmountList(PPID, PPIDArray *);
	int    GetGenericList(PPID, ObjRestrictArray *);
	int    GetGenericList(PPID, PPIDArray *);
	int    GetReckonExData(PPID, PPReckonOpEx *);
	int    GetPoolExData(PPID, PPBillPoolOpEx *);
	int    GetDraftExData(PPID, PPDraftOpEx *);
	int    GetPacket(PPID, PPOprKindPacket *);
	int    PutPacket(PPID *, PPOprKindPacket *, int use_ta);
	int    SerializePacket(int dir, PPOprKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    FetchInventoryData(PPID, PPInventoryOpEx *);
	int    FetchReckonExData(PPID opID, PPReckonOpEx * pData); // @v11.7.11
	int    GetPaymentOpList(PPID linkOpID, PPIDArray *);
	int    GetCorrectionOpList(PPID linkOpID, PPIDArray * pList);
	//
	// Descr: Возвращает список видов операций, предназначенных для формирования ведомого
	//   запроса котировок в ответ на оригинальный.
	//
	int    GetQuoteReqSeqOpList(PPID linkOpID, PPIDArray * pList);
	//
	// Descr: Возвращает список видов операций, требующих оплаты и связанных
	//   с таблицей статей accSheetID.
	//   Операции относящиеся к типу PPOPT_GOODSORDER пропускаются, если
	//   в конфигурации установлена опция CCFLG_IGNOREORDERSDEBT.
	//   Если accSheetID == -1, то извлекаются все виды операций, требующие
	//   оплаты (с учетом флага конфигурации CCFLG_IGNOREORDERSDEBT).
	//
	int    GetPayableOpList(PPID accSheetID, PPIDArray * pList);
	int    GetProfitableOpList(PPID accSheetID, PPIDArray * pList);
	int    GetEdiRecadvOp(PPID * pID, int use_ta);
	int    GetEdiOrdrspOp(PPID * pID, int use_ta);
	int    GetEdiStockOp(PPID * pID, int use_ta);
	int    GetEdiShopChargeOnOp(PPID * pID, int use_ta);
	int    GetEdiWrOffShopOp(PPID * pID, int use_ta);
	int    GetEdiWrOffWithMarksOp(PPID * pID, int use_ta);
	int    GetEdiChargeOnWithMarksOp(PPID * pID, int use_ta);
	//
	// Descr: Возвращает идентификатор зарезервированного вида операции общей бух проводки для регистрового счета.
	//   Если операция не существует, то будет создана.
	//
	int    GetGenericAccTurnForRegisterOp(PPID * pID, int use_ta);
private:
	struct ReservedOpCreateBlock {
		ReservedOpCreateBlock();
		PPID   OpID;
		PPID   OpTypeID;
		uint   NameTxtId;
		PPID   AccSheetID;
		int    SubType; // @v12.1.4
		long   Flags;
		const char * P_Symb;
		const char * P_CodeTempl;
	};
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  MakeReserved(long flags);
	int    SetReckonExData(PPID, const PPReckonOpEx * pData, int use_ta);
	int    SetPoolExData(PPID, const PPBillPoolOpEx * pData, int use_ta);
	int    SetDraftExData(PPID id, const PPDraftOpEx * pData);
	int    Helper_GetReservedOp(PPID * pID, const ReservedOpCreateBlock & rBlk, int use_ta);
	int    Helper_GetOpListByLink(PPID opTypeID, PPID linkOpID, PPIDArray * pList);
	// @v11.1.11 (@construction) int    AssignImages(ListBoxDef * pDef);
};
//
// @ModuleDecl(PPObjBillStatus)
// Статусы документов
//
#define BILSTF_DENY_MOD               0x0001 // Документы нельзя модифицировать
#define BILSTF_DENY_DEL               0x0002 // Документы нельзя удалять
#define BILSTF_DENY_TRANSM            0x0004 // Документы нельзя передавать в другой раздел
#define BILSTF_DENY_CHANGELINK        0x0008 // Связанные документы нельзя изменять
#define BILSTF_DENY_RANKDOWN          0x0010 // Нельзя изменять статус документа до статуса, имеющего меньший ранг, чем текущий
#define BILSTF_LOCK_ACCTURN           0x0020 // Для документов этого статуса не проводить бух проводки
#define BILSTF_LOCK_PAYMENT           0x0040 // Не учитывать документ как оплату
#define BILSTF_LOCDISPOSE             0x0080 // Автоматически размещать товарный документ по ячейкам склада после установки этого статуса.
#define BILSTF_READYFOREDIACK         0x0100 // Документ с таким статусом готов к отправке по нему подтверждения провайдеру EDI
#define BILSTF_STRICTPRICECONSTRAINS  0x0200 // Для документов с таким статусом включается блокировка проведения если какая-либо из цен реализации
	// нарушает ограничения, заданные в товарных типах.
//
// Флаги обязательности атрибутов документа
//
#define BILCHECKF_AGENT           0x00000001 //
#define BILCHECKF_PAYER           0x00000002 //
#define BILCHECKF_DLVRADDR        0x00000004
#define BILCHECKF_PORTOFLOADING   0x00000008
#define BILCHECKF_PORTOFDISCHARGE 0x00000010
#define BILCHECKF_ISSUEDT         0x00000020
#define BILCHECKF_ARRIVALDT       0x00000040
#define BILCHECKF_SHIP            0x00000080
#define BILCHECKF_FREIGHTCOST     0x00000100
#define BILCHECKF_OBJECT          0x00000200
#define BILCHECKF_CAPTAIN         0x00000400
#define BILCHECKF_TRBROKER        0x00000800
#define BILCHECKF_OBJECT2         0x00001000 //
#define BILCHECKF_DUEDATE         0x00002000 //
#define BILCHECKF_CODE            0x00004000 // Проверка на не пустой номер документа
#define BILCHECKF_CONTRACT        0x00008000 // @v11.5.11 Проверка на валидный договор (номер и дата в соглашении или привязка к документу договора)
#define BILCHECKF_FREIGHT         (BILCHECKF_DLVRADDR|BILCHECKF_PORTOFLOADING|BILCHECKF_PORTOFDISCHARGE|\
	BILCHECKF_ARRIVALDT|BILCHECKF_SHIP|BILCHECKF_FREIGHTCOST|BILCHECKF_CAPTAIN|BILCHECKF_TRBROKER)
#define BILCHECKF_LNEXPLVATRATE   0x00010000 // @v11.8.9 Проверка по строкам документа: каждый товар должен иметь явно установленную ставку НДС
#define BILCHECKF_LNCHZNMARKS     0x00020000 // @v11.8.9 Проверка по строкам документа: строки документа, соответствующие товарам, для которых
	// необходима маркировка, должны содержать марки.

struct PPBillStatus2 {     // @persistent @store(Reference2Tbl+)
	PPBillStatus2();
	long   Tag;            // Const=PPOBJ_BILLSTATUS
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символ статуса
	char   Reserve[44];    // @reserve
	SColor IndColor;       // Цвет, которым подствечиваются документы с этим статусом
	PPID   CounterID;      // Счетчик, по которому назначается номер документа при присвоении данного статуса
	PPID   RestrictOpID;   // Вид операции (возможно, обобщенный) документам которого может быть присвоен данный статус.
	int16  Rank;           //
	int16  Reserve2;       // @alignment
	long   Flags;          // BILSF_XXX
	long   CheckFields;    // BILCHECKF_XXX Обязательные поля документа
	long   Reserve3;       // @reserve
};

class PPObjBillStatus : public PPObjReference {
public:
	explicit PPObjBillStatus(void * extraPtr = 0);
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPBillStatus * pRec);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
};
//
// Descr: Размерность расчета долгов
//
struct PPDebtDim {
	PPDebtDim(); // @v11.9.6
	long   Tag;            // Const=PPOBJ_DEBTDIM
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ размерности
	uint8  Reserve[64];    // @reserve
	long   Reserve2[2];    // @reserve
};

struct PPDebtDimPacket {
	PPDebtDimPacket();

	PPDebtDim Rec;
	ObjIdListFilt AgentList;
};

class PPObjDebtDim : public PPObjReference {
public:
	//
	// Descr: Вызывает диалог выбора размерности
	//
	static PPID Select();
	PPObjDebtDim();
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPDebtDim * pRec);
	int    FetchAgentList(LAssocArray * pList);
	void FASTCALL Dirty(PPID id);
	int    GetPacket(PPID id, PPDebtDimPacket * pPack);
	int    PutPacket(PPID * pID, PPDebtDimPacket * pPack, int use_ta);
	int    SerializePacket(int dir, PPDebtDimPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
//
//
class PPObjSecur : public PPObjReference {
public:
	enum {
		maskUserGroup = 0x08000000,
		maskConfig    = 0x10000000,
		maskUER       = 0x20000000,
		mask  = (maskUserGroup|maskConfig|maskUER)
	};
	struct ExtraParam {
		ExtraParam();
		ExtraParam & FASTCALL operator = (const ExtraParam & rS);
		bool   IsConsistent() const;

		enum {
			fShowAll       = 0x0001, // Флаг для отображения в списке всех типов объектов Secur
			fSelectNewType = 0x0002  // При создании нового объекта предписывает предлагать выбор типа объекта (группа, пользователь, UER)
		};
		const  uint32 Signature; // @anchor Специальный признак, идентифицирующий то, что по указателю находится именно этот объект
        PPID   Type;
        PPID   ParentID;
		PPID   SampleID; // Идентификатор объекта-образца для создания нового экземпляра
        long   Flags;
	};
	class Exclusion {
	public:
		explicit Exclusion(int exclrt);
		~Exclusion();
	private:
		enum {
			stMerged = 0x0001
		};
		long   State;
		PPRights Preserve;
	};
	PPObjSecur(PPID aObj, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int  UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  ProcessReservedItem(TVRez &);
	int    GetPacket(PPID id, PPSecurPacket * pPack);
	int    PutPacket(PPID * pID, PPSecurPacket * pPack, int use_ta);
	int    AssignPrivateDesktop(PPID userID, const S_GUID & rDesktopUuid, const char * pDeskName, int use_ta);
	int    GetPrivateDesktop(PPID userID, S_GUID & rDesktopUuid);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Name, Flags, PersonID, ParentID}
	//
	int    FASTCALL Fetch(PPID id, PPSecur *);
	int    SerializePacket(int dir, PPSecurPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	int    AssignImages(ListBoxDef * pDef);

	ExtraParam SelectorP; // Блок параметров, с которым был вызван последний Selector.
		// Необходим для правильной обработки UpdateSelector
};
//
// @ModuleDecl(PPObjBizScore)
//

//
// @v12.3.6
// Descr: Классы бизнес-показателей. 
//   Все классы зарезервированы. Нужны для того, чтобы можно было программно определить специфическое поведение конкретного бизнес-показателя //
//
#define BSCCLS_INC_SALE_UNIT           1 // Доходы от продажи единицы продукции
#define BSCCLS_EXP_SALE_UNIT           2 // Расходы на продажу единицы продукции
#define BSCCLS_EXP_PURCHASE_UNIT       3 // Расходы на закупку единицы продукции
#define BSCCLS_EXP_TRANSFER_UNIT       4 // Расходы на передачу единицы продукции (с одного места хранения на другое, либо со склада покупателя, либо возврат от покупателя на склад etc)  
#define BSCCLS_EXP_STORAGE_UNIT        5 // Расходы на хранение единицы продукции 
#define BSCCLS_EXP_PRESALE_UNIT        6 // Расходы на предпродажную подготовку единицы продукции
#define BSCCLS_EXP_PRESALE_SKU_TIME    7 // Расходы на предпродажную подготовку одного наименования продукции (в единицу времени)
#define BSCCLS_EXP_PROMO_SKU_TIME      8 // Маркетинговые расходы на категорию продукции (в единицу времени)
#define BSCCLS_EXP_PROMO_TIME          9 // Маркетинговые расходы не привязанные к продукции (в единицу времени)
//
// Descr: Индикаторы бизнес-показателей.
// 
#define PPBZSI_NONE                    0 //
#define PPBZSI_AMOUNT                  1 // Номинальная сумма "amount"    kBill, kPaym, kCCheck, kGoodsRest, kDebt, kBizScore
#define PPBZSI_AMT_COST                2 // Сумма в ценах поступления "cost"      kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_AMT_PRICE               3 // Сумма в ценах реализации без учета скидки "price"     kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_AMT_DISCOUNT            4 // Сумма скидки "discount"  kBill, kCCheck
#define PPBZSI_AMT_NETPRICE            5 // Сумма в ценах реализации с учетом скидки "netprice"  kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_AMT_MARGIN              6 // "margin"    kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_PCTINCOME               7 // "pctincome" kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_PCTMARGIN               8 // "pctmargin" kBill, kPaym, kCCheck, kGoodsRest
#define PPBZSI_COUNT                   9 // "count"     kBill, kPaym, kCCheck, kGoodsRest, kPersonEvent, kDebt, kBizScore
#define PPBZSI_AVERAGE                10 // "average"   kBizScore
#define PPBZSI_MPACCEPTANCE           11 // @v12.1.6 "MPACCEPTANCE" Стоимость приемки товара на складе маркетплейса
#define PPBZSI_MPSTORAGE              12 // @v12.1.6 "MPSTORAGE" Стоимость хранения товара на складе маркетплейса
#define PPBZSI_MPCOMMISSION           13 // @v12.1.6 "MPCOMMISSION" Сумма комиссионного вознаграждения маркетплейса
#define PPBZSI_MPCOMMISSIONPCT        14 // @v12.1.6 "MPCOMMISSIONPCT" Процент комиссионного вознаграждения маркетплейса от суммы продажи
#define PPBZSI_MPSELLERSPART          15 // @v12.1.6 "MPSELLERSPART" Сумма, перечисляемая маркетплейсом продавцу за проданный товар
#define PPBZSI_MPSELLERSPARTPCT       16 // @v12.1.6 "MPSELLERSPARTPCT" Процент доли, перечисляемоей маркетплейсом продавцу за проданный товар, от суммы продажи
#define PPBZSI_MPACQUIRING            17 // @v12.1.6 "MPACQUIRING" Стоимость экваринга на стороне маркетплейса, котороую маркетплейс переносит на поставщика 
#define PPBZSI_MPACQUIRINGPCT         18 // @v12.1.6 "MPACQUIRINGPCT" Процент доли экваринга на стороне маркетплейса, котороую маркетплейс переносит на поставщика, от суммы продажи
#define PPBZSI_ORDCOUNT               19 // @v12.1.6 "ordcount"  Количество документов заказа
#define PPBZSI_ORDQTTY                20 // @v12.1.6 "ordqtty"   Заказанное количество торговых единиц  
#define PPBZSI_SALECOUNT              21 // @v12.1.6 "salecount" Количество документов продажи
#define PPBZSI_SALEQTTY               22 // @v12.1.6 "saleqtty"  Проданное количество торговых единиц 
#define PPBZSI_ORDCANCELLEDCOUNT      23 // @v12.1.6 "ordcancelledcount" Количество заказоы которые были отменены
#define PPBZSI_ORDCANCELLEDQTTY       24 // @v12.1.6 "ordcancelledqtty"  Количество торговых единиц товара, заказы на которые были отменены
#define PPBZSI_ORDSHIPMDELAYDAYSAVG   25 // @v12.1.6 [compound] "ordshipmdelaydaysavg"   Средний период между заказом и продажей в днях
#define PPBZSI_ORDSHIPMDELAYDAYSMIN   26 // @v12.1.6 "ordshipmdelaydaysmin"   Минимальный период между заказом и продажей в днях  
#define PPBZSI_ORDSHIPMDELAYDAYSMAX   27 // @v12.1.6 "ordshipmdelaydaysmax"   Максимальный период между заказом и продажей в днях  
#define PPBZSI_SUPPLSHIPMDELAYDAYSAVG 28 // @v12.1.6 "supplshipmdelaydaysavg" Средний период между поставкой и продажей в днях
#define PPBZSI_ORDSHIPMDELAYDAYS      29 // @v12.1.7 "ordshipmdelaydays"      Суммарное количество дней между заказом и продажей (вспомогательное значение для получения более осмысленных относительных величин)
#define PPBZSI_SUPPLSHIPMDELAYDAYS    30 // @v12.1.7 "supplshipmdelaydays"    Суммарное количество дней между поставкой и продажей (вспомогательное значение для получения более осмысленных относительных величин)
#define PPBZSI_MPAMT_ORDPRICE         31 // @v12.1.8 "mpamtordprice"         Сумма заказа на маркетплейсе в терминах конечной цены покупателя //
#define PPBZSI_MPAMT_ORDSELLERPRICE   32 // @v12.1.8 "mpamtordsellerprice"   Сумма заказа на маркетплейсе в терминах цены продавца //
#define PPBZSI_MPAMT_SHIPMPRICE       33 // @v12.1.8 "mpamtshipmprice"       Сумма отгрузки с маркетплейса в терминах конечной цены покупателя (может отличаться от конечной цены заказа) //
#define PPBZSI_MPAMT_SHIPMSELLERPRICE 34 // @v12.1.8 "mpamtshipmsellerprice" Сумма отгрузки с маркетплейса в терминах цены продавца //
#define PPBZSI_SALECOST               35 // @v12.1.9 "salecost"  Себестоимость проданных товаров
#define PPBZSI_FREIGHT                36 // @v12.1.9 "freight"   Стоимость фрахта 
#define PPBZSI_ORDCANCELLATIONRATE    37 // @v12.1.11 [compound] "ordcancellationrate" Отношение числа отмененных заказов к общему числу заказов
#define PPBZSI_SALERETCOUNT           38 // @v12.1.11 "saleretcount" Количество документов возврата от покупателей //
#define PPBZSI_SALERETQTTY            39 // @v12.1.11 "saleretqtty"  Возвращенное от покупателей количество торговых единиц 
#define PPBZSI_SALERETCOST            40 // @v12.1.11 "saleretcost"  Себестоимость возвращенных от покупателей товаров
#define PPBZSI_MPPROMOTION            41 // @v12.1.12 "mppromotion"  Расходы на продвижение товаров на маркетплейсах
//
// Флаги значений бизнес-показателей
//
#define BISCVF_BOUNDLOW  0x0001 // Значение выходит за нижнюю допустимую границу
#define BISCVF_BOUNDUPP  0x0002 // Значение выходит за верхнюю допустимую границу

class BizScoreCore : public BizScoreTbl {
public:
	BizScoreCore();
	int    Search(LDATE actualDate, PPID scID, PPID objID, BizScoreTbl::Rec * pRec);
	int    SetItem(LDATE actualDate, PPID scID, PPID userID, long flags, double val, int use_ta);
	int    SetItem(LDATE actualDate, PPID scID, PPID userID, const char * pStr, int use_ta);
	int    SetItem(LDATE actualDate, PPID scID, PPID userID, PPObjID obj, const char * pStr, int use_ta);
	int    DeleteItem(LDATE actualDate, PPID scID, PPID objID, int use_ta);
};

int GetBizScoresVals(const char * pUserName, const char * pPassword, TcpSocket * pSock);

struct PPBizScore { // @flat
	PPBizScore();

	long   Tag;            // Const=PPOBJ_BIZSCORE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ показателя //
	char   Reserve[44];    // @reserve
	RealRange Bounds;      // Допустимые границы значения показателя //
	long   Flags;          // @flags
	long   UserID;         // ->Ref(PPOBJ_USR) Пользователь, которому принадлежит показатель
	long   Reserve2;       // @reserve
};

struct PPBizScorePacket {
	PPBizScore Rec;
	SString Descr;
	SString Formula;
};

class PPObjBizScore : public PPObjReference {
public:
	static const char * GetBzsiSymb(int bzsi, SString & rBuf);
	static const char * GetBzsiDescr(int bzsi, SString & rBuf);
	static int  RecognizeBzsiSymb(const char * pSymb);
	// @v12.3.6 static bool IsBzsiAdditive(int bzsi);
	static uint GetBzsiAggrFunc(int bzsi); // @v12.3.6 

	explicit PPObjBizScore(void * extraPtr = 0);
	~PPObjBizScore();
	virtual int  Edit(PPID * pID, void * extraPtr /*userID*/);
	virtual int  Browse(void * extraPtr /*userID*/);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    Fetch(PPID, PPBizScorePacket *);
	int    GetPacket(PPID id, PPBizScorePacket * pPack);
	int    PutPacket(PPID * pID, PPBizScorePacket * pPack, int use_ta);
	int    TestPacket(PPBizScorePacket * pPack, SString & rResult);
	int    ReverseFormula(PPBizScorePacket * pPack, SString & rResult);
private:
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);

	DL2_Resolver * P_Resolver;
	BizScoreCore * P_ValTbl;
};
//
//
//
class BizScore2ValuePacket {
public:
	BizScore2ValuePacket();
	BizScore2ValuePacket & Z();
	bool   FASTCALL IsEq(const BizScore2ValuePacket & rS) const;
	//
	// Descr: Виды записей индикаторов
	//
	enum {
		kRegular = 0, // Регулярное значение
		kPlan    = 1  // Планируемое значение
	};

	BizScore2Tbl::Rec Rec;
	SString Text; // Текстовое значение индикатора
};

#define PPTRPROP_BIZSCORE2_TEXT (PPTRPROP_USER+1)

class BizScore2Core : public BizScore2Tbl { // @v11.9.1 @construction
public:
	BizScore2Core();
	int   PutPacket(PPID * pID, BizScore2ValuePacket * pPack, int use_ta);
	int   GetPacket(PPID id, BizScore2ValuePacket * pPack);
};

struct PPBizScore2 { // @v11.9.0 @construction
	PPBizScore2();
	//
	// Descr: Флаги записи
	//
	enum {
		fNone        = 0x0001,
		fRecentValue = 0x0002, // Хранится только последнее значение индикатора (история не нужна или не имеет смысла) 
		fPlanned     = 0x0004, // Для индикатора допускается ввод планируемого значения //
	};
	long   Tag;                 // Const=PPOBJ_BIZSCORE2
	long   ID;                  // @id
	char   Name[48];
	char   Symb[20];
	uint8  Reserve[20];
	long   Cls;                 // BSCCLS_XXX Класс показателя //
	int32  DataType;            // OTTYP_XXX (будем использовать ту же систему типов, что и в тегах объектов)
	long   TypeEnumID;          // Тип ссылочного объекта для oneof2(DataType, OTTYP_ENUM, OTTYP_OBJLINK)
	long   TypeEnumExt;         // Группа ссылочных объектов для DataType == OTTYP_OBJLINK
	int16  TimeAggrFunc;        // AGGRFUNC_XXX Агрегирующая функция по временной шкале. Если 0, то показатель не агрегируется по времени.
	int16  HierAggrFunc;        // AGGRFUNC_XXX Агрегирующая функция по иерархии. Если 0, то показатель не агрегируется по иерархии.
	int16  AgentAggrFunc;       // AGGRFUNC_XXX Агрегирующая функция по участникам. Если 0, то показатель не агрегируется по участникам.
	int16  TimeCycle;           // PRD_XXX Периодичность фиксации показателя.
	uint32 SpecificUnit;        // SUOM_XXX Если индикатор является удельной величиной, то это поле - единица измерения относительно которой указана величина.
	long   AgentPsnKindID;      // Вид персоналии, соответствующий участникам, к которым привязывается индикатор
	long   LinkObjType;         // Тип объекта, к которому привязан показатель
	long   LinkExtID;           // Группа объектов типа LinkObjType, уточняющая привязку показателя. 
	long   Flags;               // @flags 
	long   ParentID;            // ->Ref(PPOBJ_BIZSCORE2) Родительский элемент
	long   AccSheetID;          //
};

struct PPBizScore2Packet : public PPExtStrContainer {
	enum {
		extssDescr   = 1,
		extssMemo    = 2,
		extssFormula = 3,
	};
	PPBizScore2 Rec;
};

#define PPTRPROP_BIZSCORE2  (PPTRPROP_USER+1) // @v12.3.6 Строки расширения бизнес-показателя II

class PPObjBizScore2 : public PPObjReference { // @v11.9.1 @construction
public:
	static uint GetBscClsList(PPIDArray & rList);
	static bool GetBscClsName(long cls, SString & rBuf);
	static bool GetBscClsResultName(long cls, SString & rBuf);
	//
	// Descr: Возвращает true если класс cls бизнес-показателя олицетворяет доходные значения //
	//
	static bool IsBscCls_Income(long cls);
	//
	// Descr: Возвращает true если класс cls бизнес-показателя олицетворяет расходные значения //
	//
	static bool IsBscCls_Expense(long cls);
	explicit PPObjBizScore2(void * extraPtr = 0);
	~PPObjBizScore2();
	virtual int  Edit(PPID * pID, void * extraPtr /*userID*/);
	virtual int  Browse(void * extraPtr /*userID*/);
	int    IsPacketEq(const PPBizScore2Packet & rS1, const PPBizScore2Packet & rS2, long flags);
	int    GetPacket(PPID id, PPBizScore2Packet * pPack);
	int    PutPacket(PPID * pID, PPBizScore2Packet * pPack, int use_ta);
	int    Fetch(PPID id, PPBizScore2Packet * pRec);
	int    ValidateValuePacket(const BizScore2ValuePacket * pValuePack);
	int    EditValuePacketDialog(BizScore2ValuePacket * pValuePack);
private:
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options/* = rmv_default*/, void * pExtraParam);
	StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
};
//
// @ModuleDecl(PPViewBizScore)
//
struct BizScoreFilt : public PPBaseFilt {
	BizScoreFilt();
	BizScoreFilt & FASTCALL operator = (const BizScoreFilt & s);

	uint8  ReserveStart[32]; // @anchor
	PPID   UserID;
	long   Flags;
	long   Order;
	SString DescrPattern;    // @anchor
	SString FormulaPattern;
};

struct BizScoreViewItem {
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	PPID   UserID;
	long   Flags;
	char   Descr[256];
	char   Formula[256];
};

class PPViewBizScore : public PPView {
public:
	PPViewBizScore();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(BizScoreViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   OnExecBrowser(PPViewBrowser * pBrw);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * GetEditExtraParam();

	BizScoreFilt Filt;
	PPObjBizScore BscObj;
};

class PrcssrBizScore {
public:
	struct Param { // @persistent
	public:
		Param();
		void   Init();
		int    Read(SBuffer & rBuf, long);
		int    Write(SBuffer & rBuf, long);
		enum {
			fExportXml = 0x0001, // Экспортировать данные в XML сразу после расчета
			fSendToFTP = 0x0002  // Отправить данные на FTP сервер
		};
		uint32 Ver;
		PPID   FtpAcctID;
		uint8  Reserve[24]; // @reserve
		PPID   BzsID;       // Идентификатор единственного показателя, который следует рассчитать
		DateRange Period;
		long   Flags;
		long   Reserve2;    // @reserve
	private:
		static const uint32 CVer;
	};
	PrcssrBizScore();
	~PrcssrBizScore();
	int    InitParam(Param *);
	int    EditParam(Param *);
	int    Init(const Param *);
	int    Run();
private:
	int    Helper_Calc(LDATE actualDate, PPLogger & rLogger, int use_ta);

	BizScoreCore Tbl;
	DL2_Resolver * P_Resolver;
	Param P;
};

struct BizScoreValFilt : public PPBaseFilt {
	BizScoreValFilt();
	BizScoreValFilt & FASTCALL operator = (const BizScoreValFilt & s);

	uint8  ReserveStart[32]; // @anchor
	DateRange Period;        // Период расчетной даты
	PPID   UserID;           // ->Ref(PPOBJ_USR)
	PPID   BizScoreID;       // ->Ref(PPOBJ_BIZSCORE)
	LDATETIME Since;         // Отбираются записи, измененные с момента Since
	long   Flags;            //
	long   Order;            //
	long   Reserve;          // @anchor
};

struct BizScoreValTotal {
	long   Count;
	double Sum;
};

struct BzsVal { // @v12.1.6 
	BzsVal();
	long   Bzsi; // @firstmember
	double Val;
};

class BzsValVector : public TSVector <BzsVal> { // @v12.1.6
public:
	BzsValVector();
	int    Add(long id, double value);
	bool   Get(long id, double * pValue) const;
	//
	// Descr: Рассчитывает и, в случае успеха, возвращает сложный индикатор, зависящий от одного 
	//   или нескольких иных индикаторов.
	//
	bool   GetCompound(long id, double * pValue) const;
	uint64 Ident; // Некоторый идентификатор, позволяющий определить привязку вектора к внешним данным
};

DECL_CMPFUNC(BzsValVector_Ident);

typedef BizScoreTbl::Rec BizScoreValViewItem;

class PPViewBizScoreVal : public PPView {
public:
	static int SendXml(PPID ftpAcctID, const char * pFilePath); // Отправка xml файла на FTP-сервер
	PPViewBizScoreVal();
	~PPViewBizScoreVal();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(BizScoreValViewItem *);
	int    CheckForFilt(const BizScoreTbl::Rec * pRec) const;
	int    CalcTotal(BizScoreValTotal * pTotal);
	int    ViewGraph();
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);

	BizScoreCore Tbl;
	BizScoreValFilt Filt;
};
//
//
//
struct BizSc2ValFilt : public PPBaseFilt, public PPExtStrContainer {
	BizSc2ValFilt();
	BizSc2ValFilt & FASTCALL operator = (const BizSc2ValFilt & s);

	uint8  ReserveStart[128]; // @anchor
	DateRange Period;
	PPID   ScID;              //
	long   Flags;
	long   Order;
	long   ReserveEnd;        // @anchor
};

class PPViewBizSc2Val : public PPView { // @v12.3.4
public:
	struct BrwItem { // @persistent @store(Reference2Tbl) @flat
		BrwItem();
		PPID   ID;             // @id
		PPID   ScoreID;
		LDATE  Dt;
		LDATE  PlanPeriodFn;
		long   Flags;
		PPID   ArID;
		PPID   AgentID;
		PPID   LinkObjID;
		double RVal;
		long   IVal;
		uint   TextP; // Позиция строки в пуле StrPool
	};
	PPViewBizSc2Val();
	~PPViewBizSc2Val();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    MakeList(PPViewBrowser * pBrw);
	int    MakeListEntry(const BizScore2Tbl::Rec & rRec, BrwItem & rEntry);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	BizSc2ValFilt Filt; // Оставляем старую структуру фильтра (будем ее расширять)
	SStrGroup StrPool;  // Пул строковых полей, на который ссылаются поля в TempPersonTbl
	SArray * P_DsList;
	BizScore2Core BscT;
	PPObjBizScore2 BscObj;
};
//
// Descr: Структура для транзитного хранения глобального значения бизнес-показателя //
//
struct GlobalBizScoreVal {
	S_GUID LocalDbUuid;
	long   LocalUserID;
	LDATE  ActualDate;
	LDATETIME Dtm;
	long   LocalScoreID;
	long   Flags;          // BISCVF_XXX
	SString LocalScoreName;
	SString LocalScoreDescr;
	SString StrVal;
	double Val;
};

class GlobalBizScoreArray : public TSCollection <GlobalBizScoreVal> {
public:
	GlobalBizScoreArray();
	int    Add(const PPGlobalUserAcc & rGuaRec, const GlobalBizScoreTbl::Rec & rRec);
};
//
// Descr: Таблица для хранения и извлечения глобальных значений бизнес-показателей
//
class GlobalBizScoreCore : public GlobalBizScoreTbl {
public:
	GlobalBizScoreCore();
	int    SetItem(long counter, const GlobalBizScoreVal & rVal, int use_ta);
	int    SetList(const GlobalBizScoreArray & rList, int use_ta);
	int    GetLastList(PPID globalUserID, GlobalBizScoreArray * pList);
};
//
// @ModuleDecl(PPObjGlobalUserAcc)
//
struct PPGlobalUserAccConfig {
	enum {
		fValid          = 0x0001, // @transient Структура извлечена из базы данных
		fAutoCreateGUID = 0x0002  // Автоматически создавать тег собственного GUID'а для новых записей
	};
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_GLOBALUSERACCCFG
	long   Flags;          // @flags
	PPID   PersonKindID;   // ->Ref(PPOBJ_PERSONKIND)    Вид персоналии, используемый для владельцев записей.
	PPID   SCardSerID;     // ->Ref(PPOBJ_SCARDSERIES) Серия кредитных карт, используемая для учета тарифицируемых транзакции по аккаунту.
	char   Reserve1[52];   // @reserve
	long   Reserve2[2];    // @reserve
};
//
// Descr: Идентификаторы глобальных сервисов, с которыми могут быть связаны глобальные учетные записи
// All values are @persistent
//
#define PPGLS_UNDEF         0
#define PPGLS_TWITTER       1 //
#define PPGLS_FACEBOOK      2 //
#define PPGLS_VK            3 //
#define PPGLS_VETIS         4 //
#define PPGLS_CHZN          5 // честный знак
#define PPGLS_INSTAGRAM     6 // 
#define PPGLS_UDS           7 // Сервис UDS (бонусная система, интернет-магазин)
#define PPGLS_UNIVERSEHTT   8 // Сервис Universe-HTT (бонусная система, интернет-магазин и др.)
#define PPGLS_SHOPIFY       9 // @construction
#define PPGLS_WILDBERRIES  10 // @v12.1.0
#define PPGLS_APTEKARU     11 // @v12.2.0 @construction
#define PPGLS_LAST         11 // @v12.2.1 максимальное валидное значение. Поменяйте значение если вводите новый идентификатор!

#define PPTRPROP_GUAEXT    (PPTRPROP_USER+1) // @v11.9.9 Суб-идентификатор записи текстовых расширений глобальной учетной записи

struct PPGlobalUserAcc {
	PPGlobalUserAcc();
	enum {
		fSandBox = 0x0001 // Запись используется для доступа к тестовому ресурсу. Введен из-за того, что тестовые ресурсы могут отличаться по спецификации обмена и адресу.
	};
	long   Tag;            // Const=PPOBJ_GLOBALUSERACC
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ //
	S_GUID_Base LocalDbUuid; // GUID локальной базы данных
	char   Password[40];   // Пароль (зашифрован и свернут в строку кодировкой MIME64)
	PPID   ServiceIdent;   // Идентификатор сервиса, с которым связана запись
	long   Flags;          // @flags
	long   LocalUserID;    // Ид пользователя, относительно локальной базы данных
	PPID   PersonID;       // -->Person.ID
};
//
// Descr: Пакет глобальной учетной записи
//
class PPGlobalUserAccPacket : public PPExtStrContainer { // @v11.9.9 (: PPExtStrContainer)
public:
	enum {
		extssAccessKey = 1 // @v11.9.9 Это поле замещает тег PPTAG_GUA_ACCESSKEY из-за того, что ключ может не поместиться в 127 символов.
	};
	PPGlobalUserAccPacket();
	bool   FASTCALL IsEq(const PPGlobalUserAccPacket & rS) const;
	PPGlobalUserAccPacket & Z();
	int    SetAccessKey(const char * pValue);
	int    GetAccessKey(SString & rValue) const;

	PPGlobalUserAcc Rec;
	ObjTagList TagL;        // Список тегов
};

class PPObjGlobalUserAcc : public PPObjReference {
public:
	static int FASTCALL ReadConfig(PPGlobalUserAccConfig * pCfg);
	static int EditConfig();

	explicit PPObjGlobalUserAcc(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*ServiceIdent*/);
	int    Fetch(PPID id, PPGlobalUserAcc * pRec);
	int    PutPacket(PPID * pID, PPGlobalUserAccPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPGlobalUserAccPacket * pPack);
	int    SerializePacket(int dir, PPGlobalUserAccPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SearchByLocalID(const S_GUID & rDbUuid, PPID localUserID, PPID * pID, PPGlobalUserAcc * pRec);
	int    GetListByServiceIdent(PPID serviceIdent, PPIDArray * pList);
	//
	// Descr: Ищет записи, ассоциированные с персоналией personID и возвращает их идентификаторы в
	//   массиве rList.
	// Returns:
	//   >0 - найдена одна или более искомых записей
	//   <0 - не найдено ни одной записи, ассоциированной с персоналией personID
	//   0  - ошибка
	//
	int    SearchByAssociatedPersonID(PPID personID, PPIDArray & rList);
	int    CheckPassword(const char * pName, const char * pPassword, PPGlobalUserAcc * pUserAcc = 0);
	int    Register(PPID & ID, const char * pName, const char * pPassword, const S_GUID & rDbUuid, PPID localUserID, PPID personID);
	int    Unregister(const char * pName, const char * pPassword);
	int    ChangePassword(const char * pName, const char * pOldPassword, const char * pNewPassword);
	int    FASTCALL FetchConfig(PPGlobalUserAccConfig * pCfg);
	int    FASTCALL FetchAlbatossConfig(PPAlbatrossConfig * pCfg);
	int    DirtyConfig();
protected:
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
//
// @Muxa {
//
class PPGlobalAccRights {
public:
	enum {
		fAccess       = 0x0001,   // A Разрешен доступ
		fCreate       = 0x0002,   // C Разрешено создание
		fEdit = 0x0004,   // E Разрешено изменение
		fDelete       = 0x0008,   // D Разрешено удаление
		fOperation    = 0x0010,   // O Разрешено оперирование объектом
		fAccessByID   = 0x0020,   // I только для автономных адресов
		fAccessBySymb = 0x0040    // S только для автономных адресов
	};
	static int EditDialog(PPID tagID, SString & rLine);

	PPGlobalAccRights(const int tagID);
	PPGlobalAccRights(const SString & rStr);
	~PPGlobalAccRights();
	int    IsAllow(int flags, const char * pScope = "@def") const;
private:
	int    Parse(const SString & rStr);
	struct Rec { // @flat
		Rec();
		char  Scope[128];
		int   Flags;
	};
	TSVector <Rec> Recs;
};
// }
//
// PPViewGlobalUser
//
class GlobalUserAccFilt : public PPBaseFilt {
public:
	GlobalUserAccFilt();
	GlobalUserAccFilt & FASTCALL operator = (const GlobalUserAccFilt &);

	char   ReserveStart[24];
	char   Reserve[256];
	long   ReserveEnd;
};

typedef PPGlobalUserAcc GlobalUserAccViewItem;

class PPViewGlobalUserAcc : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewGlobalUserAcc();
	~PPViewGlobalUserAcc();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(GlobalUserAccViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    UpdateTempTable(const PPIDArray * pIdList);
	TempGlobUserAccTbl::Rec & MakeTempEntry(const PPGlobalUserAcc & rRec, TempGlobUserAccTbl::Rec & rTempRec);
	int    CheckForFilt(const PPGlobalUserAcc * pRec) const;

	GlobalUserAccFilt  Filt;
	PPObjGlobalUserAcc ObjGlobAcc;
	TempGlobUserAccTbl * P_TempTbl;
};
//
// @ModuleDecl(GtaJournal)
// Учет тарифицируемых транзакций глобальных учетных записей.
//
#define GTAOP_NOOP               0
#define GTAOP_OBJGET             1
#define GTAOP_OBJADD             2
#define GTAOP_OBJMOD             3
#define GTAOP_OBJRMV             4
#define GTAOP_CCHECKCREATE       5
#define GTAOP_SCARDWITHDRAW      6
#define GTAOP_FILEUPLOAD         7
#define GTAOP_FILEDOWNLOAD       8
#define GTAOP_BILLCREATE         9
#define GTAOP_SMSSEND           10
#define GTAOP_SCARDDEPOSIT      11
#define GTAOP_LAST              11

struct PPGta {
	PPGta();

	int    Op;
	PPID   GlobalUserID;
	PPObjID ObjId;
	LDATETIME Dtm;
	long   Count;
	long   Duration;
	PPID   SCardID;        // @*PPObjBill::InitGta Кредитная карта, ассоциированная с глобальной учетной записью
	double Quot;           // @*PPObjBill::InitGta Стоимость транзакции
	double SCardRest;      // @*PPObjBill::InitGta Остаток на карте SCardID на момент инициализации.
		// Извлекается только в том случае, если Quot != 0.0
	double SCardMaxCredit; // @*PPObjBill::InitGta Максимальный кредит по карте SCardID на момент инициализации.
		// Извлекается только в том случае, если Quot != 0.0
};

class GtaJournalCore : public GtaJournalTbl {
public:
	GtaJournalCore();
	int    CheckInOp(PPGta & rGta, int use_ta);
};
//
//
//
class GtinStruc : public StrAssocArray {
public:
	// Attention! Перечисление ниже портировано в проект Stylo-Q (класс GTIN) с идентичными мнемониками и значениями,
	// равными неявным значениям c-enum'а. Новые элементы добавлять строго в конец списка с одновременной
	// поддержкой идентичности в Stylo-Q.
	enum { // A.I. Описание Количество цифр и формат
		fldSscc18            = 1, // 00 Серийный код транспортной упаковки (SSCC-18): 18 цифр
		fldGTIN14,                // 01 непосредственно сам Глобальный номер товара (GTIN): 14 цифр
		fldContainerCt,           // 02 Количество контейнеров, содержащихся в другой упаковке (используется совместно с АI 37): 14 цифр
		fldPart,                  // 10 Номер партии: 1?20 буквенно-цифровой
		fldManufDate,             // 11 Дата производства: 6 цифр в формате YYMMDD
		fldExpiryPeriod,          // 12 Срок годности: 6 цифр в формате YYMMDD
		fldPackDate,              // 13 Дата упаковки: 6 цифр в формате YYMMDD
		fldBestBeforeDate,        // 15 Срок хранения … (Используется для контроля качества): 6 цифр в формате YYMMDD
		fldExpiryDate,            // 17 Дата окончания срока действия (Безопасность товара): 6 цифр в формате YYMMDD
		fldVariant,               // 20 Вариант продукта: 2 цифры
		fldSerial,                // 21 Серийный номер: 1?20 буквенно-цифровой
		fldHIBCC,                 // 22 HIBCC в количестве, дате, в пакете и ссылка: От 1 до 29 буквенно-цифровой
		fldLot,                   // 23x Номер лота: От 1 до 19 буквенно-цифровой
		fldAddendumId,            // 240 Дополнительная идентификация продукта: 1?30 буквенно-цифровой
		fldSerial2,               // 250 Второй серийный номер: 1?30 буквенно-цифровой
		fldQtty,                  // 30  Количество каждого: 1?8 цифр
		fldWtNettKg,              // 310y Вес нетто (кг): 6 цифр
		fldLenM,                  // 311y Длина изделия — первое измерение (в метрах): 6 цифр
		fldWidthM,                // 312y Ширина или диаметр изделия — 2-ое измерение (в метрах): 6 цифр
		fldThknM,                 // 313y Глубина или толщина изделия — 3-е измерение (в метрах): 6 цифр
		fldAreaM2,                // 314y Площадь (в квадратных метрах): 6 цифр
		fldVolumeL,               // 315y Объем продукта (в литрах): 6 цифр
		fldVolumeM3,              // 316y Объем продукта (в кубических метрах): 6 цифр
		fldWtNettLb,              // 320y Вес нетто (в фунтах): 6 цифр
		fldLenInch,               // 321y Длина изделия — первое измерение (в дюймах): 6 цифр
		fldLenFt,                 // 322y Длина изделия — первое измерение (в футах): 6 цифр
		fldLenYr,                 // 323y Длина изделия — первое измерение (в ярдах): 6 цифр
		fldDiamInch,              // 324y Ширина или диаметр изделия — второе измерение (в дюймах): 6 цифр
		fldDiamFt,                // 325y Ширина или диаметр изделия — второе измерение (в футах): 6 цифр
		fldDiamYr,                // 326y Ширина или диаметр изделия — второе измерение (в ярдах): 6 цифр
		fldThknInch,              // 327y Глубина или толщина изделия — 3-е измерение (в дюймах): 6 цифр
		fldThknFt,                // 328y Глубина или толщина изделия — 3-е измерение (в футах): 6 цифр
		fldThknYr,                // 329y Глубина или толщина изделия — 3-е измерение (в ярдах): 6 цифр
		fldContainerWtBruttKg,    // 330Y Вес контейнера брутто (кг): 6 цифр
		fldContainerLenM,         // 331y Длина контейнера — первое измерение (в метрах): 6 цифр
		fldContainerDiamM,        // 332y Ширина или диаметр контейнера — 2-е измерение (в метрах): 6 цифр
		fldContainerThknM,        // 333y Глубина или толщина контейнера — 3-е измерение (в метрах): 6 цифр
		fldContainerAreaM2,       // 334y Площадь контейнера (в квадратных метрах): 6 цифр
		fldContainerVolumeL,      // 335y Объем контейнера (в литрах): 6 цифр
		fldContainerGVolumeM3,    // 336y Валовой объем контейнера (в кубических метрах): 6 цифр
		fldContainerMassLb,       // 340y Полная масса контейнера (в фунтах): 6 цифр
		fldContainerLenInch,      // 341y Длина контейнера — первое измерение (в дюймах): 6 цифр
		fldContainerLenFt,        // 342y Длина контейнера — первое измерение (в футах): 6 цифр
		fldContainerLenYr,        // 343y Длина контейнера — первое измерение (в ярдах): 6 цифр
		fldContainerDiamInch,     // 344y Ширина или диаметр контейнера — 2-ое измерение (в дюймах): 6 цифр
		fldContainerDiamFt,       // 345y Ширина или диаметр контейнера — 2-ое измерение (в футах): 6 цифр
		fldContainerDiamYr,       // 346y Ширина или диаметр контейнера — 2-ое измерение (в ярдах): 6 цифр
		fldContainerThknInch,     // 347y Глубина или толщина контейнера — 3-е измерение (в дюймах): 6 цифр
		fldContainerThknFt,       // 348y Глубина или толщина контейнера — 3-е измерение (в футах): 6 цифр
		fldContainerThknYr,       // 349y Глубина или толщина контейнера — 3-е измерение (в ярдах): 6 цифр
		fldProductAreaInch2,      // 350y Площадь продукта (квадратные дюймы): 6 цифр
		fldProductAreaFt2,        // 351y Площадь продукта (квадратных футов): 6 цифр
		fldProductAreaM2,         // 352y Площадь продукта (квадратных метров): 6 цифр
		fldContainerAreaInch2,    // 353y Площадь контейнера (квадратный дюйм): 6 цифр
		fldContainerAreaFt2,      // 354y Контейнер площади (квадратных футов): 6 цифр
		fldContainerAreaYr2,      // 355y Размер контейнера (квадратных ярдов): 6 цифр
		fldWtNettTOz,             // 356y Вес нетто (в тройских унциях ): 6 цифр
		fldVolumeL_2,             // 360y Объем продукта ( литров ): 6 цифр
		fldVolumeL_3,             // 361y Объем продукта ( литров ): 6 цифр
		fldContainerGVolumeQt,    // 362y Валовой объем контейнера (в квартах): 6 цифр
		fldContainerGVolumeGal,   // 363y Валовой объем контейнера (в галлонах): 6 цифр
		fldVolumeInch3,           // 364y Объем продукции (в кубических дюймах): 6 цифр
		fldVolumeFt3,             // 365y Объем продукции (в кубических футах): 6 цифр
		fldVolumeM3_2,            // 366y Объем продукции (в кубических метрах): 6 цифр
		fldContainerGVolumeInch3, // 367y Валовой объем контейнера (в кубических дюймах): 6 цифр
		fldContainerGVolumeFt3,   // 368y Валовой объем контейнера (в кубических футах): 6 цифр
		fldContainerGVolumeM3_2,  // 369y Валовой объем контейнера (в кубических метрах): 6 цифр
		fldCount,                 // 37 Количество единиц, содержащихся (используется совместно с AI 02): 1?8 цифр
		fldCustomerOrderNo,       // 400 Номер заказа Клиента: От 1 до 29 буквенно-цифровой
		fldShipTo,                // 410 Адресат/Грузополучатель (код EAN-13 или DUNS): 13 цифр
		fldBillTo,                // 411 Доставка счета / код места, где будет произведена оплата за продукт (код EAN-13 или DUNS): 13 цифр
		fldPurchaseFrom,          // 412 Приобретение / код места, где будет произведена покупка (код EAN-13 или DUNS): 13 цифр
		fldShitToZip,             // 420 Доставка по почтовому индексу (внутренний почтовый индекс): 1?9 алфавитно-цифровой
		fldShitToZipInt,          // 421 Доставка по почтовому индексу (международный почтовый индекс): 4?12 буквенно-цифровой
		fldCountry,               // 422 Код страны в соответствии со стандартом ISO: 3 цифр
		fldRollDimentions,        // 8001 Размер продукта для рулона (ширина, длина и диаметр): 14 цифр
		fldESN,                   // 8002 Электронный серийный номер (ESN) исключительно для мобильных телефонов: 1?20 буквенно-цифровой
		fldGRAI,                  // 8003 Идентификатор возвращаемого актива — GRAI: 14 цифр UPC / EAN и 1?16 серийный номер возвращаемых активов
		fldGIAI,                  // 8004 Второй идентификатор возвращаемого актива — GIAI: 1?30 буквенно-цифровой
		fldPrice,                 // 8005 Цена за единицу измерения: 6 цифр
		fldCouponCode1,           // 8100 Расширенный код купона: Системный номер и предложение: 6 цифр
		fldCouponCode2,           // 8101 Расширенный код купона: Система счисления, предложения и завершения предложения: 10 цифр
		fldCouponCode3,           // 8102 Расширенный код купона: количеству в системе счисления предшествовует 0: 2 цифры
		fldMutualCode,            // 90 По взаимному согласию сторон: 1?30 значный буквенно-цифровой
		fldUSPS,                  // 91 USPS услуг: 2-значный код услуги, 9-значный код клиента, 8-значный ID плюс 1 контрольная цифра упаковки
		fldInner1,                // 92 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner2,                // 93 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner3,                // 94 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner4,                // 95 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner5,                // 96 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner6,                // 97 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner7,                // 98 Внутренние коды компании 1?30 буквенно-цифровой
		fldInner8,                // 99 Внутренние коды компании 1?30 буквенно-цифровой
		fldPriceRuTobacco,        // Собственный идентификатор - МРЦ сигарет (кодируется)
		fldControlRuTobacco,      // 93 Собственный идентификатор - контрольная последовательность в конце маркировки сигарет (Россия).
		fldWeight,                // @v11.9.0 3103 Масса товара в единице (на сайте честный знак указана длина поля 9 символов, но фактически длина иная)
		fldOriginalText,          // Оригинальный текст, поданый для разбора // @v12.3.5 moved from 0 (first elem) to here
	};
	GtinStruc();
	void   SetSpecialFixedToken(int token, int fixedLen /* 1000 - UNTIL EOL */);
	void   RemoveSpecialFixedToken(int token); // @v11.8.10
	void   SetSpecialMinLenToken(int token, int minLen);
	void   AddSpecialStopChar(uchar stopChar);
	void   AddOnlyToken(int token);
	GtinStruc & Z();
	int    Parse(const char * pCode);
	int    GetToken(int tokenId, SString * pToken) const;
	int    GetSpecialNaturalToken() const;
	int    Debug_Output(SString & rBuf) const;
private:
	uint   SetupFixedLenField(const char * pSrc, const uint prefixLen, const uint fixLen, int fldId);
	uint   RecognizeFieldLen(const char * pSrc, int currentPrefixID) const;
	bool   IsSpecialStopChar(const char * pSrc) const;
	//
	// Descr: Флаги функции DetectPrefix
	//
	enum {
		dpfBOL = 0x0001 // Мы находимся в начале строки (нужен для отсеивания префиксов, которые могут встречаться только в начале строки)
	};
	int    DetectPrefix(const char * pSrc, uint flags, int currentId, uint * pPrefixLen) const;
	int    GetPrefixSpec(int prefixId, uint * pFixedLen, uint * pMinLen) const;
	::LAssocArray SpecialFixedTokens; // Значение длины 1000 означает 'до конца строки' (UNTIL EOL)
	::LAssocArray SpecialMinLenTokens; // Специфицированные минимальные длины токенов
	LongArray OnlyTokenList;
	int    SpecialNaturalToken;  // При разборе может появиться специальный случай, отражаемый как NaturalToken (например, SNTOK_CHZN_CIGITEM)
	uint8  SpecialStopChars[12]; // Специальные символы-разделители токенов. Все символы в этом буфере, предшествующие 0 считаются разделителями.
};
//
//
//
struct PPEdiProvider {
	PPEdiProvider();
	int    FASTCALL IsEq(const PPEdiProvider & rS) const;

	enum {
		fPassive = 0x0001
	};
	long   Tag;            // Const=PPOBJ_EDIPROVIDER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символьный код единицы измерения //
	long   Flags;
	long   SuppOpFlags;    // Флаги поддерживаемый операций (1 << PPEDIOP_XXX)
	int32  AddrPort;       // IP-порт адреса
	int32  AddrPort2;      // IP-порт резервного адреса
	uint8  Reserve[48];
	PPID   GuaID;          // Ид глобальной учетной записи, используемой для авторизации
	PPID   DtoPersonID;    // @v11.9.12 Ид персоналии - оператора передачи данных (вид персоналии PPPRK_DTO).
};

class PPEdiProviderPacket {
public:
	enum { // @persistent
		extssDllModuleName =  1,
		extssTempPath      =  2,
		extssAddr          = 11,
		extssAddr2         = 12,
		extssLogin         = 13,
		extssPassword      = 14,
		extssFormatSymb    = 15, // Символ формата обмена (зависит от провайдера)
		extssSubIn         = 16, // @v11.9.4 Подкаталог (или иное дополнение к адресу), указывающий на входящие документы
		extssSubOut        = 17, // @v11.9.4 Подкаталог (или иное дополнение к адресу), указывающий на исходящие документы
	};

	PPEdiProviderPacket();
	~PPEdiProviderPacket();
	bool   FASTCALL IsEq(const PPEdiProviderPacket & rS) const;
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char *);
	int    MakeUrl(int reserved, InetUrl & rUrl);

	PPEdiProvider Rec;
	SString ExtString;
};

class PPObjEdiProvider : public PPObjReference {
public:
	explicit PPObjEdiProvider(void * extraPtr = 0);
	~PPObjEdiProvider();
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    GetPacket(PPID id, PPEdiProviderPacket * pPack);
	int    PutPacket(PPID * pID, PPEdiProviderPacket * pPack, int use_ta);
	int    SerializePacket(int dir, PPEdiProviderPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjAccSheet)
// Таблицы аналитических статей
//
#define ACSHF_AUTOCREATART  0x0001L // Автоматически создавать статьи при создании объекта
#define ACSHF_USECLIAGT     0x0002L // Использует соглашения с клиентами
#define ACSHF_USEALIASSUBST 0x0004L // Использует подстановку алиасов счетов
#define ACSHF_USESUPPLAGT   0x0008L // Использует соглашения с поставщиками

struct PPAccSheet2 {       // @persistent @store(Reference2Tbl+)
	PPAccSheet2();
	PPAccSheet2 & Z();

	long   Tag;            // Const=PPOBJ_ACCSHEET
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[48];   // @reserve // @v12.1.5 [52]-->[48]
	PPID   WarehouseGroup; // @v12.1.5 Если Assoc == PPOBJ_LOCATION, то в этом поле может быть задана группирующая запись складов, с которыми ассоциируются статьи этой таблицы
	PPID   BinArID;        // Статья для сброса остатков по закрываемым статьям
	PPID   CodeRegTypeID;  // ИД типа регистрационного документа, идентифицирующего персоналию, соответствующую статье.
	long   Flags;          // ACSHF_XXX
	long   Assoc;          // @#{0L, PPOBJ_PERSON, PPOBJ_LOCATION, PPOBJ_ACCOUNT} Ассоциированный объект
	long   ObjGroup;       // Подгруппа ассоциированных объектов
};

class PPObjAccSheet : public PPObjReference {
public:
	explicit PPObjAccSheet(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPAccSheet * pRec);
	//
	// Descr: возвращает >0 если таблица статей acsID ассоциирована с объектами типа objType.
	//
	int    IsAssoc(PPID acsID, PPID objType, PPAccSheet *);
	int    IsLinkedToMainOrg(PPID acsID);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual int  MakeReserved(long flags);
};
//
// @ModuleDecl(PPAbstractDevice)
//
//
// Классы устройств
// @persistent
// Наименования типов перечислены в строковом ресурсе PPTXT_ABSTRACTDEVICETYPENAMES
//
#define DVCCLS_UNKN             0 // Неопределенный тип (недопустимое значение)
#define DVCCLS_TOGGLE           1 // Переключатель
#define DVCCLS_SCALES           2 // Весы // @vmiller
#define DVCCLS_SYNCPOS          3 // Синхронные кассы // @vmiller
#define	DVCCLS_DISPLAY          4 // Дисплеи // @v7.9.6 DVCCLS_CUSTDISP-->DVCCLS_DISPLAY
#define DVCCLS_BNKTERM          5 // Банковские терминалы
#define DVCCLS_READER           6 // Считыватель
//
// Типы реализации драйверов устройств
//
#define DVCDRVIMPL_UNKN         0 // Неопределенный тип
#define DVCDRVIMPL_DLL          1 // DLL
//
// Команды устройств
//
#define DVCCMD_PING             1
#define DVCCMD_SETTEXT          2
#define DVCCMD_TOGGLE           3
//
// Теги параметров команд устройств
//
#define DVCCMDPAR_TEXT          1 // string
#define DVCCMDPAR_COUNT         2 // int
#define DVCCMDPAR_CARD          3 // string
#define DVCCMDPAR_CREDIT        4 // real
#define DVCCMDPAR_AMOUNT        5 // real
#define DVCCMDPAR_QTTY          6 // real
//
// Descr: Базовый класс для интерфейса с устройством.
//
class PPAbstractDevice {
public:
	//
	// Descr: Отправляет команду pCmd и необходимые параметры pInput устройству.
	// ARG(pCmd IN): Имя команды.
	// ARG(pInput IN): Список входных параметров. Представляет собой пары имя_параметра=значение_параемтра, перечисленные через ";".
	// ARG(pOutput OUT): Список выходных параметров или код ошибки. Список представляет собой пары имя_параметра=значение_параметра, перечисленных через ";".
	// ARG(outputBufSize IN): Размер буфера pOutput.
	// Returns:
	//		0 - нет ошибок
	//		1 - ошибка выполнения команды
	//		2 - недостаточный размер выходного буфера
	//
	typedef int (/*STDAPICALLTYPE*/ * ProcDevDll)(const char * , const char * , char * , size_t); // @vmiller заменила на CALLBACK

	struct Capability {
		long   Cls;
		long   Dvc; // @vmiller Определяет конкретное устройство из класса
		long   Flags;
		int16  DispLineSize;
		int16  DispLinesCount;
		SString DllName; // @vmiller
	};
	struct Command {
		int32  InnerId;
		int32  UnifyId;
		SString Symb;
		SString Text;
	};
	struct ConnectionParam {
		ConnectionParam();
		int    IsEqualAddr(const ConnectionParam & rParam) const;

		//char   Port[8];
		long   DeviceNo;
		PPID   DeviceID;
		CommPortTimeouts Cpt;
		CommPortParams Cpp; // size=6
		int8   NotOwned;   // Not Owned P_Conn
		int8   ReleCount;  // Кол-во срабатывний реле [0..255], 255 - удерживает аппарат на 6 секунд
		long   GoodsID;
		long   P_Conn;    // SComPort или TcpSocket
		SString Address;
		SString DeviceName;
	};

	static int CreateInstance(const char * pSymb, PPAbstractDevice ** ppDvc);
	//
	// Descr: Возвращает наименование и идентификатор секции файла ppdrv.ini по классу
	//   устройства dvcClass.
	// ARG(dvcClass IN): Класс устройсва DVCCLS_XXX
	// ARG(pReserveTypesStrId OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается значение идентификатора
	//   ресурса строки, содержащей перечисление зарезервированных типов устройств класса dvcClass.
	//   Если для заданного класса нет зарезервированных типов, то возвращается 0.
	// ARG(pSectName OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается текстовое наименование
	//   секции ppdrv.ini, содержащей определители драйверов устройсв.
	// Returns:
	//   >0 - идентификатор секции (PPINISECT_XXX)
	//   <0 - класс устройсва валидный, но идентификатор секции не определен. По адресу pSectName
	//     возвращается наименование секции.
	//   0  - инвалидный класс устройства
	//
	static int GetDrvIniSectByDvcClass(int dvcClass, int * pReserveTypesStrId, SString * pSectName);
	//
	// Descr: Разбирает значение определителя драйвера устройства, описанное в ppdrv.ini.
	// Note: Определитель драйвера устройства в файле ppdrv.ini выглядит так:
	//   symbol=drv_name,drv_impl,drv_path
	//   Здесь:
	//     symbol - уникальный символ, идентифицирующий определитель драйвера
	//     drv_name - имя драйвера устройства
	//     drv_impl - тип реализации драйвера. Сейчас только DLL (DVCDRVIMPL_DLL)
	//     drv_path - путь к файлу dll или только имя файла (тогда файл ищется в стандартном каталоге драйверов)
	//
	// Returns:
	//   1 - строка содержит все необходимые термы
	//   2 - строка не содержит префикс symbol= (аргумент rSymbol обнуляется).
	//   0  - недопустимая строка определителя.
	//
	static int ParseRegEntry(const char * pLine, SString & rSymbol, SString & rDrvName, SString & rDrvPath, int * pDrvImpl);

	PPAbstractDevice(const char * pDvcName);
	virtual ~PPAbstractDevice();
	virtual int GetCapability(Capability * pCpb);
	virtual int OpenConnection(const ConnectionParam &);
	virtual int CloseConnection();
	virtual int GetConnParam(ConnectionParam *);
	virtual int GetSessionPrice(PPObjGoods *, double *);
	virtual int RunCmd(int innerId, const StrAssocArray & rIn, StrAssocArray & rOut);
	//
	// Descr: метод для работы с dll-файлами устройств.
	// ARG(cmdID	IN): ID команды, которую должно выполнить устройство
	// ARG(rIn		IN): параметры, необходимые для выполнения команды
	// ARG(rOut	   OUT): результат выполнения команды (либо данные с устройства, лиюо сообщение об ошибке)
	// Returns:
	//  -1 - команда выполнена успешно, но устройство вернуло ошибку (код ошибки передается в rOut)
	//   0 - error
	//   1 - успешное выполнение команды
	//
	int    RunCmd__(int cmdID, const StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
	int    RunCmd(const char * pCommandLine, StrAssocArray & rOut);
	int    GetDllName(int dvcClass, long devTypeId, SString & dllName); // @vmiller
	int    GetDllName(int dvcClass, const char * pName, SString & rDllName);
	int    IdentifyDevice(const char * pSymb); // @vmiller
	int    IdentifyDevice(int dvcClass, const char * pName);

	Capability PCpb; // @vmiller
protected:
	int    Helper_RunCmd(const SString & rCmd, const SString & rArg, StrAssocArray & rOut);

	enum {
		stError     = 0x0001,
		stConnected = 0x0002
	};
	class IdentBlock {
	public:
		IdentBlock();
		~IdentBlock();
		int operator !() const;
		void Release();
		int  Set(SDynLibrary * pLib, int setOwnership);

		ProcDevDll Func;
	private:
		SDynLibrary * P_Lib;
		int    IsLibOwner; // Если 0, то не разрушает объект P_Lib
	};
	IdentBlock Ib;
	long	State;
	SString DvcName;
	STempBuffer RetBuf; // Буфер для приема возвращаемой драйвером строки
};

extern "C" typedef PPAbstractDevice * (*FN_PPDEVICE_FACTORY)();

#define PPDEVICE_FACTORY(dvcSymb)  ADF_##dvcSymb
#define IMPLEMENT_PPDEVICE_FACTORY(dvcSymb) \
	extern "C" __declspec(dllexport) PPAbstractDevice * ADF_##dvcSymb() { return new dvcSymb(); }
//
//
//

//
// @ModuleDecl(PPObjCachNode)
//
// Флаги кассового узла
//
#define CASHF_DAYCLOSED           0x00000001L // Текущий день закрыт
#define CASHF_DAYSTARTED          0x00000002L // За день были сделаны проводки
#define CASHF_CHKPAN              0x00000004L // Для ввода чеков применяется кассовая панель (иначе - устаревшая техника микродокументов).
#define CASHF_NAFCL               0x00000008L // Не активизировать первую товарную строку чека
#define CASHF_OPENBOX             0x00000010L // (sync)  При печати чека открывать ящик
#define CASHF_LASTCHKCANCELLED    0x00000020L // (sync)  Печать последнего чека была прервана
#define CASHF_SELALLGOODS         0x00000040L // (sync)  Выбор товаров независимо от того, имеются они на остатке или нет
#define CASHF_ABOVEZEROSALE       0x00000080L // (sync) Не разрешать продажу если остаток не достаточен
//
// Следующие два флага взаимоисключающие. Если оба флага имеют одинаковое
// значение, то (а)синхронность кассового узла определяется неявным образом.
//
#define CASHF_SYNC                0x00000100L // Синхронный кассовый узел
#define CASHF_ASYNC               0x00000200L // Асинхронный кассовый узел
#define CASHF_EXPCHECKD           0x00000400L // (async) Export check digit of barcode
#define CASHF_EXTFRM349           0x00000800L // Запись переведена на формат @v3.4.9
#define CASHF_IMPORTCHECKSWOZR    0x00001000L // (async) Импортировать чеки независимо от наличия Z-отчета.
#define CASHF_DISROUNDUP          0x00002000L // (sync)  Округлять скидку в большую сторону
#define CASHF_DISROUNDDOWN        0x00004000L // (sync)  Округлять скидку в меньшую сторону
#define CASHF_EXPDIVN             0x00008000L // (async) Экспортировать в кассовый модуль номера отделов
#define CASHF_ROUNDINT            0x00010000L // (sync)  округлять %% скидку при печати чека до целого
#define CASHF_EXPGOODSREST        0x00020000L // (async) Экспортировать товарные остатки
#define CASHF_AUTO_PRINTCOPY      0x00040000L // (sync)  Автоматически печатать копию чека
#define CASHF_USEQUOT             0x00080000L // (sync)  Использовать котировку в кассовой панели
	// Если этот флаг установлен, то при выборе товара в кассовой панели цена определяется по следующему алгоритму:
	// 1. Ищется базовая котировка по складу, к которому привязан кассовый узел
	// 2. Если на предыдущем шаге котировка не найдена, то ищется базовая котировка для всех складов
	// 3. Если на предыдущем шаге котировка не найдена, то используется обычное правило определение цены по лотам
#define CASHF_NOASKPAYMTYPE       0x00100000L // (sync)  не запрашивать вид оплаты
#define CASHF_SHOWREST            0x00200000L // (sync)  в панели ввода чеков показывать остаток
#define CASHF_KEYBOARDWKEY        0x00400000L // (sync)  используется клавиатура с ключом
#define CASHF_WORKWHENLOCK        0x00800000L // (sync)  разрешить работу с кассовой панелью при блокировке
#define CASHF_NOMODALCHECKVIEW    0x01000000L // (sync)  По команде "Чеки" после показа кассовой панели не показывать таблицу чеков
#define CASHF_DISABLEZEROAGENT    0x02000000L // (sync)  В панели чеков не разрешать проводить/откладывать/печатать чеки без явного указания агента
#define CASHF_EXPGOODSGROUPS      0x04000000L // (async) Экспортировать товарные группы
#define CASHF_NOTUSECHECKCUTTER   0x08000000L // (sync)  Не использовать отрезчик чеков
#define CASHF_UNIFYGDSATCHECK     0x10000000L // (sync)  Объединять одинаковые товары в чеке
#define CASHF_UNIFYGDSTOPRINT     0x20000000L // (sync)  Объединять одинаковые товары при печати
#define CASHF_SKIPUNPRINTEDCHECKS 0x40000000L // (sync)  При списании не учитывать "неотпечатанные" чеки
#define CASHF_CHECKFORPRESENT     0x80000000L // (sync)  Проверять на выдачу подарка
//
//
//
#define CASHFX_ROUNDAMTUP         0x00000001L // Округлять сумму вверх
#define CASHFX_ROUNDAMTDOWN       0x00000002L // Округлять сумму вниз
#define CASHFX_SELSERIALBYGOODS   0x00000004L // Предлагать выбор партии после выбора товара
#define CASHFX_FORCEDIVISION      0x00000008L // Не допускает проведение чека пока не будет выбран отдел
#define CASHFX_GLASSOCPRINTONLY   0x00000010L // Именованную ассоциацию товар-склад использовать только для печати
#define CASHFX_EXTSCARDSEL        0x00000020L // Улучшенный режим выбора дисконтной карты
#define CASHFX_EXPLOCPRNASSOC     0x00000040L // (async) Экспортировать символ ассоциированного с товаром (посредством склада) локального принтера
#define CASHFX_UNITEGRPWROFF      0x00000080L // Объединенное списание сессий по кассовым узлам принадлежащим группе.
#define CASHFX_APPLYUNITRND       0x00000100L // (async) Применять дробность округления, заданную в единице измерения товара.
#define CASHFX_RESTRUSERGGRP      0x00000200L // (async) Ограничивать загрузку изменений только товарами, входящими в группу,
	// которой ограничен пользователь (PPAccessRestriction::OnlyGoodsGrpID)
#define CASHFX_SUSPLISTWODLVR     0x00000400L // @unused (sync) В списке отложенных чеков не показывать чеки с доставкой
#define CASHFX_RMVPASSIVEGOODS    0x00000800L // (async) Посылать модулю требование на удаление пассивных товаров
#define CASHFX_KEEPORGCCUSER      0x00001000L // (sync)  При отложении-восстановлении чеков сохранять оригинального пользователя, создавшего чек.
#define CASHFX_CREATEOBJSONIMP    0x00002000L // (async) Создавать объекты при импорте чеков
#define CASHFX_PASSIVE            0x00004000L // Пассивный узел (не отображается в списках)
#define CASHFX_ENABLECASHLESSBPEQ 0x00008000L // @v12.0.6 Допускается проведение безналичной оплаты в обход банковского терминала
#define CASHFX_SEPARATERCPPRN     0x00010000L // (async) Загружать номера кассовых аппаратов
#define CASHFX_INPGUESTCFTBL      0x00020000L // (sync) После выбора стола требовать ввода количества гостей
#define CASHFX_DISABLEZEROSCARD   0x00040000L // (sync) Запрет операция без выбора персональной карты
#define CASHFX_UHTTORDIMPORT      0x00080000L // (sync) Импортировать заказа с сервера Universe-HTT
#define CASHFX_IGNLOOKBACKPRICES  0x00100000L // (async) Игноририровать обратный анализ доступных цены на специальные товары
#define CASHFX_ABSTRGOODSALLOWED  0x00200000L // (sync) Допускается продажа абстрактного товара по цене (в конфигурации товаров должен быть указан DefGoodsID).
#define CASHFX_EXTNODEASALT       0x00400000L // (sync) Дополнительный кассовый узел используется как альтернативный принтер
#define CASHFX_IGNCONDQUOTS       0x00800000L // (async) Не использовать при расчете цен для загрузки условные котировки.
	// Транслируется в установку флага RTLPF_IGNCONDQUOTS при вызове RetailPriceExtractor::Init()
#define CASHFX_CHECKEGAISMUNIQ    0x01000000L // (sync) Проверять уникальность сканируемых акцизных марок (медленная операция)
#define CASHFX_IGNPENNYFROMBCARD  0x02000000L // @erik игнорировать копейки при списывании бонусов с бонусной карты
#define CASHFX_NOTIFYEQPTIMEMISM  0x04000000L // (sync) Информировать в кассовой панели о расхождении времени на регистраторе со временем на компьютере
#define CASHFX_BNKSLIPAFTERRCPT   0x08000000L // (sync) Печатать банковский слип после кассового чека (иначе сначала слип, потом чек)
#define CASHFX_USEGOODSMATRIX     0x10000000L // @v11.2.8 Применять ограничения товарной матрицы в кассовой панели
#define CASHFX_SYNCOPENSESSSOFT   0x20000000L // @v11.4.7 (sync) Открывать кассовую сессию без подачи соответствующей команды устройству.
	// Причина: на некоторых устройствах функция открытия сессии влечет проблемы.
#define CASHFX_ZEROBONUS          0x40000000L // @v11.4.9 (sync) Использование бонусов не допускается.
//
// Идентификаторы строковых свойств кассовых узлов.
// Attention: Ни в коем случае не менять значения идентификаторов - @persistent
//
#define ACN_EXTSTR_FLD_IMPFILES      1 // @persistent Для асинхронный узлов - пути импорта, для синхронных URL обмена данными с головным сервером
#define ACN_EXTSTR_FLD_EXPPATHS      2 // @persistent
#define ACN_EXTSTR_FLD_LOGNUMS       3 // @persistent
#define SCN_EXTSTR_FLD_CUSTDISPPORT  4 // @persistent
#define SCN_PRINTERPORT              5 // @persistent
#define SCN_CAFETABLE_DGR_PATH       6 // @persistent
#define ACN_EXTSTR_FLD_ADDEDMSGSIGN  7 // @persistent
#define SCN_BNKTERMPATH              8 // @persistent
#define SCN_SLIPFMTPATH              9 // @persistent Путь к файлу описания slip-отчетов. Если не указан, то используется bin\stdslip.fmt
#define SCN_CASHDRAWER_PORT         10 // @persistent
#define SCN_CASHDRAWER_CMD          11 // @persistent
#define SCN_KITCHENBELL_PORT        12 // @persistent
#define SCN_KITCHENBELL_CMD         13 // @persistent
#define SCN_RPTPRNPORT              14 // @persistent Порт принтера для печати отчетов (предчеков)
#define SCN_MANUFSERIAL             15 // @persistent Заводской номер кассового аппарата
//
// Кассовый узел
//
class CashNodePaneFilt : public PPBaseFilt {
public:
	CashNodePaneFilt();

	long   ReserveStart;
	PPID   CashNodeID;
	long   CommandID;
	PPID   ParentID;
	char   Reserve[60];
	long   ReserveEnd;
};

struct PPCashNode2 {       // @persistent @store(Reference2Tbl+)
	PPCashNode2();
	//
	// Descr: Варианты специализации кассового узла
	//
	enum {
		spDefault = 0, // То же, что и spGeneral
		spGeneral = 1, // Общий.
		spCafe,        // Кафе (выбор столов, заказы столов, количество гостей и т.д.)
		spShop,        // Магазин (выбор отдела, подбор товара по цене и т.д.)
		spDelivery,    // Доставка
		spApteka       // Аптека
	};
	long   Tag;            // Const=PPOBJ_CASHNODE
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	uint16 DisRoundPrec;   // .01 @#{0..50000} Точность округления скидки //
	uint16 AmtRoundPrec;   // .01 @#{0..50000} Точность окрнугления результирующей суммы чека
	long   ExtFlags;       // CASHFX_XXX
	char   Port[8];        // Имя порта (LPT1, COM1, ...)
	PPID   GoodsLocAssocID; // Именованная ассоциация товар-склад, используемая для печати чеков и списания //
	uint16 SleepTimeout;   // Таймаут бездействия (сек), после которого панель блокируется //
	uint16 Speciality;     // PPCashNode::spXXX Специализация кассового узла
	PPID   CurRestBillID;  // Временный документ текущих остатков по незакрытым кассовым сессиям
	PPID   ParentID;       // Ссылка на родительскую группу
	PPID   GoodsGrpID;     // Товарная группа, которой следует ограничивать загрузку товаров в асинхр модуль либо
		// отбор товаров в синхронном узле. // Reserve4-->GoodsGrpID
	//
	// Поле DownBill имеет специальное назначение.
	// При закрытии синхронной кассовой сессии количество вбитых чеков может
	// быть настолько большим, что в рамках одной транзакции не удается //
	// собрать их все в один документ (ошибка Btrieve = 2). По-этому
	// каждый чек вливается в единый документ отдельной транзакцией. Но
	// если процесс был прерван в результате ошибки, то частично заполненный
	// новый документ остается. Поле DownBill как раз и сохраняет
	// идентификатор этого документа. После устранения ошибки процесс
	// закрытия кассовой сессии можно продолжить с этим документом.
	// В нормальной ситуации это поле всегда нулевое.
	//
	PPID   DownBill;       //
	PPID   CashType;       // Тип ККМ (PPCMT_XXX)
	long   LogNum;         // Логический номер кассы
	int16  DrvVerMajor;    //
	int16  DrvVerMinor;    //
	PPID   ExtQuotID;      // ->Ref(PPOBJ_QUOTKIND) Дополнительная котировка (используется некоторыми типами ККМ)
	LDATE  CurDate;        // Текущая операционная дата
	long   Flags;          // CASHF_XXX      Флаги
	long   LocID;          // ->Location.ID  Склад
	PPID   CurSessID;      // ->CSession.ID  Текущая кассовая сессия (для синхронных узлов)
};

class PPGenCashNode {        // @transient
public:
	struct DivGrpAssc {      // @flat
		PPID   GrpID;        // ->Goods2.ID (GoodsGroup)
		short  DivN;         // Номер отдела
	};
	struct RoundParam {
		int    DisRoundDir;  // Направление округления скидки
		int    AmtRoundDir;  // Направление округления результирующей суммы чека
		long   IgnPennyFromBCardFlag; // @erik v10.6.13 Игнорирование копеек при оплате бонусной картой
		double DisRoundPrec; // Точность округления скидки
		double AmtRoundPrec; // Точность округления результирующей суммы чека
	};
	struct PosIdentEntry {
		PosIdentEntry();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

        long   N_;
        S_GUID Uuid;
        SString Name;
	};
	PPGenCashNode();
	virtual ~PPGenCashNode();
	PPGenCashNode & FASTCALL operator = (const PPGenCashNode &);
	int    FASTCALL Copy(const PPGenCashNode & rS);
	int    SetRoundParam(const RoundParam * pParam);
	int    GetRoundParam(RoundParam * pParam) const;
	void   DrvVerToStr(SString & rS) const;
	int    DrvVerFromStr(const char * pS);

	PPID   ID;               // @id
	char   Name[48];         // @name
	char   Symb[20];         //
	PPID   CurRestBillID;    // Временный документ текущих остатков по незакрытым кассовым сессиям
	PPID   CashType;         // Тип ККМ (PPCMT_XXX)
	int16  DrvVerMajor;      // @todo Заменить поля DrvVerMajor && DrvVerMinor на SVerT
	int16  DrvVerMinor;      //
	uint16 DisRoundPrec;     // .01 @#{0..50000} Точность округления скидки //
	uint16 AmtRoundPrec;     // .01 @#{0..50000} Точность округления результирующей суммы чека
	uint16 Speciality;       // @v11.9.6 PPCashNode::spXXX 
	uint64 Reserve;          // @v11.9.6 @alignment
	PPID   LocID;            //
	PPID   ExtQuotID;        // ->Ref(PPOBJ_QUOTKIND) Дополнительная котировка
	long   Flags;            //
	long   ExtFlags;         //
	PPID   GoodsLocAssocID;  // Именованная ассоциация товар-склад, спользуемая для печати чеков и списания //
	PPID   ParentID;         // Группа кассовых узлов
	PPID   GoodsGrpID;       // Товарная группа, которой следует ограничивать загрузку товаров в асинхр модуль либо
		// отбор товаров в синхронном узле. // Reserve4-->GoodsGrpID
	SArray * P_DivGrpList;   // (move from PPAsyncCashNode)
	ObjTagList TagL;         // @dbd_exchange Список тегов
};

class PPAsyncCashNode : public PPGenCashNode {
public:
	PPAsyncCashNode();
	PPAsyncCashNode & FASTCALL operator = (const PPAsyncCashNode &);
	int    FASTCALL Copy(const PPAsyncCashNode & rS);
	int    FASTCALL GetLogNumList(PPIDArray & rList) const;
	const  PosIdentEntry * FASTCALL SearchPosIdentEntryByGUID(const S_GUID & rUuid) const;
	const  PosIdentEntry * FASTCALL SearchPosIdentEntryByName(const char * pName) const;

	SString ExpPaths;
	SString ImpFiles;
	SString LogNumList;
	SString AddedMsgSign;    // Описание формы загрузки доп полей товара в кассовый модуль
	TSCollection <PosIdentEntry> ApnCorrList;
};

class PPSyncCashNode : public PPGenCashNode {
public:
	PPSyncCashNode();
	SString & CTblListToString(SString & rBuf) const;
	int    CTblListFromString(const char * pBuf);
	int    SetPropString(int propId, const char * pValue);
	int    GetPropString(int propId, SString & rBuf) const;
	enum {
		btfPinpad = 0x0001
	};
	enum {
		cdfUsb = 0x0001
	};
	//
	// Descr: Параметры фильтрации отложенных чеков в кассовой панели
	//
	struct SuspCheckFilt { // @flat
		SuspCheckFilt();
		bool   IsEmpty() const;
		enum {
			fNotSpFinished = 0x0001
		};
		uint16 DaysPeriod;
		int16  DlvrItemsShowTag; // 0 - показывать не зависимо от статуса доставки, <0 - только без доставки, >0 - только с доставкой
		long   Flags;       // @flags
		uint8  Reserve[28]; //
	};
	char   Port[8];          // Имя порта (LPT1, COM1, ...)
	PPID   DownBill;         //
	LDATE  CurDate;          // Текущая операционная дата
	PPID   CurSessID;        // ->Bill.ID Текущая кассовая сессия //
	PPID   TouchScreenID;    //
	PPID   ExtCashNodeID;    //
	PPID   AlternateRegID;   // Явно обозначенный альтернативный регистратор
		// (if ExtFlags & CASHFX_EXTNODEASALT && !AlternateRegID) то альтернативным регистратором является ExtCashNodeID
	PPID   ScaleID;          //
	PPID   CustDispType;     // Тип дисплея покупателя //
	char   CustDispPort[8];  // Имя порта дисплея покупателя (COM)
	uint16 CustDispFlags;	 // cdfXXX
	int16  EgaisMode;        // Режим работы с УТМ ЕГАИС. 0 - не использовать, 1 - использовать, 2 - тестовый режим, 3 - только сканировать марку
	long   BnkTermType;		 // Тип банковского терминала
	uint16 BnkTermLogNum;	 // Логический номер банковского терминала
	uint16 BnkTermFlags;	 // btfXXX
	char   BnkTermPort[8];	 // Имя порта банковского терминала (COM)
	uint16 ClearCDYTimeout;  // Таймаут очистки дисплея покупателя после печати чека
	uint16 SleepTimeout;     //
	PPID   LocalTouchScrID;  // Локальный (по отношению к компютеру) идентификатор записи PPObjTouchScreen
	// @v11.9.6 (moved to PPGenCashNode) uint16 Speciality;       // PPCashNode::spXXX
	// @v11.9.12 uint16 Reserve;          // @v11.9.6 @alignment
	//
	// Descr: Варианты использования разрешительного режима честный знак
	//
	enum {
		chznpmDontUse = 0,
		chznpmStrict  = 1,
		chznpmSoft    = 2
	};
	int16  ChZnPermissiveMode; // @v11.9.12 Варианты работы с разрешительным режимом честный знак. 0 - не использовать, 1 - строгое использование, 2 - мягкое использование.
	uint16 BonusMaxPart;     // Максимальная часть чека, которая может быть оплачена бонусом
		// Ограничение хранится в промилле. Example: 152 = 15.2% от суммы чека
	PPID   PhnSvcID;         // Телефонный сервис (для обслуживания заказов столов и доставки)
	PPID   ChZnGuaID;        // @v11.9.12 Глобальная учетная запись для доступа к сервису честный знак (работа с разрешительным режимом)
	SuspCheckFilt Scf;       // Фильтр отображения списка отложенных чеков
	SString PrinterPort;     // Для печати напрямую на windows printer
	SString TableSelWhatman; // Имя файла ватмана для выбора стола кафе
	SString BnkTermPath;	 // Путь к промежуточной dll банковского терминала
	SString SlipFmtPath;     // Путь к файлу описания slip-отчетов
	SString ExtString;       // Строка, содержащая конфигурационные строки, которые могут быть извлечены вызовом GetPropString(int, SString &)
	LongArray CTblList;      // Список номеров столов
};

class PPObjCashNode : public PPObjReference {
public:
	struct SelFilt {
		SelFilt();

		enum {
			fSkipPassive  = 0x0001,
			fIgnoreRights = 0x0002 // Игнорировать список доступных кассовых узлов
		};
		PPID   LocID;
		int    SyncGroup;
		int    OnlyGroups; // -1 - кассовые узлы без групп, 0 - все, 1- только группы
		long   Flags;
		PPID   ParentID;
	};

	static int   Lock(PPID);
	static int   Unlock(PPID);
	static int   IsLocked(PPID);
	static int   IsExtCashNode(PPID nodeID, PPID * pParentID);
	//
	// Descr: Вызывает список выбора кассового узла. В списке отображаются узлы
	//   в соответствии со следующими условиями:
	//   1. Если locID != 0, то только те, которые относятся к складу locID
	//   2. Если syncGroup == 1, то выбираются только синхронные узлы
	//   3. Если syncGroup == 2, то выбираются только асинхронные узлы
	//   4. Если syncGroup == 0, то выбор узла не зависит от признака синхронности
	//   5. Узлы, имеющие признак CASHFX_PASSIVE пропускаются //
	//   Если существует только один кассовый узел, соответствующий заданным критериям,
	//   то он возвращается без отображения списка выбора. При этом, если параметр
	//   pSingle != 0, то по этому указателю присваивается 1.
	// ARG(locID     IN): если !0 то узлы фильтруются по принадлежности к складу locID
	// ARG(syncGroup IN): см. выше
	// ARG(pSingle  OUT): @#{vptr0} см.выше
	// ARG(isAny     IN): если этот параметр !0 то функция только проверяет
	//   наличие кассовых узлов, соответствующих заданным критериям.
	// Returns:
	//   0 - если ARG(isAny) == 0, то это означает ошибку, в противном случае -
	//       нет ни одного доступного узла, удовлетворяющего критериям.
	//  -1 - нет кассовых узлов, удовлетворяющих заданным критериям отбора либо
	//       пользователь отказался от выбора.
	//  !0 - если ARG(isAny) == 0, то возвращается ИД вбранного кассовго узла,
	//       в противном случае возвращается количество доступных кассовых узлов.
	//
	static PPID Select(PPID locID, int syncGroup, int * pSingle = 0, int isAny = 0);
	//
	// Descr: Возвращает текст наименования стола с номером ctblN.
	//   Если в справочнике столов ресторанного зала PPOBJ_CAFETABLE есть запись с символом ctblN,
	//   то функция в буфер rBuf заносит наименование этой записи, в противном случае в rBuf
	//   заносится текстовое представление ctblN.
	// ARG(ctblN IN): @#{>0} номер стола
	// ARG(rBuf OUT): буфер, в который заносится наименование стола
	// Returns:
	//   1 - найдена запись PPOBJ_CAFETABLE с символом ctblN
	//   2 - запись PPOBJ_CAFETABLE с символом ctblN не найдена
	//   0 - error (аргумент ctblN <= 0)
	//
	static int  GetCafeTableName(int ctblN, SString & rBuf);
	static const int SubstCTblID; // Специализированный идентификатор стола, применяемый для замещения неопределенного списка столов. =999

	explicit PPObjCashNode(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {Tag, ID, Name, Symb, CashType, ExtQuotID, LocID, Flags }
	//
	int    FASTCALL Fetch(PPID id, PPCashNode * pRec);
	int    GetSync(PPID, PPSyncCashNode *);
	int    GetAsync(PPID, PPAsyncCashNode *);
	int    EditGroup(PPGenCashNode * pData);
	int    EditDistrib(PPGenCashNode * pData);
	int    Get(PPID id, PPGenCashNode * pPack, PPCashNode * pRec = 0);
	int    Put(PPID * pID, PPGenCashNode * pPack, int use_ta);
	bool   Validate(PPGenCashNode * pRec, long);
	//
	// Descr: Возвращает список кассовых узлов, привязанных к складу locID.
	// Note: Функция не очищает массив rList. То есть, если до вызова в массиве были
	//   какие-либо элементы, то они там и остануться после выхода из функции.
	//
	//   Новые элементы в массив добавляются методом LongArray::addUnique по этому
	//   ни одного дубликата функция в массив не добавит (то есть, если их там не было,
	//   то и не появятся).
	//
	//   Функция предполагает, что locID - идентификатор терминального склада, а не
	//   группы складов и тем более не места хранения. То есть, вызывающая функция //
	//   должна позаботиться об этом (см. PPObjLocation::ResolveWarehouseList).
	//
	// ARG(locID  IN): ИД склада для которого ищутся привязанные кассовые узлы.
	// ARG(rList OUT): Массив, в который заносятся кассовые узлы, привязанные к locID.
	// Returns:
	//   >0 - существует по крайней мере один узел, привязанный к locID
	//   <0 - не существует ни одного узла, привязанного к locID
	//   0  - ошибка
	//
	int    GetListByLoc(PPID locID, PPIDArray & rList);
	int    GetListByGroup(PPID grpID, PPIDArray & rList);
	int    ResolveList(const PPIDArray * pSrcList, PPIDArray & rDestList);
	//
	// Descr: Выясняет статус продавца, использующего кассовый узел id как
	//   освобожденного от НДС.
	// Порядок идентификации статуса следующий:
	//    Если id != 0 и склад, ассоциированный с этим узлом имеет признак особожденного от НДС,
	//    то продавец особожден от НДС. В противном случае проверяет признак PSNF_NOVATAX у
	//    персоналии, являющейся текущей главной организацией.
	// Returns:
	//    >0 - продавец освобожден от НДС
	//    <0 - продавец не освобожден от НДС
	//     0 - error
	//
	int    IsVatFree(PPID id);
	//
	// Descr: Выясняет систему налогообложения, действующую на дату dt и соответствующую кассовому узлу cnID и присваивает
	//   ее по указателю pTaxSysID.
	//   Если значение dt инвалидно или ZERODATE, то трактует это как дату равнуют текущей системной дате.
	// Returns:
	//   >0 - система налогообложения идентифицирована
	//   <0 - не удалось идентифицировать систему налогообложения. По указателю pTaxSysID присваивается значение TAXSYSK_GENERAL(1)
	//    0 - error
	//
	int    GetTaxSystem(PPID cnID, LDATE dt, PPID * pTaxSysID);
	int    DiagnoseNode(const PPGenCashNode & rNode, StringSet & rSsResult);
private:
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    EditSync(PPSyncCashNode *);
	int    EditAsync(PPAsyncCashNode *);
	int    Helper_ResolveItem(PPID id, PPIDArray & rDestList, LAssocArray & rFullList); // @recursion
};
//
// @ModuleDecl(PPCashMachine)
//
// Общий интерфейс к высокоуровневым операциям с кассовыми машинами
//
// Будем различать два класса интерфейсов с кассовыми машинами: синхронные и асинхронные.
//   Синхронный интерфейс предусматривает непосредственное подключение
// кассовой машины к компьютеру, на котором работает наша программа.
// Такой интерфейс как минимум должен уметь отпечатать чек и одновременно
// модифицировать фискальную память кассовой машины в соответствии с
// проданным товаром.
//   Асинхронный интерфейс предполагает экспорт справочника товаров
// в кассовую машину перед началом кассовой сессии и импорт результатов
// продаж в конце кассовой сессии.
//   Кассовая машина может одновременно поддерживать и синхронный и
// асинхронный интерфейсы, однако кассовый узел (PPOBJ_CASHNODE)
// может использовать либо то либо другое, не не оба вместе.
//
typedef PPCashMachine * (* RegCashMachineFunc)(PPID cashID);

struct AsyncPosPrepParam {
	AsyncPosPrepParam();
	enum {
		fUpdateOnly = 0x00000001L
	};
	PPID   CashNodeID;
	long   Flags;
};
//
// Descr: Класс, управляющий блокировкой кассового узла
//
class CmLocking {
public:
	explicit CmLocking(const PPCashNode & rNodeRec);
	~CmLocking();
	int    operator !() const;
	int    IsForeignLocking() const;
private:
	enum {
		fError  = 0x0001,
		fLocking        = 0x0002,
		fForeignLocking = 0x0004
	};
	long   Flags;
	const  PPCashNode & R_NodeRec;
};

class PPCashMachine {
public:
	friend class CmLocking;

	static PPCashMachine * CreateInstance(PPID cashID);
	static int RegisterMachine(PPID, RegCashMachineFunc, bool _sync, bool _async);
	static int IsSyncCMT(PPID cmtID);
	static int IsAsyncCMT(PPID cmtID);
	virtual ~PPCashMachine();
	virtual PPSyncCashSession  * SyncInterface() { return 0; }
	virtual PPAsyncCashSession * AsyncInterface() { return 0; }
	//
	// Синхронные методы
	//
	int    SyncOpenSession(LDATE *);
	int    SyncCloseSession();
	int    SyncDiagnose(StringSet * pSs);
	//
	// Descr: Опции отображения панели итогов по кассовой сессии SyncViewSessionStat()
	//
	enum {
		cssoCloseSession = 0x0001, // Закрытие сессии (Z-отчет)
		cssoXReport      = 0x0002  // Пересменка (X-отчет)
		// @#cssoCloseSession^cssoXReport
	};

	int    SyncViewSessionStat(long options);
	int    SyncGetSummator(double *);
	int    SyncGetDeviceTime(LDATETIME * pDtm);
	int    SyncPrintCheck(CCheckPacket * pPack, int addSummator);
	int    SyncPrintCheckCopy(CCheckPacket * pPack, const char * pFormatName);
	int    SyncPrintSlipDocument(CCheckPacket * pPack, const char * pFormatName);
	int    SyncPrintBnkTermReport(const char * pSlipText);
	int    SyncPrintFiscalCorrection(const CcFiscalCorrection * pFc);
	int    SyncPrintXReport();
	int    SyncPrintZReportCopy(const CSessInfo * pInfo);
	int    SyncPrintIncasso();
	int    SyncAllowPrint();
	//
	// Descr: Выполняет препроцессинг марки честный знак для ОФД версии 1.2.
	// Note: Функция фактически используется только для тестовой проверки марки из кассовой панели.
	//   При проведении чеки применяются менее высокоуровневые вызовы.
	//
	int    SyncPreprocessChZnCode(int op, const char * pCode, double qtty, int uomId, uint uomFragm, CCheckPacket::PreprocessChZnCodeResult & rResult);
	int    SyncBrowseCheckList(const char * pCheckPanInitStr, long checkPanFlags);
	int    SyncLockCashKeyb();
	int    SyncUnlockCashKeyb();
	int    SyncOpenBox();
	int    SyncCheckForSessionOver();
	int    GetSlipFormatList(StrAssocArray * pList, int getSlipDocForms);
	//
	//   Функция SyncGetPrintErrCode возвращает код ошибки при печати чека:
	//     0 - error собственно в SyncPrintCheck или при печати на АМС-100Ф
	//     1 - ошибка после печати чека     |
	//     2 - ошибка при печати чека       | для Штрих-ФР-Ф
	//     3 - печать прервана оператором   |
	//
	int    SyncGetPrintErrCode() const { return SyncPrintErrCode; }
	int	   SyncPrintBnkTermReport(long pinpad, const char * pZCheck); // @vmiller
	//
	// Асинхронные методы
	//
	int    AsyncOpenSession(int update, PPID sinceDlsID);
	int    AsyncCloseSession(int asTempSess, DateRange * pPrd);
	static int AsyncCloseSession2(PPID posNodeID, DateRange * pPeriod);
	int    AsyncUpdateSession();
	int    AsyncBrowseCheckList();
	int    AsyncBrowseExcess();
	int    AsyncInteractiveQuery();
	//
	// Общие методы
	//
	bool   IsValid() const;
	const  PPCashNode & GetNodeData() const;
	//
	// Descr: Возвращает ИД текущей кассовой сессии узла NodeID.
	// Note: Для получения этого значения нельзя использовать GetNodeData() по тому,
	//   что при одновременной работе нескольких компьютеров с одним кассовым узлом
	//   возможна ситуация, когда один узел закрыл/открыл сессию, а другой об этом
	//   ни чего не знает.
	//
	PPID   GetCurSessID();
	void   SetParentNode(PPID parentNodeID);
	//
	// Descr: проверяет корректность чека. Если в чеке есть ошибка,
	//   то текст ошибки возвращается в буфере pErrBuf. Если параметр correct != 0,
	//   тогда эта функция пытается исправить чек.
	// Returns:
	//   1 - check is valid
	//   2 - function not supported
	//  -1 - check is invalid (not corrected)
	//  -2 - check is invalid (corrected). Record pRec contains corrected data.
	//   0 - error
	//
	virtual int ValidateCheck(CCheckTbl::Rec * pRec, int correct, char * pErrBuf, size_t errBufLen);
	//
	int    TestPrintCheck(CCheckPacket * pPack);
protected:
	explicit PPCashMachine(PPID cashID);
	int    GetNode();
	int    UpdateNode(int use_ta);

	int    Valid;
	PPID   NodeID;
	PPID   ParentNodeID;
	PPCashNode NodeRec;
private:
	static int GetRegEntry(PPID cmtID, uint * pPos);
	//
	// Descr: Проверяет кассовый узел на синхронность, если он описан в ppdrv.ini
	//
	static int SyncOrAsync(int cashID, int & s); // @vmiller
	int    NewDayDialog(LDATE *);
	int    GetSyncIntrf();
	int    GetAsyncIntrf();
	int    _SyncCloseBill(int ret, int use_ta);
	int    SyncSetPrintErrCode(int retCode, int updateNode);
	static void * P_RegData; // @global @threadsafe
	PPSyncCashSession  * P_SyncIntrf;
	PPAsyncCashSession * P_AsyncIntrf;
	int    SyncPrintErrCode;
};
//
//
//
#define HORZNT_LEFT		0
#define HORZNT_RIGHT	1
#define HORZNT_CENTER	2
#define ALIGN_CURPOS	3 // Горизонтальная табуляция (текущая позиция)
#define VERTAB_CURPOS	2 // Вертикальная табуляция (текущая позиция)
//
// Descr: Базовый класс интерфейса с дисплеем покупателя //
//
class PPCustDisp {
public:
	enum CustDispFlags {
		fcdShowTime      = 0x0001,
		fcd850CodePage   = 0x0002,
		fcdTyssoCodePage = 0x0004,
		fcdUsb   = 0x0005
	};
	static bool IsComPort(const char * pPortName);
	PPCustDisp(int portNo, int dispStrLen, long flags, int usb = 0);
	~PPCustDisp();
	bool   IsError() const { return LOGIC(State & stError); }
	virtual int ClearDisplay();
	virtual int OpenedCash();
	virtual int ClosedCash();
	virtual int SetGoodsName(const char * pName);
	virtual int SetPresent();
	virtual int SetAmt(double price, double qtty);
	virtual int SetDiscount(double percent, double discount);
	virtual int SetTotal(double sum);
	virtual int SetChange(double cash, double change);
protected:
	enum {
		upp,
		down
	};
	enum {
		stError     = 0x0001,
		stConnected = 0x0002
	};
	int    InitPort();
	int    Init(int usb = 0);
	int    PutChar(int c);
	//int    PutString(const char * pStr); // @vmiller comment
	int	   PutString(const char * pStr, int align = ALIGN_LEFT, int verTab = VERTAB_CURPOS); // @vmiller
	int    PutCenteredString(const char * pStr);
	int    SetLine(int lineNo);
	int    ClearLine(int lineNo);
	int    SetCurTime();
	int    OpenOrCloseCash(int open);
	int    GetConfig(); // @vmiller
	int	   ExecOper(int cmd, StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
	int    Port;
	//uint   IsConnected; // @vmiller
	uint   DispStrLen;
	long   Flags; // fcdXXX
	long   State; // stXXX
	char * P_DispBuf;
	SString Words;
	//SCommPort * P_ComPort; // @vmiller comment
	// @vmiller {
	PPAbstractDevice * P_AbstrDvc;
	StrAssocArray Arr_In;
	StrAssocArray Arr_Out;
	// } @vmiller
};

PPCustDisp * GetCustDisp(PPID custDispID, char * pPortName, int usb);

//
// Класс для работы с банковскими терминалами
//
class PPBnkTerminal { // BnkTerm
public:
	PPBnkTerminal(PPID bnkTermId, uint logNum, int port, const char * pPath);
	~PPBnkTerminal();
	int    Pay(double amount, SString & rSlip);
	int    Refund(double amount, SString & rSlip);
	//int    Cancel();
	int    GetSessReport(SString & rZCheck);
	//int    GetErrorMsg(SString & rStr);
	int    IsInited() const;
	int    IsConnected() const;
private:
	//int    Init__(const char * pPath);
	//int    Connect__(int port);
	int    Disconnect();
	int    SetConfig(uint logNum);
	int    Release();
	int    ExecOper(int cmd, StrAssocArray & rIn, StrAssocArray & rOut);

	//int    Inited;
	//int    Connected;
	enum {
		stInited    = 0x0001,
		stConnected = 0x0002
	};
	long   State;
	PPAbstractDevice * P_AbstrDvc;
	StrAssocArray Arr_In;
	StrAssocArray Arr_Out;
};

int GetBnkTerm(PPID bnkTermID, uint logNum, const char * pPort, const char * pPath, PPBnkTerminal ** ppResult);
//
// @ModuleDecl(PPObjLocPrinter)
// Descr: Принтеры, привязанные к складам
//
struct PPLocPrinter2 {     // @persistent @store(Reference2Tbl+)
	PPLocPrinter2();
	enum {
		fHasKitchenBell = 0x0001 // Принтер имеет кухонных звонок. При печати на этот принтер следует отправлять сигнал для подачи звонка.
	};
	long   Tag;            // Const=PPOBJ_LOCPRINTER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[12];    // @reserve
	char   Port[48];       // Имя порта вывода
	long   Flags;          //
	long   LocID;          // ->Location.ID  Склад
	long   Reserve2;       // @reserve
};

class PPObjLocPrinter : public PPObjReference {
public:
	explicit PPObjLocPrinter(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    GetPacket(PPID id, PPLocPrinter * pPack);
	int    PutPacket(PPID * pID, const PPLocPrinter * pPack, int use_ta);
	int    GetPrinterByLocation(PPID locID, SString & rPrnPort, PPLocPrinter * pRec);
	//
	// Descr: Формирует список ассоциация склад-локальный принтер (key - LocID, val - LocPrinterID).
	//   Список функцией предварительно очищается.
	// Note: Каждый склад в списке уникален. То есть, если в справочнике существуют
	//   более одной записи принтера, имеющюх один и тот же склад, то в списко попадет
	//   только запись с наименьшим идентификатором.
	//   Если существует запись без склада (PPLocPrinter::LocID == 0), то она попадет в список.
	// Returns:
	//   >0 - в список добавлена по крайней мере одна запись.
	//   <0 - нет ни одной записи в справочнике.
	//   0  - ошибка.
	//
	int    GetLocPrnAssoc(LAssocArray & rList);
	int    IsPrinter();
};
//
// Флаги бухгалтерских счетов
//
#define ACF_FREEREST        0x0001L // Даже имея субсчета и (или) статьи, счет допускает прямые проводки
#define ACF_HASBRANCH       0x0002L // Счет имеет субсчет(а)
#define ACF_CURRENCY        0x0004L // Валютный счет
#define ACF_FRRL            0x0008L // Флаг блокировки пересчета форвардных остатков
#define ACF_EXCLINNERTRNOVR 0x0010L // Исключать взаимные обороты (для группирующего счета)
#define ACF_SYSNUMBER       0x0020L // Номер счета генерируется системой (только для регистров и группирующих счетов)
//
// Флаги элемента группирующего счета
//
#define ACGF_ACO1GRP        0x0001L // Группировать по счету 1-го порядка
#define ACGF_ACO2GRP        0x0002L // Группировать по счету 2-го порядка !(flags & (ACGF_ACO1GRP | ACGF_ACO2GRP)) - терминальный счет
#define ACGF_NEGATIVE       0x0004L // Изменять знак при суммировании

int FASTCALL GetAcoByGenFlags(long);

#define MINGENACCNUMBER     10000   // Минимальное значение номера группирующего счета
#define MAXGENACCNUMBER     19999   // Максимальное значение номера группирующего счета
//
// Descr: Структура бухгалтерского счета
//
struct PPAccount { // @persistent
	PPAccount();
	long   Tag;         // Const=PPOBJ_ACCOUNT2
	long   ID;          // @id
	char   Name[48];
	char   Code[20];
	uint8  Reserve[20];
	PPID   MainOrgID;
	PPID   CurID;
	PPID   ParentID;
	int16  Type;        // ACY_XXX
	int16  Kind;        // 
	long   Flags;
	LDATE  OpenDate;
	LDATE  Frrl_Date;
	double Limit;
	double Overdraft;
	struct _A_ {
		//
		// Важно: Порядок полей именно такой, поскольку в результате счет 20.2 > 20.1
		//
		int16  Sb;
		int16  Ac;
	} A;
	PPID   AccSheetID;
};
// } @construction

struct PPAccountPacket {
	PPAccountPacket();
	PPAccountPacket & Z();

	PPAccount Rec;
	PPIDArray CurList;
	ObjRestrictArray GenList;   // Список группируемых счетов (для группирующего счета)
};
//
// @ModuleDecl(PPObjAccount)
//
#define ACY_SEL_BAL          ACY_BAL
#define ACY_SEL_OBAL         ACY_OBAL
#define ACY_SEL_REGISTER     ACY_REGISTER
#define ACY_SEL_AGGR         ACY_AGGR
#define ACY_SEL_ALIAS        ACY_ALIAS
#define ACY_SEL_BUDGET       ACY_BUDGET
#define ACY_SEL_BALCUR       -1
#define ACY_SEL_BALOBAL      -2
#define ACY_SEL_BALOBALCUR   -3
#define ACY_SEL_BALOBALALIAS -4
#define ACY_SEL_ALL          -100

class PPObjAccount : public PPObjReference {
public:
	static Reference2Tbl::Key2 & MakeAcctKey(int ac, int sb, Reference2Tbl::Key2 & rKey);
	static int  CheckRecursion(PPID id, PPID parentID);
	static void GenerateCode(PPAccount & rRec);
	explicit PPObjAccount(void * extraPtr = 0);
	~PPObjAccount();
	virtual int  Edit(PPID *, void * extraPtr);
	int    ParseString(const char * pStr, int tok[]);
	int    PutPacket(PPID * pID, PPAccountPacket * pAccPack, int use_ta);
	int    GetPacket(PPID id, PPAccountPacket * pAccPack);
	int    SerializePacket(int dir, PPAccountPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    GetCurList(int ac, int sb, PPIDArray * pAccList, PPIDArray * pCurList);
	int    GetCurList(PPID accID, PPIDArray * pAccList, PPIDArray * pCurList);
	int    GetIntersectCurList(PPID accID_1, PPID accID_2, PPIDArray * pCurList);
	int    GetSubacctList(int ac, int sb, PPID curID, PPIDArray * pList);
	int    HasAnySubacct(int ac);
	int    InitAccSheetForAcctID(AcctID * pAcctId, PPID * pAccSheetID);
	//
	// Для функции Selector дополнительное значение:
	//  ACY_SEL_AGGR         - только группирующие счета
	//  ACY_SEL_REGISTER     - только регистры
	//  ACY_SEL_OBAL         - только забалансовые счета
	//  ACY_SEL_BAL          - только балансовые счета (валютные и невалютные)
	//  ACY_SEL_ALIAS        - только алиасы
	//  ACY_SEL_BALCUR       - только валютные балансовые счета
	//  ACY_SEL_BALOBAL      - балансовые и забалансовые
	//  ACY_SEL_BALOBALCUR   - только валютные балансовые и забалансовые
	//  ACY_SEL_BALOBALALIAS - балансовы, забалансовые счета и алиасы счетов
	//  ACY_SEL_ALL          - все счета
	//  1000L+AccSheetID - балансовые счета с таблицей аналитического учета AccSheetID
	// -------------------------------------------
	// Для функции Browse дополнительные значения:
	//  ACY_AGGR        - только группирующие счета
	//  ACY_REGISTER    - только регистры
	//  ACY_OBAL        - только забалансовые счета
	//  ACY_BAL         - только балансовые счета (валютные и невалютные)
	//  ACY_ALIAS       - только алиасы
	//  0               - все счета
	//
	virtual int  Browse(void * extraPtr);
	virtual void FASTCALL Dirty(PPID id);
	//
	// Descr: Если в функции SearchNum параметр sb == -1, то ищется //
	//   первый субсчет для счета ac
	//
	int    SearchNum(int ac, int sb, PPID curID, PPAccount * = 0);
	int    SearchBase(PPID curAccID, PPID * pBaseAccID, PPAccount * pRec);
	int    SearchCur(PPID accID, PPID curID, PPID * pCurAccID, PPAccount * pRec);
	int    SearchCode(const char * pCode, PPID curID, PPAccount * pRec);
	int    GenerateNumber(PPAccount * pRec);
	int    FASTCALL Fetch(PPID id, PPAccount * pRec);
	int    FetchNum(int ac, int sb, PPID curID, PPAccount * pRec);
	int    GetChildList(PPID acctID, StrAssocArray * pChildList);
	int    GetParentList(PPID acctID, StrAssocArray * pParentList);
	int    BelongTo(PPID acctID, PPID parentID);
	int    GetListByAccSheet(PPID accSheetID, PPIDArray & rList);
	int    LockFRR(PPID accID, LDATE dt, int doUnlock);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    AddCurRecord(const PPAccount * pBaseRec, PPID curID);
public:
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*acySelType*/);
};
//
//
//
class Balance : public BalanceTbl {
public:
	explicit Balance(const char * pFileName = 0);
	int    Turn(PPID bal, LDATE, AccTurnParam * param, int use_ta);
	int    RollbackTurn(PPID bal, LDATE, AccTurnParam * param, int use_ta);
	int    Search(PPID * bal, LDATE *, int spMode);
	int    GetRest(PPID bal, LDATE, double * dbt, double * crd);
	int    GetTurnover(PPID bal, LDATE beg, LDATE end, double * dbt, double * crd);
	//
	// Descr: передает обороты и исходящие остатки по счету
	//   за период [beg..end]. Результаты присваиваются элементам массива row
	//   в следующем порядке: {dbtTurnover, crdTurnover, dbtRest, crdRest}.
	//
	int    GetBalance(PPID bal, LDATE beg, LDATE end, double row[]);
	double _Rest() const;
	double _Rest(int side) const;
	void   _SetRest(int side, double val);
	int    _Turn(PPID bal, LDATE, AccTurnParam * param, uint flags);
};
//
//
//
#define ACRF_FRRL 0x0008L // Флаг блокировки пересчета форвардных остатков

class AcctRel : public AcctRelTbl {
public:
	friend class PPTblEnum <AcctRel>;

	AcctRel();
	int    Search(PPID id, AcctRelTbl::Rec * pRec = 0);
	int    Fetch(PPID id, AcctRelTbl::Rec * pRec);
	//
	// Descr: перебирает записи, соответствующие счету accID и возвращает
	//   каждую найденную запись в буфере pRec.
	//   Счетчиком итераций является указатель на ИД статьи аналитического учета pArID.
	//   Начинать перебор следует со значения *pArID = 0. Если существует сочетание {accID, 0},
	//   то функция вернет его.
	// Returns:
	//   >0 - найдена очередная запись, соответствующая счету accID
	//   <0 - записей, соответствующих сочетанию {accID, *pArID+1 (или больше)} нет
	//   0  - ошибка
	//
	int    EnumByAcc(PPID accID, PPID * pArID, AcctRelTbl::Rec *);
	//
	// Descr: перебирает записи, соответствующие статье arID и возвращает
	//   каждую найденную запись в буфере pRec.
	//   Счетчиком итераций является указатель на ИД счета pAccID.
	//   Начинать перебор следует со значения *pAccID = 0. Если существует сочетание {0, arID},
	//   то функция вернет его.
	// Returns:
	//   >0 - найдена очередная запись, соответствующая статье arID
	//   <0 - записей, соответствующих сочетанию {*pAccID+1 (или больше), arID} нет
	//   0  - ошибка
	//
	int    EnumByArticle(PPID arID, PPID * pAccID, AcctRelTbl::Rec *);
	SEnum::Imp * EnumByAcc(PPID accID);
	SEnum::Imp * EnumByArticle(PPID arID);
	//
	// Заменяет все сочетания {oldAc, oldSb} на {newAc, newSb}
	// @! Без транзакции
	//
	int    ReplaceAcct(int oldAc, int oldSb, int newAc, int newSb);
	int    SearchAcctID(const AcctID * pAcctId, AcctRelTbl::Rec * pRec = 0);
	//
	// Descr: Если параметр closed == -1, то ищет последний закрытый счет с
	//   номером acct. Иначе ищет точное соответствие { closed, acct }
	//
	int    SearchNum(int closed, const Acct * pAcct, PPID curID, AcctRelTbl::Rec * pRec = 0);
	//
	// Так как операции модификации этой таблицы, кроме CloseAcct,
	// не используются самостоятельно, то транзакции здесь не применяются //
	//
	int    OpenAcct(PPID *, const Acct *, PPID curID, const AcctID *, int accKind, int accsLevel = 0);
	int    CloseAcct(PPID, int use_ta);
private:
	SEnum::Imp * Enum(int keyN, PPID keyID);

	PPTblEnumList EnumList;
};
//
//
//
struct RecoverBalanceParam {
	RecoverBalanceParam();
	enum {
		fCorrect = 0x0001
	};
	DateRange Period;
	PPID   BalAccID;
	long   Flags;
	SString LogFileName;
};

struct CurRevalParam {
	CurRevalParam();
	void   Init();
	CurRevalParam & FASTCALL operator = (const CurRevalParam &);
	LDATE  Dt;
	Acct   CorrAcc;
	Acct   NegCorrAcc;
	PPID   LocID;
	long   Flags;
	PPIDArray AccList;
	AmtList   CRateList;
};
//
// @ModuleDecl(AccTurnCore)
//
// Flags of function AccTurnCore::Repair()
//
#define ATRPRF_CHECKBILLLINK   0x0001
#define ATRPRF_CHECKACCLINK    0x0002
#define ATRPRF_REPAIRMIRROR    0x0004
#define ATRPRF_RMVZEROBILLLINK 0x0008
#define ATRPRF_RMVZEROACCLINK  0x0010
//
// Flags of function AccTurnCore::GetBalRest
//
#define BALRESTF_INCOMING        0x0001 // Входящее сальдо
#define BALRESTF_ACO1GROUPING    0x0002 // Группировать по счету первого порядка
#define BALRESTF_SPREADBYSUBACC  0x0004 // Разворачивать по субсчетам (предполагает BALRESTF_GROUPBYACO1)
#define BALRESTF_SPREADBYARTICLE 0x0008 // Разворачивать по субконто
#define BALRESTF_SPREAD          (BALRESTF_SPREADBYSUBACC|BALRESTF_SPREADBYARTICLE)

class AccTurnCore : public AccTurnTbl {
public:
	AccTurnCore();
	int    SearchByBill(PPID, int reverse, short rByBill, void * = 0);
	int    GetAcctCurID(int aco, PPID accID, PPID * pCurID);
	void   GetAccRelIDs(const AccTurnTbl::Rec *, PPID * pDbtRelID, PPID * pCrdRelID) const;
	int    ConvertRec(const AccTurnTbl::Rec *, PPAccTurn *, int useCache);
	int    Turn(PPAccTurn*, int use_ta);
	int    RollbackTurn(PPID, short rByBill, int use_ta);
	int    UpdateAmount(PPID, short rByBill, double newAmt, double cRate, int use_ta);
	int    AcctIDToRel(const AcctID *, PPID * rel);
	int    AcctRelToID(PPID relID, AcctID *, PPID * pAccSheetID);
	int    GetAcctRel(PPID accID, PPID arID, AcctRelTbl::Rec * pRec, int createIfNExists, int use_ta);
	//
	// Descr: возвращает список счетов 2-го порядка (pAccList),
	//   по идентификатору группирующего счета genAccID. С каждым из возвращенных счетов ассоциировано поле флагов
	//   ((pAccList->)::Flags), соответствующих таковому в исходном списке группирующего счета.
	//   В списке pCurList возращается объедининение валют по всем счетам списка pAccList.
	// Returns:
	//   >0 - pAccList->getCount() > 0
	//   <0 - pAccList->getCount() == 0
	//   0  - Error (PPERR_NOMEM, PPERR_SLIB, PPERR_ACCNGEN)
	//
	int    GetExtentAccListByGen(PPID genAccID, ObjRestrictArray *, PPIDArray * pCurList);
	int    GetBaseAcctID(const AcctID & rCurAcctId, AcctID * pBaseAcctId);
	int    ConvertAcct(const Acct *, PPID curID, AcctID *, PPID * pSheetID);
	int    ConvertAcctID(const AcctID & rAci, Acct *, PPID * pCurID, int useCache);
	int    ConvertStr(const char *, PPID curID, Acct *, AcctID *, PPID * pSheetID);
	int    GetAcctRest(LDATE, PPID accrel, double *, int incoming);
	//
	// Descr: Возвращает дебитовый и кредитовый остатки по балансовому счету accID на
	//   дату dt, по указателям pDbt и pCrd.
	//   Параметр flags задает опции расчета сальдо (см. BALRESTF_XXX)
	//
	int    GetBalRest(LDATE, PPID accID, double * pDbt, double * pCrd, uint flags = 0);
	int    EnumByBill(PPID billID, int * rByBill, PPAccTurn *);
	int    CalcRest(int aco, PPID accID, const DateRange *, double * pInRest, double * pOutRest);
	int    CalcComplexRest(long aco, PPID accID, PPID curID, PPID personRelID, const DateRange *, AmtList * pInRest, AmtList * pOutRest);
	int    CalcComplexRestOnGenList(ObjRestrictArray *, PPID curID, const DateRange *, AmtList * pInRest, AmtList * pOutRest);
	//
	// Descr: проверяет и пересчитывает остатки в записях проводок по счету и ид. acc (->AcctRel.ID).
	//   Всякий раз, при обнаружении неверной записи вызывается пользовательская функция MsgProc.
	//   Если эта функция возвращает > 0, то запись исправляется.
	//   Если 0, то не исправляется, если < 0, то RecalcRest завершается без исправления последней записи.
	//   Функция MsgProc не должна обращаться к транзакии.
	//   Если параметр MsgProc == 0, то проверяются и исправляются все проводки.
	//
	int    RecalcRest(PPID accRelID, LDATE startDate, int (*MsgProc)(PPID, LDATE, long, double, void * paramPtr), void * paramPtr, int use_ta);
	int    UpdateAccNum(PPID accID, int newAc, int newSb, int use_ta);
	//
	// Descr: проверяет остатки в таблице Balance по балансовому счету balID за период beg..end.
	//   В зависимости от параметра flags функция может записывать ошибки
	//   в файл balance.err и исправлять найденные ошибки.
	//
	enum {
		chkBalLog     = 0x0001,
		chkBalCorrect = 0x0002
	};
	int    RecalcBalance(const RecoverBalanceParam *, PPLogger &);
	int    RecalcBalance(PPID accID, LDATE startDate, int use_ta);
	int    Repair(long flags, int (*MsgProc)(int msgCode, PPID accID, PPID billID, LDATE dt, long oprno, void * paramPtr), void * paramPtr);
	int    RemoveEmptyAcctRels();
	int    AccBelongToOrd(PPID accID, int ord, const Acct * pAcct, PPID curID, int useCache);
	int    UpdateRelsArRef(PPID arID, long arNo, int use_ta);
	int    NormalyzeAcc(int aco, PPID * pAccID, PPID * pCurID); // @unused
	//
	// Descr: Идентифицирует нормализованный идентификатор счета *pAccID.
	//   Если этот ид скрывает за собой семейство счетов (aco == ACO_1 || curID < 0),
	//   то по указателю pAccList заполняется список соответствующих
	//   идентификаторов счетов. Если результирующий список содержит более одного
	//   элемента, то ид по указателю pAccID остается в нормализованной форме,
	//   если же pAccList->getCount() == 1, то *pAccID = pAccList->at(0).
	//
	int    IdentifyAcc(long * pAco, PPID * pAccID, PPID curID, PPID personRelID, PPIDArray * pAccList);
	int    LockingFRR(int lock, int * pFRRL_Tag, int use_ta);
	bool   IsFRRLocked() const;
	int    RevalCurRests(const CurRevalParam *);
	int    SortGenAccList(ObjRestrictArray *);
	int    ReplaceArticle(PPID dest, PPID src);
	int    SearchAccRef(PPID accID, int removeUnusedRel);
	int    SearchArticleRef(PPID arID, int removeUnusedRel, PPID * pBillID);
private:
	int    SetupAccTurnParam(AccTurnParam * p, int side, int kind);
	int    GetBill(PPAccTurn *);
	int    _OprNo(LDATE, long * oprno);
	int    _RecByBill(PPID billID, short * rByBill);
	int    _UpdateForward(LDATE, long, PPID accRel, const AccTurnParam & rParam);
	int    _Turn(const PPAccTurn * pAt, PPID accRel, PPID corrAccRel, const AccTurnParam & rParam);
	int    _ProcessAcct(int side, PPID curID, const AcctID &, PPID * pAccRelID, AccTurnParam *);
	int    _RollbackTurn(int side, LDATE date, long oprNo, PPID bal, PPID rel, double);
	int    _UpdateTurn(PPID billID, short rByBill, double newAmt, double cRate, int use_ta);
	int    _RecalcBalance(PPID, const RecoverBalanceParam *, PPLogger &);
	int    _CheckBalance(PPID, LDATE, double, double, char *, int correct, PPLogger &, int use_ta);
	int    LockFRR(PPID accRelID, LDATE dt);
	int    RevalCurRest(const CurRevalParam & rParam, const Acct * pAcc, const PPIDArray * pCurList, int use_ta);
	int    UpdateItemInExtGenAccList(PPID objID, long f, PPID accID, ObjRestrictArray *, PPIDArray *);
	int    Helper_Repair(long flags, int reverse, int (*MsgProc)(int msgCode, PPID accID, PPID billID, LDATE dt, long oprno, void * paramPtr), void * paramPtr);

	struct FrrlData {
		int    Counter;
		PPIDArray AccrelIdList;
	};
	TLP_MEMB(FrrlData, Frrl);
public:
	PPObjAccount AccObj;
	ArticleCore Art;
	AcctRel     AccRel;
	Balance     BalTurn;
};
//
// PPSlipFormatter
//
struct SlipLineParam {
	SlipLineParam();
	SlipLineParam & Z();
	//
	// Descr: Флаги
	//
	enum {
		fRegRegular          = 0x0001, // Регистрация на чековой ленте
		fRegJournal          = 0x0002, // Регистрация на контрольной чековой ленте
		fRegFiscal           = 0x0004, // Регистрация в фискальной памяти
		fRegSlip             = 0x0008, // Регистрация на подкладном документе
		fBcTextAbove         = 0x0010, // Текст штрихкода печатать сверху
		fBcTextBelow         = 0x0020, // Текст штрихкода печатать снизу
		fDraftBeerSimplified = 0x0040, // @v11.9.3 Специальная опция, индицирующая то, что в честном знаке разливное пиво фиксируется в упрощенном виде (GTIN+емкость)
	};
	//
	// Descr: Вид данного элемента
	//
	enum {
		lkRegister    = 1, // Регистрация продажи
		lkText        = 2, // Просто текст
		lkPict        = 3, // Изображение
		lkBarcode     = 4, // Штрихкод на элемент чека
		lkSignBarcode = 5  // Подписывающий штрихкод для всего чека
	};
	int    Font;          // для подкладного документа - номер шрифта подкладного документа; для ленты: 1 - обычный шрифт, >1 - широкий шрифт
	int    Kind;          // lkXXX
	int    Flags;         // fXXX
	int    UomId;         // @v11.9.5 Единица измерения SUOM_XXX
	uint   UomFragm;      // @v11.2.6 Фрагментация единицы измерения товара
	double Qtty;          // для regtoFiscal
	double PhQtty;        // @v11.9.3 for chzn (ChZnProductType==GTCHZNPT_DRAFTBEER || GTCHZNPT_DRAFTBEER_AWR)
	double Price;         // для regtoFiscal
	double VatRate;       // для regtoFiscal
	int    PaymTermTag;   // для regtoFiscal CCheckPacket::PaymentTermTag
	int    SbjTermTag;    // для regtoFiscal CCheckPacket::SubjTermTag @erik v10.4.12
	short  DivID;         // для regtoFiscal
	short  FontSize;      // Размер шрифта (для обычного принтера)
	int    BarcodeStd;    // BARCSTD_XXX Стандарт штрихкода
	int    BarcodeWd;     // Ширина штрихкода (в точках)
	int    BarcodeHt;     // Высота штрихкода (в точках)
	int    ChZnProductType; //
	TRect  PictCoord;     // Координаты изображения
	CCheckPacket::PreprocessChZnCodeResult PpChZnR; // @v11.1.11 Результат препроцессинга марки честный знак. Если PpChZnR.LineIdx == 0, то препроцессинга не было.
	SString FontName;     // Наименование гарнитуры шрифта (для обычного принтера)
	SString PictPath;     // Путь к файлу изображения
	SString Text;         // 
	SString Code;         // 
	SString ChZnCode;     // Маркировка товара маркой честный знак
	SString ChZnGTIN;     // 
	SString ChZnSerial;   // 
	SString ChZnPartN;    // Номер партии в марке честный знак
	SString ChZnSid;      // Ид предприятия для передачи в честный знак
	S_GUID ChZnPm_ReqId;  // @v12.1.1 ответ разрешительного режима чзн: уникальный идентификатор запроса
	int64  ChZnPm_ReqTimestamp; // @v12.1.1 ответ разрешительного режима чзн: дата и время формирования запроса
};

struct SlipDocCommonParam {
	SString Title;
	SString DocNumber;
	uint   PageWidth;
	uint   PageLength;
	uint   HeadLines;
	uint   RegTo;         // SlipLineParam::regtoXXX
	uint   TextOutput; // @vmiller
	SString PictPath;
	RECT   PictCoord;
};

class PPSlipFormatter {
public:
	explicit PPSlipFormatter(const char * pFmtFileName);
	 ~PPSlipFormatter();
	int    Init(const char * pFormatName, SlipDocCommonParam * pParam);
	int    InitIteration(const CCheckPacket *);
	int    InitIteration(const PPBillPacket *);
	int    InitIteration(const CSessInfo *);
	int    NextIteration(SString & rBuf, SlipLineParam * pParam);
	int    GetFormList(StrAssocArray * pList, int getSlipDocForms = 0);
private:
	SString SlipFmtPath;
	void * P_SlipFormat;
};
//
// PPSyncCashSession
// Базовый класс интерфейса с синхронными кассовыми сессиями
//
#define CSHCHK_CHECKBAND         0x0001
#define CSHCHK_CTRLBAND          0x0002
#define CSHCHK_WIDE              0x0100
//
// Флаги функции PPSyncCashSession::PrintCheck
//
#define PRNCHK_ADDFISCCNTR       0x0001 // Изменять фискальный счетчик
#define PRNCHK_ADDSESSCNTR       0x0002 // Изменять сменный счетчик
#define PRNCHK_NODISPLAY         0x0004 // Подавить вывод на дисплей ККМ
#define PRNCHK_REPRINT           0x0008 // Перепечатка последнего чека
#define PRNCHK_OPENBOX           0x0010 // Открыть денежный ящик
#define PRNCHK_RETURN            0x0020 // Чек возврата
#define PRNCHK_LASTCHKANNUL      0x0040 // Перед печатью аннулировать последний чек
#define PRNCHK_BANKING           0x0080 // Чек оплачен банковской кредитной картой
#define PRNCHK_ROUNDINT          0x0100 // %% скидку в чеке округлять до целого
//
// Коды возврата функции PPSyncCashSession::GetPrintErrCode()
//
#define SYNCPRN_NO_ERROR              0 // OK
#define SYNCPRN_ERROR_AFTER_PRINT     1 // Сбой после печати чека
#define SYNCPRN_ERROR                 2 // Сбой
#define SYNCPRN_ERROR_WHILE_PRINT     3 // Сбой во время печати чека
#define SYNCPRN_CANCEL                4 // Отмена до начала печати чека
#define SYNCPRN_CANCEL_WHILE_PRINT    5 // Отмена во время печати чека

class PPSyncCashSession {
public:
	//
	// Descr: Утилитная функция, возвращающая в буфере rBuf имя текущего пользователя.
	//   Функция стереотипно применяется для получения имени кассира.
	//   Имя возвращается в INNER-кодировке.
	// Returns:
	//   true - функции удалось получить имя текущего пользователя //
	//   false - попытка получить результат оказалась безуспешной. В общем случае, это - почти аварийная //
	///    ситуация: если сеанс авторизован, то у него есть пользователь, имеющий не пустой имя.
	//
	static bool GetCurrentUserName(SString & rBuf);
	//
	// Descr: Выясняет следует ли товар goodsID учитывать в контексте честного знака как
	//   разливное пиво, списываемое по упрощенной схеме (суррогатная марка, состоящая из GTIN и количества).
	//   Для такого товара, кроме прочего, не осуществляется предварительная проверка марки для ОФД 1.2.
	//
	static bool IsSimplifiedDraftBeerPosition(PPID posNodeID, PPID goodsID);
	//
	// Descr: Выясняет следует ли товар goodsID учитывать в контексте честного знака как
	//   разливное пиво, списываемое в автоматическом режиме. Такой режим подразумевает
	//   идентификацию кега, из которого разлито пиво по структуре товара goodsID и автоматический выбор
	//   того кега, для которого не все пиво израсходовано (по маркам в кассовых чеках)
	//
	static bool IsAutoWriteOffDraftBeerPosition(PPID posNodeID, PPID goodsID);

	PPSyncCashSession(PPID cnID, const char * pName, const char * pPort);
	virtual ~PPSyncCashSession();
	int    Init(const char * pName, const char * pPort);
	int    IsError() const;
	/*
		int    CheckResult;      // tag 2106 Результат проверки КМ в ФН (ofdtag-2106)
		int    Reason;           // Причина того, что КМ не проверен в ФН
		int    ProcessingResult; // tag 2005 Результаты обработки запроса (ofdtag-2005)
		int    ProcessingCode;   // tag 2105 Код обработки запроса (ofdtag-2105)
		int    Status;           // tag 2109 Сведения о статусе товара (ofdtag-2109)
	*/
	static void LogPreprocessChZnCodeResult(int ret, int op, const char * pCode, double qtty, const CCheckPacket::PreprocessChZnCodeResult & rResult);

	enum {
		ppchzcopCheck           =   0, // проверка марки
		ppchzcopAccept          =   1, // акцепт марки. должна быть вызвана непосредственно после вызова PreprocessChZnCode(0, ...)
		ppchzcopReject          =   2, // отказ от акцепта марки. должна быть вызвана непосредственно после вызова PreprocessChZnCode(0, ...)
		ppchzcopInit            = 100, // предварительные операции перед проверкой марок по чеку. Может быть актуально для некоторых типов регистраторов
		ppchzcopSurrogateCheck  = 101, // фиктивная проверка марки в специальных случаях (draftbeer horeca) // @v11.9.4
		ppchzcopSurrogateAccept = 102, // фиктивный акцепт марки в специальных случаях (draftbeer horeca) // @v11.9.4
		ppchzcopCancel          = 103, // @v12.0.4 Функция отмены после проверки марок. Применяется в паре с ppchzcopInit если операция инициализации
			// провела какие-то действия, которые требуется отменить в случае, если чек не проводится.
			// Фактически, эта операция введена ради аппарата Штрих-ФР из-за того, что проверку марок он осущетсвляет только в режиме открытого чека.
	};
	//
	// Descr: Функция реализует препроцессинг кодов маркировки товаров в соответствии с российскими правилами ОФД 1.2
	// ARG(op IN):
	//   0 - проверка марки
	//   1 - акцепт марки. должна быть вызвана непосредственно после вызова PreprocessChZnCode(0, ...)
	//   2 - отказ от акцепта марки. должна быть вызвана непосредственно после вызова PreprocessChZnCode(0, ...)
	//   100 - предварительные операции перед проверкой марок по чеку. Может быть актуально для некоторых типов регистраторов.
	//   101 - фиктивная проверка марки в специальных случаях (draftbeer horeca) // @v11.9.4
	//   102 - фиктивный акцепт марки в специальных случаях (draftbeer horeca) // @v11.9.4
	// Returns:
	//  <0 - функция не поддерживается либо pCode не является валидным кодом честный знак
	//  >0 - функция выполнена (не обязательно успешно - это определяется результатом rResult)
	//   0 - error при выполнении запроса
	//
	virtual int    PreprocessChZnCode(int op, const char * pCode, double qtty, int uomId, uint uomFragm, CCheckPacket::PreprocessChZnCodeResult & rResult) { return -1; }
	//
	// Функции кассового аппарата уровня приложения //
	//
	//
	// Descr: печатает документ pack на принтере ККМ, выводит сообщение
	//   на дисплей ККМ (если на noDisplay) и, если установлены соответствующие флаги,
	//   обновляет счетчики ККМ. Если pPack == 0, то выводится пустой чек.
	//
	virtual int PrintCheck(CCheckPacket * pPack, uint flags) { return -1; }
	virtual int PrintFiscalCorrection(const CcFiscalCorrection * pFc) { return -1; }
	virtual int PrintCheckCopy(const CCheckPacket * pPack, const char * pFormatName, uint flags) { return -1; }
	virtual int PrintSlipDoc(const CCheckPacket * pPack, const char * pFormatName, uint flags) { return -1; }
	virtual int PrintXReport(const CSessInfo *) { return -1; }
	virtual int PrintZReportCopy(const CSessInfo *) { return -1; }
	virtual int PrintIncasso(double sum, bool isIncome) { return -1; }
	virtual int GetDeviceTime(LDATETIME * pDtm) { ASSIGN_PTR(pDtm, ZERODATETIME); return -1; }
	virtual int GetSummator(double * val) { return -1; }
	virtual int EnableCashKeyb(int) { return -1; }
	virtual int OpenSession_(PPID sessID) { return -1; } // @v11.3.12
	virtual int CloseSession(PPID sessID) { return -1; }
	virtual int GetPrintErrCode() { return 0; }
	virtual int OpenBox() { return -1; }
	virtual int CheckForSessionOver() { return -1; }
	virtual int PrintBnkTermReport(const char * pZCheck) { return -1; }
	//
	// Descr: Редактирование особых параметров устройства
	//   На данный момент эта функция используется в универсальном драйвере АТОЛ
	//   для редактирования и выбора кассы
	//
	virtual int EditParam(void *) { return -1; }
	//
	// Descr: Выполняет диагностику оборудования и возвращает результат в виде
	//   набора строк pSs.
	// Returns:
	//   >0 - диагностика выполнена (даже если есть проблемы с оборудованием)
	//   <0 - функция не поддерживается
	//   0  - ошибка (на уровне самой функции, но не ошибка в работе оборудования)
	//
	virtual int Diagnostics(StringSet * pSs) { return -1; }
	const  char * GetName() const { return Name; }
	PPSlipFormatter * GetSlipFormatter() { return P_SlipFmt; }
	int    CompleteSession(PPID sessID);
	//
	// Descr: Параметры, необходимые для правильной печати чека с ёбнутыми обвесами для российской офд и честного знака
	//
	struct OfdFactors {
		OfdFactors();
		OfdFactors & Z();
		// 
		// Descr: Возвращает true если версия офд для этого кассового узла больше или равна 1.2
		//
		bool   IsOfdVerGe12() const; 
		//SString OfdVer;
		SVerT  OfdVer_;
		PPID   ChZnGuaID; // @v11.9.12 Идентификатор глобальной учетной записи для работы с честным знаком
		int16  ChZnPermissiveMode; // @v11.9.12
		uint16 Reserve; // @v11.9.12 @alignment
		SString Sid;
	};
	void    GetOfdFactors(OfdFactors & rP);
	//
	// Descr: Высокоуровневая функция, реализующая предварительную обработку пакета чека
	//   с марками честный знак перед проведением чека через фискальный регистратор.
	//
	int     PreprocessCCheckForOfd12(const OfdFactors & rOfdf, CCheckPacket * pPack);
	const PPSyncCashNode & GetPosNode() const { return SCn; } // @v11.9.12
protected:
	//
	// Descr: Функция формирования json чека в формате atol-driver. Вынес эту функцию
	//   из класса SCS_ATOLDRV в целях тестирования.
	//
	SJson * AtolDrv_MakeJson_CCheck(const OfdFactors & rOfdf, const CCheckPacket * pPack, PPSlipFormatter * pSf, uint flags);
	enum {
		stError = 0x0001
	};
	PPID   NodeID;
	char   Port[128]; //
	char   Name[48];  //
	int    PortType;  // 0 - file, 1 - lpt, 2 - com, 3 - server /*@v12.0.3*/
	int    Handle;    //
	long   State;
	PPSlipFormatter * P_SlipFmt;
	PPObjCashNode CnObj;
	PPSyncCashNode SCn;
};
//
// Флаги PPAsyncCashSession
//
#define PPACSF_TEMPSESS         0x0001L // Временная сессия //
#define PPACSF_LOADRESTWOSALES  0x0002L // Загружать остатки без учета продаж (для Атола)
//
// Descr: Базовый класс интерфейса с асинхронными кассовыми сессиями
//
class PPAsyncCashSession : public CSessGrouping {
public:
	explicit PPAsyncCashSession(PPID cashNodeID);
	virtual ~PPAsyncCashSession();
	int    OpenSession(int updOnly, PPID sinceDlsID);
	int    CloseSession(int asTempSess = 0, DateRange * pPrd = 0);
	PPID   GetLocation();
	enum {
		dfactCopy   = 0, // скопировать файл pFileName в каждый из каталогов экспорта
		dfactDelete = 1, // удалить файлы с именем, заданным параметром pFileName
		dfactCheckExistence = 2, // проверить наличие файла с именем, заданным параметром pFileName
		dfactCheckDestPaths = 3  // проверить доступность каталогов назначения на запись
	};
	//
	// Descr: производит действие, определяемое параметром action над файлом, определенным параметром //
	//   pFileName относительно набора каталогов экспорта, заданного полем PPAsyncCashNode::P_ExpPaths.
	//   Возможные действия (action):
	//     dfactCopy - скопировать файл pFileName в каждый из каталогов экспорта
	//         Если аргумент pEndFileName не пустой, то имя файла заменяется на значение этого аргумента
	//         @!Код возвращаемый функцией копирования не проверяется.
	//     dfactDelete - удалить файлы с именем, заданным параметром pFileName (путь, входящий в эту строку
	//         игнорируется) в каталогах экспорта
	//         @!Успешность удаления не проверяется.
	//     dfactCheckExistence - проверить наличие файла с именем, заданным параметром pFileName (путь, входящий в эту строку
	//         игнорируется) в каталогах экспорта.
	//     dfactCheckDestPaths - проверить доступность каталогов назначения на запись (параметр pFileName игнорируется).
	//         Функция пытается создать временный файл в каждом из каталогов назначения. Если попытка прошла
	//         успешно, то файл сразу удаляется.
	//
	//     pSubDir    - Вместо папки назначения будет использован следующий путь: диск назначения:\pSubDir
	//     pEmailSubj - Тема письма для отправки файла через email, если путь указан как почтовый адрес
	//
	// Returns:
	//   0 - неверный параметр action или не удалось получить значение каталогов экспорта из
	//       записи кассового узла.
	//   For action == 0:
	//     1  - каталоги экспорта определены и предпринята попытка скопировать заданный файл в
	//          эти каталоги.
	//     -1 - в кассовом узле не задано ни одного каталога экспорта
	//   For action == 1:
	//     1  - каталоги экспорта определены и предпринята попытка удалить файл с заданным именем
	//          из этих каталогов.
	//     -1 - в кассовом узле не задано ни одного каталога экспорта
	//   For action == 2:
	//     1  - по крайней мере в одном из каталогов экспорта существует файл с заданным именем
	//     -1 - ни в одном из каталогов экспорта файла с заданным именем нет.
	//   For action == 3:
	//     1 - все каталоги доступны для записи
	//     0 - как минимум один из каталогов не доступен для записи
	//
	int    DistributeFile_(const char * pFileName, const char * pEndFileName, int action, const char * pSubDir /*= 0*/, const char * pEmailSubj /*= 0*/);
	//
	// Descr: Если поддерживаются запросы к кассовому узлу, то эта функция
	//   должна отправить серверу узла запрос (возможно в интерактивном режиме).
	// Note: Не предполагается, что функция должна дождаться ответа на запрос (но и не возбраняется).
	// Returns:
	//   >0 - запрос был отправлен
	//   <0 - функция не поддерживается либо пользователь отказался от функции
	//   0  - ошибка
	//
	virtual int InteractiveQuery();
	//
	// Descr: Вызывается после завершения процедуры закрытия сессии(й).
	//   Может быть использована для удаления файлов источника, каких-либо подтверждающих действия и т.д.
	//   Если сессии закрываются по группе кассовых узлов, то функция вызывается после того, как
	//   для всех членов группы процедура закрытия будет выполнена.
	//
	//   Первичной мотивацией для ввода функции явилась необходимость удалять исходные файлы только
	//   после того, как все члены группы кассовых узлов извлекут от туда данные (если некоторые члены
	//   группы испольузют один и тот же источник).
	//
	virtual void CleanUpSession();
protected:
	//
	// Descr: должна сформировать файлы, необходимые для загрузки кассовых аппаратов.
	// ARG(mode IN):
	//   0 - полная загрузка данных
	//   1 - загрузка изменений. Если SinceDlsID != 0, то экспортируются изменения начиная с момента SinceDlsID
	//   2 - повторная загрузка данных, экспортированных начиная с SinceDlsID
	//
	virtual int ExportData(int updOnly) = 0;
	//
	// Descr: должна инициализировать информацию о
	//   подлежащих импорту кассовых сессиях и вернуть вызывающей функции
	//   количество импортируемых сессий и признак являются ли эти сессии
	//   форвардными или нет.
	//
	//   Форвардные сессии отличаются от нефорвардных
	//   тем, что на момент пробития чека и занесения его в файл неизвестно,
	//   к сессии с каким номером он относится. То есть, чек форвардной сессии
	//   не несет информации о принадлежности к какой-либо сессии.
	//
	virtual int GetSessionData(int * pSessCount, int * pIsForwardSess, DateRange * pPrd = 0) = 0;
	//
	// Descr: должна конвертировать файлы кассовой сессии с
	//   индексом sessionNo в таблицы временной сессии (P_TmpCcTbl и P_TmpCclTbl).
	//
	virtual int ImportSession(int sessionNo) = 0;
	//
	// Descr: вызывается после конвертации всех сессий отмеченных функцией GetSessionData.
	//   Здесь должны быть произведены завершающие операции по импорту сессий. Функция может
	//   добавить в список закрываемых сессий элементы, используя метод PPIDArray::addUnique
	//
	virtual int FinishImportSession(PPIDArray * pSessList);
	//
	// Descr: вызывается перед вызовом PPAsyncCashSession::ExportData для определения //
	//   возможности кассовой машины принять данные из Papyrus'а.
	//   Если функция вернула 0, то ExportData вызвана не будет.
	//   Если (PPEquipConfig::Flags & fIgnAcsReadyTags), то функция OpenSession
	//   игнорирует результат вызова этой функции (но в любом случае вызывает ее).
	// Returns:
	//   >0 - кассовая машина готова принять данные (ExportData() вызывается)
	//   0  - кассовая машина не готова принять данные (ExportData() не вызывается)
	//   <0 - функция не поддерживается данной реализацией (ExportData() вызывается)
	//
	virtual int IsReadyForExport(); // @<<PPAsyncCashSession::OpenSession
	virtual int SetGoodsRestLoadFlag(int updOnly);
	int    CreateTables();
	void   DestroyTables();
	int    IsCheckExistence(PPID cashID, long code, const LDATETIME * pDT, PPID * pTempReplaceID);
	int    SearchTempCheckByCode(PPID cashID, PPID code, PPID sessNo = -1L);
	int    SearchTempCheckByTime(PPID cashID, const LDATETIME *);
	int    AddTempCheck(PPID * pID, long sessNumber, long flags /* CCHKF_XXX */, PPID cash, PPID code, PPID user, PPID cardID, const LDATETIME & rDtm, double amt, double dscnt);
	int    AddTempCheckAmounts(PPID checkID, double amt, double dis);
	int    AddTempCheckPaym(long checkID, int paymType, double amount, long scardID);
	int    UpdateTempCheckFlags(long checkID, long flags);
	int    SetTempCheckAmounts(PPID checkID, double amt, double dis);
	int    AddTempCheckSCardID(PPID checkID, PPID scardID);
	int    AddTempCheckGiftCardID(PPID checkID, PPID giftCardID);
	void   SetupTempCcLineRec(TempCCheckLineTbl::Rec * pRec, long ccID, long ccCode, LDATE dt, int div, PPID goodsID);
	int    SetTempCcLineValuesAndInsert(TempCCheckLineTbl * pTbl, double qtty, double price, double discount, PPExtStrContainer * pLnExtStrings);
	int    GetExpPathSet(StringSet *);
	bool   FASTCALL CheckCnFlag(long);
	bool   FASTCALL CheckCnExtFlag(long);
	int    GetNodeData(PPAsyncCashNode *);
	void   FASTCALL AdjustSCardCode(char * pCode);
	//
	// Descr: Добавляет контрольную цифру в конец штрихкода при следующих условиях:
	// 1. В кассовом узле установлен флаг CASHF_EXPCHECKD
	// 2. Штрихкоды базе данных указаны без контрольных цифр (флаг GCF_BCCHKDIG в конфигурации
	//    справочника товаров не установлен)
	// 3. Длина кода превышает три символа
	// 4. Префикс штрихкода отличен от префикса весового штрихкода
	//
	int    FASTCALL AddCheckDigToBarcode(char * pBarcode);
	const  PPGoodsConfig & GetGoodsCfg();
	//
	// Descr: заносит в журнал ppinfo.log строку с информацией об экспортируемом товаре,
	//   которую извлекает из структуры pInfo.
	// ARG(pInfo IN): @#{vptr0} указатель на структуру AsyncCashGoodsInfo, используемую
	//   порожденными классами для экспорта справочника товаров в асинхронный кассовый узел.
	//
	int    LogExportingGoodsItem(const AsyncCashGoodsInfo * pInfo);
	//
	// Descr: Заносит в журнал debug.log строку pMsg.
	//   Функция отрабатывает только в том случае, если установлен флаг CConfig.Flags & CCFLG_DEBUG.
	//
	int    LogDebug(const char * pMsg);

	PPID   NodeID;
	long   Flags;      // PPACSF_XXX
	PPID   SinceDlsID; // Ид записи статистики загрузки, начиная (включая) с которой следует выгрузить изменения //
	// Temp Session {
	TempCCheckTbl * P_TmpCcTbl;
	TempCCheckLineTbl * P_TmpCclTbl;
	CCheckPaymTbl * P_TmpCpTbl;
	// }
	DeviceLoadingStat * P_Dls;
private:
	int    GetLastSess(long cashNumber, LDATETIME dtm, long * pSessNumber, PPID * pSessID);
	int    SetLastSess(long cashNumber, long sessNumber, PPID sessID, LDATETIME dtm);
	int    GetCashSessID(LDATETIME dtm, long cashNumber, long sessNumber, int forwardSess, int temporary, PPID * pSessID);
	int    CalcSessionTotal(PPID sessID, CSessTotal *);
	int    ConvertTempSession(int forwardSess, PPIDArray & rSessList, void * pTotalLogData);
	int    FlashTempCcLines(const SVector *, LAssocArray * pHasExLineList);

	DateRange SurveyPeriod; // Период, в который попадают закрываемые сессии
	long   CnFlags;     // Флаги узла PPCashNode(NodeID) если ~0, то не инициализированы
	long   CnExtFlags;  // Расширенные флаги узла PPCashNode(NodeID) если ~0, то не инициализированы
	PPGoodsConfig * P_GCfg;

	struct LastSess {
		long  CashNumber;
		long  SessNumber;
		PPID  SessID;
		LDATETIME Dtm;
	};
	SArray * P_LastSessList;
	PPIDArray SessList;
	SString LogFmt_ExpGoods; // @used LogExportingGoodsItem()
};
//
// Descr: Общий базовый класс для некоторых асинхронных кассовых аппаратов,
//   работающих через DBF-таблицы.
//
class CS_1 : public PPAsyncCashSession {
public:
	CS_1(PPID);
	~CS_1();
	virtual int ExportData(int) = 0;
	virtual int GetSessionData(int * pSessCount, int * pIsForwardSess, DateRange * pPrd = 0) = 0;
	virtual int ImportSession(int) = 0;
protected:
	int    GetFileSet(char * pSectName, uint filesPerSet);
	DbfTable   * OpenDBFTable(uint num, uint fn);
	BarcodeTbl * CreateTmpBarToID(int, int fn, int fldGoodsID, int fldBarCode, int fldUnitPerPack);
	int    ConvertCashList(int);
	int    ConvertWareList(int);

	int    Valid;
	uint   FilesPerSet;
	uint   NumEntries;
	struct InFiles {
		char fn[5][MAX_PATH];
	} * P_Entries;
};
//
// Макросы для регистрации кассового аппарата
//
#define REGISTER_CMT(nm,sync,async) \
	static PPCashMachine * Create_##nm(PPID cashID) { return /*(PPCashMachine*)*/new CM_##nm(cashID); } \
	struct Registrar_##nm { Registrar_##nm(); }; \
	void _Register_##nm() { PPCashMachine::RegisterMachine(PPCMT_##nm, Create_##nm, sync, async); } \
	Registrar_##nm::Registrar_##nm() { _Register_##nm(); }
//
// @ModuleDecl(PPObjBarcodePrinter)
// Принтеры штрихкодов
//
struct PPBarcodePrinter2 { // @persistent @store(Reference2Tbl+)
	PPBarcodePrinter2();
	void   Normalyze();

	enum {
		fPortEx = 0x0001 // Запись использует расширенное поле имени порта вывода
	};
	PPID   Tag;            // Const=PPOBJ_BCODEPRINTER
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   LabelName[20];  //
	char   Reserve[28];    // @reserve
	int16  BcNarrowPt;     // Толщина узких полос штрихкода (точек)
	int16  BcWidePt;       // Толщина широких полос штрихкода (точек)
	char   Port[20];       //
	CommPortParams Cpp;    // Size=6
	int16  Cp;             // Кодовая страница при выводе текста
	long   Flags;          //
	PPID   PrinterType;    // PPBCPT_ZEBRA | PPBCPT_DATAMAX
	long   Reserve3;       // @reserve
	//
	SString PortEx;        // @persistent @store(PropertyTbl[PPOBJ_BCODEPRINTER, id, BCPPRP_PORTEX]) @anchor
};

class PPObjBarcodePrinter : public PPObjReference {
public:
	PPObjBarcodePrinter(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    GetPacket(PPID id, PPBarcodePrinter * pPack);
	int    PutPacket(PPID * pID, const PPBarcodePrinter * pPack, int use_ta);
};
//
// Descr: Интерфейс для работы с принтерами штрихкодов
//
class BarcodeLabelPrinter {
public:
	struct BarcodeLabelPrintParam {
		BarcodeLabelPrintParam();
		enum {
			fPrintAll    = 0x0001, // Печать всей выборки
			fQttyAsPack  = 0x0002, // Количество этикеток по каждой строке документа
				// рассчитывается как количество упаковок (в противном случае - количество торговых единиц)
			fInteractive = 0x0004  // Выводить дополнительный диалог перед печатью (для Windows-принтеров)
		};
		PPID   PrinterID;
		int16  NumCopies;
		int16  Pad;       // @alignment
		PPID   LocID;     // Склад, для которого печатается этикетка (от этого зависит цена и, возможно, ряд других параметров)
		long   Flags;     // @flags
		SString Port;     //
	};
	static BarcodeLabelPrinter * CreateInstance(/*PPID printerTypeID*/const PPBarcodePrinter & rPrnPack);
	static int PrintGoodsLabel(PPID goodsID);
	//
	// Descr: Печатает на принтер этикетку по данным, определенным параметром pRgi.
	//   Если параметр silent == 0, то предварительно выдает диалог, в котором пользователь
	//   может выбрать принтер, порт вывода и др параметры печати. Если silent != 0, то
	//   диалог не выдается, а печать реализуется по тем параметрам, которые заданы в
	//   характеристиках принтера prnID.
	//   Если silent != 0, то в случае возникновения ошибки, функция этого сообщения на
	//   экран не выводит.
	// Returns:
	//   >0 - этикетка успешно отпечатана
	//   <0 - пользователь отказался от печати
	//   0  - ошибка
	//
	static int PrintGoodsLabel__(RetailGoodsInfo * pRgi, PPID prnID /*= 0*/, int silent /*= 0*/);
	static int PrintGoodsLabel2(RetailGoodsInfo * pRgi, PPID prnID /*= 0*/, int silent /*= 0*/);
	static int PrintLotLabel(PPID lotID);
		// @>>BarcodeLabelPrinter::PrintGoodsLabel
	static int PrintLabelByBill__(const PPBillPacket * pPack, uint pos);
	static int PrintLabelByBill2(const PPBillPacket * pPack, uint pos);
	static int UpLoad(PPID prnID, const char * pLoadName, int silent);
	static int LoadFonts(PPID prnID, int silent);

	BarcodeLabelPrinter(const PPBarcodePrinter & rPrnPack);
	virtual ~BarcodeLabelPrinter();
	virtual int StartLabel(const BarcodeLabelParam *, int numCopies) = 0;
	virtual int EndLabel() = 0;
	virtual int PutDataEntry(const BarcodeLabelEntry *) = 0;
	virtual int PrintLabel(const char * pPortName, const CommPortParams *);
	int    PrintLabelUsb(PPID devType); // @vmiller
protected:
	static int GetLabelFileName(PPIniFile & rIniFile, SString & rBuf);
	int    FASTCALL PutStr(const char *);
	int    FASTCALL PutChr(char);
	int    PutInt(int, int numDigits);

	PPBarcodePrinter PrnPack;
private:
	int    Helper_PrintRgiCollection(const BarcodeLabelPrintParam & rBclpp, TSCollection <RetailGoodsInfo> & rList);

	SBuffer Buf;
};
//
// @ModuleDecl(PPObjStyloPalm)
//
#define PLMF_IMPASCHECKS        0x00000001 // Документы с устройства можно импортировать как чеки.
	// Этот флаг не исключает возможности принимать документы с устройства и как обычные документы.
#define PLMF_GENERIC            0x00000002 // Обобщенная запись, определяющая конфигурацию для нескольких устройств
#define PLMF_EXPCLIDEBT         0x00000004 // Экспортировать долги по клиентам
#define PLMF_EXPSELL            0x00000008 // Экспортировать продажи
#define PLMF_EXPBRAND           0x00000010 // Экспортировать бренды и владельцев брендов
#define PLMF_INHFLAGS           0x00000020 // Все флаги (кроме этого, конечно) наследуются от родительской группы
#define PLMF_EXPLOC             0x00000040 // Экспортировать склады
#define PLMF_EXPSTOPFLAG        0x00000080 // Экспортировать признак 'стоп' для клиентов
#define PLMF_ANDROID            0x00000100 // КПК на базе google android. Экспорт/импорт в виде xml файла
#define PLMF_EXPIMAGES          0x00000200 // Экспортировать картинки
#define PLMF_PALMLINKED         0x00000400 // Данная учетная запись связана с КПК (только для Андроид)
#define PLMF_DISABLCEDISCOUNT   0x00000800 // Запрет на установку общей скидки по заказу
#define PLMF_REGISTERED         0x00001000 // Признак состоявшейся централизованной регистрации устройса. Если установлен, то последующая регистрация не возможна
#define PLMF_BLOCKED            0x00002000 // Признак блокированного (украденного) устройства
#define PLMF_TREATDUEDATEASDATE 0x00004000 // При импорте заказов трактовать дату исполнения заказа как основную дату документа
#define PLMF_EXPZSTOCK          0x00008000 // @v11.4.3 Экспортировать товары с нулевым остатком 
#define PLMF_EXPGOODSEXPIRYTAGS 0x00010000 // @v11.6.2 (Stylo-Q) Экспортировать атрибуты сроков годности товаров (самая ранняя expiry-дата). 
#define PLMF_INHMASK          (PLMF_IMPASCHECKS|PLMF_EXPCLIDEBT|PLMF_EXPSELL|PLMF_EXPBRAND|PLMF_EXPLOC|PLMF_EXPSTOPFLAG|PLMF_DISABLCEDISCOUNT|PLMF_TREATDUEDATEASDATE|PLMF_EXPZSTOCK|PLMF_EXPGOODSEXPIRYTAGS)
#define PLMF_TRANSMITMASK     (PLMF_DISABLCEDISCOUNT) // Флаги, которые передаются на устройство полем StyloFlags
//
// Descr: Флаги режима отслеживания гео-позиции устройства
//
#define GTMF_AUTO             0x0001 // Автоматически через заданные промежутки времени
#define GTMF_CHECKIN          0x0002 // Ручная регистрация местоположения
#define GTMF_EVNT_BILL        0x0004 // По событию создания документа
#define GTMF_FORCEGPSON       0x0008 // По возможности форсированно включать геолокацию на устройстве

struct PPGeoTrackingMode { // @persistent @size==8
	PPGeoTrackingMode();
	PPGeoTrackingMode & Z();
	bool   FASTCALL operator == (const PPGeoTrackingMode & rS) const;
	bool   FASTCALL operator != (const PPGeoTrackingMode & rS) const;

	int32  Mode;  // @flags GTMF_XXX
	int32  Cycle; // Периодичность автоматической регистрации положения устройства (ms)
};

struct PPStyloPalm2 {          // @persistent @store(Reference2Tbl+)
	//
	// Descr: Опции выбора вида котировки на устройстве
	//
	enum {
		qkoNone   = 0, // Не ассоциировать вид котировки с документов
		qkoAuto   = 1, // Автомитически выбирать вид котировки (по данным клиента)
		qkoManual = 2  // Разрешать выбирать вид котировки вручную
	};
	PPID   Tag;                // Const=PPOBJ_STYLOPALM
	PPID   ID;                 // @id
	char   Name[48];           // @name @!refname
	char   Symb[20];           //
	int32  MaxUnsentOrders;  // Максимальное кол-во неотправленных заявок. При достижении этого числа, блокируется создание новой заявки.
	LDATETIME RegisterTime;    // Время регистрации (для централизованной регистрации устройств)
	LDATETIME LastExchgTime;   // Время последнего обмена данными
	uint32 DeviceVer;          // Версия системы на устройсве, считанная при последнем обмене
  	int16  TransfDaysAgo;      // Количество дней назад, начиная с которого надо отправлять документы с устройства. 0 - все, что есть
	int16  QuotKindOptions;    // @v11.7.1 qkoXXX Опции выбора котировки на устройстве
  	char   Reserve1[4];        // @reserve @v11.7.1 [6]-->[4]
  	int32  InhBillTagVal;      // Значение тега документа, наследуемое принимаемыми заказами от устройства
		// Сам тег определяется в конфигурации StyloPalm
	PPGeoTrackingMode Gtm;     // Режим отслеживания положения устройства
	PPID   ObsoleteLocID;      // ->Location.ID // @v8.6.8 LocID-->ObsoleteLocID поле более не используется - только список складов PPStyloPalmPacket::LocList
	PPID   GoodsGrpID;         //
	PPID   OrderOpID;          // ->Ref(PPOBJ_OPRKIND)
	PPID   FTPAcctID;          //
	long   Flags;              // PLMF_XXX
	PPID   GroupID;            // ->Ref(PPOBJ_STYLOPALM) Группа, которой принадлежит устройство
		// Запись, порожденная от группы, наследует у группы следующие поля: LocID, OrderOpID,
		// Flags & (PLMF_IMPASCHECKS|PLMF_EXPCLIDEBT|PLMF_EXPSELL|PLMF_EXPBRAND), PPStyloPalmPacket::P_LocList
	PPID   AgentID;            // ->Article.ID; Agent - owner of palm
};

struct PPStyloPalmPacket {
public:
	PPStyloPalmPacket();
	~PPStyloPalmPacket();
	void   destroy();
	PPStyloPalmPacket & FASTCALL operator = (const PPStyloPalmPacket &);
	void   Setup();
	//
	// Returns:
	//   !0 - если P_Path != 0
	//    0 - если P_Path == 0
	int    MakeOutputPath(SString & rBuf) const; // @>>PPStyloPalmPacket::MakePath
	//
	// Returns:
	//   !0 - если P_Path != 0
	//    0 - если P_Path == 0
	int    MakeInputPath(SString & rBuf) const;  // @>>PPStyloPalmPacket::MakePath
	int    MakePath(const char * pSuffix, SString & rBuf) const;

	PPStyloPalm Rec;
	char * P_Path;
	char * P_FTPPath;
	ObjIdListFilt LocList;
	ObjIdListFilt QkList__; // Список видов котировок, используемых для передачи цен на устройства
};
//
//
//
struct PalmBillItem {
	PalmBillItem();
	PPID   GoodsID;
	double Qtty;
	double Price;
};

class PalmBillPacket : private SVector {
public:
	PalmBillPacket();
	void   Init();
	uint   GetItemsCount() const;
	int    EnumItems(uint * pPos, PalmBillItem *) const;
	int    AddItem(const PalmBillItem *);
	int    RemoveItem(uint);

	struct Header {
		PPID   PalmID;
		long   ID;             // ИД документа на устройстве + смещение, необходимое для того, чтобы идентификаторы от разных устройств отличались
		long   OrgID;          // Оригинальный ИД документа на устройстве (без смещения)
		long   Op;             // Код операции (1 - заказ, 2 - инвентаризация)
		char   Code[12];
		LDATE  Dt;
		PPID   ClientID;
		PPID   AgentID;        // ->Article.ID
		PPID   DlvrAddrID;
		PPID   QuotKindID;
		double Amount;
		double PctDis;
		char   Memo[160];
		PPID   LocID;
		LDATETIME CreateDtm;
		LDATETIME CreateDtmEnd;
		double Latitude;
		double Longitude;
		double LatitudeEnd;
		double LongitudeEnd;
	};

	Header Hdr;
};

struct PalmToDoItem { // @transient
	PPID   ID;            // ИД задачи в базе данных
	LDATE  DueDate;       // Дата планового завершения задачи
	LDATE  ComplDate;     // Дата фактического выполнения задачи
	PPID   AgentID;       // ->Article.ID
	int    Priority;      // Приоритет TODOPRIOR_XXX
	int    Completed;     // Признак завершенной задачи
	char   Descript[256];
	char   Memo[256];
};

struct PalmDebtMemoItem {
	PPID   BillID;     // Ид. долгового документа
	char   Memo[256];  // Примечание
};

class PalmBillQueue : private SArray {
public:
	PalmBillQueue();
	uint   GetItemsCount() const;
	long   GetBillIdBias() const;
	bool   IsEmpty() const;
	int    Push(PalmBillPacket *);
	int    PushUnique(PalmBillPacket * pPack);
	PalmBillPacket * Pop();
	PalmBillPacket * Peek();
	int    AddItem(PPID billID, const PalmBillItem *, uint * pPos);
	void   Destroy();
	int    SetIdAssoc(PPID dvcID, PPID outerID, PPID innerID);
	PPID   GetInnerIdByOuter(PPID dvcID, PPID outerID) const;
private:
	struct IdAssocItem { // @flat
		IdAssocItem(PPID dvcID, PPID outerBillID, PPID innerBillID = 0);
		PPID   DvcID;
		PPID   OuterBillID;
		PPID   InnerBillID;
	};
    TSVector <IdAssocItem> IdAssocList; // Сопоставление внешних идентификаторов документов с идентификаторами в принимающей базе данных
};

struct PalmInputParam {
	PalmInputParam();

	PalmBillQueue * P_BillQueue;
	SQueue * P_ToDoQueue; // Queue of PalmToDoItem
	SQueue * P_DebtMemoQueue;
	TSVector <PPGeoTrackItem> * P_GtList;
};
//
// Descr: Класс, опрелеляющий блок данных для отображения на удаленном дисплее.
//
class PalmDisplayBlock {
public:
	friend class PPObjStyloPalm;
	friend class StyloDisplayQueue;

	PalmDisplayBlock();
	void   Clear();

	enum {
		ctxNone = 0,
		ctxPersonEvent
	};
	enum {
		fError = 0x0001
	};
	SVerT Ver;
	PPID   DvcID;
	long   Flags;
	int32  Ctx;         // Тип контекста
	SBuffer CtxData;    // Контекстные данные
	SString DirectMsg;  // Прямое сообщение для устройства
private:
	uint32  QueuePos;   // @inner Идентификатор, с которым блок хранится в очереди.
		// Необходим для корректного удаления блока после подтверждения приема от устройства.
};
//
// Конфигурация обмена данными между Papyrus'ом и StyloPalm'ом
//
struct PPStyloPalmConfig {  // @persistent @store(PropertyTbl)
	enum {
		ordercodeIdHash = 1,
		ordercodeSymbName,
		ordercodeNameSymb
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_STYLOPALMCFG
	int16  SellAnlzTerm;    // Период (недель), на который необходимо подготовить данные о продажах (0 - не готовить)
	PPID   SellOpID;        // Вид операции продаж
	PPID   CliInvOpID;      // Вид операции инвентаризации клиентов
	int16  Reserve;         // @alignment
	int32  OrderCodeFormatType; // Тип формата номеров заказов
	PPID   InhBillTagID;    // Тег документа, наследуемый принимаемыми заказами от устройства
	char   Reserve1[40];
	long   Flags;
	long   Reserve2[2];
};

struct PalmPaneData {
	PalmPaneData();

	enum {
		fUpdateData    = 0x0001,
		fExportFTP     = 0x0002,
		fImportFTP     = 0x0004,
		fDelImpData    = 0x0008,
		fForceEdit     = 0x0010, // @internal При вызове функции PPObjStyloPalm::ImpExp() будет открываться диалог редактирования
			// параметров не зависимо от значения остальных полей этой структуры
		fExclExpDebts  = 0x0020, // Не готовить данные для экспорта по долгам (ради ускорения процесса)
		fIgnoreMutex   = 0x0040  // dangerous option! Игнорировать mutex, предотвращающий одновременный запуск нескольких
			// сеансов обмена данными.
	};
	PPID   PalmID;
	PPID   OpID;
	PPID   LocID;
	long   Flags;
};

class PPObjStyloPalm : public PPObjReference {
public:
	static int FASTCALL ReadConfig(PPStyloPalmConfig *);
	static int EditConfig();
	static int ImpExp(const PalmPaneData *);
	static int EditImpExpData(PalmPaneData *);
	static int XmlCmpDtm(LDATE dt, LTIME tm, const char * pXmlPath);
	static int PutDisplayBlock(const PalmDisplayBlock & rBlk);
	static int LockDisplayQueue(PPID dvcID);
	static int UnlockDisplayQueue(PPID dvcID);
	static int PeekDisplayBlock(PPID dvcID, PalmDisplayBlock & rBlk, int lock);
	static int RemoveDisplayBlock(const PalmDisplayBlock & rBlk);
	static int PopDisplayBlock(PPID dvcID, PalmDisplayBlock * pBlk, int lock);
	explicit PPObjStyloPalm(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	int    IsPacketEq(const PPStyloPalmPacket & rS1, const PPStyloPalmPacket & rS2, long flags);
	int    GetChildList(PPID id, PPIDArray & rPalmList);
	int    GetLocList(PPID id, ObjIdListFilt & rLocList);
	int    GetQuotKindList(PPID id, ObjIdListFilt & rQuotKindList);
	int    GetListByPerson(PPID personID, PPIDArray & rPalmList);
	int    GetPacket(PPID id, PPStyloPalmPacket * pPack);
	int    PutPacket(PPID * pID, PPStyloPalmPacket * pPack, int use_ta);
	bool   CheckSignalForInput(const char * pPath);
	void   ClearInputSemaphore(const char * pPath);
	int    ReadInput(PPID id, PalmInputParam * pParam, long flags, PPLogger * pLogger, long * pOrdCount);
		// @<<PPObjStyloPalm::ImportData, @<<PalmImportWaiter::Activate
	int    ExportData(const PalmPaneData & rParam);
	int    CopyToFTP(PPID, int delAfterCopy, PPLogger *);
	int    CopyFromFTP(PPID, int delAfterCopy, PPLogger *);
	int    DeleteImportData(PPID id);
	//
	//
	//
	struct RegisterDeviceBlock {
        uint8  DeviceID[16];
	};

	int    RegisterDevice(PPID id, RegisterDeviceBlock * pBlk, int use_ta);
private:
	class ExportBlock {
	public:
		struct GoodsGrpEntry { // @flat
			PPID   ID;
			PPID   ParentID;
			char   Name[64];
		};
		struct BrandEntry { // @flat
			PPID   BrandID;
			PPID   OwnerID;
			char   BrandName[64];
			char   OwnerName[128];
		};
		struct WhEntry { // @flat
			PPID   WhID;
			char   WhName[48];
		};
		ExportBlock();
		~ExportBlock();

        PPObjGoods * P_GObj;
        PPObjBrand * P_BrObj;
        PPObjPerson * P_PsnObj;
        PPObjLocation * P_LocObj;
        PPObjArticle * P_ArObj;
        PPViewDebtTrnovr * P_DebtView;
        PPViewGoodsRest * P_GrView;
        TSVector <BrandEntry> * P_BrandList;
        TSVector <WhEntry> * P_WhList;
        TSVector <GoodsGrpEntry> * P_GgList;
	};
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    CreateBrandList(ExportBlock & rBlk);
	int    CreateWhList(ExportBlock & rBlk);
	int    CreateGoodsGrpList(ExportBlock & rBlk);
	int    Helper_GetPacket(PPID id, PPStyloPalmPacket * pPack, PPIDArray * pStack);
	int    Helper_GetChildList(PPID id, PPIDArray & rPalmList, PPIDArray * pStack);
	int    ResolveClientID(const char * pInTblPath, PPID inID, PPID * pOutID);
	int    ImportData_(PPID id, PPID opID);
	int    ReadInputBill(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger * pLogger, long * pOrdCount);
		//
	// Документы инвентаризации заносятся в туже очередь, что и документы заказов, но
	// поле PalmBillHeader::Op = 2
	//
	int    ReadInputInv(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger *);
	int    ReadInputToDo(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger *);
	int    ReadInputDebtMemo(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/);
	int    ImportData(PPID, PPID opID, PPID locID, PPLogger * pLog);
		// @<<PPObjStyloPalm::ImpExp
	int    ImportBill(PalmBillQueue * pQueue, PPID opID, PPID locID, PPLogger * pLogger, long ordCount, int use_ta);
		// @<<PPObjStyloPalm::ImportData
	int    ImportOrder(PalmBillPacket * pSrcPack, PPID opID, PPID locID,
		/*int orderCodeFormatType*/const PPStyloPalmConfig & rCfg, PPID * pResultID, PPLogger * pLogger, int use_ta);
	int    ImportInventory(PalmBillPacket * pSrcPack, PPID opID, PPID locID, PPLogger * pLogger, int use_ta);
	int    ImportToDo(SQueue *, PPLogger * pLogger, int use_ta);
	int    ImportToDo(const PPStyloPalmPacket *);
	int    ImportDebtMemo(SQueue *, PPLogger * pLogger, int use_ta);
	int    ExportGoods(const PPStyloPalmPacket * pPack, ExportBlock & rBlk);
	int    ExportClients(PPID acsID, long palmFlags, ExportBlock & rBlk);
};
//
// Класс PalmImportWaiter реализует функции ожидания, постановки в очередь и
// обработки документов, поступивших с PDA в компьютер.
//

//
// Функция PalmImportProc должна возвращать следующие значения //
//
#define PIPR_ERROR_BREAK  0 // пакет не обработан по причине возникновения ошибки, следует прервать обработку очереди
#define PIPR_OK_CONTINUE  1 // пакет успешно обработан и функция готова к обработке следующего пакета
#define PIPR_OK_BREAK     2 // пакет успешно обработан, но обслуживание очереди следует прервать
#define PIPR_OK_DESTROY   3 // пакет успешно обработан, обслуживание очереди прервать и очистить очередь

typedef int (*PalmImportProc)(PalmBillPacket *, void *);

class PalmImportWaiter {
public:
	PalmImportWaiter(PalmImportProc, void * procExtraPtr);
	~PalmImportWaiter();
	int    Activate();
private:
	int    InitDeviceList();
	int    ProcessQueue();

	struct DeviceEntry {
		PPID   ID;
		char   Path[MAX_PATH];
	};
	PPObjStyloPalm PalmObj;
	SArray * P_DeviceList;
	PalmBillQueue Queue;
	PalmImportProc Proc;
	void * ProcExtraPtr;
	int    Semaphore;
};
//
// @ModuleDecl(PPObjTouchScreen)
// TouchScreen
//
#define TSF_PRINTSLIPDOC  0x0001 // Печать подкладного документа (вместо печати на принтер)
#define TSF_TXTSTYLEBTN   0x0002 // Текст на кнопках

struct PPTouchScreen2 {    // @persistent @store(Reference2Tbl+)
	PPTouchScreen2();

	PPID   Tag;                 // Const=PPOBJ_TOUCHSCREEN
	PPID   ID;                  // @id
	char   Name[48];            // @name @!refname
	char   Symb[20];            //
	char   Reserve[20];         // @reserve
	long   GdsListFontHight;    //
	char   GdsListFontName[32]; //
	uint8  GdsListEntryGap;     // Дополнительное слагаемое высоты строки списка выбора товара (pixel)
		// Рекомендуемый диапазон: [0..8]
	uint8  Reserve2[3];         // @alignment
	long   Flags;               // TSF_XXX
	PPID   TouchScreenType;     //
	PPID   AltGdsGrpID;         // Альтернативная группа, товары из которой показываются в кассовой панели по умолчанию
};

class PPTouchScreenPacket {
public:
	PPTouchScreenPacket();
	PPTouchScreenPacket & FASTCALL operator = (const PPTouchScreenPacket &);
	PPTouchScreen Rec;
	PPIDArray GrpIDList;
};

class PPObjTouchScreen : public PPObjReference {
public:
	PPObjTouchScreen(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    GetPacket(PPID id, PPTouchScreenPacket * pPack);
	int    PutPacket(PPID * pID, PPTouchScreenPacket * pPack, int use_ta);
};
//
//
//
#define PHNSVCTYPE_ASTERISK 1

struct PPPhoneService {
	PPPhoneService();

	PPID   Tag;                 // Const=PPOBJ_PHONESERVICE
	PPID   ID;                  // @id
	char   Name[48];            // @name
	char   Symb[20];            // @symb
	char   Reserve[60];         // @reserve
	long   Flags;               // @flags
	long   DvcType;             // Тип устройства
	long   Val2;                //
};

#define PHNSVCEXSTR_ADDR     1
#define PHNSVCEXSTR_PORT     2
#define PHNSVCEXSTR_USER     3
#define PHNSVCEXSTR_PASSWORD 4

class PPPhoneServicePacket {
public:
	PPPhoneServicePacket();
	int    GetExField(int fldId, SString & rBuf) const;
	int    SetExField(int fldId, const char * pBuf);
	int    GetPassword(SString & rBuf) const;
	int    SetPassword(const char * pPassword);
	//
	// Descr: Возвращает символ канала, с которого можно совершать звонки
	//
	int    FASTCALL GetPrimaryOriginateSymb(SString & rChannel);

	PPPhoneService Rec;
	SString Tail;
	SString LocalChannelSymb; // Символ локального канала. хранится в реестре Windows
	SString ScanChannelSymb;  // Символ сканируемого канала. хранится в реестре Windows
};

class PPObjPhoneService : public PPObjReference {
public:
	static int FASTCALL IsPhnChannelAcceptable(const SString & rFilter, const SString & rChannel);
	static int PhoneTo(const SString & rPhone);

	PPObjPhoneService(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    PutPacket(PPID * pID, PPPhoneServicePacket *, int use_ta);
	int    GetPacket(PPID id, PPPhoneServicePacket *);

	AsteriskAmiClient * InitAsteriskAmiClient(PPID id);
};
//
//
//
struct PhnSvcChannelStatus {
	enum {
		stUndef    = -1,   // Undefined
		stDown     =  0,   // Channel is down and available
		stReserved =  1,   // Channel is down, but reserved
		stOffHook,         // Channel is off hook
		stDialing,         // Digits (or equivalent) have been dialed
		stRing,            // Line is ringing
		stRinging,         // Remote end is ringing
		stUp,              // Line is up
		stBusy,            // Line is busy
		stDialingOffHook,  // Digits (or equivalent) have been dialed while offhook
		stPreRing,         // Channel has detected an incoming call and is waiting for ring
		stMuteFlag = 0x00010000 // Do not transmit voice data
	};
	enum {
		typUnkn     = 0,
		typSip      = 1
	};
	enum {
		fMute = 0x0001
	};
	PhnSvcChannelStatus();
	PhnSvcChannelStatus & Z();

	long   State;
	long   Flags;
	long   Priority;
	long   Type;   // PhnSvcChannelStatus::typXXX
	long   TimeToHungUp;
	long   Seconds;
	uint64 CallGroup;
	uint64 PickUpGroup;
	SString Channel;
	SString CallerId;
	SString CallerIdName;
	SString ConnectedLineNum;
	SString ConnectedLineName;
	SString AccountCode;
	SString Context;
	SString Exten;
	SString DnId;
	SString EffConnectedLineNum;
	SString EffConnectedLineName;
	SString Application;
	SString Data;
	SString BridgeId;
	SString IdentifiedCallerName;
};

class PhnSvcChannelStatusPool : SVector, SStrGroup {
public:
	PhnSvcChannelStatusPool();
	uint   GetCount() const;
	int    FASTCALL Add(const PhnSvcChannelStatus & rStatus);
	int    FASTCALL Get(uint idx, PhnSvcChannelStatus & rStatus) const;
	int    GetByChannel(const char * pChannel, PhnSvcChannelStatus & rStatus) const;
	int    GetListWithSameBridge(const char * pBridgeId, int excludePos, PhnSvcChannelStatusPool & rList) const;
	int    SetIdentifiedCallerName(uint idx, const char * pName);
	PhnSvcChannelStatusPool & Z();
private:
	struct Item_ { // @flat
		long   State;
		long   Flags;
		long   Priority;
		long   Type;
		long   TimeToHungUp;
		long   Seconds;
		uint64 CallGroup;
		uint64 PickUpGroup;
		uint   ChannelPos;
		uint   CallerIdPos;
		uint   CallerIdNameP;
		uint   ConnectedLineNumPos;
		uint   ConnectedLineNameP;
		uint   AccountCodeP;
		uint   ContextP;
		uint   ExtenP;
		uint   DnIdP;
		uint   EffConnectedLineNumP;
		uint   EffConnectedLineNameP;
		uint   ApplicationP;
		uint   DataP;
		uint   BridgeIdP;
		uint   IdentifiedCallerNameP; // Позиция строки имени, идентифицированного вне телефонного сервера
	};
};

class AsteriskAmiClient {
public:
	enum {
		stConnected = 0x0001,
		stLoggedOn  = 0x0002
	};
	class Message : public StringSet {
	public:
		struct ReplyStatus {
			int    Code;          // -1 undef; 1 - success; 0 - error
			int    EventListFlag; // -1 - undef; 0 - start; 1 - end or complete; 2 - cancelled
			SString Message;
		};
		Message();
		explicit Message(const char * pReply);
		int    Get(uint * pPos, SString & rTag, SString & rValue) const;
		int    GetTag(const char * pTag, SString & rValue) const;
		int    Parse(StrStrAssocArray & rTags) const;
		int    Convert(SString & rBuf) const;
		Message & Z();
		int    Add(const char * pTag, const char * pValue);
		int    AddAction(const char * pValue);
		int    ParseReply(const char *);
		int    GetReplyStatus(ReplyStatus & rS) const;
	};

	static int GetStateText(long state, SString & rBuf);
	static int GetStateVal(const char * pText, long * pState);

	enum {
		fDoLog = 0x0001 // Записывать в журнал phnsvc.log информацию об обмене данными с сервером
	};
	explicit AsteriskAmiClient(long flags);
	~AsteriskAmiClient();
	int    Connect(const char * pServerAddr, int serverPort);
	int    Login(const char * pUserName, const char * pPassword);
	int    Logout();
	int    GetChannelList(const char * pChannelName, PhnSvcChannelStatusPool & rList);
	int    GetChannelStatus(const char * pChannelName, PhnSvcChannelStatusPool & rList);
	int    GetChannelListLinkedByBridge(const char * pChannelName, PhnSvcChannelStatusPool & rList);
	int    Redirect(const char * pChannelFrom, const char * pExtenTo, const char * pExtraChannel, const char * pContext, int priority);
	int    Originate(const char * pChannelFrom, const char * pPhontTo, const char * pContext, int priority);
	int    ExecCommand(const Message & rIn, Message * pOut);
	int    ReadReply(Message & rOut);
	int    Read(Message & rMsg);
private:
	void   FASTCALL Log(const char * pText);

	struct AsteriskAmiStateStr {
		long   State;
		const char * P_Str;
	};
	static AsteriskAmiStateStr StateList[];
	long   Flags;
	long   State;
	int64  LastActionId;
	TcpSocket S;
};
//
// Descr: Класс, реализующий высокоуровневый функционал ответа на события телефонного сервиса.
//   Подписывается на события телефонного сервиса и в ответ на них вызывает ту или иную высокоуровневую функцию.
//
class PhoneServiceEventResponder {
public:
	PhoneServiceEventResponder();
	~PhoneServiceEventResponder();
	bool   IsConsistent() const;
	int    IdentifyCaller(const char * pCaller, PPObjIDArray & rList);
	const  StrAssocArray * GetInternalPhoneList();
private:
	static int AdviseCallback(int kind, const PPNotifyEvent * pEv, void * procExtPtr);

	uint32 Signature;
	long   AdvCookie_Ringing;
	long   AdvCookie_Up;
	PPObjPerson * P_PsnObj;
	StrAssocArray * P_InternalPhoneList; // Список персоналий, ассоциированных со внутренними телефонными номерами
};
//
// @ModuleDecl(PPViewJobPool)
//
class PhnSvcMonitorFilt : public PPBaseFilt {
public:
	PhnSvcMonitorFilt();

	uint8  ReserveStart[64]; // @anchor
	PPID   PhnSvcID;
	long   Flags;
	long   ReserveEnd;       // @anchor
};

typedef PhnSvcChannelStatus PhnSvcMonitorViewItem;

class PPViewPhnSvcMonitor : public PPView {
public:
	PPViewPhnSvcMonitor();
	~PPViewPhnSvcMonitor();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	//int    InitIteration();
	//int    FASTCALL NextIteration(PhnSvcMonitorViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    Update();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    CreatePhnSvcClient();

	PhnSvcChannelStatusPool List;
	PhnSvcMonitorFilt Filt;
	AsteriskAmiClient * P_Cli;
	PPObjPerson * P_PsnObj;
	PhnSvcChannelStatus TempStatusEntry; // @fastreuse
};
//
// @ModuleDecl(PPObjInternetAccount)
//
#define MAEXSTR_SENDSERVER       1 // Сервер исходящей почты (SMTP)
#define MAEXSTR_SENDPORT         2 // Порт исходящей почты (SMTP)
#define MAEXSTR_RSRVSENDSERVER   3 // Резервный сервер исходящей почты (SMTP)
#define MAEXSTR_RSRVSENDPORT     4 // Резервный порт исходящей почты (SMTP)
#define MAEXSTR_RCVSERVER        5 // Сервер входящей почты (POP3)
#define MAEXSTR_RCVPORT          6 // Порт входящей почты (POP3)
#define MAEXSTR_RCVNAME          7 // Имя для доступа к серверу входящей почты (POP3)
#define MAEXSTR_RCVPASSWORD      8 // Пароль для доступа к серверу входящей почты (POP3)
#define MAEXSTR_FROMADDRESS      9 // Обратный почтовый адрес
#define MAEXSTR_RCVPASSWORD2    10 // @v11.5.9 (новый тег для хранения более длинных паролей) Пароль для доступа к серверу входящей почты (POP3)
#define FTPAEXSTR_HOST           MAEXSTR_SENDSERVER     // Ftp сервер
#define FTPAEXSTR_PORT           MAEXSTR_SENDPORT       // Порт ftp сервера
#define FTPAEXSTR_PROXY          MAEXSTR_RSRVSENDSERVER // Proxy сервер
#define FTPAEXSTR_PROXYPORT      MAEXSTR_RSRVSENDPORT   // Порт proxy сервера
#define FTPAEXSTR_USER           MAEXSTR_RCVNAME        // Имя для доступа к ftp серверу
#define FTPAEXSTR_PASSWORD       MAEXSTR_RCVPASSWORD    // Пароль для доступа к ftp серверу
#define FTPAEXSTR_PROXYUSER     10 // Имя для доступа к proxy серверу
#define FTPAEXSTR_PROXYPASSWORD 11 // Пароль для доступа к proxy серверу

struct PPInternetAccount2 { // @persistent @store(Reference2Tbl+)
	enum {
		fFtpAccount = 0x0001L,
		fFtpPassive = 0x0002L, // Пассивный режим
		fUseSSL     = 0x0004L  //
	};
	PPInternetAccount2();
	void   Init();
	int    Cmp(const PPInternetAccount2 * pAccount) const;
	int    NotEmpty();
	//int    GetExtField(int fldID, char * pBuf, size_t bufLen);
	int    GetExtField(int fldID, SString & rBuf) const;
	int    SetExtField(int fldID, const char * pBuf);
	int    SetPassword_(const char *, int fldID/*= MAEXSTR_RCVPASSWORD*/);
	int    GetPassword_(char * pBuf, size_t bufLen, int fldID/*= MAEXSTR_RCVPASSWORD*/) const;
	int    SetMimedPassword_(const char * pPassword, int fldID/*= MAEXSTR_RCVPASSWORD*/);
	int    GetMimedPassword_(char * pBuf, size_t bufLen, int fldID/*= MAEXSTR_RCVPASSWORD*/);
	int    GetSendPort() const;
	int    GetRcvPort();
	//
	long   Tag;            // Const=PPOBJ_INTERNETACCOUNT
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	uint16 SmtpAuthType;   // Тип аутентификации для соединения с SMTP сервером
	int16  Timeout;        // Таймаут сервера (сек)
	long   Flags;          //
	PPID   PersonID;       // ->Person.ID
	long   Reserve2;       // @reserve
	SString ExtStr;        // @anchor
};

typedef TSCollection <PPInternetAccount> PPInetAccntArray;

class PPObjInternetAccount : public PPObjReference {
public:
	//
	// Descr: Фильтрующие флаги для списков (передаются как *extraPtr)
	//
	enum {
		filtfMail = 0x0001,
		filtfFtp  = 0x0002,
		filtfHttp = 0x0004
	};
	explicit PPObjInternetAccount(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	int    Get(PPID id, PPInternetAccount * pPack);
	int    Put(PPID * pID, const PPInternetAccount * pPack, int use_ta);
private:
	int    AssignImages(ListBoxDef * pDef);
};
//
//
//
struct StConfig {
	StConfig();
	void   Clear();
	SString Host;
	uint   Port;
	SString SystemId; // Идентификатор клиента в системе
	SString Login;
	SString Password;
	SString SystemType; // Тип системы
	SString AddressRange; // Фильтр адресов отправителя
	uint   SourceAddressTon; // Тип номера отправителя
	uint   SourceAddressNpi; //Цифровой индикатор плана отправителя
	uint   DestAddressTon; // Тип номера получателя
	uint   DestAddressNpi; // Цифровой индикатор плана получателя
	uint   DataCoding; // Схема кодирования сообщения
	uint   EsmClass; // Тип сообщения и режим отправки сообщения
	SString From; // Имя или номер отправителя
	uint   SplitLongMsg; // Разбивать или нет длинные сообщения
	uint16 ResponseTimeout;
	uint16 ResendMsgQueueTimeout;
	uint16 ResendTriesNum;
	uint16 ReconnectTimeout;
	uint16 ReconnectTriesNum;
};

class SmsClient {
public:
	SmsClient(PPLogger * pLogger);
	~SmsClient();
	//int    IsConnected() const;
	int    SendSms(const char * pTo, const char * pText, SString & rStatus);
	int    SmsInit_(PPID accID, const char * pFrom);
	int    SendingSms_(PPID personId, const char * pPhone, const char * pText);
	int    SmsRelease_();
private:
	struct StSubmitSMParam { // Структура параметров запроса submit_sm
		StSubmitSMParam();
		void   Clear();

		uchar  SourceAddressTon;
		uchar  SourceAddressNpi;
		uchar  DestinationAddressTon;
		uchar  DestinationAddressNpi;
		uchar  EsmClass;
		uchar  ProtocolId;
		uchar  PriorityFlag;
		uchar  ReplaceIfPresentFlag;
		uchar  DataCoding;
		uchar  SmDefaultMsgId;
		uint8  Reserve[2]; // @alignment
		SString SourceAddress;
		SString DestinationAddress;
		SString SheduleDeliveryTime;
		SString ValidityPeriod;
	};
	struct StSMResults {
		StSMResults();
		int    GetResult(int kindOfResult);

		int    BindResult;
		int    UnbindResult;
		int    SubmitResult;
		int    DataResult;
		int    EnquireLinkResult;
		int    GenericNackResult;
	};
	//
	// Descr: Добавляет информацию об ошибочных командах посылки смс в массив ErrorSubmitArr
	//
	void   AddErrorSubmit(const char * pDestNum, int errCode);
	void   DecodeDeliverSm(int sequenceNumber, void * pPduBody, size_t bodyLength);
	void   DisconnectSocket();
	//
	// Descr: Добавляет статус смс в массив StatusCodesArr
	//
	void   AddStatusCode(const char * pDestNum, int statusCode, const char * pError);
	int    SendSms_(const char * pFrom, const char * pTo, const char * pText);
	//int    Send_(const void * data, size_t bufLen);
	int    Send(const SmsProtocolBuf & rBuf, int tryReconnect);
	int    Bind();
	int    Unbind();
	int    SubmitSM(const StSubmitSMParam & rParam, const char * pMessage, bool payloadMessage);
	int    ConnectToSMSC();
	int    TryToReconnect(uint & rRecconectionCount);
	int    SendGenericNack(int sequenceNumber, int commandStatus);
	int    Receive(uint timeout);
	//
	// Descr: Если USE_ENQUIRELINK = true, то посылает команду на проверку связи через каждый промежуток времени ENQUIRE_LINK_TIMEOUT
	//
	int    ReceiveToTimer();

	PPUhttClient * P_UhttCli;
	TcpSocket ClientSocket;
	LDATETIME StartTime;
	StConfig Config;
	StSMResults SMResults;
	StSubmitSMParam SMParams;
	StrAssocArray ErrorSubmitArr; // Массив с информацией об ошибочных запросах посылки смс. Структура записи: номер_получателя;описание_ошибки
	StrAssocArray StatusCodesArr; // Массив структур состояний сообщений, в том числе и ошибочных. Структура записи: номер_получателя;состояние_сообщения
	int    ConnectionState;
	uint   ResendErrLenMsg; // Счетчик попыток переотправить сообщение при неверной его длине
	uint   ReSendQueueMsgTryNums; // Счетчик попыток переотправить смс, которые не были отправлены из-за переполнения очереди
	uint   MessageCount; // Счетчик успешных запросов отправки сообщения (submit_sm)
	uint   SequenceNumber; // Номер пакета
	uint   AddStatusCodeNum; // Счетчик элементов массива StatusCodesArr
	uint   AddErrorSubmitNum; // Счетчик эелементов массива ErrorSubmitArr
	uint   UndeliverableMessages; // Счетчик недоставляемых сообщений
	PPLogger * P_Logger;
};
//
// @ModuleDecl(PPObjSmsPrvAccount)
//
#define SMEXTSTR_HOST          1 // Интрефейс, через который работает клиент
// @v11.0.5 #define SMEXTSTR_PORT_OBSOLETE 2 // @v8.5.4 SMEXTSTR_PORT-->SMEXTSTR_PORT_OBSOLETE
#define SMEXTSTR_SYSTEMID      3 // Идентификатор клиента в системе
#define SMEXTSTR_PASSWORD      4 // Пароль доступа к SMPP-сервису
#define SMEXTSTR_FROM          5 // Имя отправителя в том виде, как его будут видеть получатели
#define SMEXTSTR_SYSTYPE       6 // Тип системы
//
// Общая структура для смс-уведомлений (автоматическая рассылка)
//
struct PPAutoSmsConfig {
	enum {
		asmsDaysMon = 0x01,
		asmsDaysTue = 0x02,
		asmsDaysWed = 0x04,
		asmsDaysThu = 0x08,
		asmsDaysFri = 0x10,
		asmsDaysSat = 0x20,
		asmsDaysSun = 0x40
	};
	PPAutoSmsConfig();
	bool   IsEmpty() const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx); // для запихивания структуры в буфер

	uint8  Reserve[32];
	SString TddoPath; // Путь к файлу шаблона сообщения //
	uint16 AllowedWeekDays;
	uint16 Reserve2;
	LTIME  AllowedStartTm;
	LTIME  AllowedEndTm;
};
//
// @todo Переделать структуру - она ужасна.
//
struct PPSmsAccount { // size=sizeof(Reference2Tbl::Rec)
	enum {
		smacfSpliLongMsg = 0x0001,
		smacfUseUHTT     = 0x0002
	};
	PPSmsAccount();
	int    FASTCALL IsEq(const PPSmsAccount & rS) const;

	long   Tag;            // Const=PPOBJ_SMSPRVACCOUNT
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[46];    // @reserve [60] --> [50]
	int32  ServerPort;     // Порт сервера (адрес хранится в PPSmsAccPacket::ExtStr[SMEXTSTR_HOST]
	long   Flags;          // smacfXXX
	PPID   PersonID;       // ->Person.ID
	long   Reserve2;       // @reserve
	//
	// System params {
	//
	uint16 ResponseTimeout;
	uint16 ResendMsgQueueTimeout;
	uint16 ResendTriesNum;
	uint16 ReconnectTimeout;
	uint16 ReconnectTriesNum;
	// }
};
//
// @v8.5.4 DECL_REF_REC(PPSmsAccount);
//
class PPSmsAccPacket {
public:
	PPSmsAccPacket();
	void   Init();
	int    FASTCALL IsEq(const PPSmsAccPacket & rS) const;
	//
	// Descr: Опции функции PPSmsAccPacket::Verify
	//
	enum {
        vfEditingOnly = 0x0001 // Проверка только для этапа редактирования учетной записи
	};

	int    Verify(long flags) const;
	int    SetPassword(const char *);
	int    GetPassword(SString & rBuf) const;

	PPSmsAccount Rec;
	SString ExtStr;
};

typedef TSCollection <PPSmsAccount> PPSmsAccntArray;

class PPObjSmsAccount : public PPObjReference {
public:
	static int VerifyString(const SString & rStr, int options);
	static int BeginDelivery(PPID accID, StrAssocArray & rPrsnIdArr, StrAssocArray & rPhoneArr);
	static int BeginDelivery(PPID accID, StrAssocArray & rPrsnIdArr, StrAssocArray & rPhoneArr, PPID objTypeId, StrAssocArray & rObjIdArr);
	PPObjSmsAccount(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    GetPacket(PPID id, PPSmsAccPacket * pPack);
	int    PutPacket(PPID * pID, PPSmsAccPacket * pPack, int use_ta);
};

int    GetSmsConfig(PPSmsAccPacket & rPack, StConfig & rConfig);
int    FormatPhone(const char * pOldPhone, SString & rNewPhone, SString & rMsg);

class PPSmsSender {
public:
	struct FormatMessageBlock {
		FormatMessageBlock() : PersonID(0)
		{
		}
		PPID   PersonID;
	};
	static int FormatMessage_(const char * pTemplate, SString & rResult, FormatMessageBlock * pFmBlk);
	static int GetSubstVar(long p, SString & rBuf);
	PPSmsSender();
	~PPSmsSender();
};
//
// @ModuleDecl(PPObjSmsText)
//
#define	SENDSMEXTSTR_TEXT	1	// Текст сообщения //

struct PPSendSmsParam {
	PPSendSmsParam();
	void   Init();
	int    NotEmpty();

	long   Tag;            // Const=PPOBJ_SENDSMS
	long   ID;             //
	int	   SymbolCount;
	int	   SmsCount;
	SString ExtStr;        // @anchor
};
//
// @v7.6.1 @Muxa {
// @ModuleDecl(PPObjUhttStore)
//
struct PPUhttStore { // @size=sizeof(Reference2Tbl::Rec)
	PPUhttStore()
	{
		THISZERO();
	}
	enum {
		fUseGoodsPkg   = 0x0001, // Использовать емкость упаковки
		fShowRest      = 0x0002, // Показывать остатки
		fDontShowZeroRestItems = 0x0004, // Не показывать позиции для которых остаток нулевой
		fCreateBuyerPerson     = 0x0008  // При регистрации продажи (заказа) по возможности создавать персоналию (
			// в противном случае создается автономный адрес)
	};
	enum {
		kGenericStore  = 0, // Магазин, продающий товары
		kTSessCip      = 1  // Выставляется на продажу персональная регистрация в технологических сессиях
	};
	long   Tag;            // Const=PPOBJ_UHTTSTORE
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	long   Kind;           // Вид торговой площадки PPUhttStore::kXXX
	double UpRestShowThreshold; // Порог остатка, значения выше которого следует отабражать как, например, "более 8"
	long   Flags;          // @flags
	PPID   PersonID;       // ->Person.ID
	PPID   LocID;          // ->Location.ID
};

class PPUhttStoreSelDescr : private SStrGroup {
public:
	friend class PPObjUhttStore;

	enum {
		attrGroup     = 1,
		attrBrand     = 2,
		attrName      = 3,
		attrClass     = 4,
		attrTag       = 5,
		attrPeriod    = 6,
		attrProcessor = 7,
		attrCity      = 8
	};
	struct Entry {
		Entry();

		int    Attr;
		union {
			PPID   ClsID;
			PPID   TagID;
		};
		int    GcClsf; // Классификатор товара, принадлежащего классу PPGdsCls::eXXX
		SString Title;
	};

	PPUhttStoreSelDescr();
	PPUhttStoreSelDescr & Destroy();
	int    FASTCALL IsEq(const PPUhttStoreSelDescr & rS) const;
	uint   GetCount() const;
	int    ValidateEntry(const Entry * pEntry) const;
	int    AddEntry(uint * pPos, const Entry * pEntry);
	int    UpdateEntry(uint pos, const Entry * pEntry);
	int    GetEntry(uint pos, Entry & rEntry) const;
	int    GetDefaultEntryTitle(uint pos, SString & rBuf) const;
	int    Pack();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	struct InnerEntry { // @flat
		int32  Attr;
		int32  ExtID;
		int32  GcClsf; // Классификатор товара, принадлежащего классу PPGdsCls::eXXX
		uint   TitleP;
	};
	SVerT Ver; // Для сериализации
	TSVector <InnerEntry> L;
};

class PPUhttStorePacket {
public:
	PPUhttStorePacket();
	~PPUhttStorePacket();
	int    FASTCALL IsEq(const PPUhttStorePacket & rS) const;
	void   destroy();
	//
	// Descr: Возвращает список селекторов, откорректированный с учетом
	//   переданного параметром clsID товарного класса.
	//   Возвращаемый список содержит пару { key; val }, где
	//   key - [1..] целочисленная позиция селектора в списке Sd
	//   val - строковый заголовок селектора
	//
	int    GetSelectorListInfo(PPID clsID, StrAssocArray & rList) const;

	PPUhttStore Rec;
	ObjTagList  TagL;        // Список тегов
	PPUhttStoreSelDescr Sd;  // Селекторы
};

class PPObjUhttStore : public PPObjReference {
public:
	explicit PPObjUhttStore(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    ValidatePacket(const PPUhttStorePacket * pPack, long flags);
	int    Fetch(PPID id, PPUhttStore * pRec);
	int    PutPacket(PPID * pID, PPUhttStorePacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPUhttStorePacket * pPack);
	int    SerializePacket(int dir, PPUhttStorePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
};
// } @v7.6.1 @Muxa
//
// @v7.9.2 @Muxa {
//
// @ModuleDecl(PPObjWorkbook)
//
//
// Descr: Типы записей Workbook
// @persistent
//
#define PPWBTYP_UNDEF   0
#define PPWBTYP_PAGE    1
#define PPWBTYP_CSS     2
#define PPWBTYP_MEDIA   3
#define PPWBTYP_FOLDER  4
#define PPWBTYP_SITE    5
#define PPWBTYP_KEYWORD 6
//
// Descr: Флаги записей Workbook
// @persistent
//
#define PPWBF_HIDDEN           0x0001
#define PPWBF_DONTSHOWCHILDREN 0x0002
#define PPWBF_KWDONTSHOWMAINC  0x0004
//
// Descr: Коды дополнительных строковых значений записей рабочей книги
//
#define WBEXSTR_DESCRIPTION    1

struct PPWorkbookConfig { // @persistent @store(PropertyTbl)
	PPWorkbookConfig();
	PPWorkbookConfig & Z();

	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_WORKBOOKCFG
	PPID   SymbCntrID;         // ->Ref(PPOBJ_OPCOUNTER)
	PPID   DefImageFolderID;   // ->Ref(PPOBJ_WORKBOOK)
	PPID   UhttXEvTokID;       // ->Ref(PPOBJ_EVENTTOKEN) Событийная метка последнего обмена с Universe-HTT
	uint8  Reserve[52];        // @reserve
	long   ReservVal1;         // @reserve
	long   ReserveVal2;        // @reserve
};

class PPWorkbookPacket {
public:
	PPWorkbookPacket();
	~PPWorkbookPacket();
	bool   FASTCALL IsEq(const PPWorkbookPacket & rS) const;
	void   destroy();
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char * pBuf);
	int    SetLongSymb(const char * pSymb);

	WorkbookTbl::Rec Rec;
	enum {
		ufDontChgContent = 0x0001, // Функция PPObjWorkbook::PutPacket не должна изменять контент записей
	};
	long   UpdFlags;        // @transient Флаги, определяющие правила изменения некоторых полей
	ObjTagList TagL;        // Список тегов
	ObjLinkFiles F;
	SString ExtString;
};

class WorkbookCore : public WorkbookTbl {
public:
	friend class PPTblEnum <WorkbookCore>;
	enum {
		idxfldParent = 1,
		idxfldType
	};
	enum {
		eoIdName = 0x0001, // Инициализировать запрос на поля ID, Name, Rank
		eoIdSymb = 0x0002  // Инициализировать запрос на поля ID, Symb, Rank
		// Если указаны и eoIdName и eoIdSymb, то запрос результат содержит {ID, Rank, ObjName, Symb}
	};

	WorkbookCore();
	int    GetChildList(PPID id, int recursive, PPIDArray & rList);
	SEnum::Imp * Enum(int options);
	SEnum::Imp * EnumByParent(PPID parentID, int options);
	SEnum::Imp * EnumByType(long type, int options);
	int    NextEnum(long enumHandle, WorkbookTbl::Rec * pRec);
	int    Arrange(PPID rootID);
private:
	int    Helper_GetChildList(PPID id, int recursive, PPIDArray & rList, PPIDArray * pRecurTrace);
	int    InitEnum(int options, long * pHandle);
	int    InitEnumByParam(int fldId, PPID param, int flags, long * pHandle);

	PPTblEnumList EnumList;
};

class PPObjWorkbook : public PPObject {
public:
	static int  FASTCALL ReadConfig(PPWorkbookConfig * pCfg);
	static int  EditConfig();
	explicit PPObjWorkbook(void * extraPtr = 0);
	~PPObjWorkbook();
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	virtual int Search(PPID id, void * b = 0);
	int    SearchByName(const char * pName, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SearchBySymb(const char * pSymb, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SearchByLongSymb(const char * pLongSymb, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SearchAnalog(const WorkbookTbl::Rec * pSample, PPID * pID, WorkbookTbl::Rec * pRec);
	int    Fetch(PPID id, WorkbookTbl::Rec * pRec);
	int    MakeUniqueCode(SString & rBuf, int use_ta);
	int    PutPacket(PPID * pID, PPWorkbookPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPWorkbookPacket * pPack);
	StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    SetupParentCombo(TDialog *, uint ctlID, int itemType, PPID itemID, PPID parentID);
	int    SetupCSSCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID, PPID cssID);
	int    SetupLinkCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID, PPID linkID);
	int    SetupItemCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID);

	struct AddBlock {
		AddBlock();

		long   Type;
		PPID   ParentID;
		long   Flags;
		SString FileName;
	};

	int    AddItem(PPID * pID, PPID parentID);

	struct SelectLinkBlock {
		SelectLinkBlock();
		int    GetWbType(PPID * pType, PPID * pAddendumType) const;

		enum LinkType {
			ltImage = 1,
			ltRef,
			ltLink,
			ltAnnot
		};
		PPID   ID;
		PPID   AddendumID;
		int    Type;
	};
	int    SelectLink(PPObjWorkbook::SelectLinkBlock * pData);
	//
	// Descr: Не интерактивная привязка файла pFileName к записи id
	//
	int    AttachFile(PPID id, const char * pFileName, int use_ta);
	//
	// Descr: Интерактивный выбор и привязка файла к записи id
	//
	int    AttachFile(PPID id);

	struct ImpExpParam {
		ImpExpParam();
		enum {
			fRecursive    = 0x0001,
			fDirAsFolder  = 0x0002,
			fUpdateByName = 0x0004,
			fMedia        = 0x0008,
			fCanonical    = 0x0010  // Специализированный формат, позволяющий переносить книгу между базами данных.
				// В этом случае Wildcard - имя файла, файлы же с содержанием сохраняются в том же каталоге.
		};
		PPID   RootID;
		long   Flags;
		SString RmvFileNamePrefix;
		SString RmvFileNameSuffix;
		SString Wildcard;
	};

	int    SelectKeyword(SString & rKeyword);
	int    SelectKeywordReverse(SString & rKeyword);
	int    ImportFiles(PPID rootID, PPObjWorkbook::ImpExpParam * pParam);
	int    Export(PPID rootID);
	int    Transmit(PPID rootID);
	int    RemoveAll();
	void   SortIdListByRankAndName(LongArray & rList);
	LDATETIME GetLastModifTime(PPID id);
	LDATETIME GetContentLastModifTime(PPID id);
	int    InterchangeUhtt();
	int    ExportToUhtt(PPID id);
	int    TestImportFromUhtt();
	int    SerializePacket(int dir, PPWorkbookPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual const char * GetNamePtr();
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int Write(PPObjPack * pPack, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    Helper_Edit(PPID * pID, AddBlock * pAb);
	int    AddListItem(StrAssocArray * pList, const WorkbookTbl::Rec * pRec, PPIDArray * pRecurTrace);
	int    CheckParent(PPID itemID, PPID parentID);
	int    GetItemPath(PPID itemID, SString & rPath);
	int    EditImportParam(PPObjWorkbook::ImpExpParam * pParam);
	int    Helper_MakeStrAssocList(PPID parentID, StrAssocArray * pList, UintHashTable & rRecurTrace);
	int    Helper_Import(PPID rootID, const PPObjWorkbook::ImpExpParam & rParam, const SString & rBasePath, const SString & rNakedWc); // @recursive
	int    Helper_Export(PPID rootID, PPWorkbookExporter & rExporter, PPIDArray * pRecurTrace);
	int    Helper_Transmit(PPID rootID, PPIDArray & rResultList, PPIDArray * pRecurTrace);
	int    Helper_RemoveAll(PPID id, PPIDArray * pRecurTrace);

	struct ProcessUhttImportBlock {
		ProcessUhttImportBlock(PPUhttClient & rUc, const TSCollection <UhttWorkbookItemPacket> & rSrcList, LDATETIME sinceEvTm);

		PPUhttClient & R_Uc;
		const TSCollection <UhttWorkbookItemPacket> & R_SrcList;
		const LDATETIME SinceEvTime;
		LAssocArray ProcessedList;
	};

	int    Helper_CreatePacketByUhttList(PPID * pID, ProcessUhttImportBlock & rBlk, uint srcListPos, int use_ta);
	int    Helper_UhttToNativePacket(ProcessUhttImportBlock & rBlk, const UhttWorkbookItemPacket * pUhttPacket, const SString & rSymb, PPWorkbookPacket & rPack);
	int    Helper_ExportToUhtt(PPUhttClient & rUc, PPID id, const TSCollection <UhttWorkbookItemPacket> * pForeignList, PPLogger * pLogger);
public:
	TLP_MEMB(WorkbookCore, P_Tbl);
	void * ExtraPtr;
};
// } @v7.9.2 @Muxa
//
//
//
class PPObjBarCodeStruc : public PPObjReference {
public:
	explicit PPObjBarCodeStruc(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Вызывает диалог просмотра списка структур штрихкодов.
	// ARG(extraPtr IN): 0.
	//
	virtual int Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjDBDiv)
// Раздел базы данных (PPOBJ_DBDIV)
//
// Флаги разделов БД
//
#define DBDIVF_DISPATCH              0x0001L // Раздел-диспетчер
#define DBDIVF_SCARDSONLY            0x0002L // Обмен с разделом идет только на уровне пластиковых карт
#define DBDIVF_RCVCSESSANDWROFFBILLS 0x0004L // Раздел принимает кассовые сессии вместе с документами списания //
	// Если этот флаг установлен, то функция PPObjectTransmit::PutObjectToIndex пропускает документы
	// списания кассовых сессий несмотря на флаг DBDXF_SENDCSESSION в конфигурации обмена данными.
#define DBDIVF_CONSOLID              0x0008L // Раздел, принимающий консолидирующую информацию из других
	// разделов (документы без товарных строк)
#define DBDIVF_PASSIVE               0x0010L // Пассивный раздел
#define DBDIVF_FOREIGN               0x0020L // "Чужой" раздел. Используется для маршрутизации передачи пакетов между разделами
#define DBDIVF_MQBEXCHANGE           0x0040L // Раздел обменивается посредством брокера сообщений

struct PPDBDiv2 {          // @persistent @store(Reference2Tbl+)
	//
	// Descr: Следующие флаги полностью дублируют макросы DBDIVF_XXX.
	//   Использовать флаги PPDBDiv::fXXX НЕЛЬЗЯ. Сделано для будущих релизов.
	//
	enum {
		fDispatch      = 0x0001, // Раздел-диспетчер
		fSCardOnly     = 0x0002, // Обмен с разделом идет только на уровне пластиковых карт
		fRcvCSessAndWrOffBills = 0x0004, // Раздел принимает кассовые сессии вместе с документами списания //
			// Если этот флаг установлен, то функция PPObjectTransmit::PutObjectToIndex пропускает документы
			// списания кассовых сессий несмотря на флаг DBDXF_SENDCSESSION в конфигурации обмена данными.
		fConsolid      = 0x0008, // Раздел, принимающий консолидирующую информацию из других разделов (документы без товарных строк)
		fPassive       = 0x0010, // Пассивный раздел
		fForeign       = 0x0020,
		fMqbExchange   = 0x0040  // Раздел обменивается посредством брокера сообщений
	};
	long   Tag;           // Const=PPOBJ_DBDIV
	long   ID;            // @id
	char   Name[48];      // @name
	char   Symb[20];      // @symb
	char   Reserve[4];    // @reserve
	S_GUID Uuid;          // Уникальный идентификатор раздела
	char   Addr[40];      // Адрес узла e-mail или что-то в этом роде
	long   Flags;         // Флаги
	long   IntrRcptOpr;   // Операция межскладского прихода
	long   OutCounter;    // Счетчик исходящих пакетов
};

#define DBDIVEXSTR_ACCLIST     1 // Список счетов, проводки по которым следует передавать //
#define DBDIVEXSTR_GATEWAYLIST 2 // Список адресов шлюзов, через которые следует отправлять данные
//
// Пакет данных по разделу БД
//
struct DBDivPack {
	DBDivPack();
	DBDivPack & FASTCALL operator = (const DBDivPack & rS);
	void   Init();
	int    ResponsibleForLoc(PPID loc, int forQuot) const;
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char * pBuf);

	PPDBDiv   Rec;
	PPIDArray LocList;
	SString ExtString;
};
//
// @ModuleDecl(PPObjDBDiv)
// Раздел базы данных (PPOBJ_DBDIV)
//
class PPObjDBDiv : public PPObjReference {
public:
	enum {
		mklefShowPassive = 0x0001
	};

	static PPID Select(int skipCurrent, int * single = 0);
	explicit PPObjDBDiv(void * extraPtr = 0);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    Get(PPID, DBDivPack *);
	int    Put(PPID *, DBDivPack *, int use_ta);
	int    GetCounter(PPID dbid, long * counter, int use_ta);
	int    GetUuid(PPID dbid, S_GUID * pUuid, int use_ta);
	int    AcceptUuid(PPID dbid, const S_GUID & rUuid, int use_ta);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsType)
// Типы товаров (PPOBJ_GOODSTYPE)
//
// Флаги типов товаров
//
#define GTF_UNLIMITED      0x00000001L // Неограниченный ресурс
#define GTF_RPLC_COST      0x00000002L // Заменить станд сумму поступления //
#define GTF_RPLC_PRICE     0x00000004L // Заменить станд сумму реализации
#define GTF_RPLC_DSCNT     0x00000008L // Заменить станд сумму скидки
#define GTF_PRICEINCLDIS   0x00000010L // Сумма реализации включает скидку
#define GTF_EXCLAMOUNT     0x00000020L // Не включать в номинальную сумму документа
#define GTF_AUTOCOMPL      0x00000040L // Автокомплектация //
#define GTF_ALLOWZEROPRICE 0x00000080L // Допускается нулевая цена реализации
#define GTF_ASSETS         0x00000100L // Основные фонды
#define GTF_EXCLVAT        0x00000200L // Товары этого типа не включать в расчетную базу исходящего НДС
// @unused #define GTF_DISTRIBCOST    0x00000400L // Распределять сумму поступления этих товаров на все остальные строки приходного документа.
#define GTF_REQBARCODE     0x00000800L // Обязательно требовать ввода штрихкода на товар этого типа
#define GTF_QUASIUNLIM     0x00001000L // Квази-нелимитированный ресурс. Ведет себя как обычный товар, но при печати отчетов может интрепретироваться как нелимитированный.
#define GTF_LOOKBACKPRICES 0x00002000L // На товары этого типа розничные цены могут дифференцироваться в зависимости от партии
	// В России эта опция нужна для разрешения проблем с ценами на сигареты. При изменении максимальной розничной цены (МРЦ)
	// ритейлеры вынуждены выбирать ту цену, которая отпечатана на пачке.
#define GTF_ADVANCECERT    0x00004000L // Сертификат на последующую покупку товаров (главное назначение флага -
	// сигнализировать при учете, что оплата такого товара является авансом, но не собственно покупкой).
#define GTF_GMARKED        0x00008000L // Товары этого типа имеют государственную маркировку
#define GTF_EXCISEPROFORMA 0x00010000L // @v11.7.10 Товары этого типа формально подакцизные (предприятие, ведущее учет, акциз не рассчитывает, 
	// но передает специальную информацию о продаже таких товаров в надзорные органы)
#define GTF_EGAISAUTOWO    0x00020000L // @v12.0.7 Специальная опция, позволяющая автоматически определять марки егаис для списания при проведении
	// кассового чека с товаром, имеющим тип с таким флагом. Сам товар может не идентифицироваться как алкогольный, но если он имеет комплектующую 
	// товарную структуру, в которую входят алкогольные товары с марками, то формируется специальная алгоритмическая структура для списания долей этих товаров
	// через егаис.

#define GTCHZNPT_UNKN              -1 // @v11.5.0 Специальное интерфейсное значение, используемое для обозначения того, что товар маркируемый, но категория в терминах честного знака не ясна
#define GTCHZNPT_UNDEF              0
#define GTCHZNPT_FUR                UED::GetRawValue32(UED_RUCHZNPRODTYPE_FUR)/*1*/
#define GTCHZNPT_TOBACCO            UED::GetRawValue32(UED_RUCHZNPRODTYPE_TOBACCO)/*2*/
#define GTCHZNPT_SHOE               UED::GetRawValue32(UED_RUCHZNPRODTYPE_SHOE)/*3*/
#define GTCHZNPT_MEDICINE           UED::GetRawValue32(UED_RUCHZNPRODTYPE_MEDICINE)/*4*/
#define GTCHZNPT_CARTIRE            UED::GetRawValue32(UED_RUCHZNPRODTYPE_CARTIRE)/*5*/ // Автомобильные шины
#define GTCHZNPT_TEXTILE            UED::GetRawValue32(UED_RUCHZNPRODTYPE_TEXTILE)/*6*/ // Текстиль
#define GTCHZNPT_PERFUMERY          UED::GetRawValue32(UED_RUCHZNPRODTYPE_PERFUMERY)/*7*/ // Парфюмерия
#define GTCHZNPT_MILK               UED::GetRawValue32(UED_RUCHZNPRODTYPE_MILK)/*8*/ // Молоко
#define GTCHZNPT_JEWELRY            UED::GetRawValue32(UED_RUCHZNPRODTYPE_JEWELRY)/*9*/ // @v11.4.9 Ювелирные изделия //
#define GTCHZNPT_WATER              UED::GetRawValue32(UED_RUCHZNPRODTYPE_WATER)/*10*/ // @v11.5.4 Вода питьевая //
#define GTCHZNPT_ALTTOBACCO         UED::GetRawValue32(UED_RUCHZNPRODTYPE_ALTTOBACCO)/*11*/ // @v11.9.0 Альтернативная табачная продукция. Марки очень похожи на табак, но есть нюансы в обработке.
#define GTCHZNPT_DRAFTBEER          UED::GetRawValue32(UED_RUCHZNPRODTYPE_DRAFTBEER)/*12*/ // @v11.9.2 Пиво разливное
#define GTCHZNPT_DRAFTBEER_AWR      UED::GetRawValue32(UED_RUCHZNPRODTYPE_DRAFTBEER_AWR)/*1012*/ // @v12.0.5 Пиво разливное. Специальная модификация, предполагающая автоматическое списание 
#define GTCHZNPT_DIETARYSUPPLEMENT  UED::GetRawValue32(UED_RUCHZNPRODTYPE_DIETARYSUPPLEMENT)/*13*/ // @v11.9.6 БАДы
#define GTCHZNPT_BEER               UED::GetRawValue32(UED_RUCHZNPRODTYPE_BEER)/*14*/ // @v12.0.3 Пиво фасованное 
#define GTCHZNPT_ANTISEPTIC         UED::GetRawValue32(UED_RUCHZNPRODTYPE_ANTISEPTIC)/*15*/ // @v12.0.5 Антисептик
#define GTCHZNPT_MEDICALDEVICES     UED::GetRawValue32(UED_RUCHZNPRODTYPE_MEDICALDEVICES)/*16*/ // @v12.1.2 Изделия медицинского назначения
#define GTCHZNPT_SOFTDRINKS         UED::GetRawValue32(UED_RUCHZNPRODTYPE_SOFTDRINKS)/*17*/ // @v12.1.10 Соковая продукция и безалкогольные напитки
#define GTCHZNPT_NONALCBEER         UED::GetRawValue32(UED_RUCHZNPRODTYPE_NONALCBEER)/*18*/ // @v12.2.6 Пиво безалкогольное

struct PPGoodsType2 {      // @persistent @store(Reference2Tbl+)
	PPGoodsType2();
	long   Tag;            // Const=PPOBJ_GOODSTYPE
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[28];    // @reserve
	long   ChZnProdType;   //
	double StockTolerance; // Величина толерантности к дефициту либо к излишку товара.
		// Если доступный остаток меньше требуемого на величину, не превышающую StockTolerance
		// то расходуется то, что есть.
	PPID   PriceRestrID;   // ->Ref(PPOBJ_GOODSVALRESTR) Ограничение на цену реализации
	PPID   AmtCVat;        // ->Ref(PPOBJ_AMOUNTTYPE) Сумма НДС в ценах поступления //
	PPID   AmtCost;        // ->Ref(PPOBJ_AMOUNTTYPE) Сумма поступления //
	PPID   AmtPrice;       // ->Ref(PPOBJ_AMOUNTTYPE) Сумма реализации  //
	PPID   AmtDscnt;       // ->Ref(PPOBJ_AMOUNTTYPE) Сумма скидки
	long   Flags;          //
	PPID   WrOffGrpID;     // Группа списания основных фондов (required GTF_ASSETS)
	long   Reserve2;       // @reserve
};

class PPObjGoodsType : public PPObjReference {
public:
	explicit PPObjGoodsType(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Вызывает диалог просмотра списка типов товаров.
	// ARG(extraPtr IN): 0.
	//
	virtual int Browse(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Name, WrOffGrpID, AmtCost, AmtPrice, AmtDscnt, AmtCVat, Flags}
	//
	int    FASTCALL Fetch(PPID id, PPGoodsType *);
	bool   FASTCALL IsUnlim(PPID id);
private:
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjSalesRestriction)
// 
struct PPSalesRestriction { // @flat @persistent @store(Reference2Tbl+)
	PPSalesRestriction();
	PPSalesRestriction & Z();
	long   Tag;            // Const=PPOBJ_SALESRESTRICTION
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	DateRange Period;      // Временные рамки действия ограничения
	uint32 MinAge;         // Минимальный возвраст, с которого продажа возможна 
	long   Flags;          //
	PPID   Reserve2;       // @reserve
	long   Reserve3;       // @reserve
};

class PPObjSalesRestriction : public PPObjReference {
public:
	PPObjSalesRestriction(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsValRestr)
//
struct PPGoodsValRestr { // @flat @persistent
	PPGoodsValRestr();
	long   Tag;            // Const=PPOBJ_GOODSVALRESTR
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[28];    // @reserve
	//
	// Параметры управления отгрузкой
	//
	PPID   ScpShipmOpID;   // Вид операции отгрузки, принимаемый во внимание при быстром анализе продаж/возвратов
	PPID   ScpRetOpID;     // Вид операции возврата, принимаемый во внимание при быстром анализе продаж/возвратов
	long   ScpDurationDays; // Количество дней обзора назад для анализа предыдущих продаж/возвратов
	long   ScpUpDev;       // Допустимая величина верхнего отклонения в промилле от рассчитанного баланса продаж/возвратов //
	long   ScpDnDev;       // Допустимая величина нижнего отклонения в промилле от рассчитанного баланса продаж/возвратов //
	PPID   ScpShipmLimitOpID; // Вид операции драфт-расхода (план продаж), ограничивающий отгрузку операцией ScpShipmOpID за период (по количеству)
	uint8  ScpReserve[8];  // @reserve Зарезервированное пространство для расширения параметров управления отгрузкой
	long   Flags;
	long   Reserve2[2];    // @reserve
};

class PPGoodsValRestrPacket {
public:
	friend class PPObjGoodsValRestr;
	//
	// Descr: Опции ограничений по статьям документов
	//
	enum {
		barMainArOnly    = 1, // Только для выбранной основной статьи
		barMainArDisable,     // Запрет для выбранной основной статьи
		barExtArOnly,         // Только для выбранной дополнительной статьи
		barExtArDisable       // Запрет для выбранной дополнительной статьи
	};
	PPGoodsValRestrPacket();
	int    SetBillArRestr(PPID arID, long option);
	int    RemoveBillArRestr(PPID arID);
	const  ObjRestrictArray & GetBillArRestrictList() const;

	PPGoodsValRestr Rec;
	SString LowBoundFormula;
	SString UppBoundFormula;
private:
	ObjRestrictArray BillArRestr; // Ограничения по статьям документа на внесение товара в документ
};
//
// Descr: Объект, управляющий ограничениями на включение товаров в документы: пределы цены реализации и
//   ограничения по статьям (основной и дополнительной) документа.
// @dbd_exchange Сделать полную синхронизацию пакета PPGoodsValRestrPacket // @done
//
class PPObjGoodsValRestr : public PPObjReference {
public:
	static int TestFormula(const char * pFormula);

	struct GvrItem { // @flat
		PPID   GvrID;
		PPID   ArID;
		int    GvrBarOption;
	};
	class GvrArray : public TSVector <PPObjGoodsValRestr::GvrItem> {
	public:
		GvrArray();
		int    TestGvrBillArPair(PPID gvrID, PPID arID) const;
		int    TestGvrBillExtArPair(PPID gvrID, PPID arID) const;
	private:
		//
		// ARG(what IN): 0 - основная статья документа, 1 - дополнительная статья документа
		//
		int    Helper_TestGvrBillArPair(PPID gvrID, PPID arID, int what) const;
	};

	explicit PPObjGoodsValRestr(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, const PPGoodsValRestrPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPGoodsValRestrPacket * pPack);
	int    SerializePacket(int dir, PPGoodsValRestrPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    IsPacketEq(const PPGoodsValRestrPacket & rS1, const PPGoodsValRestrPacket & rS2, long flags);
	int    ReadBarList(PPID id, ObjRestrictArray & rList);
	int    Fetch(PPID id, PPGoodsValRestrPacket * pPack);
	//
	// Descr: Извлекает через кэш список ассоциаций идентификаторов ограничений с аналитическими статьями,
	//   для которых определены ограничивающие правила для внесения товаров в документы.
	//
	int    FetchBarList(PPObjGoodsValRestr::GvrArray & rList);
private:
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    Helper_ReadBarList(PPID id, PPGoodsValRestrPacket & rPack);
};
//
// @ModuleDecl(PPObjPallet)
//
struct PPPallet {
	long   Tag;            // Const=PPOBJ_PALLET
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	PPDimention Dim;       // Габариты (мм).
	long   MaxLoad;        // Максимальная загрузка (кг)
	char   Reserve[48];    // @reserve
	long   Flags;
	long   Reserve2[2];    // @reserve
};

class PPObjPallet : public PPObjReference {
public:
	explicit PPObjPallet(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsStruc)
//
#define GSF_COMPL          0x00000001L // Допускается комплектация     //
#define GSF_DECOMPL        0x00000002L // Допускается разукомплектация //
#define GSF_PARTITIAL      0x00000008L // Частичная структура
#define GSF_NAMED          0x00000020L // Именованная структура. Однажды будучи присвоен, флаг GSF_NAMED не может быть отобран и такая структура обязана иметь непустое уникальное имя.
#define GSF_OUTPWOVAT      0x00000040L // Выход без НДС
#define GSF_FOLDER         0x00000080L // Структура верхнего уровня.
#define GSF_CHILD          0x00000100L // Дочерняя структура (не может быть именованной)
#define GSF_AUTOWROFF      0x00000200L // Автоматическое списание в техн сессиях (исключен ручной ввод)
#define GSF_SUBST          0x00000400L // Структура подстановки (позиции, которые можно использовать вместо той,
	// к которой относится структура). Исключает GSF_COMPL и GSF_DECOMPL
	// @#{GSF_SUBST ^ (GSF_COMPL|GSF_DECOMPL|GSF_PARTITIAL)}
#define GSF_DYNGEN         0x00000800L // @transient Структура принадлежит динамическому обобщению
#define GSF_PRESENT        0x00001000L // Подарок
#define GSF_GIFTPOTENTIAL  0x00002000L // Информировать кассира о близкой возможности предоставления подарка
#define GSF_COMPLEX        0x00004000L // Комплекс
#define GSF_POSMODIFIER    0x00008000L // POS-модификаторы (только в комбинации с GSF_PARTITIAL)
#define GSF_OVRLAPGIFT     0x00010000L // Подарок с "перекрытием": такой подарок назначается независимо от того,
	// что по некоторым позициям были выданы другие подарки. При этом два и более подарка с перекрытием взаимно исключаются.
// #define GSF_RECOMPL        0x00020000L // Допускается рекомплектацию //
#define GSF_AUTODECOMPL    0x000020000L // @v11.6.2 Допускается автоматическая декомплектация в случае дефицита одного или нескольких компонентов
	// в операциях списания техн сессий.
#define GSF_PRICEPLANNING  0x000040000L // @v12.0.6 @construction Специальный вид структуры для планирования стоимости продаж
//
// Descr: Дескрипторы, определяющие специальные правила установки цен на товарные позиции,
//   составляющие подарочную комбинацию.
//
#define GSGIFTQ_CHEAPESTITEMFREE    0x40000001 // Самая дешевая позиция из комбинации - бесплатно.
#define GSGIFTQ_LASTITEMBYGIFTQ     0x40000002 // Последняя (и только) штука одного наименования - по котировке PPQUOTK_GIFT
#define GSGIFTQ_CHEAPESTITEMBYGIFTQ 0x40000003 // Самая дешевая позиция из комбинации - по котировке PPQUOTK_GIFT
//
// Descr: Заголовок товарной структуры.
//
struct PPGoodsStrucHeader2 { // @persistent @store(Reference2Tbl+)
	PPGoodsStrucHeader2();
	long   Tag;              // Const=PPOBJ_GOODSSTRUC
	long   ID;               //
	char   Name[48];         // @name
	char   Symb[20];         //
	char   Reserve[24];      // @reserve
	float  GiftLimit;        // Предельное количество подарков, которое может быть выдано на чек по данной структуре
	PPID   GiftQuotKindID;   // Вид котировки, применяемый для установки цен на товары, к которым применяется подарок.
		// Если GiftQuotKindID & 0x40000000, то этот идентификатор представляет специальное правило установки скидки
		// на позиции, составляющие подарочную комбинацию (GSGIFTQ_XXX).
	double GiftAmtRestrict;  // Сумма, которой должна достичь комбинация компонентов для начисления подарка.
	PPID   VariedPropObjType; // Тип объекта изменяющейся характиристики заголовочного товара структуры и элементов структуры.
	DateRange Period;        // Период актуальности структуры
	double CommDenom;        // Общий делитель для компонентов структуры.
	long   Flags;            // GSF_XXX
	PPID   ParentID;         // Родительская структура
	long   Reserve2;         // @reserve
};
//
// Descr: Флаги компонентов товарной структуры
//
#define GSIF_PCTVAL      0x0001L // Оценочный интервал в %%
#define GSIF_ROUNDDOWN   0x0002L // При использовании отбрасывать дробную часть
#define GSIF_PHUVAL      0x0004L // Оценочный интервал в физических единицах
#define GSIF_UNCERTPRICE 0x8000L // Не удалось выяснить точную цену компонента
#define GSIF_AUTOTSWROFF 0x0008L // Автосписание в технологических сессиях в случае, если этот товар не присутствует в строках сессии.
#define GSIF_QTTYASPRICE 0x0010L // Только для нелимитированных ресурсов. Количество устанавливать в 1, а цену в процентах от суммы основного товара.
#define GSIF_MAINITEM    0x0020L // Основной компонент структуры (используется в производственных отчетах)
#define GSIF_FORMULA     0x0040L // Компонент содержит формулу для расчета количества
#define GSIF_SUBPARTSTR  0x0080L // Вычитать количество этого компонента из количества основного товара применяя частичную структуру.
#define GSIF_GOODSGROUP  0x0100L // Вместо товара в поле PPGoodsStrucItem::GoodsID установлена
	// товарная группа. Это необходимо для специальных подарков, распространяемых на целую товарную группу.
#define GSIF_IDENTICAL   0x0200L // Для подарочных структур: заданное количество применимо только для одинаковых позиций.
#define GSIF_QUERYEXPLOT 0x0400L // При автоматическом внесении компонента в документ как расходной строки запрашивать выбор лота
#define GSIF_BIZSC2      0x0800L // @v12.0.6 Вместо товара в поле PPGoodsStrucItem::GoodsID установлен индикатор (бизнес-показатель). 
	// Используется в структурах планирования стоимости продаж (GSF_PRICEPLANNING)

struct PPGoodsStrucItem {  // @persistent(DBX) @size=52 @flat
	//
	// Descr: Статическая реализация определения эффективного количества компонента на complQtty
	//   результирующего товара.
	//
	static int FASTCALL GetEffectiveQuantity(double complQtty, PPID goodsID, double median, double denom, long flags, double * pItemQtty);
	static SString & FASTCALL MakeEstimationString(double median, double denom, SString & rBuf, long format = 0);
	PPGoodsStrucItem();
	int    FASTCALL operator == (const PPGoodsStrucItem & rS) const;
	int    FASTCALL operator != (const PPGoodsStrucItem & rS) const;
	int    FASTCALL IsEq(const PPGoodsStrucItem & rS) const;
	int    SetEstimationString(const char *);
	SString & GetEstimationString(SString &, long format = 0) const;
	int    SetFormula(const char * pStr, const PPGoodsStruc * pStruc);
	int    GetQtty(double complQtty, double * pItemQtty) const;
	int    GetQttyAsPrice(double complPriceSum, double * pItemPrice) const;

	PPID   GoodsID;        // Если элемент принадлежит структуре типа PPGoodsStruc::kPricePlanning то здесь может быть бизнес-показатель.
		// В этом случае Flags & GSIF_BIZSC2
	long   Flags;          // GSIF_XXX Флаги
	double Median;         // Среднее значение оценочного интервала
	// @v12.3.7 (unused) double Width__;        // Ширина оценочного интервала
	double ManualValue;    // @v12.3.7 Значение, установленное в ручную (для структур с флагом GSF_PRICEPLANNING)
	double Denom;          // Знаменатель простой дроби, которая определяет количество компонента
		// Если Denom == 0, то это эквивалентно Denom = 1
	double Netto;          //
	// @construction PPID   PrefInnerGsID;  // Предпочтительная структура комплектации/декомплектации для внутреннего элемента
		// @dbd_exchange Требуется синхронизация //
	char   Symb[20];       // Символ элемента структуры (для ссылки из формул)
	PPID   ObjType;        // @v12.0.6 @todo @dbx Тип объекта, идентификатор которого указан в поле GoodsID.
		// Это - переключатель, актуальный только для структур планирования цены товара. 
		// Значение 0 трактуется как PPOBJ_GOODS (для обратной совместимости). Допускается: 0 || PPOBJ_GOODS || PPOBJ_ARTICLE || PPOBJ_BIZSCORE2
	// @v12.3.6 PPID   AccSheetID;     // @v12.0.6 @todo @dbx Таблица аналитический статей для указания статьи в поле ItemGoodsID (для PPGoodsStruc::kPricePlanning)
	PPID   Reserve; // @v12.3.6
	char   Formula__[64];      // @transient
};

class PPGoodsStruc : public PPExtStrContainer { // @v12.0.6 унаследован от PPExtStrContainer с целью хранения текстовых строк расширения //
public:
	struct Ident {
		explicit Ident(PPID goodsID = 0, long andF = 0, long notF = 0, LDATE = ZERODATE);
		enum {
			oAnyOfAndFlags = 0x0001
		};
		PPID   GoodsID;
		long   Options;
		long   AndFlags;
		long   NotFlags;
		LDATE  Dt;
	};
	//
	// Descr: Виды структур.
	//
	enum {
		kUndef = 0,    // Неопределенный
		kBOM   = 1,    // Комплектация/декомплектация //  GSF_COMPL|GSF_DECOMPL|GSF_RECOMPL
		kPart,         // Частичная структура             GSF_PARTITIAL
		kSubst,        // Подстановочная структура        GSF_SUBST
		kGift,         // Подарочная //                   GSF_PRESENT
		kComplex,      // Комплекс                        GSF_COMPLEX
		kPricePlanning // @v12.0.6 @construction Планирование стоимости продаж GSF_PRICEPLANNING
	};
	//
	// Descr: Вспомогательный класс, обеспечивающий кэширующий расчет значений, соответствующих элементам структуры по формулам.
	//
	class FormulaResolutionCache {
	public:
		FormulaResolutionCache(const PPGoodsStruc & rGs);
		int    Resolve(uint itemIdx, double * pValue);
	private:
		//
		// Descr: Рассчитывае параметр хэширования элемента структуры. Этот параметр должен учитывать
		//   все важные факторы структуры дабы при изменении какого либо из них кэш утратил актуальность.
		//
		uint32 MakeStrucSeed() const;
		long   MakeItemKey(uint itemIdx) const;
		bool   SearchCacheForResult(uint itemIdx, long * pKey, double * pValue) const;

		PPObjBizScore2 BsObj;
		const PPGoodsStruc & R_Gs;
		RAssocArray ResultCache;
	};
	static int FASTCALL IsSimpleQttyString(const char * pStr);
	static int FASTCALL GetStrucKind(long flags);
	static SString & MakeTypeString(PPID strucID, long flags, PPID parentStrucID, SString & rBuf);
	PPGoodsStruc();
	PPGoodsStruc(const PPGoodsStruc & rS);
	void   Init();
	PPGoodsStruc & FASTCALL operator = (const PPGoodsStruc &);
	PPGoodsStruc & FASTCALL Copy(const PPGoodsStruc & rS);
	bool   FASTCALL IsEq(const PPGoodsStruc &) const;
	bool   IsEmpty() const;
	bool   IsNamed() const;
	bool   CanExpand() const;
	bool   CanReduce() const;
	SString & FASTCALL GetTypeString(SString & rBuf) const;
	int    SetKind(int kind);
	int    GetKind() const;
	//
	// Descr: Возвращает общий делитель структуры. Если Rec.CommDenom == 0, то возвращается 1.
	//
	double GetDenom() const;
	//
	// Descr: Возвращает указатель на основной компонент структуры (такой компонент
	//   имеет признак GSIF_MAINITEM). Если основной компонент найден, то
	//   по указателю pPos присваивается позиция основного компонента.
	//
	const  PPGoodsStrucItem * GetMainItem(uint * pPos) const;
	//
	// Descr: Умножает количество *pQtty на соотношение физических/торговых единиц
	//   определенное для основного компонента структуры.
	// Returns:
	//   >0 - структура имеет основной компонент у которого определен коэфф PhUPerU.
	//       Функция умножила величину *pQtty на этот коэффициент.
	//  <0  - либо структура не имеет основного компонента, либо этот компонент не
	//       имеет определенного коэффициента PhUPerU.
	//
	int    RecalcQttyByMainItemPh(double * pQtty) const;
	//
	// Descr: Получает эффективное значение по строке для структуры, имеющей вид kPricePlanning.
	//   Если в строке задано ненулевое ручное значение, то возвращается оно, в противном случае, 
	//   если в строке задана формула, то значение вычисляется по ней. Если же и локальной формулы не
	//   задано, то функция обращается к показателю (PPObjBizScore2), который ассоциирован со строкой
	//   и вычисляет значение показателя.
	//
	int    GetItemValue(uint itemIdx, PPGoodsStruc::FormulaResolutionCache * pRCache, double * pValue) const;
	int    ResolveItemFormula(const PPGoodsStrucItem & rItem, double * pValue) const;
	int    GetEstimationPrice(uint itemIdx, PPID locID, double * pPrice, double * pTotalPrice, ReceiptTbl::Rec * pLotRec) const;
	void   CalcEstimationPrice(PPID locID, double * pPrice, int * pUncertainty, int calcInner) const;
	int    FASTCALL HasGoods(PPID goodsID) const;
	int    SearchSymb(const char * pSymb, uint * pPos) const;
	int    CopyItemsFrom(const PPGoodsStruc * pS);
	int    MoveItem(uint pos, int dir  /* 0 - down, 1 - up */, uint * pNewPos);
	//
	// Descr: Перечисляет элементы структуры с вычислением количества, необходимого
	//   для комплектации srcQtty единиц составного товара. Требуемое количество
	//   возвращается по указателю pQtty. Для получения первого элемента по указателю pPos
	//   следует передать значение 0.
	//   Функция, после каждого успешного вызова, увеличивает значение *pPos на единицу.
	// Returns:
	//   >0 - Функция успешно вернула следующий элемент
	//   <0 - По индексу *pPos элемента нет
	//
	int    EnumItemsExt(uint * pPos, PPGoodsStrucItem * pItem, PPID parentGoodsID, double srcQtty, double * pQtty) const;
	int    GetItemExt(uint pos, PPGoodsStrucItem * pItem, PPID parentGoodsID, double srcQtty, double * pQtty) const;
	//
	// Descr: Преобразует структуру в родительскую, перенося при этом содержимое структуры
	//   в первую дочернюю. Функция применима, если !(Rec.Flags & (GSF_FOLDER | GSF_CHILD)).
	// Returns:
	//   >0 - Структура успешно переведена в родительскую
	//    0 - Ошибка
	//   <0 - Структура уже является родительской
	//
	int    Expand();
	//
	// Descr: Преобразует родительскую структуру в одноуровневую. Функция применима только
	//   к родительским структурам, имеющим не более одной дочерней структуры.
	//   Все элементы дочерней структуры переходят в собственность родительской, дочерняя структура
	//   удаляется, а родительская теряет флаг GSF_FOLDER.
	// Returns:
	//  >0 - Структура успешно редуцирована
	//   0 - Ошибка
	//  <0 - Структура не является родительской
	//
	int    Reduce();
	int    Select(const Ident & rIdent, PPGoodsStruc * pGs) const;
	int    Select(const Ident & rIdent, TSCollection <PPGoodsStruc> & rList) const;
	int    GetItemQtty(PPID goodsID, double complQtty, double * pQtty) const;
	SString & MakeChildDefaultName(SString & rBuf) const;
	//
	// ARG(recursiveUnrollIncome IN): @v11.2.4 рекурсивно "раскручивать" входящие позиции, которые имеют собственную структуру декомплектации
	//
	int    InitCompleteData(PPID goodsID, double needQty, const PPBillPacket * pBillPack, PPComplBlock & rData, bool recursiveUnrollIncome);
	int    InitCompleteData2(PPID goodsID, double needQty, PPComplBlock & rData);
	//
	// Поле GoodsID не является неотъемлемой частью структуры товара, поскольку одна структура
	// может принадлежать нескольким товарам. Это поле используется как справочное и может быть
	// равно нулю. Функции, загружающие или инициализирующие структуру должны сами
	// заботится об инициализации этого поля.
	//
	PPID   GoodsID; // @transient
	mutable const PPComplBlock * P_Cb; // @transient Предварительный массив товарных строк для вставки в документа.
		// Необходим для обсчета компонентов по формулам.
	PPGoodsStrucHeader Rec;
	TSVector <PPGoodsStrucItem> Items;  //
	TSCollection <PPGoodsStruc> Children; // Используется только если (Flags & GSF_FOLDER)
private:
	int    SubstVariedProp(PPID parentGoodsID, PPGoodsStrucItem * pItem) const;
		// @<<PPGoodsStruc::EnumItemsExt
	int    Helper_Select(const Ident & rIdent, TSCollection <PPGoodsStruc> & rList) const;
	int    RecursiveUnrollIncome(PPID goodsID, double reqQtty, const PPBillPacket * pBillPack, PPComplBlock & rData);
};

struct GStrucRecurItem { // @flat
	PPGoodsStrucItem Item; //
	PPID   LastLotID;      //
	double Qtty;           //
	double Price;          //
	double Sum;            //
	int    Level;          //
	int    HasInner;       // Признак того, что элемент имеет вложенную структуру
};

class GStrucIterator {
public:
	GStrucIterator();
	const  PPGoodsStruc * GetStruc() const;
	void   Init(const PPGoodsStruc * pStruc, int loadRecurItems);
	void   InitIteration();
	int    FASTCALL NextIteration(GStrucRecurItem * pItem);
private:
	int    LoadItems(const PPGoodsStruc * pStruc, PPID parentGoodsID, double srcQtty, int level);

	int    LoadRecurItems;
	uint   Idx;
	PPGoodsStruc GStruc;
	TSVector <GStrucRecurItem> Items;
};
//
// Descr: Элемент списка автоматической разукомплектации по товарным структурам с признаком GSF_AUTODECOMPL
//
class SaAutoDecomplItem { // @flat
public:
	PPID   GoodsID; // Ид товара
	PPID   StrucID;
	double Qtty;    // Количество, которое может быть получено при разбиении одной единицы титульного товара структуры 
};
//
// Descr: Блок данных для подбора аналогичных товаров по подстановочным структурам
//
class SaSubstBlock { // @v11.6.6
	friend class PPObjGoodsStruc;
public:
	SaSubstBlock();
	SaSubstBlock & Z();
	int    Get(PPID goodsID, RAssocArray & rSubstList) const;
private:
	struct Item {
		Item(PPID goodsID, uint rank, double rate);
		PPID   GoodsID;
		uint   Rank; // @v11.6.7 Ранг подстановки. Чем меньше значение, тем выше приоритет использования //
		double Rate;
	};
	struct Entry {
		Entry();
		PPID   GsID;
		TSVector <Item> V;
	};
	struct IndexEntry {
		PPID   GoodsID;
		uint   P;
	};

	Entry * GetEntry(PPID gsID);
	int    AddItem(Entry * pEntry, PPID goodsID, uint rank, double rate);

	TSCollection <Entry> L;
	TSVector <IndexEntry> Index;
};
//
// Descr: Элемент списка продаж, используемый для подбора подарка на основе подарочных структур (GSF_PRESENT)
//
struct SaSaleItem { // @flat
	PPID   GoodsID;
	double Qtty;
	double Price;
};
//
// Descr: Структура комбинации, по которой может быть выдан подарок за покупку
//
class SaGiftItem {
public:
	enum {
		fCalcPotential = 0x0001,
		fOverlap       = 0x0002
	};
	//
	// Descr: Структура элемента комбинации, по которой выдается подарок
	//
	struct Entry {
		PPIDArray GoodsList;
		PPID   OrgGoodsID; // Идентификатор товара, указанный в компоненте структуры (может быть обобщенным).
			// Если OrgGoodsID - обобщенный, то список GoodsList содержит все элементы обобщения, в
			// противном случае GoodsList.get(0) == OrgGoodsID
		double MinQtty;
		long   GsiFlags;   // Копия поля PPGoodsStrucItem::Flags
	};
	//
	SaGiftItem();
	SaGiftItem(const SaGiftItem &);
	SaGiftItem & FASTCALL operator = (const SaGiftItem &);
	//
	// Descr: Копирует экземпляр класса pS в this. Если pS == 0, то очищает this.
	//
	int    FASTCALL Copy(const SaGiftItem * pS);
	int    IsSaleListSuitable(const TSVector <SaSaleItem> & rSaleList, RAssocArray * pCheckList, LongArray * pMainPosList, double * pQtty) const;
	int    CalcPotential(const TSVector <SaSaleItem> & rSaleList, PPID * pPotGoodsID, double * pPotAmount, double * pPotDeficit, SString & rPotName) const;

	PPID   StrucID;        // Ид товарной структуры (подарочной)
	PPID   OrgStrucID;     // Структура, родительская к StrucID самого верхнего уровня.
		// Если StrucID не имеет родительской структуры, то OrgStrucID == StrucID
	PPID   QuotKindID;     // Вид котировки, применяемый как подарочная цена на купленные товары
	long   Flags;          //
	float  Limit;          // Предельное количество подарков, которое может быть выдано по одному чеку.
	double AmtRestrict;    // Минимальная сумма продажи, на которую начисляется подарок
	PPIDArray GiftList;    // Список идентификаторов товаров-подарков
	TSCollection <SaGiftItem::Entry> List; // Список проданных товаров, по которым полагается подарок
};
//
// Descr: Структура списка подарков, которые могут быть выданы при покупке одной из заданных комбинаций товаров
//
class SaGiftArray : public TSCollection <SaGiftItem> {
public:
	struct Potential {
		PPID   GoodsID;   // ИД товара, который осталось докупить до получения подарка
		double Amount;    // Общая сумма покупки оговоренных товаров для получения подарка
		double Deficit;   // Недостающая для получения подарка сумма покупки
		SString Name;     // Наименование потенциального подарка
	};
	//
	// Descr: Результирующая структура выбора подарка.
	//
	struct Gift {
		Gift();
		Gift & Z();
		void   FASTCALL PreservePotential(SaGiftArray::Potential & rS) const;
		void   FASTCALL RestorePotential(const SaGiftArray::Potential & rS);
		int    FASTCALL IsEqualForResult(const Gift & rS) const;

		PPID   ID;           // Идентификатор структуры подарка
		double Qtty;         // Количество торговых единиц товара, составляющего подарок
		PPID   QuotKindID;   // Вид котировки, применяемый в качестве подарка к проданным позициям.
		PPIDArray List;      // Список идентификаторов товаров-подарков (владельцев подарочных структур)
		RAssocArray CheckList; // Список идентификаторов товаров, продажа которых принята в качестве условия предоставления подарка.
			// Каждый идентификатор ассоциирован с минимальным количеством, которое, в соответствии со структурой, может быть принято для предоставления подарка.
		LongArray MainPosList; // Список индексов позиций в CheckList, помеченных в подарочной структуре флагом GSIF_MAINITEM
		SaGiftArray::Potential Pot; // Информация о возможности получения наиболее близкого к чеку подарка
	};

	SaGiftArray();
	SaGiftArray(const SaGiftArray &);
	SaGiftArray & FASTCALL operator = (const SaGiftArray &);
	int    FASTCALL Copy(const SaGiftArray * pS);
	int    CreateIndex();
	int    SelectGift(const TSVector <SaSaleItem> & rSaleList, const RAssocArray & rExGiftList, int overlap, SaGiftArray::Gift & rGift) const;
private:
	LAssocArray Index; // Key - StrucID, Val - GoodsID
};

class PPObjGoodsStruc : public PPObjReference {
public:
	static  int    EditDialog(PPGoodsStruc *, int toCascade = 0);
	static  int    CheckRecursion();
	//
	// @attention !!!
	// Если необходимо получить только заголовок структуры, то следует
	// использовать функцию Search в которой вторым параметром должен
	// быть указатель на PPGoodsStrucHeader, а не на PPGoodsStruc.
	//
	explicit PPObjGoodsStruc(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr /*goodsID*/);
	virtual int  Browse(void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPGoodsStrucHeader * pRec);
	int    GetChildIDList(PPID id, PPIDArray * pList);
	int    Get(PPID id, PPGoodsStruc * pGs);
	int    Put(PPID * pID, PPGoodsStruc * pGs, int use_ta);
	int    Print(PPGoodsStruc *);
	int    CheckStruc(PPID strucID, PPLogger *);
	int    LoadAutoDecomplList(TSVector <SaAutoDecomplItem> & rList);
	int    LoadSubstBlock(SaSubstBlock & rBlk); // @v11.6.6
	int    LoadGiftList(SaGiftArray * pList);
	int    FetchGiftList(SaGiftArray * pList);
	int    FetchSubstList(PPID goodsID, RAssocArray & rSubstList);
	int    SelectorDialog(const TSCollection <PPGoodsStruc> & rList, uint * pSelectionPos);
	int    SelectorDialog(PPID * pNamedGsID);
	int    CheckStructs();
	struct CheckGsProblem : public SCompoundError { // @v12.1.11 inherited from SCompoundError
		enum {
			errRecur = 1,      // Рекурсивная структура
			errUnRef,          // Ни один товар не ссылается на структуру
			errNoNameAmbig,    // На неименованную структуру ссылается более одного товара
			errNamedEmptyName  // Именованная структура содержит пустое наименование
		};
		// @v12.1.11 PPID   GsID;
		// @v12.1.11 int    RowN;
		// @v12.1.11 int    Code;
		// @v12.1.11 SString Text;
	};
	int    CheckStruct(PPIDArray * pGoodsIDs, PPIDArray * pStructIDs, const PPGoodsStruc * pStruct,
		TSCollection <CheckGsProblem> * pProblemList, PPLogger * pLogger);
	// @v12.2.4 @construction {
	// Далее - просто прикидка по поводу как реализовывать экспорт/импорт товарных структур.
	// Общая идея такова, чтоб использовать предопределенный собственный формат (xml and (or) json).
	// Основные проблемы - в идентификации товаров при импорте.
	//
	// Descr: Параметры импорта/экспорта товарных структур
	//
	struct ImpExpParam {
		ImpExpParam()
		{
		}
	};
	int    Export(const PPIDArray & rStrucIdList, const ImpExpParam & rParam, const char * pFileName);
	int    Import(const char * pFileName, const ImpExpParam * pParam);
	// } @v12.2.4 @construction 
private:
	static  int  EditExtDialog(PPGoodsStruc *);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*goodsID*/);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	int    Helper_LoadItems(PPID id, PPGoodsStruc * pData);
	int    SerializePacket(int dir, PPGoodsStruc * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};

int LoadGoodsStruc(const PPGoodsStruc::Ident & rIdent, PPGoodsStruc * pGs);
//
// @ModuleDecl(PPObjGoodsTax)
// Товарные налоговые группы
//
#define GTAXF_ABSEXCISE   0x0001L
#define GTAXF_USELIST     0x0002L // Налоговая группа состоит из списка
#define GTAXF_ENTRY       0x0004L //
#define GTAXF_ZEROEXCISE  0x0008L // @transient Группа (включая списочные элементы)
	// без акциза (инициализируется при загрузке пакета группы функцией PPObjGoodsTax::GetPacket())
#define GTAXF_NOLOTEXCISE 0x0010L // При расчете входящих налогов (на лот) акциз исключать
#define GTAXF_SPCVAT      0x0020L // @v12.2.3 Специальная ставка НДС. Применяется к конкретному налогоплательщику независимо от того, 
	// по какой ставке облагается товар. В общем, это - та хрень, которую вводят в России с 2025 года (5% и 7%)
#define GTAXF_GENERALVAT  0x0040L // @v12.2.5 Если налоговая схема принадлежит персоналии или локации, то установка
	// этого флага означает, что персоналия либо локация находится на общей схеме уплаты НДС. То есть, ставка НДС
	// в этом случае берется из товара.
	// Флаг необходим для того, чтобы была возможность определить схему налогообложения, зависящую от периода в 
	// течении которого налогоплательщик платит НДС на общих основаниях (если в соседних периодах у него специальный режим).
	// @#(GTAXF_SPCVAT^GTAXF_GENERALVAT)

struct PPGoodsTaxEntry { // @flat
	static const PPGoodsTaxEntry & GetVatFreeEntry()
	{
		static PPGoodsTaxEntry entry(0.0, GTAXF_ENTRY|GTAXF_SPCVAT);
		return entry;
	}
	PPGoodsTaxEntry();
	int    FASTCALL IsEq(const PPGoodsTaxEntry & rS) const;
	PPGoodsTaxEntry & Z();
	double GetVatRate() const;
	SString & FormatVAT(SString & rBuf) const;
	SString & FormatExcise(SString & rBuf) const;
	SString & FormatSTax(SString & rBuf) const;

	PPID   TaxGrpID;       //
	DateRange Period;      //
	PPID   OpID;           //
	long   VAT;            // prec 0.01
	long   Excise;         // prec 0.01
	long   SalesTax;       // prec 0.01
	long   Flags;          // GTAXF_XXX
	long   Order;          // Порядок начисления налогов
	long   UnionVect;      //
private:
	PPGoodsTaxEntry(double vat, long flags);
};

struct PPGoodsTax2 {       // @persistent @store(Reference2Tbl+)
	PPGoodsTax2();
	void   FASTCALL ToEntry(PPGoodsTaxEntry *) const;
	void   FASTCALL FromEntry(const PPGoodsTaxEntry *);
	PPID   Tag;            // Const=PPOBJ_GOODSTAX
	PPID   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[36];    // @reserve
	double VAT;            //
	double Excise;         //
	double SalesTax;       //
	long   Flags;          //
	long   Order;          //
	long   UnionVect;      //
};

class PPGoodsTaxPacket : private SVector {
public:
	PPGoodsTaxPacket();
	PPGoodsTaxPacket & FASTCALL operator = (const PPGoodsTaxPacket &);
	uint   GetCount() const;
	PPGoodsTaxEntry & FASTCALL Get(uint idx) const;
	int    PutEntry(int pos, const PPGoodsTaxEntry *);
	void   Sort();
	//
	// Descr: Calls SVectot::insert(&rEntry)
	//
	int    FASTCALL Insert(const PPGoodsTaxEntry & rEntry);
	SVector * vecptr();

	PPGoodsTax Rec;
};

class PPObjGoodsTax : public PPObjReference {
public:
	static long  GetDefaultOrder();
	static int   ReplaceGoodsTaxGrp();
	static int   IsIdentical(const PPGoodsTax * pRec1, const PPGoodsTax * pRec2);
	static int   Fetch(PPID taxGroupID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx);
	static int   FetchByID(PPID taxGroupID, PPGoodsTaxEntry * pGtx);

	explicit PPObjGoodsTax(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    IsPacketEq(const PPGoodsTaxPacket & rS1, const PPGoodsTaxPacket & rS2, long flags);
	int    Search(PPID id, PPGoodsTaxEntry * pEntry);
	int    Search(PPID id, PPGoodsTax * pRec);
	int    AddBySample(PPID * pID, long sampleID);
	int    GetByScheme(PPID * pID, double vat, double excise, double stax, long flags, int use_ta);
	void   GetDefaultName(const PPGoodsTax * pRec, char * buf, size_t buflen);
	//
	// Descr: Ищет налоговую группу, аналогичную по схеме налогообложения записи pPattern.
	//
	int    SearchIdentical(const PPGoodsTax * pPattern, PPID * pID, PPGoodsTax * pRec);
	int    SearchAnalog(const PPGoodsTax * pSample, PPID * pID, PPGoodsTax * pRec);
	int    Test(PPID);
	int    FormatOrder(long order, long unionVect, SString & rBuf);
	int    StrToOrder(const char *, long * pOrder, long * pUnionVect);
	int    GetPacket(PPID id, PPGoodsTaxPacket *);
	int    PutPacket(PPID * pID, PPGoodsTaxPacket *, int use_ta);
	int    SerializePacket(int dir, PPGoodsTaxPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// GTaxVect
//
#define GTAX_NONE          0
#define GTAX_VAT           1
#define GTAX_EXCISE        2
#define GTAX_SALES         3

#define GTAXVF_AFTERTAXES  0x00000001L // Without any operational taxes
#define GTAXVF_VAT         0x00000002L
#define GTAXVF_EXCISE      0x00000004L
#define GTAXVF_SALESTAX    0x00000008L
#define GTAXVF_BEFORETAXES 0x80000000L // With all operational taxes
#define GTAXVF_NOMINAL     0x08000000L // Флаг, применяемый для того, чтобы рассчитать суммы налогов исходя из номинальных налоговых 
	// групп по товарам (опуская признаки освобождения от НДС и входящие налоговые группы по лотам).
	// Может быть использован только в аргументе exclFlags функции GTaxVect::CalcTI().

class GTaxVect {
public:
	class EvalBlock { // @v12.2.4
		friend class GTaxVect;
	public:
		EvalBlock();
		EvalBlock(const PPBillPacket & rBPack, int tiIdx, int tiamt/*TIAMT_XXX*/, long exclFlags, int correctionFlag);
		EvalBlock(const PPBillPacket & rBPack, const PPTransferItem & rTi, int tiamt/*TIAMT_XXX*/, long exclFlags, int correctionFlag);
		EvalBlock(const PPTransferItem & rTi, PPID opID, int tiamt/*TIAMT_XXX*/, long exclFlags, int correctionFlag);
		EvalBlock(const CCheckPacket & rCc, CCheckLineTbl::Rec & rCcRow, long exclFlags);
	private:
		PPID   GetMainOrgPersonID(const BillTbl::Rec * pBillRec) const;
		PPID   GetSupplPersonID(const PPTransferItem * pTi) const;
		PPID   GetSupplPersonID_() const;
		const  PPTransferItem * GetTI() const;
		PPID   GetLocID() const;
		LDATE  GetOpDate();
		const  PPBillPacket * P_BPack;
		const  PPTransferItem * P_Ti;
		const  PPGoodsTaxEntry * P_Gte; // Если P_Ti != 0 then ignored
		const  CCheckPacket * P_CcPack; //
		const  CCheckLineTbl::Rec * P_CcRow;
		int    TiIdx;          // Если P_Ti == 0 && P_BPack != 0 && TiIdx >= 0 && TiIdx < P_BPack->GetTCount(), то элемент PPTransferItem извлекается как P_BPack->ConstTI(TiIdx)
		PPID   OpID;           // if P_BPack != 0 then ignored
		int    TiAmt;          // TIAMT_XXX
		long   ExclFlags;      //
		int    CorrectionFlag; // processed cases: 0, <0, >0
		PPID   MainOrgID;      // Если 0, то возможно определение из контекста (P_BPack)
		PPID   SupplPsnID;     // Если 0, то возможно определение из контекста (P_BPack, P_Ti)
		double Amount;         // if P_Ti != 0 then ignored 
		double Qtty;           // if P_Ti != 0 then ignored
	};
	static int Test(PPID gtaxID);
	static int GetTaxNominalAmountType(const BillTbl::Rec & rBillRec); // @v12.2.4
	explicit GTaxVect(int roundPrec = 2);
	bool   FASTCALL IsEq(const GTaxVect & rS) const;
	GTaxVect & Z();
	//
	// Descr: Новый вариант централизованного расчета налогов. Возник из-за ввода тупой российской властью
	//   специальных ставок НДС. 
	//
	int    EvaluateTaxes(const EvalBlock & rBlk); // @v12.2.4
	void   Calc_(const PPGoodsTaxEntry & rGtEntry, double amount, double qtty, long amtFlags, long excludeFlags = 0);
	//
	// ARG(correctionFlag IN): Флаг расчета сумм по строке корректирующего документа.
	//  0 - как разница между новыми значениями и старыми
	// -1 - по изначальным значениям (до корректировки)
	//  1 - по финальным значениям (после корректировки)
	//
	int    CalcTI(const PPTransferItem & rTi, PPID opID, int tiamt/* TIAMT_XXX */, long exclFlags = 0L, int correctionFlag = 0);
	int    CalcBPTI(const PPBillPacket & rBp, const PPTransferItem & rTi, int tiamt/* TIAMT_XXX */, long exclFlags = 0L, int correctionFlag = 0); // @v12.2.4
	double FASTCALL GetValue(long flags /* mask GTAXVF_XXX */) const;
	double GetTaxRate(long taxID/* GTAX_XXX */, bool * pIsAbs) const;
private:
	//
	// Descr: Внутренняя структура, обеспечивающая атрибуты расчета налогов, зависящие только от товара
	//
	struct WareBlock {
		WareBlock(PPObjGoods & rGObj, PPID goodsID, PPID lotID, long exclFlags);
		PPID   GoodsID;
		PPID   LotID;      // Ид лота. Важно! Конструктор не пытается использовать этот ид для получения налоговой группы.
		PPID   TaxGroupID; // Налоговая группа, принадлежащая товару (точно - не лоту lotID)
		bool   IsFound;    // Признак того, что запись товара goodsID существует.
		bool   IsAsset;    //
		bool   IsExclVat;  //
		double TaxFactor;  // 
	};
	int    FASTCALL TaxToVect(int) const;
	int    FASTCALL VectToTax(int) const;
	void   CalcForward(int n, double amount);
	void   CalcBackward(int n, double amount);
	double CalcTaxValByBase(int idx, double base) const;
	int    CalcTI_Implement(const PPTransferItem & rTi, PPID opID, int tiamt/*TIAMT_XXX*/, long exclFlags, int correctionFlag);

	const  int  RoundPrec;
	const  long N;
	long   AbsVect;
	long   UnionVect;
	long   OrderVect[8];
	double RateVect[8];
	double Vect[8];
	double Amount;
	double Qtty;
};
//
//
//
class PPObjFormula : public PPObjReference {
public:
	explicit PPObjFormula(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    Get(PPID id, SString & rName, SString & rExpr);
	int    Put(PPID * pID, const char * pName, const char * pExpr, int use_ta);
	//
	// Descr: Вызывает диалог просмотра списка формул.
	// ARG(extraPtr IN): 0.
	//
	virtual int Browse(void * extraPtr);
	// Private: for conversion use only
	// @obsolete @v4.9.3 int    GetBefore290(PPID id, char * pName, char * pBuf, size_t buflen);
};
//
// @ModuleDecl(PPObjRegisterType)
// Тип регистрационного документа (PPOBJ_REGISTERTYPE)
//
#define REGTF_UNIQUE      0x0001L // 'U' Персоналия не может содержать более одного документа такого типа
#define REGTF_PRIVATE     0x0002L // 'P' Разрешен для физ. лиц
#define REGTF_LEGAL       0x0004L // 'L' Разрешен для юр. лиц (REGTF_PRIVATE ^ REGTF_LEGAL)
#define REGTF_WARNEXPIRY  0x0008L // Предупреждать об истечении срока действия //
#define REGTF_INSERT      0x0010L // Вводить документ при вводе персоналии
#define REGTF_WARNABSENCE 0x0020L // Предупреждать об отсутствии регистра у персоналии //
#define REGTF_DUPNUMBER   0x0040L // 'D' Номер регистра может быть дублируемым
#define REGTF_ONLYNUMBER  0x0080L // 'N' Для регистра значим только номер
#define REGTF_LOCATION    0x0100L // 'A' Регистр может быть использован для привязки к локациям

struct PPRegisterType2 {   // @persistent @store(Reference2Tbl+)
	PPRegisterType2()
	{
		THISZERO();
	}
	enum {
		ggrpaOnlyGroup = 0,
		ggrpaDenyGroup,
		ggrpaAllowByReg
	};
	PPID   Tag;            // Const=PPOBJ_REGISTERTYPE
	PPID   ID;             // @id
	char   Name[48];       // Наименование типа регистра
	char   Symb[20];       // Символ для ссылок из формул и т.д.
	int16  ExpiryPeriod;   // Период истечения срока годности в днях от даты ввода регистра
	//GoodsGrpAllow
	int16  RestrictGoodsKind; // Признак ограничения, накладываемого этим регистром
		// на применение товарной группы в документах:
		//   0 - продавать только эту группу,
		//   1 - запретить эту группу,
		//   2 - разрешить продавать эту группу при наличие регистра (ggrpaXXX)
	PPID   RestrictGoodsGrpID;     // Товарная группа
	char   Reserve[48];    // @reserve
	PPID   RegOrgKind;     // ->Ref(PPOBJ_PERSONKIND) Вид регистрирующей организации
	long   Flags;          // @flags
	PPID   CounterID;      // ->Ref(PPOBJ_OPCOUNTER)
	PPID   PersonKindID;   // Вид персоналии, к которой должен относиться этот регистр. Если 0, то к любому виду.
};

struct PPRegisterTypePacket {
	PPRegisterTypePacket();
	PPRegisterTypePacket & FASTCALL operator = (const PPRegisterTypePacket &);

	PPRegisterType Rec;
	PPOpCounterPacket CntrPack;
	SString Format;
};

class PPObjRegisterType : public PPObjReference {
public:
	static int FASTCALL IsDupRegType(PPID regTypeID);
	//
	// Descr: Находит тип регистрационного документа с символом pRegTypeCode.
	// ARG(pRegTypeCode  IN): символ типа регистрационного документа
	// ARG(pRegTypeID   OUT): возвращаемый функцией идентификатор типа регистрационных документов.
	//   Если тип регистрационных документов с кодом pRegTypeCode не найден, то
	//   *pRegTypeID = 0.
	// Returns:
	//   >0 - заданный тип регистрационных документов найден.
	//   <0 - заданный тип регистрационных документов не найден.
	//   0  - ошибка
	//
	static int FASTCALL GetByCode(const char * pRegTypeCode, PPID * pRegTypeID); // @>>Refernce::SearchSymb
	PPObjRegisterType();
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    GetPacket(PPID, PPRegisterTypePacket *);
	int    PutPacket(PPID *, PPRegisterTypePacket *, int use_ta);
	int    GetFormat(PPID, SString &);
	int    PutFormat(PPID, const char *);
	int    GetCode(PPID, long * pCounter, char * pBuf, size_t bufLen);
	int    UngetCounter(PPID, long counter);
	//
	// Descr: извлекает через кэш редуцированную запись PPRegisterType,
	//   содержащую следующие актуальные поля: {ID, PersonKindID, RegOrgKind, Flags}
	//
	int    Fetch(PPID, PPRegisterType *);
	int    SearchSymb(PPID * pID, const char * pSymb);
private:
	virtual int  ProcessReservedItem(TVRez &);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjQuotKind)
//
struct QuotKindFilt {
	QuotKindFilt();
	enum {
		fAddBase     = 0x0001, // Добавить в список базовую котировку
		fExclNotForBill      = 0x0002, // Исключить из списка виды котировок с признаком "Не использовать в документах"
		fSupplDeal   = 0x0004, // Список, содержащий контрактную цену поставщиков, верхнее и нижнее отклонения.
			// Этот флаг отменяет действия флагов fAddBase и fExclNotForBill
		fAll         = 0x0008, // Показывать все явно существующие виды котировок
		fGoodsMatrix = 0x0010, // Содержит котировку, которая определяет принадлежность товара к товарной матрице
		fGoodsMatrixRestrict = 0x0020, // Содержит котировку, которая определяет ограничение товарной матрицы
		fPredictCoeff        = 0x0040, // Корректировочный коэффициент для прогноза продаж
		fSortByRankName      = 0x0080, // Сортировать список по рангу, имени
		fIgnoreRights        = 0x0100  // Игнорировать список доступных видо котировок в правах доступа
	};
	PPID   AccSheetID; //
	//
	// Если поле OpID != 0, то выбираются виды котировок по следующим условиям:
	//   1. Вид котировки имеет ссылку на эту операцию
	//   2. Вид котировки имеет ссылку на обобщенную операцию, членом которой является OpID
	//   3. Если OpID является операцией межскладского расхода, то виды котировок, имеющие нулевую
	//      ссылку на вид операции пропускаются, но безусловно выбирается базовая котировка.
	//   4. Если вид котировки имеет признак QUOTKF_NOTFORBILL и Flags & fExclNotFroBill,
	//      то такой вид котировки пропускается.
	//   5. Если вид котировки имеет ненулевую ссылку на таблицу аналитических статей, и
	//      эта ссылка не равна GetSellAccSheet(), то такой вид котировки пропускается.
	//
	PPID   OpID;       //
	long   MaxItems;   // Максимальное количество видов в выборке. Если MaxItems <= 0, то не ограничено.
	long   Flags;      // QuotKindFilt::fXXX
};
//
// Виды котировок товаров (PPOBJ_QUOTKIND)
//
#define QUOTKF_ABSDIS         0x0001L // Скидка в абсолютном (денежном) выражении, иначе в %%
#define QUOTKF_NOTFORBILL     0x0002L // Котировка не используется при формировании цены в документе
#define QUOTKF_PCTDISONCOST   0x0004L // Скидка задана в процентах от цены поступления //
	// (исключает QUOTKF_ABSDIS). Задается, например, как '10P' : 10% от цены поступления     //
#define QUOTKF_DSCNTONGROUPS  0x0008L // @obsolete Привязать к данной котировке группы, по которым котировки рассчитываются отдельно
#define QUOTKF_EXTPRICEBYBASE 0x0010L // Если вид котировки используется как дополнительная цена по документу
	// то за базу при расчете принимать учетную цену реализации, если флаг не установлен, то за базу
	// принимается чистая цена реализации (Price-Discount)
#define QUOTKF_RETAILED       0x0020L // Розничная котировка
#define QUOTKF_SERIAL         0x0040L // (ограниченное использование) котировки храняться в
	// хронологической последовательности. То есть, каждое новое значение не стирает предыдущие, но
	// заносится в базу данных с меткой времени. При этом признак Actual остается действительным и
	// присваивается самому новому значению.
#define QUOTKF_SERIALTERMDAYS 0x0080L // Количество хранимых значений ограничивается разницей
	// в днях между актуальным значением и самым первым значением. Если флаг не установлен, то
	// ограничение (если есть) - максимальное количество хранимых значений.
#define QUOTKF_NODIS          0x0100L // Если применяется этот вид котировки, то скидки по картам не действуют.
#define QUOTKF_USEROUNDING    0x0200L // Применять округление значений котировок в соответствии с полями PPQuotKind2::RoundingPrec,  PPQuotKind2::RoundingDir
#define QUOTKF_PASSIVE        0x0400L // @v12.0.8 Пассивный вид котировки (не отображается в списках)

struct PPQuotKind2 { // @flat @persistent @store(Reference2Tbl+)
	PPQuotKind2();
	//
	// Descr: Извлекает из структуры диапазон времени действия вида котировки с одновременной проверкой
	//   его валидности.
	// Returns:
	//   true - диапазон времени действия не пустой и валидный. Присвоен по ссылке rRange.
	//   false - диапазон времени действия пустой или инвалидный. Значение по ссылке rRange обнуляется (TimeRange::Z)
	//
	bool   GetTimeRange(TimeRange & rRange) const;
	void   SetTimeRange(const TimeRange & rRange);
	int    GetAmtRange(RealRange * pRange) const;
	int    SetAmtRange(const RealRange * pRange);
	int    GetRestrText(SString & rBuf) const;
	bool   HasWeekDayRestriction() const;
	bool   CheckWeekDay(LDATE dt) const;

	PPID   Tag;            // Const=PPOBJ_QUOTKIND
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[14];    // @reserve
	double RoundingPrec;   // (Flags & QUOTKF_USEROUNDING) Точность округления
	int16  RoundingDir;    // (Flags & QUOTKF_USEROUNDING) Направление округления (-1 down, +1 up, 0 nearest)
	int16  SerialTerm;     // Ограничение на количество хранимых значений
	int16  Reserve2;       // @alignment
	IntRange AmtRestr;     // Диапазон суммы покупки, при которой действует этот вид котировки
	double Discount;       // Скидка
	DateRange Period;      // Период действия розничной котировки
	int16  BeginTm;        // Время начала действия розничной котировки. byte 0 - hours, byte 1 - minuts
	int16  EndTm;          // Время окончания действия розничной котировки. byte 0 - hours, byte 1 - minuts
	int16  Rank;           // Уровень приоритета котировки при показе в диалоге
		// редактирования или в тех случаях, когда все котировки не могут быть использованы
		// в виду ограничения на количество видов (например, при загрузке в StyloPalm).
		// Чем выше значение, тем выше вероятность использования этого вида котировки по сравнению с другими.
	uint8  DaysOfWeek;     // Дни недели действия розничной котировки (0x01 - Пн, ... , 0x40 - Вс)
	int8   UsingWSCard;    // Совместное использование с дисконтными картами (uwscXXX)
	long   Flags;          // Флаги (QUOTKF_XXX)
	enum {                 //
		uwscDefault = 0,   // - сначала котировка, затем скидка по карте
		uwscSCardNQuot,    // - сначала скидка по карте, затем котировка
		uwscOnlyQuot,      // - только котировка
		uwscOnlySCard      // - только скидка по карте
	};
	PPID   OpID;           // Вид операции, для которой определена котировка
	PPID   AccSheetID;     // Таблица статей, с которыми ассоциируются значения котировок.
		// Если AccSheetID == 0, то полагается, что таблица статей GetSellAccSheet() (покупатели)
};

class PPQuotKindPacket : public PPExtStrContainer { // @v12.0.10 унаследован от PPExtStrContainer с целью хранения текстовых строк расширения //
public:
	enum {
		extssFormula = 1, // Формула для расчета значения котировки в случае, если явно значение не определено
	};
	PPQuotKindPacket();
	PPQuotKindPacket & Z();
	int    GetCalculatedQuot(PPID goodsID, double cost, double basePrice, double * pQuot, long * pFlags) const;

	PPQuotKind Rec;
};

//
// Специфические флаги прав доступа по котировкам
//
#define QUOTRT_UPDQUOTS      0x0100 // Право на изменение котировок
#define QUOTRT_UPDSUPPLCOST  0x0200 // Право на изменение контрактных цен
#define QUOTRT_UPDMTX        0x0400 // Право на изменение товарной матрицы
#define QUOTRT_UPDMTXRESTR   0x0800 // Право на изменение ограничений по товарной матрице
//
// Категории котировок
//
#define PPQC_UNKN                 0 // Неопределенная категория (вид котировки 0 или не найден) //
#define PPQC_PRICE                1 // Обыкновенная ценовая котировка
#define PPQC_SUPPLDEAL            2 // Контрактная цена (включает и ограничения для контрактных цен)
#define PPQC_MATRIX               3 // Товарная матрица
#define PPQC_MATRIXRESTR          4 // Ограничение по товарной матрице
#define PPQC_PREDICTCOEFF         5 // Поправочный коэффициент прогноза продаж

#define PPTRPROP_QUOTKIND         (PPTRPROP_USER+1) // @v12.0.10 Строки расширения вида котировки

class PPObjQuotKind : public PPObjReference {
public:
	friend class QuotKindCache;

	struct ListEntry {
		PPID   ID;
		char   Name[48];
	};
	//
	// Descr: Специальные виды котировок
	//
	struct Special {
		enum CtrOption {
			ctrDefault = 0,
			ctrInitialize,
			ctrInitializeWithCache,
		};
		explicit Special(CtrOption);
		int    FASTCALL IsSupplDealKind(PPID qkID) const;
		//
		// Descr: Возвращает категорию вида котировки qkID.
		// Returns:
		//   Одно из значений PPQC_XXX. Если qkID == 0, то возвращает PPQC_UNKN.
		//
		int    FASTCALL GetCategory(PPID qkID) const;
		void   GetDefaults(int quotCls, PPID qkID, PPID * pAcsID, PPID * pDefQkID, long * pQkSelExtra) const;

		enum {
			fInited = 0x0001 // Запись инициализирована
		};
		long   Flags;
		PPID   MtxID;           // Вид котировки товарной матрицы
		PPID   MtxRestrID;      // Вид котировки ограничения товарной матрицы
		PPID   PredictCoeffID;  // Вид котировки поправочного коэффициента прогноза продаж
		PPID   SupplDealID;     // Вид котировки, управляющей контрактными ценами поставщиков
		PPID   SupplDevUpID;    // Вид котировки, ограничивающий верхнюю границу отклонения фактических цен от контрактных
		PPID   SupplDevDnID;    // Вид котировки, ограничивающий нижнюю границу отклонения фактических цен от контрактных
	};

	static int  FASTCALL GetSpecialKinds(Special *, int useCache);
	static PPID GetDefaultAccSheetID(int cls);
	//
	// Descr: округляет значение цены p в соответствии с параметрами, заданными в конфигурации
	//
	static double RoundUpPrice(PPID quotKindID, double p);
	/*explicit*/PPObjQuotKind(/*void * extraPtr = 0*/);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    IsPacketEq(const PPQuotKindPacket & rS1, const PPQuotKindPacket & rS2, long flags);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {Tag, ID, Name, Discount, Period, BeginTm, EndTm, Rank, OpID, Flags, AccSheetID}
	//
	int    FASTCALL Fetch(PPID id, PPQuotKindPacket * pRec); // @v12.0.10 PPQuotKind-->PPQuotKindPacket
	int    FetchBySymb(const char * pSymb, PPID * pID);
	//
	// Descr: Идентифицирует класс вида котировки (PPQuot::clsXXX).
	// Returns:
	//   >0 - вид котировки успешно классифицирован. По указателю pCls присвоено значение класса.
	//   <0 - вид котировки id не найден. По указателю pCls присваивается значение PPQuot::clsGeneral.
	//   0  - ошибка
	//
	int    Classify(PPID id, int * pCls);
	int    GetListByOp(PPID opID, LDATE dt, PPIDArray * pList);
	//
	// Descr: Возвращает список идентификаторов видов котировок, которые могут
	//   быть использованы для определения розничной цены товаров.
	//   Если dt != ZERODATE то виды котировок, которые не проходят по критериям
	//   периода использования и дня недели, не попадают в список.
	//   Особенности поведения функции в зависимости от флагов flags:
	//   RTLPF_PRICEBYQUOT если установлен, то базовая котировка автоматически попадает в список без
	//     проверки на критерии даты и времени.
	//   RTLPF_USEQUOTWTIME если установлен, то виды котировок проверяются на удовлетворение
	//     времени tm критерию диапазона времени.
	//
	//   Результирующий список отсортирован в порядке приоритета вида котировки и наименования.
	//
	int    GetRetailQuotList(LDATETIME dtm, PPIDArray * pList, long flags /* RTLPF_XXX */);
	//
	// Descr: Сортирует список видов котировок rQkList по рангу и наименованию.
	//   Если присутствующий в списке идентификатор не может быть найдет в таблице видов котировок,
	//   то он изымается из списка.
	//
	int    ArrangeList(const LDATETIME & rDtm, PPIDArray & rQkList, long flags);
	int    GetPacket(PPID id, PPQuotKindPacket *);
	int    PutPacket(PPID *, PPQuotKindPacket *, int use_ta);
	int    SerializePacket(int dir, PPQuotKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    GetCalculatedQuot(PPID id, PPID goodsID, double cost, double basePrice, double * pQuot, long * pFlags);
	//
	// Descr: Создает список элементов типа PPObjQuotKind::ListEntry
	//   Если addBaseQuotKindID != 0, тогда в список добавляется искусственная //
	//   запись, соответствующая базовой котировке (если таковая отсутствует в БД)
	//   ID базовой котировки - PPQUOTK_BASE
	//
	int    MakeList(const QuotKindFilt * pFilt, StrAssocArray * pList);
	SArray * MakeListByIDList(const PPIDArray *);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	int    SearchSymb(PPID * pID, const char * pSymb);
	SString & MakeCodeString(const PPQuot * pQuot, SString & rBuf);
private:
	virtual int  Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int  MakeReserved(long flags);
	int    Helper_GetRtlList(const LDATETIME & rDtm, PPIDArray * pList, PPIDArray * pTmList, long flags);
	int    FetchRtlList(PPIDArray & rList, PPIDArray & rTmList);
};
//
// @ModuleDecl(PPObjPsnOpKind)
// Виды персональных операций
//
// Флаги персональных операций
//
#define POKF_UNIQUE    0x0001L // Уникальная операция   //
#define POKF_BINDING   0x0002L // Обязательная операция //
#define POKF_GROUP     0x0004L // Группа верхнего уровня //
//
// Типы парности персональных операций
//
#define POKPT_NONE          0  // Не парная (PPPsnOpKind::PairOp == 0)
#define POKPT_OPEN          1  // Открывающая      //
#define POKPT_CLOSE         2  // Закрывающая      //
#define POKPT_NULLCLOSE     3  // Нуль-закрывающая (открывающая операция не обязательна) //
//
// Группы дополнительных значений
//
#define POKEVG_NONE         0  // Нет
#define POKEVG_TAG          1  // Тег
#define POKEVG_POST         2  // Должность

struct PPPsnOpKind2 {      // @persistent @store(Reference2Tbl+)
	PPPsnOpKind2();
	//
	// Descr: Сравнивает объект this с экземпляром rS. Если они равны (за исключением
	//   полей Tag и ID, то возвращает !0, в противном случае - 0.
	//
	int    FASTCALL IsEq(const PPPsnOpKind2 & rS) const;

	PPID   Tag;            // Const=PPOBJ_PERSONOPKIND
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ
	PPID   ParentID;       // Родительская группа
	char   Reserve[32];    // @reserve
	PPID   RestrStaffCalID; // Ограничивающий штатный календарь (событие может произойти только в периоды календаря)
	int32  RscMaxTimes;     // Максимальное количество событий, которое может произойти в течении одного периода календаря RestrStaffCalID.
	long   RedoTimeout;    // Таймаут (секунды) в течении которого возможно повторение
		// операции с целью исполнения действий, помеченных флагом PoClause_::fOnRedo
	PPID   RegTypeID;      // ->Ref(PPOBJ_REGISTERTYPE).ID Тип регистрационного документа
	short  ExValGrp;       // Группа дополнительного значения (POPKEVG_XXX)
	short  PairType;       // Тип парности (POPKPT_XXX)
	PPID   ExValSrc;       // Источник дополнительного значения //
		// if(ExValGrp == POPKEVG_TAG) then ExValSrc ->Ref(PPOBJ_TAG).ID
	long   Flags;          // Флаги (POPKF_XXX)
	PPID   LinkBillOpID;   // ->Ref(PPOBJ_OPRKIND).ID
	PPID   PairOp;         // @#{PairOp != ID} ->self.ID   Парная операция //
};
//
// Описание действий над персоналиями, осуществляемых посредством
// персональных операций
//
//
// Типы действий
// Наименования действий хранятся в ресурсах строк с типом PPSTR_POVERB
//
#define POVERB_ASSIGNKIND        1 // Присвоить персоналии ВИД. Вид задается дополнительным параметром действия //
#define POVERB_REVOKEKIND        2 // Отозвать у персоналии ВИД. Вид задается дополнительным параметром действия //
#define POVERB_SETTAG            3 // Установить тег. Тег задается дополнительным параметром операции.
	// Если доп параметр операции не тег, то (по крайней мере пока) это действие не допускается //
#define POVERB_REMOVETAG         4 // Снять тег. Тег задается дополнительным параметром действия //
#define POVERB_ASSIGNPOST        5 // Присвоить персоналии должность
	// Должность определяется дополнительным параметром операции. Если
	// доп параметр операции не должность, то это действие не допускается.
#define POVERB_REVOKEPOST        6 // Отозвать у персоналии должность
	// Отзывается последняя должность первичной персоналии, по отношению
	// ко вторичной. Это накладывает неприятное ограничение, предписывающее
	// человеку занимать не более одной должности у работодателя, либо
	// порождает двусмысленность, если это не так.
#define POVERB_ASSIGNREG         7 // Присвоить персоналии регистрационный документ
	// Персоналии присваивается копия регистрационного документа, оговоренного
	// в операции. Если регистр является уникальным и регистр такого типа
	// уже есть у персоналии, то он изменяется.
#define POVERB_REVOKEREG         8 // Отозвать регистрационный документ у персоналии
	// Тип отзываемого регистрационного документа задается доп параметром
	// действия. Если этот тип уникален, то все однозначно. Если же нет,
	// то придется отзывать все регистрационные документы такого типа.
#define POVERB_SETCALENDAR       9 // Установить значение в календаре
#define POVERB_COMPLETECAL      10 // Заполнение календаря по закрывающей парной операции
#define POVERB_INCTAG           11 // Увеличить значение тега на единицу
#define POVERB_DECTAG           12 // Уменьшить значение тега на единицу
#define POVERB_SETCALCONT       13 // Установить календарь в протяженное состояние с даты события //
#define POVERB_SETCALCONT_SKIP  14 // Установить календарь в протяженное состояние с даты события (пропуск) //
#define POVERB_RESETCALCONT     15 // Удалить запись календаря, переводяющую его в протяженное состояние.
#define POVERB_SETCALENDAR_SKIP 16 // Установить пропуск в календаре
#define POVERB_COMPLETECAL_SKIP 17 // Заполнение календаря пропусками по закрывающей парной операции
#define POVERB_ADDRELATION      18 // Установить отношение персоналии к другой персоналии
#define POVERB_REVOKERELATION   19 // Отозвать отношение персоналии к другой персоналии
#define POVERB_INCSCARDOP       20 // Провести операцию увеличения остатка по персональной карте
#define POVERB_DECSCARDOP       21 // Провести операцию списания остатка по персональной карте
#define POVERB_DEVICECMD        22 // Команда на устройство PoClause_::DirObj
#define POVERB_STYLODISPLAY     23 // Выдавать информацию на дисплей StyloDisplay PoClause_::DirObj
#define POVERB_BEEP             24 // Звуковой сигнал
#define POVERB_CHKSCARDBILLDEBT 25 // Проверка на отсутствие просроченного долга по документам, привязанным к карте

#define POCOBJ_PRIMARY           1
#define POCOBJ_SECONDARY         2
#define POCOBJ_REGORG            3
#define POCOBJ_DIVISION          4
#define POCOBJ_POST              5
#define POCOBJ_TAGVAL            6

class PoClause_ {
public:
	PoClause_();
	int    FASTCALL IsEq(const PoClause_ & rS) const;
	PPID   GetDirObjType() const;
	long   GetDirFlags() const;
	//
	// Descr: Заносит содержимое записи в буфер rBuf для сохранения в таблице PropertyTbl.
	//   После успешного завершения rBuf.GetSize() точно равна длине данных, которые должны быть сохранены в БД.
	//
	int    PutToPropBuf(STempBuffer & rBuf) const;
	//
	// Descr: Извлекает запись из буфера rBuf, полученного, в свою очередь, из записи таблицы PropertyTbl.
	//
	int    GetFromPropBuf(const STempBuffer & rBuf, long exValSrc);

	enum {
		fPassive = 0x0001, // Пассивное действие (не исполнять при проведении операции)
		fOnRedo  = 0x0002  // Действие должно исполняться при повторном выполнении операции
	};
	long   Num;     // Counter
	PPID   VerbID;  // POVERB_XXX
	PPID   Subj;    // POCOBJ_PRIMARY | POCOBJ_SECONDARY
	PPID   DirObj;  // Объект, связанный с действием. Тип объекта может быть определен с помощью функции PoClause::GetDirObjType()
	long   Flags;
	SString CmdText;
};

class PoClauseArray_ {
public:
	PoClauseArray_();
	PoClauseArray_ & FASTCALL operator = (const PoClauseArray_ & rS);
	PoClauseArray_ & Z();
	int    IsEq(const PoClauseArray_ & rS, int options = 0) const;
	uint   GetCount() const;
	int    Get(uint pos, PoClause_ & rItem) const;
	int    Add(const PoClause_ & rItem);
	int    Set(uint pos, const PoClause_ * pItem);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	struct Item {
		long   Num;
		PPID   VerbID;
		PPID   Subj;
		PPID   DirObj;
		long   Flags;
		uint   CmdTextP;
	};
	TSVector <Item> L;
	StringSet Pool;
};
//
// Ограничения на тип юридического статуса персоналии
//
#define PSNSTT_ANY          0
#define PSNSTT_PRIVATE      1
#define PSNSTT_LEGAL        2
//
// Descr: Пакет, управляющий всеми данными по персональной операции
// @done (@v8.2.3) @dbd_exchange Реализовать передачу PPPsnOpKindPacket::PCPrmr.RestrictScSerList и PPPsnOpKindPacket::PCScnd.RestrictScSerList
//
class PPPsnOpKindPacket { // @persistent
public:
	friend class PPObjPsnOpKind;
	//
	// Descr: Ограничение на персоналию в персональных операциях
	//
	struct PsnConstr {
		PsnConstr();
		PsnConstr & Z();

		PPID   PersonKindID;   // ->Ref(PPOBJ_PERSONKIND) Вид персоналии
		short  StatusType;     // PSNSTT_XXX Категория статуса персоналии
		short  Reserve1;       // @reserve
		PPID   DefaultID;      // ->Person.ID (Default Person)
		PPID   RestrictTagID;  // Ограничивающий тег (если его значение <=0, то событие вводить нельзя)
		PPIDArray RestrictScSerList; // Список серий карт, которые можно использовать для идентификации персоналии
	};

	PPPsnOpKindPacket();
	PPPsnOpKindPacket & FASTCALL operator = (const PPPsnOpKindPacket &);
	int    FASTCALL IsEq(const PPPsnOpKindPacket & rS) const;
	void   destroy();
	int    CheckExVal();
	PPPsnOpKind  Rec;
	PsnConstr    PCPrmr;     // Ограничения по первичной персоналии
	PsnConstr    PCScnd;     // Ограничения по вторичной персоналии
	PoClauseArray_ ClauseList;
	ObjIdListFilt AllowedTags;
private:
	void * AllocExtraProp(size_t * pSz) const;
};

struct PsnOpKindFilt {
	enum {
		tShowAll    = 0,
		tShowItems  = 1,
		tShowGroups = 2
	};
	PsnOpKindFilt(PPID show = 0, PPID parentID = 0, int cantSelParent = 0);

	PPID   Show;          // Тип PsnOpKindFilt::tShowXXX
	PPID   ParentID;      // Группа видов персональных операций
	int    CantSelParent; // Не выбирать группы если установлен данный флаг,
};

class PPObjPsnOpKind : public PPObjReference {
public:
	static PPID Select(long = 0);
	static int  FASTCALL CheckRecursion(PPID id, PPID parentID);
	explicit PPObjPsnOpKind(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPPsnOpKind * pRec);
	int    GetPacket(PPID, PPPsnOpKindPacket *);
	int    PutPacket(PPID *, PPPsnOpKindPacket *, int use_ta);
	long   GetLevel(PPID id);
	StrAssocArray * MakeList(const PsnOpKindFilt * pPsnOpKindFilt);
	int    SerializePacket(int dir, PPPsnOpKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual bool ValidateSelection(PPID, uint olwFlags, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);

	PsnOpKindFilt CurrFilt;
};
//
// @ModuleDecl(PPObjWorldObjStatus)
//
struct PPWorldObjStatus2 { // @persistent @store(Reference2Tbl+)
	PPWorldObjStatus2()
	{
		THISZERO();
	}
	long   Tag;            // Const=PPOBJ_CITYSTATUS
	long   ID;             // @id
	char   Name[48];       // @name
	char   Abbr[20];       // Сокращение
	char   Reserve[60];    // @reserve
	long   Flags;          // @reserve
	long   Kind;           // WORLDOBJ_XXX
	long   Code;           // Классификатор (возможно, связан с внешним классификатором). Если Code!=0, то значение уникально
};

class PPObjWorldObjStatus : public PPObjReference {
public:
	explicit PPObjWorldObjStatus(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Ищет запись с кодом code.
	// ARG(code     IN): Код статуса, по которому ущется запись. Если code == 0, то функция //
	//   немедленно возвращает -1.
	// ARG(kind     IN): Если kind != 0, то ищется запись только со значением Kind == kind
	// ARG(pID  IN/OUT): Если pID != 0 && *pID != 0, то запись с идентификатором равным *pID
	//   не принимается. Используется для нахождения дубликата по коду записи с ид *pID.
	// ARG(pRec    OUT): @#{vptr0} Указатель на буфер, в который копируется найденная запись.
	// Returns:
	//   >0 - найдена запись по заданным условиям
	//   <0 - запись не найдена
	//   0  - ошибка
	//
	int    SearchByCode(long code, long kind, PPID * pID, PPWorldObjStatus * pRec);
	int    AddSimple(PPID * pID, const char * pName, const char * pAbbr, long kind, long code, int use_ta);
};
//
// @ModuleDecl(PPObjWorld)
//
#define WORLDOBJ_SPECIAL    -100  // Специальная запись: индикатор того, что таблица была отконвертирована из старого набора объектов PPObjCountry, PPObjCity, PPObjRegion
#define WORLDOBJ_CONTINENT  1
#define WORLDOBJ_GENREGION  2
#define WORLDOBJ_COUNTRY    3
#define WORLDOBJ_REGION     4
#define WORLDOBJ_CITY       5
#define WORLDOBJ_STREET     6 // Улица (площадь, проспект и т.д.)
#define WORLDOBJ_CITYAREA   7 // Район города
#define WORLDOBJ_LOCALAREA  8 // Локальная область (район) (в базе данных не хранится)
#define WORLDOBJ_HOUSE      9 // Стоение, дом (в базе данных не хранится)
#define WORLDOBJ_APART     10 // Квартира, комната, офис (в базе данных не хранится)
#define WORLDOBJ_FLOOR     11 // Этаж (в базе данных не хранится)
#define WORLDOBJ_POSTBOX   12 // Абонентский ящик (в базе данных не хранится)

class PPWorldPacket {
public:
	PPWorldPacket();
	void   Init();
	WorldTbl::Rec Rec;
};

class PPObjWorld : public PPObject {
public:
	struct SelFilt {
		SelFilt();
		PPID   GetSingleKind() const;

		uint    KindFlags;    // WORLDOBJ_XXX (0 - any kind)
		PPID    ParentID;
		PPID    CountryID;
		SString SubName;
	};
	static void * FASTCALL MakeExtraParam(int kind, PPID parentID, PPID countryID);
	static void * FASTCALL MakeExtraParam(const PPIDArray & rKindList, PPID parentID, PPID countryID);
	static int  ConvertExtraParam(void * extraPtr, SelFilt * pFilt);
	static int  UniteMaxLike();
	static int  Recover();
	static SString & GetNativeCountryName(SString & rBuf);
	//
	// @v12.2.12
	// Descr: Ищет наименование региона России по коду. Поиск осуществляется по 
	//   данным, загружаемым из файла ru-region.csv (распространяется с дистрибутивом)
	//
	static bool GetRuRegionNameByCode(const char * pCode, SString & rNameUtf8);
	explicit PPObjWorld(void * extraPtr = 0);
	~PPObjWorld();
	virtual int    Browse(void * extraPtr);
	virtual int    Edit(PPID * pID, void * extraPtr);
	virtual int    Search(PPID id, void * b = 0);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {ID, Kind, ParentID, CountryID, Name, Status, Flags}
	//
	int    Fetch(PPID id, WorldTbl::Rec * pRec);
	int    SearchByName(int kind, const char * pName, WorldTbl::Rec * pRec);
		// @>>PPObjWorld::GetListByName
	int    SearchByCode(const char * pCode, WorldTbl::Rec * pRec);
	int    GetListByName(int kind, const char * pName, SVector * pList);
	int    GetListByCode(int kind, const char * pCode, SVector * pList);
	int    GetListByFilt(const SelFilt & rFilt, SVector * pList);
	//
	// Descr: Ищет государство (Kind == WORLDOBJ_COUNTRY) по следующему алгоритму:
	//   - Если !isempty(pName), тогда точное соответствие по наименованию.
	//     В случае, если существует более одной записи государства с именем равным pName,
	//     то список таких записей сверяется с параметрами pCode и pAlpha2. Первая запись,
	//     которая согласуется либо с pCode либо с pAlpha2, считается искомой. Если все
	//     записи не соответствуют этим критериям, то берется первая из списка.
	//   - Если предыдущие шаги безуспешны, то
	//       если !isempty(pCode), тогда точное соответствие WorldTbl::Rec::Code - pCode
	//   - Если предыдущие шаги безуспешны, то
	//       если !isempty(pAlpha2), тогда точное соответствие WorldTbl::Rec::Abbr - pAlpha2
	// Returns:
	//   <0 - государство не найдено
	//   1 - государство найдено по наименованию
	//   2 - государство найдено по коду
	//   3 - государство найдено по аббревиатуре pAlpha2
	//
	int    SearchCountry(const char * pName, const char * pCode, const char * pAlpha2, WorldTbl::Rec * pRec);
	//
	// Descr: Опции поиска аналога географического объекта
	//
	enum {
		smlDefault      = 0,             // smlCode|smlName|smlCheckCountry
		smlCode = 0x0001,        // Поиск по коду
		smlName = 0x0002,        // Поиск по наименованию
		smlCheckCountry = 0x0004,        // Если код или наименование дали совпадение, то проверить эквивалентность государства
		smlCheckParent  = 0x0008,        // Если код или наименование дали совпадение, то проверить эквивалентность родительского объекта
		smlCheckCountryOrParent = 0x0010 // Если код или наименование дали совпадение, то проверить эквивалентность по правилу:
			// NZOR(ParentID, CountryID) == NZOR(candidate.ParentID, candidate.CountryID))
	};
	int    SearchMaxLike(const PPWorldPacket * pPack, long flags, PPID * pID);
	//
	// Descr: Определяет, является ли объект id потомком объекта parentID.
	//   Родство определяется либо по линии ParentID либо CountryID.
	// Returns:
	//   >0 - объект id является потомком объекта parentID
	//    0 - объект id не является потомком объекта parentID.
	//
	bool   IsChildOf(PPID id, PPID parentID); // @recursion
	int    GetCountryByChild(PPID id, WorldTbl::Rec * pCountryRec);
	int    GetPacket(PPID id, PPWorldPacket * pPack);
	//
	// Descr: Записывает пакет объекта в базу данных. Возможны следующие случаи:
	//   {*pID == 0 && pPack != 0}: ЗАПИСЫВАЕТ НОВЫЙ пакет в БД. По указателю pID присваивает ИД нового объекта.
	//   {*pID != 0 && pPack != 0}: ИЗМЕНЯЕТ СУЩЕСТВУЮЩИЙ пакет c идентификатором *pID в БД.
	//   {*pID != 0 && pPack == 0}: УДАЛЯЕТ СУЩЕСТВУЮЩИЙ пакет c идентификатором *pID из БД.
	// ARG(pID    IN/OUT): @#{vptr}  Указатель на идентификатор объекта
	// ARG(pPack      IN): @#{vptr0} Указатель на пакет объекта
	// ARG(use_ta     IN): Если !0, то функция реализует внутреннюю транзакцию
	// Returns:
	//   >0 - пакет успешно записан (удален) в (из) базу данных
	//   <0 - в случае {*pID != 0 && pPack != 0} функция обнаружила, что пакет не изменился по сравнению с БД
	//        и функция не стала выполнять обновление данных в БД
	//   0  - ошибка
	//
	int    PutPacket(PPID * pID, PPWorldPacket * pPack, int use_ta);
	int    AddSimple(PPID * pID, int kind, const char * pName, const char * pCountry, int use_ta);
	int    GetParentCountry(PPID id, PPID * pParentCountryID);
	int    GetNativeCountry(PPID * pID);
	int    ImportCountry(int use_ta);
	// Возвращает PPObjListWindow
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
private:
	virtual int  DeleteObj(PPID id);
	virtual bool ValidateSelection(PPID id, uint olwFlags, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual const char * GetNamePtr();
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	int    Unite(PPID destID, PPID srcID);
	struct AislBlock {
		StrAssocArray * P_List;
		int    UseHierarchy;
		PPIDArray Stack;
		UintHashTable El; // Список идентификаторов, которые уже добавлены в P_List
	};
	int    AddItemToSelectorList(const WorldTbl::Rec & rRec, AislBlock & rBlk); // @recursion
	int    AddItemToSelectorList(PPID id, StrAssocArray * pList, int useHierarchy, PPIDArray * pStack); // @recursion
	int    GetChildList(PPID id, PPIDArray * pChildList, PPIDArray * pStack); // @recursion
	bool   Helper_IsChildOf(PPID id, PPID parentID, PPIDArray * pRecurTrace); // @recursion
	int    CorrectCycleLink(PPID id, PPLogger * pLogger, int use_ta);
	int    Recover(PPLogger * pLogger); // @todo Срочно!!!
public:
	static int Convert();

	void * ExtraPtr;
	TLP_MEMB(WorldTbl, P_Tbl);
};
//
//
//
#define FIASADRF_ACTUAL       0x0001 // Признак актуальности адресного объекта

#define FIASHSEINTSTATUS_HOUSE     0 // запись отдельного дома
#define FIASHSEINTSTATUS_SOLID     1 // обычный интервал, включающий четные и нечетные номера домов
#define FIASHSEINTSTATUS_EVEN      2 // только четные значения
#define FIASHSEINTSTATUS_ODD       3 // только нечетные значения

#define FIASHSEESTSTATUS_INT       0 // для интервала
#define FIASHSEESTSTATUS_OWNRSH    1 // владение
#define FIASHSEESTSTATUS_HOUSE     2 // дом
#define FIASHSEESTSTATUS_HSEOWNRSH 3 // домовладение
#define FIASHSEESTSTATUS_LAND      4 // участок

#define FIASHSEBLDSTATUS_INT       0 // для интервала
#define FIASHSEBLDSTATUS_STRUC     1 // строение
#define FIASHSEBLDSTATUS_CONSTR    2 // сооружение
#define FIASHSEBLDSTATUS_LITER     3 // литер

class FiasObjCore {
public:
	struct HouseCode {
		static SString & NormalizeItem(SString & rBuf);
		HouseCode(const char * pCode);
		HouseCode & Z();
		SString & FASTCALL Encode(SString & rBuf) const;
		int    FASTCALL Decode(const char * pCode);

		SString HseNum; // Номер дома
		SString BldNum; // Номер корпуса
		SString StrNum; // Номер строения
	};

    FiasObjCore();
    //
    // Descr: Ищет адресный объект по идентификатору записи (не путать с идентификатором объекта).
    //
    int    SearchAddr(long recID, FiasAddrObjTbl::Rec * pRec);
    //
    // Descr: Ищет здание по идентификатору
    //
    int    SearchHouse(long hseID, FiasHouseObjTbl::Rec * pRec);
    //
    // Descr: Ищет адресный объект по идентификатору.
    //
    int    SearchAddrByID(long addrID, FiasAddrObjTbl::Rec * pRec);
    //
    // Descr: Ищет адресный объект по глобальному идентификатору.
    //
    int    SearchAddrByUUID(const S_GUID & rUuid, FiasAddrObjTbl::Rec * pRec);
    int    SearchHouseByUUID(const S_GUID & rUuid, FiasHouseObjTbl::Rec * pRec);
    int    GetAddrListByZIP(const char * pZip, PPIDArray & rList);
    int    GetHouseListByZIP(const char * pZip, PPIDArray & rList);
    int    GetChildList(PPID id, int level, PPIDArray & rList);

    FiasAddrObjTbl  AdrT;
    FiasHouseObjTbl HseT;
    UuidRefCore UrT;
private:
	int    Helper_GetChildList(PPID parentID, int level, PPIDArray & rList);
};

class PPFiasReference {
public:
	static int IdentifyShortDescription(const char * pText, int * pLevel, SString * pFullText);

    PPFiasReference();
    ~PPFiasReference();
    int    SearchObjByID(PPID id, FiasAddrObjTbl::Rec * pRec, int useCache);
    int    SearchObjByUUID(const S_GUID & rUuid, FiasAddrObjTbl::Rec * pRec);
    int    SearchHouseByID(PPID id, FiasHouseObjTbl::Rec * pRec);
    int    SearchHouseByUUID(const S_GUID & rUuid, FiasHouseObjTbl::Rec * pRec);
    //
    // Descr: Опции функции SearchObjByText
    //
    enum {
    	stfAnsiInput    = 0x0001, // Входящая строка - в ANSI кодировке
    	stfPrefix       = 0x0002, // Искать все, что начинается с pText
    	stfDontUseCache = 0x0004  // @internal Не использовать кэш
    };

    int    SearchObjByText(const char * pText, long flags, PPID upperID, PPIDArray & rList);

    enum {
    	matfZipPrefix = 0x0001,
    	matfTryHouse  = 0x0002
    };
    int    MakeAddressText(PPID terminalID, long flags, SString & rBuf);
    int    GetText(PPID textRef, SString & rBuf);
	//
	// ARG(vec IN) :
	//    0 - предварительно не известно нахождение obj1ID и obj2ID друг относительно друга в иерархии
	//   <0 - obj1ID заведомо на уровне ниже obj2ID
	//   >0 - obj1ID заведомо на уровне выше obj2ID
	// Returns:
	//   0 - error
	//  -1 - not match
	//   1 - obj1ID belong to obj2ID
	//   2 - obj2ID belong to obj1ID
	//   3 - obj1ID equal obj2ID
	//
    int    Match(PPID obj1ID, PPID obj2ID, int vect);
    int    IdentifyHouse(PPID terminalObjID, const char * pHouseCode, PPID * pHouseID);

    int    GetRandomHouse(long extValue, PPID terminalObjID, PPID * pHouseID);
    int    GetRandomAddress(long extValue, PPID cityID, PPID * pStreetID, PPID * pHouseID);

	FiasObjCore FT;
private:
	friend class FiasAddrCache;

	int    Helper_GetHierarchy(PPID id, long flags, FiasHouseObjTbl::Rec * pHseRec, TSArray <FiasAddrObjTbl::Rec> & rList, long * pZip);
	uint   IsObjInHierarchy(PPID objID, const TSArray <FiasAddrObjTbl::Rec> & rList) const;
	int    SearchObjByTextRefList(const TSVector <TextRefIdent> & rTRefList, PPIDArray & rList);
};
//
//
//
class FiasImporter {
public:
	struct Param {
		Param();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fImportAddrObj    = 0x0001,
			fImportHouseObj   = 0x0002,
			fIgnoreSavedState = 0x0004,
			fDoDebugOutput    = 0x0008,
			fDontAcceptToPpDb = 0x0010, // Не акцептировать результаты в базу данных Papyrus
			fAcceptToSartreDb = 0x0020  // Записывать результаты импорта в SartreDB
		};
		long   Flags;
		SString Path;
	};
	enum {
		inpAddrObj = 1,
		inpHouse
	};
	static int EditParam(Param & rP);
	FiasImporter();
	~FiasImporter();
	int    Run(const Param & rP);
private:
	int    Import(int inpObject);
	int    DoPhase(int inpObject, int phase, const SString & rFileName, xmlSAXHandler & rSaxH);
	int    FASTCALL ToggleTransaction(ulong threshold);
	int    ReadRecordFromXmlAttrList(const char ** ppAttrList);
	static int  ParseFiasFileName(const char * pFileName, SString & rObjName, LDATE & rDt, S_GUID & rUuid);
	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    SaxParseFile(xmlSAXHandler * sax, const char * pFileName);
	void   SaxStop();
	int    ProcessString(const char * pRawText, long * pRefId, SString & rTempBuf, SStringU & rTempBufU);
	int    ProcessString(const char * pRawText, int * pRefId, SString & rTempBuf, SStringU & rTempBufU)
		{ return ProcessString(pRawText, reinterpret_cast<long *>(pRefId), rTempBuf, rTempBufU); }
	int    CollectUuid(const S_GUID & rUuid);
	int    FlashUuidChunk(uint maxCount, int use_ta);
	int    FlashAddrChunk(uint maxCount, int use_ta);
	int    FlashHouseChunk(uint maxCount, int use_ta);
	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);

	enum {
		phaseGeneric = 0,
		phaseCount = 1,
		phaseUUID,
		phaseText,
		phaseData,
		phaseSartrePass1,
		phaseSartrePass2
	};

	class ProcessState {
	public:
		ProcessState();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    Store(int use_ta);
		int    Restore();
		int    SearchItem(const char * pPath, int phase, uint * pPos, SString & rNormalizedName) const;
		int    SetItem(const char * pPath, int phase, uint * pPos, SString & rNormalizedName);

        struct Item { // @flat
        	Item();
        	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

			char   InputFileName[128];
			int32  Phase;
        	uint32 LastProcessedRecN;
        	int64  TotalMks;
        	uint8  Reserve[64];
        };
        TSVector <Item> L;
	};
	enum {
		stError = 0x0001
	};
	long   State;
	enum {
		fDoDebugOutput = 0x0001
	};
	int    InputObject;
	Param  P;
	ProcessState Ps;
	int    CurPsPos; // Текущая позиция в Ps. <0 - не определена
	xmlParserCtxt * P_SaxCtx;
	PPTransaction Tra;
	ulong  RawRecN;
	SdRecord * P_Sdr;
	SFile * P_DebugOutput;
	SymbHashTable TextCache;
	UuidArray PreprocessUuidChunk;
	TSVector <FiasAddrObjTbl::Rec> AddrRecChunk;
	TSVector <FiasHouseObjTbl::Rec> HouseRecChunk;
    FiasObjCore FT;
	SrDatabase * P_SrDb;
	void * P_SrStoreFiasAddrBlock;
};
//
// Descr: Объект данных, управляющий справочником видов налогообложения //
//
class PPObjTaxSystemKind : public PPObjReference {
public:
	PPObjTaxSystemKind(void * extraPtr = 0);
private:
	virtual int  ProcessReservedItem(TVRez &);
};
//
// @ModuleDecl(PPObjRegister)
//
// Descr: Объект данных, управляющий регистрами персоналий.
//   Этот объект существует в тесной зависимости от объектов PPOBJ_PERSON, PPOBJ_PERSONEVENT, PPOBJ_LOCATION.
//   Если запись RegisterTbl::Rec имеет ненулевую ссылку PsnEvent, то
//   она управляется объектом PPOBJ_PERSONEVENT, в противном случае - объектом PPOBJ_PERSON или PPOBJ_LOCATION.
//   @# RegisterTbl::Rec::Person != 0
//
class PPObjRegister : public PPObject {
public:
	static int InitPacket(RegisterTbl::Rec * pRec, PPID regTypeID, PPObjID oid, const char * pNumber);
	static int Format(const RegisterTbl::Rec & rRec, const char * pFormat, SString & rBuf);

	PPObjRegister(void * extraPtr = 0);
	~PPObjRegister();
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID);
	virtual int  Search(PPID id, void * b = 0);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /* (RegisterFilt*) */);
	int    Fetch(PPID id, RegisterTbl::Rec * pRec);
	int    SearchByNumber(PPID *, PPID regTypeID, const char * pSn, const char * pNmbr, RegisterTbl::Rec *);
	int    SearchByFilt(const RegisterFilt *, PPIDArray * pResList, PPIDArray * pObjList);
	int    Edit(PPID * pID, PPID objType, PPID objID, PPID regTypeID);
	int    EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, const PPPersonPacket * pOuterPack);
	int    EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, const PPLocationPacket * pOuterPack);
	int    EditBankAccount(PPBankAccount * pRec, PPID psnKindID);
	int    EditList(PPPersonPacket * pPsnPack, PPID psnEventID);
	int    EditList(PPLocationPacket * pLocPack);
	int    EditBankAccountList(PPPersonPacket * pPsnPack);
	int    GetBankAccountList(PPID personID, TSVector <PPBankAccount> * pList);
	//
	// Descr: Проверяет массив регистров pRegs на отсутствие дублирования типа regTypeID
	//   если этот тип имеет признак REGTF_UNIQUE.
	//   То есть в массиве pRegs должно быть не более одного регистра с типом regTypeID,
	//   если он (тип) имеет признак REGTF_UNIQUE.
	// Returns:
	//   >0 - Дублирование отсутствует
	//   0  - Есть дублированные регистры (PPErrCode = PPERR_DUPREGISTER)
	//
	int    CheckUnique(PPID regTypeID, const RegisterArray * pRegs) const;
	int    CheckUniqueNumber(const RegisterTbl::Rec *, const RegisterArray *, PPID objType, PPID objID);
	//
	// Descr: Форматирует регистрационный документ согласно форматирующей строке,
	//   заданной параметром fmt. Если первый параметр <0, то форматируется запись,
	//   находящаяся в буфере, иначе запись ищется по идентификатору.
	//   Если форматирующая строка не задана (pFormat == 0), то она извлекается //
	//   из записи типа регистрационного документа.
	//
	int    Format(PPID id, const char * pFormat, char *, size_t); // @obsolete
	int    Format(PPID id, const char * pFormat, SString & rBuf);
	int    GetTabNumber(PPID personID, SString & rTabNum);
	//
	// Descr: Специализированная функция, используемая при акцепте объектов,
	//   включающих записи регистров (PPOBJ_PERSON, например).
	//
	int    PreventDup(RegisterTbl::Rec & rRec, PPID linkObjType, PPID linkObjID);
private:
	virtual int    HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual const char * GetNamePtr();
	int    Helper_EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, PPID outerObjType, const void * pOuterPacket);
public:
	TLP_MEMB(RegisterCore, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPObjLocation)
//
enum {
	whzcDefault = 0,
	whzcAlpha,
	whzcDigit1,
	whzcDigit2,
	whzcDigit3,
	whzcDigit4,
	whzcOwnCode
};

struct PPLocationConfig {  // @transient @store(PropertyTbl)
	PPLocationConfig();
	PPLocationConfig & Z();

	enum {
		fValid        = 0x0001, // @transient Используется при кэшировании. Означает, что запись, хранящаяся в кэше была считана из базы данных.
		fUseFias      = 0x0002  // Применять справочник ФИАС
	};
	int16  WhZoneCoding;
	int16  WhColCoding;
	int16  WhRowCoding;
	int16  WhCellCoding;
	int16  WhCodingDiv;    // Разделитель кодов складских позиций  (0 - dot, 1 - defis, 2 - none)
	int16  Reserve;        // @alignment
	long   Flags;          // @flags
	PPID   DefPalletID;    //
	PPID   StoreIdxTagID;  // Идентификатор тега, отвечающий за индекс магазина в сети (только для LOCTYP_WAREHOUSE)
	PPID   MarketplaceWarehoustFolderID; // @v12.2.1 Каталог складов маркетплейсов. Так как один маркетплейс сам по себе может
		// иметь более одного склада, то вероятнее всего внутру этого каталога будут подкаталоги, относящиеся к конкретным маркетплейсам.
	char   AddrCodeTempl[28]; // Шаблон кода нового адреса // @v12.2.1 [32]-->[28]
};
//
// Descr: Специализированная структура для унифицированного обмена информацией о государстве.
//   Необходимость этой структуры обусловлена двоякой формой хранения данных о государствах:
//   -- В таблице World (нормальный метод)
//   -- В таблице Person (специальный метод, иногда используемый для обозначения страны происхождения товаров)
//
struct PPCountryBlock {
	PPCountryBlock();
	PPCountryBlock & Z();

	int    IsNative; // Если код страны совпадает с кодом страны фактического (или юридического,
		// если фактический пуст) адреса главной организации.
	SString Name;
	SString Code;
	SString Abbr;
};

class PPLocationPacket : public LocationTbl::Rec, public ObjTagContainerHelper {
public:
	PPLocationPacket();
	PPLocationPacket(const PPLocationPacket & rS);
	void   destroy();
	int    FASTCALL Copy(const PPLocationPacket & rS);
	PPLocationPacket & FASTCALL operator = (const PPLocationPacket & rS);
	PPLocationPacket & FASTCALL operator = (const LocationTbl::Rec & rS);
	int    IsEmptyAddress() const;

	RegisterArray Regs;
	ObjTagList TagL;
	ObjIdListFilt WarehouseList; // @v11.0.6 Список складов, ассоциированных с подразделением главной организации
};

class PPObjLocation : public PPObject {
public:
	static int FASTCALL ReadConfig(PPLocationConfig * pCfg);
	static int FASTCALL WriteConfig(const PPLocationConfig * pCfg, int use_ta);
	static int EditConfig();
	static int FASTCALL FetchConfig(PPLocationConfig * pCfg);
	static int DirtyConfig();
	static int  SelectWarehouse(PPID owner = 0, PPID level = 0);
	static PPID FASTCALL ObjToWarehouse(PPID arID);
	static PPID FASTCALL ObjToWarehouse_IgnoreRights(PPID arID);
	static PPID FASTCALL WarehouseToObj(PPID locID);
	static PPID FASTCALL ObjToWarehouse_Direct(PPID arID, PPID * pAcsID);
	static PPID FASTCALL ObjToWarehouse_IgnoreRights_Direct(PPID arID, PPID * pAcsID);
	static PPID FASTCALL WarehouseToObj_Direct(PPID locID);
	static int  FASTCALL CheckWarehouseFlags(PPID locID, long);
	static int  ViewWarehouse();
	static int  ViewDivision();
	explicit PPObjLocation(void * extraPtr = 0);
	~PPObjLocation();
	virtual int  Search(PPID id, void * b = 0);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam); // @v11.0.4
	virtual void FASTCALL Dirty(PPID id); // @macrow
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
		// @>>PPObjLocation::MakeList(const LocationFilt, long)
	//
	// Descr: возвращает родительский склад для объекта locID.
	//   Если locID является складом, то по указателю pWarehouseID присваивается собственно locID,
	//   если locID является складской зоной, складской колонной либо складской ячейкой,
	//   то по указателю pWarehouseID присваивается идентификатор склада, которому принадлежит этот объект.
	//   В остальных случаях по указателю pWarehouseID присваивается ноль и
	//   возвращаемое значение равно -1.
	//
	int    GetParentWarehouse(PPID locID, PPID * pWarehouseID);
	int    SearchName(PPID locTyp, PPID parentID, const char * pName, PPID * pID);
	//
	// Descr: Опции формирования строки кода локации
	//
	enum {
		mcsDefault      = 0x0000,
		mcsWhCodePrefix = 0x0001, // Добавлять в качестве префикса код склада (LOCTYP_WHZONE, LOCTYP_WHCOLUMN, LOCTYP_WHCELL)
		mcsName         = 0x0002,
		mcsCode         = 0x0004,
		mcsAddr         = 0x0008,
		mcsShortAddr    = 0x0010,
		mcsPhone        = 0x0020,
		mcsContact      = 0x0040,
		mcsEmail        = 0x0080
	};
	SString & MakeCodeString(const LocationTbl::Rec * pRec, int options, SString & rBuf);
	bool   Validate(LocationTbl::Rec * pRec, int /*chkRefs*/);
	int    FASTCALL Fetch(PPID id, LocationTbl::Rec * pRec); // @macrow
	//
	// Descr: Возвращает !0 если элемент склада id требует автоматического
	//   назначения имени.
	// Returns:
	//   >0 - элемент склада id требует автоматического имени согласно его собственному свойству
	//   <0 - элемент склада id требует автоматического имени согласно по требованию родительского элемента.
	//   0  - элемент склада id не требует автоматического имени либо ошибка.
	//
	int    ReqAutoName(PPID id);
	int    GenerateWhCells(PPID whColumnID, const LocationTbl::Rec * pSampleRec, int use_ta);
	int    InitCode(LocationTbl::Rec * pRec);
	int    IsPacketEq(const PPLocationPacket & rS1, const PPLocationPacket & rS2, long flags);
	int    GetPacket(PPID id, PPLocationPacket * pPack);
	int    PutPacket(PPID * pID, PPLocationPacket * pPack, int use_ta);
	int    PutRecord(PPID * pID, LocationTbl::Rec * pPack, int use_ta);
	int    PutGuid(PPID id, const S_GUID * pUuid, int use_ta);
	//
	// Descr: возвращает список складов, доступных текущему пользователю
	//   Функция не очищает список pList перед добавлением в него новых элементов,
	//   однако вставка новых элементов реализуется методом PPIDArray::addUnique
	//   что исключает дублирование.
	// ARG(pList OUT): @#{vptr0} указатель на массив, в который функция вставит
	//   идентификаторы складов
	// ARG(pHasRestrictions OUT): @#{vptr0} по указателю присваивается значение true если
	//   существуют склады, к которым текущий пользователь не имеет доступа.
	//   В противном случае по указателю присваивается false.
	// Returns:
	//   Количество складов, обработанных функцией. Если pList == 0, то возвращаемое значение
	//   будет все равно правильным.
	// Remark: использует кэш
	//
	uint   GetWarehouseList(PPIDArray * pList, bool * pHasRestrictions);
	//
	// Descr: "Распрямляет" список складов pList, возможно, содержащий склады верхнего уровня.
	//   Результирующий список формируется по ссылке rDestList.
	//   В результирующий список не попадают склады, к которым у текущего пользователя нет
	//   прав доступа.
	//
	int    ResolveWarehouseList(const PPIDArray * pList, PPIDArray & rDestList);
	int    ResolveWhCellList(const PPIDArray * pList, long options, PPIDArray & rDestList);
	//
	// Descr: Определяет является ли локация locID дочерней по отношению к grpID.
	//   Для этого функция движется вверх по иерархии от locID до корневого узла.
	//   Если один из узлов в иерархии равен grpID, то результат положительный.
	// Note: Проверяет иерархию на циклические ссылки.
	// Returns:
	//   >0 - локация locID является дочерней по отношению к grpID
	//   <0 - локация locID не является дочерней по отношению к grpID
	//   0  - ошибка. В случае обнаружения цикла возвращается код ошибки PPERR_LOCATIONRECUR.
	//
	int    IsMemberOfGroup(PPID locID, PPID grpID);
	int    GetWarehouseTerminalList(PPID parentID, PPIDArray * pList);
	//
	// Descr: Определяет, наследуется ли locID от parentID по цепочке связей LocationTbl::Rec::ParentID
	// Note:
	//   Если parentID == 0, то функция считает, что locID не принадлежит parentID
	//   Если locID == parentID, то функция считает, что locID принадлежит parentID
	// Returns:
	//   1 - locID принадлежит parentID
	//   0 - locID не принадлежит parentID
	//
	int    BelongTo(PPID locID, PPID parentID, SString * pPathText);
	//
	// Descr: Возвращает ID склада если он в справочнике один-одинешенек, иначе - 0.
	//   Учитываются только те склады, к которым пользователь имеет доступ.
	// Remark: использует кэш
	//
	PPID   GetSingleWarehouse();
	//
	// Descr: Флаги функции PPObjLocation::EditDialog(PPID, PPLocationPacket *, long);
	//
	enum {
		edfMainRecOnly = 0x0001 // Редактировать только основную запись пакета (Regs, TagL не менять)
	};
	int    EditDialog(PPID locTyp, PPLocationPacket * pPack, long flags);
	int    EditDialog(PPID locTyp, LocationTbl::Rec * pRec);
	int    EditAddrStruc(SString & rAddr);
	//
	// Descr: Формирует строку адреса локации locID.
	// Note: Функционально является полным аналогом LocationCore::GetAddress за исключением
	//   того, что запись по идентификатору locID извлекается через кэш.
	//
	int    GetAddress(PPID locID, uint flags, SString & rBuf);
	int    GetCountry(PPID locID, PPID * pCountryID, PPCountryBlock * pBlk);
	int    GetCountry(const LocationTbl::Rec * pLocRec, PPID * pCountryID, PPCountryBlock * pBlk);
	int    GetCity(PPID locID, PPID * pCityID, SString * pName, int useCache);
	int    GetCityByName(const char * pName, PPID * pCityID);
	int    FetchCity(PPID cityID, WorldTbl::Rec * pRec);
	int    FetchCityByAddr(PPID locID, WorldTbl::Rec * pRec);
	int    GetList(const LocationFilt * pLocFilt, long zeroParentId, StrAssocArray & rList);
	StrAssocArray * MakeList_(const LocationFilt * pLocFilt, long zeroParentId = 0);
	//
	struct CreateWhLocParam {
		CreateWhLocParam();
		PPID   Type;
		LocationTbl::Rec CellSample;
	};
	int    EditCreateWhLocParam(CreateWhLocParam * pParam);
	//
	// Descr: Специализированная функция, используемая для идентификации
	//   набора объектов, которые должны быть помечены как dirty в кэше.
	//
	int    GetDirtyCellParentsList(PPID locID, PPIDArray & rDestList);
	//
	// Descr: Индексирует телефонные номера, находящиеся в записях таблицы Location
	//
	int    IndexPhones(PPLogger * pLogger, int use_ta);
	int    GetEaListBySubstring(const char * pSubstr, StrAssocArray * pList, int fromBegStr);
	const  StrAssocArray * GetFullEaList();
	void   ReleaseFullEaList(const StrAssocArray * pList);
	//
	// @attention: really private
	//
	int    ResolveWhCell(PPID locID, PPIDArray & rDestList, PPIDArray * pRecurTrace, int useCache);
	int    GetRegister(PPID locID, PPID regType, LDATE actualDate, bool iheritFromOwner, RegisterTbl::Rec * pRec);
	//int    ResolveWarehouseByCode(const char * pCode, PPID accSheetID, PPID * pArID);
	int    ResolveGLN(PPID locTyp, const char * pGLN, PPIDArray & rList);
	int    GetListByRegNumber(PPID regTypeID, PPID locTyp, const char * pSerial, const char * pNumber, PPIDArray & rList);
	//
	// Descr: Если адрес dlvrAddrID существует (и относится к типу LOCTYP_ADDRESS), то функция пытается 
	//   найти зарезервированный тег PPTAG_LOC_TRUNKPOINT, связанный с этим адресом и извлечь из него
	//   магистральную точку. Функция проверяет значение тега на предмет того, чтоб это был идентификатор 
	//   географического объекта типа WORLDOBJ_CITY либо WORLDOBJ_CITYAREA.
	// Returns: 
	//   !0 - магистральная точка (географический объект), связанная с адресом dlvrAddrID
	//    0 - а адресом dlvrAddrID не связана магистральная точка (либо это - не адрес вовсе).
	//
	PPID   GetTrunkPointByDlvrAddr(PPID dlvrAddrID);
private:
	friend class LocationCache; // Только для использования PPObjLocation(SCtrLite)
	friend class PPObjPerson;   // Только для использования PPObjLocation(SCtrLite)
	friend class PPQuotArray;   // Только для использования PPObjLocation(SCtrLite)

	static PPID FASTCALL Implement_ObjToWarehouse_Direct(PPID arID, int ignoreRights, PPID * pAcsID);
	void   InitInstance(SCtrLite sctr, void * extraPtr);
	PPObjLocation(SCtrLite);
	virtual int  DeleteObj(PPID id);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  MakeReserved(long flags);
	virtual const char * GetNamePtr();
	int    AddListItem(StrAssocArray * pList, const LocationTbl::Rec * pLocRec, long zeroParentId, PPIDArray * pRecurTrace);
		// @<<PPObjLocation::MakeList(const LocationFilt, long)
	int    MakeListByType(PPID locType, PPID parentID, long zeroParentId, int flags, StrAssocArray * pList);
		// @<<PPObjLocation::MakeList(const LocationFilt, long)
	int    ResolveWarehouse(PPID locID, PPIDArray & rDestList, PPIDArray * pRecurTrace);
		// @recursion @<<PPObjLocation::ResolveWarehouseList(const PPIDArray *, PPIDArray &)
	int    InitCityCache();
	int    GetCityID(PPID locID, PPID * pCityID, int useCache);
	int    InitWhCode(LocationTbl::Rec * pRec);
	int    AssignImages(ListBoxDef * pDef);
	int    SerializePacket(int dir, PPLocationPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		clsfStrList = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		clsfFromBeg = 0x0002  // Только карты, начинающиеся с pSubstr
	};
	int    Helper_GetEaListBySubstring(const char * pSubstr, void * pList, long flags);

	SCtrLite   Sctr;
	LAssocArray CityCache;
	int    IsCityCacheInited;
	PPObjWorld * P_WObj;
	PPObjRegister * P_RegObj;
	LocationFilt * P_CurrFilt;
	SString NameBuf; // Is returned by GetNamePtr
public:
	TLP_MEMB(LocationCore, P_Tbl);
	void * ExtraPtr;
};
//
//
//
struct PPLocAddrStruc_MatchEntry {
	explicit PPLocAddrStruc_MatchEntry(uint p1 = 0, uint p2 = 0, int reverse = 0);
	PPLocAddrStruc_MatchEntry(const PPLocAddrStruc_MatchEntry & rS);

	uint   P1;
	uint   P2;
	int    Reverse;
	LAssocArray CityStreetList;
};

class PPLocAddrStruc : public StrAssocArray {
public:
	//
	// Descr: Специальный тип идентифицирующий необходимость создания экземпляра
	//   объекта с собственным экземпляром PPFiasReference
	//
	enum ConditionalConstructWithFias {
		conditionalConstructWithFias = 1
	};

	explicit PPLocAddrStruc(const char * pText = 0, PPFiasReference * pFr = 0);
	PPLocAddrStruc(ConditionalConstructWithFias ccwf);
	~PPLocAddrStruc();
	int    Recognize(const char * pText);
	int    GetFiasTerminalID(PPID * pAddrID, PPID * pHouseID);
	int    Output(SString & rBuf); // @debug
	int    HasAmbiguity() const;
	const  TSCollection <PPLocAddrStruc_MatchEntry> * GetAmbiguityMatchList() const;
	const  PPLocAddrStruc_MatchEntry * GetAmbiguityMatchEntry() const;
	int    MatchEntryToStr(const PPLocAddrStruc_MatchEntry *, SString & rBuf);

	enum {
		tAddress = 1,
		tCountry,
		tZip,
		tLocalArea,
		tCity,
		tStreet,
		tHouse,
		tHouseAddendum,
		tCorp,
		tApart,
		tFloor,
		tPostBox,
		tAddendum, // Дополнительная информация в строке адреса
		tCityKind,
		tLocalAreaKind,
		tStreetKind,
		tHouseKind,
		tHouseAddendumKind,
		tApartKind,
		tFiasCityID,
		tFiasStreetID,
		tFiasHouseID,
		tFiasTerminalID
	};
	enum {
		sRussian = 1
	};
	int    Style;        // Стиль представления строки адреса. Обычно зависит от страны.
	long   Flags;
	PPID   CountryID;
	PPID   CityID;
	PPID   StreetID;
	PPID   FiasTerminalID;
	PPID   FiasCityID;
	PPID   FiasStreetID;
	PPID   FiasHouseID;
private:
	struct AddrTok {
		enum {
			fDot  = 0x0001,
			fUsed = 0x0002
		};
		AddrTok();
		~AddrTok();
		AddrTok & Z();

		enum {
			tFinish = 0,
			tDiv = 1,
			tText,
			tDescr,
			tZip,
			tNumber,
			tNum_Hyp_Num,
			tNum_Hyp_Num_Hyp_Num,
			tNum_Sl_Num,
			tNum_Al,
			tNum_Hyp_Al,
			tNum_Sl_Al
		};
		int    T;      // Токен
		uint   P;      // Начальная позиция в исходной строке
		long   Flags;  // @flags
		SString S;     // Текст
		LongArray Dl;  // Только для T == tDescr: список позиций (zero-based) в массиве AddrItemDescr Aidl[]
		TSCollection <AddrTok> * P_SplitL;
	};
	struct DescrSelector {
		DescrSelector();
		void   Init();
		int    T;
		int    Kt;
		SString Kind;
	};
	struct DetectBlock {
		DetectBlock & Init(int entityType, uint tokPos, const char * pOrgText, PPID fiasUpperID = 0);

		int    T;
		uint   P;
		PPID   FiasUpperID;
		SString OrgText;
		SString RecognizedText;
		LongArray FiasCandidList;
	};
	void   Helper_Construct();
	int    GetTok(AddrTok & rTok);
	int    ProcessDescr(const AddrItemDescr & rDescr, DescrSelector & rSel);
	int    DetectCityName(DetectBlock & rDb);
	int    DetectStreetName(DetectBlock & rDb);
	int    Recognize(const char * pText, TSCollection <AddrTok> & rTokList); // @debug
	void   OutputTokList(const TSCollection <AddrTok> & rList, SString & rBuf); // @debug
	int    GetFiasAddrObjKind(PPID adrObjID, SString & rKind);

	enum {
		stOwnFiasRef = 0x0001
	};
	long   State;
	long   ReZip;
	long   ReNum_Hyp_Num;
	long   ReNum_Hyp_Num_Hyp_Num;
	long   ReNum_Sl_Num;
	long   ReNumA_Hyp_Num;
	long   ReNumA_Sl_Num;
	SStrScan Scan;
	TSCollection <AddrTok> TokList;
	PPFiasReference * P_Fr; // @notowned unless State & stOwnFiasRef
	TSCollection <PPLocAddrStruc_MatchEntry> * P_AmbigMatchList;
	PPLocAddrStruc_MatchEntry * P_AmbigMatchEntry;
};
//
// @ModuleDecl(PPObjBnkAcct)
//
// Структура прикладной информации о банке
//
// Директивные флаги инициализации некоторых полей BnkAcctData
//
#define BADIF_INITBNAME    0x0001 // Инициализировать имя банка
#define BADIF_INITBIC      0x0002 // Инициализировать БИК
#define BADIF_INITCACC     0x0004 // Инициализировать корр.счет
#define BADIF_INITCITY     0x0008 // Инициализировать город
#define BADIF_INITBEXTNAME 0x0010 // Инициализировать расширенное имя банка
#define BADIF_INITALLBR    (BADIF_INITBNAME|BADIF_INITBIC|BADIF_INITCACC|\
	BADIF_INITCITY|BADIF_INITBEXTNAME)

struct PPBank {
	PPBank();
	PPID   ID;
	char   Name[128];
	char   BIC[24];
	char   CorrAcc[24];
	char   City[48];
	char   ExtName[128];
};

struct BnkAcctData {
	explicit BnkAcctData(long initFlags = BADIF_INITALLBR);
	int    Format(const char * pTitle, char * pBuf, size_t bufLen) const;

	long   InitFlags; // BADIF_XXX
	PPID   BnkAcctID;
	PPID   OwnerID;
	char   Acct[28];
	PPBank Bnk;
};
//
// @ModuleDecl(PPObjPersonRelType)
// Связи между персоналиями
//
// Тип связи между персоналиями
//
struct PPPersonRelType2 {  // @persistent @store(Reference2Tbl+)
	PPPersonRelType2();

	enum {
		cOneToOne = 1,
		cOneToMany,
		cManyToOne,
		cManyToMany
	};
	enum {
		ssUndef = 0,
		ssPrivateToPrivate,
		ssPrivateToLegal,
		ssLegalToPrivate,
		ssLegalToLegal
	};
	enum {
		fInhAddr  = 0x0001,
		fInhRAddr = 0x0002,
		fGrouping = 0x0004, // Группирующее отношение (только для Cardinality = cManyToOne)
		fInhMainOrgAgreement = 0x0008, // Наследует соглашение с клиентами из главной организации (только для филиалов)
		fInhAgreements       = 0x0010  // Наследует соглашение (хоть с клиентом, хоть с поставщиком) из родительской организации (PPPSNRELTYP_AFFIL)
	};
	long   Tag;            // Const=PPOBJ_PERSONRELTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[56];   // @reserve
	int16  StatusRestriction; // Ограничение по статусу отношений (PPPersonRelType::ssXXX)
	int16  Cardinality;    // Ограничение по множественности отношений (PPPersonRelType::cXXX)
	long   Flags;          // Флаги (PPPersonRelType::fXXX)
	long   Reserve2[2];    // @reserve
};

struct PPPersonRelTypePacket {
	PPPersonRelTypePacket();
	void   Init();
	PPPersonRelTypePacket & FASTCALL operator = (const PPPersonRelTypePacket &);
	PPPersonRelType Rec;
	PPIDArray InhRegTypeList;
};

class PPObjPersonRelType : public PPObjReference {
public:
	PPObjPersonRelType(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    PutPacket(PPID *, PPPersonRelTypePacket *, int use_ta);
	int    GetPacket(PPID, PPPersonRelTypePacket *);
	int    Fetch(PPID, PPPersonRelTypePacket *);
	//
	// Descr: Возвращает список типов отношений с признаком fGrouping
	// Return:
	//   >0 - найден по крайней мере один группирующий тип отношений
	//   <0 - не найдено ни одного группирующего типа
	//   0  - ошибка
	//
	int    GetGroupingList(PPIDArray * pList);
	int    SearchSymb(PPID *, const char * pSymb);
	int    SerializePacket(int dir, PPPersonRelTypePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  ProcessReservedItem(TVRez &);
};
//
// @ModuleDecl(PPObjPerson)
// @todo DlvrAddrExtFldList перевести на StrAssocArray (понадобится конвертация хранящихся в Property данных)
//
struct PPPersonConfig { // @transient (для сохранения проецируется на PropertyTbl::Rec)
	PPPersonConfig();
	void   Init();

	struct ClientActivityDetectionItem {
		ClientActivityDetectionItem();
		PPObjID Oi;
		long   Flags;
		uint8  Reserve[12];
	};

	enum {
		fSyncByName                = 0x0001, // Синхронизировать по имени
		fSyncBySrchReg             = 0x0002, // Синхронизировать по поисковому регистру
		fSyncDeclineUpdate         = 0x0004, // Не принимать изменения из других разделов
		fSyncMergeRegList          = 0x0008, // При синхронизации объединять регистры
		fValid                     = 0x1000, // Признак того, что запись является действительной (загруженной из базы данных)
		fShowPsnImageAfterCmdAssoc = 0x2000, // Показывать диалог с картинкой персоналии после ввода ассоциированной команды с рабочего стола (или из панели чеков)
		fSendAttachment            = 0x4000, // Передавать в другие разделы файлы, прикрепленные к персоналиям (обычно, изображения)
		fSyncAppendAbsKinds        = 0x8000  // При акцепте персоналии из другого раздела включать в принимаемую
			// персоналию недостающие виды, необходимые для связывания существующих аналитических статей.
			// Опция вводится для смягчения ошибки PPERR_AR_INVLINKPERSONKIND
	};
	PPID   TradeLicRegTypeID;     // Тип регистрационного документа, используемого для торговой лицензии предприятия //
	PPID   RegStaffCalID;         // Регулярный штатный календарь
	long   Flags;
	long   SendSmsSamePersonTimeout; // Таймаут на отсылку SMS одной и той же персоналии (seconds).
	long   StaffCalQuant;         // Квант времени в сек. для временной диаграммы анализа штатных календарей.
	//
	// Понятие критической задержки активности клиента подразумевает детекцию факта отсутствия активности клиента в течении какого-то
	// времени (в том смысле, что надо ему, наверное, позвонить и спросить не разлюбил ли он нас).
	// 
	// Понятие безнадежной задержки активности клиента подразумевает детекцию факта невозможности вернуть клиента.
	// 
	uint16 CriticalCliActivityDelayDays; // @v12.2.2 Критическая задержка активности клиента в днях.
	uint16 HopelessCliActivityDelayDays; // @v12.2.2 Безнадежная задержка активности клиента в днях.
	float  CriticalCliActivityDelaySigm; // @v12.2.2 Критическая задержка активности клиента в сигмах (стандартных отклонениях от средней периодичности).
	float  HopelessCliActivityDelaySigm; // @v12.2.2 Безнадежная задержка активности клиента в сигмах (стандартных отклонениях от средней периодичности).
	PPID   CliActivityPsnKindID;  // @v12.2.9 Вид персоналии (по умолчанию), по которому анализируется клиентская активность
	TimeRange SmsProhibitedTr;    // Диапазон времени, в течении которого запрещено отсылать SMS-сообщения (ночь, очевидно)
	SString TopFolder;            // @anchor
	SString AddImageFolder;       // Папка из которой будут автоматически прикрепляться файлы к персоналиям. хранится в реестре
	StrAssocArray DlvrAddrExtFldList; // Наименования дополнительных полей для адресов доставки //
	TSVector <ClientActivityDetectionItem> ClientActivityDetectionList;
};

struct PersonReq { // @flat
	PersonReq();
	long   Flags;        // @flags
	PPID   AddrID;       // Ид юридического адреса
	PPID   RAddrID;      // Ид фактического адреса
	char   Name[128];    // @name
	char   ExtName[128]; // Расширенное наименование
	char   Addr[128];    // Текст юридического адреса
	char   RAddr[128];   // Текст фактического адреса
	char   Phone1[64];   // Список телефонов через ';'
	char   TPID[32];     // @russia код ИНН
	char   KPP[12];      // @russia код КПП
	char   OKONF[32];    // @russia код ОКОНФ
	char   OKPO[32];     // @russia код ОКПО
	PPID   SrchRegTypeID; // Тип регистра для поиска. Если для персоналии не определено ни одного
		// поискового регистра, то SrchRegTypeID = 0 (даже если для какого-либо из видов, которому принадлежит
		// персоналии такой тип регистра определен).
	char   SrchCode[32];  // Номер поискового регистра (тип этого регистра прописан в виде персоналии).
		// Если персоналия относится к нескольким видам, то тип поискового регистра берется из первого
		// встреченного вида, которому принадлежит персоналия и для которого определен тип поискового регистра.
	BnkAcctData BnkAcct;
	char   Memo[256];     // @memo // @v11.1.12 [128]-->[256]
};
//
//
//
#define CIF_CASHIER    0x0001
#define CIF_MODIFIED   0x0002

struct CashierInfo {
	CashierInfo();
	int    FASTCALL IsEq(const CashierInfo & rS) const;

	char   Password[20]; // Пароль кассира
	long   Rights;	     // Права  кассира
	long   Flags;		 // CIF_XXX
};

class PPPersonPacket : public PPPerson, public ObjTagContainerHelper { // Managed by class PPObjPerson
public:
	PPPersonPacket();
	PPPersonPacket(const PPPersonPacket & rS);
	~PPPersonPacket();
	PPPersonPacket & FASTCALL operator = (const PPPersonPacket &);
	PPPersonPacket & Z();
	int    GetRegister(PPID regTyp, uint * pos) const;
	int    GetRegNumber(PPID regTyp, SString & rBuf) const;
	int    GetSrchRegNumber(PPID * pRegTypeID, SString & rBuf) const;
	int    GetAddress(uint, SString & rBuf);
	int    GetRAddress(uint, SString & rBuf);
	int    GetPhones(uint maxCount, SString & rBuf);
	int    GetCurrBnkAcct(PPBankAccount *) const;
	void   FASTCALL SetExtName(const char * pName);
	int    FASTCALL GetExtName(SString & rBuf) const;
	int    AddRegister(PPID regTypeID, const char * pNumber, int checkUnique = 1);
	//
	// Descr: Возвращает информацию об адересе доставки из внутреннего списка по индексу *pPos
	//   и, в случае успеха, увеличивает значение индекса *pPos на единицу.
	//   !0 - адрес успешно присвоен по указателю pPack. Индекс по указателю pPos увеличен на 1.
	//    0 - позиция pos выходит за пределы [0..GetDlvrLocCount()]
	//
	int    EnumDlvrLoc(uint * pPos, PPLocationPacket * pPack) const;
	//
	// Descr: Возвращает информацию об адересе доставки из внутреннего списка по индексу pos.
	// Returns:
	//   !0 - адрес успешно присвоен по указателю pPack
	//    0 - позиция pos выходит за пределы [0..GetDlvrLocCount()]
	//
	int    GetDlvrLocByPos(uint pos, PPLocationPacket * pPack) const;
	uint   GetDlvrLocCount() const;
	int    AddDlvrLoc(const PPLocationPacket & rAddr);
	int    PutDlvrLoc(uint pos, const PPLocationPacket * pAddr);
	void   ClearDlvrLocList();      // @Muxa  @v7.3.7
	//
	// Descr: Замещает адрес доставки locID в пакете на адрес доставки с идентификатором replacementID.
	// Note: Фукнция проверяет идентификатор replacementID на существование и, кроме того, проверяет
	//   что бы соответствующая запись действительно была адресом (не складом и т.д.)
	// Returns:
	//   1 - адрес locID успешно замещен на replacementID
	//   2 - адрес replacementID был в пакете - просто удален адрес locID.
	//  -1 - адрес locID в пакете не найден
	//   0 - error.
	//
	int    ReplaceDlvrLoc(PPID locID, PPID replacementID);
	int    SetSCard(const PPSCardPacket * pScPack, int autoCreate);
	const  PPSCardPacket * GetSCard() const;

	RegisterArray    Regs;          // Список регистров
	PPLocationPacket Loc;           // Юридический адрес
	PPLocationPacket RLoc;          // Фактический адрес
	PPELinkArray ELA;           // Список электронных адресов
	CashierInfo  CshrInfo;      // Специфическая информация о кассире (для загрузки в кассовые модули)
	ObjLinkFiles LinkFiles;     // @transient
	ObjTagList   TagL;          // @transient
	StaffAmtList Amounts;       // Список штатных сумм (только для работодателей)
	enum {
		ufDontChgImgFlag  = 0x0001, // Функция PPObjPerson::PutPacket не должна изменять флаг GF_HASIMAGES
		ufDontChgStaffAmt = 0x0002, // Функция PPObjPerson::PutPacket не должна изменять список штатных сумм
		ufDontRmvDlvrLoc  = 0x0004, // Функция PPObjPerson::PutPacket не должна удалять из БД адреса доставки, которых нет в пакете
		ufDontEditRelPsn  = 0x0008  // Не позволяет редактировать персоналию из диалога списка отношений персоналии, чтобы избежать рекурсии.
	};
	long   UpdFlags;                // @transient Флаги, определяющие правила изменения некоторых полей
	//
	// Descr: значение, идентифицирующее выбранный адрес в данном пакете.
	// Если SelectedLocPos > 0 && SelectedLocPos <= DlvrLocList.getCount(), то идентифицирует позицию (1..) в
	//   списке адресов доставки.
	// Если SelectedLocPos == -1, то - юридический адрес
	// Если SelectedLocPos == -2, то - реальный адрес
	// 0 - не определенное значение.
	//
	long   SelectedLocPos;          // @transient
private:
	SString ExtString;
	TSCollection <PPLocationPacket> DlvrLocList; // Список адресов доставки
	PPSCardPacket * P_SCardPack; // @transient Используется при одновременном редактировании персоналии и карты
};
//
// Флаги дополнительных прав доступа персоналий
//
#define PSNRT_UNITE             0x0100 // Право на объединение персоналий
#define PSNRT_UPDIMAGE          0x0200 // Право на изменение присоединенной картинки
#define PSNRT_UNITEADDR         0x0400 // Право на объединение адресов доставки
#define PSNRT_MULTUPD           0x0800 // Право на массовое изменение или удаление
//
// Флаги функции PPObjPerson::GetPacket
//
#define PGETPCKF_USEINHERITENCE 0x0001 // При извлечении регистров использовать наследование
//
// Опции (параметр option) функции PPObjPerson::GetAddrID
//
#define PSNGETADDRO_DEFAULT   0 // Брать основной адрес персоналии
#define PSNGETADDRO_REALADDR  1 // Брать действительный адрес персоналии. Если этот адрес для персоналии не определен, то брать основной адрес.
#define PSNGETADDRO_DLVRADDR  2 // Брать адрес доставки. Если адрес доставки не определен, то работает как PSNGETADDRO_REALADDR.
//
// Флаги (параметр flags) функции PPObjPerson::Subst
//
#define PSNSUBSTF_LASTRELINHIERARH 0x00000001L

class PPObjPerson : public PPObject {
	//
	// В качестве дополнительного параметра методам PPObjPerson передается вид персоналии.
	//
public:
	enum {
		sapfMatchWholeWord = 0x0001
	};
	struct SrchAnalogPattern {
		explicit SrchAnalogPattern(const char * pNamePattern = 0, long flags = 0);

		SString NamePattern;
		long   Flags;             // Флаги (PPObjPerson::sapfXXX)
	};
	static int FASTCALL ReadConfig(PPPersonConfig *);
	static int FASTCALL WriteConfig(const PPPersonConfig *, int use_ta);
	static int EditConfig();
	//
	// Descr: Специализированная функция, открывающая диалог для редактирования параметров
	//   анализа клиентской активности как части конфигурации персоналий.
	//   В качестве standalone-варианта понадобилась потому, что эти параметры
	//   необходимо редактировать не только из диалога конфигурации персоналий, но и из
	//   диалога фильтра персоналий.
	//
	static int EditClientAcitivityConfig(PPPersonConfig & rCfg);
	static int ReplacePerson(PPID srcID = 0, PPID srcKindID = 0);
	static int ReplaceDlvrAddr(PPID srcID);
	static int TestSearchEmail();
	//
	// Descr: Извлекает информацию о персоналии, ассоциированной с текущим пользователем (LConfig.User).
	// ARG(pPersonID      OUT): @#{vptr0} Указатель, по которому функция присваивает идентификатор искомой
	//   персоналии. Если pPersonID == 0, то функция не пытается ничего присвоить по этму адресу.
	//   Если с пользователем не связана действительная запись персоналии, то по указателю присваивается 0.
	// ARG(pPersonName IN/OUT): @#{vptr0} Указатель на строку, в которую, если указатель не нулевой,
	//   функция записывает наименование найденной персоналии. Если указатель нулевой, то функция не пытается //
	//   извлекать запись персоналии, связанной с пользователем.
	//   Если с пользователем не связана действительная запись персоналии, то по указателю присваивается пустая строка.
	// Returns:
	//   >0 - с текущим пользователем связана действительная запись персоналии.
	//   -2 - не найдена запись текущего пользователя //
	//   -1 - с текущим польователем либо не связана персоналия, либо по связанному идентификатору не найдена
	//        запись персоналии.
	//   0  - ошибка
	//
	static int FASTCALL GetCurUserPerson(PPID * pPersonID, SString * pPersonName);

	explicit PPObjPerson(void * extraPtr = 0);
	explicit PPObjPerson(SCtrLite); // @v12.2.4 private-->public
	~PPObjPerson();
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Search(PPID id, void * b = 0);
	virtual int RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	int    IsPacketEq(const PPPersonPacket & rS1, const PPPersonPacket & rS2, long flags);

	struct EditBlock {
		EditBlock();

		PPID   InitKindID;
		PPID   InitStatusID;
		int    ShortDialog;  // 0 - использовать обычный диалог, 1 - использовать сокращенный диалог,
			// другое - идентификатор диалога, который следует использовать.
		PPID   SCardSeriesID;
		SString Name;
		SString InitPhone;   //
		//
		PPID   RetSCardID;   // @out Ид дисконтной карты, созданной (выбранной) в сокращенном диалоге
		long   UpdFlags;     // -> PPPersonPacket::UpdFlags
	};
	void   InitEditBlock(PPID kindID, EditBlock & rBlk);
	int    Edit_(PPID * pID, EditBlock & rBlk);
	//
	// Descr: Извлекает частичную запись персоналии с идентификатором id из кэша.
	//   Поля инициализируемые в записи pRec: {ID, Name, MainLoc, RLoc, CatID, Flags}
	// Returns:
	//   >0 - Запись найдена. По указателю pRec присваивается запись с инициализированными
	//     полями, перечисленными в описании выше. Остальные поля инициализируются в 0.
	//   <0 - Запись с идентификатором id не найдена. Содержимое по указателю pRec
	//     имеет непредсказуемые значения.
	//   0  - Ошибка. Содержимое по указателю pRec имеет непредсказуемые значения.
	//
	int    FASTCALL Fetch(PPID id, PersonTbl::Rec * pRec); // @macrow
	int    FASTCALL FetchConfig(PPPersonConfig * pCfg);
	int    DirtyConfig();
	const PPPersonConfig & GetConfig();
	int    ExtEdit(PPID * pID, void * extraPtr);
	//
	// Descr: Выводит диалог редактирования версии histID пакета персоналии.
	//
	int    ViewVersion(PPID histID);
	//
	// Descr: Извлекает из базы данных список идентификаторов персоналий, относящихся к 
	//   категории catID. Кроме того, если параметр kindID != 0 то функция проверяет чтобы 
	//   в список попали идентификаторы только тех персоналий, которые принадлежат виду kindID.
	//   Если аргумент catID <= 0 то функция немедленно возвращает -1
	//   Массив по ссылке rList предварительно очищается функцией.
	// Returns:
	//   >0 - найдена по крайней мере одна персоналия, удовлетворяющая заданным критериям
	//   <0 - не найдено ни одной персоналии, удовлетворяющих заданным критериям
	//    0 - error
	//
	int    GetPersonListByCategory(PPID catID, PPID kindID, PPIDArray & rList);
	//
	// Descr: Извлекает из базы данных список персоналий, ссылающихся на адрес доставки dlvrLocID.
	//   Массив по ссылке rList предварительно очищается функцией.
	// Returns:
	//   >0 - есть, по крайней мере, одна персоналия, ссылающаяся на адрес dlvrLocID как на адрес доставки
	//   <0 - нет ни одной персоналии, ссылающейся на адрес доставки dlvrLocID
	//   0  - ошибка
	//
	int    GetPersonListByDlvrLoc(PPID dlvrLocID, PPIDArray & rList);
	int    GetDlvrLocList(PPID personID, PPIDArray * pList);
	int    EditDlvrLocList(PPID personID);
	int    SetupDlvrLocCombo(TDialog *, uint ctlID, PPID personID, PPID locID);
	int    AddRegisterToPacket(PPPersonPacket & rPack, PPID regTypeID, const char * pNumber, int checkUnique = 1);
	//
	// Descr: Вызывает диалог редактирования списка сумм, принадлежащих персоналии id,
	//   если эта персоналия относится к виду "Работодатели".
	// Returns:
	//   >0 - пользователь нажал OK в диалоге
	//   <0 - пользователь отказался от редактирования //
	//   0  - ошибка
	//
	int    EditAmountList(PPID id);
	//
	// Descr: Редактирует список отношений персоналии id в обход общего диалога
	//   редактирования персоналии.
	// Returns:
	//   >0 - пользователь изменил список отношений и успешно провел его
	//   <0 - пользователь не менял список отношений
	//   0  - ошибка
	//
	int    EditRelationList(PPID id);
	//
	// Descr: Вызывает диалог добавления отношения для персоналии id. Если relTypeID != 0
	//   то диалог инициализируется указанным видом отношения. Если успешно пользователь создал
	//   новое отношение, то информация об этом сохраняется в базе данных.
	// Returns:
	//   >0 - пользователь успешно сождал новое отношение и провел его
	//   <0 - пользователь отказался от создания нового отношения //
	//   0  - ошибка
	//
	int    EditRelation(PPID * pPrmrID, PPID * pScndID, PPID * pRelTypeID);
	int    AddRelationList(PPID * pPrmrID, PPIDArray * pScndList, PPID * pRelTypeID, int reverse);
	int    RemoveRelation(PPID prmrID, PPID scndID, PPID relTypeID);
	int    GetRelPersonList(PPID personID, PPID relTypeID, int reverse, PPIDArray * pList, int lastInHieararhy = 0, PPIDArray * pHierarhIDList = 0);
	int    GetPacket(PPID, PPPersonPacket *, uint flags /* PGETPCKF_XXX */);
	int    PutPacket(PPID * pID, PPPersonPacket *, int use_ta);
	int    ValidatePacket(const PPPersonPacket * pPack, long flags);
	int    PutGuid(PPID id, const S_GUID * pUuid, int use_ta);
	int    GetBankData(PPID, PPBank *);
	//
	// Descr: Извлекает предпочтительный банковский счет для персоналии personID.
	//   Если pBnkAcctID != 0 && *pBnkAcctID != 0, то среди счетов персоналии
	//   ищется тот, который имеет заданный идентификатор. Если такой найден,
	//   то он и возвращается. В противном случае извлекается либо первый счет
	//   с признаком "предпочтительный" (/*BACCTF_PREFERRED*/PREGF_BACC_PREFERRED) либо самый первый в списке.
	//   Если параметр bankID != 0 тогда ищется счет, банк которого точно равен
	//   bankID или же тот, который равен ненулевому значению *pBnkAcctID.
	// ARG(personID       IN): ИД персоналии, для которой ищется счет
	// ARG(pBnkAcctID IN/OUT): @#{vptr0} указатель, по которому присваивается ид
	//   найденного счета или 0, если ничего не найдено.
	//   Обратите внимание, что если не требуется проверка на принадлежность
	//   счета *pBnkAcctID персоналии personID, то значение по этому указатели
	//   при входе в функцию должно быть нулевым.
	// Returns:
	//   >0 - если для персоналии найден хотя бы один подходящий счет.
	//   <0 - у персоналии personID нет ни одного банковского счета.
	//    0 - error
	//
	int    GetSingleBnkAcct(PPID personID, PPID bankID, PPID * pBnkAcctID, /*BankAccountTbl::Rec*/PPBankAccount * pRec);
	int    GetStaffAmtList(PPID id, StaffAmtList * pList);
	int    PutStaffAmtList(PPID id, const StaffAmtList * pList);
	int    SearchFirstByName(const char * pName, const PPIDArray * pKindList, PPID exclID, PersonTbl::Rec * pRec);
	enum {
		smlRegisterOnly = 0x0001
	};
	int    SearchMaxLike(const PPPersonPacket *, PPID * pID, long flags, PPID regTypeID/*= PPREGT_TPID*/);
	int    SearchEmail(const char * pEmail, long flags, PPIDArray * pPsnList, PPIDArray * pLocList);
	int    GetListByKind(PPID psnKindID, PPIDArray *, StrAssocArray * pNameList);
	//
	// Descr: Формирует список персоналий, чье имя подходит под правила образца pPattern.
	// Remark: Реализация опции sapfMatchWholeWord - отвратительна
	//
	int    GetListByPattern(const SrchAnalogPattern * pPattern, PPIDArray * pList);
	int    GetListBySubstring(const char * pSubstr, PPID kindID, StrAssocArray * pList, int fromBegStr);

	class ResolverParam {
	public:
		ResolverParam();
		enum {
			fCreateIfNFound = 0x0001,
			fIgnoreKppWhenSearching = 0x0002 // Не пустой код КПП не применять для сужения поиска по ИНН (только для создания новой персоналии)
		};
		enum {
			attrUUID = 1,
			attrCommonName,
			attrGLN,
			attrINN,
			attrPhone,
			attrEMail
		};
		long   Flags;
		PPID   KindID;
		PPID   StatusID; // @v12.1.3 Юридический статус персоналии
		S_GUID Uuid;
		SString CommonName;
		SString INN;
		SString KPP;
		SString GLN;
		SString Phone; // Поиск по телефону работает только если телефоны проиндексированы
		SString EMail;
		// default priority is: attrUUID, attrGLN, attrINN, attrPhone, attrEMail, attrCommonName
		LongArray AttrPriorityList;
	};
	int    Resolve(const ResolverParam & rP, PPIDArray & rCandidateIdList, int use_ta);
	//
	// Descr: Выбирает список персоналий со значением регистра regTypeID pSerial:pNumber.
	//   Если kindID != 0, то из найденного списка вычленяет только те персоналии, которые
	//   относятся к виду kindID.
	// ARG(regTypeID IN): тип регистрационного документа, которому соответствуют заданные серия и номер
	// ARG(kindID    IN): вид, которому должны принадлежать найденные персоналии
	// ARG(pSerial   IN): @#vptr0 серия регистрационного документа. Если pSerial == 0 или pSerial[0] == 0,
	//   то просматриваются регистрационные документы независимо от серии
	// ARG(pNumber   IN): @#vptr0 номер регистрационного документа.
	// ARG(pIDList  OUT): @#vptr0 массив, в который заносятся идентификаторы найденных персоналий.
	//   Если до вызова функции массив был непустым, то это содержимое теряется.
	// Returns:
	//   >0 - найдена как минимум одна персоналия с заданными свойствами
	//   <0 - не найдено ни одной персоналии с заданными свойствами (инициализируется код ошибки)
	//   0  - ошибка
	//
	int    GetListByRegNumber(PPID regTypeID, PPID kindID, const char * pSerial, const char * pNumber, PPIDArray & rIDList);
	//
	// Descr: То же, что и GetListByRegNumber(PPID, PPID, const char * pSerial, const char *, PPIDArray *),
	//   но с pSerial = 0
	//
	int    GetListByRegNumber(PPID regTypeID, PPID kindID, const char * pNumber, PPIDArray & rIDList);
	int    GetRegList(PPID, RegisterArray *, int useInheritence);
	int    GetRegister(PPID personID, PPID regType, RegisterTbl::Rec * pRec);
	int    GetRegister(PPID personID, PPID regType, LDATE actualDate, RegisterTbl::Rec * pRec);
	int    GetRegNumber(PPID personID, PPID regType, SString & rBuf);
	int    GetRegNumber(PPID personID, PPID regType, LDATE actualDate, SString & rBuf);
	int    ResolveGLN(const char * pGLN, PPID * pID);
	int    ResolveGLN_Article(const char * pGLN, PPID accSheetID, PPID * pArID);
	int    GetStatus(PPID, PPID * pStatusID, int * pIsPrivate);
	int    GetAddrID(PPID psnID, PPID dlvrAddrID, int option, PPID * pAddrID);
	//
	// Descr:
	//   if Person(id).Status == PPPRS_COUNTRY then
	//      *pCountryID = 0, pCountryName = Person(id).Name
	//      return 2
	//   else *pCountryID  = City(Location(Person(id).MainLoc).CityID).CountryID
	//      pCountryName = Country(City(Location(Person(id).MainLoc).CityID).CountryID).Name
	//      return 1
	//   in case of searching fault
	//      return -1
	//   otherwise
	//      return 0;
	//
	int    GetCountry(PPID id, PPID * pCountryID, PPCountryBlock * pBlk);
	int    GetCityByAddr(PPID addrID, PPID * pCityID, SString * pCityName, int useLocCityCache = 0);
	//
	// Descr: Так как юридические и физические адреса персоналий не имеют ссылки на
	//   персоналию-владельца, то эта функция находит персоналию, которая ссылается на адрес rLocRec.ID
	//   как на юридический или на физический, и заполняет поле OwnerID соответствующим идентификатором.
	// Note: Если rLocRec.OwnerID не равен 0 или rLocRec.ID == 0, то функция ничего не делает.
	// Returns:
	//   <0 - rLocRec.OwnerID != 0 || rLocRec.ID == 0 || не найдено ни одной персоналии, ссылающейся на rLocRec.ID
	//   1  - найдена единственная персоналия, ссылающаяся на rLocRec.ID как на юридический или физический адрес.
	//   2  - существует более одной персоналии, ссылающихся на rLocRec.ID как на юридический или физический адрес.
	//      В этом случае применяется первая найденная персоналия как владелец.
	//   0  - ошибка
	//
	int    AdjustLocationOwner(LocationTbl::Rec & rLocRec);
	//
	// Descr: Извлекает адрес персоналии с идентификатором id.
	//   Если персоналия не найдена либо не имеет адреса, то rBuf = 0.
	//
	int    GetAddress(PPID id, SString & rBuf);
	int    GetExtName(PPID, SString & rBuf);
	int    FormatRegister(PPID, PPID regTypeID, char * buf, size_t buflen);
	int    GetBnkAcctData(PPID bnkAcctID, const PPBankAccount *, BnkAcctData *);
	int    GetPersonReq(PPID, PersonReq *);
	int    GetTradeLicList(PPID, RegisterArray *);
	int    GetActualTradeLic(PPID, LDATE, RegisterTbl::Rec *);
	//
	// Функции для работы с адресной книгой.
	// Адресная книга - это таблица ассоцииаций {PPOBJ_USER, PPOBJ_PERSON},
	// хранящаяся в таблице ObjAssoc (PPASS_ADDRESSBOOK).
	// Таким образом, каждый пользователь системы имеет собственную адресную книгу.
	// В следующих функциях параметр userID идентифицирует пользователя. Если userID == -1,
	// то эти функции полагают userID == LConfig.User.
	//
	int    AddToAddrBook(PPID personID, PPID userID, int use_ta);
	int    RemoveFromAddrBook(PPID personID, PPID userID, int use_ta);
	int    EnumAddrBookItems(PPID userID, PPID * pPersonID, ObjAssocTbl::Rec *);
	int    GetAddrBookIDList(PPID userID, PPIDArray * pList);
	//
	// Descr: Создает запись персоналии по заданному имени и принадлежности к виду
	//
	int    AddSimple(PPID *, const char * pName, PPID kindID, PPID statusID, int use_ta);
	//
	// Descr: Создает запись банка по параметрам, указанным в структуре pBnk.
	//
	int    AddBankSimple(PPID *, const PPBank * pBnk, int use_ta);
	//
	// Descr: Импортирует данные о персоналиях из DBF-файла. Описание соответствия полей
	//   должно быть в файле BIN\import.ini.
	// ARG(specKind IN):
	//   0           - описание берется из зоны [person]
	//   PPPRK_SUPPL - описание берется из зоны [suppl]. При этом некоторые параметры импорта
	//     заимствуются из таблицы статей GetSupplAccSheet(), но имеют меньший приоритет, чем
	//     соответствующие значения в файле описания import.ini.
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	//
	int    Import(int specKind, int use_ta);
	//
	// Descr: Новая унифицированная версия импорта персоналий
	//
	int    Import();
	//
	// Функции подстановки
	//
	struct SubstParam {
		SubstParam();
		void   Init(SubstGrpPerson sgp);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
		enum {
			fSubstDlvrAddr    = 0x0001, // Подставлять адрес доставки
			fSubstPersonRAddr = 0x0002  // Подставлять фактический адрес
				// Priority: fSubstDlvrAddr, fSubstPersonRAddr
		};
		SubstGrpPerson Sgp;
		long   Flags;
		PPObjWorld WObj;
	};
	int    Subst(PPID psnID, PPID dlvrLocID, SubstParam *, long flags, PPID * pDestID);
	int    GetSubstObjType(long id, const SubstParam * pParam, PPObjID * pObjId) const;
	void   GetSubstText(PPID psnID, PPID dlvrLocID, SubstParam *, SString & rBuf);
	//
	// Descr: Сравнивает записи и возвращает их похожесть в диапазоне [0..1]
	// pSwap = 1, значит что элемент 2 сравнивался с элементом 1, иначе элемент 1 с элементом 2
	//
	double CalcLikeness(const PersonTbl::Rec * pRec1, const PersonTbl::Rec * pRec2, int * pSwap, long extra);
	int    CheckDuplicateName(const char * pName, PPID * pID);
	int    SelectAnalog(const char * pName, PPID * pID);
	int    Helper_WritePersonInfoInICalendarFormat(PPID personID, int icalToken, const char * pRole, SString & rBuf);
	//
	// Descr: Индексирует телефонные номера, связанные с персоналиями
	//
	int    IndexPhones(PPLogger * pLogger, int use_ta);
	int    SerializePacket(int dir, PPPersonPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum ClientActivityStatisticsIndicator { // @persistant
		casiFirstEventDt = 1, // Дата первого события //
		casiLastEventDt,      // Дата последнего события // 
		casiEventCount,       // Количество событий
		casiDateCount,        // Количество дней, охваченных событиями 
		casiGapDaysAvg,       // Средний перерыв между событиями в днях //
		casiGapDaysStdDev,    // Стандартное отклонение перерыва между событиями 
		casiCurrentDelayDays, // @v12.2.4 Текущая (относительно даты ActualDate) задержка активности в днях
		casiCurrentDelaySd    // @v12.2.4 Текущая (относительно даты ActualDate) задержка активности в стандартных отклонениях //
	};
	//
	// Descr: Структура представляющая агрегированные значения статистики активности клиентов.
	//   Структура сохраняется в таблице PropertyTbl в привязке к персоналии.
	//
	struct ClientActivityStatistics { // @flat // @persistent
		ClientActivityStatistics();
		ClientActivityStatistics & Z();
		bool   FASTCALL IsEq(const ClientActivityStatistics & rS) const;
		//
		// Descr: Возвращает true если в структуре определен PersonID, EventCount != 0, а
		//   FirstEventDt и LastEventDt не нулевые и валидные.
		//
		bool   IsDetermined() const;

		PPID   PersonID;
		LDATE  FirstEventDt;  // Дата первого события //
		LDATE  LastEventDt;   // Дата последнего события // 
		uint32 EventCount;    // Количество событий
		uint16 DateCount;     // Количество дней, охваченных событиями 
		uint16 Reserve2;      // @alignment 
		double GapDaysAvg;    // Средний перерыв между событиями в днях //
		double GapDaysStdDev; // Стандартное отклонение перерыва между событиями 
		uint8  Reserve[64];
	};
	//
	// Descr: Блок, определяющий значение статуса активности клиента (State), привязанного к параметрам, заданным здесь же.
	//
	struct ClientActivityState { // @v12.2.2
		static bool GetStateText(uint state, SString & rBuf);

		ClientActivityState();
		//
		// Значения статусов активности клиентов
		//
		enum { // @persistent
			stUndef               = 0, // Неопределенный (не инициализирован)
			stNoData              = 1, // По клиенту нет (достаточной) статистики активности
			stRegularTa           = 2, // Активность клиента находится в приемлемых рамках
			stDelayedTa           = 3, // Клиент давно не проявлял активности, но есть шанс его вернуть (задержка относительно не велика)
			stHopelesslyDelayedTa = 4, // Вероятно, клиента вернуть не удасться (задержка активности слишком велика)
			//
			stfNewClient          = 0x1000 // Битовый признак нового клиента. Признак нового клиента устанавливается если первая транзакция попадает
				// в заданный интервал NewCliPeriod (если это интервал не пустой).
		};
		PPID   PersonID;        // IN
		LDATE  ActualDate;      // IN
		DateRange NewCliPeriod; // IN
		int    CurrentDelayDays; // OUT Текущая (относительно даты ActualDate) задержка активности в днях
		float  CurrentDelaySd;   // OUT Текущая (относительно даты ActualDate) задержка активности в стандартных отклонениях //
		uint   State;           // OUT
	};

	int    StoreClientActivityStatistics(PPID personID, const ClientActivityStatistics & rTotalEntry, const TSVector <uint16> & rDateList, int use_ta);
	int    ReadClientActivityStatistics(PPID personID, ClientActivityStatistics & rTotalEntry, TSVector <uint16> * pDateList);
	int    FetchCas(PPID id, ClientActivityStatistics * pCas);
	int    FetchClientActivityDateList(PPID id, TSVector <LDATE> & rDateList);
	int    IdentifyClientActivityState(ClientActivityState & rParam);
private:
	friend class PersonCache;
	friend int FASTCALL GetPersonName(PPID id, SString & rBuf);

	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int  UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	virtual int  DeleteObj(PPID id);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint, ObjRights *, EmbedDialog * = 0);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual const char * GetNamePtr();
	virtual int  MakeReserved(long flags);
	int    ReplyPersonELinkDel(PPID);
	int    ReplyPersonTagDel(PPID);
	int    ReplyLocationReplace(PPID dest, PPID src);
	int    UpdateAddress(PPID * pID, PPLocationPacket * pLocPack);
	ListBoxDef * _Selector2(ListBoxDef * pDef, long flags, void * extraPtr);
	//
	// Descr: Находит дублирование регистров и вставляет
	//   в начало их серии код #number (number - число от 1 до MAXLONG)
	//
	int    PreventDupRegister(PPID id, PPPersonPacket *); // @<<PPObjPerson::Write()
		// @<<PPObjPerson::Write
	int    Helper_GetAddrID(const PersonTbl::Rec *, PPID psnID, PPID dlvrAddrID, int option, PPID * pAddrID);
	int    Helper_PutSCard(PPID personID, PPPersonPacket * pPack);

	SCtrLite Sctr;
	PPObjArticle * P_ArObj;    //
	PPObjProcessor * P_PrcObj; // Скрытый экземпляр для быстрой обработки сообщений DBMSG_PERSONACQUIREKIND
	PPObjSCard * P_ScObj;      // @v11.3.10 При изменении пакета (PPObjPerson::PutPacket) необходимо идентифицировать карты, владелец которых меняется //
	PPPersonConfig Cfg;        // Использовать только через PPObjPerson::GetConfig()
	int    DoObjVer_Person;    // Хранить версии измененных и удаленных объектов
public:
	TLP_MEMB(PersonCore, P_Tbl);
	void * ExtraPtr;
	PPObjLocation LocObj;
	PPObjRegister RegObj;
};
//
// Утилитные функции, проверяющие правильность кодов ОКПО, ИНН, корр счета банка и расчетного банковского счета.
//
int CheckBnkAcc(const char * pCode, const char * pBic);
int CheckCorrAcc(const char * pCode, const char * pBic);
//
// @ModuleDecl(AsyncCashiersIterator)
//
struct AsyncCashierInfo {
	PPID  TabNum;
	char  Name[48];
	char  Password[24];
	char  Rights[32];
	int   IsWorked;
};

class AsyncCashiersIterator {
public:
	AsyncCashiersIterator();
	~AsyncCashiersIterator();
	int    Init(PPID cashNodeID);
	int    Next(AsyncCashierInfo *);
protected:
	PPObjPerson PsnObj;
	PPID   TabNumRegID;
	uint   ProsessUnworkedPos;
	PPIDArray Iterated;
	PPIDArray Unworked;
	LDATETIME Since;
	BExtQuery * P_IterQuery;
};
//
// @ModuleDecl(PPObjStaffList)
// @todo Реализовать синхронизацию объекта между разделами
//
struct PPStaffEntry {
	PPStaffEntry()
	{
		THISZERO();
	}
	long   Tag;            // Const=PPOBJ_STAFFLIST
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символьный код //
	uint8  Reserve[44];
	int16  VacancyCount;   // Общее количество ставок
	int16  VacancyBusy;    // Занятое количество вакансий
	long   FixedStaff;     // Зарезервированный ИД должности (PPFIXSTF_XXX)
	long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
	long   Rank;
	long   Flags;
	PPID   OrgID;          // ->Person.ID
	PPID   DivisionID;     // ->Location.ID
};

class PPStaffPacket  {
public:
	PPStaffPacket();
	void   Init();
	PPStaffPacket & FASTCALL operator = (const PPStaffPacket &);

	PPStaffEntry Rec;
	StaffAmtList Amounts;
};

class PPPsnPostPacket {
public:
	PPPsnPostPacket();
	void   Init();
	PPPsnPostPacket & FASTCALL operator = (const PPPsnPostPacket &);

	PersonPostTbl::Rec Rec;
	StaffAmtList Amounts;
};

class PersonPostArray : public TSVector <PersonPostTbl::Rec> {
public:
	PersonPostArray();
	void   Sort();
	uint   GetBusyCount() const;
};

class PPObjStaffList : public PPObjReference {
public:
	static int SetupPostCombo(TDialog *, uint ctl, PPID id, uint /*olwFlags*/, PPID orgID, PPID divID, PPID staffID);
	//
	// Специфические флаги доступа (в дополнение к общим PPR_XXX)
	//
	enum {
		rtReadAmounts = 0x0100, // Просмотр сумм штатной должности либо назначения //
		rtModAmounts  = 0x0200  // Изменение сумм штатной должности либо назначения //
	};
	struct Filt {
		PPID   OrgID;
		PPID   DivID;
	};
	explicit PPObjStaffList(void * extraPtr = 0);
	~PPObjStaffList();
	int    GetPacket(PPID, PPStaffPacket *);
	int    PutPacket(PPID *, PPStaffPacket *, int use_ta);
	int    SerializePacket(int dir, PPStaffPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Проверяет и, если необходимо, восстанавливает запись должности staffID.
	// Returns:
	//   1 - запись нормальная //
	//   2 - в записи была ошибка - восстановлена
	//   0 - error проверки либо восстановления //
	//
	int    Recover(PPID staffID, int use_ta);
	int    SearchPost(PPID postID, PersonPostTbl::Rec *);
	int    GetPostPacket(PPID postID, PPPsnPostPacket * pPack);
	int    PutPostPacket(PPID * pPostID, PPPsnPostPacket * pPack, int use_ta);
	int    MakeCodeString(const PersonPostTbl::Rec * pRec, SString & rBuf);
	int    CreateFixedStaff(PPID *, PPID orgID, PPID divID, PPID fixID, int use_ta);
	int    GetFixedStaffList(PPID orgID, PPID fixID, PPIDArray * pList);
	int    GetFixedPostOnDate(PPID orgID, PPID fixID, LDATE dt, PersonPostTbl::Rec * pRec);
	int    GetFixedPostList(PPID orgID, PPID fixID, PersonPostArray * pList);
	int    AssignPersonToStaff(PPID personID, PPID staffID, LDATE dt, int useTa);
	//
	// Descr: Отзывает персоналию personID с должности staffID. Отзыв осуществляется //
	//   путем установки признака "Закрыт" и даты закрытия (dt) в записи должностного назначения //
	// Returns:
	//   >0 - персоналия успешно отозвана с должности
	//   <0 - персоналия не была назначена на долность staffID (нет открытого назначения)
	//   0  - ошибка
	//
	int    RevokePersonPost(PPID personID, PPID staffID, LDATE dt, int use_ta);
	//
	// Descr: Отзывает персоналию personID со всех должностей организации orgID.
	//   Отзыв осуществляется установкой признака "Закрыт" и даты закрытия (dt) в записях
	//   найденных должностных назначений персоналии personID в организации orgID.
	// Returns:
	//   >0 - персоналия имела по крайней мере одно назначение в организации, которое (которые)
	//     было закрыто этой функцией.
	//   <0 - персоналия не имела ни одного назначения в организации orgID.
	//   0  - ошибка
	//
	int    RevokeAllPersonPosts(PPID personID, PPID orgID, LDATE dt, int use_ta);
	//
	// Descr: Ищет назначение персоналии personID на должность staffID. Если closed == 0,
	//   то ищет действующее назначение (PersonPost::Closed == 0), в противном случае, если
	//   closed < 0, то ищет последнее закрытое назначение personID на staffID. Если closed > 0,
	//   то ищет закрытое назначение personID на staffID у которого значение Closed точно равно closed.
	// Returns:
	//   >0 - требуемое назначение найдено
	//   <0 - требуемое назначение не найдено
	//   0  - ошибка
	//
	int    GetPersonPost(int closed, PPID staffID, PPID personID, PersonPostTbl::Rec * pRec);
	//
	// Descr: Извлекает список штатных должностей в соответствии с фильтром rFilt.
	//   Список функцией не очищается: те элементы, которые там были остаются не тронутыми.
	//   Должности добавляются в список методом addUnique.
	//   Если параметр pNameList не нулевой, то в него заносится список всех найденных
	//   должностей с соответствующими наименованиями.
	// Returns:
	//   >0 - найдена по меньшей мере одна должность.
	//   <0 - не нейдено ни одной должности, соответствующей фильтру rFilt
	//   0  - ошибка
	//
	int    GetList(const Filt & rFilt, PPIDArray * pList, StrAssocArray * pNameList);
	//
	// Descr: Возвращает список назначений на должность staffID.
	//   Список заносится в массив pList. Функция проверяет размер элемента переданного
	//   массива на равенство записи PersonPostTbl::Rec.
	//   В список заносятся все назначения независимо от того, являются они открытыми или закрытыми.
	//   Список функцией не очищается: те элементы, которые там были остаются не тронутыми.
	// Returns:
	//   >0 - существует по крайней мере одно назначение на должность staffID
	//   <0 - не существует ни одного назначения на должность staffID
	//   0  - ошибка
	//
	int    GetPostList(PPID staffID, PersonPostArray * pList);
	int    GetPostByPersonList(PPID personID, PPID employerID, int openedOnly, PersonPostArray * pList);
	//
	// Descr: Формирует список наименований штатных назначений в соответствии с условием
	//   удовлетворения ограничениям {orgID, divID} или {staffID} (если задан staffID, то
	//   orgID и divID игнорируются.
	// ARG(orgID   IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатным должностям, привязанным к работодателю (PPObjPerson) orgID.
	// ARG(divID   IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатным должностям, привязанным к подразделению (PPObjLocation) divID.
	// ARG(staffID IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатной должности (PPObjStaffList) staffID (orgID и divID в этом случае игнорируются).
	// ARG(pList  OUT): @#{vptr}
	// Returns:
	//   !0 - список (возможно пустой) сформирован
	//   0  - ошибка
	//
	int    MakePostStrAssocList(PPID orgID, PPID divID, PPID staffID, StrAssocArray * pList);
	virtual int  Browse(void * extraPtr /* (PPObjStaffList::Filt *) */);
	//
	// Descr: Редактирование объекта по идентификатору *pID.
	//   Если *pID != 0, то извлекает пакет элемента штатного расписания из базы данных
	//   и вызывает диалог редактирования для него.
	//   Если *pID == 0, то инициализирует новый пакет и вызывает диалог редактирования.
	//   При этом параметр extraParam интерпретируется как указатель на структуру PPObjStaffList::Filt.
	// ARG(pID    IN/OUT): Указатель на идентификатор элемента штатного расписания. Если *pID == 0
	//   и пользователь создал новый элемент, то по этому указателю присваивается идентификатор нового
	//   элемента.
	// ARG(extraParam IN): Используется только при *pID == 0. В этом случае значение параметра
	//   интерпретируется как указатель на структуру PPObjStaffList::Filt для инициализации нового
	//   пакета элемента штатного расписания.
	//
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {ID, OrgID, DivisionID, Flags, Rank, FixedStaff, ChargeGrpID, Name}
	//
	int    FASTCALL Fetch(PPID id, PPStaffEntry * pRec);
	//
	// Descr: осуществляет кэшированное извлечение записи штатного назначения по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {ID, StaffID, PersonID, ChargeGrpID, Flags, Closed}
	//
	int    FetchPost(PPID id, PersonPostTbl::Rec * pRec);
	int    EditDialog(PPStaffPacket *);

	enum {
		epdfFixedPost = 0x0001,
		epdfRecover   = 0x0002
	};
	int    EditPostDialog(PPPsnPostPacket * pPack, long flags);
	int    EditFixedStaffPost(PPID orgID);
	int    EditAmounts(PPID staffID);
	int    EditPostAmounts(PPID postID);
private:
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint bufSize, ObjRights * rt, EmbedDialog * pDlg);
	virtual int  Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	//
	// Descr: Извлекает список назначений персоналии personID на должность staffID.
	//   Все найденные назначения заносятся в массив pList. Массив предварительно очищается.
	//   Функция проверяет, чтобы размер записи pList был равен sizeof(PersonPostTbl::Rec).
	// Returns:
	//   >0 - найдена по крайней мере одна запись назначения personPost на staffID
	//   <0 - не найдено ни одной записи
	//   0  - ошибка.
	//
	int    GetPersonPostList(PPID staffID, PPID personID, SArray * pList);
	void   FASTCALL Dirty(PPID id);
	void   DirtyPost(PPID id);
	int    ReplyPersonReplace(PPID dest, PPID src);
	int    IncrementStaffVacancy(PPID staffID, int decr, int use_ta);
public:
	TLP_MEMB(PersonPostTbl, P_PostTbl);
	PPObjPerson PsnObj;
};
//
// @ModuleDecl(PPViewStaffList)
//
class StaffListFilt : public PPBaseFilt {
public:
	StaffListFilt();
	//
	// Descr: Если extraData != 0, то функция считает, что OrgID = GetMainEmployerID
	//   если extraData > 0, то DivID = extraData.
	//   Чтобы OrgID был равен GetMainEmployerID, а DivID == 0, необходимо установить extraData = -1
	//
	virtual int Init(int fullyDestroy, long extraData);

	char   ReserveStart[32]; // @anchor
	PPID   OrgID;            // ->Person.ID
	PPID   DivID;            // ->Location.ID
	long   Flags;            // @flags
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct StaffListViewItem : public PPStaffEntry {
	double Salary;
	double RiseInWages1;
	double RiseInWages2;
	double RiseInWages3;
};

class PPViewStaffList : public PPView {
public:
	struct BrwEntry {
        PPID   ID;
		int16  VacancyCount;   // Общее количество ставок
		int16  VacancyBusy;    // Занятое количество вакансий
		long   FixedStaff;     // Зарезервированный ИД должности (PPFIXSTF_XXX)
		long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
		long   Rank;
		long   Flags;
		PPID   OrgID;
		PPID   DivisionID;
	};
	PPViewStaffList();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(StaffListViewItem *);
	int    FASTCALL CheckForFilt(const PPStaffEntry & rItem) const;
	PPID   GetSalaryAmountType(int typeNo);
private:
	static void FASTCALL MakeListEntry(const PPStaffEntry & rSrc, PPViewStaffList::BrwEntry & rEntry);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * GetEditExtraParam();
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    FetchData(PPID id);

	TSArray <BrwEntry> Data;
	StaffListFilt Filt;
	PPObjStaffList::Filt TempExtra;
	PPObjStaffList SlObj;
	PPID   SalaryAmountTypes[4];
};
//
// @ModuleDecl(PPViewPersonPost)
//
class StaffPostFilt : public PPBaseFilt {
public:
	StaffPostFilt();
	enum {
		fOpenedOnly = 0x0001, // Только "открытые" назначения //
		fClosedOnly = 0x0002  // Только "закрытые" назначения //
			// Если (Flags & fOpenedOnly) && (Flags & fClosedOnly), то - все
	};
	char   ReserveStart[32];
	PPID   OrgID;     // @anchor ->Person.ID Организация-работодатель
	PPID   DivID;     // ->Location.ID  Подразделение
	DateRange Period; // Период назначения на должность
	DateRange FnPeriod; // Период снятия с должности
	PPID   StaffID;   // ->StaffList.ID Штатная должность
	PPID   PersonID;  // ->Person.ID    Сотрудник
	long   Flags;     //
	int    InitOrder; // PPViewStaffPost::ordByXXX Порядок сортировки
	long   Reserve;   // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef PersonPostTbl::Rec StaffPostViewItem;

class PPViewStaffPost : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByPerson,
		ordByDate,
		ordByStaffPerson,
		ordByStaffDate
	};
	PPViewStaffPost();
	~PPViewStaffPost();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(StaffPostViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * GetEditExtraParam();
	int    CreateTempTable(int order);

	StaffPostFilt Filt;
	ObjIdListFilt StaffList; // Список должностей, соответствующий элементам фильтра Filt.OrgID, Filt.DivID
	PPObjStaffList SlObj;
	TempOrderTbl * P_TempTbl;
};
//
// @ModuleDecl(PPObjSalCharge)
// Начисления зарплаты
//
struct PPSalCharge2 {      // @persistent @store(Reference2Tbl+)
	enum {
		fGroup       = 0x0001, // Группа начислений (объединяет произвольный упорядоченный набор обыкновенных начислений)
		fWrOffSingle = 0x0002  // Начисления по всем контрагентам за один период списывать одним документом (суммы складываются)
	};
	PPID   Tag;            // Const=PPOBJ_SALCHARGE
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ
	char   Reserve[48];    // @reserve
	PPID   EnumObjType;    // @#{0||PPOBJ_PERSONEVENT} Тип объекта для перечисления //
	PPID   EnumExtVal;     // Дополнительный параметр для перечисления по объектам EnumObjType
	PPID   AmtID;          // ->Ref(PPOBJ_AMOUNTTYPE) Тип учетной суммы для этого начисления //
	long   Flags;          //
	PPID   CalID;          // ->Ref(PPOBJ_STAFFCAL)   Календарь, используемый для этого начисления //
	PPID   WrOffOpID;      // ->Ref(PPOBJ_OPRKIND)    Вид операции списания //
};

struct PPSalChargePacket {
	DECL_INVARIANT_C(); // @unimplemented
	PPSalChargePacket();
	void   Init();
	PPSalCharge Rec;
	SString   Formula; // Формула расчета
	PPIDArray GrpList; // Список элементов группы
};

class PPObjSalCharge : public PPObjReference {
public:
	explicit PPObjSalCharge(void * extraPtr = 0);
	//
	// Descr: Редактирует существующую либо новую запись.
	//   Если *pID == 0, то extraParam == -1000 означает, что необходимо
	//   создать и редактировать запись группы начислений, в противном случае - запись начисления.
	//
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPSalChargePacket *, int use_ta);
	int    GetPacket(PPID id, PPSalChargePacket *);
	int    SerializePacket(int dir, PPSalChargePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: осуществляет кэшированное извлечение пакета по идентификатору ID.
	//   В пакете инициализируются следующие поля: Rec {ID, Name, Symb, AmtID, CalID, Flags}, Formula
	//   !Список членов группы НЕ ИНИЦИАЛИЗИРУЕТСЯ //
	//
	int    Fetch(PPID id, PPSalChargePacket *);
private:
	virtual int Browse(void * extraPtr);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjDateTimeRep)
//
struct PPDateTimeRep2 {    // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_DATETIMEREP
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	DateTimeRepeating Dtr; //
	long   Duration;       // Продолжительность (sec)
	long   Reserve2[2];    //
};

class PPObjDateTimeRep : public PPObjReference {
public:
	PPObjDateTimeRep(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
};
//
// @ModuleDecl(PPObjDutySched)
//
struct PPDutyCountPoint { // @flat
	PPID   ObjID;
	LDATETIME Dtm;
};

struct PPDutySchedEntry { // @flat
	PPID   ObjID;
	PPID   DtrID; // Ид повторения. Если DtrID == 0, то используется непосредсредственное значение Dtr.
	DateTimeRepeating Dtr;
	long   Duration; // Продолжительность (sec)
};

struct PPDutySched2 {      // @persistent @store(Reference2Tbl+)
	PPDutySched2()
	{
		THISZERO();
	}
	PPID   Tag;            // Const=PPOBJ_DUTYSHED
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[60];   // @reserve
	long   Flags;          //
	PPID   ObjType;        //
	long   ObjGroup;       //
};

class PPDutySchedPacket {
public:
	struct EnumParam {
		uint   QueuePos; // @internal
		int    IsFirst;  // @internal Первая итерация //
		PPID   ObjID;
		LDATETIME Dtm;
		long   Duration;
		STimeChunk Bounds; // Границы итераций.
	};
	PPDutySchedPacket();
	//
	// Descr: Сортирует список CpList, инициализирует CpFirst и CpLast.
	//   Функции InitIteration и NextIteration полагаются на то, что
	//   предварительно Normalyze была вызвана.
	//
	int    Normalyze();
	int    IsCountPoint(LDATETIME dtm) const;
	int    AddCountPointDate(LDATE, uint * pPos);
	int    RemoveCountPoint(uint pos);
	int    WhoIsDuty(LDATETIME & rDtm, PPID * pObjID) const;
	//
	// @sample
	//   PPDutySchedPacket::EnumParam ep;
	//   for(ep.Init(); Enum(&ep) > 0; ep.Advance()) {
	//      // ep содержит информацию о текущей очереди
	//   }
	//
	int    InitIteration(EnumParam * pEnum, const STimeChunk & rTmChunk) const;
	int    FASTCALL NextIteration(EnumParam * pEnum) const;
	int    Test(const char * pOutFile) const;

	PPDutySched2 Rec;
	TSVector <PPDutySchedEntry> List;
	TSVector <PPDutyCountPoint> CpList;
private:
	int    IsCountPoint(LDATETIME * pDtm) const;

	STimeChunk Cp;
};

class PPObjDutySched : public PPObjReference {
public:
	PPObjDutySched(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    SearchByObjType(PPID objType, long objGroup, PPID * pID);
	int    PutPacket(PPID * pID, PPDutySchedPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPDutySchedPacket * pPack);
};
//
// @ModuleDecl(PPObjStaffCal)
//
// Штатные календари могут быть связанными с каким-либо объектом данных либо не связанными.
// Связанные календари обязательно имеют родительский календарь (который, в свою очередь,
// не может быть связанным).
// Запись связанного календаря имеет пустые значения Name и Symb (они наследуют их от своего родителя).
//
// Принадлежность даты календарю какого-либо объекта определяется по следующей иерархии объектов:
// Персоналия (PPOBJ_PERSON) -
//    Штатное назначение (PPOBJ_PERSONPOST) -
//       Штатное расписание (PPOBJ_STAFFLIST) -
//          Главная организация (PPOBJ_PERSON) -
//             Заголовочные календари (0)
//
// Флаги записей штатных календарей (StaffCalendarTbl::Rec::Flags)
//
#define STCALEF_BYPEVENT    0x0001 // Запись сформирована персональной операцией
#define STCALEF_SKIP        0x0002 // Пропуск (выходной день).
#define STCALEF_BYDUTYSCHED 0x0004 // Запись сформирована графиком дежурств
#define STCALEF_CONTINUOUS  0x0008 // Начиная с этой записи календарь находится в состоянии "бесконечности".
	// То есть, все дни, следующие за датой этой записи включены в календарь.
	// Если установлен флаг STCALEF_SKIP, то и все дни, вслед за этой записью считаются пропущенными.
#define STCALEF_ALLFALGS    (STCALEF_BYPEVENT|STCALEF_SKIP|STCALEF_BYDUTYSCHED|STCALEF_CONTINUOUS)

struct PPStaffCal2 {       // @persistent @store(Reference2Tbl+)
	enum {
		fInherited        = 0x0001, // Календарь наследует элементы от родителя. То есть, такой календарь не может содержать собственных элементов.
		fUseNominalPeriod = 0x0002, // При начислении зарплаты к календарю по умолчанию применяется актуальный период начисления (не номинальный)
		fDayGap   = 0x0004  // Календарь допускает разрывы в течении дня (в один день может быть несколько записей) //
	};
	DECL_INVARIANT_C();

	PPID   Tag;            // Const=PPOBJ_STAFFCAL
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname Для порожденных календарей (LinkCalID != 0) - пусто
	char   Symb[20];       // Символ. Для порожденных календарей (LinkCalID != 0) - пусто
	long   Color;          // Цвет календаря (отображается в анализе штатных календарей)
	char   Reserve[44];    // @reserve
	PPID   PersonKind;     // Вид персоналий, с которыми связываются (устанавливается в родительском календаре)
	PPID   SubstCalID;     // Календарь, замещающий родительский. Используется в том случае,
		// если родительский календарь является смысловым, а StubCalID - фактическим.
		// Пример: регулярный календарь (смысловой) замещается графиком для женщин (фактический)
	PPID   LinkObjType;    // Тип связанного объекта
	long   Flags;          //
	PPID   LinkCalID;      // ИД родительского календаря //
	PPID   LinkObjID;      // ИД связанного объекта
};
//
// Descr: Структура фильтра штатных календарей.
//
class StaffCalFilt : public PPBaseFilt {
public:
	enum {
		fInverseProj = 0x0001 // Если ProjCalID != 0, то приметь инверсивную проекцию
	};
	StaffCalFilt();

	char   ReserveStart[20];   // @anchor
	PPID   ProjCalID;          // Календарь, на который следует проецировать записи анализируемых календарей
	SubstGrpDate  Sgd;         // Подстановка даты
	PPID   LinkPersonKind;     // Вид связанной персоналии (по умолчанию - PPPRK_EMPL)
	DateRange Period;          // Период, за который показывать календари
	long   Flags;              // Флаги
	PPID   LinkObjType;        // Тип связанных объектов
	long   Order;              // Порядок сортировки
	ObjIdListFilt LinkObjList; // @anchor Список объектов, для которых показывать календари
	ObjIdListFilt CalList;     // Список календарей
};

typedef TSVector <StaffCalendarTbl::Rec> PPStaffCalendarArray;

class PPStaffCalPacket {
public:
	friend class PPObjStaffCal;
	//
	// Descr: Проверяет, и если требуется, исправляет некоторые поля элемента календаря pEntry.
	//   В основном эти проверки касаются полей TmVal, TmStart, TmEnd.
	// Returns:
	//   >0 - если функция изменила какие-либо параметры
	//   <0 - если функция не обнаружила каких-либо несоответствий, которые следует исправлять.
	//
	static int SetupEntry(StaffCalendarTbl::Rec * pEntry);
	static int InvariantEntry(const StaffCalendarTbl::Rec * pRec);
	PPStaffCalPacket();
	void   Init(const StaffCalFilt *);
	PPStaffCalPacket & FASTCALL operator = (const PPStaffCalPacket &);
	int    Get(LDATE dt, double * pHours, uint * pPos = 0) const;
	int    GetTimeChunkList(const DateRange & rPeriod, STimeChunkArray * pList) const;
	const  PPStaffCalendarArray & GetList() const { return Items; }
	int    AddItem(StaffCalendarTbl::Rec * pItem, uint * pPos);
	int    RemoveItem(uint pos);

	PPStaffCal Rec;
	PPStaffCalendarArray Items;
private:
	int    Helper_Get(LDATE dt, CALDATE * pCdt, uint * pPos) const;
	int    SearchContinuousEntry(long dtVal, StaffCalendarTbl::Rec * pRec) const;
	int    FASTCALL CheckContinuousEntry(const StaffCalendarTbl::Rec * pRec) const;
};
//
// Descr: Иерархия выборки календаря по штатному назначению.
//
struct ScObjAssoc {
	enum {
		scPerson = 0,
		scPost,
		scStaffList,
		scMainOrg,
		scHeader,
		scCount // Общее количество элементов
	};
	struct H {
		PPObjID Oi;
		PPID   CalID;
		PPID   ProjCalID;
	};
	H      List[scCount];
};
//
// Descr: Класс, управляющий штатными календарями.
//   В качестве дополнительного значения функциям этого класса может быть
//   передан указатель на StaffCalFilt. Функции копируют данные по этому указателю,
//   по этому, вызывающая функция может разрушать переданный указатель.
//
class PPObjStaffCal : public PPObjReference {
public:
	static int FASTCALL HasValidTimeRange(const StaffCalendarTbl::Rec & rRec);
	explicit PPObjStaffCal(void * extraPtr = 0);
	~PPObjStaffCal();
	int    CheckForFilt(const StaffCalFilt * pFilt, const PPStaffCal * pRec) const;
	int    FASTCALL Fetch(PPID id, PPStaffCal *); // @macrow
	//
	// Descr: Ищет дочерний по отношению к parentID календарь, принадлежащий объекту {linkObjType, linkObjID}.
	// ARG(parentID    IN): родительский календарь
	// ARG(linkObjType IN): связанный объект
	// ARG(pRec       OUT): @#{vptr0} указатель, по которому возвращается найденная запись.
	// Returns:
	//   >0 - календарь по заданным условиям найден
	//   <0 - календарь по заданным условиям не найден
	//    0 - error
	//
	int    SearchByObj(PPID parentID, PPObjID linkObj, PPStaffCal * pRec);
	//
	// Descr: Извлекает список календарей дочерних по отношению к calID.
	//   Идентификаторы найденных календарей заносятся в массив pList без дублирования.
	//   pList функцией не очищается.
	// Returns:
	//   >0 - найден по карйней мере один дочерний календарь
	//   <0 - не найдено ни одного дочернего календаря //
	//    0 - error
	//
	int    GetChildList(PPID calID, PPIDArray * pList);
	int    SearchEntry(PPID calID, long dtVal, LTIME tmStart, StaffCalendarTbl::Rec * pRec);
	//
	// Descr: Ищет все записи календаря calID, соответствующие dtVal.
	// ARG(calID IN): Идент календаря //
	// ARG(dtVal IN): Значение даты (календарного дня) для которой ищутся записи
	// ARG(pList OUT): #{vptr0} Массив, в который заносятся найденные записи. Функция предварительно
	//   очищает содержимое списка pList.
	//   Если pList == 0, то функция все равно переберет все записи по критерию {calID, dtVal}, но, очевидно,
	//   не будет заносить их в список. Возвращаемое значение функции будет таким же, как если бы pList != 0.
	// Returns:
	//   >0 - найдена по крайней мере одна запись
	//   <0 - не найдено ни одной записи, соответствующей критерию
	//   0  - ошибка
	//
	int    SearchEntriesByDtVal(PPID calID, long dtVal, TSVector <StaffCalendarTbl::Rec> & rList);
	int    SearchContinuousEntry(PPID calID, long dtVal, StaffCalendarTbl::Rec * pRec);
	int    FASTCALL CheckContinuousEntry(const StaffCalendarTbl::Rec * pRec);
	int    SearchDate(PPID calID, LDATE dt, TSVector <StaffCalendarTbl::Rec> & rList);
	int    SetEntry(const StaffCalendarTbl::Rec & rEntry, int use_ta);
	//
	// Descr: Удаляет запись в календаре, по критериям {pEntry->CalID, pEntry->DtVal, pEntry->TmStart}
	//
	int    RemoveEntry(const StaffCalendarTbl::Rec & rEntry, int use_ta);
	//
	// Descr: Удаляет все элементы всех календарей, связанные с персональной операцией psnEvID.
	//
	int    RemoveEntriesByPsnEvent(PPID psnEvID, int use_ta);
	int    SetEntriesByDutySched(PPID baseCalID, PPDutySchedPacket * pDsPack, const DateRange & rPeriod, int use_ta);
	//
	// Descr: Удаляет элементы календаря calID, сформированные по графику дежурств dutySchedID
	//   за период rPeriod.
	//
	int    RemoveEntriesByDutySched(PPID calID, PPID dutySchedID, const DateRange & rPeriod, int use_ta);
	//
	// Descr: Вызывает диалог просмотра списка календарей.
	// ARG(extra IN): указатель на структуру StaffCalFilt или 0.
	//
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    EditEntry(const PPStaffCalPacket * pPack, StaffCalendarTbl::Rec * pRec);
	int    PutPacket(PPID * pID, PPStaffCalPacket * pPack, int useTa);
	int    GetPacket(PPID id, PPStaffCalPacket * pPack);
	int    SerializePacket(int dir, PPStaffCalPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    CreateChild(PPID * pID, PPID parentID, PPObjID linkObj, int use_ta);
	//
	// Descr: Инициализирует структуру иерархии поиска календаря по записи штатного назначения.
	//
	int    InitScObjAssoc(PPID calID, PPID prjCalID, const PersonPostTbl::Rec * pPostRec, ScObjAssoc * pAssc);
	//
	// Descr: Инициализирует структуру иерархии поиска календаря по идентификатору персоналии
	//
	int    InitScObjAssoc(PPID calID, PPID prjCalID, PPID personID, ScObjAssoc * pAssc);
	//
	// Descr: Рассчитывает количество дней и часов по календарю и проекции, заданным в rAssc за
	//   период rPeriod.
	//   Если параметр inverse != 0 и в rAssc задан проекционный календарь, то
	//   вычисляется количество дней и часов, не попадающих в проекционный календарь.
	//
	int    CalcPeriod(const ScObjAssoc & rAssc, const DateRange & rPeriod, int inverse,
		long * pDays, double * pHours, STimeChunkArray * = 0);
	int    CalcPeriodByPersonEvent(const ScObjAssoc & rAssc, const PPIDArray & rEvList, int inverse,
		long * pDays, double * pHours, STimeChunkArray * pList = 0);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    PutItems(PPID id, PPStaffCalPacket * pPack, int logAction);
	int    Helper_CheckInEntry(LDATE dt, int proj_r, int inverse,
		const TSVector <StaffCalendarTbl::Rec> & rCalList, const TSVector <StaffCalendarTbl::Rec> & rProjCalList,
		STimeChunkArray * pList, long & rDays, double & rHour);

	StaffCalFilt CurrFilt;
public:
	TLP_MEMB(StaffCalendarTbl, P_ScT);
};
//
// @ModuleDecl(PPViewStaffCal)
//
struct StaffCalViewItem {
	PPID   CalID;
	LDATE  Dt;
	LTIME  TmStart;
	LTIME  TmEnd;
	long   Duration;
	long   Flags;
	PPObjID LinkObj;
	char   LinkObjName[64];
	char   DtText[32];
	long   Count;
};

class PPViewStaffCal : public PPView {
public:
	struct BrwHdr {
		PPID   ID__;
		PPID   CalID;
		PPID   ObjID;
		LDATETIME StartDtm;
		LTIME  TmEnd;
	};
	enum IterOrder {
		ordByDefault = 0,
		ordByDate,
		ordByObject
	};
	PPViewStaffCal();
	~PPViewStaffCal();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(StaffCalViewItem *);
	int    GetTimeGridItemText(PPID taskID, SString & rBuf);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   Detail(const void *, PPViewBrowser * pBrw);
	virtual int   Print(const void *);
	int    CreateEntryByObj(PPID objType, PPID objID, StrAssocArray * pNameList, int refresh = 0);
	int    AddItemToTimeGrid(const TempStaffCalTbl::Rec *, int rmv);
	int    TimeChunkBrowser();
	int    UpdateTimeBrowser(int destroy);
	int    EditEntry(PPID calID, PPID objID, LDATETIME dtm, LTIME tmFinish);

	class StaffCalTimeChunkGrid : public STimeChunkGrid {
	public:
		StaffCalTimeChunkGrid(PPViewStaffCal * pV);
		~StaffCalTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
		virtual int GetColor(long id, STimeChunkGrid::Color * pClr);
	private:
		PPViewStaffCal * P_View; // @notowned
	};

	StaffCalTimeChunkGrid Grid;
	StaffCalFilt Filt;
	PPIDArray CalList;
	StrAssocArray ObjNameList;
	PPObjStaffCal Obj;
	PPObjStaffList SlObj;
	TempStaffCalTbl * P_TempTbl;
};
//
// @ModuleDecl(SalaryCore)
//
class SalaryCore : public SalaryTbl {
public:
	SalaryCore();
	bool   Validate(const SalaryTbl::Rec * pRec);
	int    Search(PPID id, SalaryTbl::Rec * pRec);
	int    Put(PPID * pID, SalaryTbl::Rec * pRec, int use_ta);
	//
	// Descr: Рассчитывает сумму начисления вида salChargeID по назначению postID за период rPeriod.
	//   Если параметр avg != 0, то рассчитывает среднее начисление за этот период (простое среднее по
	//   количеству начислений).
	//
	int    Calc(PPID postID, PPID salChargeID, int avg, const DateRange & rPeriod, double * pAmount);
	int    GetIntersection(PPID postID, PPID salChargeID, const DateRange & rPeriod, SalaryTbl::Rec * pRec);
	int    GetObjectList(PPID objType, const DateRange & rPeriod, const UintHashTable * pIdList, PPIDArray * pList);
	int    GetListByObject(PPID objType, PPID objID, const DateRange & rPeriod, const UintHashTable * pIdList, PPIDArray * pList, double * pAmount);
};
//
// @ModuleDecl(PPViewSalary)
//
class SalaryFilt : public PPBaseFilt {
public:
	enum {
		fCrosstab = 0x00000001
	};

	SalaryFilt();
	char   ReserveStart[32]; // @anchor
	DateRange Period;        // Период начисления //
	PPID   PostID;           // ->PersonPost.ID        Штатное назначение (может конфликтовать с PersonID)
	PPID   SalChargeID;      // ->Ref(PPOBJ_SALCHARGE) Вид штатного начисления //
	PPID   OrgID;            // ->Person.ID            Предприятие
	PPID   DivID;            // ->Location.ID
	PPID   StaffID;          // ->Ref(PPOBJ_STAFFLIST) Штатная должность
	PPID   PersonID;         // ->Person.ID            Персоналия (может конфликтовать с PostID)
	long   Flags;            // Флаги
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct SalaryViewItem : public SalaryTbl::Rec {
	PPID   StaffID;
	PPID   PersonID;
	PPID   OrgID;
	PPID   DivID;
};

class PPViewSalary : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByPostID  = 1
	};
	PPViewSalary();
	virtual ~PPViewSalary();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(SalaryViewItem *);
	void   GetTabTitle(long tabID, SString & rBuf) const;
	int    GetSalChargeName(PPID salChargeID, SString & rName);
	int    Calc(PPID postID, PPID salChargeID, int avg, const DateRange & rPeriod, double * pAmount) {return Tbl.Calc(postID, salChargeID, avg, rPeriod, pAmount);}
	//
	// Descr: Пара функций, используемых для печати по структуре DL600 SalaryByPost
	//
	int    InitPostDateList();
	int    SetPostDateListItem(PPID postID, LDATE dt);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   Print(const void *);
	bool   IsTempTblNeeded() const;
	void   MakeTempRec(int order, const SalaryTbl::Rec * pRec, TempSalaryTbl::Rec * pTempRec);
	int    UpdateTempRec(PPID id);
	int    TempRecToViewItem(const TempSalaryTbl::Rec * pTempRec, SalaryViewItem * pItem);
	int    EditItemDialog(SalaryTbl::Rec * pRec);
	int    GetSalChargeGroupItems(PPID salChargeGrpID, PPIDArray * pItems) const;
	PPID   GetEditId(PPID id, const PPViewBrowser * pBrw);

	PPIDArray  SalChargeList;
	LAssocArray Post_Date_List;
	SalaryFilt Filt;
	SalaryCore Tbl;
	PPObjStaffList SlObj;
	TempSalaryTbl * P_TempTbl;
};
//
// @ModuleDecl(PPObjPersonEvent)
//
//
// Флаги дополнительных прав доступа персональных событий
//
#define PSNEVRT_SETFORCEPAIR   0x0100L // Право на изменение флага PSNEVF_FORCEPAIR
//
// Флаги персональных событий
//
#define PSNEVF_NOVERBS         0x0001L // Не проводить действия по событию
#define PSNEVF_HASIMAGES       0x0002L // Прикреплено изображение
#define PSNEVF_CLOSE           0x0004L // Признак закрывающего события. Устанавливается автоматически и необходим для внутренних целей (правильная синхронизация).
#define PSNEVF_FORCEPAIR       0x0008L // Аварийный флаг, помечающий событие, фактически не имеющее пары, как имеющее таковую.

struct PPPsnEventPacket {
	PPPsnEventPacket();
	void   FASTCALL Init(PPID op);
	void   Destroy();
	int    FASTCALL Copy(const PPPsnEventPacket &);
	PPPsnEventPacket & FASTCALL operator = (const PPPsnEventPacket &);

	PersonEventTbl::Rec Rec;
	RegisterTbl::Rec Reg;
	SString SMemo; // @v11.1.12
	ObjTagList   TagL;
	ObjLinkFiles LinkFiles; // Связанные файлы
	//
	// Descr: Структура данных, формируемых во время проведения операции.
	//
	struct OnTurnBlock {
		OnTurnBlock();
		~OnTurnBlock();
		OnTurnBlock & Z();

		PPID   SCardID;
		double SCardWrOffAmount;
		double SCardRest;
		PalmDisplayBlock * P_Pdb;
	};
	OnTurnBlock Otb; // @transient
};

class PersonEventCore : public PersonEventTbl {
public:
	friend class PPTblEnum <PersonEventCore>;

	PersonEventCore();
	int    Search(PPID id, PersonEventTbl::Rec * pRec = 0);
	SString & GetItemMemo(PPID id, SString & rBuf); // @v11.1.12
	//
	// Descr: Блок, управляющий поиском парной или аналогичной операции PersonEventCore::SearchPair()
	//
	struct PairIdent {
		PairIdent();
		enum {
			fSignalNpError = 0x0001, // Сигнализировать о нарушении парности операции
				// Если ThisOpID встретилась раньше, чем PairOpID
			fSignalAnalog  = 0x0002, // Сигнализировать о том, что встречена аналогичная операция (возврат 2)
			fUseSCard      = 0x0004  // Ищет операцию в которой совпадает и PersonID и SCardID (даже нулевой)
		};
		PPID   PersonID;
		PPID   SCardID; //
		LDATE  Dt;
		long   OprNo;
		PPID   ThisOpID;
		PPID   PairOpID;
		long   Flags;
	};
	int    SearchPair(const PairIdent *, int forward, PersonEventTbl::Rec * pRec);
	int    Add(PPID * pID, PersonEventTbl::Rec *, int use_ta);
	int    Update(PPID id, PersonEventTbl::Rec *, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    CalcCountForPeriod(PPID opID, PPID personID, const STimeChunk & rTc, uint * pCount);
	SEnum::Imp * EnumByPerson(PPID prmrPesonID, const DateRange * pPeriod);
private:
	int    InitEnum(PPID prmrPersonID, const DateRange * pPeriod, long * pHandle);

	PPTblEnumList EnumList;
};
//
//
//
struct AddPersonEventFilt : public PPBaseFilt { // @persistent
	AddPersonEventFilt();
	AddPersonEventFilt & FASTCALL operator = (const AddPersonEventFilt & rSrc);
	//
	// Descr: Вызывает диалог редактирования фильтра.
	// Note: Так как для объекта AddPersonEventFilt не существует сопоставленного объекта PPView,
	//   то функцию редактирования включена сюда (обычно редактирование фильтра реализует метод PPView::EditBaseFilt).
	//
	int    Edit();
	//
	// Если определена карта постредством PrmrSCardID или PrmrSCardCode, то владелец этой карты
	// имеет приоритет перед PrmrPsnID.
	// То же самое относится и ко вторичной персоналии, соответственно, ScndSCardID, ScndSCardCode, ScndPsnID.
	//
	char   ReserveStart[24];  // @anchor
	PPID   ReaderDvcID;       // Ид устройства считывания кода
	uint16 DvcReadCycle;      // Цикл опроса устройства ReaderDvcID (ms) default=1000 (1s)
	uint16 DvcReadPeriod;     // Общая продолжительность считывания (5s) 0 означает бесконечный процесс
	PPID   OpID;              // ИД вида операции (имеет приоритет перед OpCode)
	LDATE  Dt;
	PPID   PrmrPsnID;
	PPID   ScndPsnID;
	PPID   PrmrSCardID;       // ИД карты первичной персоналии (имеет приоритет перед PrmrSCardCode)
	PPID   ScndSCardID;       // ИД карты вторичной персоналии (имеет приоритет перед PrmrSCardCode)
	PPID   PrmrPsnRegTypeID;  // Тип регистра, используемый для идентификации первичной персоналии по коду
	PPID   ScndPsnRegTypeID;  // Тип регистра, используемый для идентификации вторичной персоналии по коду
	long   Flags;             // @flags
	int16  InteractiveLevel;  // Уровень интерактивности: 0 - полностью неинтерактивно, 1 - только показывать информацию, 2 - полностью интерактивно
	int16  Reserve;           //
	SString OpCode;           // @anchor Код вида операции (применяется, если OpID == 0)
	SString PrmrPsnCode;      // Код первичной персоналии (применяется, если PrmrPsnID == 0)
	SString ScndPsnCode;      // Код вторичной персоналии (применяется, если ScndPsnID == 0)
	SString PrmrSCardCode;    // Код карты первичной персоналии (применяется, если PrmrSCardID == 0)
	SString ScndSCardCode;    // Код карты вторичной персоналии (применяется, если ScndSCardID == 0)
private:
	virtual int ReadText(const char * pText, long);
};

class PPObjPersonEvent : public PPObject {
public:
	// @v11.1.12 (no more used) static SString & FASTCALL MakeCodeString_(const PersonEventTbl::Rec * pRec, int options, SString & rBuf);
	explicit PPObjPersonEvent(void * extraPtr = 0);
	~PPObjPersonEvent();
	virtual int  Search(PPID, void * = 0);
	virtual int  DeleteObj(PPID);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr /*prmrPersonID*/);
	virtual int  EditRights(uint bufSize, ObjRights * rt, EmbedDialog * pDlg);
	SString & MakeCodeString(const PersonEventTbl::Rec * pRec, SString & rBuf);
	int    InitPacket(PPPsnEventPacket * pPack, PPID opID = 0, PPID prmrPersonID = 0);
	int    InitPacket(PPPsnEventPacket * pPack, const AddPersonEventFilt & rFilt, int interactive);
	int    GetPacket(PPID, PPPsnEventPacket *);
	int    PutPacket(PPID * pID, PPPsnEventPacket *, int use_ta);
	int    EditPacket(PPPsnEventPacket * pPack, bool asTemplate);
	void   Subst(SubstGrpPersonEvent sgpe, PPID opID, PPID prmrID, PPID scndID, PPID * pID);
	void   GetSubstName(SubstGrpPersonEvent sgpe, PPID id, char * pBuf, size_t bufLen);
	//
	// Descr: Проверяет выполнение ограничений pConstr на персоналию personID и карту scardID
	//
	int    CheckRestrictions(const PPPsnEventPacket * pPack, PPID personID, PPID scardID, const PPPsnOpKindPacket::PsnConstr * pConstr);
	//
	// Descr: Проверяет выполнение ограничений, заданных в види операции pPokPack, для персоналий,
	//   участвующих в операции, определенной пакетом pPack.
	//
	int    CheckRestrictions(const PPPsnEventPacket * pPack, const PPPsnOpKindPacket * pPokPack);
	int    SerializePacket(int dir, PPPsnEventPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Высокоуровневая функция, обрабатывающая фильтры создания событий специального вида, содержащие
	//   идентификатор устройства ввода.
	//
	int    ProcessDeviceInput(const AddPersonEventFilt & rFilt);
	int    SearchPairEvent(PPID evID, int dirArg, PersonEventTbl::Rec * pRec, PersonEventTbl::Rec * pPairRec);
	int    SetForcePairFlag(PPID evID, int set, int use_ta);

	PPObjRegister RegObj;
	PPObjPerson PsnObj;
	PPObjStaffList StLObj;

	class ProcessDeviceInputBlock {
	public:
		friend class PPObjPersonEvent;

		ProcessDeviceInputBlock();
		const  SString & GetDeviceText() const;
		const  SString & GetInfoText() const;
	private:
		enum {
			stInitialized = 0x0001,
			stError       = 0x0002
		};
		long   State;
		AddPersonEventFilt Filt;
		PPPsnOpKindPacket PokPack;
		PPAbstractDevice Ad;
		StrAssocArray Out;
		SString TempBuf; // @allocreuse
		SString DeviceText;
		SString InfoText;
	};

	int    InitProcessDeviceInput(ProcessDeviceInputBlock & rBlk, const AddPersonEventFilt & rFilt);
	int    FinalizeProcessDeviceInput(ProcessDeviceInputBlock & rBlk);
	int    Helper_ProcessDeviceInput(ProcessDeviceInputBlock & rBlk);
private:
	struct FrwdPsnEventItem { // @flat
		LDATE  Dt;
		long   OprNo;
		PPID   ID;
	};
	virtual int HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual const char * GetNamePtr();
	int    TurnClause(PPPsnEventPacket * pPack, const PPPsnOpKind * pPok, const PoClause_ * pClause, int action, int use_ta);
	int    TC_SetCalendar(PPID psnID, const PPPsnOpKind * pPok, const PPPsnEventPacket * pPack, const PoClause_ * pClause);
	int    GetFrwdList(PPID psnID, int isPrmr, LDATE dt, long oprno, TSVector <FrwdPsnEventItem> *);
	int    GetFrwdList(PPID psnID, LDATE dt, long oprno, TSVector <FrwdPsnEventItem> *);
	int    Helper_PutPacket(PPID evID, int action, PPPsnEventPacket *, PPPsnOpKindPacket *);

	void * ExtraPtr;
	SString NameBuf;
	PPObjStaffCal StcObj;
	PPObjSCard * P_ScObj;
public:
	TLP_MEMB(PersonEventCore, P_Tbl);
};
//
// @ModuleDecl(PPViewPersonEvent)
//
class AverageEventTimePrcssr {
public:
	struct Item { // @flat
		long   GetAverage() const;
		long   ID1;
		long   ID2;
		LDATETIME FirstEv;
		LDATETIME LastEv;
		long Count;
	};
	AverageEventTimePrcssr();
	int    Add(long id1, long id2, LDATE dt, LTIME tm);
	int    Enum(uint * pPos, Item ** pItem);
private:
	TSVector <Item> List;
};

struct PersonEventFilt : public PPBaseFilt {
	PersonEventFilt();

	enum {
		fWithoutPair = 0x0001
	};
	char   ReserveStart[20];   // @anchor
	PPID   ExtPrmrPersonRegID; // Регистр первичной персоналии для отображения в таблице
	PPID   ExtPrmrPersonTagID; // Тег первичной персоналии для отображения в таблице
	long   Flags;              //
	DateRange Period;          // Период обзора
	TimeRange TmPeriod;        // Период по времени
	int16  DayOfWeek;          // День недели
	int16  Reserve;
	PPID   PrmrID;             // Первичная персоналия //
	PPID   ScndID;             // Вторичная персоналия //
	SubstGrpPersonEvent Sgpe;  // Параметр подстановки
	SubstGrpDate        Sgd;   // Параметр подстановки даты
	ObjIdListFilt PsnOpList;   // @anchor Список видов операций
};

struct PersonEventViewItem : public PersonEventTbl::Rec {
	PersonEventViewItem();
	PersonEventViewItem & Z();
	SString SMemo; // @v11.1.12
	SString GrpText1;
	SString GrpText2;
	SString AvgEvTime;
	long   GrpCount;
};

class PPViewPersonEvent : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
		long   Flags;
		LDATETIME Dtm;
	};
	PPViewPersonEvent();
	~PPViewPersonEvent();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PersonEventViewItem *);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual void * GetEditExtraParam();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int    Transmit(PPID /*id*/);
	int    ChangeFlags(long action);

	PersonEventFilt  Filt;
	PPObjPersonEvent PsnEvObj;
	PPObjPsnOpKind   PokObj;
	TempPersonEventTbl * P_TempGrpTbl;
	PersonEventTbl * P_TempTbl;
};
//
// @ModuleDecl(PrcssrSalary)
//
class PrcssrSalary {
public:
	struct Param {
		enum {
			fSilent  = 0x0001, // Не выводить сообщения в журнал
			fVerbose = 0x0002  // Выводить максимально подробные сообщения в журнал
		};
		DateRange NominalPeriod;
		DateRange ActualPeriod;
		PPID   OrgID;
		PPID   DivID;
		PPID   StaffID;
		PPID   PostID;
		long   Flags;
	};
	//
	// Descr: Функции, используемые в формулах (PPCalcExpression)
	//
	enum {
		funcCalDay        = EXRP_EVAL_FIRST_FUNC +  1, // cday(CalendarName[, ProjCalendarName[, period]])
		funcCalHour       = EXRP_EVAL_FIRST_FUNC +  2, // chour(CalendarName[, ProjCalendarName[, period]])
		funcCharge        = EXRP_EVAL_FIRST_FUNC +  3, // charge(SalChargeSymb[, Period])
		funcAvgCharge     = EXRP_EVAL_FIRST_FUNC +  4, // avgcharge(SalChargeSymb, Period)
		funcBill  = EXRP_EVAL_FIRST_FUNC +  5, // bill(OpID, Kind[, Period])
		funcPaym  = EXRP_EVAL_FIRST_FUNC +  6, // paym(OpID, Kind[, Period])
		funcEvCalDay      = EXRP_EVAL_FIRST_FUNC +  7, // evcday(EvKindSymb[, ProjCalendarName[, period]])
		funcEvCalHour     = EXRP_EVAL_FIRST_FUNC +  8, // evchour(EvKindSymb[, ProjCalendarName[, period]])
		funcEvCount       = EXRP_EVAL_FIRST_FUNC +  9, // evcount(EvKindSymb[, period])
		funcThisEvCalDay  = EXRP_EVAL_FIRST_FUNC + 10, // ThisEvCDay([ProjCalendarName])
		funcThisEvCalHour = EXRP_EVAL_FIRST_FUNC + 11, // ThisEvCHour([ProjCalendarName])
		funcLastMonth     = EXRP_EVAL_FIRST_FUNC + 12, // LastMonth([date])
		funcLastQuart     = EXRP_EVAL_FIRST_FUNC + 13, // LastQuart([date])
		funcLastYear      = EXRP_EVAL_FIRST_FUNC + 14, // LastYear([date])
		funcThisMonth     = EXRP_EVAL_FIRST_FUNC + 15, // ThisMonth([date])
		funcThisQuart     = EXRP_EVAL_FIRST_FUNC + 16, // ThisQuart([date])
		funcThisYear      = EXRP_EVAL_FIRST_FUNC + 17, // ThisYear([date])
		funcNextMonth     = EXRP_EVAL_FIRST_FUNC + 18, // NextMonth([date])
		funcNextQuart     = EXRP_EVAL_FIRST_FUNC + 19, // NextQuart([date])
		funcNextYear      = EXRP_EVAL_FIRST_FUNC + 20, // NextYear([date])
		funcDiffDays      = EXRP_EVAL_FIRST_FUNC + 21, // diffd(date[, date])
		funcDiffMonths    = EXRP_EVAL_FIRST_FUNC + 22, // diffm(date[, date])
		funcDiffYears     = EXRP_EVAL_FIRST_FUNC + 23, // diffy(date[, date])
	};
	struct CalcPeriodParam {
		PPID   PostID;
		SString CalSymb;
		SString ProjCalSymb;
		DateRange Period;
	};
	PrcssrSalary();
	~PrcssrSalary();
	int    InitParam(Param *);
	int    EditParam(Param *);
	int    Init(const Param *);
	int    Run();
	int    CalcPeriod(const CalcPeriodParam & rCpP, long * pDays, double * pHours);
	int    TestCalcPeriod(PPID postID);
	int    ProcessPost(PPID postID, UintHashTable * pIdList, int use_ta);
	int    Expr_ResolveSymb(const char * pSymb, double * pVal);
	int    IsFunc(const char * pSymb, int * pFuncId);
	int    Expr_ResolveFunc(int funcId, uint argCount, double * pArgList, double * pResult);
private:
	struct FuncDescr { // @flat
		FuncDescr();
		int    FASTCALL IsEqHdr(const FuncDescr & rS) const;

		enum {
			fLink = 0x0001
		};
		int    Id;
		int    FuncId;
		PPID   AmtID;
		long   Flags;
	};

	int    WriteOff(const UintHashTable * pIdList, int undoOnly, int use_ta);
	double StorePeriod(const DateRange & rPeriod);
	int    GetArgPeriod(double arg, DateRange & rPeriod);
	int    Helper_CalcPayment(PPID opID, const DateRange & rPeriod, int kind,
		const PPIDArray & rArList, const PPIDArray * pExtBillList, const FuncDescr & rFc, double * pResult);
	int    Helper_CalcShipment(PPID opID, const DateRange & rPeriod, int kind, const PPIDArray & rArList, const FuncDescr & rFc, double * pResult);
	int    ParseFunc(const char * pText);
	int    ParseAmtType(const char * pText, FuncDescr & rDescr);
	int    GetFunc(int id, FuncDescr * pDescr) const;
	int    Helper_GetPeriod(double arg, const DateRange & rInitPeriod, DateRange & rPeriod);

	Param P;
	StrAssocArray AmtTypeList;
	StrAssocArray CalList;
	SalaryCore Tbl;
	PPObjSalCharge ScObj;
	PPObjStaffCal  CalObj;
	PPObjStaffList SlObj;
	PPObjTag       TagObj;
	PPObjPersonEvent EvObj;
	PPViewBill * P_BillView;
	PPViewPersonEvent * P_EvView;
	StrAssocArray TagSymbList;
	StrAssocArray ScSymbList;     // Список символов видов начисления //
	StrAssocArray EvSymbList;     // Список символов видов персональных операций //
	PPPsnPostPacket CurPostPack;  // Пакет штатного назначения, обрабатываемого на текущей итерации
	PPStaffPacket   CurStaffPack; // Пакет штатной должности назначения, обрабатываемого на текущей итерации
	StaffAmtList    CurEmployerAmtList; // Список штатных сумм, соответствующих работодателю из CurPostPack
	PersonEventTbl::Rec * P_CurEv; // @notowned Если начисление осуществляется по персональным событиям, то
		// P_CurEv указатель на текущее событие, по которому ведется расчет. В противном случае - 0.
	PPLogger Logger;
	TSVector <FuncDescr> FuncList; //
	TSRingStack <DateRange> PeriodStack;
	int    LastFuncId;
};
//
// @ModuleDecl(PPViewPerson)
//
// Фильтр по персоналиям
//
// EmptyAttrib
#define EA_ALL          0 // Все
#define EA_NOEMPTY      1 // С непустым атрибутом
#define EA_EMPTY        2 // С пустым атрибутом

#define TAGOFFSET 100000L

#pragma pack(push, 1)
struct PersonFilt : public PPBaseFilt {
	//
	// Descr: Специализация экземпляра
	//
	enum {
		spcGeneral = 0,         // Общее назначение
		spcClientActivityStats  // Статистика клиентской активности
	};
	enum {
		fExtEdit          = 0x0002, // @unused Отдельный диалог редактирования главной организации
		fVatFree          = 0x0004, // Свободен от НДС
		fTagsCrsstab      = 0x0008, // Показывать броузер персоналий, как кросстаб с тегами
		fHasImages        = 0x0010, // Только с картинками
		fShowNewCli       = 0x0020, // Идентифицировать новых клиентов (требуется NewCliPeriod)
		fPrecName         = 0x0040, // SrchStr содержит точное имя персоналии (не чувствительно к регистру)
		fShowHangedAddr   = 0x0080, // При использовании атрибута PPPSNATTR_ALLADDR отображать адреса, не
			// привязанные ни к одной из персоналий (но не являющиеся автономными)
		fLocTagF          = 0x0100, // Субфильтр P_TagF применяется к локациям, а не к персоналиям
		fShowFiasRcgn     = 0x0200, // Показывать результаты распознавания адресов и сопоставления с ФИАС
		// @v12.2.2 (замещено более общим функционалом анализа клиентской активности) fNewClientsOnly   = 0x0400, // Только новые клиенты (действует при не пустом NewCliPeriod)
		fCliActivityStats = 0x0800, // @v12.2.2 Отображать статистику активности клиентов. 
		fNoTempTable      = 0x1000, // @v12.3.3 @construction Не создавать временную таблицу, даже если условия фильтрации этого требуют
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке SrchStr_
	//
	enum { // @persistent
		extssNameText  = 1,
		extssEmailText = 2,
		extssPhoneText = 3
	};

	PersonFilt();
	void   Setup();
	//
	// IsEmpty calls PersonFilt::Setup, than this is not const
	//
	virtual bool IsEmpty() const;
	PersonFilt & FASTCALL operator = (const PersonFilt &);
	int    GetAttribType() const;
	//
	// Descr: Возвращает значение дополнительного атрубута, если вид строится по адресам, а не по собственно персоналиям.
	//   Специальный случай, обрабатываемый функцией: установлен флаг PersonFilt::fLocTagF и задан не пустой атрубут - в этом
	//   случае вместо самого атрибута функция возвращает PPPSNATTR_ALLADDR что означает, что модуль PPView должен построить
	//   вид по всем адресам персоналий и отобразить для этих адресов атрибут, выбранный в AttribType.
	//
	int    GetLocAttribType() const;
	bool   SetAttribType(int attribType);
	bool   IsLocAttr() const;
	int    GetExtssData(int fldID, SString & rBuf) const;
	int    PutExtssData(int fldID, const char * pBuf);

	uint8  ReserveStart[16];  // @anchor
	LDATE  ClientActivityEvalDate;   // @v12.2.2 Опорная дата для анализа состояния клиентов в соответствии со статистикой их активности. Если ZERODATE, то - текущая дата.
	uint16 ClientActivityStateFlags; // @v12.2.2 Фильтр по состояниями клиентской активности.
		// (1 << PPObjPerson::ClientActivityState::stUndef(0))
		// (1 << PPObjPerson::ClientActivityState::stNoData(1))
		// (1 << PPObjPerson::ClientActivityState::stRegularTa(2))
		// (1 << PPObjPerson::ClientActivityState::stDelayedTa(3))
		// (1 << PPObjPerson::ClientActivityState::stHopelesslyDelayedTa(4))
		// PPObjPerson::ClientActivityState::stfNewClient
		// Если ClientActivityStateFlags == 0, то это эквивалентно отсутствию ограничений (так же как и значение 0xffff)
	uint16 GenderFlags;       // (1 << GENDER_XXX)
	DateRange NewCliPeriod;   // Период идентификации нового клиента
	PPID   PersonKindID;      //
	PPID   PersonCategoryID;  //
	PPID   Status;            //
	PPID   CityID;            //
private:
	int    AttribType;        // 
public:
	int    EmptyAttrib;       // EA_XXX
	PPID   RegTypeID;         //
	PPID   StaffOrgID;        //
	PPID   StaffDivID;        //
	PPID   PersonID;          // Отображает в броузере только данную персоналию
	long   Flags;             //
	RegisterFilt * P_RegF;    // @anchor для отмера "плоского" участка фильтра
	TagFilt * P_TagF;         //
	SysJournalFilt * P_SjF;   //
	ObjIdListFilt List;       // Список идентификаторов персоналий, которые следует показать
	SString SrchStr_;         //
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};
#pragma pack(pop)

typedef TempPersonTbl::Rec PsnAttrViewItem;

struct PersonViewItem : public PersonTbl::Rec {
	PersonViewItem()
	{
	}
	PsnAttrViewItem AttrItem;
	//
	long    CaEventCount;      // @v12.2.10
	double  CaGapDaysAvg;      // @v12.2.10
	double  CaGapDaysStdDev;   // @v12.2.10
	long    CaDelayDays;       // @v12.2.10
	double  CaDelaySd;         // @v12.2.10  
	bool    CaIsNew;           // @v12.2.10
	uint8   Reserve[3];        // @v12.2.10 @alignment
	long    CaActivityState;   // @v12.2.10
};

class PPViewPerson : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	PPViewPerson();
	~PPViewPerson();
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void ViewTotal();
	int    InitIteration();
	int    FASTCALL NextIteration(PersonViewItem * pViewItem);
	int    AddItem(PPID * pID);
	int    EditItem(PPID);
	int    DeleteItem(PPID);
	int	   OpenClientDir(PPID personId);
	int    EditRegs(PPID personID, PPID locID, int oneReg);
	int    EditDlvrAddrExtFlds(PPID id);
	int    ViewRelations(PPID);
	int    AddRelation(PPID);
	int    ViewTasks(PPID);
	int    ViewPersonEvents(PPID);
	int    Export();
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    Transmit(PPID id, int transmitKind);
	void   GetTabTitle(long tabID, SString & rBuf) const;
	int    GetSmsLists(StrAssocArray & rPsnList, StrAssocArray & rPhoneList, uint what = 0); // @vmiller
	int    CreateAuthFile(PPID psnId);
	// @v12.2.10 int    FASTCALL IsNewCliPerson(PPID id) const;
	SString & FASTCALL GetFromStrPool(uint strP, SString & rBuf) const;
	int    FASTCALL HasImage(const void * pData);
	int    CheckIDForFilt(PPID id, const PersonTbl::Rec * pRec);
	//
	// Descr: Элемент с дополнительной информацией о персоналии
	//
	struct ExtEntry { // @v12.2.10
		ExtEntry();
		PPID   ID; // Person.ID
		uint   ClientActivityState;
		uint   PhoneP;         // Ссылка на строку телефона
		uint   EMailP;         // Ссылка на строку адреса электронной почты
		uint   AddressP;       //
		uint   RAddressP;      //
		uint   BnkNameP;       // 
		uint   BnkAcctP;       //
		uint   RegSerialP;     //
		uint   FiasAddrGuidP;  //
		uint   FiasHouseGuidP; //
		uint   AddrTypeP;      // Ссылка на строку наименования типа адреса (адрес доставки, юридически, реальный etc)
	};
	//
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
	// @v12.2.10 static bool CheckClientActivityState(PPID personID, long filtFlags, const LAssocArray * pClientActivityStateList);
	static bool CheckClientActivityState(PPID personID, long filtFlags, const TSVector <ExtEntry> * pExtList);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   OnExecBrowser(PPViewBrowser *);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	virtual void * GetEditExtraParam();
	virtual int   Print(const void *);
	int    InitPersonAttribIteration();
	int    InitPersonIteration();
	bool   IsTempTblNeeded(); // non-const because calls PsnObj.GetConfig
	int    CreateTempRec(PersonTbl::Rec * pPsnRec, PPID tabID, PsnAttrViewItem * pItem);
	int    AddTempRec(PPID personID, UintHashTable * pUsedLocList, int use_ta);
	int    EditTempRec(PPID, int use_ta);
	int    CreateLikenessTable();
	int    CreateAddrRec(PPID addrID, const LocationTbl::Rec * pLocRec, const char * pAddrKindText, PsnAttrViewItem * pItem);
	int    UpdateList();
	int    UpdateHungedAddr(PPID addrID);
	int    RemoveHangedAddr();
	int    Recover();
	int    Helper_InsertTempRec(const TempPersonTbl::Rec & rRec);
	int    Helper_GetTagValue(PPObjID oid, PPID tagID, SString & rBuf);
	
	enum {
		nifOmitCliActivityFlags = 0x0001,
	};

	int    Helper_NextIteration(uint flags, PersonViewItem * pViewItem);
	int    Helper_CheckIDForFilt(PPID id, uint flags, const PersonTbl::Rec * pRec);
	//
	// Рассылка сообщений по email
	//
	int    SendMail(PPID mailAccId, const StrAssocArray * pMailList, PPLogger * pLogger);
	int    ExportUhtt();
	static const ExtEntry * FASTCALL Implement_SearchExtEntry(const TSVector <ExtEntry> * pExtList, PPID id);
	const  ExtEntry * FASTCALL SearchExtEntry(PPID id) const;
	ExtEntry * SearchExtEntryForUpdate(PPID id, uint * pIdx);
	bool   SearchInternalViewItem(PPID personID, PPID tabID, uint * pPos) const;

	PPID   DefaultTagID;
	//
	// Descr: Флаги состояния //
	//
	enum {
		stUseInternalList = 0x0001, // Init_() вызвана с опцией фильтра PersonFilt::fNoTempTable. Вместо P_TempPsn используется InternalViewList
	};
	uint   State; // @v12.3.3
	// @v12.2.10 UintHashTable NewCliList;
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в TempPersonTbl
	TempPersonTbl * P_TempPsn;
	PersonFilt  Filt;
	PPObjPerson PsnObj;
	PPObjStaffList StLObj;
	PPObjTag   ObjTag;
	PPObjWorld WObj;
	PPFiasReference * P_Fr;
	TSVector <ExtEntry> ExtList;
	//
	// Descr: Структура для хранения элемента VIEW при отсутствии временной таблицы (Filt.Flags & PersonFilt::fNoTempTable)
	//
	struct InternalViewItem { // @v12.3.3 @construction @flat
		InternalViewItem();
		void   Setup(const TempPersonTbl::Rec & rRec);
		PPID   PersonID;
		PPID   TabID;
		uint32 PhoneP;
		uint32 EMailP;
		uint32 AddressP;
		uint32 RAddressP;
		uint32 BnkNameP;
		uint32 BnkAcctP;
		uint32 RegSerialP;
		uint32 FiasAddrGuidP;
		uint32 FiasHouseGuidP;
		uint32 AddrTypeP;
	};
	TSVector <InternalViewItem> InternalViewList; // @v12.3.3 @construction
	//
	static int DynFuncCheckClientActivityStatus; // @v12.2.2
};

int ViewPersonInfoBySCard(const char * pCode);

/* @v12.2.6 замещено более общим функционалом анализа клиентской активности
class PPNewContragentDetectionBlock {
public:
	PPNewContragentDetectionBlock();
	~PPNewContragentDetectionBlock();
	int    IsNewPerson(PPID psnID, const DateRange & rPeriod);
	int    IsNewArticle(PPID arID, const DateRange & rPeriod);
private:
	int    InitProcess();

	enum {
		stPrcInited = 0x0001,
		stEmpty     = 0x0002  // Не определено ни одного эффективного условия для идентификации
	};
	long   State;
	PPIDArray OpList;
	PPIDArray AcsList;
	PPIDArray PsnOpList;
	PPIDArray ScOpList;
	PPPersonConfig PsnCfg;
	PPObjPersonEvent * P_PeObj;
	PPObjArticle * P_ArObj;
	PPObjSCard * P_ScObj;
};*/
//
//
//
struct ClientActivityDetailedEntry { // @flat @transient
	ClientActivityDetailedEntry() : Dtm(ZERODATETIME)
	{
	}
	ClientActivityDetailedEntry(PPObjID oid, LDATE dt) : Dtm(ZERODATETIME), Oid(oid)
	{
		Dtm.d = dt;
	}
	ClientActivityDetailedEntry(PPObjID oid, LDATETIME dtm) : Dtm(dtm), Oid(oid)
	{
	}
	LDATETIME Dtm; // Дата/время нужны (по крайней мере) из-за того, что операцию по карте однозначно по дате не идентифицировать.
	//
	// Если Oid.Obj == PPOBJ_SCARD, то подразумеваемая транзакции - операции по этой карте на момент Dtm.
	//
	PPObjID Oid;
};
//
// @ModuleDecl(PPObjArticle)
//
class ArticleFilt : public PPBaseFilt {
public:
	ArticleFilt();
	ArticleFilt & FASTCALL operator = (const ArticleFilt &);

	enum {
		fShowAgreement   = 0x0001,
		fCheckObj        = 0x0002, // Проверять корректность объектов. Если установлен, то
			// в таблице добавляется колонка с сообщением о проблеме (если есть).
		fShowAddedLimit  = 0x0004, // Показывать дополнительный кредитный лимит, рассчитанный для специального периода
			// Опция действует только если fShowAgreement и в конфигурации рейтингов дебиторов установлены значения //
			// периода расчета кредитного лимита и периода дополнетельного кредитного лимита
		fWithIxParamOnly = 0x0008, // Только статьи с не пустыми параметрами обмена в соглашении
		fNonGenericOnly  = 0x0010  // Исключить группирующие статьи
	};
	char   ReserveStart[28]; // @anchor
	int32  LimitAddedTerm; // Период в днях для отображения дополнительного кредитного лимита
	PPID   AccSheetID;     //
	PPID   PersonID;       //
	int    Order;          //
	int16  Ft_Closed;      // (0) ignored, (< 0) off, (> 0) on
	int16  Ft_Stop;        // (0) ignored, (< 0) off, (> 0) on
	long   Flags;          // @flags
	long   Reserve;        // @anchor Заглушка для отмера "плоского" участка фильтра
};
//
// Специфические флаги доступа к аналитическим статьям
//
#define ARTRT_CLIAGT   0x0100 // Добавление и модификация соглашений с клиентами
#define ARTRT_MULTUPD  0x0200 // Право на массовое изменение или удаление

// ArticleTbl::Rec::Flags   ARTRF_XXX
#define ARTRF_GROUP    0x0001L // Группирующая статья аналитического учета
#define ARTRF_STOPBILL 0x0002L // По статье, имеющей такой флаг запрещено создавать новые документы
#define ARTRF_BUDG_INC 0x0004L // Доходная статья бюджета
#define ARTRF_CLOSED   0x0008L // @transient Дублирование поля Closed (используется в кэше)

struct PPArticlePacket {
	friend class PPObjArticle;

	PPArticlePacket();
	~PPArticlePacket();
	PPArticlePacket & FASTCALL operator = (const PPArticlePacket &);
	void   Init();
	//
	// Descr: Устанавливает параметры соглашения с клиентом в пакет записи.
	//   Если ignoreEmpty != 0 && pAgt->IsEmpty() то в соглашение обнуляется (или не устанавливается)
	//
	int    SetClientAgreement(const PPClientAgreement * pAgt, int ignoreEmpty /*= 0*/);
	//
	// Descr: Устанавливает параметры соглашения с поставщиком в пакет записи.
	//   Если ignoreEmpty != 0 && pAgt->IsEmpty() то в соглашение обнуляется (или не устанавливается)
	//
	int    SetSupplAgreement(const PPSupplAgreement * pAgt, int ignoreEmpty = 0);
	const  LAssocArray * GetAliasSubst() const;
	int    EnumAliasSubst(uint * pPos, PPID * pAliasID, PPID * pAccID) const;
	int    AddAliasSubst(PPID accAliasID, PPID accID);
	int    UpdateAliasSubst(PPID accAliasID, PPID accID);
	int    RemoveAliasSubst(PPID accAliasID);

	ArticleTbl::Rec Rec;         // Заголовочная запись
	long   Assoc;                // @transient PPAccSheet(Rec.AccSheetID).Assoc
	PPClientAgreement * P_CliAgt;   // Соглашение с клиентом
	PPSupplAgreement  * P_SupplAgt; // Соглашение с поставщиком
	int    DontUpdateAliasSubst; // @transient Признак того, что функция PPObjArticle::PutPacket
		// не должна изменять таблицу соответствия алиасов счетов в базе данных.
private:
	LAssocArray * P_AliasSubst; // Таблица подстановок алиасов счетов
};

class PPObjArticle : public PPObject {
public:
	static int DefaultClientAgreement();
	static int DefaultSupplAgreement();
	//
	// Descr: Возвращает идентификатор типа регистрационного документа, используемого для //
	//   поиска персоналии, соответствующей статьям таблицы accSheetID.
	//   Если задан код типа регистрационного документа pRegTypeCode, то функция //
	//   ищет соответствующий име идентификатор. Если такой код не найден или
	//   pRegTypeCode == 0, то из записи таблицы accSheetID извлекается поле CodeRegTypeID.
	//   Если и в записи таблицы аналитического учета регистрационный документ для поиска не
	//   указан, и параметр useBillconfig != 0, то функция получает поле PPBillConfig::ClCodeRegTypeID.
	//   Если это поле больше нуля, то функция возвращает 2.
	// Returns:
	//   1  - ид типа регистрационного документа удачно обнаружен и присвоен по указателю pRegTypeID
	//   2  - ид типа регистрационного документа извлечен из конфигурации документов
	//   <0 - не удалось идентифицировать тип регистрационного документа для поиска персоналии.
	//   0  - ошибка
	//
	static int GetSearchingRegTypeID(PPID accSheetID, const char * pRegTypeCode, int useBillConfig, PPID * pRegTypeID);
	//
	// Descr: Возвращает вид соглашения, используемого статьей pArRec.
	// Returns:
	//   -1 - статья не соотносится ни с одним видом соглашения //
	//   0  - ошибка
	//   1  - статья использует соглашение с клиентом
	//   2  - статья использует соглашение с поставщиком
	//
	static int FASTCALL GetAgreementKind(const ArticleTbl::Rec * pArRec);
	// @v11.2.0 static int FASTCALL PropToClientAgt(const PropertyTbl::Rec * pPropRec, PPClientAgreement * pAgt, int loadDebtLimList = 0);
	static int FASTCALL GetSupplAgreement(PPID id, PPSupplAgreement * pAgt, int useInheritance = 0);
	static int FASTCALL EditSupplAgreement(PPSupplAgreement *);
	static int FASTCALL PropToSupplAgt(const PropertyTbl::Rec & rPropRec, PPSupplAgreement * pAgt);
	static int FASTCALL HasSupplAgreement(PPID arID);
	static int GetAliasSubst(PPID id, LAssocArray *); // @>>Reference::GetPropArray()
	static int PutAliasSubst(PPID id, const LAssocArray *, int use_ta); // @>>Reference::PutPropArray()

	explicit PPObjArticle(void * extraPtr = 0);
	~PPObjArticle();
	//
	// В качестве дополнительного параметра методам PPObjArticle
	// передается идентификатор таблицы аналитических статей.
	//
	virtual int    Browse(void * extraPtr);
	virtual int    Edit(PPID * pID, void * extraPtr);
	virtual int    EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int    DeleteObj(PPID id);
	//
	// Selector(extraParam)
	// If (extraParam >= 0), select only articles with (Closed == 0),
	// Else - without such constrain.
	//
	virtual int  Search(PPID id, void * b = 0);
	virtual void FASTCALL Dirty(PPID id);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*(ArticleFilt *)*/);
	const  ArticleFilt * GetCurrFilt() const;
	void   SetCurrFilt(const ArticleFilt * pFilt);
	SString & MakeCodeString(const ArticleTbl::Rec * pRec, long options, SString &);
	//
	// Descr: Опции сравнения пакетов функцией IsPacketEq
	//
	enum {
		peoDontCmpAliasSubst = 0x0001 // Не сравнивать алиасы подстановки
	};

	int    IsPacketEq(const PPArticlePacket & rS1, const PPArticlePacket & rS2, long options);
	int    CheckObject(const ArticleTbl::Rec * pRec, SString * pMsgBuf);
	//
	// Descr: Проверяет согласуется ли изменяемый пакет персоналии с соответствующими статьями
	//
	int    CheckPersonPacket(const PPPersonPacket * pPack, PPIDArray * pAbsentKinds);
	int    FASTCALL Fetch(PPID id, ArticleTbl::Rec * pRec); // @macrow
	int    GetPacket(PPID, PPArticlePacket *);
	int    PutPacket(PPID *, PPArticlePacket *, int use_ta);
	int    SerializePacket(int dir, PPArticlePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    GetFreeArticle(long * pID, long accSheetID);
	int    AutoFill(const PPAccSheet *);
	int    EditDialog(ArticleDlgData *);
	int    EditGrpArticle(PPID * pID, PPID sheetID);
	int    NewArticle(PPID * pID, long sheetID);
	int    GetMainOrgAsSuppl(PPID * id, int processAbsense = 0, int use_ta = 0);
	int    CreateObjRef(PPID *, PPID accSheetID, PPID objID, long ar, int use_ta);
	int    AddSimple(PPID *, PPID accSheetID, const char * pName, long ar, int use_ta);
	int    GetClientAgreement(PPID id, PPClientAgreement & rAgt, int use_default = 0);
	static int PutClientAgreement(PPID id, PPClientAgreement *, int use_ta);
	int    HasClientAgreement(PPID arID);
	int    EditClientAgreement(PPClientAgreement *);
	int    PutSupplAgreement(PPID id, PPSupplAgreement *, int use_ta);
	//
	// Descr: Интерактивная функция редактирования соглашения с клиентом или поставщиком
	//   (в зависимости от таблицы, которой принадлежит статья arID).
	// Returns:
	//   >0 - пользователь успешно изменил соглашение
	//   <0 - либо статья arID не предполагает существования соглашения, либо пользователь
	//        отказался от изменения соглашения //
	//   0  - ошибка
	//
	int    EditAgreement(PPID arID);
	//
	// Descr: Ищет аналитическую статью, сопоставленную персоналии, имеющей номер
	//   регистрационного документа типа regTypeID равный pRegCode. Найденная персоналия должна
	//   быть сопоставленна статье по таблице accSheetID.
	//
	int    SearchByRegCode(PPID accSheetID, PPID regTypeID, const char * pRegCode, PPID * pID, ArticleTbl::Rec *);
	int    GetByLocationList(PPID accSheetID, const PPIDArray * pLocList, PPIDArray * pArList);
	int    GetByPersonList(PPID accSheetID, const PPIDArray * pPsnList, PPIDArray * pArList);
	int    GetByPerson(PPID accSheetID, PPID psnID, PPID * pArID);
	int    GetRelPersonList(PPID arID, PPID relTypeID, int reverse, PPIDArray * pList);
	int    GetRelPersonSingle(PPID arID, PPID relTypeID, int reverse, PPID * pRelID);
	int    GetByProcessor(PPID accSheetID, PPID prcID, PPIDArray * pArList);
	//
	static int ConvertClientAgreements_11200(Reference * pRef, int use_ta);
private:
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual const char * GetNamePtr();
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SearchAssocObjRef(PPID objType, PPID objID, PPID * pAccSheetID, PPID kind, PPID * pID);
	int    ReplyArticleReplace(PPID dest, PPID src);
	int    ReplyPersonReplace(PPID dest, PPID src);
	int    ReplyObjectCreated(PPID objType, PPID objID);
	int    _ProcessSearch(int, PPID id);
	int    _UpdateName(const char * pNewName);
	int    Helper_PutAgreement(PPID id, PPArticlePacket * pPack);

	void * ExtraPtr;
	ArticleFilt CurrFilt;
	PPObjPersonRelType ObjRelTyp;
public:
	TLP_MEMB(ArticleCore, P_Tbl);
};
//
// @ModuleDecl(PPViewSysJournal)
//
struct SysJournalFilt : public PPBaseFilt {
	enum {
		fShowObjects    = 0x0001, // Отображать наименования объектов, связанными с событиями
		fShowHistoryObj = 0x0002  // Отображать дополнительную информацию, связанную с предшествующим
			// событию состоянием объектов (только для тех, для которых хранятся версии).
	};

	SysJournalFilt();
	virtual bool IsEmpty() const;

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPID   UserID;
	PPID   ObjType;
	PPID   ObjID;
	long   Flags;
	int16  DayOfWeek;
	int16  Reserve;
	SubstGrpSysJournal Sgsj;
	SubstGrpDate       Sgd;  // Параметр подстановки даты
	PPIDArray ActionIDList;  // @anchor
};

struct SysJournalViewItem : public SysJournalTbl::Rec {
	SysJournalViewItem & Z();

	long   ID;
	long   GrpCount;
	SString ObjName;
	SString GrpText1;
	SString AvgEvTime;
};

class PPViewSysJournal : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		double Extra;
		PPID   Action;
		LDATETIME Dtm;
	};
	struct EvVerEntry : public PPObjID {
		enum {
			fAmtUp = 0x0001,
			fAmtDn = 0x0002
		};
		LDATETIME Dtm;
		uint   Flags;
		uint   NameP;
	};
	PPViewSysJournal();
	~PPViewSysJournal();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int    InitIteration();
	int    FASTCALL NextIteration(SysJournalViewItem *);
	int    FASTCALL CheckRecForFilt(const SysJournalTbl::Rec * pRec);
	int    GetObjName(const PPObjID & rOid, SString & rBuf) const;
	int    GetEvVerText(const EvVerEntry & rKey, SString & rBuf) const;
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void ViewTotal();
	virtual int Detail(const void *, PPViewBrowser * pBrw);
	virtual int Print(const void *);
	virtual int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	virtual int SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	bool   IsTempTblNeeded() const;
	int    RefreshTempTable(LDATETIME since);
	int    EditObj(const PPObjID * pObjID);
	int	   ViewBillHistory(PPID histID, LDATETIME evDtm);
	int    Transmit();

	static int DynFuncObjNameFromList;
	static int DynFuncEvVerTextFromList;

	SysJournalFilt  Filt;
	SysJournal * P_Tbl;
	SysJournalTbl * P_TmpTbl;
	TempSysJournalTbl * P_SubstTbl;
	ObjCollection * P_ObjColl;
	PPObjPerson PsnObj; // @fastreuse
	int    LockUpByNotify; // Семафор, блокирующий обновление данных по системному событию
	LDATETIME LastRefreshDtm; // Время последнего обновления выборки. Используется для определения времени,
		// начиная с которого следует извлекать события из журнала для последующего обновления.
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в TempSysJournalTbl
	TSVector <PPObjNamePEntry> ObjNameList;
	TSVector <EvVerEntry> EvVerList;
};
//
//
//
struct GtaJournalFilt : public PPBaseFilt {
	GtaJournalFilt();
	virtual bool IsEmpty() const;
	enum {
		fShowObjects  = 0x0001
	};
	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPID   GlobalUserID;
	PPObjID Oi;
	long   Flags;
	int16  DayOfWeek;
	int16  Reserve;
	PPIDArray ActionIDList;  // @anchor
};

struct GtaJournalViewItem : public GtaJournalTbl::Rec {
	long   ID;
	SString ObjName;
};

class PPViewGtaJournal : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		long   Op;
		LDATETIME Dtm;
	};
	PPViewGtaJournal();
	~PPViewGtaJournal();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	//virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int    InitIteration();
	int    FASTCALL NextIteration(GtaJournalViewItem *);
	int    FASTCALL CheckRecForFilt(const GtaJournalTbl::Rec * pRec);
	int    GetObjName(const PPObjID & rOid, SString & rBuf) const;
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	//virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int Detail(const void *, PPViewBrowser * pBrw);
	//virtual int Print(const void *);
	//virtual int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	//virtual int SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	bool   IsTempTblNeeded() const;

	static int DynFuncObjNameFromList;

	GtaJournalFilt  Filt;
	GtaJournalCore  T;
	GtaJournalTbl  * P_TmpTbl;
	//TempDoubleIDTbl * P_NamesTbl;
	ObjCollection  * P_ObjColl;
	int    LockUpByNotify; // Семафор, блокирующий обновление данных по системному событию
	LDATETIME LastRefreshDtm; // Время последнего обновления выборки. Используется для определения времени,
		// начиная с которого следует извлекать события из журнала для последующего обновления.
	SStrGroup StrPool; // Пул строковых полей
	TSVector <PPObjNamePEntry> ObjNameList;
};
//
// @ModuleDecl(PPViewLogsMonitor)
//
struct LogFileEntry {
	LogFileEntry();
	PPID   ID;
	char   LogName[128];
	char   FileName[32];
};
typedef TSArray <LogFileEntry> LogsArray;
//
struct LogsMonitorFilt : public PPBaseFilt {
	LogsMonitorFilt();
	virtual int Describe(long flags, SString & rBuff) const;

	char   ReserveStart[32]; // @anchor
	long   Flags;
	long   Reserve; // @anchor
	LogsArray Selected;
};
//
struct LogsMonitorViewItem;
//
class PPViewLogsMonitor : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		double Extra;
		PPID   Action;
	};
	PPViewLogsMonitor();
	~PPViewLogsMonitor();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(LogsMonitorViewItem *);
	virtual void PreprocessBrowser(PPViewBrowser *pBrw);
	//int CheckRecForFilt(const TempLogFileMonTbl::Rec *pRec);
private:
	virtual DBQuery * CreateBrowserQuery(uint *pBrwId, SString *pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int UpdateTempTable(LogsArray *pExpiredLogs);
	//virtual int Print(const void *);
	//
	LogsMonitorFilt		Filt;
	uint				CountLogs;
	LAssocArray			LogsOffsets;
	TempLogFileMonTbl	*P_TmpTbl;
	LDATETIME			LastUpdated;
	int					FirstTime;
};
//
void ViewLogsMonitor();
//
// @ModuleDecl(PPViewGeoTracking)
//
struct GeoTrackingFilt : public PPBaseFilt {
	GeoTrackingFilt();
	virtual bool IsEmpty() const;

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPObjID Oi;
	PPObjID ExtOi;
	long   Flags;
	uint32 Reserve;           // @anchor
};
//
// Descr: Итоги выборки гео-треков
//
struct GeoTrackingTotal {
	GeoTrackingTotal();

	long   Count;     // Количество точек в выборке
	long   ObjCount;  // Количество объектов в выборке
};

typedef GeoTrackTbl::Rec GeoTrackingViewItem;

class PPViewGeoTracking : public PPView {
public:
	PPViewGeoTracking();
	~PPViewGeoTracking();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(GeoTrackingViewItem *);
	int    FASTCALL CheckRecForFilt(const GeoTrackTbl::Rec * pRec);
	int    CalcTotal(GeoTrackingTotal * pTotal);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	int    Export();

	GeoTrackingFilt Filt;
	GeoTrackCore T;
};
//
// Descr: Фильтр по классификаторам товаров
//
struct ClsdGoodsFilt {
	//
	// @note Порядок полей важен! Сначала идут плоские данные, и затем сложные (ObjIdListFilt)
	//
	ClsdGoodsFilt();
	ClsdGoodsFilt & Z();
	int    FASTCALL IsEq(const ClsdGoodsFilt & rS) const;
	//
	// Descr: Возвращает !0 если фильтр содержит ограничение
	//   хотя бы по одному из классифицирующих атрибутов.
	//
	int    HasAttrRestrictions() const;
	int    SetDimRange(int dim, double low, double upp);
	enum {
		fFirstGenGoods = 0x0001 // Первый обобщенный товар, соответствующий фильтру
	};
	PPID   GdsClsID;
	long   Flags;
	RealRange DimX_Rng;
	RealRange DimY_Rng;
	RealRange DimZ_Rng;
	RealRange DimW_Rng;
	//
	// Ограничения по классифицирующим атрибутам {
	//
	ObjIdListFilt KindList;   // @anchor
	ObjIdListFilt GradeList;
	ObjIdListFilt AddObjList;
	ObjIdListFilt AddObj2List;
};
//
// Фильтр по товарам
//
class GoodsFilt : public PPBaseFilt { // @persistent
public:
	//
	// @todo Эту структуру следует объединить с ClsdGoodsFilt
	//  (данная структура @persistent по-этому действовать следует осторожно).
	//
	/*
	struct ExtParams {
		//
		// Descr: Возвращает !0 если фильтр содержит ограничение
		//   хотя бы по одному из классифицирующих атрибутов.
		//
		int    HasAttrRestrictions() const
		{
			return (KindID || GradeID || AddObjID || AddObj2ID ||
				!DimX.IsZero() || !DimY.IsZero() || !DimZ.IsZero() || !DimW.IsZero());
		}
		PPID   GdsClsID;
		PPID   KindID;
		PPID   AddObjID;
		PPID   GradeID;
		PPID   AddObj2ID;
		RealRange DimX;
		RealRange DimY;
		RealRange DimZ;
		RealRange DimW;
	};
	*/
	enum {
		fHideGeneric       = 0x00000001L, // @construction Не отображать обобщенные товары
		fWithStrucOnly     = 0x00000002L, // Только товары, с которыми связаны структуры
		fWoBrand           = 0x00000004L, // Только те товары, у которых не определен бренд. Флаг имеет приоритет перед полями BrandList, BrandOwnerList
		fIntUnitOnly       = 0x00000008L, //
		fFloatUnitOnly     = 0x00000010L, //
		fNegation          = 0x00000020L, // Отрицание фильтра
		fGenGoods          = 0x00000040L, // Если установлен, то поле GrpID используется как обобщенный товар.
		fGroupGenGoods     = 0x00000080L, // Группировать обобщенные товары
		fUndefType         = 0x00000100L, // Только с неопределенным типом товара
		fNewLots           = 0x00000200L, // Только те товары, которых не было на дату (LotPeriod.low-1)
		fExcludeAsset      = 0x00000400L, // Исключить основные средства
		fIncludeIntr       = 0x00000800L, // Рассматривать порожденные лоты. Действует при (!LotPeriod.IsZero() || SupplID)
		fShowBarcode       = 0x00001000L, // Показывать штрихкоды в броузере
		fShowCargo         = 0x00002000L, // Показывать товары с грузовыми параметрами
		fHidePassive       = 0x00004000L, // Не показывать пассивные товары (отменяет fPassiveOnly)
		fPassiveOnly       = 0x00008000L, // Показывать только пассивные товары (отменяет fHidePassive)
		fGenGoodsOnly      = 0x00010000L, // Показывать только обобщенные товары
		fWOTaxGdsOnly      = 0x00020000L, // Показывать только товары с ценой без налогов. @#{fPassiveOnly^fGenGoodsOnly^fWOTaxGdsOnly}
		fNoZeroRestOnLotPeriod = 0x00040000L, // Если товар не удовлетворяет ограничению LotPeriod, но есть на остатке, то попадает в выборку
		fNoDisOnly         = 0x00080000L, // Показывать только товары с признаком без скидки
		fShowStrucType     = 0x00100000L, // Показывать признак наличия структуры
		fNotUseViewOptions = 0x00200000L, // Не показывать в товарном фильтре кнопку опции просмотра
		fShowGoodsWOStruc  = 0x00400000L, // Показывать товары без структуры
		fWoTaxGrp          = 0x00800000L, // Показывать только товары без налоговой группы
		fRestrictByMatrix  = 0x01000000L, // Ограничивать выборку товарной матрицей. Если LocID == 0, то ограничивается матрицей для всех складов
		fShowArCode        = 0x02000000L, // Показывать артикулы товаров
		fShowOwnArCode     = 0x04000000L, // Показывать собственные артикулы (ArID = 0)
		fShowWoArCode      = 0x08000000L, // Показывать товары без артикулов
		fOutOfMatrix       = 0x10000000L, // Показывать только те товары, которые НЕ принадлежат матрице.
			// Этот флаг имеет более низкий приоритет, чем fRestrictByMatrix. То есть, если установлены оба
			// флага (что программа не должна допускать), то применяется fRestrictByMatrix
		fActualOnly        = 0x20000000L, // Показывать только те товары, по которым есть не нулевые остатки по одному из складов LocList
		fHasImages         = 0x40000000L, // Только с картинками
		fUseIndepWtOnly    = 0x80000000L  // Только с флагом GF_USEINDEPWT
	};
	enum {
		f2ShowWhPlace      = 0x00000001L, // @v11.5.8 Показывать место хранения // 
		f2SoonExpiredOnly  = 0x00000002L, // @v11.6.2 Показывать только те позиции, для которых в ближайшее время закончится срок годности (или уже закончился)
	};
	enum { // @persistent
		bcrLength = 1,
		bcrPrefix
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке SrchStr_
	//
	enum { // @persistent
		extssNameText    = 1,
		extssBarcodeText = 2
	};
	explicit GoodsFilt(PPID group = 0);
	GoodsFilt(const GoodsFilt &);
	GoodsFilt & FASTCALL operator = (const GoodsFilt & s);
	int    Setup();
	virtual bool IsEmpty() const;
	//
	// Descr: Преобразует строку, в которой перечислены через запятую длины
	//   штрихкодов в список PPIDArray.
	//   Результирующий список отсортирован по возрастанию и в нем отсутствуют
	//   дублирования.
	// Returns:
	//   <0 - Строка BarcodeLen пустая.
	//   >0 - Спецификация фильтра предполагает фильтрацию по длинам штрихкодов
	//
	int    FASTCALL GetBarcodeLenList(PPIDArray & rList) const;
	int    FASTCALL GetBarcodePrefixList(StringSet & rSet) const;
	int    GetExtssData(int fldID, SString & rBuf) const;
	int    PutExtssData(int fldID, const char * pBuf);
	//
	// Descr: Определяет результирующий список брендов по спискам BrandList и BrandOwnerList
	//
	int    CalcResultBrandList(ObjIdListFilt & rResult) const;
	//
	// Descr: Возвращает результирующий список брендов (по спискам BrandList и BrandOwnerList),
	//   сформированный функцией GoodsFilt::Setup
	//
	const  ObjIdListFilt & GetResultBrandList() const;
	//
	// Descr: Если фильтр ограничивает выборку только теми товарами,
	//   для которых есть коды по статье CodeArID, то функция возвращает !0,
	//   в противном случае - 0.
	//
	int    IsRestrictedByAr() const;
	int    ReadFromProp(PPID obj, PPID id, PPID prop, PPID propBefore8604);
	int    WriteToProp(PPID obj, PPID id, PPID prop, PPID propBefore8604);

	char   ReserveStart[8];    // @anchor Проецируется на __GoodsFilt::Reserve // @v11.5.8 [4]-->[28] // @v11.6.2 [28]-->[26] // @v11.8.1 [26]-->[8]
	IntRange IdRange;          // @v11.8.1 @construction Диапазон идентификаторов товаров
	IntRange GrpCountRange;    // @v11.8.1 @construction Диапазон мощностей родительских групп (по-человечески: диапазон, в который попадает количество товаров, 
		// находящихся в родительской группе). Критерий нужен для извлечения товаров, принадлежащих группам, в которых либо очень мало, либо очень много товаров
		// для наведения порядка в справочнике.
	uint16 Reserve;            // @v11.8.1 @alignment  
	int16  AheadExpiryDays;    // @v11.6.2 Минимальное количество дней до истечения срока, при котором товарная позиция попадает в риск-категорию (see f2SoonExpiredOnly)
	PPID   GoodsLocAssocID;    // @v11.5.8 Если установлен флаг Flags2 & f2ShowWhPlace то в этом поле может быть определен id именованной ассоциации.
	PPID   UhttStoreID;        // Магазин Universe-HTT в контексте которого извлекаются товары.
	PPID   RestrictQuotKindID; // Вид ограничивающей котировки (извлекаются только те товары, которые имеют котировку этого вида)
	int32  InitOrder;          // PPViewGoods::IterOrder::OrdByXXX
	PPID   MtxLocID;           // Если (Flags & (fRestrictByMatrix|fOutOfMatrix)), то данное поле
		// определяет склад, по которому проверяется принадлежность (не принадлежность) матрице.
		// Если (Flags & (fRestrictByMatrix|fOutOfMatrix)) и MtxLocID == 0, то принадлежность (не принадлежность) матрице
		// проверяется относительно склада LocID_.
	PPID   BrandOwnerID;       //
	PPID   CodeArID;           // Статья, по которой фильтровать коды, связанные со статьями
	PPID   GrpID;              //
	PPID   ManufID;            //
	PPID   ManufCountryID;     //
	PPID   UnitID;             //
	PPID   PhUnitID;           //
	PPID   SupplID;            //
	PPID   GoodsTypeID;        //
	PPID   TaxGrpID;           //
	DateRange LotPeriod;       //
	long   Flags;              //
	long   Flags2;             // @v11.5.8
	long   VatRate;            // Ставка НДС, которой облагается товар. Ненулевое значение этого поля исключает фильтрацию по полю TaxGrpID.
	LDATE  VatDate;            // Дата, на которую следует брать ставку НДС. Используется только если VatRate != 0
	PPID   GoodsStrucID;       // Товарная структура, на которую ссылаются товары
	PPID   LocID_Obsolete;     //
	PPID   BrandID_Obsolete;   // Товарный брэнд
	ClsdGoodsFilt Ep;          // @anchor
	//
	// @v8.2.12
	//  Начиная с версии 8.2.12 внутри SrchStr_ могут содержаться одновременно строка для поиска по наименованию и
	//  строка для поиска по штрихкоду. Соответственно, прямо это поле использовать не следует - необходимо применять функции
	//  GetExtssData и PutExtssData с указанием типов полей, определенных через enum GoodsFilt::extssXXX
	//  Для обратной совместимости, если внутри строки нет спец тегов <>, то вся строка трактуется как критерий поиска по наименованию.
	//
	SString SrchStr_;          // @anchor Строка, содержащаяся в имени.
	//
	SString BarcodeLen;        // Список длин штрихкодов (через запятую)
	ObjIdListFilt GrpIDList;   // Список групп
	ObjIdListFilt ManufList;   // Helper (not filter) field
	ObjIdListFilt LocList;     //
	ObjIdListFilt BrandList;   //
	ObjIdListFilt BrandOwnerList; //
	SysJournalFilt * P_SjF;    //
	TagFilt * P_TagF;          // Фильтр по тегам
private:
	int    InitInstance();
	virtual int Describe(long flags, SString & rBuf) const;
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	char * WriteObjIdListFilt(char * p, const ObjIdListFilt & rList) const;
	const  void * ReadObjIdListFilt(const /*char*/void * p, ObjIdListFilt & rList);
	int    ReadFromProp_Before8604(PPID obj, PPID id, PPID prop);

	ObjIdListFilt ResultBrandList; // @transient @*GoodsFilt::Setup Результирующий список брэндов, агрегирующий BrandList и BrandOwnerList
};
//
// Descr: Информация о товаре, специфичная для розничной торговли.
//   Используется также для печати этикеток на принтере штрихкодов.
//
struct RetailGoodsInfo {   // @transient
	RetailGoodsInfo();
	void   Init();

	enum {
		fDisabledQuot    = 0x0001, // Котировка QuotKindUsedForPrice является блокирующей - продажа товара запрещена.
		fDisabledExtQuot = 0x0002, // Котировка
		//
		fNoDiscount      = 0x0004, // OUT (устанавливается в результате вычислений) - на товар не распространяется скидка
		fEgais           = 0x0008, // @v11.5.0 Товар является алкогольным, попадающим под маркировку егаис
		fDontShowRest    = 0x0010  // @11.6.4 Специальный флаг, используемые при экспорте данных для индикации того, что блокировать 
			// отображение остатков для товарной позиции
	};
	PPID   ID;             // ->Goods.ID
	char   Name[128];      // =Goods(ID).Name
	char   BarCode[24];    //
	char   UnitName[48];   //
	char   Manuf[128];     // @v11.4.5 [48]-->[128]
	char   ManufCountry[48];
	PPID   LocID;          // Склад, для которого рассчитана цена
	PPID   QuotKindUsedForPrice; // Вид котировки, использованной для получения цены Price.
		// Данное поле гарантированно имеет смысл только после вызова PPObjGoods::GetRetailGoodsInfo
	PPID   QuotKindUsedForExtPrice; // Вид котировки из блока RetailPriceExtractor::ExtQuotBlock, примененный для формиования ExtPrice.
	LDATE  Expiry;         //
	double OuterPrice;     // @IN Цена, установленная вызывающей функцией дабы использовать ее (при установленном флаге rgifUseOuterPrice)
	double Cost;           // Цена поступления //
	double Price;          // Цена реализации
	double ExtPrice;       // Цена по дополнительной котировке
	double RevalPrice;     // Цена реализации до переоценки (RevalPrice != Price только если структура
		// сформирована по строке документа переоценки).
	double LineCost;       // Цена поступления из строки документа (по контексту)
	double LinePrice;      // Цена реализации из строки документа (по контексту)
	double PhUPerU;        // Соотношение физические единицы/торговые единицы
	//
	// Информация о партии
	//
	PPID   LotID;
	LDATE  BillDate;       // Дата прихода (для техн сессий - дата производства)
	char   BillCode[48];   // Номер документа прихода (для техн сессий - номер сессии) // @v11.1.12 [24]--[48]
	char   Serial[32];     // Серийный номер лота
	int16  LabelCount;     // Количество этикеток, которое требуется напечатать. [1..999], default=1
	int16  Reserve;        // @alignment
	int    ChZnMarkCat;    // @v11.5.0 GTCHZNPT_XXX Категория маркировки честный знак
	LDATETIME ManufDtm;    // Дата/время производства
	long   Flags;          //
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double UnitPerPack;    // Емкость упаковки
	double Brutto;         // Масса брутто для количества Qtty
	//
	char   ArName[48];     // Наименование контрагента техн сессии, по которой сформирована структура
	char   Ar2Name[48];    // Наименование дополнительной статьи техн сессии, по которой сформирована структура
	char   PrcName[48];    // Наименование процессора техн сессии, по которой сформирована структура
};
//
// @ModuleDecl(RetailPriceExtractor)
//
#define RTLPF_PRICEBYQUOT     0x0001L // Соответствует PPEquipConfig::fUseQuotAsPrice
#define RTLPF_USEQUOTWTIME    0x0002L // Использовать котировки с установленным временем действия //
#define RTLPF_GETCURPRICE     0x0004L // Выдавать текущую цену товара (а не по розничным котировкам)
#define RTLPF_USEQKCACHE      0x0008L // Применять кэширование при извлечении списка розничных котировок
#define RTLPF_USEMINEXTQVAL   0x0010L // Если задан RetailPriceExtractor::ExtQuotBlock,
	// то из указанных там котировок применять минимально возможное значение.
#define RTLPF_USEOUTERPRICE   0x0020L // Использовать цену RetailExtrItem::OuterPrice, заданную извне
#define RTLPF_IGNCONDQUOTS    0x0040L // Игнорировать условные котировки (для которых заданы условия применимости).
	// Опция важна при экспорте данных, когда получатель самостоятельно определяет применимость котировок.

struct RetailExtrItem { // @transient
	RetailExtrItem();

	enum {
		fDisabledQuot    = 0x0001, // Заблокированная котировка. Этот флаг означает, что продажа товара запрещена
		fDisabledExtQuot = 0x0002, // Заблокированная дополнительная котировка. Этот флаг означает, что продажа товара запрещена
	};
	double Cost;                 // Цена поступления (по последнему лоту) Если товар нелимитируемый, то 0.
	double Price;                // Цена реализации (возможно, по котировке, обусловленной датой или временем)
	double BasePrice;            // Цена реализации без учета розничных котировок.
	double ExtPrice;             // Цена по котировки RetailPriceExtractor::ExtQuotKindID
	LDATE  CurLotDate;           //
	LDATE  Expiry;               //
	LDATETIME ManufDtm;          // Дата/время производства товара (извлекается из лота по зарезервированному т'гу PPTAG_LOT_MANUFTIME)
	PPID   QuotKindUsedForPrice; // Вид котировки, использованный для формирования значения Price.
		// Если цена сформирована по последнему лоту, либо вообще не определена, то 0.
	PPID   QuotKindUsedForExtPrice; // Вид котировки из блока RetailPriceExtractor::ExtQuotBlock, примененный для формиования ExtPrice.
	long   Flags;
	double OuterPrice;    // IN Цена, заданная вызывающей функцией. Имеет силу если RetailPriceExtractor::GetPrice
		// вызывается с флагом RTLPF_USEOUTERPRICE
	RealRange AllowedPriceR; // OUT Допустимый диапазон цен, рассчитанный на основании ограничений товарных величин.
	RAssocArray QuotList; // IN Список дополнительных котировок.
		// Вызывающая функция заполняет поля Key идентификаторами видов котировок.
		// AsyncCashGoodsIterator инициализирует поля Val массива соответствующими эффективными значениями котировок.
};

class RetailPriceExtractor {
public:
	struct ExtQuotBlock {
		ExtQuotBlock(PPID quotKindID);
		ExtQuotBlock(const PPSCardSerPacket & rScsPack);

		PPIDArray QkList;
	};
	RetailPriceExtractor();
	RetailPriceExtractor(PPID locID, const ExtQuotBlock * pEqBlk, PPID arID, LDATETIME actualDtm, long flags);
	~RetailPriceExtractor();
	int    Init(PPID locID, const ExtQuotBlock * pEqBlk, PPID arID, LDATETIME actualDtm, long flags);
	//
	// Descr: Переопределяет склад объекта. Главная цель этой функции - избежать
	//   полной повторной инициализации (довольно дорогой) объекта если изменился только склад.
	//
	void   SetLocation(PPID locID);
	//
	// Descr: возвращает цену товара по следующим правилам:
	//   1. Если есть приоритетная котировка (ExtQuotKindID), то цена возвращается //
	//      в RetailExtrItem::ExtPrice, для других случаев в RetailExtrItem::Price.
	//   2. Если есть розничные котировки (акции), действующие на указанную дату,
	//      выбирается котировка с наивысшим рангом. При одинаковых рангах - первая найденная.
	//      Базовая котировка является розничной, если установлен флаг PPEquipConfig::fUseQuotAsPrice.
	//   3. При отсутствии котировок цена определяется по текущему лоту.
	// ARG(goodsID     IN):
	// ARG(forceBaseLotID IN): Если !0, то для определения базовых учетных цен функция //
	//   пытается использовать лот, указанный этим идентификатором. Его значение передается //
	//   в функцию ::GetCurGoodsPrice.
	// ARG(pItem   IN/OUT): @{vptr}
	//
	int    GetPrice(PPID goodsID, PPID forceBaseLotID, double qtty, RetailExtrItem * pItem);
private:
	PPID   LocID;
	PPID   ArID;          // Статья, в привязке к которой извлекаются котировки
	ExtQuotBlock EqBlk;
	long   Flags;
	PPIDArray  RetailQuotList;
	PPObjGoods * P_GObj;
};
//
// Структуры, необходимые для агрегированной подстановки свойств товаров
// вместо самих товаров в отчетности
//
struct GoodsSubstItem { // @flat
	GoodsSubstItem();

	long   ID;
	long   ClsID;
	long   Par1;
	union {
		struct {
			long   Par2;
			long   Par3;
		} L;
		double RVal;
	} U;
	union {
		uint   StrP;          // Позиция строки в GoodsSubstList::StrPool
		const  char * P_Text; // При добавлении элемента - указатель на текст, который сохраняется в GoodsSubstList::StrPool в позиции StrP.
	};
};

class GoodsSubstList : public SStrGroup {
public:
	struct AssocItem {
		PPID   SrcGoodsID;
		PPID   LocID;
		PPID   LotID;
		LDATE  Dt;
	};
	GoodsSubstList(int saveAssoc = 0);
	~GoodsSubstList();
	//
	// Descr: Инициализирует объект:
	//   - очищает все списки,
	//   - устанавливает переменную SaveAssoc
	//   - если pSrc != 0, то копирует pSrc->P_List -> P_List
	//
	void   Init(int saveAssoc, const GoodsSubstList * pSrc);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    AddItem(const GoodsSubstItem & rItem, const AssocItem & rAssocItem, PPID * pID);
	int    GetItem(PPID id, GoodsSubstItem * pItem) const;
	void   Clear();
	long   GetAssocCount(PPID substID) const;
	//
	// Descr: Заполняет список идентификаторов подстановок.
	//   Не очищает массив pList до начала цикла заполнения.
	//   Все элементы добавляются методом addUnique, по-этому, дублирования не возникает.
	//
	int    GetSubstList(PPIDArray & rList) const;
	//
	// Descr: Заполняет список идентификаторов товаров, соответствующих подстановке substID
	//
	int    GetGoodsBySubstID(PPID substID, PPIDArray * pGoodsList) const;
	int    GetGoodsBySubstID(PPID substID, ObjIdListFilt * pGoodsList) const;
	int    GetSubstAssocList(PPID substID, TSVector <AssocItem> * pList) const;
	int    AddToAssoc(PPID substID, const AssocItem & rAssocItem);
	PPID   SubstAlcoCategory(PPID goodsID);
	int    GetAlcoCategoryText(PPID substID, SString & rBuf) const;
	PPID   SubstLocAssoc(PPID goodsID);
	int    GetLocAssocText(PPID substID, SString & rBuf) const;
	const char * FASTCALL GetTextPtr(uint pos) const;

	int    SaveAssoc;
private:
	TSVector <GoodsSubstItem> List;
	struct InnerAssocItem {
		InnerAssocItem(PPID substID);
		uint   SearchAssoc(const GoodsSubstList::AssocItem & rPattern) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		PPID   SubstID;
		TSVector <AssocItem> List;
	};
	class AssocCollection : public TSCollection <InnerAssocItem> {
	public:
		AssocCollection();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	};
	AssocCollection AsscList;
	PrcssrAlcReport * P_Arp;
	GoodsToObjAssoc * P_Goa;
};
//
// Некоторые существенные признаки группы товаров, которые иногда
// полезны сами по себе (бывает эффективнее однажды извлечь и хранить
// только эти признаки, чем каждый раз доставать целую запись).
//
enum GoodsGroupTag {
	ggtagZero      = 0,
	ggtagUndefined = 0x8000, // Признаки не определены (необходимо извлечь)
	ggtagAlternate = 0x0001, // Альтернативная группа
	ggtagParent    = 0x0002, // Группа имеет подгруппы
	ggtagOdd       = 0x0004, // Группа имеет тип, отличный от стандартного
	ggtagTemp      = 0x0008  // Временная альтернативная группа
};
//
// Флаги товаров
//
#define GF_INTVAL            0x00000001L // @transient Целочисленная единица измерения //
#define GF_DERIVED_HASIMAGES 0x00000001L // @v12.0.4 Это флаг используется объектами данных, отличными от PPOBJ_GOODS и хранящимися в той же таблице goods2.
	// Значение 0x01 нельзя так просто поменять, поскольку базы данных уже используют такое значение. До версии 12.0.4 применялась мнемоника BRNDF_HASIMAGES__ (теперь она удалена)
#define GF_UNLIM             0x00000002L // @transient Неограниченный ресурс
#define GF_ODD               0x00000004L // @transient Нестандартный товар
#define GF_AUTOCOMPL         0x00000008L // @transient Автокомплект
#define GF_GENERIC           0x00000010L // Обобщенный товар
//
#define GF_ABSEXCISE         0x00000020L // Obsolete Акциз в денежных единицах (не процентах)
#define GF_ZEXCISE           0x00000040L // Obsolete Нулевой акциз (акциз не наследуется от группы)
#define GF_ZVAT              0x00000080L // Obsolete Нулевой НДС (НДС не наследуется от группы)
//
#define GF_TAXFACTOR         0x00000020L // ExtRec содержит ненулевой налоговый фактор
#define GF_PRICEWOTAXES      0x00000040L // UC Цена реализации товара указана без всех операционных налогов
#define GF_EXTPROP           0x00000080L // Товар имеет запись расширенных свойств (PPGoodsPacket::ExtString)
#define GF_ALTGROUP          0x00000100L // Альтернативная группа
#define GF_FOLDER            0x00000200L // Группа верхнего уровня //
#define GF_PASSIV            0x00000400L // Пассивный товар
#define GF_NODISCOUNT        0x00000800L // На товар не распространяется общая скидка
#define GF_EXCLALTFOLD       0x00001000L // Папка, объединяющая непересекающиеся альтернативные группы
#define GF_UNIQPCKGCODE      0x00002000L // Уникальный код пакета
#define GF_DFLTPCKGTYPE      0x00004000L // Тип пакета по умолчанию
#define GF_PCKG_AROWS        0x00008000L //
#define GF_PCKG_ANEWROW      0x00010000L //
#define GF_ASSETS            0x00020000L // @transient Основные фонды. Проекция флага GTF_ASSETS типа, которому принадлежит товар
#define GF_WROFFBYPRICE      0x00040000L // Списывать основное средство исходя из остаточной стоимости
#define GF_TRANSGLED         0x00080000L // @transient Признак передачи в пакете структуры GoodsLotExtData
#define GF_VOLUMEVAL         0x00100000L // Объем упаковки поставки задается одним значением
#define GF_TRANSQUOT         0x00200000L // @transient Пакет передачи предназначен для трансмиссии котировок
	// Сами товары не меняются. Не удаляются остутствующие в пакете, но присутствующие в базе котировки.
#define GF_TEMPALTGRP_       0x00400000L //
#define GF_USEINDEPWT        0x00800000L // Операции по товару ведуться параллельно в торговых и физических единицах
#define GF_DYNAMIC           0x01000000L // Динамическая альтернативная группа
#define GF_HASIMAGES         0x02000000L // К товару присоединены картинки
#define GF_ABBREQNAME        0x04000000L // @transient Используется у элементов кэша для информации о том, что
	// сокращенное наименование эквивалентно полному.
#define GF_EXCLVAT           0x08000000L // @transient Наследуется от типа товара (GTF_EXCLVAT) при извлечении через кэш
#define GF_AUTOCREATE        0x10000000L // Признак того, что товар (группа) создан автоматически (например, при импорте внешнего документа, содержащего этот товар)
#define GF_UNCLASSF          0x20000000L // Признак группы, бренда или иного контейнера, содержащего неклассифицированные товары.
	// Используется для автоматической классификации.
#define GF_WANTVETISCERT     0x40000000L // Требует сертификата на приход и отгрузку

#define GF_TEMPALTGROUP      (GF_ALTGROUP|GF_TEMPALTGRP_) // Временная альтернативная группа
#define GF_DB_FLAGS_GROUP    (GF_ALTGROUP|GF_FOLDER|GF_EXCLALTFOLD)
#define GF_DB_FLAGS_GOODS    (GF_GENERIC|GF_TAXFACTOR|GF_PRICEWOTAXES|GF_EXTPROP|GF_PASSIV|GF_NODISCOUNT|\
	GF_WROFFBYPRICE|GF_VOLUMEVAL|GF_USEINDEPWT|GF_HASIMAGES|GF_WANTVETISCERT)
#define GF_DB_FLAGS_PCKGTYPE (GF_UNIQPCKGCODE|GF_DFLTPCKGTYPE|GF_PCKG_AROWS|GF_PCKG_ANEWROW)
#define GF_DYNAMICALTGRP     (GF_ALTGROUP|GF_DYNAMIC) // Динамическая альтернативная группа
#define GF_DYNAMICTEMPALTGRP (GF_ALTGROUP|GF_DYNAMIC|GF_TEMPALTGRP_)
//
// Специфические флаги прав доступа по товарам
//
#define GOODSRT_UPDQUOTS  0x0100 // Право на массовое изменение котировок (cmUpdateQuots)
#define GOODSRT_UPDTAXGRP 0x0200 // Право на изменение налоговой группы товара
#define GOODSRT_UNITE     0x0400 // Право на объединение товаров
#define GOODSRT_MULTUPD   0x0800 // Право на массовое изменение (флагов, наименований)
#define GOODSRT_UPDIMAGE  0x1000 // Право на изменение картинки присоединенной к товару
#define GOODSRT_UPDGTYPE  0x2000 // Право на изменение принадлежности товара (группы) типу
#define GOODSRT_PRIORCODE 0x4000 // Право на изменение приоритетного штрихкода. Если этого
	// права нет, то пользователь не может изменить значение приоритетного кода равно как и установить/снять
	// признак приоритетности.
//
// Виды товарных пакетов
//
enum GoodsPacketKind {
	gpkndUndef = 0, // Неопределенный (необходимо инициализировать)
	gpkndGoods = 1, // @gpkind_goods         Товар
	gpkndOrdinaryGroup = 2, // @gpkind_ordinarygroup Обыкновенная группа
	gpkndFolderGroup   = 3, // @gpkind_foldergroup   Папка (содержит подгруппы)
	gpkndAltGroup      = 4, // @gpkind_altgroup      Альтернативная группа
	gpkndPckgType      = 5  // @v3.3.4 @UnderConstruction
};
//
// Коды дополнительных текстовых полей товара
//
#define GDSEXSTR_STORAGE   1 // (A) Условия хранения //
#define GDSEXSTR_STANDARD  2 // (B) Стандарт
#define GDSEXSTR_LABELNAME 3 // Наименование для печати ценников
#define GDSEXSTR_INGRED    4 // (C) Ингредиенты товара
#define GDSEXSTR_ENERGY    5 // (D) Энергетическая ценность
#define GDSEXSTR_USAGE     6 // (E) Способ использования (приготовления)
#define GDSEXSTR_A         1 // (A) Синоним
#define GDSEXSTR_B         2 // (B) Синоним
#define GDSEXSTR_C         4 // (C) Синоним
#define GDSEXSTR_D         5 // (D) Синоним
#define GDSEXSTR_E         6 // (E) Синоним
#define GDSEXSTR_OKOF     10 // Код ОКОФ основного средства
#define GDSEXSTR_INFOSYMB 11 // Специальный символ, идентифицирующий дополнительную информацию о товаре, отображаемую в диалоге товара
//
// Descr: Специализированная структура для переноса параметров лотов по товару из
//   одного раздела БД в другой
//
struct GoodsLotExtData {
	PPID   QCertID;
	LDATE  Expiry;
	double UnitPerPack;
	char   Serial[32];
	char   CLB[32];
};

class PPGoodsPacket {
public:
	PPGoodsPacket();
	~PPGoodsPacket();
	PPGoodsPacket & Z();
	PPGoodsPacket & FASTCALL operator = (const PPGoodsPacket &);
	int    AddCode(const char *, long codeType, double uPerP);
	int    FASTCALL GetGroupCode(SString & rBuf) const;
	int    SetGroupCode(const char *);
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const SString & rBuf/*const char * pBuf*/);
	bool   IsExtRecEmpty() const;
	GoodsPacketKind GetPacketKind() const;
	int    GetArCode(PPID arID, SString & rCode) const;
	static int ValidateAddedMsgSign(const char * pSign, size_t signBufSize);
	//
	// Descr: Флаги функции PPGoodsPacket::PrepareAddedMsgStrings()
	//
	enum {
		pamsfStrictOrder = 0x0001 // Формировать список строк в строгом соответствии с
			// порядком, определенным pSign. Фактически, это означает, что пустые строки
			// так же включаются в список.
	};
	//
	// Descr: Формирует список дополнительных строк по товару в соответствии с правилом,
	//   определенным строкой pSign. Строка правила pSign может содержать буквы A..E, M (дата производства) и
	//   скобки (для объединения нескольких доп строк в одну). Например "ABC", "D(AB)E"
	//
	int    PrepareAddedMsgStrings(const char * pSign, long flags, const LDATETIME * pManufDtm, StringSet & rSet);

	Goods2Tbl::Rec   Rec;     //
	GoodsExtTbl::Rec ExtRec;  //
	GoodsStockExt    Stock;   //
	BarcodeArray     Codes;   // Список штрихкодов товара
	ArGoodsCodeArray ArCodes; // Список кодов, сопоставленных с контрагентами
	PPGoodsStruc  GS;         // @todo Если структура не собственная (GSF_NAMED), то при изменении требует блокировки.
	enum {
		ufDontChgTaxGrp  = 0x0001, // Функция PPObjGoods::PutPacket не должна изменять налоговую группу товара или группы товаров.
		ufChgNamedStruc  = 0x0002, // Функция PPObjGoods::PutPacket должна изменить именованную структуру товара
		ufDontChgImgFlag = 0x0004, // Функция PPObjGoods::PutPacket не должна изменять флаг GF_HASIMAGES
		ufDontChgArCodes = 0x0008, // Функция PPObjGoods::PutPacket не должна изменять список кодов по статьям
		ufDontChgPltList = 0x0010, // Функция PPObjGoods::PutPacket не должна изменять параметры размещения на паллете
	};
	long   UpdFlags;          // @transient Флаги, определяющие правила изменения некоторых полей
	long   ClsDimZeroFlags;   // @transient Флаги обнуляние числовых классификаторов товаров. Используется в
		// специальном случае массового изменения атрибутов товаров (функция PPViewGoods::RemoveAll())
	SString ExtString;        // Дополнительные текстовые поля товара
	SString ExTitles;         // Список наименований дополнительных текстовых полей товара. Используется только для обыкновенных групп.
	PPQuotArray * P_Quots;    // Список котировок товара. Особенность этого поля в том, что функция //
		// PPObjGoods::GetPacket заполняет его, но функция PPObjGoods::PutPacket не сохраняет список в БД.
	GoodsLotExtData * P_Gled; // Только для переноса параметров лотов из одного раздела в другой
	GoodsFilt * P_Filt;       // Используется в пакете альтернативной группы
	ObjLinkFiles LinkFiles;   // @transient
	ObjTagList   TagL;        // Список тегов
	ObjIdListFilt GenericList; // Список товаров, ассоциированный с данным обобщенным товаром.
		// Используется только для передачи содержимого обобщенного товара между разделами БД.
		// Функция PPObjGoods::GetPacket не загружает данный список.
};
//
// Descr: Структура, передаваемая в качестве параметра (PPFilt::Ptr)
//   при печати товарных этикеток (PPALDD_GoodsLabel).
//
struct GoodsLabelAlddParam {
	PPID   GoodsID;
	PPID   LocID;
	int    NumCopies;
};

struct PPGoodsReplaceNameParam {
	PPGoodsReplaceNameParam();

	enum {
		fAbbr           = 0x0001,
		fNameAndAbbr    = 0x0002,
		fDoReplace      = 0x0004,
		fRestoreLastHistoryName = 0x0008
	};
	SString SrchPattern;
	SString RplcPattern;
	PPID   BrandID;        // Брэнд, который следует установить в найденных товарах
	PPID   GoodsGrpID;     // Товарная группа, в которую следует переместить найденные товары
	PPID   ManufID;        // Производитель, которого следует установить в найденных товарах
	long   Flags;
};

struct PPSupplDeal {
	int    CheckCost(double c) const;
	SString & FASTCALL Format(SString &) const;

	double Cost;       // Контрактная цена
	double UpDev;      // Верхнее отклонение (%)
	double DnDev;      // Нижнее отклонение (%)
	int    IsDisabled; // Блокированная комбинация (ввод строки в документ невозможен) //
};
//
// Descr: Структура, используемая для поиска товара по коду функцией PPObjGoods::SearchByCodeExt()
//
struct GoodsCodeSrchBlock {
	GoodsCodeSrchBlock();
	~GoodsCodeSrchBlock();

	enum {
		fAdoptSearch = 0x0001, // IN
		fWeightCode  = 0x0002, // OUT Весовой код
		fArCode      = 0x0004, // OUT Артикул
		fOwnArCode   = 0x0008, // OUT Собственный артикул
		fGoodsId     = 0x0010, // OUT ИД товара
		fList        = 0x0020, // OUT Список штрихкодов по шаблону
		fUse2dTempl  = 0x0040, // IN  Искать по шаблону 2-мерного штрихкода
		fBc2d        = 0x0080, // OUT Товар найден по шаблону 2d-кода
		fChZnCode    = 0x0100, // OUT Товар найден по коду "честный знак"
		fMarkedCode  = 0x0200  // OUT Идентифицированный код имеет признак "маркируемый" (BARCODE_TYPE_MARKED)
	};
	char   Code[256];      // IN CONST
	char   RetCode[32];    // OUT
	char   ChZnCode[32];   // OUT
	char   ChZnGtin[32];   // OUT
	char   ChZnSerial[32]; // OUT
	PPID   ArID;           // IN CONST
	long   Flags;          // IN/OUT
	PPID   GoodsID;        // OUT
	PPID   ScaleID;        // OUT
	double Qtty;           // OUT
	BarcodeArray * P_List; // OUT
	Goods2Tbl::Rec Rec;    // OUT
};
//
// Флаги реализации функции PPObjGoods::CheckForFilt
//
#define GOCFIF_GROUP  0x0001 // Не проверять на принадлежность группам
#define GOCFIF_BCLEN  0x0002 // Не проверять длины штрихкодов
#define GOCFIF_ARCODE 0x0004 // Не проверять наличие кода по статье GoodsFilt::CodeArID
#define GOCFIF_SYSJ   0x0008 // Не проверять условия фильтра по системному журналу
#define GOCFIF_TAG    0x0010 // Не проверять на соответствие фильтру по т'гам
//
// Флаг подстановки товара. Если идент товара содержит этот флаг, то этот идент в действительности
// ссылается на какой-то иной объект данных, определенный типом подстановки.
//
#define GOODSSUBSTMASK  0x40000000L
//
// Флаг динамического обобщения товаров. Если согласно маске дин обобщения существует
// набор классицированных товаров, подходящих под это обобщение, но при этом не существует
// реального обобщенного товара, соответствующего такой маске, то создается искусственный
// идентификатор равный одному из товаров обобщения с наложением маски DYNGENGOODSMASK.
//
#define DYNGENGOODSMASK 0x20000000L
//
// Descr: Специализированная структура для формирования данных DL600 UhttGoodsArCode
//
struct UhttGoodsArCodeIdent {
	PPID   GoodsID;
	PPID   ArID;
	char   Name[128];
	char   Code[32];
};

class PPObjGoods : public PPObject {
public:
	//
	// Descr; Результаты диагностики корректности розничного штрихкода (EAN13, EAN8, UPCA, UPCE).
	//
	enum {
		cddOk = 0,                  //
		cddEmpty = 1,               // Пустой код
		cddNonDigit,                // Код содержит нецифровые символы
		cddInvCheckDigEan13,        // Неверная контрольная цифра EAN13
		cddInvCheckDigUpca,         // Неверная контрольная цифра UPCA
		cddInvCheckDigEan8,         // Неверная контрольная цифра EAN8
		cddInvCheckDigUpce,         // Неверная контрольная цифра UPCE
		cddExtraDigitEan13,         // Лишняя цифра в конце EAN13
		cddExtraDigitEan8,          // Лишняя цифра в конце EAN8
		cddEan14,                   // EAN14
		cddUnknownFormat,           // Неизвестный формат
		cddUpcaAsEan13,             // Код UPCA в формате EAN13
		cdd_ExtraDigitUpca,         // Возможно, лишняя цифра в конце UPCA
		cdd_UpcaWoCheckDig,         // Возможно, UPCA без контрольной цифры
		cdd_Ean13WoCheckDig,        // Возможно, EAN13 без контрольной цифры
		cdd_Ean8WoCheckDig,         // Возможно, EAN8 без контрольной цифры
		cdd_UpcaWoLead0,            // UPCA без лидирующего нуля //
		cdd_UpcaWoCheckDigAndLead0, // Возможно, UPCA без лидирующего нуля и без контрольной цифры
		cdd_UpceWoLead0,            // Возможно, UPCE без лидирующего нуля //
		cdd_UpceWoCheckDig,         // Возможно, UPCE без контрольной цифры
		cdd_UpceWoCheckDigAndLead0, // Возможно, UPCE без лидирующего нуля и без контрольной цифры
		cddEan8AsEan13,             // Код EAN8 в формате EAN13
		cddExtraZeroEan8,           // Код EAN8 с лишним ведущим нулем
		cddExtraZeroUpce,           // Код UPCE с лишним ведущим нулем
		cddFreePrefixEan13,         // Код EAN13 со свободным префиксом (2)
		cddGuaPrefix                // Код содержит один из допустимых префиксов, ассоциированных с текущей глобальной учетной записью
	};

	static GoodsPacketKind FASTCALL GetRecKind(const Goods2Tbl::Rec * pRec);
	static int FASTCALL ReadConfig(PPGoodsConfig *);
	static int EditConfig();
	static int FASTCALL ReadGoodsExTitles(PPID grpID, SString & rBuf);
	static int ProcessBomEstimatedValues(); // @v11.7.11

	struct ExtUniteBlock {
		ExtUniteBlock();

		enum {
			fUseSpcFormEgais = 0x0002, // В качестве диалога объединения применять специальную форму,
				// позволяющую фильтровать товары по критериям ЕГАИС.
			fOnce    = 0x0004, // После завершения объединения одной пары товаров возвращать
				// управление вызывающей функции (в противном случае будет предложено повторить процедуру
				// для иной пары товаров).
			fAllToOne        = 0x0008  // Все товары списка DestList объединяются на ResultID
		};
		long   Flags;
		PPID   ResultID; // Товар, который заместил собой все ссылки на DestID
		PPIDArray DestList; // Список товаров, все ссылки на которые перенесены на ResultID (и, возможно, удаленные)
	};

	static int ReplaceGoods(ExtUniteBlock & rEub);
	static int GenerateOwnArCode(SString & rCode, int use_ta);
	static int DiagBarcode(const char * pBarcode, int * pDiag, int * pStd, SString * pNormalizedCode);
	static int GetBarcodeDiagText(int diag, SString & rBuf);
	static int FASTCALL HasUndupNameSuffix(const SString & rBuf, uint * pPos);
	//
	// Descr: Ищет в конце строки rBuf суффикс вида #99, испольуемый для обхода требования уникальности имени записи.
	//   Если находит, то убирает его (и предшествующий пробел).
	//
	static int FASTCALL RemoveUndupNameSuffix(SString & rBuf);
	// non-static
	int    WriteConfig(const PPGoodsConfig * pCfg, const SString * pGoodsExTitles, int use_ta);

	explicit PPObjGoods(void * extraPtr = 0);
	~PPObjGoods();
	virtual int  Search(PPID id, void * b = 0);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	//
	// Методу PPObjGoods::Selector в качестве дополнительного
	// параметра передается ID родительской группы.
	// Если этот параметр меньше нуля, то выбираются только те
	// товары, которые есть в наличии на текущей позиции.
	//
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	const  PPGoodsConfig & GetConfig() const;
	//
	// Результирующие флаги функции IsPacketEq
	//
	enum {
		pefCodeEq       = 0x0001, // Список кодов не изменился //
		pefRecFlagsOnly = 0x0002  // Во всем пакете изменились только флаги
	};
	int    IsPacketEq(const PPGoodsPacket & rS1, const PPGoodsPacket & rS2, long options, long * pResultFlags);
	int    Edit(PPID *, GoodsPacketKind, long parentID, long clsID, const char * bcode);
	int    EditClsdGoods(PPGoodsPacket *, int modifyOnlyExtRec);
	int    EditVad(PPID goodsID);
	int    EditArCode(PPID goodsID, PPID arID, int ownCode);
	//
	// Descr: Если в базе данных существует запись товара с именем, совпадающим с rBuf и
	//   идентификатором, отличным от id, то функция добавляет в конец rBuf символ # с последющим
	//   номером.
	//   При замене наименования функция сначала проверяет наличие аналогичного суффикса в конце
	//   rBuf и, если находит, то убирает его (PPObjGoods::RemoveUndupNameSuffix()).
	//   Кроме того, результируюая длина наименования проверяется на непревышение
	//   sizeof(Goods2Tbl::Rec::Name)-1 (если результат выходит за эту границу, то
	//   обрезаются избыточные символы.
	// Returns:
	//   >0 - функция осуществила замену наименования и поместила результат обратно в rBuf //
	//   <0 - заданное наименование не встречается в базе данных (или принадлежит записе с идентификатором id)
	//
	int    ForceUndupName(PPID id, SString & rBuf);
	int    SearchUhttInteractive(const SString & rName, const SString & rBarcode, UhttGoodsPacket * pResultItem);
	int    ViewUhttGoodsRestList(PPID goodsID);
	int    ViewGoodsRestByLocList(PPID goodsID);
	//
	// Descr: Выводит диалог редактирования версии histID пакета товара.
	//
	int    ViewVersion(PPID histID);
	//
	// Descr: Изменяет некоторые из флагов записи товара с идент goodsID.
	//   Устанавливаемые флаги указываются параметром setF, снимаемые - resetF.
	//   Список изменяемых флагов:
	//   GF_NODISCOUNT
	//   GF_PASSIV
	//   GF_PRICEWOTAXES
	//   GF_HASIMAGES
	//
	int    UpdateFlags(PPID goodsID, long setF, long resetF, int use_ta);
	int    AddBySample(PPID *, PPID sampleID);

	enum {
		selfByName = 0x0001, // В списке показывать наименования //
		selfHidePassive    = 0x0002, // Не показывать пассивные товары
		selfForcePassive   = 0x0004, // Показывать пассивные товары
			// Если !selfHidePassive && !selfForcePassive, то функция выясняет
			// показывать или нет пассивные товары по флагу GCF_DONTSELPASSIVE конфигурации товаров.
			// Если установлены оба флага, то работает так, как будто установлен только selfHidePassive.
		selfUseMatrix      = 0x0008, // Применять товарную матрицу
		selfExtLongAsBrand = 0x0010, // extLong - ид Бренда
		selfHideGeneric    = 0x0020  // Не показывать обобщенные товары
	};
	//
	// Descr: Формирует ListBoxDef посредством выборки товаров (либо других объектов, управляемых
	//   классом PPObjGoods).
	// ARG(pDef     IN): @#{vptr0} Указатель на внешний (требующий изменения) экземпляр ListBoxDef.
	//   Если 0, то функция создает новый экземпляр, если !0, то использует pDef
	// ARG(parentID IN): Ид родительской группы
	// ARG(options  IN): Флаги (PPObjGoods::selfXXX)
	// ARG(extraPtr  IN): Дополнительный параметр конкретизирующй вид объекта данных.
	//   Фактически, применяется только для PPOBJ_TRANSPORT
	// ARG(locID    IN): Ид склада, используемый при выборке только тех товаров, которые
	//   (options & PPObjGoods::selfUseMatrix) или при выборке только тех товаров, которые
	//   есть на текущем остатке.
	//   Если locID == 0, но определнный склад необходим, то полагает locID == LConfig.Location.
	// ARG(mtxLocID IN): Ид склада, используемый для установки ограничения по матрице
	//   (options & PPObjGoods::selfUseMatrix). Если mtxLocID == 0 && (options & PPObjGoods::selfUseMatrix),
	//   то применяется матрица по складу locID.
	//   Если опция PPObjGoods::selfUseMatrix не установлена, то параметр игнорируется.
	//
	ListBoxDef * _Selector2(ListBoxDef * pDef, long parentID, long options, void * extraPtr, PPID locID, PPID mtxLocID);
	StrAssocArray * CreateListByPrice(PPID loc, double price);
	StrAssocArray * CreateListByList(const PPIDArray * pIdList);
	//
	// Descr: Возвращает иерархию товара или группы с идентификатором goodsID.
	//   Иерархия возвращается в виде списка первый элемент которого соответствует самому верхнему уровню иерархии,
	//   которой подчинен элемент goodsID.
	//   Сам элемент goodsID является последним членом списка //
	//
	int    GetHierarchy(PPID grpID, StrAssocArray * pList);
	//
	// Descr: вызывает диалог выбора товара вместо висячего идентификатора rmvdGoodsID.
	//   Перед выводом диалога, если не указан extGoodsID, функция пытается определить не
	//   был ли товар rmvdGoodsID объединен с каким-либо другим и, если да, то предлагает
	//   выбрать именно тот другой товар.
	//   Если указан extGoodsID, то функция сразу подставляет в комбо-бокс выбора товара
	//   extGoodsID (использование extGoodsID бывает оправданно в случае, если предыдущий
	//   выбор был, по мнению вызывающей функции, неудачным, но при этом не хочется терять
	//   выбранную до этого пользователем группу и позицию в списке товаров).
	// Returns:
	//   >0 - пользователь выбрал замещающий товар (его идентификатор возвращается по
	//        указателю pReplaceGoodsID)
	//   <0 - либо товар rmvdGoodsID существует в базе данных, либо пользователь
	//        отказался выбирать замещающий товар
	//    0 - error
	//
	int    SelectGoodsInPlaceOfRemoved(PPID rmvdGoodsID, PPID extGoodsID, PPID * pReplaceGoodsID);
	int    SelectGoodsByBarcode(int initChar, PPID arID, Goods2Tbl::Rec *, double *, SString * pRetCode);
	int    GetGoodsByBarcode(const char * pBarcode, PPID arID, Goods2Tbl::Rec * pRec, double * pQtty, SString * pRetCode);
	int    GetParentID(PPID, PPID * pParentID);
	int    SearchByName(const char * pName, PPID * pID, Goods2Tbl::Rec * pRec = 0);
	int    SearchMaxLike(const PPGoodsPacket *, PPID *);
	//
	// Descr: Ищет товар, имеющий штрихкод pCode. Если штрихкод найден, то по указателям
	//   pBcRec и pGoodsRec возвращается соответственно запись штрихкода и товара.
	//   Если adoptSearching != 0, то функция пытается искать по вариациям заданного
	//   штрихкода: если коды задаются без контрольной цифры и длина pCode == 13, 12 или 8,
	//   то отбрасывает последнюю цифру; если ведущие символы pCode нули, то поочередно
	//   отбрасывает каждый из нулей и пытается найти получившийся код.
	// Returns:
	//   > 0 - штрихкод найден
	//   < 0 - штрихкод не найден
	//     0 - error
	//
	int    SearchByBarcode(const char * pCode, BarcodeTbl::Rec * pBcRec, Goods2Tbl::Rec * pGoodsRec = 0, int adoptSearching = 0);
	int    SearchBy2dBarcode(const char * pCodeLine, BarcodeTbl::Rec * pRec, Goods2Tbl::Rec * pGoodsRec);
	bool   GetSimplifiedDraftBeerBarcode(PPID goodsID, SString & rCode); // @v11.9.3
	//
	// Descr: Для товара goodsID, если с ним ассоциирована структура (GSF_COMPL, GSF_PARTITIAL), находит основной компонент
	//   этой структуры (PPGoodsStruc::GetMainItem) и считает соответствующий товар основным сырьевым компонентом для goodsID.
	//   Функция реализована с целью обеспечить списание марок chzn для разливного пива, формируемого по структурам из кегов 
	//   (возможно, где-то еще пригодится).
	// Returns:
	//   true - искомый основной сырьевой товар найден
	//   false - не удалось найти искомый товар
	//
	bool   GetOriginalRawGoodsByStruc(PPID goodsID, PPID * pOriginalGoodsID); // @v12.0.5
	bool   SelectValidBarcode(PPID goodsID, const PPIDArray * pStdList, SString & rCode);
	//
	// Descr: Определяет является ли код pCode весовым кодом какого-либо товара.
	//
	int    IsScaleBarcode(const char * pCode, PPID * pScaleID, PPID * pGoodsID, double * pQtty);
	int    GenerateScaleBarcode(PPID goodsID, PPID scaleID, SString & rCode);
	//
	// Descr: Расширенная функция поиска товара по коду.
	//   В перспективе должна заменить PPObjGoods::SearchByBarcode
	//
	int    SearchByCodeExt(GoodsCodeSrchBlock * pBlk);
	int    CheckBarcodeList(const PPGoodsPacket * pPack);
	void   GenGroupCode(int numDigits, SString & rBuf);
	//
	// Descr: Утилитная функция, используемая в диалогах.
	//   Предлагает выбрать шаблон штрихкода для генерации кода.
	//
	int    SelectBarcode(int kind, PPID parentID, SString & rBuf);
	//
	// Descr: Позволяет получить информацию о стране происхождения товара
	// Returns:
	//   manufacturer country name by pRec->ManufID in buf pCountryName
	//   if pRec == 0 then
	//       uses Search(goodsID)
	//   else
	//       parameter goodsID ignored
	//   if data obtained and Person(pRec->ManufID).Status == PPPRS_COUNTRY then
	//       *pCountryID = pRec->ManufID
	//       returns 2
	//   if data obtained and Person(pRec->ManufID).Status != PPPRS_COUNTRY then
	//       *pCountryID = City(Location(Person(pRec->ManufID).MainLoc).City).Country
	//       returns 1
	//   if data not obtained then
	//       returns -1
	//   in case of error
	//       returns 0
	//
	int    GetManufCountry(PPID goodsID, const Goods2Tbl::Rec * pRec, PPID * pCountryID, PPCountryBlock * pBlk);
	int    ReadBarcodes(PPID goodsID, BarcodeArray & rCodeList);
	//
	// Descr: возвращает один штрихкод для товара с ИД = id.
	//   Если для заданного товара существует только один штрих-код,
	//   то он и возвращается. Если существует несколько штрих-кодов,
	//   то возвращается тот, которому соответствует одна единица
	//   товара, или, если такого кода нет, то самый первый.
	//   Если для товара нет штрих-кода, то barcode[0] = 0.
	//
	// @v11.9.9 int    GetSingleBarcode(PPID id, char * barcode, size_t bufLen); // @obsolete
	int    GetSingleBarcode(PPID id, uint sifFlags/*BarcodeArray::sifXXX*/, SString & rBuf);
	//
	// Descr: Извлекает посредством кэша один штрихкод для товара с ИД = id.
	//   Правила извлечение то же, что и в функции GetSingleBarcode().
	//
	int    FetchSingleBarcode(PPID id, SString & rBuf);
	//
	// Descr: поиск товара по артикулу, полученному при импорте в Papyrus.
	//
	int    SearchByArticle(PPID article, BarcodeTbl::Rec * pRec);
	//
	// Descr: Флаги функции PPObjGoods::GetRetailGoodsInfo
	//
	enum {
		rgifUseQuotWTimePeriod = 0x0001, // Использовать котировки с временным периодом действия //
		rgifUseBaseQuotAsPrice = 0x0002, // Если для товара есть базовая котировка, то для определения //
			// цены реализации использовать ее, в противном случае - учетную цену реализации.
			// Если этот флаг не установлен, то учетная цена реализации используется с приоритетом.
		rgifAllowUnlimWoQuot   = 0x0004, // Если нелимитированный товар не имеет котировки, то
			// не инициировать ошибку, а вернуть -2 (как для обычного товара, не имеющего цены).
		rgifConcatQttyToCode   = 0x0008, // Для весового штрихкода к этому штрихкоду добавляется в конец
			// количество, заданное в структуре pInfo.
		rgifUseInBarcode       = 0x0010, // Использовать штрихкод, заданный в структуре pInfo.
		rgifUseOuterPrice      = 0x0020, // Предписывает использовать OuterPrice в качестве цены.
		rgifPriceOnly          = 0x0040  // Функция рассчитывает только цену (для ускорения)
 	};
	//
	// Descr: Возвращает информацию о товаре, необходимую для продажи
	//   товара через кассу, печати этикетки и пр.
	// ARG(goodsID IN): ИД товара, по которому необходимо получить данные
	// ARG(locID   IN): ИД склада, в привязке к которому необходимы данные по ценам и сроку голности
	// ARG(pEqBlk  IN):
	// ARG(arID    IN): ИД статьи в привязке к которой необходимо извлекать котировку (если цена
	//   определяется по котировке).
	// ARG(pInfo  OUT): указатель на экземпляр структуры RetailGoodsInfo
	//   Перед вызовом функции никакие поля этой структуры заполнять не надо.
	//   Перед обработкой вся струкутра функцией обнуляется.
	// ARG(flags   IN): Опции функции. См. примечания к rgifXXX-флагам выше.
	// Returns:
	//   >0 - информация успешно извлечена
	//   0  - ошибка
	//   -1 - не найден товар с ИД goodsID
	//   -2 - не найдено ни одного лота для указанного товара (поля Expiry, Cost, Price,
	//        LotID, BillDate, BillCode, Serial, Qtty, PhQtty, UnitPerPack не заполнены)
	//
	int    GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk, PPID arID, double qtty, RetailGoodsInfo * pInfo, long flags);
	int    GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk, PPEgaisProcessor * pEp, PPID arID, LDATETIME actualDtm, double qtty, RetailGoodsInfo * pInfo, long flags);
	//
	// Descr: Упрощенная версия GetRetailGoodsInfo с нулевыми значениями параметров: pEqBlk, arID, qtty, flags.
	//
	int    GetRetailGoodsInfo(PPID goodsID, PPID locID, RetailGoodsInfo * pInfo);
	int    GetBarcodeByTemplate(PPID grp, const char * pTempl, const BarcodeArray * pCurrentList, SString & rBuf);
	//
	// Descr: Удаляет из пакета товара штрихкоды, для которых есть дубликаты в базе данных
	//
	int    RemoveDupBarcodes(PPGoodsPacket * pPack, ObjTransmContext * pCtx);
		// @<<PPObjGoods::AcceptPacket, @<<PPDS_CrrBillItem::AcceptListItem
	//
	// Descr: Удаляет из пакета товара артикулы, для которых есть дубликаты в базе данных
	//
	int    RemoveDupArCodes(PPGoodsPacket * pPack, ObjTransmContext * pCtx);
	int    AssignGoodsToAltGrp(PPID goodsID, PPID grp, long innerNum, int use_ta);
	//
	// Descr: проверяет товар на соответствие фильтру.
	//   Если параметр id == 0, то проверяется запись, находящаяся //
	//   в рабочем буфере, в противном случае проверяется запись по
	//   заданному идентификатору.
	// ARG(pFilt IN): Фильтр, которому должен соответствовать товар
	// ARG(id    IN): Идентификтор проверяемого товара. Если id == 0, то
	//   проверяется запись, находящаяся в буфере обекта PPObjGoods::P_Tbl
	// ARG(implFlags IN): GOCFIF_XXX Флаги реализации. Установка определенных флагов
	//   позволяет избежать дорогостоящих проверок если по мнению вызывающей функции
	//   эти проверки избыточны
	// Returns:
	//   >0 - Если товар удовлетворяет всем критериям фильтра
	//   0  - в противном случае
	//
	int    CheckForFilt(const GoodsFilt * pFilt, PPID id, long implFlags = 0);
	//
	// Descr: Проверяет валидность группы parentID, которой принадлежит товар.
	//   Товар может принадлежать только обыкновенной группе (Kind == PPGDSK_GROUP && !(Flags & GF_FOLDER|GF_ALTGROUP))
	// Returns:
	//   >0 - parentID является правильным идентификатором группы, которой может принадлежать товар.
	//   <0 - parentID не найден
	//   0  - parentID не является группой, которой может принадлежать товар.
	//
	int    ValidateGoodsParent(PPID parentID);
	//
	// Descr: проверяет товар id на принадлежность группе grpID.
	//
	int    BelongToGroup(PPID id, PPID grpID, PPID * pSubGrpID = 0);
	int    GetPhUPerU(PPID goodsID, PPID * pPhUnitID, double * pPhUPerU);
		// @>>PPObjGoods::GetPhUPerU(const Goods2Tbl::Rec *, PPID *, double *)
	int    GetPhUPerU(const Goods2Tbl::Rec * pRec, PPID * pPhUnitID, double * pPhUPerU);
	int    IsAltGroup(PPID grpID); // @>>GoodsCore::IsAltGroup
	int    IsTempAltGroup(PPID grpID); // @>>GoodsCore::IsTempAltGroup
	int    IsDynamicAltGroup(PPID grpID); // @>>GoodsCore::IsDynamicAltGroup
	int    SupplyAddingToAltGrp(PPID id, int use_ta = 1);
	//
	// Descr: Ищет структуру товара goodsID, относящуюся к динамическому обобщению
	//   которому (возможно) принадлежит заданный товар.
	// ARG(goodsID    IN): Товар, для которого ищется альтернативная структура
	// ARG(pDynGenID OUT): @#{vptr0} Указатель, по которому в случае успеха, присваивается //
	//   ИД обобщения.
	// ARG(pStrucID  OUT): @#{vptr0} Указатель, по которому в случае успеха, присваивается //
	//   ИД структуры.
	// Returns:
	//   >0 - найдена структура, относящаяся к динамическому обобщению, к которому относится goodsID
	//   <0 - искомая структура не обнаружена
	//   0  - ошибка
	//
	int    GetAltGoodsStrucID(PPID goodsID, PPID * pDynGenID, PPID * pStrucID);
	int    LoadGoodsStruc(const PPGoodsStruc::Ident & rIdent, PPGoodsStruc * pGs);
	int    LoadGoodsStruc(const PPGoodsStruc::Ident & rIdent, TSCollection <PPGoodsStruc> & rGsList);
	int    EditGoodsStruc(PPID goodsID);
	//
	// Descr: Сканирует таблицу товаров в поиске тех, к которым привязана структура strucID.
	// ARG(strucID IN):        Ид товарной структуры, владельцев которой ищет функция //
	// ARG(expandGenerics IN): Если true, то, если найденный товар является обобщенным - вместо него 
	//   в целевой список вставляются элементы этого обобщения //
	// ARG(pList OUT): Указатель на список, в который будут внесены найденные идентификаторы.
	//   В прологе функция очищает этот список.
	//   В эпилоге список сортируется и очищается от дубликатов.
	// Returns:
	//   >0 - найден по крайней мере один товар, владеющий структурой strucID
	//   <0 - не найдено ни одного товара, владеющего структурой strucID
	//    0 - error
	//
	int    SearchGListByStruc(PPID strucID, bool expandGenerics, PPIDArray & rList);
	int    GetValueAddedData(PPID, PPGoodsPacket *);
	int    InitPacket(PPGoodsPacket *, GoodsPacketKind, PPID parentID, PPID clsID, const char * pBarCode);
	int    ValidatePacket(const PPGoodsPacket * pPack);
	//
	// Descr: Опции функции PPObjGoods::GetPacket
	//
	enum {
		gpoSkipQuot = 0x0001 // Не загружать котировки.
	};

	int    GetPacket(PPID id, PPGoodsPacket * pPack, long options);
	int    PutPacket(PPID * pID, PPGoodsPacket * pPack, int use_ta);
	int    SetupAttrByTextDescr(PPID id, const char * pLine, int use_ta);
	//
	// Descr: Специализированная функция, изменяющая наименование и сокращенние записи товара с идентификатором id
	//   на pNewName. При необходимости pNewName модифицируется вызовом PPObjGoods::ForceUndupName() во избежании
	//   ошибки дублирования имени.
	//
	int    UpdateName(PPID id, const char * pNewName, int use_ta);
	//
	// Descr: ищет товар по параметрам записи расширения pExtRec (pExtRec->GoodsID игнорируется)
	//   Если товар найден, то возвращает значение больше нуля. Если товар не найден и параметр
	//   createIfNExists != 0 то пытается создать новый товар, полагаясь только на информацию
	//   в записи pExtRec.
	//
	int    GetGoodsByExt(const GoodsExtTbl::Rec * pExtRec, PPID * pGoodsID, int createIfNExists, int use_ta);
	//
	// Descr: Извлекает через кэш запись товара goodsID и, если это удалось сделать, то
	//   проверяет, установлен ли в записи товара флаг flag. Если установлен, то возвращает значение >0.
	// Returns:
	//   >0 - запись для товара goodsID найдена и в поле Flags флаг flag установлен.
	//   0  - либо запись goodsID не найдена, либо в поле Flags флаг flag не установлен.
	//
	bool   CheckFlag(PPID goodsID, long flag);
	bool   IsGeneric(PPID goodsID); // @>>PPObjGoods::CheckFlag
	bool   IsAsset(PPID goodsID);   // @>>PPObjGoods::CheckFlag
	bool   IsAssetType(PPID goodsTypeID);
	//
	// Descr: Возвращает !0 если товар с идентификатором goodsID равен otherGoodsID либо
	//   otherGoodsID является обобщенным товаром и goodsID входит в это обобщение.
	//   Если goodsID == 0 || otherGoodsID == 0 результат автоматически отрицательный (0)
	// Returns:
	//   1 - goodsID == otherGoodsID
	//   2 - othetGoodsID является обобщенным товаром и goodsID входит в это обобщение
	//   0 - ни одно из условий истинности функции не выполняется, то есть, goodsID != otherGoodsID
	//      и otherGoodsID не обобщенный либо goodsID не входит в обобщение.
	//
	int    IsEqualOrBelongToGeneric(PPID goodsID, PPID otherGoodsID);
	//
	// Descr: Добавляет в список pList товары, принадлежащие обобщению genID.
	//   Список pList предварительно не очищается, а новые элементы добавляются в ного методом LongArray::addUnique.
	//
	int    GetGenericList(PPID genID, PPIDArray * pList);
	int    GetAltGenGoodsList(PPID goodsID, int kind, RAssocArray * pList);
	int    GetStrucSubstList(PPID goodsID, RAssocArray & rList);
	//
	// Descr: Возвращает список допустимой подстановки вместо товара goodsID.
	//   В зависимости от параметра substStrucOnly и конфигурации документов (PPBillConfig::GoodsSubstMethod)
	//   используется либо подстановка по обобщенному товару либо по подстановочной структуре.
	//   Результирующий массив rList предварително очицается функцией.
	//   Результат заносится в массив в виде списка ассоциаций {GoodsID, Qtty}, где
	//     GoodsID - ид товара, который может быть использован вместо goodsID
	//     Qtty    - количество товара GoodsID которое необходимо использовать
	//               для компенсации дефицита одной единицы товара goodsID.
	// Returns:
	//   >0 - найден по крайней мере один товар, который может быть подставлен вместо goodsID
	//   <0 - не найдено ни одного варианта подстановки
	//   0  - ошибка
	//
	int    GetSubstList(PPID goodsID, int substStrucOnly, RAssocArray & rList);
		// @>>PPObjGoods::GetAltGenGoodsList
		// @>>PPObjGoods::GetStrucSubstList
	int    BelongToGen(PPID goodsID, PPID * pGenID, ObjAssocTbl::Rec * = 0);
	int    AssignGoodsToGen(PPID goodsID, PPID genID, int abbr, int use_ta);
	int    RemoveGoodsFromGen(PPID goodsID, PPID genID, int use_ta);
	//
	// Descr: извлекает запись о товаре с использованием кэша.
	//   В записи инициализированы следующие поля - ID, ParentID, UnitID,
	//   TaxGrpID, GoodsType, Flags (все флаги корректно установлены).
	//   Поля TaxGrpID, GoodsType содержат корректные значения с
	//   учетом наследования соответствующих характеристик из групп.
	//
	int    Fetch(PPID goodsID, Goods2Tbl::Rec * pRec);
	//
	// Descr: Извлекает через кэш наименование товара goodsID.
	// Returns:
	//   >0 - запись с идентификатором goodsID найдена - наименование скопировано в rBuf
	//   <0 - запись с идентификатором goodsID не найдена - в rBuf скопирована строка id={goodsID}.
	//        Если goodsID == 0, то буфер rBuf обрезается до нулевой длины.
	//    0 - error
	//
	int    FetchNameR(PPID goodsID, SString & rBuf);
	int    FetchTax_(PPID goodsID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx); // @v12.2.4 replaced with FetchTaxEntry2
	//
	// Descr: Извлекает схему налогообложения по набору факторов {товар, лот, налогоплательщик, дата, вид операции}.
	// ARG(goodsID in): Идентификатор товара, налогообложение которого нас интересует
	// ARG(lotID in): Идентификатор лота, по которому получен товар. Этот идентификатор нужен только в случае,
	//   если необходимо расчитать входящий НДС (к зачету). Если интересует налогообложение при продаже товара,
	//   то lotID должен быть 0 (в противном случае можете получить не ту налоговую группу, которая нужна).
	// ARG(taxPayerPsnID in): Идентификатор персоналии-налогоплательщика. В случае, если нужна налоговая группа
	//   для расчета налогов, которые должны заплатить мы, то это - идентификатор главной организации.
	//   Если требуется получить налоговую группу для расчета входящего НДС (к зачету) то здесь должен быть
	//   идентификатор поставщика. Важно: если указан ненулевой lotID, то поставщик берется из него и taxPayerPsnID
	//   будет проигнорирован.
	// ARG(dt in): Дата, на которую расчитываются налоги. Может быть важна для получения правильного элемента налоговой группы.
	// ARG(opID in): Вид операции, для которой расчитываются налоги. Может быть важен для получения правильного элемента налоговой группы.
	// ARG(pGtx out): Результирующий эффективный элемент налоговой группы для расчета налогов. Он может быть синтезирован 
	//   из налоговой группы товара (лота) и налоговой группы налогоплательщика. 
	// Returns:
	//   >0 
	//   <0
	//    0
	//
	int    FetchTaxEntry2(PPID goodsID, PPID lotID, PPID taxPayerPsnID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx); // @v12.2.4
	int    FetchTaxEntry2_WithPayerAndWarehouse(PPID goodsID, PPID taxPayerPsnID, PPID taxPayerWarehouseID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx); // @v12.2.4
	//
	// Descr: Функция аналогичная FetchTaxEntry2 но с той разницей, что оперирует не идентификаторами товара и лота
	//   для извлечения схем налогообложения, а использует непосредственно идентификаторы налоговых групп.
	//   Следствием такой модификации является то, что в случае, если необходимо получить входящую налоговую схему (применительно
	//   к поставке и поставщику), то taxPayerPsnID (если не нулевой) должен быть поставщиком, от которого поступил товар
	//   (в случае FetchTaxEntry2 функция может самостоятельно идентифицировать поставщика по lotID), а dt должна
	//   быть датой поставки (в случае FetchTaxEntry2 функция может самостоятельно определить дату поставки по lotID).
	//
	int    FetchTaxEntry2_ByTaxGroups(PPID goodsTaxGrpID, PPID lotTaxGrpID, PPID taxPayerPsnID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx); // @v12.2.4
	int    FetchTaxEntry2_WithPayerAndWarehouse_ByTaxGroup(PPID goodsTaxGrpID, PPID taxPayerPsnID, PPID taxPayerWarehouseID, LDATE dt, PPID opID, PPGoodsTaxEntry * pGtx); // @v12.2.4
	int    FetchCls(PPID goodsID, Goods2Tbl::Rec * pRec, PPGdsClsPacket * pGcPack);
	int    MultTaxFactor(PPID goodsID, double * pVal);
	//
	// Descr: Извлекает товарный тип goodsTypeID через кэш.
	//
	int    FetchGoodsType(PPID goodsTypeID, PPGoodsType * pGtRec);
	bool   IsZeroPriceAllowed(PPID goodsID);
	//
	// Descr: Функция выясняет является ли товар goodsID маркируемой развесной молочной продукцией, для которой 
	//   дополнительно необходимо количественное значение числа отгружаемых мест.
	// Note: Если кратко, то суть проблемы в том, что ебаный честный знак требует от оптовиков что бы сыры, сметана и прочая
	//   молочная хуйня, отгружаемая литрами или килограммами содержала какую-то целочисленную величину, сопоставляемую
	//   с суррогатной маркой, отправляемой вместе с накладной. В общем, в этом лучше на разбираться - это все следствие
	//   того, что вся рашка ебнулась окончательно и бесповоротно.
	//
	bool   IsChZnCtWtGoods(PPID goodsID); // @v12.1.4
	//
	// Descr: Извлекает запись единицы измерения unitID из кэша.
	//
	int    FetchUnit(PPID unitID, PPUnit * pUnitRec); // @>>PPObjUnit::Fetch
	//
	// Descr: Находит коэффициент перевода одной торговой единицы товара rGoodsRec в
	//   базовую единицу измерения baseUnitID.
	// Returns:
	//   >0 - удалось выполнить пересчет. По указателю pRate присвоен коэффициент
	//     пересчета одной торговой единицы товара rGoodsRec в единицы baseUnitID
	//   <0 - не удалось выполнить пересчет. По указателю pRate присвоено значение 0.0
	//   0  - ошибка
	//
	int    TranslateGoodsUnitToBase(const Goods2Tbl::Rec & rGoodsRec, PPID baseUnitID, double * pRate);
	//
	// Descr: Высокоуровневая функция, извлекающая округление количество товара по следующему правилу:
	//   -- если в GoodsStockExt::MinShippmQtty больше нуля и флаги GoodsStockExt::GseFlags содержат
	//     бит GoodsStockExt::fMultMinShipm, то считаем, что определяет округление вверх.
	//   -- в противном случае, если торговая единица измерения товара (Goods2Tbl::Rec::UnitID) 
	//     имеет PPUnit2::Rounding_ > 0.0, тогда эта величина признается кратностью округления.
	// Returns:
	//   1 - валидное значение округления извлечено из товара (GoodsStockExt::MinShippmQtty)
	//   2 - валидное значение округления извлечено из единицы измерения (PPUnit2::Rounding_)
	//  <0 - не удается определить параметр округления количества товара
	//   0 - ошибка (какой-то внутренний сбой: инвалидный ид товара, с базой данных что-то не так etc)
	//
	int    GetQttyRounding(PPID goodsID, double * pRounding);
	int    GetStockExt(PPID, GoodsStockExt * pExt, int useCache = 0);
	//
	// Descr: If(withOrWithout == 1 /with/): добавляет к цене поступления pCost
	//   величину НДС, Предполагается, что значение pCost не содержит НДС.
	//       If(withOrWithout == 0 /without/): снимает с цены поступления pCost
	//   величину налогов. Предполагается, что значение pCost содержит все налоги
	//   кроме налога с продаж.
	//       Parameter vatFreeSuppl: { @before @v4.2.11 используется только при withOrWithout == 0.}
	//   Если vatFreeSuppl > 0, то функция полагает, что НДС нулевой.
	//   Расчет налогов ведется исходя из налоговых групп lotTaxGrpID или
	//   goodsTaxGrpID (если lotTaxGrpID == 0, то используется goodsTaxGrpID).
	// @CAUTION
	//   Вызовы функции с противоположными значениями параметра withOrWithout
	//   в общем случае не являются взаимно обратимыми
	//
	void   AdjCostToVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate, double qtty, double * pCost /* In, Out */, int withOrWithout, int vatFreeSuppl = -1);
	void   CalcCostVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate, double qtty, double cost, double * pVatSum, int withOrWithout, int vatFreeSuppl = -1, int roundPrec = 2);
	void   AdjPriceToTaxes(PPID taxGrpID, double taxFactor, double * pPrice, int exclSTax);
	//
	// Descr: определяет является ли товар id1 совместимым с товаром id2 по единицам измерения.
	//   Если да, то возвращается значение > 0, а по указателю pRatio (если pRatio != 0)
	//   возвращается количество торговых единиц товара id1, эквивалентное
	//   торговой единице товара id2.
	//   Если торговая единица товара id1 является целочисленной и
	//   *pRatio является нецелочисленной величиной, при совместимости
	//   товаров, возвращаемое значение < 0.
	//
	int    IsGoodsCompatibleByUnit(PPID id1, PPID id2, double * pRatio);
	//
	// Функции для работы с котировками
	//
	int    EditQuotations(PPID goodsID, PPID initLocID, PPID initCurID, PPID initArID, int quotCls, int toCascade = 0, PPID accSheetID = 0);
	int    GetQuot(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache = 0);
		// @>>GoodsCore::GetQuot
	int    GetQuotExt(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache);
	int    GetQuotExt(PPID goodsID, const QuotIdent &, double *, int useCache);
	int    BelongToMatrix(PPID goodsID, PPID locID);
		// @>>GoodsCore::BelongToMatrix(PPID goodsID, PPID locID)
	//
	// Descr: @todo
	//
	int    CheckMatrix(PPID goodsID, PPID locID, PPID opID, PPID billArID);
	int    GetMatrixRestrict(PPID goodsID, PPID locID, int srchNearest, PPID * pGoodsGrpID, long * pResult);
	int    CheckMatrixRestrict(PPID goodsID, PPID locID, long restrict);
	int    GetSupplDeal(PPID goodsID, const QuotIdent & rIdent, PPSupplDeal * pResult, int useCache = 0);
	int    SetSupplDeal(PPID goodsID, const QuotIdent & rIdent, const PPSupplDeal * pDeal, int useTa);
	int    GetQuotExtByList(const PPQuotArray *, const QuotIdent &, double cost, double price, double *);
	int    GetQuotList(PPID goodsID, PPID locID, PPQuotArray & rList); // @>>GoodsCore::GetQuotList
	//
	// Descr: Сохраняет список котировок, ассоциированных с товаром goodsID.
	//   Если pList == 0, то удаляет все котировки, ассоциированные с этим товаром.
	// Remark:
	//   Если pList != 0, то проверяет соответствие pList->GoodsID == goodsID и,
	//   если это равенство не выполняется возвращает 0 и PPErrCode = PPERR_INVQUOTLIST.
	//
	int    PutQuotList(PPID goodsID, const PPQuotArray * pList, bool updByTime, int use_ta);
	int    ImportOld(int use_ta); // Импорт по устаревшей технологии
	int    Import(const char * pCfgName, int analyze, int use_ta); // Импорт по новой технологии
	int    ImportQuotOld(int use_ta);
	int    ImportQuot(const char * pCfgName, int use_ta);
	//
	// Функции подстановки
	//
	struct SubstBlock {
		SubstBlock();
        PPID   ExclParentID;
        PPID   LocID;
        LDATE  Dt;           // Дата актуальности. Требуется в некоторых ситуациях
			// (например, подстановка по ставке НДС). Если Dt == 0, то полагается равной текущей системной дате.
		PPID   LotID;        // Ид лота. Если !0, то для подстановки характеристики лота
			// функция SubstGoods будет получать непосредственно из этого лота (без оглядки на SupplID, LotTaxGrpID и Dt)
		const  ReceiptTbl::Rec * P_LotRec; // Запись лота. Если !0, то используется с приоритетом по сравнению с LotID
	};
	int    SubstGoods(PPID srcID, PPID * pDestID, SubstGrpGoods sgg, const SubstBlock * pBlk, GoodsSubstList *);
	void   GetSubstText(PPID id, SubstGrpGoods, const GoodsSubstList *, SString & rBuf);
	int    ReplaceName(PPGoodsPacket *, const PPGoodsReplaceNameParam *);
	int    ShowGoodsAsscInfo(PPID goodsID);
	//
	// Descr: Блокирует товар goodsID. Блокировка предотвращает возможность редактирования //
	//   товара другим сеансом.
	//
	int    Lock(PPID goodsID);
	//
	// Descr: Снимает блокировку с товара goodsID. После снятия блокировки товар доступен
	//   для редактирования другим сеансом
	//
	int    Unlock(PPID goodsID);
	int    Helper_Edit(PPID *, PPGoodsPacket *, GoodsPacketKind, int IsNew, int viewOnly = 0);
	int    GetRandomIdsAry(int count, PPIDArray * pAry);
	//
	// Descr: Проверяет товар на принадлежность товарной матрице и контрактным ценам поставщика
	//
	int    CheckSpecQuot(PPID supplID, PPID goodsID, PPID locID, PPID currID);
	//
	// Descr: Сравнивает записи и возвращает их похожесть в диапазоне [0..1]
	//
	double CalcLikeness(const Goods2Tbl::Rec * pRec1, const Goods2Tbl::Rec * pRec2, int * pSwap, long extra);
	int    GetOpenedList(PPID locID, const PPIDArray * pOverlapList, UintHashTable & rHash);
	//
	// Descr: Извлекает UUID (зарезервированный тег PPTAG_GOODS_UUID) для товара goodsID.
	//   Если у товара тега нет и параметр generateIfAbsent == true то генерируется новый UUID
	//   для этого товара. Использование транзакции при генерации регламентируется параметром use_ta.
	//   При успешном завершении по ссылке rUuid устанавливается найденный UUID.
	// Returns:
	//   1 - для товара goodsID найден UUID
	//   2 - UUID не был найден и после этого был успешно сгенерирован
	//  <0 - UUID не был найден (параметр generateIfAbsent == false)
	//   0 - error (либо ошибка создания нового UUID, либо отсутствие тега PPTAG_GOODS_UUID)
	//
	int    GetUuid(PPID goodsID, S_GUID & rUuid, bool generateIfAbsent, int use_ta);
	//
	// Descr: Утилитная функция, автоматически расставляющая признак PREFERRED_BARCODE
	//   по всей выборке товаров.
	//
	int    SetupPreferredBarcodeTags();
	int    GetTagList(PPID goodsID, ObjTagList * pTagList);
	int    SetTagList(PPID goodsID, const ObjTagList * pTagList, int use_ta);
	int    SerializePacket(int dir, PPGoodsPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx, const DBDivPack * pDestDbDiv);
	int    __Helper_GetPriceRestrictions_ByFormula(SString & rFormula, const PPGoodsPacket * pPack, double & rBound);
	int    QuerySpecialNecessityForAcceptingSyncPacket();

	struct ProcessNameBlock {
		long   Flags;
		SString OrgName;
	};

	int    ProcessName(const ProcessNameBlock & rBlk, SString & rResult);

	struct ExportToGlbSvcParam {
		enum {
			fOnlyUnassocItems  = 0x0001, // Экспортировать только те позиции, которые остутствуют во внешнем сервисе
			fBlockAbsenceItems = 0x0002, // Блокировать позиции, отсутствующие в выборке
			fExportPrice       = 0x0004, // Экспортировать цены
			fExportRest        = 0x0008  // Экспортировать остатки
		};
		enum {
			coGoodsGrpName = 0,
			coTag
		};

		ExportToGlbSvcParam();
		long   GlobalService;  // PPGLS_XXX
		PPID   GuaID;          // ->Ref(DLG_GLOBUSERACC)
		long   Flags;          // @flags
		long   CategoryObject; // Сущность, которую следует выгружать в качестве наименования категории товара
		PPID   CategoryTagID;  // Тег категории
		long   DescrExtStrId;  // GDSEXSTR_XXX Ид строки расширения товара, используемой как подробное описание товара
	};
	struct ExportToGlbSvcItem { // @flat
		ExportToGlbSvcItem();
		PPID   GoodsID; // @anchor
		PPID   LocID;   // @anchor
		double Cost;
		double Price;
		double Rest;
	};

	int    EditExportToGlbSvcParam(ExportToGlbSvcParam * pData);

	PPObjGoodsStruc GSObj;
	PPObjGoodsTax   GTxObj;
	PPObjGoodsType  GtObj;
protected:
	PPObjGoods(PPID objType, PPID kind, void * extraPtr);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);

	PPID   Kind; // PPGDSK_XXX (Initialized by constructor)
private:
	friend class GoodsCache;
	friend int FASTCALL GetGoodsNameR(PPID goodsID, SString & rBuf);

	PPObjGoods(SCtrLite);
	virtual const char * GetNamePtr();
	void   InitInstance(SCtrLite sctr, PPID kind, void * extraPtr);
	void   InitConfig();
	int    MakeReplaceStr(const PPGoodsPacket *, const PPGoodsReplaceNameParam *, const char * pFragment, SString &);
	int    Helper_ReplaceName(const PPGoodsPacket *, const PPGoodsReplaceNameParam *, char *, size_t);
	int    Helper_WriteConfig(const PPGoodsConfig * pCfg, const SString * pGoodsExTitles, PPOpCounterPacket * pOwnAcCntr, int rebuild, int use_ta);
	//
	// Descr: Записывает принятый из другого раздела пакет в БД.
	//
	int    AcceptPacket(PPID * pID, PPGoodsPacket * pPack, bool updQuotsByTime, ObjTransmContext * pCtx); // @<<PPObjGoods::Write
	int    AcceptQuot(PPID goodsID, PPGoodsPacket * pPack, bool updByTime, ObjTransmContext * pCtx); // @<<PPObjGoods::AcceptPacket
	int    Helper_ImportHier(PPIniFile *, DbfTable *, PPID defUnitID, HierArray * pHierList); // @<<PPObjGoods::Import
	void   Helper_AdjCostToVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate,
		double qtty, double * pCost /* In, Out */, double * pVatSum, int withOrWithout, int vatFreeSuppl, int roundPrec);
	int    Unite(PPID destID, PPID srcID); // @<<PPObjGoods::HandleMsg
	int    Helper_EditGoodsStruc(PPID goodsID, int isDynGen); // @<<PPObjGoods::EditGoodsStruc
	int    AddDefaultBarcode(PPGoodsPacket * pPack);
	int    Helper_SearchMaxLikeByBarcode(const char * pCode, PPID * pID);
	int    Helper_GetQuotExt(PPID goodsID, const QuotIdent & rQi, double cost, double price, double * pResult, int useCache);
	int    Helper_GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk, PPEgaisProcessor * pEp, 
		PPID arID, LDATETIME actualDtm, double qtty, RetailGoodsInfo * pInfo, long flags);
	int    Helper_SearchByBarcodeAdopt(const char * pCode, int mode, StringSet & rProcessedList, BarcodeTbl::Rec * pBcRec, Goods2Tbl::Rec * pGoodsRec);
	bool   Helper_GetOriginalRawGoodsByStruc(PPID goodsID, const PPIDArray * pValidBcStdList, PPID * pOriginalGoodsID, SString * pValidCode); // @v12.0.5
	int    CombineTaxEntry(const PPGoodsTaxEntry & rGtx, PPID taxPayerPersonID, PPID taxPayerLocID, LDATE dt, PPID opID, PPGoodsTaxEntry * pResultGtx);

	PPGoodsConfig * P_Cfg;
	SCtrLite Sctr;
	int16  EcoSel;         // if !0 && !__WIN32__ then 'exists only' selection uses DBQuery, not SArray
	int16  DoObjVer;       // Хранить версии измененных и удаленных объектов
	PPObjPerson * P_PsnObj;
	PPIDArray Locks;
public:
	TLP_MEMB(GoodsCore, P_Tbl);
	void * ExtraPtr;
};
//
// Descr: Контекст разрешения формул.
//
class GoodsContext : public ExprEvalContext {
public:
	struct Param {
		Param();
		enum {
			fCostSettled  = 0x0001, // Индикатор того, что цена поступления Cost инициализирована (пусть и нулевая)
			fPriceSettled = 0x0002  // Индикатор того, что цена реализации Price инициализирована (пусть и нулевая)
		};
		double Par1;
		double Par2;
		double Par3;
		PPID   TSessID;
		PPID   GoodsID;
		PPID   PrevGoodsID;
		PPID   LocID;
		PPID   ArID;
		PPID   CurID;
		PPID   LotID; // @v11.1.12
		long   Flags; // 
		double Qtty;
		double Cost;  //
		double Price; //
		ReceiptCore::LotDimensions LotDim;
	};
	enum {
		funcVat       = EXRP_EVAL_FIRST_FUNC +  1, // vat(x)
		funcVatPlus   = EXRP_EVAL_FIRST_FUNC +  2, // vatplus(x)
		funcVatMinus  = EXRP_EVAL_FIRST_FUNC +  3, // vatminus(x)
		funcGetQuot   = EXRP_EVAL_FIRST_FUNC +  4, // getquot(qk_symb)
		funcGetQuotCP = EXRP_EVAL_FIRST_FUNC +  5, // getquotcp(qk_symb, cost, price)
	};

	GoodsContext(GdsClsCalcExprContext * pCtx);
	GoodsContext(Param & rParam);
	GoodsContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack);
	GoodsContext(const CCheckItem * pCi);
	~GoodsContext();
	int    SetParam(const Param & rP);
	const  Param & GetParam() const;
	virtual int Resolve(const char *, double *);
	virtual int IsFunc(const char * pSymb, int * pFuncId);
	virtual int ResolveFunc(int funcId, FC & rFc);
private:
	void   Init();
	int    IsRef(const char *, size_t * pPos, SString & rRef);
	int    ResolveGoodsAttr(const SString & rSymb, PPID goodsID, double * pVal);
	int    ResolveRefQtty(PPID goodsID, int cbItemRef, int isPhQtty, double * pVal);
	void   AllocGoodsStruc();

	const  PPGoodsPacket  * P_Pack;
	const  PPGdsClsPacket * P_ClsPack;
	const  PPGoodsStruc * P_Gs;
	const  PPBillPacket * P_BillPack;
	const  PPTransferItem * P_Ti;
	const  CCheckItem * P_Ci;
	const  TSessLineTbl::Rec * P_TslRec; // @v11.0.7
	PPObjGoods GObj;
	PPObjTSession * P_TSesObj;
	PPGoodsStruc ProperGs; // Внутренний экземпляр структуры товара на тот случай,
		// если из-вне структура передана не была, но может быть получена из контекста.
	Param  P;
};
//
//
// @ModuleDef(PPObjGoodsInfo)
//
#define GIF_SHOWLOTS 0x00000001L

struct PPGoodsInfo2 {      // @persistent @store(Reference2Tbl+)
	long   ObjType;
	long   ObjID;
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	long   LocID;
	long   TouchScreenID;
	long   LabelPrinterID;
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};
//
// Descr: Параметры запуска инфокиоска
//
class InfoKioskPaneFilt : public PPBaseFilt {
public:
	InfoKioskPaneFilt();

	uint8  ReserveStart[32]; // @anchor @reserve
	PPID   InfoKioskID;      // Идентификатор записи инфокиоска
	PPID   DefaultGrpID;     // Товарная группа по умолчанию (отображается при открытии панели)
	long   Flags;
	long   ReserveEnd;       // @anchor @reserve
};

class PPObjGoodsInfo : public PPObjReference {
public:
	explicit PPObjGoodsInfo(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    GetPacket(PPID id, PPGoodsInfo *);
	int    PutPacket(PPID * pID, PPGoodsInfo *, int useTa);
	int    EditInfoKioskPaneFilt(InfoKioskPaneFilt * pData);
};
//
// Descr: Класс, управляющий ассоциациями товар-объект. В качестве ассоциированного
//   объекта предполагается использовать PPOBJ_LOCATION и PPOBJ_ARTICLE (поставщики)
//   Ассоциации хранятся в таблице ObjAssoc с типом ассоциации, определяемом клиентом
//   класса, и указываемом в контрукторе GoodsToObjAssoc.
//
class GoodsToObjAssoc {
public:
	GoodsToObjAssoc(PPID asscTyp, PPID objType, int dupAllowing = 0);
	operator const LAssocArray & () const;
	bool   IsValid() const;
	uint   GetCount() const;
	const  LAssoc & FASTCALL at(uint pos) const;
	//
	// Returns:
	//   0 - ассоциация для товара goodsID не определена
	//   1 - найдена прямая ассоциация товара goodsID
	//   2 - найдена унаследованная от родительской группы ассоциация товара goodsID
	//
	int    Get(PPID goodsID, PPID * pObjID) const;
	int    Search(PPID goodsID, PPID * pObjID, uint * pPos) const;
	int    SearchPair(PPID goodsID, PPID objID, uint * pPos) const;
	int    GetListByGoods(PPID goodsID, PPIDArray & rObjList) const; // @recursion
	int    GetListByObj(PPID objID, PPIDArray & rGoodsList) const;
	int    Add(PPID goodsID, PPID objID, uint * pPos = 0);
	int    UpdateByPos(uint pos, PPID goodsID, PPID objID);
	int    Remove(PPID goodsID, PPID objID);
	int    Load();
	int    Save();
	SString & GetKeyName(PPID id, SString & rBuf);
private:
	PPID   AsscType;
	PPID   ObjType;
	enum {
		fDup   = 0x0001, // Допускает дублирование товара
		fNamed = 0x0002, // Объект инициализирован именованной ассоциацией
		fError = 0x0004  // При инициализации объекта возникла ошибка
	};
	long   Flags;
	PPNamedObjAssoc NoaRec;
	mutable PPObjGoods GObj;
	LAssocArray List;
};

class GoodsIterator {
public:
	enum {
		ordByDefault = 0,
		ordByName = 1,
		ordByAbbr = 2
	};
	//
	// Descr: Расширение информации о товаре, предоставляемое итератором при
	//   установке некоторых параметров фильтра.
	// Note: Данное расширение не может быть использовано для определения параметров
	//   непосредственной продажи. На первоначальном этапе расширение применяется для 'кспорта
	//   данных в интернет-магазин Universe-HTT
	//
	struct Ext {
		Ext  & Z();

		PPID   GoodsID;
		PPID   CurID;
		double Price;
		double Rest;
		LDATETIME PriceDtm;
		StrAssocArray SfList;
	};

	static int FASTCALL GetListByGroup(PPID goodsGrpID, PPIDArray * pList);
	static int FASTCALL GetListByFilt(const GoodsFilt * pFilt, PPIDArray * pList, PPIDArray * pDupDynGrpList = 0);
	static int FASTCALL GetListByFilt(const GoodsFilt * pFilt, StrAssocArray * pList, int byName);
	GoodsIterator(const GoodsFilt *, int aOrder, PPIDArray * pDupDynGrpList = 0);
	GoodsIterator(PPID grp, int aOrder, PPIDArray * pDupDynGrpList = 0);
	explicit GoodsIterator(int aOrder = 0, PPIDArray * pDupDynGrpList = 0);
	~GoodsIterator();
	int    Init(const GoodsFilt *, int aOrder);
	int    Init(PPID grp, int aOrder);
	int    Init(int aOrder);
	int    Next(Goods2Tbl::Rec * pRec, GoodsIterator::Ext * pExt = 0);
	int    GetSelectorListInfo(PPID * pClsID, StrAssocArray & rList) const;
	const  IterCounter & GetIterCounter() const;
	int    GetSelectorListItem(long handler, PPUhttStoreSelDescr::Entry & rEntry) const;
private:
	void   FASTCALL InitInstance(PPIDArray * pDupDynGrpList);
	int    CreateIterQuery();
	int    Helper_MakeListByGroup(const PPIDArray * pGrpList, PPID grpID, PPIDArray * pList, int doIntersect);
	int    FASTCALL CheckActual(const Goods2Tbl::Rec & rRec) const;
	//
	// Descr: Проверяет элементы списка pSrcList на соответствие фильтру this->Filt.
	//   Если pDestList != 0, то элементы, которые соответствуют фильтру, добавляются в pDestList.
	//   Если pDestList == 0, то элементы, которые не соответствуют фильтру, удаляются из pSrcList
	//
	int    FilterList(PPIDArray * pSrcList, PPIDArray * pDestList, long implFlags);
	int    IterIdx;
	int    Order;
	PPIDArray * P_List;
	PPIDArray * P_MtxList;       // Список товаров, соответствующих матрице
	UintHashTable * P_ActualHash; // Набор товаров, которые есть на остатке
	BExtQuery * P_IterQuery;
	PPIDArray * P_DupDynGrpList;
	PPUhttStorePacket * P_UhttsPack;
	LAssocArray * P_GrpCountList; // @v11.8.3 Список товарных групп с подсчетом количества соответствующих товаров. Для критерия GoodsFilt::GrpCountRange
	IterCounter Counter;
	PPObjGoods GObj;
	PPObjTag   TagObj;
	GoodsFilt  Filt;
	PPIDArray UnlimTypeList;

	struct InnerExt { // @flat
		PPID   GoodsID;
		PPID   CurID;
		double Price;
		double Rest;
		LDATETIME PriceDtm;
	};

	PPID   SfClsID; // Класс товара, по которому набираются селекторные атрибуты
	TSVector <InnerExt> ExtList;
	StrAssocArray ExtSfTitleList;
};
//
// @ModuleDecl(PPObjGoodsGroup)
//
// Bias for selecting goods groups. Used in PPObjGoodsGroup::Selector()
//
#define GGRTYP_SEL_NORMAL    0x02000000L // Исключить альтернативные группы
#define GGRTYP_SEL_ALT       0x01000000L // Только альтернативные группы и группы верхнего уровня //
#define GGRTYP_SEL_ASSET     0x04000000L // Только группы основных фондов (имеют тип товара с признаком GTF_ASSETS)
#define GGRTYP_SEL_EXCLASSET 0x08000000L // Исключить группы основных фондов
#define GGRTYP_SEL_FOLDER    0x10000000L // Показывать только группы-папки
//
// Descr: Параметр функции PPObjGoodsGroup::Recover
//
struct GoodsGroupRecoverParam {
	GoodsGroupRecoverParam();
	enum {
		fCorrect = 0x0001, // Исправлять ошибки
		fDelTempAltGrp   = 0x0002, // Удалять временные альтернативные группы
		fDelUnusedBrands = 0x0004  // Удалять не используемые бренды
	};
	//
	// Descr: Действия над пустыми группами
	//
	enum {
		egaNone = 0,     // Ничего не делать
		egaReport,       // Выводить сообщение в журнал
		egaMoveToFolder, // Переместить в выбранную папку
		egaRemove        // Удалить
	};
	SString LogFileName;  // Имя файла журнала, в который заносится информация об ошибках
	PPID   EgaFolderID;
	long   Ega;           // egaXXX Действие над пустыми товарными группами
	long   Flags;
};
//
// Descr: Итоговая информация по товарным группам
//
struct GoodsGroupTotal {
	GoodsGroupTotal();
	long   MaxLevel;       // Максимальная вложенность групп
	long   Count;          // Общее количество элементов
	long   AltCount;       // Количество альтернативных групп
	long   FoldCount;      // Количество групп-папок
	long   GrpCount;       // Количество обыкновенных групп
};

class PPObjGoodsGroup : public PPObjGoods {
public:
	explicit PPObjGoodsGroup(void * extraPtr = 0);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID id);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*parent*/);
	//
	// Методу PPObjGoodsGroup::Selector в качестве дополнительного
	// параметра передается ид. родительской группы + биас типа группы
	// (GGRTYP_SEL_XXX). В случае успеха этот ид. присваивается полю
	// PPObjGoodsGroup::Extra.
	// Методы UpdateSelector, ChangeLevel использует поле
	// PPObjGoodsGroup::Extra как идентификатор родительской группы,
	// а параметр extraParam игнорируют. Метод ChangeLevel
	// модифицирует PPObjGoodsGroup::Extra.
	//
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int  UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	int    SearchCode(const char * pCode, BarcodeTbl::Rec * = 0);
	//
	// Descr: Присваивает картинки каждому элементу списка для древовидных списков
	//
	int    AssignImages(ListBoxDef * pDef);
	//
	// Descr: Вычисляет уровень вложенности группы grpID.
	//   Для группы, не имеющей предков, уровень вложенности - 0.
	// Returns:
	//   >0 - уровень вложенности успешно определен
	//   <0 - идентификатор grpID не найден
	//   0  - ошибка
	//
	int    GetLevel(PPID grpID, long * pLevel);
	int    CalcTotal(GoodsGroupTotal * pTotal);
	//
	// Descr: Подсчитывает количество товаров в каждой терминальной группе.
	// Note: Функция может работать достаточно долго!
	// ARG(pRange IN): Если указатель не нулевой, то в результат включаются только те группы,
	//   мощность которых не выходит за границы диапазона по этому указателю.
	//   Этот параметр позволяет ускорить работу функции за счет прекращения перебора групп,
	//   количество товаров в которых выходит за верхнюю границу диапазона.
	// ARG(rResult OUT): Результат работы функции: ассоциации {group; count}
	//
	int    GetListOfCounts(const IntRange * pRange, LAssocArray & rResult);
	int    Transmit();
	//
	// Descr: Проверяет и, возможно, корректирует товарные группы.
	//   Проверяются следующие дефекты:
	//     1. существуют товары, ссылающиеся на альтернативную группу как на родительскую
	//     2. существуют товары, ссылающиеся на группу-папку как на родительскую
	//     3. циклические ссылки между группами
	//   Обнаруженные ошибки функция записывает в файл журнала, определенный параметром pParam->LogFileName.
	// ARG(pParam IN): @{vptr0} Параметры проверки и восстановления ошибок
	//   Если этот параметр нулевой, то функция выводит диалог редактирования параметров проверки
	//   и восстановления.
	// Returns:
	//   >0 - проведена проверка и, возможно, восстановление ошибок
	//   <0 - если pParam == 0 и пользователь отказался от проверки.
	//   0  - ошибка
	//
	int    Recover(const GoodsGroupRecoverParam * pParam, PPLogger * pLogger);
	//
	// Descr: Считывает из базы данных товарных фильтр, ассоциированный с альтернативной
	//   группой с идентификатором id.
	//
	int    ReadGoodsFilt(PPID id, GoodsFilt * pFilt);
	//
	// Descr: Утилитная функция. Определяет, является ли
	//   заданная параметром группа альтернативной. Если запись,
	//   соответствующая параметру не найдена, то возвращается -1.
	//   В противном случае, если группа альтернативная, то возвращается (>0),
	//   иначе - 0.
	//
	static int IsAlt(PPID id);
	static int IsTempAlt(PPID id);
	static int IsDynamicAlt(PPID id);
	//
	// Descr: Создает группу по упрощенному набору параметров. Если группа, имеющая имя pName или
	//   код pCode уже существует, то функция возвращает ее идентификатор.
	// ARG(pID     OUT): Указатель на идентификатор созданной или обнаруженной группы
	// ARG(kind     IN): @#{0 || gpkndOrdinaryGroup || gpkndFolderGroup || gpkndAltGroup} Вид создаваемой группы.
	//   Если kind == 0, то функция считает, что kind = gpkndOrdinaryGroup.
	// ARG(parentID IN): Родительская группа.
	// ARG(pName    IN): Наименование группы. Функция пытается сначала найти группу с таким именем, прежде чем
	//   создавать новую.
	// ARG(pCode    IN): @#{vptr0} Код группы. Если pCode != 0 то функция сначала пытается найти группу с
	//   таким кодом, прежде чем создать новую.
	// ARG(unitID   IN): Ид единицы измерения торговых единиц создаваемой группы.
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 -
	//
	int    AddSimple(PPID * pID, GoodsPacketKind kind, PPID parentID, const char * pName, const char * pCode, PPID unitID, int use_ta);
	StrAssocArray * Implement_MakeStrAssocList(long parentID, const PPIDArray * pTerminalList);
	int    Import(int use_ta);
	static int SetOwner(PPID id, long curOwner, long newOwner);
	static int RemoveTempAlt(PPID id, long owner, int forceDel = 0, int useTa = 1);
	static int AddDynamicAltGroupByFilt(const GoodsFilt * pFilt, PPID * pDynamicAltGrpID, long owner, int useTa);
	static int SetDynamicOwner(PPID id, long curOwner, long newOwner);
	static int RemoveDynamicAlt(PPID id, long owner, int forceDel = 0, int useTa = 1);
private:
	virtual int  MakeReserved(long flags);
};
//
//
//
class GoodsGroupIterator {
public:
	enum {
		fAddZeroGroup      = 0x0001,
		fSortByCode        = 0x0002,
		fEnumAltGroups     = 0x0004,
		fEnumAltGroupsOnly = 0x0008
	};
	GoodsGroupIterator(PPID parentID, long flags = 0);
	int    Init(PPID parentID, long flags);
	int    Next(PPID * pID, SString & rBuf);
	//int    Next(PPID * pID, char * pBuf, size_t bufLen);
	int    Get(PPID id, SString & rBuf) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	PPID   ParentID;
	long   Flags;
	PPObjGoods GObj;
	SCollection List;
	uint   IterIndex;
};
//
// Package
//
struct PPGdsPckgType {
	PPID   ID;
	char   Name[64];
	char   CodeTempl[20];
	long   Counter;
	PPID   GoodsGrpID;
	long   Flags;
};

class PPObjPckgType : public PPObjGoods {
public:
	static int CodeByTemplate(const char * pTempl, long counter, char *, size_t bufLen);

	PPObjPckgType(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    Get(PPID, PPGdsPckgType *);
	int    Put(PPID *, PPGdsPckgType *, int use_ta);
	PPID   GetSingle();
private:
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	virtual int  Browse(void * extraPtr);
};
//
//
//
struct PPFreightPackageType {
	PPFreightPackageType()
	{
		THISZERO();
	}
	enum {
		fPassive = 0x0001
	};
	long   Tag;            // Const=PPOBJ_FREIGHTPACKAGETYPE
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символьный код  //
	char   Code[12];       // Цифровой код //
	char   Reserve[48];    // @reserve
	long   Flags;          //
	long   Reserve2;       // @reserve
	long   Reserve3;       // @reserve
};

class PPObjFreightPackageType : public PPObjReference {
public:
	explicit PPObjFreightPackageType(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
};
//
// Transport
//
// Transport Types
//
#define PPTRTYP_CAR      1 // Car
#define PPTRTYP_SHIP     2 // Ship
//
//
//
struct PPTransportConfig {
	PPTransportConfig();
	bool   FASTCALL operator == (const PPTransportConfig & rS) const;

	long   Flags;           // @reserve
	PPID   OwnerKindID;     // Вид персоналии - владельцы транспортных средств. По умолчанию - PPPRK_SHIPOWNER
	PPID   CaptainKindID;   // Вид персоналии - капитаны (водители). По умолчанию - PPPRK_CAPTAIN
	SString NameTemplate;   // Шаблон наименования записи. Если определен, то
		// имя новой записи формируется автоматически по этому шаблону.
};
//
// @todo @dbd_exchange Добавить теги
//
struct PPTransport {       // @persistent @store(Goods2Tbl)
	//
	// Descr: Типы фургонов (изначально сделаны для сопоставления с соответствующими типами VETIS, в дальнейшем будет расширяться)
	//
	enum {
		vantypUndef       = 0,
		vantypFrozen      = 1,
		vantypChilled     = 2,
		vantypCooled      = 3,
		vantypVentilated  = 4
	};
	PPTransport();
	bool   FASTCALL IsEq(const PPTransport & rS) const;

	PPID   ID;             // @id
	long   TrType;         // PPTRTYP_XXX (Stored as Goods2.GdsClsID)
	char   Name[64];       // @name
	char   Code[16];       // Номер транспортного средства         (Stored as Barcode.Code with prefix '^' and Qtty = 1.0)
	char   TrailerCode[16]; // Номер прицепа (для автотранспорта)  (Stored as Barcode.Code with prefix '^' and Qtty = 2.0)
	PPID   TrModelID;      // ->Ref(PPOBJ_TRANSPMODEL) ИД модели (Stored as Goods2.BrandID)
	PPID   OwnerID;        // ->Person.ID (PPPRK_SHIPOWNER) Владелец транспорта (Stored as Goods2.ManufID)
	PPID   CountryID;      // ->Country.ID (Stored as Goods2.DefBCodeStrucID)
	PPID   CaptainID;      // ->Person.ID (PPPRK_CAPTAIN) Командир транспорта (Stored as Goods2.RspnsPersonID)
	long   Capacity;       // Грузоподьемность (кг) (Stored as Goods2.PhUPerU)
	int16  VanType;        // PPTransport::vantypXXX Тип фургона
	int16  Flags;          // @flags
};

class PPTransportPacket { // @v11.2.12
public:
	PPTransportPacket();
	PPTransportPacket & Z();
	bool   FASTCALL IsEq(const PPTransportPacket & rS) const;

	PPTransport Rec;
	ObjTagList TagL; // @v11.2.12 Список тегов
};

class PPObjTransport : public PPObjGoods {
public:
	static int FASTCALL ReadConfig(PPTransportConfig *);
	static int FASTCALL WriteConfig(const PPTransportConfig *, int use_ta);
	static int EditConfig();
	PPObjTransport(void * extraPtr = 0);
	int    Get(PPID id, PPTransportPacket * pPack);
	int    Put(PPID * pID, const PPTransportPacket * pPack, int use_ta);
	int    GetNameByTemplate(PPTransport * pPack, const char * pTemplate, SString & rBuf) const;
	virtual int  Edit(PPID * pID, void * extraPtr);
	// realy private
	static int MakeStorage(PPID id, const PPTransport * pRec, Goods2Tbl::Rec * pRawRec, BarcodeArray * pBcList);
	LongArray * MakeList(long trType);
private:
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
// PPObjBrand
// Объект, управляющий информацией о товарных брэндах
//
// @v12.0.4 (replaced with GF_DERIVED_HASIMAGES) #define BRNDF_HASIMAGES__ 0x00000001L

class BrandFilt : public PPBaseFilt {
public:
	BrandFilt();
	BrandFilt & FASTCALL operator = (const BrandFilt & rS);
	virtual bool IsEmpty() const;

	enum {
		fSubName        = 0x0001,
		fShowGoodsCount = 0x0002
	};
	uint8  ReserveStart[28];  // @anchor
	long   Order;             //
	long   Flags;
	SString SrchStr;          // @anchor Строка, содержащаяся в имени
	ObjIdListFilt ParentList;
	ObjIdListFilt OwnerList;
};

struct PPBrand {           // @persistent @store(GoodsTbl)
	PPBrand();
	int    FASTCALL CheckForFilt(const BrandFilt * pFilt) const;
	bool   FASTCALL IsEq(const PPBrand & rS) const;
	PPID   ID;             // @id
	char   Name[64];       // Наименование на родном языке
	PPID   OwnerID;        // ->Person.ID (PPPRK_MANUF) Владелец брэнда
	PPID   ParentID;       // ->Goods2.ID Группа (PPGDSK_BRANDGROUP), которой принадлежит брэнд (может быть 0)
	long   Flags;
	char   Reserve[8];     // @reserve
};

class PPBrandPacket {
public:
	PPBrandPacket();
	~PPBrandPacket();
	void   Init();
	PPBrandPacket & FASTCALL operator = (const PPBrandPacket &);
	//
	// Descr: Сравнивает на эквивалентность пакет this с пакетом rS. Без учета LinkFiles!
	//
	bool   FASTCALL IsEq(const PPBrandPacket & rS) const;
	PPBrand    Rec;
	ObjLinkFiles LinkFiles;
	ObjTagList TagL;        // @v11.2.12 Список тегов
};

class PPObjBrand : public PPObjGoods {
public:
	static int FASTCALL Helper_GetRec(const Goods2Tbl::Rec & rGoodsRec, PPBrand * pRec);

	PPObjBrand(void * extraPtr = 0);
	int    Fetch(PPID id, PPBrand * pRec);
	int    Get(PPID, PPBrandPacket *);
	int    Put(PPID *, PPBrandPacket *, int use_ta);
	int    AddSimple(PPID * pID, const char * pName, PPID ownerID, int use_ta);
	int    GetListByFilt(const BrandFilt * pFilt, PPIDArray * pList);
	//
	// Возвращает PPObjListWindow
	//
	virtual void * CreateObjListWin(uint aFlags, void * extraPtr);
private:
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
//
//
typedef PPBrand BrandViewItem;

class PPViewBrand : public PPView {
public:
	struct BrwItem { // @persistent @store(Reference2Tbl)
		explicit BrwItem(const PPBrand * pS);
		PPID   ID;
		PPID   OwnerID;
		long   Flags;
		char   Name[128];
		char   OwnerName[128];
		long   ViewFlags;
		uint   LinkGoodsCount;
	};
	PPViewBrand();
	~PPViewBrand();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(BrandViewItem *);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList();

	SArray * P_DsList;
	BrandFilt Filt;
	PPObjBrand Obj;
};
//
// @vmiller {
// Классы, к оторым относятся составные товары. Перечислены в строковом ресурсе PPTXT_COMPGDS_TYPES
#define SUPRWARECLASS_NUTRITION 1 // Продукты питани
#define SUPRWARECLASS_MEDICAL   2 // Лекарственные препараты
// Типы для составных товаров
#define SUPRWARETYPE_GOODS      1L // Товар
#define SUPRWARETYPE_COMPONENT  2L // Компонент
//
// PPObjSuprWare
// Объект для управления информацией о составе товаров
//
struct PPSuprWare {
	PPSuprWare();
	//
	// Descr: Сравнивает this с rS. Поля ID и Reserve[] в сравнении не участвуют.
	// Returns:
	//   !0 - *this == rS
	//   0  - *this != rS
	//
	int    FASTCALL IsEq(const PPSuprWare & rS) const;

	PPID   ID;             // @id
	char   Name[128];      // Наименование на родном языке
	char   Code[24];       // Код (Stored as Barcode.Code with prefix '~' and Qtty = 1.0)
	PPID   SuprWareType;   // SUPRWARETYPE_XXX (Stored as Goods2Tbl::GoodsTypeID)
	PPID   SuprWareCat;    // SUPRWARECLASS_XX (Stored as Goods2Tbl::WrOffGrpID)
	PPID   ParentID;       //
	long   Flags;          //
	uint8  Reserve[32];    // @reserve
};

struct PPSuprWareAssoc { // @flat
	PPSuprWareAssoc();
	PPSuprWareAssoc & FASTCALL operator = (const PPSuprWareAssoc & rS);
	PPSuprWareAssoc & FASTCALL operator = (const ObjAssocTbl::Rec & rS);

	PPID   GoodsID;
	PPID   CompID;
	PPID   TypeID;
	long   Num;
	PPID   UnitID;   // ИД единицы измерения (используется для записи и извлечения из таблицы ассоциаций)
	double Qtty;
};

class PPSuprWarePacket {
public:
	PPSuprWarePacket();
	void   Init();
	PPSuprWarePacket & FASTCALL operator = (const PPSuprWarePacket & rSrc);

	PPSuprWare Rec;
	TSVector <PPSuprWareAssoc> Items;
};

class PPObjSuprWare : public PPObjGoods {
public:
	PPObjSuprWare(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    Get(PPID goodsID, PPSuprWarePacket * pPack);
	int    Put(PPID * pID, const PPSuprWarePacket * pPack, int use_ta);
	int    PutAssoc(const PPSuprWareAssoc & rItem, int use_ta);
	//
	// Descr: Ищет товар или компонент по коду. Код базового товара хранится в таблице BarcodeTbl с префиксом '~'.
	//
	int    SearchByBarcode(const char * pBarcode, BarcodeTbl::Rec * pBcRec);
	//
	// Descr: Не редактирует запись о товаре, а просто выводит таблицу с его содержанием
	//
	int    EditList(PPID * pID);
	int    GetListByComponent(PPID componentID, PPIDArray & rList);
private:
	static int MakeStorage(PPID id, const PPSuprWare * pRec, Goods2Tbl::Rec * pRawRec, BarcodeArray * pBcList);
	virtual int DeleteObj(PPID id);
};
//
//
//
#pragma pack(push,1)
struct PPComputerCategory {
	PPComputerCategory();
	long   Tag;            // Const=PPOBJ_COMPUTERCATEGORY
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];
	char   CNameTemplate[32]; // Шаблон для автоматического именования компьютеров, принадлежащих категории
	uint8  Reserve[32];    // @reserve
	int32  Val1;
	int32  Val2;
};
#pragma pack(pop)

class PPObjComputerCategory : public PPObjReference {
public:
	explicit PPObjComputerCategory(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    MakeReservedItem(PPID * pID, int use_ta);
private:
	virtual int  MakeReserved(long flags);
};

class ComputerFilt : public PPBaseFilt { // @construction
public:
	ComputerFilt();
	ComputerFilt & FASTCALL operator = (const ComputerFilt & rS);
	virtual bool IsEmpty() const;

	uint8  ReserveStart[28];  // @anchor
	long   Order;             //
	long   Flags;
	SString SrchStr;          // @anchor Строка, содержащаяся в имени
};

struct PPComputer { // @flat
	PPComputer();
	PPComputer & Z();
	bool   FASTCALL IsEq(const PPComputer & rS) const;
	bool   FASTCALL CheckForFilt(const ComputerFilt * pFilt) const;
	PPID   ID;             // @id
	char   Name[128];      // @name
	char   Code[20];       // (Stored as Barcode.Code with prefix '^' and Qtty = 1.0)
	long   Flags;
	PPID   CategoryID;     // ->Reference(PPOBJ_COMPUTERCATEGORY)
	S_GUID  Uuid;
	MACAddr MacAdr;        // 		
	S_IPAddr IpAdr;
};

class PPComputerPacket {
public:
	PPComputerPacket();
	PPComputerPacket & Z();
	bool    FASTCALL IsEq(const PPComputerPacket & rS) const;
	bool    FASTCALL Copy(const PPComputerPacket & rS);

	PPComputer Rec;
	ObjLinkFiles LinkFiles;
	ObjTagList TagL;
};

class PPObjComputer : public PPObjGoods { // @construction
public:
	static  int  Helper_SetRec(const PPComputer * pRec, Goods2Tbl::Rec & rGoodsRec);
	static  int  Helper_GetRec(const Goods2Tbl::Rec & rGoodsRec, PPComputer * pRec);

	PPObjComputer(void * extraPtr = 0);
	~PPObjComputer();
	int    Get(PPID id, PPComputerPacket * pPack);
	int    Put(PPID * pID, PPComputerPacket * pPack, int use_ta);
	//
	// Descr: Находит все идентификаторы компьютеров, имеющих mac-адрес равный rKey.
	//   Предварительно очищает список rIdList.
	// Note: Вообще, все компьютеры должны иметь уникальные mac-адреса, но в реальности
	//   возможны какие-то сбои с работе системы, эксцессы исполнителей и т.д. По-этому
	//   нам нужна функция, которая вернет все идентификаторы записей, имеющих заданный mac-адрес.
	//
	int    GetListByMacAddr(const MACAddr & rKey, PPIDArray & rIdList);
	//
	// Descr: Находит первую запись компьютера, имеющую mac-адрес равный rKey.
	// Note: See note to function GetListByMacAddr
	// 
	int    SearchByMacAddr(const MACAddr & rKey, PPID * pID, PPComputerPacket * pPack);
	int    GenerateName(PPID categoryID, SString & rBuf);
private:
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID id);
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	//
	// Descr: Реализация извлечения записей по критерию равенства mac-адреса.
	//
	int    Implement_GetByMacAddr(const MACAddr & rKey, PPID * pID, PPComputerPacket * pPack, PPIDArray * pIdList);

	PPObjProcessor * P_PrcObj; // Скрытый экземпляр для быстрой обработки сообщений DBMSG_COMPUTERACQUIRECAT
};

typedef PPComputer ComputerViewItem;

class PPViewComputer : public PPView {
public:
	struct BrwItem { // @persistent @store(Reference2Tbl)
		explicit BrwItem(const PPComputerPacket * pS);
		PPID   ID;
		long   Flags;
		PPID   CategoryID; // @v12.2.4
		S_GUID Uuid;       // @v12.2.4
		MACAddr MacAdr;    // @v12.2.4  
		char   Name[128];
		char   CategoryName[48]; // @v12.2.4
		long   ViewFlags;
	};
	PPViewComputer();
	~PPViewComputer();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ComputerViewItem *);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList();

	TSArray <BrwItem> * P_DsList;
	ComputerFilt Filt;
	PPObjComputer Obj;
};
//
// 
//
class SwProgramFilt : public PPBaseFilt { // @construction
public:
	SwProgramFilt();
	SwProgramFilt & FASTCALL operator = (const SwProgramFilt & rS);
	virtual bool IsEmpty() const;

	uint8  ReserveStart[28];  // @anchor
	long   Order;             //
	long   Flags;             // @flags
	SString SrchStr;          // @anchor Строка, содержащаяся в имени
	ObjIdListFilt ParentList;
};

struct PPSwProgram { // @flat
	PPSwProgram();
	PPSwProgram & Z();
	bool   FASTCALL IsEq(const PPSwProgram & rS) const;
	bool   FASTCALL CheckForFilt(const SwProgramFilt * pFilt) const;
	PPID   ID;             // @id
	char   Name[128];      // @name
	char   Code[20];       // (Stored as Barcode.Code with prefix '^' and Qtty = 1.0)
	char   ExeFn[128];     // Имя исполняемого файла (без пути)
	long   Flags;          // @flags
	PPID   CategoryID;     // 
};

class PPSwProgramPacket {
public:
	PPSwProgramPacket();
	PPSwProgramPacket(const PPSwProgramPacket & rS);
	PPSwProgramPacket & Z();
	PPSwProgramPacket & FASTCALL operator = (const PPSwProgramPacket & rS);
	bool    FASTCALL IsEq(const PPSwProgramPacket & rS) const;
	bool    FASTCALL Copy(const PPSwProgramPacket & rS);
	PPSwProgram Rec;
	ObjLinkFiles LinkFiles;
	ObjTagList TagL;
	SString CategoryName_; // @v12.0.4 @transient Поле используется как временное хранилище имени категории при импорте. При извлечении 
		// пакета из базы данных и при сохранении никак не обрабатывается. В методе IsEq не учитывается.
};

class PPObjSwProgram : public PPObjGoods { // @construction
public:
	static int Helper_GetRec(const Goods2Tbl::Rec & rGoodsRec, PPSwProgram * pRec);
	static int Helper_SetRec(const PPSwProgram * pRec, Goods2Tbl::Rec & rGoodsRec);
	static SJson * PackToJson(const PPSwProgramPacket & rPack);
	static int  PackFromJson(const SJson * pJs, const char * pImgPathUtf8, PPSwProgramPacket & rPack);
	static bool MakeImgSymb(SFileFormat fmt, PPID id, SString & rBuf);

	explicit PPObjSwProgram(void * extraPtr = 0);
	~PPObjSwProgram();
	int    Fetch(PPID id, PPSwProgram * pRec);
	int    Get(PPID id, PPSwProgramPacket *);
	int    Put(PPID * pID, PPSwProgramPacket *, int use_ta);
	virtual void * CreateObjListWin(uint aFlags, void * extraPtr);
	SJson * ExportToJson(const char * pImgPath);
	int    ImportFromJson(const SJson * pJs, const char * pImgPathUtf8);
private:
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID id);
};

typedef PPSwProgram SwProgramViewItem;

class PPViewSwProgram : public PPView { // @construction
public:
	struct BrwItem { // @persistent @store(Reference2Tbl)
		explicit BrwItem(const PPSwProgram * pS);
		PPID   ID;
		PPID   CategoryID;
		long   Flags;
		char   Name[128];
		char   ExeFn[128];
		long   ViewFlags;
	};
	PPViewSwProgram();
	~PPViewSwProgram();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(SwProgramViewItem *);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList();
	int    Export();

	SArray * P_DsList;
	SwProgramFilt Filt;
	PPObjSwProgram Obj;
};
//
// Descr: Специализированный блок обработки структур для отображения //
//   Применяется в PPViewGoodsStruc и для отображения иерархии структур.
//
struct GoodsStrucProcessingBlock {
	enum {
		intfMultAssociatedTech = 0x0001, // Со структурой связано более одной ассоциированных технологий
		intfUncertEstPrice     = 0x0002, // @v11.8.2 Ожидаемая цена по структуре не может быть точно вычислена 
	};
	struct ItemEntry {
		PPID   GStrucID;
		PPID   GoodsID;
		long   ItemNo;     // Порядковый номер элемента в структуре [1..]
		long   Flags;
		long   InternalFlags; // @v11.8.2 intfXXX Транзиентные флаги элемента, не связанные с persistent-флагами Flags
		long   StrucFlags; // Для быстрого доступа (дублирует StrucEntry::Flags)
		uint   StrucEntryP;
		double Median;
		double Denom;
		double Netto;
		double EstPrice;   // @v11.8.2
	};
	struct StrucEntry {
		PPID   GStrucID;
		PPID   PrmrGoodsID;
		long   Flags;
		long   InternalFlags; // @v11.7.6 intfXXX Транзиентные флаги элемента, не связанные с persistent-флагами Flags
		PPID   ParentStrucID;
		PPID   GiftQuotKindID;
		PPID   VariedPropObjType;
		PPID   SingleAssociatedTechID; // @v11.7.6 Единственная ассоциированная со структурой технология. 
			// Если ассоциированных технологий больше одной, то устанавливается флаг InterlanFlags{intfMultAssociatedTech}
			// и в это поле заносится первая попавшаяся технология //
		uint   NameP;
		uint   SymbP;
		DateRange Period;
		float  GiftLimit;
		double GiftAmtRestrict;
		double CommDenom;
	};
	GoodsStrucProcessingBlock();
	GoodsStrucProcessingBlock(const GoodsStrucProcessingBlock & rS);
	~GoodsStrucProcessingBlock();
	enum {
		addifCheckExistance = 0x0001,
		addifRecursive      = 0x0002,
		addifMainTreeOnly   = 0x0004,
		addifInitTech       = 0x0008, // @v11.7.6 Инициализировать информацию об ассоциированных технологиях // 
		addifInitEstValue   = 0x0010, // @v11.8.2 Инициализировать ожидаемую цену
	};
	int    AddItem(PPID goodsID, PPID strucID, PPID filtScndGroupID, PPID filtScndID, uint flags/*bool checkExistance, bool recursive*/);
	PPObjGoodsStruc GSObj;
	PPObjGoods GObj;
	PPObjTech * P_TecObj; // @v11.7.6
	TSVector <StrucEntry> StrucList;
	TSArray  <ItemEntry> ItemList; // must be SArray (not SVector), because it'll be handed to AryBrowserDef
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в StrucEntry и ItemEntry
};
//
// Descr: Класс, реализующий построение дерева отображения товарных структур
//
class GoodsStrucTreeListViewBlock {
public:
	explicit GoodsStrucTreeListViewBlock(const GoodsStrucProcessingBlock & rCb);
	StrAssocTree * MakeTree();
	const  GoodsStrucProcessingBlock::ItemEntry * GetEntryByIdx(uint idx) const;
	const  GoodsStrucProcessingBlock::StrucEntry * GetStrucEntryByID(PPID id) const;

	GoodsStrucProcessingBlock Cb; // @todo must be private
private:
	SString & MakeText(const GoodsStrucProcessingBlock::StrucEntry & rSe, SString & rTitleBuf);
	void AddEntry_TopDown(StrAssocTree * pList, uint level, uint idx, const GoodsStrucProcessingBlock::ItemEntry & rEntry, SPtrHandle hParent, LongArray & rRecurList);
	const long ItemOffset;
	SString TitleBuf;
};
//
//
//
#define ALBATROSEXSTR_UHTTURN_unused   1 // 
#define ALBATROSEXSTR_UHTTURLPFX       2 //
#define ALBATROSEXSTR_UHTTACC          3 //
#define ALBATROSEXSTR_UHTTPASSW        4 //
#define ALBATROSEXSTR_EGAISSRVURL      5 // URL сервера обмена данными с системой ЕГАИС
#define ALBATROSEXSTR_VETISUSER        6 //
#define ALBATROSEXSTR_VETISPASSW       7 //
#define ALBATROSEXSTR_VETISAPIKEY      8 //
#define ALBATROSEXSTR_VETISDOCTUSER    9 // 
#define ALBATROSEXSTR_VETISDOCTPASSW  10 // 
#define ALBATROSEXSTR_MQC_HOST        11 // Адрес сервера брокера сообщений
#define ALBATROSEXSTR_MQC_USER        12 // Имя доступа к брокеру сообщений
#define ALBATROSEXSTR_MQC_SECRET      13 // Пароль доступа к брокеру сообщений
#define ALBATROSEXSTR_MQC_DATADOMAIN  14 // Домен данных
#define ALBATROSEXSTR_MQC_VIRTHOST    15 // Виртуальный хост

struct PPAlbatrosCfgHdr { // @persistent @store(PropertyTbl)
	enum {
		fSkipBillWithUnresolvedItems = 0x0001, // При акцепте документов пропускать те, которые имеют не разрешенные товарные позиции
			// Автоматическое создание товаров в этом случае не допускается.
		fRecadvEvalByCorrBill        = 0x0002, // Идентификация расхождения драфт-прихода и учетного документа списания
			// осуществляется не прямым сравнением этих документов, а извлченеием данных из корректирующих
			// накладных, привязанных к учетному документу прихода (если таких нет, то считается, что совпадение полное).
		fUncondAcceptEdiIntrMov      = 0x0004, // Безусловный акцепт внутренних перемещений, продублированных по каналу EDI
		fUseOwnEgaisObjects  = 0x0008, // Использовать собственную базу данных объектов ЕГАИС
		fUseDateInBillAnalog = 0x0010, // Использовать критерий даты при поиске аналога документа
		fStrictExpGtinCheck  = 0x0020, // Строгая проверка передаваемых кодов товара на принадлежность EAN/UPC
		fVetisTestContour    = 0x0040  // Используется тестовый контур ВЕТИС
	};
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_ALBATROSCFG2
	uint32 Size;           // Полный размер записи. Если Size == 0, то запись представлена в формате pre7.2.7 и имеет размер sizeof(PropertyTbl)
	char   Reserve[20];    // @reserve
	int16  VetisCertDelay; // Максимальная задержка в днях от даты выпуска сертификата до получения накладной с ним
		// Примениятся для фильтрации документов при связывании с сертификатами.
	int16  VetisTimeout;   // Таймаут ожидания ответа на application request (секунд). По умолчанию - 60
	PPID   EgaisRetOpID;   // Вид (драфт) операции возврата от покупателя, принятого с сервера ЕГАИС
	long   Flags;          // @flags
	PPID   EgaisRcptOpID;  // ->Ref(PPOBJ_OPRKIND) Вид (драфт)операции прихода от поставщика, принятого с сервера ЕГАИС
    PPID   EdiOrderOpID;   // ->Ref(PPOBJ_OPRKIND)
    PPID   EdiOrderSpOpID; // ->Ref(PPOBJ_OPRKIND)
    PPID   EdiDesadvOpID;  // ->Ref(PPOBJ_OPRKIND)
    PPID   RcptTagID;      // ->Ref(PPOBJ_TAG)
    PPID   TtnTagID;       // ->Ref(PPOBJ_TAG)
	PPID   SmsAccID;	   // ->Ref(PPOBJ_SMSPRVACCOUNT) ИД учетной записи SMS-клиента
	PPID   OpID;           // ->Ref(PPOBJ_OPRKIND)     Вид операции приема заказов
	PPID   MailAccID;      // ->Ref(PPOBJ_MAILACCOUNT) ИД учетной записи электронной почты
};

class PPAlbatrossConfig {
public:
	PPAlbatrossConfig();
	PPAlbatrossConfig & Z();
	int    SetPassword(int fld, const char * pPw);
	int    GetPassword(int fld, SString & rPw) const;
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char * pStr);

	PPAlbatrosCfgHdr Hdr;
	SString ExtString; // Идентификаторы полей: ALBATROSEXSTR_XXX
};

class PPAlbatrosCfgMngr {
public:
	static int Get(PPAlbatrossConfig * pCfg);
	static int Fetch(PPAlbatrossConfig * pCfg); // @macrow
	static int Put(PPAlbatrossConfig * pCfg, int use_ta);
	static int Edit();
	static int Helper_Get(Reference * pRef, PPAlbatrossConfig * pCfg);
	static int Helper_Put(Reference * pRef, PPAlbatrossConfig * pCfg, int use_ta);
	static int MakeCommonMqsConfigPacket(const PPAlbatrossConfig & rCfg, SString & rBuf);
	static int ParseCommonMqsConfigPacket(const char * pBuf, PPAlbatrossConfig * pCfg);
private:
	static int Get(PPAlbatrosCfgHdr * pHdr);
	static int Put(const PPAlbatrosCfgHdr * pHdr, int use_ta);
	static int Helper_Get(Reference * pRef, PPAlbatrosCfgHdr * pHdr);
};
//
//
//
class EgaisPersonCore : public EgaisPersonTbl {
public:
	enum {
		txtprpAddressDescr = (PPTRPROP_USER+1)
	};
	enum {
		rolefManuf     = 0x0001,
		rolefImporter  = 0x0002,
		rolefSupplier  = 0x0004,
		rolefShipper   = 0x0008,
		rolefConsignee = 0x0010,
		rolefVerified  = 0x0200  // Признак верифицированной записи
	};
	struct Item {
		enum {
			cmpfExceptID    = 0x0001,
			cmpfExceptFlags = 0x0002
		};
		Item();
		void   Clear();
		int    IsEq(const Item & rItem, long cmpFlags) const;

		PPID   ID;
		char   RarIdent[16];
		char   INN[16];
		char   KPP[16];
		char   UNP[16];
		char   RNN[16];
		int16  CountryCode;
		int16  RegionCode;
		long   Flags; // rolefXXX
		LDATE  ActualDate;
		SString Name;
		SString FullName;
		SString AddressDescr;
	};
	EgaisPersonCore();
    int    Search(PPID id, EgaisPersonCore::Item &);
    int    SearchByCode(const char * pRarCode, TSVector <EgaisPersonTbl::Rec> & rList);
    //int    SearchByInn
    //
    // Descr: Если для контрагента с ФСРАР-кодом pRarCode существует запись и
    //   эта запись имеет флаг rolefVerified, то функция возвращает (>0).
    //   Если запись не существует или не верифицирована, то (<0).
    //   В случае ошибки - 0.
    //
    int    IsVerifiedCode(const char * pRarCode);
    int    Put(PPID * pID, EgaisPersonCore::Item * pItem, long * pConflictFlags, int use_ta);
    int    RecToItem(const EgaisPersonTbl::Rec & rRec, EgaisPersonCore::Item & rItem);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    Clear(int use_ta);
    int    Export(long fmt, const char * pFileName);
};

class EgaisProductCore : public EgaisProductTbl {
public:
	enum {
		fVerified = 0x0001 // Признак верифицированной записи
	};

	struct Item {
		enum {
			cmpfExceptID = 0x0001
		};
		Item();
		void   Clear();
		int    IsEq(const Item & rItem, long cmpflags) const;

		PPID   ID;
		char   AlcoCode[24];
		char   ManufRarIdent[16];
		char   ImporterRarIdent[16];
		char   CategoryCode[8];
		long   Flags;
		double Proof;
		double Volume;
		LDATE  ActualDate;
		SString Name;
		SString FullName;
	};
	EgaisProductCore();
	int    RecToItem(const EgaisProductTbl::Rec & rRec, EgaisProductCore::Item & rItem);
    int    Search(PPID id, EgaisProductCore::Item & rItem);
    int    SearchByCode(const char * pAlcoCode, TSVector <EgaisProductTbl::Rec> & rList);
    //
    // Descr: Если для товара с ФСРАР-кодом pAlcoCode существует запись и
    //   эта запись имеет флаг fVerified, то функция возвращает (>0).
    //   Если запись не существует или не верифицирована, то (<0).
    //   В случае ошибки - 0.
    //
    int    IsVerifiedCode(const char * pAlcoCode);
    int    Put(PPID * pID, const EgaisProductCore::Item * pItem, long * pConflictFlags, int use_ta);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    Clear(int use_ta);
    int    Export(long fmt, const char * pFileName);
};

class EgaisRefACore : public EgaisRefATbl {
public:
	//
	// Descr: Флаги записи таблицы EgaisRefA
	//
	enum { // @persistent
		fVerified = 0x0001 // Данные записи верифицированы запросом к ЕГАИС.
			// Поле EgaisRefA::ActualDate указывает на дату верификации.
	};
    EgaisRefACore();
    static int FASTCALL IsRecEq(const EgaisRefATbl::Rec & rR1, const EgaisRefATbl::Rec & rR2);
    int    Search(PPID id, EgaisRefATbl::Rec * pRec);
    //
    // Descr: Возвращает список записей справок А с кодом pRefACode.
    // Returns:
    //   <0 - нет ни одной записи с кодом pRefACode
    //    0 - error
    //   >0 - найдена одна или более записей с кодом pRefACode. Возвращенное значение
    //     равно индексу наиболее актуальной записи max(ActualDate), увеличенному на 1.
    //     То есть, rList[ret-1] соответствует наиболее актуальному элементу массива.
    //
    int    SearchByCode(const char * pRefACode, TSVector <EgaisRefATbl::Rec> & rList);
    int    SearchByProductCode(const char * pAlcoCode, TSVector <EgaisRefATbl::Rec> & rList);
    int    Put(PPID * pID, const EgaisRefATbl::Rec * pRec, long * pConflictFlags, int use_ta);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    Clear(int use_ta);
    int    Export(long fmt, const char * pFileName);
};

class PrcssrAlcReport {
public:
	friend class DL6ICLS_PrcssrAlcReport;
	//
	// Descr: Конфигурация алкогольной декларациия. Используется для конфигурирования формирования алкогольной
	//   декларации, обмена с ЕГАИС а так же некоторых аспектов работы VETIS.
	//
	class Config { // @persistent
	public:
		Config();
		Config(const Config & rS);
		~Config();
		Config & FASTCALL operator = (const Config & rS);
		Config & Z();
		int    FASTCALL Copy(const Config & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fDetectAlcByClass = 0x0001, // Идентифицировать алкогольную продукцию по принадлежности классу ExtBlock::AlcGoodsClsID.
				// Если флаг не установлен или AlcGoodsClsID == 0, то - по принадлежности группе AlcGoodsGrpID
			fWhToReg2ByLacks  = 0x0002, // Передавать остатки ЕГАИС со склада на регистр 2 по отрицательным значениям в текущих остатках ЕГАИС
				// на регистре 2.
			fEgaisVer2Fmt     = 0x0004, // Применять 2-ю версию форматов ЕГАИС
			fEgaisVer3Fmt     = 0x0008, // Применять 3-ю версию форматов ЕГАИС (автоматически отменяет fEgaisVer2Fmt для тех документов, к которым применим 3-й формат).
			fInvcCodePref     = 0x0010, // @v11.0.8 Если в документе есть номер счет-фактуры, то использовать его вместо номера документа
			fEgaisVer4Fmt     = 0x0020, // @v11.0.11 Применять 4-ю версию форматов ЕГАИС
			fNMarkedBalance   = 0x0040  // @v11.7.12 Немаркированную продукцию уравнивать по остаткам (дополнение к опции woswByCChecks)
		};
		//
		// Descr: Варианты списания остатков с регистра 2 ЕГАИС
		//
		enum {
			woswNone = 0,         // Не списывать
			woswBalanceWithLots,  // Приводить в соответствие с текущими остатками по лотам
			woswByCChecks,        // Списывать продажи по чекам
			woswByBills           // Списывать продажи по документам
		};

		SVerT  Ver;                  // Версия системы, создавшая экземпляр объекта
		PPID   RcptOpID;             // Операция прихода от поставщика
		PPID   SaleRetOpID;          // Операция возврата от покупателя
		PPID   RcptEtcOpID;          // Операция прочего прихода
		PPID   ExpndOpID;            // Операция расхода
		PPID   SupplRetOpID;         // Операция возврата поставщику
		PPID   ExpndEtcOpID;         // Операция прочего расхода
		PPID   IntrExpndOpID;        // Операция внутреннего перемещения
		PPID   AlcGoodsGrpID;        // Товарная группа, ограничивающая алкогольную продукцию
		PPID   BeerGoodsGrpID;       // Товарная группа, ограничивающая пивную продукцию
		PPID   CategoryTagID;        // Тег, определяющий категорию вида продукции (имеет приоритет перед CategoryClsDim)
		int16  CategoryClsDim;       // PPGdsCls2::e... Размерность класса, определяющая категорию алкогольной продукции
		int16  VolumeClsDim;         // PPGdsCls2::e... Размерность класса, определяющая объем алкоголя в одной торговой единице
		PPID   AlcLicRegTypeID;      // Тип регистра алкогольной лицензии
		PPID   KppRegTypeID;         // Тип регистра КПП. Если 0, то используется зарезервированный тип регистра для КПП.
		int32  KppDlvrExt;           // Дополнительное поле адреса, содержащее КПП этого адреса (устарело - с приоритетом используется регистр адреса)
		PPID   WhsExpTagID;          // Тег персоналии Оптовый покупатель/Экспорт (1/2)
		PPID   ManufImpTagID;        // Тег персоналии Производитель/Импортер (1/2)
		char   SubstCategoryCode[8]; // Код алкогольной продукции, используемый в некоторых случаях вместо любого иного кода
		//
		// Блок для расширения структуры "плоскими" данными
		//
		struct ExtBlock {
			PPID   TransportLicRegTypeID;
			PPID   AlcGoodsClsID; // ИД класса алкогольной продукции
			int16  ProofClsDim;   // PPGdsCls2::e... Размерность класса, определяющая крепость алкоголя в одной торговой единице (в объемных %)
			uint16 Reserve2;
			PPID   ImporterPersonKindID; // Вид персоналии, идентифицирующий импортера
			long   Flags;                //
			long   WrOffShopWay;         //
			PPID   EgaisInvOpID;         // Вид операции инвентаризации - необходим для идентификации видов операций
				// списания излишков и недостач.
            TimeRange RtlSaleAllwTime;   // Время, в течении которого разрешена розничная торговля алкоголем
			PPID   ManufOpID;            // Вид операции производства (PPOPT_GOODSMODIF). Используется для обмена с ВЕТИС
			PPID   SupplAgentID;         // @v11.0.8 ->Article.ID Агент поставщика
			uint8  Reserve[20];          // @v11.0.8 [24]-->[20]
		};
		ExtBlock  E;                 // @anchor
		PPIDArray StorageLocList;    // @anchor
		PPIDArray LotManufTagList;   // Список тегов лотов, хранящих производителя/импортера товара
		CCheckFilt * P_CcFilt;       // Фильтр по кассовым чекам для списания с регистра 2
	};

	struct EgaisMarkBlock {
		EgaisMarkBlock();
		int16  Ver; // Первые два символа марки
		SString EgaisCode; // Код продукции по ЕГАИС
	};

    static int FASTCALL ReadConfig(Config * pCfg);
    static int FASTCALL WriteConfig(Config * pCfg, int use_ta);
	static int EditConfig();
	static int AutoConfigure(long flags);
	//
	// Descr: Функция определяет является ли строка pMark валидным номером алкогольной акцизной марки.
	//   Если параметр pProcessedMark != 0, то при правильной длине и нахождении в коде pMark недопустимого
	//   символа функция пытается спроецировать этот символ на латинский в соответствии с текущей
	//   раскладкой клавиатуры. Если все такие попытки оказались успешными, то преобразованный код
	//   марки заносится в буфер *pProcessedMark. Если все же pMark имеет недопустимый формат, то
	//   *pProcessedMark при выходе из функции содержит пустую строку.
	//
	static bool FASTCALL IsEgaisMark(const char * pMark, SString * pProcessedMark);
	static int  ParseEgaisMark(const char * pMark, EgaisMarkBlock & rMb);
	//
	// Descr: Определяет относится ли код категории алкогольной продукции pCode
	//   к пиву и иной пивной продукции (пиво, пуаре, медовуха и пр.)
	//   Функция применяется для автоматического разделения операций по товарам
	//   с целью правильного формирования регламентированных отчетов.
	//
	static int FASTCALL IsBeerCategoryCode(const char * pCode);

    PrcssrAlcReport();
    ~PrcssrAlcReport();
    //
    // Descr: Устанавливает параметры конфигурации.
    //   Если pCfg != 0, то устанавливаются внешние параметры, в противном случае функция считывает
    //   конфигурацию из базы данных методом PrcssrAlcReport::ReadConfig
    //
    int    SetConfig(const Config * pCfg);
    int    ValidateConfig(const Config & rCfg, long flags);
	const  Config & GetConfig() const { return Cfg; }
	int    UseOwnEgaisObjects() const;//  BIN(ACfg.Hdr.Flags & ACfg.Hdr.fUseOwnEgaisObjects && P_RefC);

    struct GoodsItem {
    	GoodsItem();
    	GoodsItem & Z();

    	enum {
    		stClass                = 0x0001,  // Товар классифицирован
    		stCategoryCodeByLotTag = 0x0002,  // Код категории продукции извлечен из тега лота
    		stCategoryCodeByClsDim = 0x0004,  // Код категории продукции извлечен из классификатора-размерности
    		stCategoryName         = 0x0008,  // Наименование категории продукции успешно идентифицировано
    		stRefcUsedByGoodsCode  = 0x0010,  // Поля с префиксом Refc инициализированы исходя из GoodsItem::EgaisCode
    		stRefcUsedByRefA       = 0x0020,  // Поля с префиксом Refc инициализированы исходя из GoodsItem::InformA
    		stEgaisCodeByLotTag    = 0x0040,  // ЕГАИС-код товара получен из лота (более надежный вариант, нежели stEgaisCodeByGoods)
    		stEgaisCodeByGoods     = 0x0080,  // ЕГАИС-код товара получен как один из кодов товара (менее надежный вариант, нежели stEgaisCodeByLotTag)
    		stRefcInfAPrManufConfl = 0x0100,  // Конфликт в справочнике ЕГАИС между кодом производителя в справка А и записе товара
    		stRefcInfAPrImprtConfl = 0x0200,  // Конфликт в справочнике ЕГАИС между кодом импортера в справка А и записе товара
    		stRefcPrDbCategConfl   = 0x0400,  // Конфликт между видом продукции в базе данных и записе товара ЕГАИС
    		stMarkWanted           = 0x0800   // Товар маркированный (имеет акцизную марку)
    	};
    	long   StatusFlags;
    	PPID   GoodsID;
    	PPID   LotID;
    	PPID   MnfOrImpPsnID;   // ИД персоналии производителя или импортера (для импортного товара)
    	double Volume;
    	double Brutto;
    	double Proof;           // Крепость в объемных процентах
    	uint   CategoryCodePos; // Позиция (1..) кода категории в PrcssrAlcReport::CategoryNameList
    	double UnpackedVolume;  // Если товар имеет единицу измерения, производную от литра (PPUNIT_LITER),
			// то считается не неупакованным и измеряется в литрах. В этом случае это поле содержит
			// количество литров в одное торговой единице (PPUnit::BaseRatio). В противном случае это поле 0.0
		LDATE  BottlingDate;    // Дата розлива
		int    CountryCode;     // Код страны-производителя
		int    OuterUnpackedTag; // При извлечении данных о товаре из внешнего источника
			// был детектирован признак Unpacked (не упакованная алкогольная продукция)
    	SString CategoryCode;
    	SString CategoryName;
    	SString MsgPool;   // Список сообщений, разделенных символом '\t'
    	SString EgaisCode; // Код товара в системе ЕГАИС
    	SString InformA;   // Код справки А
    	SString InformB;   // Код справки Б
    	//
    	// Descr: Следующие поля извлекаются из внутренних таблиц базы данных,
    	//   отражающих значения, хранящиеся в ЕГАИС.
    	//   До тех пор, пока не получим высокого уровня надежности кода, использующего
    	//   такие данные, эти поля будут дублировать соответствующие, определенные выше.
    	// Note: Какие-либо действия по извлечению этих полей предпринимаются только
    	//   если установлен флаг PPAlbatrossConfig::Hdr::fUseOwnEgaisObjects
    	//
    	LDATE  RefcInfA_ActualDate;
    	LDATE  RefcPr_ActualDate;
    	PPID   RefcProductID;
    	PPID   RefcManufID;
    	PPID   RefcImporterID;
    	PPID   RefcInfAID;
        double RefcVolume;
        double RefcProof;
        SString RefcCategoryCode;
    	SString RefcEgaisCode;
    	SString RefcManufCode;
    	SString RefcImporterCode;
    };

	int    Init();

	enum {
		pgifUseSubstCode          = 0x0001,
		pgifForceUsingInnerDb     = 0x0002,
		pgifUseInnerDbByGoodsCode = 0x0004  // @v11.3.8 Искать информацию во внутренней ДБ ЕГАИС по коду товара, если не определен лот
	};

	int    GetEgaisCodeList(PPID goodsID, BarcodeArray & rList);
    int    PreprocessGoodsItem(PPID goodsID, PPID lotID, const ObjTagList * pTags, long flags, GoodsItem & rItem);
    int    FASTCALL IsStorageLoc(PPID locID) const;
    int    FASTCALL IsStorageBillLoc(PPID billID);
    //
    // Descr: Определяет является ли товар goodsID алкогольным
    //
    int    FASTCALL IsAlcGoods(PPID goodsID);
    //
    // Descr: Возвращает список алкогольных товаров из базы данных.
    //   Результирующий список отсортирован и не содержит дубликатов.
    //
    int    FASTCALL GetAlcGoodsList(PPIDArray & rList);
    //
    // Descr: Возвращает тип персоналии-источника происхождения алкоголя.
    // Returns:
    //   1 - производитель
    //   2 - импортер
    //  <0 - не возможно идентифицировать
    //   0 - error
    // Note: Идентификация осуществляется по тегу Config::ManufImpTagID или
    //   по принадлежности виду
    //
    int    FASTCALL GetManufPersonType(PPID personID);
    int    GetLotManufID(PPID lotID, PPID * pManufID, SString * pMsgBuf);
    int    GetCategoryNameByCodePos(uint codePos, SString & rBuf);
    int    GetCategoryNameByCode(const char * pCode, SString & rBuf);
    int    SearchGoodsByRarCode(const char * pCode, PPID * pGoodsID);
    int    SearchPersonByRarCode(const char * pCode, PPID * pPsnID, PPID * pLocID);
	int    GetEgaisPersonByCode(const char * pCode, EgaisPersonCore::Item & rItem);

    enum {
    	wkrAlcLic       = 1,
    	wkrKPP  = 2,
    	wkrTransportLic = 3
    };
    PPID   FASTCALL GetWkrRegisterTypeID(int wkr) const;
    int    GetWkrRegister(int wkr, PPID psnID, PPID locID, LDATE dt, RegisterTbl::Rec * pRec);
    int    GetWkrRegisterList(int wkr, PPID psnID, PPID locID, LDATE dt, RegisterArray * pList);
    int    GetWkrRegisterListByPeriod(int wkr, PPID psnID, PPID locID, const DateRange & rPeriod, RegisterArray * pList);
    //
    // Descr: Источники идентификации регистра алкогольной лицензии
    //
    enum {
    	licsrcObject  = 1, // Контрагент по документу
    	licsrcDlvrLoc = 2, // Адрес доставки
    	licsrcBillExt = 3  // Прямая ссылка на лицензию в атрибуте документа
    };

    int    GetBillLic(PPID billID, PPID * pRegID, RegisterTbl::Rec * pRegRec);
    int    FetchRegister(PPID regID, PPID psnID, PPID locID, RegisterTbl::Rec * pRegRec);

	PPObjPerson PsnObj;
	PPObjGoods GObj;
	PPObjGoodsClass GcObj;
	PPObjTag TagObj;
	PPObjAccSheet AcsObj;
	PPObjArticle ArObj;
protected:
	class RefCollection {
	public:
		RefCollection();
		int    FASTCALL SetPerson(const EgaisPersonCore::Item & rItem);
		int    FASTCALL SetProduct(const EgaisProductCore::Item & rItem);
		int    FASTCALL SetRefA(EgaisRefATbl::Rec & rItem);
		int    Store(int use_ta);

		TSCollection <EgaisPersonCore::Item> PersonList;
		TSCollection <EgaisProductCore::Item> ProductList;
		TSVector <EgaisRefATbl::Rec> RefAList;
		int    LastPersonP;
		int    LastProductP;
		int    LastRefAP;
		EgaisProductCore PrC;
		EgaisPersonCore  PsC;
		EgaisRefACore    RaC;
	};

	int    ProcessRegisterRec(RegisterTbl::Rec * pRegRec, PPID psnID, PPID locID);

    StrStrAssocArray CategoryNameList;
	Config Cfg;
	PPAlbatrossConfig ACfg;
	PPObjBill * P_BObj;
	RefCollection * P_RefC;
private:
	PPIDArray AlcGoodsList;
	PPIDArray BeerGoodsList;
};
//
// @ModuleDecl(PPViewGoods)
//
struct GoodsViewItem : public Goods2Tbl::Rec {
	char   Barcode[24];    //
	long   Brutto;         //
	PPDimention PckgDim;   //
	PPDimention RtlDim;    // Габаритные размеры торговой единицы, мм
	int16  ExpiryPeriod;   // Срок годности товара (дней).
	int16  GseFlags;       //
	double MinStock;
	double Package;
	double MinShippmQtty;  // Минимальное количество, которое можно отгрузить в одном документе
	char   StrucType[16];
	PPID   AssocLocID;     // @v11.5.8 Ассоциированная с товаром локация (если GoodsFilt::Flags2 & GoodsFilt::f2ShowWhPlace)
};

class PPViewGoods : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,  // Внутренние сортировки, для отображения в списках
		OrdByName,
		OrdByAbbr,
		OrdByGrp_Name,
		OrdByGrp_Abbr,
		OrdByBarcode,      // Сортировка на выбор пользователем, включая OrdByName
		OrdByBrand_Name,
		OrdByBarcode_Name,
		OrdByID,           // @v11.7.12 Сортировка строго по идентификатору
		OrdByManuf_Name,   // @v11.8.4  Сортировка по производителю и наименованию //
	};
	PPViewGoods();
	~PPViewGoods();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual const IterCounter & GetCounter() const;
	int    InitIteration(int aOrder = OrdByName);
	int    FASTCALL NextIteration(GoodsViewItem *);
	int    ChangeOrder(PPViewBrowser * pW);
	int    PrintPLabel(PPID goodsID);
	// @v11.2.8 PPObjGoods * GetObj();
	int    AddItem(GoodsListDialog ** ppDlgPtr, PPViewBrowser * pBrw, PPID * pID);
	int    DeleteItem(PPID);
	int    Transmit(PPID);
	int    Repair(PPID);
	void   PrintLabel(PPID);
	void   ViewGenMembers(PPID);
	int    RemoveAll();
	bool   IsAltFltGroup();
	bool   IsGenGoodsFlt() const;
	int    ReplaceNames();
	int    AddBarcodeCheckDigit();
	int    AddGoodsFromBasket();
	//
	// Descr: Изменяет флаги выборки товаров,
	//   предварительно запросив изменяемые флаги у пользователя //
	//
	int    UpdateFlags();
	int    UpdateTempTable(PPID goodsID, PPViewBrowser * pBrw);
	//
	// Descr: экспортирует товары
	//
	int    Export(const PPGoodsImpExpParam * pExpCfg);
	int    ExportUhtt();
	//
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser *);
	int    CreateTempTable(IterOrder ord, TempOrderTbl ** ppTbl);
	PPViewGoods::IterOrder GetIterOrder() const;
	bool   IsTempTblNeeded(); // not const function
	void   MakeTempRec(const Goods2Tbl::Rec &, TempOrderTbl::Rec *);
	int    InitGroupNamesList();
	void   RemoveTempAltGroup();
	int    NextInnerIteration(int initList, GoodsViewItem *);
	void   Test_EgaisMarkAutoSelector(PPID goodsID);

	struct GoodsMoveParam {
		GoodsMoveParam();
		enum {
			aRemoveAll = 1,
			aMoveToGroup,
			aChgClssfr,
			aActionByFlags,
			aActionByRule,
			aChgMinStock,
			aSplitBarcodeItems, //
			aMergeDiezNames,    //
			aChgTaxGroup,       //
			aChgGoodsType,      //
			aAssignCodeByTemplate, //
			aSetAlcoCategory    // @v11.3.8
		};
		enum {
			fMassOpAllowed  = 0x0001,
			fAltGroup       = 0x0002,
			fRemoveExtTextA = 0x0004,
			fRemoveExtTextB = 0x0008,
			fRemoveExtTextC = 0x0010, //
			fRemoveExtTextD = 0x0020, //
			fRemoveExtTextE = 0x0040, //
			fInit           = 0x0080  // Структура была иницализирована (может быть использована для редактирования)
		};
		long   Action;
		PPID   DestGrpID;
		long   Flags;
		long   ClsDimZeroFlags;
		double RValue;
		GoodsExtTbl::Rec Clssfr;
		SString Rule;
		ObjIdListFilt LocList;
	};
	PPObjGoods GObj;
	PPObjPerson PsnObj;    // Используется неявно для извлечения имени производителя в броузере
	GoodsFilt  Filt;
	GoodsToObjAssoc * P_G2OAssoc; // @v11.5.8
	TempOrderTbl  * P_TempTbl;
	GoodsIterator * P_Iter;
	BarcodeArray BarcodeAry;
	GoodsViewItem IterCurItem;
	uint   BrcIdx;
	SString IterGrpName;
	GoodsMoveParam GmParam;
	static int DynFuncStrucType;
	static int DynFuncAssocLoc; // @v11.5.8
	enum {
		stCtrlX     = 0x0002,
	};
	long   State; // @v12.0.9
};
//
// @ModuleDecl(PPViewGoodsStruc)
//
class GoodsStrucFilt : public PPBaseFilt {
public:
	GoodsStrucFilt();
	enum {
		fShowComplDecompl   = 0x0001, // Показывать структуры комплектации/декомплектации
		fShowPartitial      = 0x0002, // Показывать частичные структуры
		fShowSubst          = 0x0004, // Показывать подстановочные структуры
		fShowGift           = 0x0008, // Показывать подарочные структуры
		fShowComplex        = 0x0010, // Показывать комплексные структуры
		fShowUnrefs         = 0x0020, // Показывать структуры, на которые не ссылается ни один товар
		fSkipByPassiveOwner = 0x0040, // Не показывать структуры, все товары-владельцы которых пассивные
		fShowTech           = 0x0080, // @v11.7.6 Показывать связанные технологии
		fShowEstValue       = 0x0100  // @v11.8.2 Показывать оценочную стоимость структуры
	};
	char   ReserveStart[32]; // @anchor
	PPID   PrmrGoodsGrpID;
	PPID   PrmrGoodsID;
	PPID   ScndGoodsGrpID;
	PPID   ScndGoodsID;
	long   StrucFlagSet;
	long   StrucFlagReset;
	long   ItemFlagSet;
	long   ItemFlagReset;
	long   Flags;            // @flags
	long   InitOrder;        // Порядок сортировки PPViewGoodsStruc::OrdXXX
	long   ReserveEnd;       // @anchor
};

struct GoodsStrucViewItem {
	PPID   GStrucID;
	PPID   PrmrGoodsID;
	long   StrucFlags;
	PPID   ParentStrucID;
	PPID   GiftQuotKindID;
	PPID   VariedPropObjType;
	char   StrucName[48];
	char   StrucSymb[20];
	DateRange Period;
	float  GiftLimit;
	double GiftAmtRestrict;
	double CommDenom;
	PPID   GoodsID;
	long   ItemFlags;
	double Median;
	double Denom;
	double Netto;
};

class PPViewGoodsStruc : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByPrmrGoodsName,
		OrdByScndGoodsName,
		OrdByStrucTypePrmrGoodsName
	};
	static int FASTCALL Cmp_ItemEntry(const PPViewGoodsStruc * pView, int order, const void * p1, const void * p2);

	PPViewGoodsStruc();
	~PPViewGoodsStruc();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void ViewTotal();
	int    InitIteration();
	int    FASTCALL NextIteration(GoodsStrucViewItem *);
	IterOrder GetCurrentViewOrder() const { return CurrentViewOrder; }
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
	int    CmpSortIndexItems(PPViewBrowser * pBrw, const GoodsStrucProcessingBlock::ItemEntry * pItem1, const GoodsStrucProcessingBlock::ItemEntry * pItem2);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int    FASTCALL _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	//int    UpdateTempTable(PPID goodsID, PPID parentStrucID, PPID strucID, int goodsIsItem, int use_ta);
	//int    AddItem(PPID goodsID, PPID strucID, int checkExistance);
	int    Transmit(PPID /*id*/);
	int    Recover();
	int    MakeList(PPViewBrowser * pBrw);
	int    SortList(PPViewBrowser * pBrw);
	int    MakeTreeListView(PPViewBrowser * pBrw); // @v11.1.12 @construction

	uint    IterIdx;
	IterOrder CurrentViewOrder;
	GoodsStrucFilt Filt;
	GoodsStrucProcessingBlock Cb;
	TSArray  <GoodsStrucProcessingBlock::ItemEntry> * P_DsList__;
	TSCollection <PPObjGoodsStruc::CheckGsProblem> Problems; // Список проблем, выявленных функцией Recover()
	void * H_AsideListWindow; // @v11.1.12 Список иерархии структур
};
//
// @ModuleDecl(PPViewGoodsToObjAssoc)
//
struct GoodsToObjAssocFilt : public PPBaseFilt {
	GoodsToObjAssocFilt();

	enum {
		fDestroyExtraParam = 0x0001
	};
	char   ReserveStart[32]; // @anchor
	PPID   AsscType;         //
	PPID   ObjType;          //
	PPID   ObjID;            //
	void * ExtraPtr;         //
	long   Flags;            //
	long   Reserve;          // @anchor
	LocationFilt * P_LocF;   //
};

struct GoodsToObjAssocViewItem {
	PPID   GoodsID;
	PPID   ObjID;
	char   GoodsName[128];
	char   ObjName[128];
};

class PPViewGoodsToObjAssoc : public PPView {
public:
	PPViewGoodsToObjAssoc();
	~PPViewGoodsToObjAssoc();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt * pFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(GoodsToObjAssocViewItem *);
private:
	struct BrwHdr {
		PPID   GoodsID;
		PPID   ObjID;
	};
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    AddItem(PPViewBrowser * pBrw);
	int    EditItem(PPViewBrowser * pBrw, const BrwHdr *);
	int    DeleteItem(const BrwHdr *);
	int    EditGoodsToObjAssoc(LAssoc * pData, PPID objType, void * extraPtr, bool newItem);
	void   UpdateOnEdit(PPViewBrowser * pBrw);

	GoodsToObjAssocFilt Filt;
	GoodsToObjAssoc * P_Assoc;
	uint   IterIdx;
	PPObject * P_AsscObj; // Ассоциированный с товаром объект (фоновый экземпляр для ускорения)
};
//
// Descr: Класс, управляющий информацией о загрузке данных на кассы, весы и, возможно,
//   другие устройства.
//   Класс используется двумя способами:
//   1. Фиксация информации о загрузке устройства.
//      DeviceLoadingStat dls;
//      PPID stat_id = 0;
//      dls.StartLoading(&stat_id, 1 /* cash_node */, cashNodeID, 0);
//      for(;;) {
//        DeviceLoadingStat::GoodsInfo dls_item;
//        // заполняем dls_item
//        dls.RegisterGoods(stat_id, &dls_item);
//      }
//      dls.FinishLoading(stat_id, 1, 0);
//   2. Извлечение информации об объектах, загруженных на устройства
//
enum DvcTypes {
	dvctCashs = 1,
	dvctScales
};

class DeviceLoadingStat : public DvcLoadingStatTbl {
public:
	struct GoodsInfo {
		PPID   ID;
		char   Name[64];
		long   PLU;
		double Price;
	};
	struct SCardInfo {
		PPID   ID;
		char   Code[32];
		double Discount;
	};
	DeviceLoadingStat();
	int    StartLoading(PPID * pStatID, int deviceType, PPID deviceID, int use_ta);
	int    RegisterGoods(PPID statID, const GoodsInfo *);
	int    RegisterSCard(PPID statID, const SCardInfo *);
	int    RegisterBillList(PPID statID, const PPIDArray & rBillList);
	int    FinishLoading(PPID statID, int status, int use_ta);
	int    Search(PPID statID, DvcLoadingStatTbl::Rec *);
	PPID   GetCurStatID() const { return StatID; }
	//
	// Descr: Ищет последнюю запись по устройству типа dvcType с идентификатором dvcID,
	//   имеющую статус !0.
	// ARG(dvcType  IN): Тип устройства (1 - касса, 2 - весы).
	// ARG(dvcID    IN): ИД устройства
	// ARG(rDtm     IN): Функция ищет запись по указанному устройству до момента, не превышающего
	//   этот параметр. Если rDtm.d == 0, то поиск ведется с конца таблицы без ограничения по дате и времени.
	// ARG(pStatID OUT): @#{vptr0} Указатель на идентификатор найденной записи.
	// ARG(pRec    OUT): @#{vptr0} Указатель на буфер, в котором функция сохранит найденную запись
	// Returns:
	//   >0 - Требуемая запись найдена
	//   <0 - Нет ни одной подходящей записи
	//   0  - Ошибка
	//
	int    GetLast(int dvcType, PPID dvcID, const LDATETIME & rDtm, PPID * pStatID, DvcLoadingStatTbl::Rec * pRec);
	//
	// Descr: Ищет запись, предшествующую записи curStatID по тому же устройству.
	//   Если curStatID == 0, то функция ищет запись, предшествующую this->StatID
	//
	int    GetPrev(PPID curStatID, PPID * pStatID, DvcLoadingStatTbl::Rec * pRec);
	int    GetLastObjInfo(int dvcType, PPID dvcID, PPID objType, PPID objID, LDATE dt, DlsObjTbl::Rec * pRec);
	int    GetLastObjInfo(PPID objType, PPID objID, LDATE dt, DlsObjTbl::Rec * pRec);
		// @>>GetLastObjInfo(int, PPID, PPID, PPID, LDATE, DlsObjTbl::Rec *)
	int    GetUpdatedObjects(PPID objType, const LDATETIME & since, PPIDArray * pObjList);
	int    GetExportedObjectsSince(PPID objType, PPID sinceDlsID, PPIDArray * pObjList);
	int    GetExportedItems(PPID statID, PPID objType, TSVector <DlsObjTbl::Rec> & rList);
	//
	// Descr: Возвращает список идентификаторов документов, повлиявших на выбор товаров
	//   для обновления statID.
	// Returns:
	//   >0 - найден по крайней мере один искомый идентификатор документа
	//   <0 - ничего не найдено
	//    0 - error
	//
	int    GetBillList(PPID statID, PPIDArray & rList);
	int    DoMaintain(LDATE toDt);
		// @>>DoDBMaintain
	int    Remove(PPID id, int useTa);
private:
	int    Fetch(PPID statID, DvcLoadingStatTbl::Rec * pRec);
	int    CutTables(short dvcType, int use_ta);

	DlsObjTbl DlsoT;
	PPID   StatID;         // Текущая обрабатываемая сессия //
	long   StartClock;
	RAssocArray SCardList;
	SVector GoodsList;
	SVector StatCache;
	PPIDArray UpdatedBillList;
};
//
// Descr: Класс AsyncCashGoodsGroupIterator, испольуемый для экспорта товарных групп в асинхронный кассовый модуль.
//
struct AsyncCashGoodsGroupInfo {
	AsyncCashGoodsGroupInfo();
	void   Init();

	PPID   ID;
	char   Name[128];   // @name
	PPID   ParentID;    // ИД родительской группы
	PPID   UnitID;      // ИД торговое единицы измерения
	long   DivN;        // Номер отдела
	double VatRate;     // Ставка НДС (%)
	char   Code[32];    // Код группы
	uint   Level;
	const  PPQuotArray * P_QuotByQttyList;
};

class AsyncCashGoodsGroupIterator {
public:
	AsyncCashGoodsGroupIterator(PPID cashNodeID, long flags, DeviceLoadingStat * pDls, const PPIDArray * pTermGrpList = 0);
	~AsyncCashGoodsGroupIterator();
	int    Init(PPID cashNodeID, long flags, DeviceLoadingStat * pDls, const PPIDArray * pTermGrpList = 0);
	int    Next(AsyncCashGoodsGroupInfo *);
private:
	int    MakeGroupList(StrAssocArray * pTreeList, PPID parentID, uint level); // @recursion

	uint   Pos;
	long   Flags;
	PPID   CashNodeID;
	PPAsyncCashNode AcnPack;
	PPObjGoods GObj;
	SArray    * P_GrpList;
	PPQuotArray QuotByQttyList; // Список котировок, применяемых для скидки на кол-во товаров из группы
	DeviceLoadingStat * P_Dls;  // @notowned
};
//
// Descr: Служебный класс AsyncCashGoodsIterator предназначен для экспорта
//   данных в асинхронную кассовую сессию
//
struct AsyncCashGoodsInfo { // @transient
	DECL_INVARIANT_C();
	AsyncCashGoodsInfo();
	AsyncCashGoodsInfo & Z();
	int    AdjustBarcode(int chkDig);

	enum {
		fDeleted         = 0x0001,
		fGMarkedType     = 0x0002,
		fGMarkedCode     = 0x0004,
		fGExciseProForma = 0x0008  // @v11.7.10 Формально подакцизный товар
	};
	PPID   ID;
	char   Name[128];        //
	char   Abbr[128];        //
	PPID   ParentID;         // ->Goods2.ID Родительская товарная группа
	PPID   UnitID;           // ->Unit.ID Единица измерения //
	PPID   PhUnitID;         // ->Unit.ID Физическая единица измерения
	double PhUPerU;          // ->Unit.ID Соотношение физических единиц к торговым
	PPID   ManufID;          // ->Person.ID ИД производителя товара
	PPID   GdsClsID;         // ->Ref(PPOBJ_GOODSCLASS) ИД класса товара
	PPID   GoodsTypeID;      // ->Ref(PPOBJ_GOODSTYPE) ИД типа товара
	char   BarCode[24];      // Штрихкод
	char   PrefBarCode[24];  // Предпочтительный штрихкод
	double UnitPerPack;      // Емкость упаковки
	double Cost;             // Цена поступления //
	double Price;            // Цена реализации
	double ExtQuot;          // Специальная цена (соответствует котировке типа PPCashNode.ExtQuotID)
	double Rest;             // Остаток
	double Precision;        // Точность для дробного количества товара. Некоторые кассовые модули
		// позволяют загружать т.н. максимальную дробность представления количества товара.
		// Если в записе кассового узла установлен флаг CASHFX_APPLYUNITRND, то это поле
		// заполняется значением Rounding из записи торговой единицы измерения товара.
		// Если флаг CASHFX_APPLYUNITRND не задан или единица измерения имеет Rounding == 0,
		// то Precision = 0.001.
	long   GoodsFlags;       // Флаги записи товара
	LDATE  Expiry;           // @v11.9.5 Срок истечения годности @todo
	long   Flags_;           //
	PPID   LocPrnID;         // ->Ref(PPOBJ_LOCPRINTER)
	char   LocPrnSymb[20];   // Символ локального принтера LocPrnID
	PPID   AsscPosNodeID;    // Ассоциированный с товаром кассовый аппарат
	char   AsscPosNodeSymb[20]; // Символ ассоциированного с товаров кассового аппарата
	char   SalesRestrSymb[20];  // @v12.3.7 Символ записи ограничения на продажу для товара ID (если задано)
	uint16 SalesRestrAge;       // @v12.3.7 Минимальный возраст, с которого возможна продажа товара (из записи ограничения на продажу, если таковая есть)
	int16  NoDis;            // Запрет скидки на товар (> 0 - без скидки, 0 - со скидкой, -1 - со скидкой (признак "без скидки" был снят)
	int16  ChZnProdType;     // Тип маркированной продукции честный знак
	int16  DivN;             // Номер отдела // @v12.3.7 long-->int16
	double VatRate;          // Ставка НДС
	RealRange AllowedPriceR; // Допустимый диапазон цен, рассчитанный на основании ограничений товарных величин.
	S_GUID Uuid;             // UUID товара, извлеченный из тега PPTAG_GOODS_UUID
	RAssocArray QuotList;    // Список дополнительных котировок.
		// Вызывающая функция заполняет поля Key идентификаторами видов котировок.
		// AsyncCashGoodsIterator инициализирует поля Val массива соответствующими
		// эффективными значениями котировок.
	StringSet AddedMsgList;  // Список дополнительных текстовых полей, составленный по правилам, определенным полем PPAsyncCashNode::AddedMsgSign.
	SString LabelName;       // Наименование для ценника (этикетки и т.д.). Извлекается вызовом PPGoodsPacket::GetExtStrData(GDSEXSTR_LABELNAME, SString &)
	const PPQuotArray  * P_QuotByQttyList; // @ownedby(AsyncCashGoodsIterator)
	const BarcodeArray * P_CodeList;       // @ownedby(AsyncCashGoodsIterator)
};

#define ACGIF_UPDATEDONLY       0x0001 // Только измененные товары
#define ACGIF_GETCURPRICE       0x0002 // Выдавать текущую цену товара (а не по розничным котировкам)
#define ACGIF_DONTUSEQUOTWTIME  0x0004 // Не включать в список видов котировок, используемых для определения базовой цены, виды с определенным периодом временем.
#define ACGIF_INITLOCPRN        0x0008 // Инициализировать идентификатор и символ локального принтера, ассоциированного со складом, с которым, в свою очередь, ассоциирован товар.
#define ACGIF_UNCONDBASEPRICE   0x0010 // Базовая цена - без учета розничных котировок.
	// Инициализируется самим классом AsyncCashGoodsIterator как проекция флага PPEquipConfig::fUncondAsyncBasePrice
#define ACGIF_EXCLALTFOLD       0x0020 // @internal Товарная группа, заданная в кассовом узле является группой-папкой эксклюзивных альтернат групп.
#define ACGIF_ALLCODESPERITER   0x0040 // Все коды товара передавать в одной итерации
#define ACGIF_REDOSINCEDLS      0x0080 // Повторная выгрузка данных, которые были начиная с заданного DLSID
#define ACGIF_ENSUREUUID        0x0100 // Итератор гарантирует наличие UUID'а у товара, возвращаемого очередной итерацией.
#define ACGIF_IGNOREGWODISTAG   0x0200 // Игнорировать признак товаров 'без скидки'. Флаг выставляется автоматически функцией Init по
	// флагу конфигурации оборудования PPEquipConfig::fIgnoreNoDisGoodsTag. Внешняя установка флага игнорируется.

class AsyncCashGoodsIterator {
public:
	static int __GetDifferentPricesForLookBackPeriod(PPID goodsID, PPID locID, double basePrice, int lookBackPeriod, RealArray & rList);

	AsyncCashGoodsIterator(PPID posNodeID, long flags, PPID sinceDlsID, DeviceLoadingStat * pDls);
	~AsyncCashGoodsIterator();
	int    Next(AsyncCashGoodsInfo *);
	const  IterCounter & GetIterCounter() const;
	int    UpdateCPrice(PPID goodsID, double price);
	AsyncCashGoodsGroupIterator * GetGroupIterator();
	//
	// Descr: Находит список уникальных и отличающихся от basePrice цен по открытым лотам товара goodsID
	//   за период getcurdate_()-PricesLookBackPeriod..
	//   и возвращает их в массиве rList.
	//   Функция требуется в некоторых ситуациях, когда необходимо предоставлять ручной выбор
	//   цены из набора возможных.
	// Returns:
	//   >0 - PricesLookBackPeriod > 0 и найдена по крайней мере одна цена, отличающаяся от basePrice
	//   <0 - PricesLookBackPeriod < 0 или не найдено цен, отличающихся от basePrice
	//
	int    GetDifferentPricesForLookBackPeriod(PPID goodsID, double basePrice, RealArray & rList);
	PPID   GetAlcoGoodsCls(SString * pProofExpr, SString * pVolumeExpr) const;
	PPID   GetTobaccoGoodsCls() const;
	PPID   GetGiftCardGoodsCls() const;
	int    GetAlcoGoodsExtension(PPID goodsID, PPID lotID, PrcssrAlcReport::GoodsItem & rExt);
	bool   IsSimplifiedDraftBeer(PPID goodsID) const; // @v11.9.6
	//
	// Descr: Возвращает список идентификаторов объектов типа refType,
	//   на которые ссылаются товары из выборки.
	//   Допустимые значения refType: PPOBJ_GOODSGROUP, PPOBJ_UNIT, PPOBJ_GOODSCLASS, PPOBJ_GOODSTYPE
	// Returns:
	//   !0 - список объектов
	//    0 - error (например, refType задает недопустимый тип объекта)
	//
	const PPIDArray * FASTCALL GetRefList(int refType) const;
private:
	int    Init(long flags);
	int    SearchCPrice(PPID goodsID, double * price);
	const  PPID PosNodeID;  // Кассовый узел для которого формируется список товаров
	const  PPID SinceDlsID; // Ид записи статистики загрузки, начиная (включая) с которой следует выгрузить изменения //
	int    LotThreshold;    // Количество дней от последнего прихода, после которого товар, по которому остаток нулевой, не следует загружать на кассовые аппараты
	long   Flags;           // ACGIF_XXX
	PPID   LocID;
	PPID   UserOnlyGoodsGrpID;    // Товарная группа, которой ограничен пользователь при загрузке изменений.
	PPID   AlcoGoodsClsID;        //
	PPID   TobaccoGoodsClsID;     //
	PPID   GiftCardGoodsClsID;    //
	int    PricesLookBackPeriod;  // Количество дней за которые необходимо просмотреть прошлые лоты для нахождения списка дополнительных цен
	uint   CodePos;               // Текущая позиция экспортируемого штрихкода в списке кодов текущего товара
	uint   GoodsPos;              //
	LDATE  CurDate;               // @!Init()
	//
	// Descr: Алгоритм формирования списка измененных товаров для асинхронных кассовых сессий.
	//
	enum {
		//
		// Традиционный - перебирается весь справочник товаров для идентификации
		// тех позиций, цены по которым изменились. Список измененных товаров извлекается из системного журнала
		//
		algDefault = 0,
		//
		// Традиционный с тестом алгоритма "по измененным документам". Переходный
		// режим, позволяющий оценить погрешность перехода на алгоритм algUpdBills(2). Позиции,
		// которые должны быть признаны измененными в соответствии с алгоритмом 0,
		// но не признаны таковыми в соответствии с алгоритмом algUpdBills(2), заносятся в
		// файл журнала ppinfo.log сообщением "AsyncCashGoodsIterator miss: [id=ид товара] наименование товара"
		//
		algUpdBillsVerify = 1,
		//
		// Алгоритм "по изменениям документов". По системному журналу извлекается //
		// список документов, которые были добавлены или изменены с момента
		// последней загрузки кассового узла. По документам, которые влияют на состояние
		// склада, извлекается список товаров, в него вливается список измененных
		// товаров, и перебор идет уже по результирующему списку, а не по всему справочнику товаров
		//
		algUpdBills = 2
	};
	int    Algorithm;             // AsyncCashGoodsIterator::algXXX Алгоритм выбора измененных товаров, которые необходимо загрузить во внешний модуль.
	AsyncCashGoodsInfo Rec;       //
	SString VerMissMsg;           // Шаблон сообщения для вывода информации о том, что товар, попавший в загрузку, не соответствует критерию нового алгоритма algUpdBills
	SString AlcoProofExpr;        //
	SString AlcoVolExpr;          //
	//
	// Списки идентификаторов объектов, на которые ссылаются товары, попадающие в выборку
	//
	PPIDArray GroupList;          // Родительские группы
	PPIDArray UnitList;           // Единицы измерения (и торговые и физические)
	PPIDArray GdsClsList;         // Классы товаров
	PPIDArray GdsTypeList;        // Типы товаров
	PPIDArray UpdGoods;           //
	PPIDArray RmvGoods;           // Товары, для которых следует отправить уведомление об удалении
	PPIDArray IterGoodsList;      //
	PPIDArray NoDisToggleGoodsList; // Список товаров, по которым был снят признак "без скидки" (за заданный период)
	PPIDArray UpdatedBillList;    // Список измененных документов, по которым идентифицированы модифицированные товары.
		// Список сохраняется в DlsObjTbl в диагностических целях.
	PPQuotArray QuotByQttyList;   // Список котировок, применяемых для скидки на кол-во товара
	BarcodeArray Codes;           // Список кодов для текущего товара
	LAssocArray LocPrnAssoc;      // Список ассоциаций Склад-Локальный принтер
	LAssocArray GroupAssoc;       // Список товарных групп, ассоциированных с товарами.
	PPAsyncCashNode AcnPack;      //
	LAssocArray BcPrefixList;     // Список весов, ассоциированных с префиксами штрихкодов
	SysJournal SJ;                //
	CCurPriceTbl CCP;             //
	PPObjGoods GObj;              //
	PPObjGoodsClass GcObj;        //
	PPObjLocPrinter LpObj;        //
	PPObjCashNode CnObj;          //
	GoodsIterator Iter;           // Итератор по товарам
	RetailPriceExtractor RetailExtr;
	UintHashTable GoodsIdListWithSalesRestrTag; // @v12.3.7 Список идентификаторов товаров, у которых есть зарезервированный тег PPTAG_GOODS_SALESRESTR
	DeviceLoadingStat * P_Dls;    // @notowned
	GoodsToObjAssoc * P_G2OAssoc; //
	GoodsToObjAssoc * P_G2DAssoc; // Ассоцииации {товар-кассовый узел} для загрузки номеров кассовый аппаратов, ассоциированных с товарами
	IterCounter InnerCounter;     // Используется если (Flags & ACGIF_UPDATEDONLY && Algorithm == algUpdBills)
	AsyncCashGoodsGroupIterator * P_AcggIter; //
	PrcssrAlcReport * P_AlcPrc;   //
};
//
// @ModuleDecl(PPViewQuot)
//
// QuotFilt определен выше так как используется в классе Quot2Iterator
//
#define MAX_QUOTS_PER_TERM_REC 32

struct QuotViewItem {
	PPID   GoodsID;
	PPID   LocID;
	PPID   ArticleID;
	char   Quots[MAX_QUOTS_PER_TERM_REC][10];
};

class PPViewQuot : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoods,
		OrdByArGoods
	};
	struct BrwHdr {
		PPID   GoodsID;
		PPID   LocID;
		PPID   ArticleID;
		PPID   QuotKindID;
		int32  PeriodIdx;
	};
	//
	// Descr: Заголовок строки данных таблицы временного изменения котировки
	//
	struct BrwHdrSer {
		LDATETIME Dtm;
		double Val;
		long   ValF;
	};

	PPViewQuot();
	~PPViewQuot();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void GetTabTitle(long tabID, SString & rBuf);
	const  StrAssocArray & GetQuotKindList() const;
	int    InitIteration();
	int    FASTCALL NextIteration(QuotViewItem *);
	//
	// Descr: Предлагает пользователю редактировать котировки по товару, которого нет
	//   в выборке. Если pGoodsID == 0 || *pGoodsID == 0, то система предлагает выбрать товар.
	//
	int    AddItem(PPID * pGoodsID);
	int    EditItem(const BrwHdr *, int simple);
	int    Transmit(const BrwHdr *);
	int    Export();
	int    Recover();
	int    GetCtQuotVal(const void * pRow, long col, long aggrNum, double * pVal);
	void   GetEditIds(const void * pRow, PPViewQuot::BrwHdr * pHdr, long col);
	const  PPQuotItemArray * GetQList() const;
private:
	static  int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	static  int DynFuncPeriod;
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  Print(const void * pHdr);
	virtual void ViewTotal();
	int    UpdateTempTable(PPID goodsID, int use_ta);
	int    Helper_CreateTmpTblEntries(const QuotFilt *, PPQuotItemArray * pQList, int use_ta);
	int    Helper_RemoveTempRecsByGoodsID(PPID goodsID, int use_ta);
	int    CreateCrosstab(int useTa);
	int    CheckDelFromMtx(PPID goodsID);
	int    CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    MakeOrderEntry(IterOrder ord, const TempQuotTbl::Rec & rSrcRec, TempOrderTbl::Rec & rDestRec);
	int    FASTCALL CheckGoodsKindDiffRestriction(PPID goodsID);
	SString & GetQuotTblBuf(const TempQuotTbl::Rec * pRec, uint pos, SString & rBuf);
	void   SetQuotTblBuf(TempQuotTbl::Rec * pRec, uint pos, const SString & rVal);

	QuotFilt Filt;
	QuotationCore * P_Qc;
	Quotation2Core * P_Qc2;
	PPObjQuotKind QkObj;
	PPObjGoods GObj;
	PPObjLocation LocObj;
	PPObjArticle ArObj;
	PPObjBill * P_BObj; // @notowned
	StrAssocArray QuotKindList;
	TempQuotTbl * P_TempTbl;
	TempQuotSerialTbl * P_TempSerTbl;
	TempOrderTbl * P_TempOrd;
	PPIDArray QkList;
	ExtGoodsSelDialog * P_GoodsSelDlg;
	PPQuotItemArray QList_;
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в TempQuotTbl
	//
	// Это поле инициализируется функцией Browse()
	// и используется для вычисления вида котировки, соответствующего
	// текущей позиции броузера.
	//
	int    FirstQuotBrwColumn;
	int    HasPeriodVal;        // Временная таблица содержит по крайней мере одно значение, ограниченное периодом действия //
	const  PPObjQuotKind::Special Spc;
	GoodsSubstList Gsl;
};
//
// @ModuleDecl(PPObjScale)
// Электронные весы
//
#define SCALF_STRIPWP    0x0001L // Игнорировать весовой префикс
#define SCALF_EXSGOODS   0x0002L // Загружать товары, которые есть на складе
#define SCALF_SYSPINITED 0x0004L // Системные параметры инициализированы (иначе default)
#define SCALF_TCPIP      0x0008L // Грузим данные используя TCP/IP соединение, адрес хранится в поле Port
#define SCALF_CHKINVPAR  0x0010L // Проверять при загрузке данные на ошибки (штрихкод, срок хранения)
#define SCALF_PASSIVE    0x0020L // Признак "Пассивный". Означает что данные на эти весы грузиться не будут.

struct PPScale2 {          // @persistent @store(Reference2Tbl+)
	PPScale2();
	int    IsValidBcPrefix() const;

	long   Tag;              // Const=PPOBJ_SCALE
	long   ID;               // @id
	char   Name[48];         // @name @!refname
	char   Symb[20];         //
	PPID   ParentID;         // Ид. группы весов
	SVerT  Ver_Signature;    // Сигнатура версии. Необходима для индикации факта конвертации v10.5.7
	uint16 Get_NumTries;   // @#{0..32000} // System param
	uint16 Get_Delay;      // @#{0..1000}  // System param
	uint16 Put_NumTries;   // @#{0..32000} // System param
	uint16 Put_Delay;      // @#{0..1000}  // System param
	int16  BcPrefix;       // Префикс искусственного штирхкода, загружаемого на весы
	int16  MaxAddedLn;       // Максимальная длина строки дополнительного текста. Если не указано, то система принимает значение на свое усмотрение.
	int16  MaxAddedLnCount;  // Максимальное количество строк дополнительного текста.
	char   FontSize[8];      // @v11.1.6 Размер шрифта. Специфичный для конкретной модели параметр. В общем случае может быть как
		// числовым, так и текстовым. На момент ввода применяется только для весов DIGI
	char   Reserve[14];      // @reserve // @v11.1.6 [22]-->[14]
	PPID   QuotKindID;     // ->Ref(PPOBJ_QUOTKIND) Вид котировки, используемый для ценообразования //
	PPID   ScaleTypeID;    // Тип устройства
	long   ProtocolVer;    // Версия протокола обмена. Зависит от типа устройства
	long   LogNum;         // Логический номер устройства. Применяется для некоторых типов устройств.
	long   Flags;          // SCALF_XXX
	PPID   Location;       // ->Location.ID Склад, к которому относится устройство
	PPID   AltGoodsGrp;    // ->Goods2.ID   Альтернативная группа товаров, загружаемая на весы
};

#define PPTRPROP_SCALEEXT      (PPTRPROP_USER+1)

class PPScalePacket : public PPExtStrContainer {
public:
	PPScalePacket();
	PPScalePacket & Z();
	void   SetSysParams(uint _getNumTries, uint _getDelay, uint _putNumTries, uint _putDelay);
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке ExtString
	//
	enum { // @persistent
		extssAddedMsgSign = 1,
		extssPort         = 2,
		extssPaths        = 3
	};
	PPScale2 Rec;
};

class PPObjScale : public PPObjReference {
public:
	struct Stat {
		uint   NumSendPluColl;      // Количество коллизий в функции PPObjScale::SendPlu
		uint   MaxSendPluCollIters; // Максимальное количество итерациий, вызыванных при обработке
			// коллизий в функции PPObjScale::SendPlu
		uint   NumGetColl;          // Количество коллизий в функции PPScaleDevice::GetChr()
		uint   MaxGetCollIters;     // Максимальное количество итераций, вызванных при обработке
			// коллизий в функции PPScaleDevice::GetChr()
	};
	//
	// Флаги функции PPObjScale::TransmitData
	//
	enum {
		fTrUpdateOnly  = 0x0001, // Загружать только изменения //
		fTrSkipListing = 0x0002  // Не предлагать печать листинга и не печатать
	};
	static int PrepareData(PPID scaleID);
	static int TransmitData(PPID scaleID);
	static int EncodeIP(const char * pIP, char * pEncodedIP, size_t ipSize);
	static int DecodeIP(const char * pEncodedIP, char * pIP);
	static void * FASTCALL MakeExtraParam(long scaleTypeID, long groupID);
	static int CheckForConnection(const char * pIPAddress, uint timeout, uint attemptCount);

	explicit PPObjScale(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    IsPacketEq(const PPScalePacket & rS1, const PPScalePacket & rS2, long flags);
	int    PutPacket(PPID * pID, PPScalePacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPScalePacket * pPack);
	int    SerializePacket(int dir, PPScalePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Проверяет запись весов pRec на уникальность значения IP-адреса (если установлен флаг SCALF_TCPIP)
	//   и значения BcPrefix (если оно не нулевое).
	// ARG(objID IN): идентификатор проверяемой записи (0 - если запись новая)
	// ARG(pRec  IN): @#{vptr} проверяемая запись
	// Returns:
	//   >0 - запись pRec удовлетворяет требованиям уникальности полей Port и BcPrefix
	//   0  - в записи pRec дублируется либо Port либо BcPrefix (устанавливается соответствующий код ошибки PPErrCode).
	//
	int    CheckDup(PPID objID, const PPScalePacket * pPack);
	int    PrepareData(PPID, long flags, PPLogger * pLogger);
	int    TransmitData(PPID, long flags, PPLogger * pLogger);
	void   GetStat(Stat *) const;
	//
	// Descr: Возвращает список устройств, у которых определен префикс штрихкода.
	//   Результать заноситься в массив pList парами {ID устройства, префикс штрихкода}.
	//   Функция учитывает только те устройства, для которых префиксы попадают в один из двух
	//   диапазонов: [20..29] и [200..299].
	// Note: Если pList == 0, то функция не пытается ничего делать со списком, но возрващает
	//   тот же код, как буд-то указатель не нулевой.
	// ARG(pList OUT): @#{vptr0} указатель на список, в который заносятся искомые пары.
	//   Функция предварительно очищает список (если указатель не нулевой).
	// Returns:
	//   <0 - функция нашла по крайней мере одно устройство с заданным допустимым префиксом
	//   <0 - не определено ни одного утсройства с заданным допустимым префиксом
	//   0  - ошибка
	//
	int    GetListWithBcPrefix(LAssocArray * pList);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//
	int    FASTCALL Fetch(PPID id, PPScalePacket * pRec); // @macrow
	//
	// Descr: Проверяет, установлен-ли у весов или у группы к которой принадлежат весы признак SCALF_PASSIVE
	//
	int    IsPassive(PPID id, const PPScale * pScale);
protected:
	int    SendPlu(PPScalePacket *, const char * pFileName, int updateOnly, PPLogger * pLogger);
	void   InitStat();

	Stat   StatBuf;
private:
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
};
//
// @ModuleDecl(PPObjBHT)
//
#define RCPTPLACE_ALTGROUP  0
#define RCPTPLACE_GBASKET   1

struct PPBhtTerminal2 {    // @persistent @store(Reference2Tbl+)
	enum {
		fDelAfterImport = 0x00000001L
	};
	PPID   Tag;            // Const=PPOBJ_BHT
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	PPID   LocID;          // Привязка терминала к складу.
	char   Port[8];        // Output port name (default "COM1")
	//
	// Параметры com-порта
	//
	uint16 ComGet_NumTries; // @#{0..32000} not used
	uint16 ComGet_Delay;    // @#{0..1000}  for Win32 only
	uint16 ComPut_NumTries; // @#{0..32000} not used
	uint16 ComPut_Delay;    // @#{0..1000}  not used
	PPID   IntrExpndOpID;  // Операция внутреннего перемещения (PPOPT_GOODSEXPEND || PPOPT_DRAFTEXPEND)
	PPID   InventOpID;     // Inventory Operation Kind ID
	int16  Cbr;            // ComBaudRate (default 19200)
	uint16 BhtpTimeout;    // Bht protocol timeout, mc (default 3000)
	uint16 BhtpMaxTries;   // Bht protocol max attempts sending data (default 10)
	short  ReceiptPlace;   // Куда качать накладные  @todo > Flags
	long   Flags;          //
	long   BhtTypeID;      // Reserved (Denso only)
	PPID   ExpendOpID;     // Expend Operation Kind ID (PPOPT_GOODSEXPEND || PPOPT_DRAFTEXPEND)
};

struct SBIIOpInfo { // @persistent @size=24 @flat @{stylobhtiiopcfg}
	long   OpID;
	long   ToBhtOpID;
	long   ToHostOpID;
	long   BhtOkCancelActions;
	long   BhtCfmActions;
	long   Flags;
};

typedef TSVector <SBIIOpInfo> SBIIOpInfoArray;

struct StyloBhtIIOnHostCfg {
	StyloBhtIIOnHostCfg();
	~StyloBhtIIOnHostCfg();
	void   Init();
	StyloBhtIIOnHostCfg & FASTCALL operator = (const StyloBhtIIOnHostCfg & rSrc);
	bool   IsEmpty() const;
	PPID   GetOpID(PPID opID) const;
	bool   IsCostAsPrice(PPID opID) const;
	bool   IsValid() const;

	SString DeviceName;
	SString WeightPrefix;
	SString QttyWeightPrefix;
	SString UserName;
	SString Password;
	ulong   ServerAddr;
	ulong   ServerPort;
	ulong   ServerMask;
	long    Flags;
	PPID    BcdPrinterID;
	double  DefQtty;
	DateRange ExportBillsPeriod;
	SBIIOpInfoArray * P_OpList;
};

struct PPBhtTerminalPacket {
	PPBhtTerminalPacket();
	~PPBhtTerminalPacket();
	PPBhtTerminalPacket & FASTCALL operator = (const PPBhtTerminalPacket &);
	//
	// Descr: Конвертирует пакет в структуру конфигурации StyloBHTII.
	// ARG(expKind IN): Категория данных, для которой должно быть инициирована
	//   время последнего обмена:
	//  -1 - ничего (все поля XxxLastExch остаются нулевыми).
	//   0 - all (товары, контрагенты, документы)
	//   1 - только товары
	//   2 - только контрагенты
	//   4 - только документы
	// ARG(pCfg OUT): @#{vptr0} Указатель, по которому в случае успеха будут
	//   скопированы данные конфигурации.
	//
	// Return:
	//   >0 - конвертация осуществлена успешно
	//   <0 - (P_SBIICfg==0)
	//
	int    ConvertToConfig(int expKind, StyloBhtIIConfig * pCfg) const;

	PPBhtTerminal Rec;
	GoodsFilt * P_Filt;
	StyloBhtIIOnHostCfg * P_SBIICfg;
	SString ImpExpPath_;
};

class PPObjBHT : public PPObjReference {
public:
	enum {
		btDenso      = 0L,
		btSyntech    = 1L,
		btPalm       = 2L,
		btWinCe      = 3L,
		btCom        = 4L,
		btStyloBhtII = 5L // терминал на котором установлена программа StyloBhtII
	};
	struct BillRec {
		PPID   ID;
		PPID   SupplID;
		LDATE  Dt;
	};
	struct BillLineRec {
		PPID   BillID;
		PPID   GoodsID;
		double Price;
		double Quantity;
		LDATE  Expiry;
	};
	struct InventRec {
		PPID   ID;
		LDATE  Dt;
		S_GUID Uuid;
		char   Code[32];
	};
	struct InventLineRec {
		PPID   InventID;
		PPID   GoodsID;
		double Price;
		double Quantity;
	};

	static int TransmitProgram(); // @TEMP
	static int TransmitData();
	static int ReceiveData();

	PPObjBHT(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPBhtTerminalPacket *, int use_ta);
	int    GetPacket(PPID, PPBhtTerminalPacket *);
	int    InitProtocol(PPID, BhtProtocol *);
	int    InitProtocol(PPID, CipherProtocol *);
	int    TransmitSuppl(BhtProtocol *, int updateData);
	int    TransmitGoods(PPID bhtID, BhtProtocol *, int updateData);
	int    TransmitSuppl(CipherProtocol *, int updateData);
	int    TransmitGoods(PPID bhtID, CipherProtocol *, int updateData);
	int    ReceiveBills(PPID);
	int    ReceiveInvent(PPID);
	int    AcceptBill(PPObjBHT::BillRec * pRec, PPBasketPacket * pGBPack, PPID * pAltGrpID);
	int    AcceptBillLine(PPID billID, PPObjBHT::BillLineRec * pRec, PPBasketPacket * pGBPack, PPID * pAltGrpID);
	int    AcceptInvent(PPID opID, PPObjBHT::InventRec * pRec, BillTbl::Rec * pInvRec, PPLogger * pLogger);
	int    PrepareBillData2(const PPBhtTerminalPacket * pPack, PPIDArray * pGoodsList, int uniteGoods = 1);
	int    PrepareBillRowCellData(const PPBhtTerminalPacket * pPack, PPID billID);
	int    PrepareLocCellData(const PPBhtTerminalPacket * pPack);
	int    PrepareConfigData(const PPBhtTerminalPacket * pPack, StyloBhtIIConfig * pCfg);
private:
	static int AcceptBills(const char * pHName, const char * pLName, PPLogger *);
	static int AcceptBillsToGBasket(const char * pHName, const char * pLName, PPLogger *);
	static int AcceptInvent(const char * pHName, const char * pLName, PPID opID, PPLogger *);
	static int AcceptExpendBills(const char * pHName, const char * pLName, const PPBhtTerminal *, PPLogger *);
	static int AddEBLineToPacket(PPBillPacket *, const char * pBarcode, double qtty, double price, PPLogger *);
	static int AcceptBillsPalm(const char * pHName, const char * pLName, PPLogger *);
	static int AcceptBillsToGBasketPalm(const char * pHName, const char * pLName, PPLogger *);
	static int AcceptInventPalm(const char * pHName, const char * pLName, PPID opID, PPLogger *);
	static int AcceptExpendBillsPalm(const char * pHName, const char * pLName, const PPBhtTerminal *, PPLogger *);
	static int AcceptTechSessPalm(const char * pLName, PPLogger *);
	static int AcceptBillsSBII(const PPBhtTerminalPacket * pPack, PPID destIntrLocID, const char * pHName, const char * pLName, PPLogger *);
	int    PrepareGoodsData(PPID bhtID, const char * pPath, const char * pPath2, PPID bhtTypeID, const PPIDArray * pAddendumGoodsIdList);
	int    PrepareSupplData(const char * pPath, PPBhtTerminalPacket * pPack = 0);
	int    PrepareLocData(const char * pPath, PPID bhtTypeID);
	int    PrepareTechSessData(const char * pPath, PPID bhtTypeID);
	void   InitGoodsBhtRec(BhtRecord *) const;
	void   InitSupplBhtRec(BhtRecord *) const;

	PPObjGoods GObj;
	PPObjGoodsGroup GGObj;
	PPObjBill * P_BObj;
};
//
//
//
class StyloBhtIIExchanger {
public:
	StyloBhtIIExchanger();
	~StyloBhtIIExchanger();
	int    FASTCALL ProcessSocketInput(TcpSocket & rSo);
private:
	int    GetTable(TcpSocket & rSo, int16 Cmd, uint fileNameCode, const char * pTblInfo, SBIIRec * pRec, long nextRecNo);
	int    SetTable(TcpSocket & rSo, int16 cmd, uint fileNameCode, const char * pTblInfo, SBIIRec * pRec, long count);
	int    PrepareBills(int uniteGoods);
	int    GetConfig(StyloBhtIIConfig * pCfg);
	int    GetGoodsList(TcpSocket & rSo, long cellID, int getGoods);
	int    AcceptLocOp(SBIILocOp * pRec);
	int    FindGoods(PPID goodsID, const char * pBarcode, SBIIGoodsRec * pRec);
	int    FindLocCell(PPID locID, const char * pName, SBIILocCellRec * pRec);
	int    PrintBarcode(const char * pBarcode);
	int    SendCmd(TcpSocket & rSo, int16 cmd, int32 retcode, const void * pBuf, size_t bufSize);
	int    RecvCommand(TcpSocket & rSo, void * pBuf, size_t bufSize, size_t * pRecvBytes = 0);
	int    Log_(uint errCode, uint msgCode, const char * pAddInfo);
	int    Log_(uint errCode, uint msgCode, const char * pAddInfo, long count, long total);

	SString DeviceDir;
	StyloBhtIIConfig Cfg;
	PPBhtTerminalPacket BhtPack;
	PPObjGoods GObj;
	PPObjLocation LocObj;
	LocTransfCore * P_LocTransf;
};
//
// @ModuleDecl(PPObjQCert)
//
class PPObjQCert : public PPObject {
	//
	// Дополнительный параметр содержит мин. дату закрытия сертификата.
	// Используется только функцией Selector
	//
public:
	explicit PPObjQCert(void * extraPtr = 0);
	~PPObjQCert();
	virtual int Browse(void * extraPtr);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int DeleteObj(PPID id);
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr /* goodsID */);
	virtual int Search(PPID id, void * b = 0);
	virtual int Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    SearchByCode(const char * pCode, PPID * pID, QualityCertTbl::Rec * pRec);
	int    PutPacket(PPID * pID, QualityCertTbl::Rec * pPack, int use_ta);
	//
	// DescrL Устанавливает (set != 0) или снимает (set == 0) признак Passive для //
	//   записи с идентификатором id.
	// Returns:
	//   >0 - признак установлен (снят)
	//   <0 - признак уже находится в заданном состоянии
	//   0  - ошибка
	//
	int    SetPassiveTag(PPID id, int set, int use_ta);
private:
	virtual int    HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual const char * GetNamePtr();
public:
	TLP_MEMB(QualityCertTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewQCert)
//
class QCertFilt : public PPBaseFilt {
public:
	QCertFilt();
	enum {
		fHasRest     = 0x0001, // Ненулевой остаток товаров
		fShowPassive = 0x0002  // Показывать пассивные сертификаты
	};
	char   ReserveStart[32];   // @anchor
	DateRange ExpiryPeriod;    //
	DateRange InitPeriod;      //
	PPID   RegOrgan;           //
	char   CodeStr[32];        // Строка, содержащаяся в коде
	char   InnerCode[24];      // Внутренний код сертификата
	long   Flags;
	long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef QualityCertTbl::Rec QCertViewItem;

class PPViewQCert : public PPView {
public:
	PPViewQCert();
	~PPViewQCert();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(QCertViewItem *);
private:
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	int    Transmit();
	int    SetPassiveTag(int set);

	QCertFilt Filt;
	PPObjQCert QcObj;
	ReceiptCore * P_RcptT;        // PPViewQCert is not owned by P_RcptT
	QualityCertTbl * P_TempTbl;
};
//
// Флаги редактирования бух. проводки
//
#define ATDF_DSBLDOC      0x00000001L
#define ATDF_DSBLDATE     0x00000002L
#define ATDF_DSBLAMOUNT   0x00000004L
#define ATDF_DSBLDACC     0x00000008L
#define ATDF_DSBLDART     0x00000010L
#define ATDF_DSBLCACC     0x00000020L
#define ATDF_DSBLCART     0x00000040L
#define ATDF_DSBLALL      0x0000007fL
//
// Структуры для агрегированного расчета НДС
//
struct BVATAccm { // @flat
	BVATAccm();
	int    IsVatFree; // ставка по освобожденным от уплаты НДС поставщиков
	double CRate;
	double PRate;
	double Cost;
	double Price;
	double CVATSum;
	double PVATSum;
	double PTrnovr;
	double Discount;
};
//
// Флаги класса BVATAccmArray
//
#define BVATF_IGNORESUPPL 0x0001 // Игнорировать зависимость НДС от поставщика
#define BVATF_SUMZEROVAT  0x0002 // Суммировать строки с освобожденными значениями
#define BVATF_DIFFBYCRATE 0x0004 // Различать элементы по ставке входящего НДС

class BVATAccmArray : public TSVector <BVATAccm> {
public:
	explicit BVATAccmArray(uint aFlags = 0);
	BVATAccmArray(const BVATAccmArray & rS);
	int    CalcBill(PPID billID);
	int    CalcBill(const PPBillPacket & rPack);
	int    CalcCCheckLineArray(const CCheckLineArray & rList);
	void   Scale_(double part, int useRounding);
	int    Add(const PPTransferItem &, PPID opID);
	int    Add(const BVATAccm *, int dontRound = 0);
private:
	int    IsVataxableSuppl(PPID);

	PPObjGoods GObj;
public:
	uint   Flags;
};
//
// Специфические флаги доступа PPObjBill (в дополнение к общим PPR_XXX)
//
#define BILLRT_CASH                0x0100
#define BILLRT_CLOSECASH           0x0200
#define BILLRT_OPENCASH            0x0400
#define BILLRT_MODDATE             0x0800
#define BILLRT_SYSINFO             0x1000
#define BILLRT_MODGOODS            0x2000 // Модификация товара в приходе
#define BILLRT_USEWLABEL           0x4000 // Разрешение на использование WL
#define BILLRT_ACCSCOST            0x8000 // Доступ к ценам поступления //

#define BILLOPRT_MULTUPD           0x0001 // Массовое изменение документов
#define BILLOPRT_UNITEBILLS        0x0002 // Объединение документов
#define BILLOPRT_MODOBJ            0x0004 // Модификация контрагента
#define BILLOPRT_MODSTATUS         0x0008 // Модификация статуса
#define BILLOPRT_CANCELQUOT        0x0010 // Право на отмену установленной котировки в строке документа
#define BILLOPRT_TOTALDSCNT        0x0020 // Право на установку скидки на весь документ
#define BILLOPRT_MODFREIGHT        0x0040 // Право на модификацию фрахта. Опция действует независимо от права на модификацию
	// документа, но не переопределяет статусный запрет на модификацию.
#define BILLOPRT_MODTRANSM         0x0080 // Право на изменение компонентов товарных документов, которые уже были переданы
	// в другой раздел при том, что вносимые изменения не смогут быть изменены в разделе-получателе.
#define BILLOPRT_ACCSSUPPL         0x0100 // Доступ к информации о поставщике лота
#define BILLOPRT_REJECT            0x0200 // Право на установку признака 'Отклонен' на документе (если вид операции допускает такое действие)
#define BILLOPRT_EMPTY             0x0400 // Право на сохранение пустого документа
//
// Флаги функции PPObjBill::ConvertILTI
//
#define CILTIF_DEFAULT             0x0000 //
#define CILTIF_OPTMZLOTS           0x0001 // Оптимизировать лоты
#define CILTIF_USEGENGOODS         0x0002 // @obsolete Использовать лоты обобщенных товаров
#define CILTIF_USESUBST            0x0002 // Использовать подстановку
#define CILTIF_ABSQTTY             0x0004 // Устанавливать абсолютное значение PPTransferItem::Quantity
#define CILTIF_QUOT                0x0008 // Устанавливать флаг PPTFR_QUOT в строках
#define CILTIF_ZERODSCNT           0x0010 // Не выравнивать цену скидкой
#define CILTIF_USESUBST_STRUCONLY  0x0020 // При подстановке использовать только структуру (не обобщение)
#define CILTIF_SUBSTSERIAL         0x0040 // Если в функцию передан серийный номер лота, из которого
	// следует израсходовать товар, но этот лот уже использован, то данный флаг позволяет использовать
	// другие лоты по этому товару. При этом использование доступного лота с точным соответствием
	// серии приоритетно.
	// Если флаг не установлен и указан серийный номер, то расход идет строго по серийному номеру.
#define CILTIF_ALLOWZPRICE         0x0080 // Допускается нулевая чистая цена реализации. Если CILTIF_ZERODSCNT,
	// то этот флаг не действует, в противном случае нулевая чена НЕ воспринимается как исключение при котором следует
	// устанавливать чистую цену реализации равную учетной.
#define CILTIF_EXCLUDESERIAL       0x0100 // Опция, используемая при преобразовании расходной строки. Если установлена,
	// то параметр pSerial содержит список серийных номеров лотов, которые не следует использовать для расходования заданного количества.
	// Если необходимо задать более одного исключенного серийного номера, то номера разделяются символом ';'
	// Note: если этот флаг установлен, то параметр pSerial в любом случае (для приходных и прочих операций)
	//   не будет рассматриваться как собственно серийный номер.
#define CILTIF_INHLOTTAGS          0x0200 // Для приходного документа наследовать теги из предыдущего лота
#define CILTIF_USESYNCLOT          0x0400 // При конвертации пытаться использовать лоты, на которые ссылаются поля ILTI::LotSyncID и ILTI::LotMirrID
#define CILTIF_SYNC                0x0800 // Признак того, что функция ConvertILTI используется для формирования образа
	// документа из другого раздела. В этом случае ее поведение немного отличается.
#define CILTIF_MOD                 0x1000 // Функция ConvertILTI должна изменить (удалить,добавить) строку в существующем документе
#define CILTIF_REPFULLSYNCPROBLEM  0x2000 // Выводить в журнал synclot.log информацию о проблемах подстановки синхронизированного лота
#define CILTIF_CAREFULLYALIGNPRICE 0x4000 // Выравнивать цену реализации результирующих строк по исходной сумме в ценах реализации
#define CILTIF_CUTRESTTOZERO       0x8000 // Остатки по лотам срезать до нуля
//
// Опции выбора даты зачетной оплаты (PPObjBill::Reckon())
//
#define RECKON_DATE_CURR                1 // Зачитывать текущей датой
#define RECKON_DATE_PAYM                2 // Зачитывать датой платежного документа.
	// Если дата платежного документа меньше даты долгового, то зачет проводится датой долгового документа.
#define RECKON_DATE_DEBT                3 // Зачитывать датой долгового документа
#define RECKON_DATE_USER                4 // Зачитывать указанной пользователем датой
//
// Options of method PPObjBill::RecalcTurns
//
#define BORTF_NORECALCAMOUNTS     0x0001L // Don't recalc bill's amounts
#define BORTF_RECALCTRFRS         0x0002L // Recalc transfer items (imply !BORTF_NORECALCAMOUNTS)
#define BORTF_IGNOREOPRTLIST      0x0004L // При изменении пакета документа в нем устанавливается флаг PPBillPacket::pfIgnoreOpRtList
//
//
//
struct ReckonOpArItem {
	ReckonOpArItem();
	PPID   PaymentOpID;
	PPID   PaymentArID;
	PPID   PayableOpID;
	PPID   PayableArID;
	PPID   PayableAccSheetID;
	long   RoxFlags; // @v11.7.11 Проекция поля PPReckonOpEx::Flags
	PPIDArray * P_BillIDList;
};

class ReckonOpArList : public TSArray <ReckonOpArItem> {
public:
	ReckonOpArList();
	~ReckonOpArList();
	void   Destroy();
	PPID   FASTCALL GetPaymOpIDByBillID(PPID billID) const;
	bool   IsBillListSortingNeeded() const;
};

struct CfmReckoningParam {
	CfmReckoningParam();
	void   Init(int debtOrPaym, BillTbl::Rec *, double debt, double paym, PPIDArray *);

	int    DebtOrPaym;
	int    DateOption;
	PPID   ArticleID;
	PPID   CurID;
	double TotalDebt;
	double PaymAmount;
	LDATE  BillDt;
	LDATE  Dt;
	PPID   ForceBillID;       // Идент документа, который должен быть зачтен
	PPID   SelectedBillID;    // OUT
	PPIDArray ResultBillList; // OUT
	PPIDArray * P_BillList;
};
//
//
//
#define BCF_CONFIRMWL              0x00000001L  // Спрашивать подтверждение на установки или снятие WL по документу
#define BCF_ALLOWZSUPPLINCOSTREVAL 0x00000002L  // Допускать переоценку цен поступления без выбора поставщика
#define BCF_WARNMATCLIDEBT         0x00000004L  // Предупреждать о просроченной задолженности клиента при выборе этого клиента в долговом документе
#define BCF_SIGNDIFFLOTCOST        0x00000008L  // Выставлять признак отличия цены поступления последнего лота,
	// от введенной в диалоге строки прихода товара. Для магазинов самообслуживания, использующих BHT-терминалы.
#define BCF_WARNADDBILLNOFLT       0x00000010L  // Предупреждать о вводе документа, не соответствующего фильтру
#define BCF_ALLOWMULTIPRINT        0x00000020L  // Разрешить множественную печать для первичных документов
#define BCF_CHECKRESERVEDORDERS    0x00000040L  // Проверять остатки по уровню резерва при проводке документов
#define BCF_ADDAUTOQTTYBYBRCODE    0x00000080L  // При добавлении новой строки в документ по штрихкоду автоматически устанавливать количество равное 1.
#define BCF_SHOWBARCODESINGBLINES  0x00000100L  // Показывать штрихкоды в строках товарных документов
#define BCF_SHOWSERIALSINGBLINES   0x00000200L  // Показывать серийные номера в строках товарных документов
#define BCF_DONTWARNDUPGOODS       0x00000400L  // Не выдавать предупреждение о том, что выбранный товар уже есть в документе
#define BCF_RETAILEDPRICEINLABEL   0x00000800L  // Печатать в ценниках цену из котировки по акции
#define BCF_AUTOSERIAL             0x00001000L  // При добавлении строки приходного товарного документа автоматически генерировать серийный номер (если нет, то требуется нажатие F2)
#define BCF_AUTOCOMPLOUTBYQUOT     0x00002000L  // При автокомплектации цену реализации исходящих позиций устанавливать по базовой котировке (если нет, то - по последнему лоту)
#define BCF_VALUATION_STRICT       0x00004000L  // Расценка приходных документов остуществляется строго по конфигурации документов
#define BCF_VALUATION_RNDVAT       0x00008000L  // При расценке округлять цены до величины, кратной НДС
#define BCF_WARNAGREEMENT          0x00010000L  // Предупреждать если у контаргента нет соглашения или соглашение просрочено
#define BCF_PAINTSHIPPEDBILLS      0x00020000L  // Отображать цветом документы, имеющие признак BILLF_SHIPPED (отгружен)
#define BCF_OVRRDAGTQUOT           0x00040000L  // Допускается в документах выбирать котировку, отличную от заданной в соглашении с контрагентом.
#define BCF_VALUATION_BYCONTRACT   0x00080000L  // Расценку проводить по контрактной котировке поставщика, если расценочная котировка задана отностиельно цены поступления.
#define BCF_ORDPRICELOWPRIORITY    0x00100000L  // Цена из заказа имеет меньший приоритет перед котировкой.
#define BCF_EXTOBJASMAINORG        0x00200000L  // Если дополнительная статья по документу относится к таблице
	// статей, ссылающейся на персоналии вида "Главная организация", то ненулевую доп статью документа трактовать как
	// главную организацию (вместо главной организации из текущего состояния сеанса).
#define BCF_ACCEPTGOODSBILLCHG     0x00400000L  // Принимать изменения товарных документов
#define BCF_SENDATTACHMENT         0x00800000L  // Передавать в другие разделы файлы, привязанные к документам
#define BCF_DONTINHQCERT           0x01000000L  // Не наследовать сертификаты качества для новых лотов
#define BCF_RETINHERITFREIGHT      0x02000000L  // Связанный документ возврата наследует фрахт от основного документа
#define BCF_PICKLOTS               0x04000000L  // В товарных документах на расход предпочтение - подбору лота, а не товара
#define BCF_INHSERIAL              0x08000000L  // Наследовать в приходах серийный номер от последнего лота
#define BCF_DONTVERIFEXTCODECHAIN  0x10000000L  // Не проверять цепочки кодов расширения лотов при расходе
#define BCF_NEWDOCBYFILTUSEFLTDATE 0x20000000L  // @v11.1.7 При создании документа по фильтру к документу применять верхнюю дату периода фильтра. Иначе - текущую системную.

struct PPBillConfig {        // @persistent @store(cvt:PropertyTbl)
	PPBillConfig();
	PPBillConfig & Z();

	PPID   SecurID;            // Const=PPCFG_MAIN
	char   OpCodePrfx[8];      // Префикс кода операции
	char   ClCodePrfx[8];      // Префикс кода клиента
	PPID   ClCodeRegTypeID;    // Тип регистра персоналии для ведения кодов клиентов
	long   Flags;              // BCF_XXX
	PPID   CashNodeID;         // ИД кассового узла, используемого для печати чека по документу
	char   SnTemplt[16];       // Шаблон генерации серийных номеров лотов                         @obsolete since @v5.0.0
	char   InvSnTemplt[16];    // Шаблон генерации инвентарных номеров основных средств
	long   SnrCounter;         // Счетчик для генерации серийных номеров лотов и драфт документов @obsolete since @v5.0.0
	PPID   InitStatusID;       // Статус, присваиваемый новым документам
	PPID   SnCntrID;           // ->Ref(PPOBJ_OPCOUNTER) Счетчик для генерации серийных номеров (заменяет SnTempl и SnrCounter)
	PPID   ContractRegTypeID;  // Тип регистрационного документа договора с контрагентом
	PPID   MnfCountryLotTagID; // Тип тега лота, определяющего страну происхождения товара
	LDATE  LowDebtCalcDate;    //
	//
	// Способы подстановки товаров вместо дефицитного
	//
	enum {
		gsmGeneric = 0,      // Обобщенные товары (по умолчанию)
		gsmSubstStruc,       // Подстановочная структура
		gsmNone              // Не использовать
	};
	int16  GoodsSubstMethod;   // Способ подстановки товаров вместо дефицитного.
	PPID   LnkFilesCntrID;     // ->Ref(PPOBJ_OPCOUNTER) Счетчик для генерации имен присоединенных файлов
	int16  ValuationRndDir;    // Направление округления при расценке
	LDATE  SwitchedTDisCalcMethodDate;  // Дата, начиная с которой при расчете
		// скидки по документу следует пользоваться методом, определяемым переключателем TDisCalcMethod.
	enum {
		tdcmSimple,   // Простое равномерно-пропорциональное распределение скидки по строкам документа
		tdcmRegress,  // Регрессивный метод (общая скидка последовательно разносится по строкам таким образом,
			// что общая сумма скидки строго равна заявленной).
		tdcmRegress2  // Улучшенный регрессивный метод (строки документа ранжируются так, что ошибка
			// округления минимизируется, а на строки с одинаковыми товарами величина Price-Discount идентична.
	};
	uint8  TDisCalcMethod;     // Метод расчета скидки по документу
	uint8  TDisCalcPrec;       // @#[0..5] Точность округления при расчете скидки
	PPID   ValuationQuotKindID; // ->Ref(PPOBJ_QUOTKIND) Вид котировки для расценки приходных документов
	double ValuationRndPrec;   // Точность округления при расценке
	char   UniqSerialSfx[16];  // Сигнатура суффикса, присоединяемого к серийному номеру для обеспечения его уникальности.
	int16  WarnLotExpirDays;   // Количество дней до предупреждения об истечении срока годности лота (отрицательные значения - после даты истечения)
	//
	// Descr: Опции обработки ситуации с угрозой истечения срока годности лота
	//
	enum {
		wlefIndicator     = 0x0001, // Просто индикация
		wlefDisalbePosOp  = 0x0002, // Блокировка розничной продажи
		wlefDisableBillOp = 0x0004  // Блокировка отгрузки клиентам
	};
	uint16 WarnLotExpirFlags;  // Опции действий при угрозе истечения срока годности лота
	SVerT  Ver;                // @anchor Версия, сформировавшая запись.
	TagFilt TagIndFilt;        // @anchor Фильтр тегов, определяющий окраску номеров документов в отчетах
	SString AddFilesFolder;    // Папка для автоматического присоединения файлов к документам. Строка хранится в реестре, а не в БД.
	TagFilt LotTagIndFilt;     // Фильтр тегов, определяющий окраску лотов
};
//
//
//
struct RentChrgFilt {
	RentChrgFilt();
	DateRange Period;
	PPID   CntrgntID;
};

struct CvtAt2Ab_Param {
	CvtAt2Ab_Param();
	enum {
		fNegAmount = 0x0001
	};
	PPID   LocID;
	PPID   OpID;
	PPID   ObjID;
	PPID   ExtObjID;
	long   Flags;
	const  PPIDArray * P_OpList;
};
//
// Descr: Карточка объекта основных средств
//
struct AssetCard {
	struct MovItem { // @flat
		PPID   BillID;
		PPID   LotID;
		PPID   DestLocID;
		double Price;
	};
	PPID   LotID;
	PPID   OrgLotID;
	double OrgCost;     // Начальная балансовая стоимость
	double OrgPrice;    // Начальная остаточная стоимость
	AcctID AssetAcctID;
	PPID   ExplBillID;
	SVector * P_MovList;
};
//
// @ModuleDecl(PPViewInventory)
//
struct InventoryFilt : public PPBaseFilt {
	InventoryFilt();
	void   Setup(PPID billID = 0);
	InventoryFilt & FASTCALL operator = (const InventoryFilt & rS);
	void   FASTCALL SetSingleBillID(PPID billID);
	PPID   GetSingleBillID() const;
	int    HasSubst() const;
	enum {
		fLack       = 0x0001, // Показывать недостачи
		fSurplus    = 0x0002, // Показывать излишки
		fAmtVal     = 0x0004, // Величина разногласий в суммовом выражении
		fPctVal     = 0x0008, // Процентная величина разногласий
		fWrOff      = 0x0010, // Показывать списанные строки
		fUnwrOff    = 0x0020, // Показывать не списанные строки
		fShowAbsenseGoods   = 0x0040, // Показывать товары, которых нет в документе,
			// но учетный остаток которых не нулевой. Этот флаг используется для печати
			// документа инвентаризации с нулевым остатком по умолчанию.
		fSelExistsGoodsOnly = 0x0080, // При вводе строк в списке выбора товаров отображать только товары, которые есть на текущем остатке.
		fMultipleTotal      = 0x0100  // Специализированный флаг, используемый функцией
			// InventoryCore::CalcTotal: если флаг установлен то InventoryCore::CalcTotal в начале
			// работы не очищает структуру InventoryTotal (необходимо для расчета итогов по нескольким документам
			// инвентаризации).
	};
	enum {
		ordByDefault = 0,
		ordByGoods   = 1,
		ordByDeficit = 2,
		ordByDiff    = 3
	};
	char   ReserveStart[4];    // @reserve
	PPID   GoodsID;            //
	PPID   GoodsGrpID;
	long   Flags;
	double MinVal;
	double MaxVal;
	double Amount;             // OUT Функция ViewInventory присваивает этой переменной сумму документа при завершении работы таблицы (модальной)
	int16  SortOrder;
	int16  Pad_;               // @alignment
	SubstGrpBill Sgb;          // Подстановка документа.
	SubstGrpGoods Sgg;         // Подстановка товара
	PPID   StorageLocID;       // Место хранения
	char   Reserve[16];        // @reserve
	ObjIdListFilt BillList;
	ObjIdListFilt GoodsList;
};

struct AutoFillInvFilt {
	AutoFillInvFilt();
	enum {
		fFillWithZeroQtty        = 0x0001,
		fRestrictZeroRestWithMtx = 0x0002, // Не добавлять в документ товары, которых нет на остатке и которые вне матрицы
		fExcludeZeroRestPassiv   = 0x0004  // @v11.1.2 Пассивные товары с нулевым остатком не включать безусловно (независимо от матрицы)
	};
	PPID   BillID;
	PPID   GoodsGrpID;
	long   Method;
	long   Flags;
	LDATE  DueDate;
};

struct InventoryTotal {
	InventoryTotal();

	PPID   ID;
	long   BillCount;
	long   ItemsCount;
	long   GoodsCount;
	double Quantity;
	double Amount;
	double StockRest;
	double StockAmount;
	double Surplus;
	double Lack;
	double DfctQtty;
	double DfctAmount;
};

#define INVENTF_GENAUTOLINE  0x00000001L // Автоматически сгенерированная строка (не подтвержденная)
#define INVENTF_GENWROFFLINE 0x00000002L // Строка сгенерирована при списании (списан по умолчанию весь остаток)
#define INVENTF_WRITEDOFF    0x00000004L // Строка списана
#define INVENTF_SURPLUS      0x00000008L // Знак рассогласований 1
#define INVENTF_LACK         0x00000010L // Знак рассогласований -1
#define INVENTF_AUTOLINE     (INVENTF_GENAUTOLINE|INVENTF_GENWROFFLINE)

#define INVENT_DIFFSIGN(f)  (((f) & INVENTF_SURPLUS) ? 1 : (((f) & INVENTF_LACK) ? -1 : 0))
#define INVENT_SETDIFFSIGN(f, sign) {f &= ~(INVENTF_SURPLUS|INVENTF_LACK); f |= (sign < 0) ? INVENTF_LACK : ((sign > 0) ? INVENTF_SURPLUS : 0);}
#define INVENT_SETAUTOLINE(f, autoLine) {f &= ~INVENTF_AUTOLINE; f |= (autoLine == 1) ? INVENTF_GENAUTOLINE : ((autoLine == 2) ? INVENTF_GENWROFFLINE : 0);}

class InventoryCore : public InventoryTbl {
public:
	friend class PPTblEnum <InventoryCore>;

	explicit InventoryCore(char * pFileName = 0);
	int    Search(PPID billID, long oprNo, void * = 0);
	int    SearchByGoods(PPID id, PPID goodsID, InventoryArray * pList);
	int    SearchIdentical(PPID billID, PPID goodsID, const char * pSerial, InventoryTbl::Rec * pRec = 0);
	SEnum::Imp * Enum(PPID billID);
	int    Set(PPID id, long * oprNo, InventoryTbl::Rec * rec, int use_ta);
	int    Remove(PPID id, int use_ta);
	int    Move(PPID destBillID, PPID srcBillID, int sgoptions /* INVMOVSGO_XXX */, int use_ta);
	//
	// Descr: Рассчитывает итоги по строкам инвентаризации в соответствии с фильтром.
	// ARG(pFilt       IN): @#{vptr}  Фильтр, в соответствии с которым перебираются строки инвентаризации
	// ARG(pTotal     OUT): @#{vptr0} Указатель на структуру, в которую заносятся итоговые значения по выборке.
	//   Функция предварительно очищает содержимое по структуры pTotal (если указатель не нулевой)
	// ARG(pGoodsList OUT): @#{vptr0} Указатель на массив, в который заносятся идентификаторы товаров,
	//   соответствующих строкам инвентаризации, удовлетворяющим фильтру pFilt. Функция не выполняет
	//   предварительную очистку массива. Элементы добавляются вызовом PPIDArray::adUnique
	//
	int    CalcTotal(const InventoryFilt * pFilt, InventoryTotal * pTotal, PPIDArray * pGoodsList = 0);
	int    CheckFlags(const InventoryFilt * pFilt, const InventoryTbl::Rec * pRec);
private:
	int    _Search(PPID, long *, int sp, void * = 0);
	int    CalcDiff(InventoryTbl::Rec *);
	int    InitEnum(PPID billID, long * pHandle);
	int    NextEnum(long enumHandle, void * pRec);
	int    DestroyIter(long enumHandle); // really private. Used by PPTblEnum <>

	PPTblEnumList EnumList;
};
//
// Descr: Структура, используемая для формирования строк документов, на основании товарных структур
//
struct ComplItem {
	ComplItem();

	PPID   GoodsID;
	long   GoodsFlags;
	uint   SrcGsPos;       // [1..] Позиция строки в исходной структуре (+1), к которой относится данных элемент
	long   GsID;           // @v11.2.4 Ид структуры, из которой сформирован элемент. Необходим в случаях, когда контейнер PPComplBlock формируется из нескольких структур
	long   GsiFlags;       // Флаги элемента структуры
	uint   FormulaP;       // @v11.2.4 Если количество элемента рассчитывается по формуле, то здесь хранится ненулевая позиция формулы в PPComplBlock::FPool
	double PartQty;
	double NeedQty;
	double FreeQty;
};

class PPComplBlock : public TSVector <ComplItem> {
public:
	PPComplBlock();
	int    Add(const PPGoodsStruc & rGs, uint srcGsPos, PPID parentGoodsID, double srcQtty, uint * pResultIdx);
	bool   GetFormula(uint idx/*0..*/, SString & rFormula) const;
	//
	// Descr: Возвращает указатель на структуру, ассоциированную с элементом по индексу idx.
	//   Если индекс idx неверный либо структура не найдена, то возвращает 0
	//   (в контексте использования данного класса, это - серьезная ошибка).
	//
	const  PPGoodsStruc * GetGoodsStruc(uint idx/*0..*/) const;
	int    Helper_InitCompleteData(const PPGoodsStruc & rGs, PPID goodsID, double needQty, const PPBillPacket * pBillPack, bool recursiveUnrollIncome);
	ComplItem Head;
private:
	SStrGroup FPool; // @v11.2.4 Пул формул
	TSCollection <PPGoodsStruc> GsList; // @v11.2.4
};
//
// Descr: Структура, содержащая информацию о заменах дефицитного товара DestID
//   на товары, имеющиеся на остатках. Используется при списании кассовых сессий,
//   драфт-документов и технологических сессий, а также при формировании MRP-таблиц.
//
class GRI : public SVector {
public:
	explicit GRI(PPID destID);
	int    Add(PPID srcID, double qtty, double ratio);
	PPID   FASTCALL GetSrcID(uint i) const;
	double FASTCALL GetQtty(uint i) const;
	double FASTCALL GetRatio(uint i) const;
	int    GetPosByGoods(PPID goodsID, uint * pPos) const;

	PPID   DestID;
};
//
// Descr: Коллекция структур экземпляров GRI.
//   Формируется функцией MrpTabCore::SetupRest
//
class GoodsReplacementArray : public TSCollection <GRI> {
public:
	explicit GoodsReplacementArray(PPID specialSubstGroupID = 0);
	int    Add(PPID destID, PPID srcID, double qtty, double ratio);
	const  GRI *  Search(PPID destID) const;
	const  PPIDArray * GetSpecialSubstGoodsList() const;
private:
	GRI *  SearchNC(PPID destID);
	PPID   SpecialSubstGroupID;
	PPIDArray SpecialSubstGoodsList;
};
//
// Объект PPObjBill служит оболочкой для выполнения //
// всех операций. В том числе и таких, в которых явно
// форма документа не высвечивается (чистые бухгалтерские проводки).
//
int PPObjBill_WriteConfig(PPBillConfig * pCfg, PPOpCounterPacket * pSnCntr, int use_ta);
//
//
//
struct PayableBillListItem {
	double MultExtCoef(double val, int zeroIfDivZero = 0) const;
	PPID   ID;
	PPID   CurID;
	LDATE  Dt;
	double Amount;
	double ExtAmt;  // Сумма документа в ценах поступления //
	double PaymAmt; // Сумма оплаты из записи документа. Используется если (CConfig.Flags2 & CCFLG2_USEOMTPAYMAMT)
};

class PayableBillList : public TSVector <PayableBillListItem> {
public:
	PayableBillList(AmtList * pAmt = 0, AmtList * pPaym = 0);
	void   FASTCALL GetIdList(LongArray & rList) const;
	int    FASTCALL AddBill(const BillTbl::Rec * pBillRec);
	int    AddPayableItem(const PayableBillListItem * pItem, long tabID, double paym, int useExtCoef);
	AmtList * P_Amt;       // @notowned
	AmtList * P_Paym;      // @notowned
};
//
// Descr: Структура, необходимая для автоматического создания платежных
//   поручений по списку документов.
//   PPObjBill::CreateBankingOrders
//
struct PPGPaymentOrder : public PPBankingOrder {
	PPID   ArID;
	PPID   Ar2ID;
	long   Options;
	PPIDArray LinkBillList;
};
//
// Descr: Список платежных поручений, автоматически сформированных
//   по списку документов.
//   PPObjBill::CreateBankingOrders
//
typedef TSCollection <PPGPaymentOrder> PPGPaymentOrderList;
//
// Descr: Блок параметров для создания документа по образцу
//
struct SelAddBySampleParam {
	SelAddBySampleParam();
	enum {
		fCopyBillCode    = 0x0001,
		fNonInteractive  = 0x0002,
		fAll             = 0x0004, // Сформировать документы для всей выборки (только если выборка по
			// одному виду операции). Автоматически предполагате fNonInteractive
		fRcptAllOnShipm  = 0x0008, // При формировании отгрузки по заказу ВЕСЬ заказанный товар безусловно оприходовать.
		fRcptDfctOnShipm = 0x0010, // @v12.0.7 При формировании отгрузки по заказу НЕДОСТАЮЩИЙ заказанный товар безусловно оприходовать.
	};
	enum {
		acnUndef               = -1, // Не определено
		acnStd                 =  0, // Стандартный документ по образцу
		acnShipmByOrder        =  1, // Отгрузка по заказу
		acnDraftExpByOrder     =  2, // Драфт-расход по заказу
		acnDraftRcpByOrder     =  3, // Драфт-приход по заказу
		acnDraftExpRestByOrder =  4, // Драфт-расход по заказу (только не отгруженные позиции)
		acnShipmAll            =  5, // Отгрузить весь оприходованный товар
		acnDraftExpByDraftRcpt =  6, // @v11.0.2 Драфт-расход по драфт-приходу
		acnDraftRcptByDraftExp =  7, // @v11.0.2 Драфт-приход по драфт-расходу
	};
	long   Action;
	PPID   OpID;
	PPID   LocID;
	PPID   QuotKindID; // Вид котировки для установки цен в создаваемом документе
	LDATE  Dt;         // Дата нового документа. Если ZERODATE, то равняется документу образца
	long   Flags;
	BillTbl::Rec SampleBillRec;
};
//
// Descr: Класс, управляющий объектом данных PPOBJ_BILL
//
class PPObjBill : public PPObject {
public:
	static int FASTCALL ReadConfig(PPBillConfig *);
	static int EditConfig();
	//
	// Descr: Опции формирования строки наименования документа
	//
	enum {
		mcsAddOpName  = 0x0001, // Добавлять наименование вида операции
		mcsAddLocName = 0x0002, // Добавлять наименование склада
		mcsAddObjName = 0x0004, // Добавлять наименование контрагента
		mcsAddSCard   = 0x0008  // Добавить код персональной карты, связанной с документом
	};
	static SString & FASTCALL MakeCodeString(const BillTbl::Rec * pRec, int options, SString & rBuf);
	//
	// Descr: Возвращает !0, если владельцем пула документов с ассоциацией assocID (PPASS_XXX)
	//   является документ. Если тип ассоциации недействителен или владельцем пула является объект
	//   типа, отличного от PPOBJ_BILL, то возвращает 0.
	//
	static bool FASTCALL IsPoolOwnedByBill(PPID assocID);
	static int  FASTCALL VerifyUniqSerialSfx(const char * pSfx);

	explicit PPObjBill(void * extraPtr = 0);
	~PPObjBill();
	virtual int  Search(PPID id, void * = 0);
	virtual void FASTCALL Dirty(PPID id); // @macrow
	virtual int  Browse(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Заполняются следующие поля: ID, Code, Dt, OpID, LocID, Object, Flags, Amount
	//
	int    Fetch(PPID id, BillTbl::Rec * pRec);
	int    FetchExt(PPID id, PPBillExt * pExt);
	int    FetchFreight(PPID id, PPFreight * pFreight);
	int    GetCrBillEntry(long & rTempID, PPBillPacket * pPack);
	int    SetCrBillEntry(long tempID, const PPBillPacket * pPack);
	//
	// Descr: осуществляет кэшированное извлечение расширенных примечаний
	//   по документу id.
	// Returns:
	//   >0 - строка расширенных примечаний найдена
	//   <0 - для документа id расширенное примечание отсутствует
	//   0  - ошибка
	//
	int    FetchExtMemo(PPID id, SString & rBuf);
	const  StrAssocArray * GetFullSerialList();
	void   ReleaseFullSerialList(const StrAssocArray * pList);
	void   ResetFullSerialList();
	//
	// Поиск документа по GUID. GUID хранится в PropertyTbl::Text
	//
	int    SearchByGuid(const S_GUID & rUuid, BillTbl::Rec * pRec);
	int    PutGuid(PPID id, const S_GUID * pUuid, int use_ta);
	int    GetGuid(PPID id, S_GUID * pUuid);
	//
	// Descr: Флаги редактирования документов
	//
	enum {
		//efCreate      = 0x0001, // Использовать при редактировании нового документа
		efEdit        = 0x0002, // Использовать при редактировании существующего документа
		efForceModify = 0x0004, // Редактирование существующего документа с форсированным признаком modified (некоторые поля блокируются)
		efNoUpdNotif  = 0x0008, // Не выводить сообщение о том что документ был модифицирован
		efCascade     = 0x0010  // Связанный документ (каскадное позиционирование)
	};
	//
	// Descr: Параметры редактирования документов
	//
	struct EditParam {
		EditParam();
		long   Flags; // PPObjBill::efXXX
	};

	virtual int  Edit(PPID * pID, void * extraPtr /* (PPObjBill::EditParam *) */);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);

	struct CreateNewInteractive_Param {
		enum {
			poUndef = 0,
			poBuyerOrder = 1,
			poSupplOrder = 2,
			poReceipt    = 3,
			poBuyerSale  = 4,
			poIntrExpend = 5,
			poInventory  = 6,
			poAccTurn    = 7
		};
		enum {
			fShowBrowserAfterCreation = 0x0001
		};
		static int OpTypeListByBbt(PPID bbt, PPIDArray * pOpTypeList);
		CreateNewInteractive_Param();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		long   PredefOp;
		PPID   Bbt;
		PPID   OpID;
		PPID   LocID;
		long   Flags;
	};
	int    EditCreateNewInteractiveParam(CreateNewInteractive_Param * pData);
	int    CreateNewInteractive(CreateNewInteractive_Param * pP);
	int    CheckRightsWithOp(PPID opID, long rtflags);
	int    Lock(PPID billID);
	int    Unlock(PPID billID);
	int    CheckStatusFlag(PPID statusID, long flag);
	int    FASTCALL GetEdiUserStatus(const BillTbl::Rec & rRec);
	//
	// Descr: Флаги функции PPObjBill::ValidatePacket
	//
	enum {
		vpfFreightOnly = 0x0001 // Проверять только поля фрахта
	};
	//
	// Descr: Проверяет непротиворечивость и правильность пакета pPack.
	//   Флаги flags могут ограничивать область проверки.
	//
	int    ValidatePacket(PPBillPacket * pPack, long flags);
	int    IsPacketEq(const PPBillPacket & rS1, const PPBillPacket & rS2, long flags);
	int    IsPaymentBill(const BillTbl::Rec & rRec);
	int    ViewHistory(PPID histID);
	int    SetupModifPacket(PPBillPacket * pPack);
	int    TurnPacket(PPBillPacket * pPack, int use_ta);
	int    __TurnPacket(PPBillPacket * pPack, PPIDArray * pList, int skipEmpty, int use_ta);
	int    UpdatePacket(PPBillPacket * pPack, int use_ta);
	int    ExtractPacket(PPID id, PPBillPacket * pPack);
	int    ExtractPacketWithFlags(PPID id, PPBillPacket * pPack, uint flags /* BPLD_XXX */);
	int    ExtractPacketWithRestriction(PPID id, PPBillPacket * pPack, uint flags /* BPLD_XXX */, const PPIDArray * pGoodsList);
	//
	// Descr: Выясняет содержит ли документ с идентификатором id по крайней мере один товар из списка rGoodsList.
	//   NB: Список rGoodsList должен быть отсортирован по возврстанию (LongArray::sort)
	// Returns:
	//   >0 - документ содержит товар(ы) из списка rGoodsList
	//   <0 - документ НЕ содержит товар(ы) из списка rGoodsList
	//   0  - ошибка (например, документ не найден, rGoodsList не отсортирован и т.п.)
	//
	int    DoesContainGoods(PPID id, const PPIDArray & rGoodsList);
	//
	// Descr: Извлекает из истории объектов оригинальный пакет документа (каким он был при первом проведении).
	//   Функция будет успешной только в том случае, если включена история изменений документов или же документ
	//   не менялся.
	// Returns:
	//   -1 - документ менялся, однако история измений не ведется, следовательно найти оригинальную копию не возможно
	//   -2 - не удалось найти в системном журнале событие создания документа
	//   1  - документ не менялся. По указателю pPack ничего не присваивается (с целью сократить издержки на, возможно,
	//      избыточную операцию извлечения текущего пакета).
	//   2  - документ менялся и удалось извлечь из истории оригинал, который присваивается по указателю pPack.
	//   0  - ошибка
	//
	int    GetOriginalPacket(PPID billID, SysJournalTbl::Rec * pSjRec, PPBillPacket * pPack);
	int    RemovePacket(PPID, int use_ta);
	int    UpdatePool(PPID poolID, int use_ta);
	int    RecalcTurns(PPID, long flags /* BORTF_XXX */, int use_ta);
	int    RecalcPayment(PPID id, int use_ta);
	int    LockFRR(LDATE, int * pFRRL_Tag, int use_ta);
	int    UnlockFRR(int * pFRRL_Tag, int isCrash, int use_ta);
	int    CheckAmounts(PPID, PPLogger &);
	//
	// Descr: Извлекает идентификатор лота заказа, к которому привязана строка отгрузки rTrfrRec.
	// Returns:
	//   >0 - строка rTrfrRec привязана к заказу и идентификатор заказа успешно извлечен
	//   <0 - строка rTrfrRec либо не привязана к заказу, либо не удалось найти соответствующий лот заказа
	//   0  - ошибка
	//
	int    GetOrderLotForTransfer(const TransferTbl::Rec & rTrfrRec, PPID * pOrdLotID);
	//
	// Descr: Вызывает диалог изменения статуса документ billID
	//   Если пользователь выбрал новый статус и подтвердил ввод, то
	//   изменяет статус документа billID
	// Returns:
	//   >0 - пользователь выбрал новый статус и операция изменения статуса прошла успешно
	//   <0 - пользователь отказался от изменения статуса документа
	//   0  - ошибка
	//
	int    EditBillStatus(PPID billID);
	//
	// Descr: Вызывает диалог редактирования параметров фрахта документа pPack.
	// Returns:
	//   1 - пользователь подтвердил редактирование фрахта. При этом фрахт не пустой либо
	//     дата отгрузки не нулевая и отличается от даты документа.
	//     В пакете pPack устанавливаются новые параметры фрахта.
	//   100 - пользователь подтвердил редактирование фрахта. Однако, фрахт пуст и дата
	//     отгрузки не отличается от даты документа. В пакете pPack фрахт обнуляется.
	//   <0 - пользователь отклонил редактирование либо документ не требует параметров фрахта.
	//   0  - ошибка. Если пользователь не имеет прав на изменение фрахта, то также возвращается 0.
	//
	int    EditFreightDialog(PPBillPacket & rPack);
	int    CheckParentStatus(PPID billID);
	int    EditGenericAccTurn(PPBillPacket *, long flags);
	int    EditGoodsBill(PPID id, const EditParam * pExtraParam);

	struct SearchBlock {
		enum {
			fContext     = 0x0001,
            fCode        = 0x0002,
            fInvoiceCode = 0x0004,
            fOuterCode   = 0x0008,
            fMemo        = 0x0010,
            fExtMemo     = 0x0020,
            fMainDate    = 0x0040,
            fInvoiceDate = 0x0080,
            fOuterDate   = 0x0100
		};
		long   Flags;
		DateRange Period;
		SString Text;
	};
	//
	// Descr: Фреймовый блок, используемый в функция проведения документа.
	//
	class TBlock {
	public:
		friend class PPObjBill;

		TBlock();
		int16 & Rbb() { return CurRByBill; } // non-const because caller may change a value by the returned reference
		int16  GetNewRbb();
	private:
		PPID   BillID;
		int16  OrgLastRByBill;
		int16  CurRByBill;
	};
	int    BeginTFrame(PPID billID, TBlock & rBlk);
	int    FinishTFrame(PPID billID, TBlock & rBlk);
	//
	struct AddBlock {
		explicit AddBlock(const AddBlock * pBlk = 0);

		PPID   SampleBillID;
		PPID   OpID;
		PPID   LinkBillID;
		PPID   RegisterID; // если OpID == 0 и registerID != 0, тогда функция AddAccturn //
			// предложит пользователю выбрать операцию из тех, которые имеют подтип OPSUBT_REGISTER
		PPID   ObjectID;
		PPID   Object2ID;
		PPBillPacket::PoolKind Pk;
		PPID   PoolID;
		PPID   LocID;
		PPID   FirstItemLotID; // Лот, который необходимо вставить в строки документов первым 'лементом.
		int    FirstItemSign;
		double FirstItemQtty;  // Количество, соответствующее автоматичекой строке FirstLotID (по умолчанию - 1)
	};
	int    AddGoodsBill(PPID * pBillID, const AddBlock * pBlk);
	//
	// Descr: создает документ по образцу указанного фильтра, и открывает диалог редактирования документа.
	//   Если sCardID != 0, функция подставляет в документ скидку по карте.
	//
	int    AddGoodsBillByFilt(PPID * pBillID, const BillFilt *, PPID opID, PPID sCardID = 0, const CCheckTbl::Rec * pChkRec = 0);
	int    AddExpendByReceipt(PPID *, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    AddExpendByOrder(PPID *, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    AddDraftBySample(PPID * pBillID, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    AddRetBill(PPID opID, long link, PPID locID);
	int    AddRetBillByLot(PPID lotID);
	void   DiagGoodsTurnError(const PPBillPacket *);
	int    GetCurRate(PPID curID, PPID rateTypeID, PPID relCurID, LDATE * pDt, double * pRate);
	int    GetCurRate(PPID curID, LDATE * pDt, double * pRate);
		// @>>GetCurRate(curID, LConfig.BaseRateTypeID, LConfig.BaseCurID, pDt, pRate)
	//
	// Descr: Флаги функции SetupImportedPrice()
	//
	enum {
		sipfAllowZeroPrice = 0x0001
	};

	int    SetupImportedPrice(const PPBillPacket * pPack, PPTransferItem * pTi, long flags);
	//
	// Descr: используется для загрузки списка строк расширения бух документа
	//   в PPBillPacke и в ILBillPacket. По-этой причине она абстрагирукется от конкретного
	//   типа пакета, а требует лишь те параметры, которые необходимы.
	//
	int    LoadAdvList(PPID billID, PPID opID, PPAdvBillItemList *);
	int    TurnAdvList(PPID billID, PPBillPacket * pPack, int use_ta);
	//
	// Descr: Ищет ссылку на billID среди строк расширения бухгалтерских документов.
	//   Если ссылка найдена, то по указателю pItemRec возвращается запись ссылающейся //
	//   строки, а по указателю pBillRec - запись документа, которому принадлежит эта строка.
	// Returns:
	//   >0 - запись найдена.
	//   <0 - запись не найдена
	//   0  - ошибка
	//
	int    SearchAdvLinkToBill(PPID billID, AdvBillItemTbl::Rec * pItemRec, BillTbl::Rec * pBillRec);
	//
	// Descr: Определяет, является лот, заданный идентификатором lotID, лотом основных фондов
	// Returns:
	//   >0 - да является //
	//   <0 - нет не является или не найден
	//   0  - ошибка
	//
	int    IsAssetLot(PPID lotID);
	int    MakeAssetCard(PPID lotID, AssetCard *);
	int    GetTagList(PPID billID, ObjTagList * pTagList);
	int    SetTagList(PPID billID, const ObjTagList * pTagList, int use_ta);

	enum {
		ltfGoodsName = 0x0001,
		ltfLocName   = 0x0002
	};
	SString & MakeLotText(const ReceiptTbl::Rec * pLotRec, long fmt, SString & rBuf);
	//
	// Descr: загружает в пакет pPack информацию о грузовых
	//   таможенных декларациях, ассоциированных с лотами. Если параметр
	//   pTagCore != 0, то для загрузки используется он, в противном случае
	//   метод самостоятельно создает объект ObjTagCore и использует его для загрузки.
	//   Если параметр force == 0, то информация о номерах ГТД загружается //
	//   только тогда, когда пакет pack имеет тип операции PPOPT_GOODSRECEIPT,
	//   то есть для редактирования номеров ГТД.
	//   Если же force != 0, то номера ГТД загружаются не зависимо от того,
	//   к какому типу операций относится пакет.
	//
	int    LoadClbList(PPBillPacket * pPack, int force);
	int    LoadRowTagListForDraft(PPID billID, PPLotTagContainer & rContainer);
	int    GetClbNumberByLot(PPID lotID, bool * isParentLot, SString & rBuf);
	int    GetSerialNumberByLot(PPID lotID, SString & rBuf, int useCache);
	//
	// Descr: Функция выясняет существует ли хоть одна марка в таблице LotExtCodeTbl (P_LotXcT), связанная с лотом lotID.
	//   Функция реализована как хелпер для Receipt::GetList в случае, если последняя вызывается с флагом ReceiptCore::glfWithExtCodeOnly.
	// Returns:
	//   >0 - с лотом lotID связана по крайней мере одна марка
	//   <0 - не существует марок, ассоциированных с лотом lotID
	//    0 - error
	//
	int    HasLotAnyMark(PPID lotID);
	//
	// Descr: Функция возвращает по ссылке rSs список марок (честный знак и егаис), ассоциированных с лотом lotID.
	//   Сет rSs предварительно очищается функцией.
	// Returns:
	//   >0 - найдена по крайней мере одна марка, ассоциированная с лотом lotID
	//   <0 - с лотом марки не ассоциированы
	//    0 - ошибка (либо lotID == 0, либо this->P_LotXcT [type of LotExtCodeCore] == 0)
	//
	int    GetMarkListByLot(PPID lotID, StringSet & rSs);
	int    GetTagListByLot(PPID lotID, int skipReserveTags, ObjTagList * pList);
	int    SetClbNumberByLot(PPID lotID, const char *, int use_ta);
		// @>>PPObjBill::SetTagNumberByLot
	int    SetSerialNumberByLot(PPID lotID, const char *, int use_ta);
		// @>>PPObjBill::SetTagNumberByLot
	int    AdjustSerialForUniq(PPID goodsID, PPID lotID, int checkOnly, SString & rSerial);
	int    ReleaseSerialFromUniqSuffix(SString & rSerial) const;
	//
	// Descr: Опции функции SelectLotFromSerial
	//
	enum {
		slbsIncClosed = 0x0001 // Включить в выбор и закрытые лоты
	};
	//
	// Descr: Находит список идентификаторов лотов, соответствующих серийному номеру pSerial.
	//   Указатель pList может быть нулевым.
	// Returns:
	//   >0 - Найден один или более лот, соответствующий pSerial
	//   <0 - Не найдено ни одного лота
	//   0  - Ошибка
	//
	int    SearchLotsBySerial(const char * pSerial, PPIDArray * pList);
	int    SearchLotsBySerialExactly(const char * pSerial, PPIDArray * pList);
	int    SelectLotFromSerialList(const PPIDArray *, PPID locID, PPID * pLotID, ReceiptTbl::Rec * pRec = 0);
	int    SelectLotBySerial(const char * pSerial, PPID goodsID, PPID locID, ReceiptTbl::Rec * pRec);

	struct SelectLotParam {
		SelectLotParam(PPID goodsID, PPID locID, PPID excludeLotID, long flags);

		enum {
			fFillLotRec     = 0x0001,
			fWithSerialOnly = 0x0002,
			fEnableZeroRest = 0x0004,
			fNotEmptySerial = 0x0080,
			fShowEgaisTags  = 0x0100,
			fShowBarcode    = 0x0200,
			fShowQtty       = 0x0400,
			fShowPhQtty     = 0x0800,
			fShowVetisTag   = 0x1000,
			fShowManufTime  = 0x2000
		};
		PPID   LocID;
		PPID   ExcludeLotID;
		DateRange Period;
		long   Flags;
		PPIDArray GoodsList;
		PPIDArray AddendumLotList; // Список идентификаторов лотов, которыми должен быть дополнен отображаемый список
		SString Title; // Опциональный заголовок окна выбора лота
		//
		PPID   RetLotID;
		SString RetLotSerial;
		ReceiptTbl::Rec RetLotRec;
	};
	int    SelectLot2(PPObjBill::SelectLotParam & rParam);
	int    GetSnByTemplate(const char * pBillCode, PPID goodsID, const PPLotTagContainer * pExclList, const char * pTempl, SString & rBuf);
	int    GetLabelLotInfo(PPID lotID, RetailGoodsInfo *);
	//
	// Descr: Флаги функции GetComplete()
	//
	enum {
		gcfGatherSources  = 0x0001, // Собирать информацию об источниках происхождения лота
        gcfGatherBranches = 0x0002  // Собирать информацию о порожденных комплектацией лотах
	};
	//
	//
	//
	int    GetComplete(PPID lotID, long flags, CompleteArray * pList);
	//
	// Descr: Находит парный товарный документ для документа billID.
	//   Пары могут быть следующего вида:
	//     {драфт - документ списания}, {документ списания - драфт}, {товарный документ - подтверждение}, {подтверждение - товарный документ}
	//
	int    GetComplementGoodsBillList(PPID billID, PPIDArray & rComplBillList);
	//
	// Descr: Находит цепочку документов, предшествующих документу коррекции billID.
	// Note: Первый документ в результирующем списке (если тот не пустой) - оригинальный корректируемый документ,
	//   все последующие - в хронологическом порядке документы коррекции, предшествующие billID.
	// Returns:
	//   <0 - не найдено ни одного документа, в том числе и оригинального корректируемого (это - плохо).
	//   0  - ошибка
	//   1  - найден только оригинальный корректируемый документ.
	//   2  - кроме оригинального корректируемого документа в цепочке есть один или более других документов коррекции.
	//
	int    GetCorrectionBackChain(PPID billID, PPIDArray & rChainList);
	int    GetCorrectionBackChain(const BillTbl::Rec & rBillRec, PPIDArray & rChainList);
	int    GetAccturn(const AccTurnTbl::Rec *, PPAccTurn *, int useCache);
	//
	// Descr: Интерактивная функция ввода нового бухгалтерского документа.
	// Parameters:
	//   pBillID - возвращаемый ид созданного документа
	//   ab.OpID - ид вида операции. Если opID == 0, тогда функция //
	//     предлагает пользователю выбрать операцию.
	//   ab.RegisterID - если opID == 0 и ab.RegisterID != 0, тогда функция //
	//     предложит пользователю выбрать операцию из тех, которые имеют подтип OPSUBT_REGISTER
	// Returns:
	//   >0 - документ успешно добавлен
	//   <0 - пользователь отказался от ввода документа
	//   0  - ошибка
	//
	int    AddAccturn(PPID * pBillID, const AddBlock * pBlk);
		// @>>PPObjBill::AddGenAccturn, @>>PPObjBill::AddGoodsBill
		// @>>::SelectOprKind, @>>::SelectOpKind
	int    AddGenAccturn(PPID * pBillID, PPID opID, PPID registerID);
	int    AddAccturnBySample(PPID * pBillID, PPID sampleBillID);
	int    EditAccTurn(PPID);
	int    EditBillExtData(PPID billID);
	int    EditBillFreight(PPID billID);
	int    EditLotExtData(PPID lotID);
	//
	// Descr: Извлекает адрес доставки документа.
	//   В общем случае адрес доставки хранится в дополнительной записи документа pFreight. Однако,
	//   если контрагентом в документе является статья, проецируемая на склад и явно во фрахте
	//   адрес доставки не указан, то адресом доставки будет склад, на который проецируется статья.
	// ARG(rBillRec IN):
	// ARG(pFreight IN):
	// ARG(pDlvrAddrID OUT):
	// Returns:
	//   1 - pFreight определяют не нулевой адрес доставки.
	//   2 - pFreight не содержит адреса доставки, но контрагент документа является складом и он может трактоваться как адрес доставки
	//   <0 - адрес доставки не определен
	//    0 - error
	//
	int    GetDlvrAddrID(const BillTbl::Rec & rBillRec, const PPFreight * pFreight, PPID * pDlvrAddrID); // @v12.1.11
	//
	// Descr: Вызывает диалог редактирования системной информации по лоту
	//
	int    EditLotSystemInfo(PPID lotID);
	int    UpdateOpCounter(PPBillPacket * pPack);
	int    SetWLabel(PPID, int mode);
	//
	// Descr: Устанавливает статус statusID у документа billID.
	//   Выполняет все проверки необходимые для установки заданного статуса.
	//
	int    SetStatus(PPID billID, PPID statusID, int use_ta);
	//
	// Descr: Выводит на экран таблицу со списком оплат (или других связанных документов),
	//   привязанных к документу billID.
	//   Функция проверяет существование документа по billID и то, чтобы этот
	//   документ требовал оплаты.
	// ARG(billID IN): Идентификатор документа, к которому привязанны просматриваемые документы
	// ARG(kind   IN): Категория просматриваемых документов
	//   0 - оплаты
	//   1 - начисления ренты
	//   2 - зачитывающие оплаты
	// Returns:
	//   >0 - сумма долга в результате работы пользователя изменилась.
	//   <0 - сумма долга не изменилась
	//   0  - ошибка
	//
	int    ViewPayments(PPID billID, int kind);
	//
	// Descr: вызывает модальный броузер просмотра бух проводок по документу billID.
	//   В этом броузере не допускаются какие-либо изменения.
	// Returns:
	//   0 - Error (called PPError())
	//  -1 - OK (no modifications)
	//
	int    ViewAccturns(PPID billID);
	int    FillTurnList(PPBillPacket *);
	int    UniteGoodsBill(PPBillPacket *, PPID addBillID, int use_ta);
	int    UniteReceiptBill(PPID destBillID, const PPIDArray & rSrcArray, int use_ta);
	int    PrintCheck__(PPBillPacket * pPack, PPID posNodeID, int addSummator);
	int    PosPrintByBill(PPID billID);
	SArray * MakePaymentList(PPID, int charge);
	int    ViewBillInfo(PPID billID);
	int    SubstText(const PPBillPacket * pPack, const char * pTemplate, SString & rResult);
	int    SubstMemo(PPBillPacket * pPack);
	//
	// Descr: Вставляет товарную строку (или строки), создаваемые по образцу
	//   типа ILTI в пакет документа PPBillPacket.
	// ARG(pItem IN):     структура, содержащая информацию о вставляемой
	//   в документ товарной строке
	// ARG(pPack IN/OUT): пакет товарного документа, в который вставляется строка
	// ARG(pRows OUT):    указатель на массив позиций товарных строк документа, в
	//   которые были добавлены новые элементы
	// ARG(flags IN):     флаги, определяющие особенности добавления новой строки (строк)
	//   см примечания к флагам CILTIF_XXX
	// Returns:
	//   > 0   - OK
	//     0   - Error
	// Remark:
	//   После вызова функции необходимо проверить поле pItem->Rest. Если его
	//   значение не равно 0, значит функции не удалось полностью вставить
	//   строку в документ (например, из-за недостатка товара pItem->GoodsID).
	//
	int    ConvertILTI(ILTI *, PPBillPacket *, LongArray * pRows, uint, const char * pSerial, const GoodsReplacementArray * pGri = 0);
	//
	// Descr: Флаги функции InsertShipmentItemByOrder()
	//
	enum {
		isibofInteractive         = 0x0001, // интерактивный режим 
		isibofErrOnCompletedOrder = 0x0002  // если заказ по позиции orderItemIdx уже выполен, то функция возвращает 0 и устанавливает код ошибки PPERR_ORDISCOMPLETED
	};
	//
	// ARG(maxQtty IN): Максимальное количество, которое необходимо вставить в документ pPack по заказу pOrderPack.
	//   Если maxQtty <= 0.0, то это трактуется как "вставляй столько, сколько заказано".
	// ARG(flags IN): @flags PPObjBill::isibofXXX (see above)
	//
	int    InsertShipmentItemByOrder(PPBillPacket * pPack, const PPBillPacket * pOrderPack, int orderItemIdx, PPID srcLotID, double maxQtty, uint flags);
	int    AdjustIntrPrice(const PPBillPacket * pPack, PPID goodsID, double * pAdjPrice);
	int    CmpSnrWithLotSnr(PPID lotID, const char * pSerial, bool serialIsRefB);
	int    ConvertBasket(const PPBasketPacket & rBasket, PPBillPacket * pPack);
	//
	// Descr: конвертирует докумет srcID общей (не расширенной)
	//   бух проводки в документ расширенной бух операции opID.
	//   Если negAmount != 0, то сумма конвертированного документа изменяет знак.
	//   В результате конвертации документ srcID удаляется, и создается документ с ид *pDestID.
	//
	int    ConvertGenAccturnToExtAccBill(PPID srcID, PPID * pDestID, const CvtAt2Ab_Param * pParam, int use_ta);
	int    GetShipmByOrder(PPID orderID, const DateRange *, PPIDArray & rList);
	int    EnumMembersOfPool(PPID poolType, PPID poolOwnerID, PPID * pMemberID, BillTbl::Rec * pRec = 0);
	int    IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID);
		// @>>P_Tbl->IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID)
	//
	// Descr: Возвращает период расчета долгов по контрагенту, определяемый нижней границей
	//   расчета, заданной в конфигурации (PPBillConfig::LowDebtCalcDate).
	// Если период пустой, то возвращает 0, в противном случае - указатель на rPeriod
	//
	DateRange * FASTCALL GetDefaultClientDebtPeriod(DateRange & rPeriod) const;

	struct DebtBlock {
		DebtBlock();
		DebtBlock & Z();
		int    AddDimItem(PPID dimID, double debt, int expiry);
		void   GetDimList(RAssocArray & rList) const;

		double Amount;
		double Debt;
		int    HasMatured;
		int    MaxDelay;   // Максимальная задержка между текущей датой и датой документа
		int    MaxExpiry;  // Максимальная задержка между текущей датой и последним сроком оплаты по документу
		struct DimItem { // @flat
			DimItem(PPID dimID, double debt, int expiry);
			PPID   DimID;
			int    MaxExpiry;
			double Debt;
		};
		TSVector <DimItem> DebtDimList; // Список сумм задолженности, ассоциированных с долговыми размерностями //
	};
	//
	// (pPeriod == 0) -> (pPeriod->low == 0 && pPeriod->upp == 0)
	//
	int    CalcClientDebt(PPID clientID, const DateRange * pPeriod, int diffByDebtDim, DebtBlock & rBlk);
	int    CalcReturnPart(PPID arID, const DateRange & rPeriod, double * pShipment, double * pRet);
	int    GetReceivableBillList(PPID arID, PPID curID, PayableBillList * pList);
	//
	// Descr: Флаги функции PPObjBill::CreateBankingOrders
	//
	enum {
		cboIn              = 0x0001, // Создавать входящие платежные ордера (получатель - главная организация)
		cboSkipUndefBnkAcc = 0x0002  // Если плательщик или получатель не имеют определенных банковских
			// счетов, то не формировать для таких контрагентов платежных ордеров.
	};
	//
	// Descr: Формирует список банковких платежных поручений на основе списка
	//   идентификаторов долговых документов rBillList.
	//   Документы в rBillList объединяются в группы по идентификатору
	//   контрагента.
	//
	int    CreateBankingOrders(const PPIDArray & rBillList, long flags, PPGPaymentOrderList & rOrderList);
	//
	// Reckoning functions
	//
	int    Reckon(PPID paymBillID, PPID debtBillID, PPID reckonOpID, PPID * pReckonBillID,
		int negativePayment, int dateOption /* RECKON_DATE_XXX */, LDATE reckonDate, int use_ta);
	int    GatherPayableBills(ReckonOpArItem * pItem, PPID curID, PPID locID, PPID obj2ID, const DateRange *, double * pDebt);
	struct ReckonParam {
		explicit ReckonParam(int automat = 1, int dontConfirm = 0);

		enum {
			fAutomat     = 0x0001, // Зачитывать автоматически (по умолчанию TRUE)
			fDontConfirm = 0x0002, // Не запрашивать предупреждение (по умолчанию FALSE)
			fPopupInfo   = 0x0004  // Показывать всплывающее окно с информацией о зачете
		};
		long   Flags;
		PPID   ForceBillID;
		LDATE  ForceBillDate;
		char   ForceBillCode[24];
	};
	int    ReckoningPaym(PPID billID, const ReckonParam & rParam, int use_ta);
	int    ReckoningDebt(PPID billID, const ReckonParam & rParam, int use_ta);
	//
	// Descr: Корректирующая функция. Проверяет и, если надо, исправляет оплаты
	//   и признаки оплат по документам
	//
	int    GatherPayments();
	int    AutoCharge(PPID, PPID op, const PPRentCondition *, const DateRange *, PPLogger * pLogger);
	int    AutoCharge(PPID);
	int    AutoCharge();
	int    AutoCalcPrices(PPBillPacket * pPack, int interactive, int * pIsModified);
	int    SelectQuotKind(PPBillPacket * pPack, const PPTransferItem * pTi, int interactive, double * pQuot);
	int    SetupQuot(PPBillPacket * pPack, PPID forceArID);
	int    ViewLotComplete(PPID lotID, PPID * pSelectedLotID);
	int    SearchPaymWOLinkBill();
	//
	// Descr: Аварийная функция - восстанавливает ссылки на объединенные города,
	//   зависшие во фрахтах документов.
	//
	int    RecoverUnitedFreightPorts();
	//
	// Descr: Рассчитываеть сальдо по товарным операциям по товару goodsID и контрагенту arID.
	//   Расчет ведется в рамках периода pPeriod, если pPeriod != 0. Если endOprNo != 0,
	//   то перечисляются только те операции, пара {Dt, OprNo} которых меньше пары {pPeriod->upp, endOprNo}.
	//   Если pPeriod == 0 или pPeriod->upp == ZERODATE, то параметр endOprNo игнорируется.
	// Note: Еще раз обратим внимание на то, что операция с парой {pPeriod->upp, endOprNo} не входит
	//   в рассмотрение при расчете.
	//
	int    CalcGoodsSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, const DateRange * pPeriod, long endOprNo, double * pSaldoQtty, double * pSaldoAmt);
	int    GetGoodsSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, LDATE dt, long oprNo, double * pSaldoQtty, double * pSaldoAmt);
	int    GetPriceRestrictions(PPBillPacket & rPack, const PPTransferItem & rTi, int itemPos, RealRange * pRange);
	int    GetPriceRestrictions(PPID goodsID, PPID lotID, double cost, double price, RealRange * pRange);
	//
	// Inventory
	//
	enum InvMovSgo {
		imsgoAdd = 0,
		imsgoSkip,
		imsgoFail
	};
	struct InvItem {
		void   Init(PPID goodsID, const char * pSerial);

		PPID   GoodsID;          // @in
		char   Serial[24];       // @in
		long   Flags;            // @in INVENTF_XXX
		LDATE  RestDt;           // @in Дата, на которую надо расчитывать учетный остаток (если 0, то на дату инвентаризации)
		long   RestOprNo;        // @in Номер операции за день, до которой следует брать в расчет учетный остаток (если 0, то на конец дня)
		double UnitPerPack;      // @in
		double Qtty;             // @in
		double Cost;             // @in
		double Price;            // @in
		const  InventoryArray * P_InvList;
		//
		// Исходящие состояния добавления строки
		//
		enum {
			stAddedToExistLine = 0x0001, // Количество добавлено к существующей строке
			stUpdatedAutoLine  = 0x0002, // Изменена авто-строка
			stFailOnDup        = 0x0004, // Вставка строки закончилась неудачно из-за существования аналогичной позиции в документе (InvBlock::Flags & InvBlock::fFailOnDup)
			stSkip     = 0x0008  // Строка не проведена по штатным причинам (returns -1)
		};
		double FinalQtty;        // @out
		double FinalPrice;       // @out
		double FinalRest;        // @out
		double StockPrice;       // @out Цена инвентаризации, вычисленная функцией GetInventoryStockRest
		long   State;            // @out
	};
	class InvBlock {
	public:
		enum {
			fPriceByLastLot    = 0x0001, // Цену брать из последнего лота
			fFailOnDup         = 0x0002, // При существовании аналогичной позиции сигнализировать об ошибке (не складывать количества).
			fSkipZeroRest      = 0x0004, //
			fUseCurrent        = 0x0008, // Функция AcceptInventoryItem определяет учетные характеристики по текущему состоянию, но не на дату документа инвентаризации
			fAutoLine          = 0x0010,
			fAutoLineAllowZero = 0x0020,
			fAutoLineZero      = 0x0040,
			fRestrictZeroRestWithMtx = 0x0080, // Проекция флага AutoFillInvFilt::fRestrictZeroRestWithMtx
			fExcludeZeroRestPassiv   = 0x0100  // @v11.1.2
		};
		explicit InvBlock(long flags = 0);
	private:
		friend class PPObjBill;
		enum {
			stInited = 0x001
		};
		long   State;
		long   Flags;
		PPInventoryOpEx Ioe;
		BillTbl::Rec BillRec;
	};

	int    InitInventoryBlock(PPID billID, InvBlock & rBlk);
	int    AcceptInventoryItem(const InvBlock & rBlk, InvItem * pItem, int use_ta);
	int    LoadInventoryArray(PPID billID, InventoryArray & rList);
	InventoryCore & GetInvT();
	int    TurnInventory(PPBillPacket * pPack, int use_ta);
	int    EditInventory(PPBillPacket * pPack, long);
	int    AutoFillInventory(const AutoFillInvFilt *);
	int    UniteInventory(PPID destID, PPIDArray * pSrcList, InvMovSgo, int rmvSrc, int use_ta);
	int    GetInventoryStockRest(const InvBlock & rBlk, InvItem * pItem, GoodsRestParam * pRestParam);
	//
	// Descr: Флаги функции RecalcInventoryStockRests
	//
	enum {
		rifRest    = 0x0001, // Пересчитывать остатки
		rifPrice   = 0x0002, // Пересчитывать цены
		rifAverage = 0x0004  // Аварийный пересчет
	};

	int    RecalcInventoryStockRests(PPID billID, /*int recalcPrices*/long flags, int use_ta);
	int    RecalcInventoryDeficit(const BillTbl::Rec * pRec, int use_ta);
	int    ConvertInventory(PPID billID);
	int    RollbackInventoryWrOff(PPID billID);
	int    WriteOffDebtInventory(PPID billID, int use_ta);
	int    ViewInventoryTotal(const PPIDArray & rIdList, const InventoryFilt * pFilt);
	//
	// Draft operations
	//
	int    WriteOffDraft(PPID billID, PPIDArray *, PUGL *, int use_ta); // @NIA
	int    RollbackWrOffDraft(PPID billID, int use_ta);
	int    GetDeficitList(const DateRange *, const PPIDArray * pLocList, RAssocArray *);
	int    GetDraftRcptList(const DateRange *, const PPIDArray * pLocList, DraftRcptArray *);
	int    ProcessDeficit(PPID compOpID, PPID compArID, const PUGL * pPugl, PPLogger * pLogger, int use_ta);
	int    CalcDraftTransitRest(PPID restOpID, PPID orderOpID, PPID goodsID, PPID locID, long flags, double * pRest, LDATE * pDt);
	int    MoveLotTagsFromDraftBillToWrOffBill(PPID billID, PPLogger * pLogger, int use_ta);
	struct QuoteReqLink {
		PPID   LeadBillID;
		int    LeadRbb;
		PPID   SeqBillID;
		int    SeqRbb;
		int    AckStatus;
		double AckCost;
		double AckQtty;
	};
	int    SearchQuoteReqSeq(const DateRange * pPeriod, TSArray <QuoteReqLink> & rList);
	//
	// Packages
	//
	int    GenPckgCode(PPID pckgTypeID, char * pBuf, size_t bufLen);
	int    InitPckg(LPackage *);
	int    AddPckgToBillPacket(PPID pckgID, PPBillPacket *);
	int    SelectPckgByCode(const char * pCode, PPID locID, PPID * pPckgID);
	int    SelectPckg(PckgFilt * pFilt, PPID * pPckgID);
	int    ViewPckgDetail(PPID pckgID);
	bool   IsLotInPckg(PPID lotID);
	int    CheckPckgCodeUnique(const LPackage *, PPBillPacket *);
	int    CorrectPckgCloseTag();
	int    InitMirrorPckg(PPID billID, const LPackage * pSrc, LPackage * pDest);
	//
	// Cutting functions
	//
	int    Cutting(LDATE endDate, int use_ta);
	int    CuttingUntiedCLB(int use_ta);
	int    SaveBalance(LDATE endDate, const char * pFileName);
	int    LoadBalance(LDATE endDate, const char * pFileName, int use_ta);
	//
	// Streaming functions
	//
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	static int   TotalTransmitProblems(ObjTransmContext * pCtx, int * pNextPassNeeded); // Realy private function. Accessed only from PPObject::ReceivePackets()
	int    GetAlternateArticle(PPID arID, PPID sheetID, PPID * pAltArID);
	int    GetPayableOpListByReckonOp(const PPReckonOpEx &, PPID arID, ReckonOpArList *);
	int    GetPaymentOpListByDebtOp(PPID debtOpID, PPID arID, ReckonOpArList * pList);

	struct PplBlock {
		enum {
			fUseOpList     = 0x0001,
			fUsePaymOpList = 0x0002,
			fGatherPaym    = 0x0004,
			fByShipment    = 0x0008  // Доля оплаченных поставщику расходов берется по отгрузкам покупателям, на не по их оплатам
		};
		PplBlock(const DateRange & rPeriod, const PPIDArray * pOpList, const PPIDArray * pPaymOpList);
		int    AddOp(PPID opID);
		int    AddPaymOpList(const PPIDArray & rOpList);
		int    FASTCALL CheckOp(PPID opID) const;
		int    FASTCALL CheckPaymOp(PPID opID) const;
		//
		// Descr: Сбрасывает внутреннее состояние объекта до готовности обработки
		//   очередного лота.
		//   { Amount = 0.0; Payment = 0.0; Part = 1.0; PaymList.clear(); }
		//
		void   Reset();
		void   FASTCALL AddPaym(const BillTbl::Rec & rRec);
		void   FASTCALL FinishLot(PPID orgLotID);

		long   Flags;
		DateRange Period;
		DateRange GatherPaymPeriod;
		PPIDArray OpList;
		PPIDArray PaymOpList;
		RAssocArray OrgPartList; // Список оплаченных частей, ассоциированных с оригинальными лотами.
			// Используется для ускорения расчета.
		//
		RAssocArray PaymList;    // Если Flags & fGatherPaym, то в этот массив заносятся пары
			// {ID, Amount} документов оплаты, попадающих в период GatherPaymPeriod.
		double NominalAmount;    // Номинальная сумма документа прихода в ценах поступления //
		double Amount;           // Сумма документа прихода в ценах поступления без возвратов
		double Payment;          // Сумма оплат от даты лота до конца периода Period
		double PaymentBefore;    // Сумма оплат от даты лота до начала периода Period
		double Part;             // Оплаченная часть лота от даты лота до конца периода Period
		double PartBefore;       // Оплаченная часть лота от даты лота до начала периода Period
	};
	int    GetPayoutPartOfLot(PPID lotID, PplBlock & rBlk, double * pPart);

	struct EprBlock {
		double Amount; // Сумма прихода в ценах поступления //
		double Expend; // Сумма израсходованных товаров в ценах поступления //
		double Payout; // Сумма оплат по расходам в ценах поступления //
	};
	int    GetExpendedPartOfReceipt(PPID lotID, const DateRange * pPeriod, const PPIDArray * pOpList, EprBlock & rBlk);
	int    CreateModifByPUGL(PPID modifOpID, PPID *, PUGL *, PPID sessID = 0, const GoodsReplacementArray * = 0);
	int    CreateMrpTab(const PPIDArray * pList, MrpTabPacket *, PPLogger *, int use_ta);
	PPID   GetSupplAgent(PPID lotID);
	int    NeedTransmit(PPID id, const DBDivPack & rDestDbDivPack, ObjTransmContext * pCtx);
	//
	// Descr: Определяет, влияет ли документ billID на состояние склада locID.
	//   Если locID == 0, то определяет, влияет ли документ на состояние складских запасов
	//   по любому из складов.
	// Returns:
	//   >0 - документ billID влияет на состояние складских запасов склада locID
	//   <0 - документ billID не влияет на состояние склада locID
	//   0  - ошибка
	//
	int    IsInfluenceToStock(PPID billID, PPID locID);
	//
	// Descr: Извлекает список товаров, соджержащихся в товарных документах, возданных или
	//   измененных с момента rDtm.
	// Note: список rGoodsList функция предварительно не чистит, а после добавления в него товаров
	//   сортирует и удаляет дубликаты.
	//
	int    GetGoodsListByUpdatedBills(PPID locID, const LDATETIME & rDtm, PPIDArray & rGoodsList, PPIDArray * pBillList);
	//
	// Descr: Переносит в список rDestList только идентификаторы тех документов из списка rSrcList, 
	//   в которых содержится товар goodsID.
	// Returns:
	//   >0 - по крайней мере один документ из списк rSrcList содержит товар goodsID
	//   <0 - ни один из документов из списка rSrcList не содержит товар goodsID
	//    0 - error
	//
	int    LimitBillListByGoods(const PPIDArray & rSrcList, PPID goodsID, PPIDArray & rDestList);
	int    SerializePacket__(int dir, PPBillPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	const  PPBillConfig & GetConfig() const;
	//
	// Descr: Флаги функции GetShippedPartOfReceipt
	//
	enum {
		gsporPayment        = 0x0001, // Рассчитывать по оплатам для отгрузок, требующим оплаты
		gsporIntrAsShipment = 0x0002, // Внутреннюю передачу считать отгрузкой. В противном случае пребираются и
			// лоты, сформированные внутренними передачами
		gsporUnlimIsShipped = 0x0004  // Нелимитированные ресурсы считать полностью отгруженными. В противном
			// случае нелимитированные ресурсы считаются никогда не отгружаемыми.
	};
	int    GetShippedPartOfReceipt(PPID rcptBillID, const DateRange * pPeriod, const ObjIdListFilt & rOpList, long flags, double * pPart);

	class SubstParam {
	public:
		friend class PPObjBill;
		//
		SubstParam();
		~SubstParam();
		void   FASTCALL Init(SubstGrpBill sgb);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		SubstGrpBill Sgb;
		PPObjPerson::SubstParam Psp;
		LAssocArray AsscList; // Массив ассоциаций, связывающий группирующее значение со списком
			// документов, которые подпадают под эту группировку.
	private:
		LAssocArray * P_DebtDimAgentList;
	};

	int    Subst(const PPBill * pPack, PPID * pDestID, SubstParam * pParam);
	int    GetSubstObjType(long id, const SubstParam * pParam, PPObjID * pObjID) const;
	void   GetSubstText(PPID srcID, SubstParam * pParam, SString & rBuf);
	//
	// Descr: Специализированная функция, реализующая минимально необходимую частичную загрузку
	//   субпакета документа PPBill для подстановки по критериям SubstParam.
	//   Главное назначение функции - снизить издержки на извлечении данных при подготовке
	//   отчетов, обрабатывающих значительное количество записей документов.
	//
	int    LoadForSubst(const SubstParam * pParam, PPBill * pPack);
	//
	// Descr: Реализует предварительные операции для начисления по тарифицируемым транзакциям.
	//
	void   InitGtaBlock();
	int    InitGta(PPGta & rGta);
	//
	// Descr: Специализированная высокоуровневая функция, реализующая начисление или списание
	//   стоимости тарифицируемой транзакции с кредитной карты, ассоциированной с глобальной учетной записью.
	//
	int    CheckInGta(const PPGta & rGta, int use_ta);
	//
	// Descr: Утилитная функция, определяющая изменилась ли цена в строке документа pTi по сравнению с предыдущим
	//   лотом того же товара. Используется при печати документа со специальными опциями.
	//
	bool   IsPriceChanged(const PPTransferItem * pTi, long procFlags);
	//
	// Descr: Конвертация UUID'ов документов из записей Property в ObjTag
	//
	int    ConvertUuid7601();
public:
	void * ExtraPtr;
	PPBillConfig Cfg;
	PPObjOprKind * P_OpObj;
	PPObjAccTurn * atobj;
	PPObjLocation LocObj;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	TLP_MEMB(BillCore, P_Tbl);
	TLP_MEMB(Transfer, trfr);
	TLP_MEMB(CpTransfCore, P_CpTrfr);
	TLP_MEMB(AdvBillItemTbl, P_AdvBI);
	TLP_MEMB(LotExtCodeCore, P_LotXcT);
private:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual const char * GetNamePtr();
	int    PutPckgList(PPBillPacket *, int use_ta);
	int    LoadPckgList(PPBillPacket *);
	int    Helper_EditGoodsBill(PPID *, PPBillPacket *);

	struct WrOffDraftBlock {
		WrOffDraftBlock(const PPDraftOpEx * pWrOffParam, PUGL * pDfctList);

		PPBillPacket SrcDraftPack;
		const PPDraftOpEx * P_WrOffParam;
		PPBillPacketCollection ResultList;
		PUGL * P_DfctList;
	};

	int    Helper_WriteOffTurnResultItem(const WrOffDraftBlock & rBlk, uint pos, PPIDArray * pWrOffBills); // @notransaction
	int    Helper_WriteOffDraft(PPID billID, const PPDraftOpEx *, PPIDArray * pWrOffBills, PUGL * pDfctList, int use_ta);
		// @<<PPObjBill::WriteOffDraft
	int    Helper_WrOffDrft_ExpExp(/*const PPBillPacket & rSrcDraftPack, const PPDraftOpEx * pWrOffParam, PPBillPacket * pPack, PUGL * pDfctList*/WrOffDraftBlock & rBlk, int use_ta);
		// @<<PPObjBill::Helper_WriteOffDraft
	int    Helper_WrOffDrft_ExpModif(WrOffDraftBlock & rBlk, int use_ta);
	int    Helper_WrOffDrft_ExpDrftRcp(/*const PPBillPacket & rSrcDraftPack, const PPDraftOpEx * pWrOffParam, PPBillPacket * pPack*/WrOffDraftBlock & rBlk, int use_ta);
	int    Helper_WrOffDrft_DrftRcptModif(WrOffDraftBlock & rBlk, PPIDArray * pWrOffBills);
	int    Helper_WrOffDrft_Acct(WrOffDraftBlock & rBlk, int use_ta);
	int    Helper_PutBillToMrpTab(PPID billID, MrpTabPacket *, const PPDraftOpEx *, int use_ta);
	// @v11.1.12 int    InitDraftWrOffPacket(const PPDraftOpEx *, const BillTbl::Rec *, PPBillPacket *, int use_ta);
	int    InitDraftWrOffPacket(const PPDraftOpEx *, const PPBillPacket * pDraftPack, PPBillPacket *, int use_ta); // @v11.1.12
	int    RemoveTransferItem(PPID billID, int rByBill, int force = 0);
	int    ProcessLink(BillTbl::Rec & rRec, PPID paymLinkID, const BillTbl::Rec * pOrgRec);
	int    ProcessShadowPacket(PPBillPacket *, int update);
	int    ProcessACPacket(PPBillPacket *);
	//
	// Descr: Находит доступные на дату dt по складу locID лоты, относящиеся к товарам,
	//   которые являются "членами обобщения goodsID". Под членством в обобщении goodsID
	//   подразумеваеся два возможных случая:
	//     1. goodsID является обобщенным товаром. При этом все товары, относящиеся к этому
	//        обобщению, само собой, являются "членами обобщения goodsID"
	//     2. Товар goodsID не является обобщенным, но относится к некоторому обобщению G.
	//        В этом случае, все остальные товары, относящиеся к обобщению G также являются //
	//        "членами обобщения goodsID"
	//   Лоты, относящиеся к товару goodsID не перебираются.
	//   Ко всем членам обобщения перед перебором по ним лотов применяется функция //
	//   PPObjGoods::IsGoodsCompatibleByUnit. Перебор лотов по члену обобщения ведется только
	//   в том случае, если этот вызов возвращает значение >0.
	// ARG(goodsID          IN): Ведующий товар обобщения, по которому ведется перебор лотов
	// ARG(locID            IN): Склад, относительно которого перебираются лоты. Если lotID == 0,
	//   то ни одного лота найдено не будет.
	// ARG(dt               IN): Перебор ведется по лотам, дата которых не превышает dt.
	// ARG(pLotList        OUT): @#{vptr0} Массив, в который функция добавляет найденные лоты.
	//
	// @v4.8.6 int    EnumAltGenGoodsLots(PPID goodsID, PPID locID, LDATE dt, PPIDArray * pLotList);
	int    ReplyGoodsDel(PPID);
	int    ReplyGoodsReplace(PPID destID, PPID srcID);
	int    ReplyInventGoodsReplace(PPID dest, PPID src);
	int    ReplyArticleDel(PPID);
	int    ReplyArticleReplace(PPID destID, PPID srcID);
	int    OrderLots(const PPBillPacket *, PPIDArray *, PPID, double, double, double);
	void   RegisterTransmitProblems(PPBillPacket *, ILBillPacket *, int skipped, ObjTransmContext * pCtx);
	int    Helper_Reckon(PPID billID, const ReckonOpArList & rOpList, CfmReckoningParam & rParam, int negativePayment, int dontConfirm, int use_ta);
	void   Helper_PopupReckonInfo(PPIDArray & rResultBillList);
	int    GetPoolsMembership(PPID id, PPBillPacket *);
		// @<<PPObjBill::ExtractPacket
	int    SetTagNumberByLot(PPID lotID, PPID tagID, const char * pNumber, int use_ta);
	int    Helper_GetPoolMembership(PPID id, const PPBillPacket * pPack, long flag, PPID poolType, PPID * pPoolID);
		// @<<PPObjBill::GetPoolsMembership
	int    Helper_ConvertILTI_Subst(ILTI *, PPBillPacket *, LongArray * pRows, double * pQtty, long flags, const GoodsReplacementArray *, char * pSerial);
		// @<<PPObjBill::ConvertILTI
	int    CheckPoolStatus(PPID billID, int poolType);
	int    Debug_TrfrError(const PPBillPacket * pPack);
	int    GetPayableBillList_(const PPIDArray * pOpList, PPID arID, PPID curID, PayableBillList * pList);
	//
	// Descr:
	//   1. Устанавливает зарезервированную сумму PPAMT_POOLAMOUNT по системному пулу
	//   которому принадлежит документ (учитываются следующие пулы: TSESSBILLPOOL TSDBILLPOOL).
	//   2. Устанавливает суммы документа, рассчитываемые по формулам
	// @attention Если документ является членом пула, то функция может создать (и разрушить)
	//   экземпляр объекта PPObjTSession. В связи с этим не следует вызывать
	//   функцию внутри транзакции (но это не повлечет ошибок в работе).
	// Returns:
	//   >0 - Сумма PPAMT_POOLAMOUNT установлена и (или) найдена и рассчитана по крайней
	//        мере одна формульная сумма.
	//   <0 - Документ не является членом ни одного из указанных пулов либо сам пул не существует
	//        и для вида операции не определено ни одной формульной суммы.
	//   0  - Ошибка
	//
	int    SetupSpecialAmounts(PPBillPacket * pPack);
	int    Helper_GetShipmentByLot(PPID lotID, const DateRange * pPeriod, const ObjIdListFilt & rOpList, long flags, double * pShipment, PPIDArray * pRecurTrace);
		// @>>PPObjBill::GetShippedPartOfReceipt
	int    SerializePacket_Base(int dir, PPBill * pPack, SBuffer & rBuf, SSerializeContext * pSCtx); // @v10.1.12 @dbd_exchange
	int    SerializePacket__(int dir, ILBillPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Helper_GetExpendedPartOfReceipt(PPID lotID, const DateIter & rDi, const DateRange * pPaymPeriod,
		const PPIDArray * pOpList, EprBlock & rBlk, PPIDArray & rRecurList);
	int    Helper_GetPayoutPartOfLot(PPID lotID, PplBlock & rBlk, double * pPart, int recur);
	int    PutSCardOp(PPBillPacket * pPack, int use_ta);
	int    Helper_StoreClbList(PPBillPacket * pPack);
	PPID   FASTCALL GetGtaGoodsID(const PPGta & rGta);
	int    AcceptLotSync(const PPBillPacket & rBp, const ILBillPacket & rIBp, ObjTransmContext * pCtx, int use_ta);
	int    CheckModificationAfterLoading(const PPBillPacket & rPack);
	int    Helper_CreateDeficitTi(PPBillPacket & rPack, const PUGL * pPugl, const PUGI * pItem, const PUGL::SupplSubstItem * pSupplSubstItem, PPID & rComplArID);
		// @<<PPObjBill::ProcessDeficit
	int    Helper_ExtractPacket(PPID id, PPBillPacket * pPack, uint fl, const PPIDArray * pGoodsList);
	int    Helper_GetPriceRestrictions_ByFormula(SString & rFormula, PPBillPacket * pPack, const PPTransferItem & rTi, int itemPos, double & rBound);

	struct GtaBlock {
		//
		// Ключевой компонент ассоциации (Key) является парой: { int16 GtaOp, ObjType; }
		// Значение ассоциации (Val) - GoodsID
		//
		LAssocArray OpGoodsAssoc;

		struct GuaAssocItem { // @flat
			PPID   GuaID;    // #key
			PPID   SCardID;
			PPID   PersonID;
			PPID   ArID;
		};
		TSVector <GuaAssocItem> GuaAssoc;
	};

	int    GetGtaGuaAssoc(const PPGta & rGta, PPObjBill::GtaBlock::GuaAssocItem & rAssoc);

	const  long CcFlags;     // Копия CConfig.Flags ради небольшого увеличения эффективности кода по размеру и скорости работы
	//
	// Descr: Флаги состояния объекта
	//
	enum {
		stDemoRestrictInit = 0x0001, // Флаг stDemoRestrict инициализирован
		stDemoRestrict     = 0x0002, // Если stDemoRestrictInit и stDemoRestrict, то сеанс имеет ограничения демо-версии
		stDoObjVer = 0x0004  // Необходимо сохранять версии измененных и удаленных документов
	};
	long   State2; // PPObjBill::stXXX
	struct LockSet { // @flat
		LockSet(PPID id, PPID linkID);
		PPID   ID;
		PPID   LinkID;
	};
	TSVector <LockSet> locks;
	GtaBlock GtaB;
	SString NameBuf;         // Is returned by GetNamePtr
	PackageCore * P_PckgT;
	CurRateCore * P_Cr;
	InventoryCore * P_InvT;
	GoodsSaldoCore * P_GsT;
	PPObjSCard * P_ScObj;
};

class PPObjAccTurn : public PPObject {
public:
	explicit PPObjAccTurn(void * extraPtr = 0);
	~PPObjAccTurn();
	int    CreateBlankAccTurn(PPID opID, PPBillPacket *, long * pFlags, int use_ta);
	int    CreateBlankAccTurnBySample(PPBillPacket * pPack, const PPBillPacket * pSamplePack, long * pFlags);
	int    CorrectBalance();
	int    EditTurn(LDATE, PPID billID, PPID oprKind, int showOnly);
	//
	// В функции ConvertStr параметры pAcctId и pAccSheetID могут быть нулевыми
	//
	int    ConvertStr(const char *, PPID curID, Acct *, AcctID * pAcctId, PPID * pAccSheetID);
	//
	// В функции ConvertAcct параметр pAccSheetID может быть нулевым
	//
	int    ConvertAcct(const Acct *, PPID curID, AcctID *, PPID * pAccSheetID);
	int    ConvertAcctID(const AcctID & rAci, Acct *, PPID * pCurID, int useCache);
	int    CorrectRelsArRefs();
	int    VerifyRevokingCurFromAccount(PPID accID, PPID curID);
	int    VerifyChangingAccsheetOfAccount(PPID accID);
	//
	// Ищет среди проводок по документу pPack первую, которая имеет на стороне,
	// определяемой параметром side (PPDEBIT || PPCREDIT) счет первого порядка ac.
	// По указателю pCorrAcc возвращает счет, корреспондирующий со счетом ac
	// в найденной проводке. По указателю pPos возвращается индекс найденной проводки
	// в массиве записей PPBillPacket::Turns.
	// Returns:
	//    > 0 - заданная проводка найдена
	//      0 - заданная проводка не найдена (значения по указателям pCorrAcc и pPos
	//          не определены).
	//
	int    SearchAccturnInPacketByCorrAcc(const PPBillPacket * pPack, int side, int ac, Acct * pCorrAcc, uint * pPos);
protected:
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	int    ReplyAccDel(PPID);
	int    ReplyArticleDel(PPID);
	int    EditRecoverBalanceParam(RecoverBalanceParam *);
public:
	TLP_MEMB(AccTurnCore, P_Tbl);
private:
	void * ExtraPtr;
};
//
// Descr: Кэш символов сумм документов и формул. Используется при
//   разборе и вычислении формул (PPExprParser, DL200).
//
class BillSymbCache : public ObjCache {
public:
	struct Data : public ObjCacheEntry {
		int    F; // 0 - Dirty, 0x0001 - Amount, 0x0002 - Formula, 0x0004 - errOnDefault, 0x0008 - AdvLineAmount
	};
	BillSymbCache();
	//
	// Returns:
	//   1 - pSymb - сумма
	//   2 - pSymb - формула
	//   3 - pSymb - символ AdvLnAmt
	//   0 - символ не распознан
	//
	int    Fetch(const char * pSymb, PPID * pID, SString & rBuf); // @sync_rw
	int    DirtySymb(const char * pSymb); // @sync_rw
private:
	virtual int  FetchEntry(PPID id, ObjCacheEntry * pEntry, void * extraData);
	virtual void EntryToData(const ObjCacheEntry * pEntry, void * pDataRec) const;
	int    Search(const char * pSymb, PPID * pID, SString & rBuf) const;
	int    Add(int F, PPID id, const char * symb, const char * buf);

	long   sDELIM;
	StringSet SymbSet;
	StringSet FormSet;
};
//
// @ModuleDecl(LocTransfCore)
//

//
// Descr: Идентификаторы типов складских операций
//   Наименования операций хранятся в строке PPTXT_LOCTRANSF_OPTEXT в формате: "1,text;2,text;3,text"
//
#define LOCTRFROP_PUT                  1 // Положить товар в ячейку
#define LOCTRFROP_GET                  2 // Извлечь товар из ячейки
#define LOCTRFROP_INVENT               3 // Инвентаризация ячейки
//
// Descr: Флаги ограничений размещения в складских ячейках
//
#define LOCDISPRESTR_SINGLEWARE   0x0001 // Ограничение единственным наименованием товара
#define LOCDISPRESTR_VOLUME       0x0002 // Оганичение по суммарному объему
#define LOCDISPRESTR_BRUTTO       0x0004 // Ограничение по суммарной массе брутто
#define LOCDISPRESTR_PALLETCOUNT  0x0008 // Ограничение по количеств паллет
#define LOCDISPRESTR_PALLETONLY   0x0010 // Загрузка только паллетами
#define LOCDISPRESTR_PALLETSIZE   0x0020 // Ограничение по размеру паллет

struct LocTransfOpBlock {
	LocTransfOpBlock(int op, PPID locID);
	LocTransfOpBlock & FASTCALL operator = (const LocTransfTbl::Rec * pRec);
	LocTransfOpBlock & Init(int op, PPID locID);
	bool   FASTCALL IsEq(const LocTransfTbl::Rec & rRec) const;

	int    Op;             // LOCTRFROP_XXX
	PPID   BillID;         //
	int    RByBill;        // Номер операции по документу. Для новой записи 0.
	PPID   GoodsID;        //
	PPID   LotID;          //
	PPID   LocID;          // Ячейка размещения //
	long   RByLoc;         // Номер операции по ячейке. Для новой записи 0.
	PPID   PalletTypeID;   //
	uint   PalletCount;    //
	double Qtty;           //
};

class LocTransfCore : public LocTransfTbl {
public:
	LocTransfCore();
	~LocTransfCore();
	int    Search(PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    SearchRestByGoods(PPID goodsID, PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    SearchRestByLot(PPID lotID, PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    EnumByBill(PPID billID, int16 * pRByBill, LocTransfTbl::Rec * pRec);
	int    GetTransByBill(PPID billID, int16 rByBill, TSVector <LocTransfTbl::Rec> * pList);
	int    PutOp(const LocTransfOpBlock & rBlk, int * pRByLoc, int use_ta);
	int    RemoveOp(PPID locID, long rByLoc, int use_ta);
	int    ValidateOpBlock(const LocTransfOpBlock & rBlk);
	int    GetLocCellList(PPID goodsID, PPID parentLocID, RAssocArray * pList);
	int    GetGoodsList(PPID locCellID, RAssocArray * pList);
	int    GetCellListForGoods(PPID goodsID, const PPIDArray * pDomain, RAssocArray * pList);
	//
	// Descr: Находит список ячеек, в которых ничего нет. Если pDomain != 0,
	//   то в расчет принимаются только те ячейки, которые перечислены в этом списке.
	//
	int    GetEmptyCellList(const PPIDArray * pDomain, PPIDArray * pList);
	//
	// Descr: Определяет список ячеек, в которых есть хоть что-то.
	//   Если pDomain != 0, то в расчет принимаются только ячейки из этого списка.
	//
	int    GetNonEmptyCellList(const PPIDArray * pDomain, PPIDArray * pList);
	//
	// Descr: Определяет размещение по ячейкам строки rByBill товарного документа billID.
	//   Результат возвращается в массиве rDispositionList.
	//
	int    GetDisposition(PPID billID, int rByBill, TSVector <LocTransfTbl::Rec> & rDispositionList);
	//
	// Descr: Определяет размещение по ячейкам строк товарного документа billID.
	//   Резудьтат возвращается в массиве rDispositionList.
	//
	int    GetDisposition(PPID billID, TSVector <LocTransfTbl::Rec> & rDispositionList);
private:
	int    PrepareRec(PPID locID, PPID billID, LocTransfTbl::Rec * pRec);
	int    GetLastOpByLoc(PPID locID, long * pRByLoc, LocTransfTbl::Rec * pRec);
	int    GetLastOpByBill(PPID billID, int16 * pRByBill, LocTransfTbl::Rec * pRec);
	int    GetLastOpByLot(PPID locID, PPID lotID, LocTransfTbl::Rec * pRec);
	int    GetLastOpByGoods(PPID locID, PPID goodsID, LocTransfTbl::Rec * pRec);
	int    UpdateForward(PPID locID, long rByLoc, PPID goodsID, PPID lotID, int check, double * pAddendum);
	int    UpdateCurrent(PPID locID, PPID goodsID, PPID lotID, double addendum);

	PPObjLocation LocObj;
};
//
//
//
struct LocTransfDisposeItem {
	//
	// Descr: Теговые флаги результата размещения.
	//
	enum {
		ctUndef      = 0,
		ctEmpty      = 0x0001, // Ячейка пустая //
		ctInAssoc    = 0x0002, // Ячейка ассоциирована с заданным товаром (предпочтительна)
		ctOutOfAssoc = 0x0004, // Ячейка не ассоциирована с заданным товаром при том, что ассоциации заданы.
			// Если ассоциаций товар-ячейка не существует вообще, этот флаг не устанавливается.
		ctUpper      = 0x0008  // Ячейка находится на верхнем ярусе
	};
	LocTransfDisposeItem();

	int    Op;             // INOUT
	PPID   GoodsID;        // IN
	PPID   WhLocID;        // IN Склад, в пределах которого следует размещать товар.
	PPID   BillID;         // IN
	int    BillTiIdx;      // IN
	PPID   LotID;          // IN
	long   Tag;            // OUT Флаги результата размещения //
	PPID   LocID;          // OUT
	PPID   Loc2ID;         // OUT
	PPID   PalletTypeID;   // OUT
	int    PalletCount;    // OUT
	double Qtty;           // INOUT
};

typedef TSVector <LocTransfDisposeItem> LocTransfDisposeArray;

class LocTransfDisposer {
public:
	LocTransfDisposer();
	~LocTransfDisposer();
	int    Dispose(const LocTransfDisposeItem & rItem, LocTransfDisposeArray & rOutList, int use_ta);
	int    Dispose(const LocTransfDisposeArray & rInList, LocTransfDisposeArray & rOutList, int use_ta);
	//
	// Descr: Размещает документы из списка rBillList по складским ячейкам.
	// ARG(rBillList IN): Список идентификаторов документов, которые необходимо разместить по ячейкам
	// ARG(pLogger   INOUT): @#{vptr0} Если не ноль, то в этот логгер будет записан отчет о размещении.
	// ARG(use_ta    IN): Если !0, то размещение осуществляется в рамках собственной транзакции.
	//
	int    Dispose(const PPIDArray & rBillList, PPLogger * pLogger, int use_ta);
	int    ArrangeCellList(const LocTransfDisposeItem & rItem, PPIDArray & rLocList);
	int    GetDistance(PPID loc1ID, PPID loc2ID, double * pDistance);
	int    CheckLocRestictions(const LocTransfDisposeItem & rItem);
private:
	int    SetupOpBlock(LocTransfDisposeItem & rItem, PPID whCellID, double * pQtty, LocTransfOpBlock & rBlk);
	int    ArrangeColumnList(PPIDArray & rColumnList);

	enum {
		stGtoaLoaded = 0x0001
	};
	LocTransfCore LtT;
	PPObjLocation LocObj;
	PPObjGoods GObj;
	GoodsToObjAssoc GtoAssc;
	long   State;
};
//
// @ModuleDecl(PPViewLocTransf)
//
struct LocTransfFilt : public PPBaseFilt {
	LocTransfFilt();

	enum {
		fZeroLot    = 0x0002,
		fZeroBill   = 0x0004
	};
	//
	// Descr: Режимы отображения данных
	//
	enum {
		modeGeneral = 0, // Общий (операции)
		modeCurrent,     // Текущее состояние остатков ячеек.
		modeEmpty,       // Пустые ячейки
		modeDisposition  // Размещение документов по ячейкам.
			// В этом режиме отображаются все строки документа, даже те, которые не рзмещены.
	};
	enum {
		moAnyMove = 0,
		moCurRest,
		moPut,
		moGet
	};
	enum {
		grpNone = 0,
		grpByColumn,
		grpByZone,
		grpByWarehouse
	};
	char   ReserveStart[32];   // @anchor
	PPID   GoodsGrpID;
	PPID   GoodsID;
	PPID   LotID;
	long   Mode;               // modeXXX
	long   MoveOp;             // moXXX
	long   Grp;
	SubstGrpGoods Sgg;         //
	long   Flags;
	ObjIdListFilt LocList;     // @anchor
	ObjIdListFilt BillList;    // Список размещаемых документов
};

struct LocTransfViewItem : public LocTransfTbl::Rec {
	PPID   TempID__;
	double BillQtty;
};

class PPViewLocTransf : public PPView {
public:
	struct Hdr {
		PPID   ID__;
		PPID   LocID;
		long   RByLoc;
	};
	PPViewLocTransf();
	~PPViewLocTransf();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(LocTransfViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    AddItem(PPID curLocID, long curRByLoc);
	int    EditItem(PPID tempRecID, PPID curLocID, long curRByLoc);
	int    DeleteItem(PPID tempRecID, PPID curLocID, long curRByLoc);
	int    Helper_BuildDispTable(int clearBefore, int use_ta);
	int    ProcessDispBill(PPID billID, BExtInsert * pBei, int use_ta);
	int    UpdateTempRec(PPID tempRecID, PPID locID, int rByLoc, int use_ta);
	int    Dispose();
	void   MakeTempRec(const LocTransfTbl::Rec & rRec, TempLocTransfTbl::Rec & rTempRec);

	static int DynCheckCellParent;

	LocTransfFilt Filt;
	LocTransfCore Tbl;
	ObjIdListFilt Domain; // Список LocTransfFilt::LocList разворачивается по
		// складским ячейкам в данный список
	PPObjLocation LocObj;
	TempLocTransfTbl * P_TempTbl;
	PPIDArray DispBillList; // Список размещаемых документов.
	PPIDArray CellList;     // Список ячеек, принадлежащих фильтрующим локациям
};
//
// Флаги GCTFilt::Flags
//
#define OPG_BYZERODLVRADDR    0x00000010L // Перебирать только документы с пустым адресом доставки
#define OPG_IGNOREZERO        0x00000020L // Игнорировать нулевые записи
#define OPG_MERGECORRECTION   0x00000040L // Модифицировать данные документов документами коррекции (если встречаются)
#define OPG_CALCINREST        0x00000080L // Считать входящий остаток (используется со структурой GoodsGrpngEntry)
#define OPG_CALCOUTREST       0x00000100L // Считать исходящий остаток (используется со структурой GoodsGrpngEntry)
#define OPG_FORCEGOODS        0x00000200L // Передается процедуре GCTFilterDialog, заставляя проверять обязательный ввод товара
#define OPG_ADJPAYM           0x00000400L // For internal use
#define OPG_STOREDAILYRESTS   0x00000800L // При переборе строк Transfer GCTIterator сохраняет информацию о ежедневных остатках товаров с детализацией по складам.
#define OPG_SETPRICEWOTAXES   0x00001000L // Устанавливать цены реализации без налогов
#define OPG_LABELONLY         0x00002000L //
#define OPG_NOZEROEXCISE      0x00004000L // Перебирать только подакцизные товары
#define OPG_COMPAREWROFF      0x00008000L // Если перебор ведется по драфт-документам, то сравнивать с документами списания //
#define OPG_GRPBYGENGOODS     0x00010000L // Группировать по обобщенным товарам (анализ товарных операций)
//
// Descr: Флаг OPG_SETTAXES предписывает процедуре ProcessGoodsGrpng заносить в массив GoodsGrpngArray записи
//   с установленными значениями ставок НДС и (или) акциза соответственно. При этом в массиве для одной операции может
//   присутствовать более одной записи (одна запись на каждую комбинацию { вид операции; ставка НДС; ставка акциза; }).
//
#define OPG_SETTAXES          0x00020000L
#define OPG_DIFFBYTAX         0x00040000L // Разбивать группировку по налогам
#define OPG_SETCOSTWOTAXES    0x00080000L // Устанавливать цены поступления без налогов
#define OPG_DONTSHOWPRGRSBAR  0x00100000L // Не показывать индикатор завершенности процесса во время расчета
#define OPG_PROCESSRECKONING  0x00200000L // Обрабатывать зачитывающие оплаты
//
// Descr: Обрабатывать элементы обобщенной операции в завершении вызова функции
//   GoodsGrpngArray::EndGoodsGroupingProcess. Эта обработка включает удаление строк, соответствующих
//   операциям не входящим в список обобщение, а так же инверсию знаков элементов для тех членов обобщенной
//   операции, которые имеют признак "Отрицательная операция"
//
#define OPG_PROCESSGENOP      0x00400000L //
#define OPG_PROCESSBYLOTS     0x00800000L // (используются со структурой GoodsGrpngEntry)
#define OPG_CALCBILLROWS      0x01000000L // Обрабатывать статистику по строкам каждого документа
#define OPG_BYZEROAGENT       0x02000000L // Ограничивать документами, в которых не указан агент. Ограничение по этому флагу имеет приоритет перед полем GCTFilt::AgentID
#define OPG_FORCEBILLCACHE    0x04000000L // Использовать классом GCTIterator кэш документов
#define OPG_OPTIMIZEFORPSALES 0x08000000L // Оптимизировать выборку для построения таблицы продаж
#define OPG_COSTBYPAYM        0x10000000L // Себестоимость элементов рассчитывать пропорционально оплаченной части документа оригинального лота (см. GGEF_COSTBYPAYM)
#define OPG_INCLACCOPS        0x20000000L // Включать в отчет бухгалтерские документы
#define OPG_SKIPNOUPDLOTREST  0x40000000L // Пропускать операции, не изменяющие товарные остатки (OPKF_NOUPDLOTREST)
#define OPG_OPENEDDRAFTONLY   0x80000000L // Если по драфт-документам, то только по открытым (не списанным)
//
// Descr: Фильтр для построения перекрестной отчетности
//
enum GCTSoftRestrict {
	srNone    = 0,
	srArticle = 1,
	srAgent   = 2,
	srGoods   = 3
};

class GCTFilt : public PPBaseFilt {
public:
	GCTFilt();
	GCTFilt(const GCTFilt & rS);
	int    FASTCALL CheckWL(long billFlags) const;
	int    FASTCALL AcceptIntr3(const BillTbl::Rec & rRec) const;

	enum Order {
		ordByDate = 1,
		ordByGoods,
		ordByArticle
	};
	uint8  ReserveStart[24];      // @anchor
	DateRange DueDatePeriod;      // Период даты исполнения документа
	DateRange Period;             // Период обзора операций
	DateRange LotsPeriod;         // Период приходов
	DateRange ShipmentPeriod;     // Период отгрузки
	PPID   OpID;                  //
	PPID   SupplID;               //
	// @v11.0.1 PPID   ArID_;                 //
	PPID   DlvrAddrID;            // Адрес доставки. Если ArID == 0, то не используется //
	// @v11.0.1 PPID   AgentID_;              // Агент по документам
	PPID   GoodsGrpID;            //
	PPID   GoodsID;               //
	PPID   ExtGoodsTypeID;        // Used only if (!GoodsGrpID && !GoodsID && !SupplID)
	PPID   BrandID;               // Торговая марка
	PPID   SupplAgentID;          // ->Article.ID
	GCTSoftRestrict SoftRestrict; //
	long   Flags;                 // OPG_XXX
	long   Order;                 // GCTFilt::ordByXXX
	int16  GrpPeriod;             // PRD_XXX
	int16  Reserve2;              // @alignment
	ObjIdListFilt BillList;       // @anchor
	ObjIdListFilt LocList;        //
	ObjIdListFilt GoodsList;      // Список товаров (если GoodsList.getCount(), то поля GoodsID и GoodsGrpID не используются //
	ObjIdListFilt ArList;         //
	ObjIdListFilt AgentList;      //
private:
	void   Helper_Init();
};

#define GGEF_VATFREE           0x0001L
#define GGEF_TOGGLESTAX        0x0002L
#define GGEF_CALCBYPRICE       0x0004L // for internal use
#define GGEF_COSTWOVAT         0x0008L // for internal use
#define GGEF_DIFFBYTAX         0x0010L //
#define GGEF_SETCOSTWOTAXES    0x0020L // for internal use
#define GGEF_PRICEWOTAXES      0x0040L // for internal use
#define GGEF_COSTWSTAX         0x0080L //
#define GGEF_RECKONING         0x0100L // Зачитывающая оплата.
	// GoodsGrpngEntry::Link указывает на вид операции зачетного (не оплачиваемого) документа.
#define GGEF_LOCVATFREE        0x0200L // Склад освобожден от НДС
#define GGEF_INTERNAL          (GGEF_CALCBYPRICE|GGEF_COSTWOVAT|GGEF_SETCOSTWOTAXES)
#define GGEF_BYLOT             0x0400L // Обработка по лотам
#define GGEF_COSTBYPAYM        0x0800L // Себестоимость элемента умножать на оплаченную долю документа
	// оригинального лота. Оплата учитывается за период, открытый слева и ограниченный справа верхней датой расчетного периода.
#define GGEF_PAYMBYPAYOUTLOT   0x1000L // Оплата по полностью оплаченному лоту
	// Этот флаг устанавливается для элемента GoodsGrpngEntry если фильтр имеет флаг
	// OPG_COSTBYPAYM и элемент сформирован по оплате приходного документа при условии,
	// что весь товар этого документа израсходован и оплачен покупателями.
#define GGEF_INTRREVERSE       0x2000L // Зеркальная по отношению к внутренней передаче запись (межскладской приход)
#define GGEF_SUPPRDISCOUNT     0x4000L // @internal
#define GGEF_SETPRICEWOTAXES_  0x8000L // @internal

struct GoodsGrpngEntry { // @flat
	//
	// Descr: Базовая имплементация идентификации знака операции (расход или приход).
	//   Используется в GoodsGrpngEntry::GetSign(int *) и в PPViewOpGrouping::GetRecSign(const TempOpGrpngTbl::Rec *, int *).
	//
	static int GetSign(PPID opID, int16 sign, int * pSign);
	
	GoodsGrpngEntry();
	PPID   FASTCALL IsProfitable(int incomeCalcMethod = -1) const;
	double FASTCALL Income(int incomeCalcMethod = -1) const;
	void   FASTCALL SetOp(const PPOprKind & rOpRec);
	int    FASTCALL GetSign(int * pSign) const;
	bool   IsInRest() const { return OpID == -1; }
	bool   IsOutRest() const { return OpID == 10000; }
	int    Compose(const GoodsGrpngEntry & rAddendum);

	PPID   OpID;           // -1 input rest, 10000 - output rest
	PPID   LotID;          //
	PPID   LotTaxGrpID;    //
	PPID   GoodsTaxGrpID;  //
	PPID   OpTypeID;       //
	PPID   Link;           //
	long   Count;          //
	long   LnCount;        // Суммарное количество товарных строк в документах
	long   AvgLn;          // Среднее количество товарных строк в документах
	char   OpName[48];     // Наименование вида операции
	int16  Sign;           // Знак операции
	int16  Reserve;        // @alignment
	double Quantity;       //
	double Volume;         //
	double TaxFactor;      //
	double Cost;           //
	double Price;          //
	double Discount;       //
	double Amount;         //
	double ExtCost;        //
	double ExtPrice;       //
	double ExtDis;         //
	double CostPaymPart;   // Оплаченная часть документа оригинального лота операции
		// Рассчитывается только если GGEF_COSTBYPAYM. В противном случае 1.0.
	long   Flags;          //
	LDATE  LotDate;        // Дата поступления товара. Необходима для расчета налогов в ценах поступления.
private:
	double FASTCALL IncomeByOpr(PPID) const;
};
//
//
//
class AdjGdsGrpng {
public:
	AdjGdsGrpng();
	int    BeginGoodsGroupingProcess(const GCTFilt & rFilt);
	int    EndGoodsGroupingProcess();

	DateRange Period;
	PPIDArray BillList;
	LAssocArray CorrectionBillList; // Список документов коррекции, ассоциированных со связанными документами
	PPIDArray SupplAgentBillList;
private:
	int    PrevPaymentList(const GCTFilt &);
	int    CorrectionList(const GCTFilt &);
	int    MakeBillIDList(const GCTFilt * pF, const PPIDArray * pOpList, int byReckon);
};

class GoodsGrpngArray : public SVector {
public:
	explicit GoodsGrpngArray(PPLogger * pLogger = 0);
	~GoodsGrpngArray();
	void   Reset();
	GoodsGrpngEntry & FASTCALL at(uint);
	const  GoodsGrpngEntry & FASTCALL Get(uint idx) const;
	int    Search(const GoodsGrpngEntry *, uint *);
	int    Insert(const GoodsGrpngEntry *, uint * p);
	//
	// Descr: просматривает все товарные операции по таблице Transfer в соответствии с фильтром,
	//   заданным первым параметром. Результатом является массив, группирующий операции по виду.
	//
	int    ProcessGoodsGrouping(const GCTFilt &, const AdjGdsGrpng * pAgg);
	void   InitOpNames();
	int    WasErrDetected() const;
	//
	// Descr: Возвращает элемент, соответствующий входящему остатку. Если массив рассчитан без остатков, то гарантированно вернет 0
	//
	const GoodsGrpngEntry * GetInRest() const;
	//
	// Descr: Возвращает элемент, соответствующий исходящему остатку. Если массив рассчитан без остатков, то гарантированно вернет 0
	//
	const GoodsGrpngEntry * GetOutRest() const;
	//
	// Descr: Рассчитывает агрегатный элемент, содержащий итоги по приходам товаров.
	//
	int    GetInput(GoodsGrpngEntry & rEntry) const;
	//
	// Descr: Рассчитывает агрегатный элемент, содержащий итоги по расходам товаров.
	//
	int    GetOutput(GoodsGrpngEntry & rEntry) const;
protected:
	struct AddEntryBlock {
		AddEntryBlock();
		TransferTbl::Rec TrfrRec;
		ReceiptTbl::Rec LotRec;
		PPOprKind OpRec;
		double Part;
		long   Flags;
	};
	int    FASTCALL AddEntry(GoodsGrpngEntry *);
	int    ProcessTrfrRec(const GCTFilt & rF, const AdjGdsGrpng * pAgg, TransferTbl::Rec & rTrfrRec, PPID taxGrpID, double phUPerU, double taxFactor);
	int    CalcRest(GoodsRestParam & rP, const PPOprKind & rOp, double);
	int    _ProcessBillGrpng(GCTFilt *);
	int    FASTCALL IsLockPaymStatus(PPID statusID) const;
private:
	PPObjBill * P_BObj;
	PPObjGoods GObj;
	PPID   ExtCostAmtID;
	PPID   ExtPriceAmtID;
	PPID   ExtDisAmtID;
	int    ErrDetected;
	ObjIdListFilt LockPaymStatusList; // Список идентификаторов статусов документа,
		// которые имеют признак "не учитывать как оплату" (BILSTF_LOCK_PAYMENT)
	PPObjBill::PplBlock * P_PplBlk;
	PPLogger * P_Logger; // @notowned
};
//
// Descr: Фронтальный класс, обеспечивающий интерфейс к механизму обработки серверных запросов
//   с унифицированным синтаксисом.
//
class SelectObjectBlock {
public:
	SelectObjectBlock();
	~SelectObjectBlock();
	//
	// Descr: Разбирает текстовую команду pStr.
	// ARG(pStr     IN): Командная строка
	// Returns:
	//  >0 - команда разобрана успешно.
	//  0  - ошибка
	//
	int    FASTCALL Parse(const char * pStr);
	//
	// Descr: Выполняет предварительно разобранную функцией Parse команду.
	//
	int    FASTCALL Execute(PPJobSrvReply & rReply);
	//
	// Descr: Представление кассового чека, используемое серверными командами
	//
	class DistribCCheck {
	public:
		struct Header {
			Header();

			PPID   PosNodeID;
			PPID   LocID;
			LDATETIME Dtm;
			PPID   SCardID;
			long   Flags;
			double Amount;
			double Discount;
		};
		struct Line {
			Line();

			PPID   GoodsID;
			double Qtty;
			double Price;
			double Discount;
		};
		DistribCCheck();
		~DistribCCheck();
		int    Begin(PPID * pID, const Header & rHdr);
		int    AddLine(PPID ccID, const Line & rLn);
		int    Finish(PPID ccID, PPID * pNewCcID);
	private:
		PPObjCSession * P_CsObj;
		PPObjCashNode CnObj;
		PPObjLocation LocObj;
	};
private:
	Backend_SelectObjectBlock * P_BSob;
};
//
// Книги продаж/покупок
//

//
// Типы записей книги продаж/покупок
//
#define PPVTB_SELL               1L // Продажа
#define PPVTB_BUY                2L // Покупка
#define PPVTB_INVOICELISTSELL    3L // Реестр исходящих счетов-фактур
#define PPVTB_INVOICELISTBUY     4L // Реестр входящих счетов-фактур
#define PPVTB_SIMPLELEDGER       5L // Книга доходов/расходов для упрощенной схемы налогообложения //

class VATBCfg {
public:
	//
	// Флаги элементов списка
	//
	enum {
		fExclude             = 0x0001, // Исключить операцию при формировании книги
		fNegative            = 0x0002, // Операция заносится в книгу с инвертированным знаком
		fByExtObj            = 0x0004, // Контрагентом в записи книги является дополнительный объект
		fVATFromReckon       = 0x0008, // Налоги из зачетного документа
		fVATFree             = 0x0010, // Операция освобождена от налогов
		fAsPayment           = 0x0020, // Только для типов операции PPOPT_PAYMENT.
			// Запись по операции формируется так: в книгу заносится запись датой документа
			// с суммой равной номинальной сумме этого документа и суммами НДС, рассчитываемыми
			// по связанному документу. Для связанного документа его датой формируется сторнирующая запись.
		fExpendByFact        = 0x0040, // Учитывать расходы по операции по факту. То есть,
			// если документ является приходом товаров, то перечисляются все лоты, сформированные
			// документом и суммируются все отгрузки (возможно по оплатам) по этим лотам за
			// заданный период.
		fFactByShipment      = 0x0080, // Переопределяет учет по данной операции таким образом,
			// что документы этой операции будут учитываться по отгрузке (если общее правило книги - по оплате).
			// Если общее правило книги "по отгрузке", то данный флаг игнорируется.
		// fExcludeNegative = 0x0100  // @v10.9.11 Исключать запись с отрицательной суммой
		fReckonDateByPayment = 0x0100 // @v11.9.10 Дату записей зачитывающих оплат формировать по дате зачетного документа, а не по дате зачета
			// То есть:
			// 2024-02-01 - платеж
			// 2024-02-05 - отгрузка и зачитывающая оплата
			// Если флаг не установлен, то ...
	};
	//
	// Флаги конфигурации
	//
	enum {
		hfIterateClb      = 0x0001, // Translated to VatBookFilt::fIterateClb
		hfDontStornReckon = 0x0002, // Не сторнировать зачитывающие оплаты
		hfWoTax           = 0x0004, // Книга доходов/расходов без НДС
		hfD_InvcDate      = 0x0008, // В качестве даты записи использовать дату счета-фактуры
		hfD_MaxInvcBill   = 0x0010  // В качестве даты записи использовать более позднюю из дат
		//hfExpendByFactShipm
	};

	VATBCfg();
	VATBCfg & FASTCALL operator = (const VATBCfg &);
	int    AddOp(PPID);
	int    SetAccSheet(PPID);
	int    CheckOp(PPID opID, PPID * pAccSheetID = 0);
	bool   CheckFlag(PPID opID, long f) const;
	int    CheckAccSheet(PPID accSheetID);
	int    CheckList(PPID * pAccSheetID = 0);
	int    Setup();

	struct Item { // @persistent @flat
		PPID   OpID;
		long   Flags;
		PPID   MainAmtTypeID;
		int8   SignFilt; // +1 - только положительные суммы, -1 - только отрицательные суммы, 0 - все равно
		uint8  Reserve[11];
	};

	PPID   Kind;       // PPVTB_XXX
	PPID   AccSheetID; // ->Reference(PPOBJ_ACCSHEET) Таблица аналитических статей
	long   Flags;      // VATBCfg::hfXXX Флаги
	int16  AcctgBasis; // Форма учета доходности (INCM_XXX (PP.H))
	int16  AcctgBasisAtPeriod; // Форма учета доходности на определенный период
	DateRange Period;
	TSVector <Item> List;
};
//
// Флаги записи книги продаж/покупок
//
#define VATBF_FIX      0x0001L // Запись нельзя модифицировать
#define VATBF_EXCLUDED 0x0002L // Исключенная из реестра запись. Такая запись предотвращает попадание связанного документа в книгу
#define VATBF_VATFREE  0x0004L // Запись книги покупок, освобожденная от НДС
#define VATBF_PARTPAYM 0x0008L // Признак частичной оплаты

class PPObjVATBook : public PPObject {
public:
	static int EditConfig(PPID kind, VATBCfg * cfg);
	static double FASTCALL GetVatRate(uint idx/*[0..4]*/);
	static bool   FASTCALL IsVatRate(uint idx/*[0..4]*/, double rate);
	//
	// Descr: Извлекает базовое значение типа строки записи из (возможно) комбинированной
	//   величины, хранящейся в записи VATBookTbl::Rec.
	//
	static int FASTCALL IsValidKind(int kind);

	explicit PPObjVATBook(void * extraPtr = 0);
	~PPObjVATBook();
	virtual int  DeleteObj(PPID);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Search(PPID id, void * b = 0);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    EditObj(PPID * pID, void * pData, int use_ta);
	int    ValidateData(void * data, long);
	int    ReadConfig();
private:
	//
	// Конфигурация книг продаж/покупок
	// sizeof(PPVATBConfig) == PROPRECFIXSIZE
	//
	struct PPVATBConfig {
		PPID  Tag;            // Const=PPOBJ_CONFIG
		PPID  ID;             // Const=PPCFG_MAIN
		PPID  Prop;           // PPPRP_VATBSCFG || PPPRP_VATBBCFG || PPPRP_SMPLLEDGCFG
		char  Reserve1[44];
		SVerT Ver;            // Версия формата (совпадает с версией системы, начиная с которой действует формат).
		LDATE BegDt;          //
		LDATE EndDt;          //
		long  Flags;          //
		PPID  AccSheetID;
		int16 AcctgBasis;
		int16 AcctgBasisAtPeriod;
		long  ListCount;
		// ... Далее следует список элементов VATBL
	};

	static int ReadCfgList(PPID what, VATBCfg *);
	static int WriteCfgList(PPID what, const VATBCfg *, int use_ta);

	virtual const char * GetNamePtr();
	virtual int    HandleMsg(int, PPID, PPID, void * extraPtr);
	PPID   SelectLineType(uint * rezID, PPID what);
	VATBCfg VATBCSell;
	VATBCfg VATBCBuy;
	VATBCfg VATBSmplLedg;
public:
	TLP_MEMB(VATBookTbl, P_Tbl);
	void * ExtraPtr;

	const  VATBCfg & FASTCALL GetConfig(PPID kind) const;
};
//
// @ModuleDecl(PPObjCSession)
// Кассовые сессии
//
// Специфические флаги доступа к кассовым сессиям
//
//abcdefghijklmnopqrstuvwxyz
//ABCDEFGHIJKLMNOP RST   XYZ12

#define CSESSRT_OPEN               0x00000100 // O Открытие сессии
#define CSESSRT_CLOSE              0x00000200 // Z Закрытие сессии
#define CSESSRT_ADDCHECK           0x00000400 // A Добавление чека
#define CSESSRT_RMVCHECK           0x00000800 // D Удаление чека
#define CSESSRT_CHECKINFO          0x00001000 // E Редактирование специальной информации по чекам
#define CSESSRT_ESCCHECK           0x00002000 // C Отмена чека
#define CSESSRT_SYSINFO            0x00004000 // N Редактирование специальной информации по сессиям
#define CSESSRT_CORRECT            0x00008000 // Y Корректировки сессий
// Операционные флаги доступа в кассовых сессиях
#define CSESSOPRT_RETCHECK         0x00000001 // R Чеки возврата
#define CSESSOPRT_BANKING          0x00000002 // B Безналичный расчет
#define CSESSOPRT_ESCCLINE         0x00000004 // L Удаление строк в чеках
#define CSESSOPRT_PREPRT           0x00000008 // P Право на печать пре-чека
#define CSESSOPRT_SUSPCHECK        0x00000010 // S Право откладывать чеки
#define CSESSOPRT_COPYCHECK        0x00000020 // 1 Право на печать копии чека
#define CSESSOPRT_COPYZREPT        0x00000040 // 2 Право на печать копии Z-отчета
#define CSESSOPRT_SELNOTOWNSUSPCHK 0x00000080 // T Право на восстановление отложенного чека, привязанного к другому агенту
#define CSESSOPRT_ROWDISCOUNT      0x00000100 // I Право на установку скидки на строку чека
#define CSESSOPRT_XREP             0x00000200 // X Право на снятие X-отчета
#define CSESSOPRT_CTBLORD          0x00000400 // K Право на администрирование заказов столов (создание, изменение, отмена)
#define CSESSOPRT_SPLITCHK         0x00000800 // F Право на разделение чека
#define CSESSOPRT_CHGPRINTEDCHK    0x00001000 // G Право на изменение чека, по которому отпечат счет
#define CSESSOPRT_RESTORESUSPWOA   0x00002000 // H Право на извлечение отложенного чека без указания агента
#define CSESSOPRT_CHGCCAGENT       0x00004000 // J Право на смену агента в чеке
#define CSESSOPRT_MERGECHK         0x00010000 // M Право на объединение чеков
#define CSESSOPRT_ESCCLINEBORD     0x00020000 // Q Удаление строк в чеках до отправки заказа на изготовление
#define CSESSOPRT_REPRNUNFCC       0x00040000 // 3 Право на повторную печать чека, по которому была ошибка печати на регистраторе
#define CSESSOPRT_ARBITRARYDISC    0x00080000 // 4 @v11.0.9  Право на предоставление произвольной скидки на чек (суммой либо в процентах)

int GetOperRightsByKeyPos(int keyPos, PPIDArray * pOperRightsAry);
int EditDueToKeyboardRights();
//
// @todo @dbd_exchange Пакет чека передается не полностью
//
class PPObjCSession : public PPObject {
public:
	static SString & FASTCALL MakeCodeString(const CSessionTbl::Rec * pRec, SString & rBuf);
	static void    RightsToString(long rt, long opRt, SString & rBuf);
	static void    StringToRights(const char * pBuf, long * pRt, long * pOpRt);
	explicit PPObjCSession(void * extraPtr = 0);
	~PPObjCSession();
	virtual int  Search(PPID id, void * b = 0);
	virtual int  RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual void FASTCALL Dirty(PPID id); // @macrow
	//
	// Descr: Кэшированное извлечение записи CSession. Инициализируются следующие поля записи:
	//   ID, SuperSessID, CashNodeID, CashNumber, SessNumber, Dt, Tm, Incomplete, Temporary
	//
	int    Fetch(PPID id, CSessionTbl::Rec * pRec);
	int    Recalc(PPID sessID, int use_ta);
	int    UndoWritingOff(PPID sessID, int use_ta);
	int    ReWriteOff(PPID sessID, int level /* @#[0,5,10] */, int use_ta);
	int    Recover(const PPIDArray & rSessList);
	int    NeedTransmit(PPID id, const DBDivPack & rDestDbDivPack, ObjTransmContext * pCtx);
	//
	// Descr: Режимы вызова функции BuildCcDate2MaxIdIndex
	//
	enum {
		buildccdate2maxidindexMode_Force = 0,    // Безусловно перестроить индекс
		buildccdate2maxidindexMode_SkipIfCached, // Ничего не делать если индекс уже кэширован
		buildccdate2maxidindexMode_SkipIfActual, // Ничего не делать если последний элемент индекса не старше чем дата последнего чека минус 3 дня //
	};

	static int ValidateCcDate2MaxIdIndex(const LAssocArray & rIndex);
	int    BuildCcDate2MaxIdIndex(int mode);
	//
	// Descr: Извлекает из базы данных индекс соответстия дат чеков их максимальным идентификаторам.
	// Note: не используйте на-прямую. Вместо этого применяйте FetchCcDate2MaxIdIndex()
	//
	int    GetCcDate2MaxIdIndex(LAssocArray & rIndex);
	//
	// Descr: Извлекает из кэша индекс соответстия дат чеков их максимальным идентификаторам.
	//
	int    FetchCcDate2MaxIdIndex(LAssocArray & rIndex);
	//
	// Descr: Возвращает список чеков, по крайней мере одна строка которых содержит текст расширения lnextss
	//   эквивалентный pText.
	//
	// Returns:
	//   >0 - найден по крайней мере один чек
	//   <0 - не найдено ни одного чека
	//   0  - ошибка
	//
	int    GetListByEgaisMark(TSCollection <CCheckCore::ListByMarkEntry> & rList);// 
	int    GetListByChZnMark(TSCollection <CCheckCore::ListByMarkEntry> & rList);
	static uint GetCcListByMarkBackDays(const TSCollection <CCheckCore::ListByMarkEntry> & rList);
	//
	// Descr: Возвращает список чеков по UUID.
	//   Если возможно, то использует индексированные ассоциации {date; id} для быстрого
	//   поиска в близком диапазоне дат [getcurdate_() - backDays..].
	//
	int    GetListByUuid(const S_GUID & rUuid, uint backDays, PPIDArray & rCcList);
	//
	// Descr: Возвращает true если индекс CcDate2MaxIdIndex загружен в кэш.
	//   Функция требуется для быстрого определения необходимости перестройки индекса.
	//
	bool   IsCcDate2MaxIdIndexLoaded();
	const  PPEquipConfig & GetEqCfg();
private:
	virtual const char * GetNamePtr();
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  EditRights(uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
	virtual void FASTCALL Destroy(PPObjPack * pPack); // @macrow
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    RemoveWrOffBills(PPID sessID, int use_ta);
	int    VerifyAmounts(PPID sessID, const CSessTotal & rTotal, PPLogger & rLogger);

	SString NameBuf; // Is returned by GetNamePtr
	PPEquipConfig * P_EqCfg; // @!GetEqCfg()
public:
	TLP_MEMB(CSessionCore, P_Tbl);
	TLP_MEMB(CCheckCore, P_Cc);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPObjSCardSeries)
//
#define SCRDSF_CREDIT            0x00000001L // Кредитные карты (иначе дисконтные)
#define SCRDSF_USEDSCNTIFNQUOT   0x00000002L // Если с серией связан вид котировки и значение котировки для товара
	// не определено, то использовать скидку, заданную в карте.
#define SCRDSF_BONUS             0x00000004L // Бонусные кредитные карты (предполагает установленный флаг SCRDSF_CREDIT)
#define SCRDSF_UHTTSYNC          0x00000008L // Карты серии синхронизированы с сервисом Universe-HTT
#define SCRDSF_USEQUOTKINDLIST   0x00000010L // @internal С серией связан список видов котировок.
	// Флаг необходим для игнорирования поля PPSCardSeries2::QuotKindID
#define SCRDSF_MINQUOTVAL        0x00000020L // Если с серией карт ассоциирован список видов котировок (более одной),
	// то применять минимальную цену из котировок, полученных по списку.
#define SCRDSF_DISABLEADDPAYM    0x00000040L // Запрет на доплату в кассовой панели (только для кредитных карт)
#define SCRDSF_BONUSER_ONBNK     0x00000080L // SCardSeries::BonusChrgExtRule трактуется как изменение суммы оборота (для расчета начисления) в промилле.
#define SCRDSF_NEWSCINHF         0x00000100L //
#define SCRDSF_TRANSFDISCOUNT    0x00000200L // Карты серии с таким флагом могут передавать значение скидки в новые карты выдельца любой серии (при создании)
#define SCRDSF_PASSIVE           0x00000400L // Пассивная серия (не отображается в списках)
#define SCRDSF_GROUP             0x00000800L // Серия верхнего уровня
#define SCRDSF_RSRVPOOL          0x00001000L // Резервный пул
#define SCRDSF_ALLOWOWNERAUTOCR  0x00002000L // @v11.6.3 Допускается автоматическое создание персоналии-владельца
#define SCRDSF_QUANTACCOUNTING   0x00004000L // @v12.0.5 Карты этой серии допускают количественный учет. Для кредитных и бонусных карт.
//
// Descr: Типы серий карт
//
enum {
	scstUnkn = 0,     // Неопределенный тип
	scstDiscount = 1, // Простые дисконтные карты
	scstCredit,       // Кредитные карты
	scstBonus,        // Бонусные карты
	scstGroup,        // Серия верхнего уровня
	scstRsrvPool      // Резервный пул для динамического сопоставления карт из него с телефоном или персоналией и переноса в действующую серию
};

struct PPSCardSeries2 {    // @persistent @store(Reference2Tbl+)
	PPSCardSeries2();
	bool   FASTCALL IsEq(const PPSCardSeries2 & rS) const;
	int    GetType() const;
	int    SetType(int type);
	int    Verify();

	long   Tag;                // Const=PPOBJ_SCARDSERIES
	long   ID;                 // @id
	char   Name[48];           // @name @!refname
	char   Symb[20];           // @symb
	PPID   ChargeGoodsID;      // Товар, использующийся для начисления на карту. Имеет приоритет перед PPSCardConfig::ChargeGoodsID.
	PPID   BonusChrgGrpID;     // Товарная группа, ограничивающая начисления на бонусные карты
	int16  BonusChrgExtRule;   // Дополнительная величина правила изменения начисления бонуса по карте
	uint8  Reserve2;           // @reserve
	int8   VerifTag;           // Если 1, то запись верифицирована версией 7.3.7 на предмет правильности установки флагов
		// Если VerifTag == 2, то запись сохранена в версии v9.8.9 или выше.
	PPID   BonusGrpID;         // Товарная группа, по которой зачитываются бонусы на карты
	PPID   CrdGoodsGrpID;      // Товарная группа, продажа товаров которой зачитывается как списание по кредитной карте в количественном выражении.
	int32  FixedBonus;         // (.01) Фиксированная сумма бонуса на один чек. Специальный сценарий. (для бонусных и кредитных карт)
	PPID   RsrvPoolDestSerID;  // Серия, в которую должна переносится карта из резервного пула (которым является данная серия) при
		// активации (динамическом сопоставлении с телефоном или персоналией)
	long   SpecialTreatment;   // Идентификатор специальной трактовки операций с картами серии.
	long   QuotKindID_s;       // Вид котировки
	long   PersonKindID;       // Вид персоналии, используемый для владельцев карт (по умолчанию - PPPRK_CLIENT)
	LDATE  Issue;              // Дата выпуска
	LDATE  Expiry;             // Дата окончания действия //
	long   PDis;               // Скидка (.01%)
	double MaxCredit;          // Максимальный кредит (для кредитных карт)
	long   Flags;              // @flags
	long   Reserve4;           //
	long   ParentID;           //
};

struct TrnovrRngDis {      // @persistent @flat
	TrnovrRngDis();
	int    GetResult(double currentValue, double * pResult) const;
	enum {
		fBonusAbsoluteValue = 0x0001, // Величина Value применяется как абсолютное значение, начисляемое на бонусную карту
		fDiscountAddValue   = 0x0002, // Величина Value применяется как инкремент для величины скидки [-100..+100]
		fDiscountMultValue  = 0x0004, // Величина Value применяется как мультипликатор для величины скидки [0..10]
		fZeroTurnover       = 0x0008  // @v11.3.10 Если флаг установлен, то правило применяется к нулевым оборотам
	};
	RealRange R;
	double Value;          //
	PPID   SeriesID;       // ->Ref(PPOBJ_SCARDSERIES) Серия, в которую следует переместить карту, если обороты по ней попадают в интервал [Beg..End]
	PPID   LocID;          // Локация, для которой применяется данный элемент правила.
	long   Flags;          // @flags
};

#define SCARDSER_AUTODIS_PREVPRD      1L // Предшествующий период
#define SCARDSER_AUTODIS_THISPRD      2L // Текущий период 
#define SCARDSER_AUTODIS_ARBITRARYPRD 3L // @v11.3.5 Произвольный период (вводится пользователем)

class PPSCardSerRule : public TSVector <TrnovrRngDis> { // @persistent @store(PropertyTbl)
public:
	PPSCardSerRule();
	PPSCardSerRule & FASTCALL operator = (const PPSCardSerRule & s);
	PPSCardSerRule & Z();
	bool   FASTCALL IsEq(const PPSCardSerRule & rS) const;
	int    ValidateItem(int ruleType, const TrnovrRngDis & rItem, long pos) const;
	int    IsList() const;
	int    CheckTrnovrRng(const TrnovrRngDis & rItem, long pos) const;
	//int    GetPDisValue(double amt, double * pValue) const;
	const TrnovrRngDis * SearchItem(double amount) const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		rultDisc = 1,
		rultCcAmountDisc,
		rultBonus
	};
	int32  Ver;            //
	//
	// Следующий блок выделен в структуру для того, чтобы сериализоваться общим отрезком.
	// При вводе вместо зарезервированного пространства новых полей следует сохранять общий
	// размер блока.
	//
	struct FlatBlock {
		uint8  Reserve[48];    // @reserve // @v11.4.9 [52]-->[48]
		int16  CancelPrd;      // @v11.4.9 Тип периода обнуления суммы бонусов 
		uint16 CancelPrcCount; // @v11.4.9 Количество периодов типа CancelPrd после истечения которых сумма бонусов обнуляется.
		uint32 Internal[2];    // @internal
		long   Flags;          // @flags
	} Fb;
	int32  TrnovrPeriod;   // SCARDSER_AUTODIS_XXX
};

struct PPSCardSerPacket {
	PPSCardSerPacket();
	PPSCardSerPacket & Z();
	//
	// Descr: Реализует операции по нормализации внутреннего состояния пакета.
	//   В частности, согласовывает поле Rec.QuotKindID_s со списком QuotKindList и флагом SCRDSF_USEQUOTKINDLIST.
	//
	int    Normalize();
	bool   FASTCALL IsEq(const PPSCardSerPacket & rS) const;
	int    GetDisByRule(double trnovr, TrnovrRngDis & rEntry) const;

	enum {
		ufDontChgBonusRule    = 0x0001, // Функция PPObjSCardSeries::PutPacket не должна изменять правило расчета бонусов.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация BonusRule
		ufDontChgQkList       = 0x0002, // Функция PPObjSCardSeries::PutPacket не должна изменять список видов котировок.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация QuotKindList_
		ufDontChgExt  = 0x0004  // Функция PPObjSCardSeries::PutPacket не должна изменять запись расширения данных о серии.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация Ext
	};
	long   UpdFlags;          // @transient Флаги, определяющие правила изменения некоторых полей
	PPSCardSeries2 Rec;
	PPSCardSerRule Rule;         // Правила пересчета скидок  
	PPSCardSerRule CcAmtDisRule; // Правила предоставления скидки по чеку
	PPSCardSerRule BonusRule;    // Правила пересчета бонусов
	PPIDArray QuotKindList_;     // Список видов котировок, применимых для карт этой серии.
		// Конкретный вид котировки выбирается в соответствии с рангом и ограничениями.
	struct Ext {
		Ext();
		void   Init();
		bool   IsEmpty() const;
		bool   FASTCALL IsEq(const Ext & rS) const;
		char   CodeTempl[32]; // Шаблон номеров карт
		uint8  Reserve[20];   // @reserve
		LTIME  UsageTmStart;
		LTIME  UsageTmEnd;
		long   Reserve2[2];
	};
	Ext    Eb;
};

struct SCardChargeRule {
	SCardChargeRule();

	PPID   SerID;
	long   Period;
	DateRange Ap; // @v11.3.5
};

struct PPSCardConfig {         // @persistent @store(PropertyTbl)
	enum {
		fValid         = 0x0001, // Признак того, что запись является действительной (загруженной из базы данных)
		fSyncWoChecks  = 0x0002, // Заменяет DBDXF_SYNCSCARDWOCHECKS
		fAcceptOwnerInDispDiv  = 0x0004, // Принимать изменения владельца карты в диспетчерском разделе
		fDontUseBonusCards     = 0x0008, // Использовать бонусные карты только как дисконтные.
			// Флаг следует установить в разделе базы данных, обслуживающем магазин, в котором бонусные карты не
			// должны использоваться, в противоположность другим синхронизированным магазинам.
		fCheckBillDebt = 0x0010, // При операциях по карте проверять наличие простроченной задолженности по документам, привязанным к карте
		fDisableBonusByDefault = 0x0020  // По умолчанию не применять бонус при расчете в кассовой панели (с возможностью ручного включения)
	};
	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_SCARDCFG
	long   Flags;              //
	PPID   PersonKindID;       // ->Ref(PPOBJ_PERSONKIND) Вид персоналии, используемый для владельцев карт.
		// Этот параметр может быть переопределен серией карт.
	PPID   DefPersonID;        // ->Person.ID Персоналия, используемая как владелец карты по умолчанию
	PPID   ChargeGoodsID;      // ->Goods2.ID Товар, используемый для начисления на кредитную карту
	PPID   ChargeAmtID;        // ->Ref(PPOBJ_AMOUNTTYPE) Тип суммы, применяемый для начисления на кредитную карту из документа.
	PPID   DefSerID;           // Серия дисконтных карт по умолчанию //
	PPID   DefCreditSerID;     // Серия кредитных карт по умолчанию //
	long   WarnExpiryBefore;   // Период в днях, в течении которого владельца карты следует предупредить об истечении срока действия //
	char   Reserve1[40];       //
	long   Reserve2[2];        //
};

struct SCardSeriesFilt {
	SCardSeriesFilt();
	enum {
		fOnlyGroups   = 0x0001, // Только группы серий
		fOnlySeries   = 0x0002, // Только терминальные серии
		fShowPassive  = 0x0004, // Показывать пассивные серии
		fOnlyReal     = 0x0008  // Только "рабочие" серии (scstDiscount, scstCredit, scstBonus)
	};
	PPID   ParentID;   // Группа серий
	int    SpecialTreatment;
	long   Flags;      //
};

class PPObjSCardSeries : public PPObjReference {
public:
	static int SetSCardsByRule(const SCardChargeRule * pSelRule);
	static int SelectRule(SCardChargeRule * pSelRule);
	static int FASTCALL FetchConfig(PPSCardConfig * pCfg);
	explicit PPObjSCardSeries(void * extraPtr = 0);
	~PPObjSCardSeries();
	virtual int    Search(PPID id, void * b);
	virtual int    Edit(PPID * pID, void * extraPtr);
	virtual ListBoxDef * Selector(ListBoxDef * pOrgDef, long flags, void * extraPtr);
	// @v11.1.10 virtual int    UpdateSelector_Obsolete(ListBoxDef * pDef, long flags, void * extraPtr);
	virtual int    Browse(void * extraPtr);
	int    FASTCALL Fetch(PPID id, PPSCardSeries * pRec); // @macrow
	int    GetPacket(PPID id, PPSCardSerPacket * pPack);
	int    PutPacket(PPID * pID, PPSCardSerPacket * pPack, int use_ta);
	int    SerializePacket(int dir, PPSCardSerPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	SCardSeriesFilt & InitFilt(void * extraPtr, SCardSeriesFilt & rFilt) const;
	int    CheckForFilt(const SCardSeriesFilt * pFilt, const PPSCardSeries & rRec) const;
	int    GetCodeRange(PPID serID, SString & rLow, SString & rUpp); // @>>SCardCore::GetCodeRange
	//
	// Descr: Возвращает список идентификаторов серий, для которых id является родительской.
	//   Функция вызывается рекурсивно для всех дочерних серий.
	//   Если серия id не является группирующей, то она единственная попадает в список. Если же
	//   она является группирующей, то в список не попадает.
	//   Функция пытается обнаружить цикличность в дереве зависимостей и, если находит, то
	//   возвращает 0 с установкой соответствующего кода ошибки.
	//
	int    GetChildList(PPID id, PPIDArray & rList);
	int    GetSeriesWithSpecialTreatment(LAssocArray & rList);
private:
	virtual void FASTCALL Destroy(PPObjPack * pPack); // @macrow
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    Helper_GetChildList(PPID id, PPIDArray & rList, PPIDArray * pStack);
	int    AssignImages(ListBoxDef * pDef);

	PPObjSCard * P_ScObj;
};
//
// @ModuleDecl(PPObjSCard)
//
//
// Специфические флаги доступа PPObjSCard (в дополнение к общим RT_XXX)
//
#define SCRDRT_VIEWOPS         0x0100      // Право просмотра операций по карте
#define SCRDRT_ADDOPS          0x0200      // Право добавления операций по карте
#define SCRDRT_RMVOPS          0x0400      // Право удаления операций по карте
#define SCRDRT_BINDING         0x0800      // Право на изменение привязки карты к чеку или документу
#define SCRDRT_MASSCHANGE      0x1000      // Право на массовое изменение дисконтных карт

#define SCRDF_INHERITED        0x00000001L // Карта наследует некоторые параметры от серии
#define SCRDF_CLOSED           0x00000002L // Карта закрыта (блокирована)
#define SCRDF_CLOSEDSRV        0x00000004L // Карта блокирована для службы доставки
#define SCRDF_NOGIFT           0x00000008L // При продаже по этой карте блокируется выдача подарка
#define SCRDF_AUTOCREATE       0x10000000L // @transient Специальный флаг, предписывающий функции, получившей запись
	// с таким флагом создать новую карту с некоторыми атрибутами записи.
#define SCRDF_NEEDACTIVATION   0x00000010L // Карта требует активации
#define SCRDF_AUTOACTIVATION   0x00000020L // Активировать карту после первой операции
#define SCRDF_NOTIFYDISCOUNT   0x00000040L // Извещать владельца карты об изменении скидки
#define SCRDF_NOTIFYDRAW       0x00000080L // Извещать владельца карты о списании средств с карты
#define SCRDF_NOTIFYWITHDRAW   0x00000100L // Извещать владельца карты о начислении средств на карту
#define SCRDF_OWNERVERIFIED    0x00000200L // Владелец карты верифицирован (например, посредством СМС)

#define PPTRPROP_SCARDEXT      (PPTRPROP_USER+1)

class PPSCardPacket : public PPExtStrContainer {
public:
	PPSCardPacket();
	PPSCardPacket & Z();
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке ExtString
	//
	enum { // @persistent
		extssMemo     = 1,
		extssPassword = 2,
		extssPhone    = 3, //
		extssOuterId  = 4  // Если эмитентом карты является сторонняя организация, то здесь может быть указан ид карты, заданный эмитентом (guid, например)
	};
	SCardTbl::Rec Rec;
};
//
// Descr: Виды специальных трактовок серий персональных карт
//
#define SCRDSSPCTRT_DEFAULT    0 // default
#define SCRDSSPCTRT_AZ         1 // AstraZeneca
#define SCRDSSPCTRT_UDS        2 // UDS
#define SCRDSSPCTRT_UHTT       3 // Universe-HTT (попытка унифицированного представления для технологии, используюемой до введения понятия SpecialTreatment
//
// Descr: Базовый класс для реализации функционала специальной трактовки серий персональных карт
//
class SCardSpecialTreatment {
public:
	//
	// Descr: Опции Capability, определяющие базовые свойства внешнего сервиса
	//
	enum {
		capfVerifyPhone   = 0x0001,  // Есть функция проверки номера телефона
		capfItemDiscount  = 0x0002,  // Определяет скидку на товарные позиции
		capfTotalDiscount = 0x0004,  // Определяет скидку на весь чек
		capfBonus         = 0x0008,  // Функция начисления и списания бонусов
	};
	//
	// Descr: Способы идентификации карты у внешнего сервиса
	//
	enum {
		ictUndef     = 0, // Не определен
		ictSCardCode = 1, // По коду карты (совпадающему с кодом карты в собственной базе данных)
		ictHash      = 2, // По специальному хэш-коду, который меняется время от времени и не может идентифицировать однозначно карту без обращения к сервису
		ictPhone     = 3  // Номер телефона
	};
	struct IdentifyReplyBlock { // @flat
		IdentifyReplyBlock();
		IdentifyReplyBlock & Z();
		enum {
			fDefinedDiscount = 0x0001, // Значение Discount определено сервисом
			fDefinedRest     = 0x0002, // Значение Rest определено сервисом
			fDefinedHash     = 0x0004, // Значение Hash определено сервисом
			fBonusDisabled   = 0x0008  // Применение бонуса по карте при данной идентификации не допускается //
		};
		int    SpecialTreatment; // Ид специальной трактовки поведения карт (из серии)
		long   Flags;      // @flags
		long   InCodeType; // ictXXX Тип кода InCode, который использовался для идентификации карты внешним сервисом
		PPID   ScID;       // Идентифицированный id карты (в локальной базе данных)
		double Discount;   // Скидка, определенная внешним сервисом
		double Rest;       // Остаток по карте, определенный внешним сервисом
		char   InCode[40]; // Код, который был передан для идентификации карты внешним сервисом
		char   OperationCode[40]; // Код карты, используемый для выполнения операций на внешнем сервисе.
		char   Hash[40];   // Код доступа к информации о карте, возвращенный внешним сервисом
	};
	struct CardBlock {
		CardBlock();

		int    SpecialTreatment;
		PPSCardPacket ScPack;
		PPID   PosNodeID;
		SString PosNodeCode;
	};
	struct DiscountBlock { // @flat
		DiscountBlock();
		enum {
			fProcessed = 0x0001 // Признак того, что по этой строке ранее был получен ответ.
				// Текущая передача обусловлена лишь необходимостью информировать провайдера обо всех его товарах в чеке.
		};
		int    RowN;    // Ссылка на номер позиции в контейнере (в чеке, например). 0 - undefined
		PPID   GoodsID;
		long   Flags;
		double Qtty;
		double InPrice;
		double ResultPrice;
		char   TaIdent[64];
	};
	struct TransactionResult { // @flat
		TransactionResult();
		enum {
			stRejected = -1,
			stUndef    = 0,
			stAccepted = 1,
		};
		int    Status;
		uint   ResultFlags;
		S_GUID CustomerUid;
		char   TaIdent[64];
		char   CustomerIdent[64];
		char   ErrMessage[512];
	};

	static SCardSpecialTreatment * FASTCALL CreateInstance(int spcTrtID);
	static int FASTCALL InitSpecialCardBlock(PPID scID, PPID posNodeID, CardBlock & rBlk);
	virtual ~SCardSpecialTreatment();
	uint   GetCapability() const { return Capability; }
	//
	// Descr: Функция пытается идентифицировать код владельца карты rB.InCode. Это может быть либо хэш-код либо телефон.
	//   Если код идентифицирован, то, возможно, функции придется создать новый экземпляр карты, соответствующий
	//   этому владельцу. Здесь проблема в том, что мы можем не знать заранее о существовании этого клиента
	//   поскольку обслуживаем клиента некоего глобального сервиса. По-этому алгоритм примерно следующий:
	//   1. Определить что нам подсунули в виде pCode: номер карты, хэш-код или номер телефона.
	//   2. Как-бы мы не интерпретировали этот код надо обратиться к сервису за подтверждением
	//   3. Если сервис вернул нам успешный результат, то попытаемся найти карту, соответствующую полученным данным
	//     и, если такая карта не найдена, вынуждены будем создать новую, вероятно, с владельцем (именно для этого нам
	//     нужен параметр use_ta).
	//   4. Идентификатор найденной карты присваиваем переменной rB.ScID
	// Returns:
	//   Одно из значений перечисления ictXXX (определено выше)
	//   ictUndef - не удалось идентифицировать код rB.InCode
	//   ictSCardCode - pCode это номер карты
	//   ictHash      - pCode это хэш который был успешно идентифицирован
	//   ictPhone     - pCode это номер телефона по которому сервис дал положительный ответ
	//
	virtual int IdentifyCode(IdentifyReplyBlock & rB, PPID seriesID, int use_ta);
	virtual int VerifyOwner(const CardBlock * pScBlk);
	//
	// Descr: Функция должна проверить принадлежит ли товар множеству, подпадающему под потенциальную скидку.
	// Returns:
	//   >0 - товар подпадает под действие карты (тем или иным образом)
	//   0  - товар никаким образом не обрабатывается специальной трактовкой карты
	//
	virtual int DoesWareBelongToScope(PPID goodsID);
	virtual int QueryDiscount(const CardBlock * pScBlk, TSVector <DiscountBlock> & rDL, long * pRetFlags, StringSet * pRetMsgList);
	virtual int CommitCheck(const CardBlock * pScBlk, const CCheckPacket * pCcPack, TransactionResult * pResult);
protected:
	explicit SCardSpecialTreatment(uint capability);
private:
	const uint Capability;
};

class PPObjSCard : public PPObject {
public:
	struct AddParam {
		explicit AddParam(PPID serID = 0, PPID ownerID = 0);

		PPID   SerID;
		PPID   OwnerID;
		PPID   LocID;
		SString Code;
		SString Phone;
	};
	//
	// Descr: Фильтр селектора (MakeStrAssocList)
	//
	struct Filt {
		Filt();

		const  uint32 Signature; // PPConst::Signature_PPObjSCard_Filt
		PPID   SeriesID;
		PPID   OwnerID;
	};

	static int FASTCALL WriteConfig(const PPSCardConfig * pCfg, int use_ta);
	static int FASTCALL ReadConfig(PPSCardConfig * pCfg);
	static int FASTCALL FetchConfig(PPSCardConfig * pCfg);
	static int EditConfig();
	static int FASTCALL PreprocessSCardCode(SString & rCode);
	static SString & CalcSCardHash(const char * pNumber, SString & rHash);
	static long GetValidFlags()
		{ return (SCRDF_INHERITED|SCRDF_CLOSED|SCRDF_CLOSEDSRV|SCRDF_NOGIFT|SCRDF_NEEDACTIVATION|SCRDF_AUTOACTIVATION|SCRDF_NOTIFYDISCOUNT|SCRDF_NOTIFYDRAW|SCRDF_NOTIFYWITHDRAW); }

	explicit PPObjSCard(void * extraPtr = 0);
	~PPObjSCard();
	//
	// В качестве дополнительного параметра методам PPObjSCard
	// передается идентификатор серии карточек.
	//
	virtual int    Browse(void * extraPtr);
	virtual int    Edit(PPID * pID, void * extraPtr);
	virtual int    DeleteObj(PPID id);
	virtual int    Search(PPID id, void * = 0);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*(PPObjSCard::Filt*)*/);
	int    IsPacketEq(const PPSCardPacket & rS1, const PPSCardPacket & rS2, long flags);
	int    PutPacket(PPID * pID, PPSCardPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPSCardPacket * pPack);
	//
	// Descr: Извлекает запись карты через кэш. Инициируются следующие поля:
	//   SeriesID, PersonID, Flags, Dt, Expiry, PDis, AutoGoodsID, MaxCredit, UsageTmStart, UsageTmEnd
	//
	int    FASTCALL Fetch(PPID id, SCardTbl::Rec * pRec); // @macrow
	//
	// Descr: Извлекает через кэш строку расширения fldId пакета с идентификатором id.
	//
	int    FetchExtText(PPID id, int fldId, SString & rBuf);
	void FASTCALL Dirty(PPID id); // @macrow
	//
	//
	//
	struct UhttEntry {
		char   Code[24];
		LDATETIME ActualDtm;
		char   UhttCode[24];
		char   UhttHash[24];
		double Rest;
	};
	int    FetchUhttEntry(const char * pCode, PPObjSCard::UhttEntry * pEntry);
	const PPSCardConfig & GetConfig();
	PPID   FASTCALL GetChargeGoodsID(PPID scardID);
	int    Edit(PPID * pID, const AddParam & pParam);
	//
	//
	//
	enum {
		edfDisableCode = 0x0001
	};
	//
	// Descr: Вызывает диалог редактирования записи персональной карты.
	//   Никаких изменений в базе данных функция не делает.
	//   Используется как вспомогательный инструмент редактирования параметров карты.
	// Returns:
	//   >0 - пользователь подтвердил изменения в записи.
	//   <0 - пользователь отклонил изменения. Запись pRec точно осталась не изменной.
	//   0  - ошибка. Запись pRec точно осталась не изменной.
	//
	int    EditDialog(PPSCardPacket * pPack, long flags);
	//
	// Descr: Открывает диалог ввода номер карты и ищет карту по этому
	//   номеру. Если карта найдена, то открывает диалог редактирования //
	//   найденной карты, в противном случае запрашивает подтверждение на
	//   создание новой карты. Если пользователь отвечает утвердительно,
	//   тогда открывает диалог создания новой карты с предустановленным
	//   введенным номером и параметрами, определяемые аргументом pParam.
	// Returns:
	//   -1 - пользователь отказался от ввода либо от создания карты.
	//   +1 - карта была найдена и пользователь подтвердил редактирование.
	//   +2 - карта не была найдена и пользователь создал новую (ее идентификатор
	//      присваивается по адресу pID).
	//    0 - error.
	//
	int    FindAndEdit(PPID * pID, const AddParam * pParam);
	//
	// Descr: Выводит диалог редактирования версии histID пакета карты.
	//
	int    ViewVersion(PPID histID);

	enum {
		cdfCreditCard = 0x0001
	};
	//
	// Descr: Создает новую запись карты.
	// ARG(pID OUT): Указатель, по которому в случае успешного исполнения присваивается идентификаторв
	//   созданной записи.
	// ARG(seriesID IN): Идентификатор серии карты. Если этот параметр нулевой, то новая присваивается //
	//   либо серии PPSCardConfig::DefSerID либо PPSCardConfig::DefCreditSerID в зависимости от
	//   наличия в параметре flags флага PPObjSCard::cdfCreditCard.
	//   При этом, если в конфигурации не определена требуемая серия, то функция завершается ошибкой.
	// ARG(rNumber IN/OUT): Номер новой карты. Если эта строка при вызове функции пуста (либо содержит только
	//   пробелы), то номер новой карты формируется автоматически в соответствии с шаблоном, определенным
	//   в серии, которой будет принадлежать карта. При отсутствии валидного шаблона
	//   функция завершается с ошибкой.
	// ARG(pPassword IN): Опциональная строка, устанавливаемая как пароль для доступа к функциям, ассоциированным с картой
	// ARG(flags IN): Опции создания новой записи (PPObjSCard::cdfXXX).
	// ARG(use_ta IN): Если !0, то фукнция выполняется в собственной транзакции.
	// Returns:
	//   >0 - функция завершилась успешно.
	//   0  - ошибка.
	//
	int    Create_(PPID * pID, PPID seriesID, PPID ownerID, const SCardTbl::Rec * pPatternRec, SString & rNumber, const char * pPassword, long flags, int use_ta);
	int    GetListBySubstring(const char * pSubstr, PPID seriesID, StrAssocArray * pList, int fromBegStr);
	//
	// Descr: Возвращает 1 если серия scSerID является серией кредитных карт.
	//   Если объект scSerID не найден или scSerID не является серией кредитных карт,
	//   то возвращает 0.
	//
	int    IsCreditSeries(PPID scSerID);
	static int GetSeriesType(PPID scSerID);
	//
	// Возвращает 1 если карта cardID относится к серии кредитных карт.
	// Если объект cardID не найден или карта cardID не относится к серии
	// кредитных карт, то возвращает 0.
	//
	int    IsCreditCard(PPID cardID);
	int    GetCardType(PPID cardID);
	int    GetTransmitPacket(PPID, const LDATETIME *, SCardTransmitPacket *, const ObjTransmContext * pCtx);
	int    PutTransmitPacket(PPID *, SCardTransmitPacket *, int update, ObjTransmContext * pCtx, int use_ta);
	int    SearchCode(PPID seriesID, const char * pCode, SCardTbl::Rec *);
	//
	// Descr: Если поле Flags структуры pRec имеет флаг SCRDF_INHERITED, то устанавливает в этой структуре
	//   значения наследуемых полей из записи серии карт. Если указатель на запись серии pSerRec != 0, то наследуемые
	//   поля извлекаются из нее (без оглядки на идентификатор pSerRec->ID), если же pSerRec == 0, то
	//   запись серии извлекается из базы данных (без кэширования).
	//   Запись *pRec изменится после вызова функции только если возращаемое значение >0.
	// Returns:
	//   <0 - либо запись pRec не наследуемая, либо pRec == 0, либо ни одно из наследуемых полей не изменилось.
	//   >0 - запись pRec наследуемая и изменилось по крайней мере одно из наследуемых полей.
	//   0  - ошибка. Если pSerRec == 0 и серия с идентификатором pRec->SeriesID не найдена, то результат также 0.
	//
	//int    SetInheritance(const PPSCardSeries * pSerRec, SCardTbl::Rec * pRec);
	int    SetInheritance(const PPSCardSerPacket * pSerRec, SCardTbl::Rec * pRec);
	int    AutoFill(PPID seriesID, int use_ta);
	int    UpdateBySeries(PPID seriesID, int use_ta);
	int    UpdateBySeriesRule2(PPID seriesID, /*int prevTrnovrPrd*/const SCardChargeRule & rRule, PPLogger * pLog, int use_ta);
	int    PutUhttOp(PPID cardID, double amount);
	//
	// Descr: Устанавливает параметры карты в состояние активности: Flags &= ~(SCRDF_CLOSED|SCRDF_NEEDACTIVATION),
	//   Expiry рассчитывает исходя из параметров PeriodTerm и PeriodCount.
	// Returns:
	//   >0 - карта успешно активирована
	//   <0 - карта не требует активации
	//   0  - ошибка
	//
	int    ActivateRec(SCardTbl::Rec * pRec);
	int    VerifyOwner(PPSCardPacket & rScPack, PPID posNodeID, int updateImmediately);

	enum {
		gtalgDefault = 0,
		gtalgByCheck,
		gtalgByBill,
		gtalgForBonus,  // Алгоритм для расчета бонусов по картам
		gtalgByOp
	};

	int    GetTurnover(const SCardTbl::Rec & rRec, int alg, const DateRange & rPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	int    GetTurnover(PPID cardID, int alg, const DateRange & rPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	//
	// Descr: Ищет карту по владельцу ownerID из которой можно унаследовать величину процентной скидки.
	//
	int    FindDiscountBorrowingCard(PPID ownerID, SCardTbl::Rec * pRec);
	//
	// Descr: Быстро рассчитывает обороты по всем картам, которые использовались
	//   в заданном периоде и заполняет найденными значениями переданный массив.
	//
	int    CreateTurnoverList(const DateRange *, RAssocArray *);
		// @>>CCheckCore::CreateSCardsTurnoverList()
	int    Import(int use_ta);
	int    SetFlags(PPID id, long flags, int use_ta);
	int    CheckUniq();
	//
	// Descr: Флаги функции CheckRestrictions
	//
	enum {
        chkrfIgnoreUsageTime = 0x0001 // Игнорировать допустимое время применения //
	};
	//
	// Descr: Проверяет возможность использования карты для обслуживания.
	// Returns:
	//   0 - карта не может быть применена
	//   1 - карта может быть применена
	//   2 - специальный случай: карта закрыта и требует активации, но в ней установлен признак автоактивации,
	//      то есть, после первой операции по ней она должна быть автоматически активирована.
	//
	int    CheckRestrictions(const SCardTbl::Rec * pRec, long flags, LDATETIME dtm);
	int    CheckExpiredBillDebt(PPID scardID);
	int    FinishSCardUpdNotifyList(const TSVector <SCardCore::UpdateRestNotifyEntry> & rList);
	int    NotifyAboutRecentOps(const LDATETIME & rSince);
	int    SelectCardFromReservePool(PPID * pPoolID, PPID destSeriesID, PPID * pID, int use_ta);
	int    IndexPhones(PPLogger * pLogger, int use_ta);
	int    SerializePacket(int dir, SCardTransmitPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SerializePacket(int dir, PPSCardPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Специальная высокоуровневая функция для многофазного поиска карты по коду
	//   Используется в кассовой панели и сопутствующих диалогах.
	//
	int    SearchCodeExt(const char * pCode, const LAssocArray * pSpcTrtScsList, PPIDArray & rScList, TSVector <SCardSpecialTreatment::IdentifyReplyBlock> & rScpRbList);
protected:
	virtual const char * GetNamePtr();
	virtual int    HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int    EditRights(uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
private:
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    Helper_Edit(PPID * pID, const AddParam * pParam);
	enum {
		clsfStrList = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		clsfFromBeg = 0x0002  // Только карты, начинающиеся с pSubstr
	};
	int    Helper_GetListBySubstring(const char * pSubstr, PPID seriesID, void * pList, long flags);
	const  StrAssocArray * GetFullList();
	void   ReleaseFullList(const StrAssocArray * pList);

	PPObjCSession * P_CsObj;  // Uses for transmission data to another db division
	PPObjLocation LocObj;     // Из-за внесения собственного номера телефона в атрибуты карты, PPObjLocation понадобится при сохранении пакета для индексации телефонов.
	PPSCardConfig Cfg;
	int    DoObjVer_SCard;    // Хранить версии измененных и удаленных объектов
public:
	TLP_MEMB(CCheckCore, P_CcTbl);
public:
	SCardCore * P_Tbl; // Не использует TLP_MEMB поскольку получает этот указатель от P_CcTbl
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewDvcLoadingStat)
//
struct DvcLoadingStatFilt : public PPBaseFilt {
	DvcLoadingStatFilt();

	uint8  ReserveStart[32]; // @anchor
	short  DvcType;          // Тип устройства
	uint16 Reserve2;         // @alignment
	long   DvcID;            // ИД устройства
	DateRange Period;        // Период, за который следует отображать данные
	long   Flags;            // @flags
	PPID   GoodsGrpID;       // Товарная группа
	PPID   GoodsID;          // ИД товара
	long   Reserve;          // @anchor @reserve
};

typedef DvcLoadingStatTbl::Rec DvcLoadingStatViewItem;

class PPViewDvcLoadingStat : public PPView {
public:
	struct BrwHdr {
		long   DlsID;
		short  DvcType;
		long   DvcID;
	};

	PPViewDvcLoadingStat();
	~PPViewDvcLoadingStat();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(DvcLoadingStatViewItem *);
private:
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);

	DvcLoadingStatFilt Filt;
	PPIDArray GGrpList;
	DeviceLoadingStat DlsT;
};
//
// @ModuleDecl(PPViewDLSDetail)
//
struct DLSDetailFilt {
	DLSDetailFilt();
	long   DlsID;
	short  DvcType;
	uint16 Reserve; // @alignment
	long   DvcID;
	long   ObjType;
	PPIDArray BillList; // Список документов, повлиявших на подбор измененных товаров
};

typedef DlsObjTbl::Rec DLSDetailViewItem;

class PPViewDLSDetail : public PPView {
public:
	struct BrwHdr {
		long   DlsID;
		short  ObjType;
		long   ObjID;
		long   LVal;
		double Val;
	};
	PPViewDLSDetail();
	~PPViewDLSDetail();
	int    Init(const DLSDetailFilt * pFilt);
	int    InitIteration();
	int    NextIteration(DLSDetailViewItem * pItem);
private:
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);

	DLSDetailFilt  Filt;
	DlsObjTbl * P_DlsObjTbl;
	PPObjGoods GObj;
	PPObjSCard SCObj;
};
//
// @ModuleDecl(AsyncCashSCardsIterator)
//
struct AsyncCashSCardInfo {
	AsyncCashSCardInfo();
	AsyncCashSCardInfo & Z();

	SCardTbl::Rec Rec;
	//int    IsClosed;
	enum {
		fClosed = 0x0001,
		fDisableSendPaperlassCCheck = 0x0002
	};
	long   Flags;
	LDATE  PsnDOB;   // @v11.3.5 День рождения персоналии 
	double Rest;     // Остаток по кредитной карте
	SString PsnName; // Наименование персоналии-владельца //
	SString Phone;   // @V10.6.3 Номер телефона, ассоциированный с картой (не с персоналией)
	SString PsnPhone; // @v11.3.5 Номер телефона персоналии
	SString Email;    // @v11.3.5 Электронная почта персоналии
};

class AsyncCashSCardsIterator {
public:
	AsyncCashSCardsIterator(PPID cashNodeID, int updOnly, DeviceLoadingStat * pDLS, PPID statID);
	~AsyncCashSCardsIterator();
	int    Init(const PPSCardSerPacket *);
	int    Next(AsyncCashSCardInfo *);
	int    SetStat();
	const  IterCounter & GetCounter() const { return Counter; }
protected:
	PPCashNode NodeRec;
	PPSCardSerPacket ScsPack;
	SCardTbl::Rec Rec;
	PPObjSCard SCObj;
	PPObjPerson PsnObj;
	int    UpdatedOnly;
	LDATETIME Since;
	BExtQuery * P_IterQuery;
	DeviceLoadingStat * P_DLS;
	PPIDArray UpdSCardList;    // Список карт, измененых с момента Since
	PPID   StatID;
private:
	PPID   DefSCardPersonID;   // Персоналия, которая по умолчанию является владельцем карт,
		// у которых нет явно заданного владельца. Необходимо для некоторых кассовых модулей, которые
		// требуют владельца для каждой карты либо работают не корректно с картами, не имеющими владельца.
	IterCounter Counter;
	SString DefPersonName;     //
};
//
// @ModuleDecl(PPObjDraftWrOff)
// @prefix=dwo
//
#define DWOF_DFCTARISLOC   0x0001L
#define DWOF_USEMRPTAB     0x0002L // При списании использовать MRP-таблицы
#define DWOF_SETMANUFDATE  0x0004L // При формировании компенсации дефицита устанавливать в лотах дату производства

struct PPDraftWrOff2 {           // @persistent @store(Reference2Tbl+)
	PPDraftWrOff2();
	void   SetLotManufTimeParam(const PUGL::SetLotManufTimeParam * pS);
	void   GetLotManufTimeParam(PUGL::SetLotManufTimeParam * pS) const;

	long   Tag;                  // Const=PPOBJ_DRAFTWROFF
	long   ID;                   // @id
	char   Name[48];             // @name
	char   Symb[20];             //
	char   Reserve[52];          // @reserve
	int16  SetManufDateOffsDays; // Смещение в днях от исходной даты до даты производства, присваиваемого лотам
		// при компенсации дефицита if(Flags & DWOF_SETMANUFDATE).
	int16  SetManufFixedTime;    // Фиксированное время производства компенсации дефицита в минутах (напр. 720=12:00)
	PPID   PoolOpID;             // Операция формирования пула документов списания //
	long   Flags;                // Флаги DWOF_XXX
	PPID   DfctCompensOpID;      // Операция компенсации дефицита
	PPID   DfctCompensArID;      // Контрагент в документах компенсации дефицита
};

struct PPDraftWrOffEntry {
	PPDraftWrOffEntry();
	PPID   OpID;
	PPID   LocID;
	long   Reserve[2];
	long   Flags;
};

struct PPDraftWrOffPacket {
	PPDraftWrOffPacket();
	~PPDraftWrOffPacket();
	void   Init();
	PPDraftWrOffPacket & FASTCALL operator = (const PPDraftWrOffPacket &);

	PPDraftWrOff Rec;
	SArray * P_List; // <PPDraftWrOffEntry>
};

class PPObjDraftWrOff : public PPObjReference {
public:
	explicit PPObjDraftWrOff(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    PutPacket(PPID * pID, PPDraftWrOffPacket *, int use_ta);
	int    GetPacket(PPID id, PPDraftWrOffPacket *);
};
//
// @ModuleDecl(PPObjAdvBillKind)
// @prefix=abk
//
struct PPAdvBillKind2 {    // @persistent @store(Reference2Tbl+)
	PPAdvBillKind2()
	{
		THISZERO();
	}
	enum {
		fSkipAccturn = 0x0001 // Для строки расширенного бух документа с таким видом не проводит бух проводку
	};
	long   Tag;            // Const=PPOBJ_ADVBILLKIND
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          // Флаги PPAdvBillKind::fXXX
	PPID   LinkOpID;       // Операция связанного документа //
	long   Reserve2;       // @reserve
};

class PPObjAdvBillKind : public PPObjReference {
public:
	PPObjAdvBillKind(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
private:
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjProcessor)
//
// Виды записей процессоров
//
#define PPPRCK_GROUP      1 // Группа процессоров
#define PPPRCK_PROCESSOR  2 // Собственно процессор
//
//
//
#define PRCF_INDUCTSUPERSESSTATUS  0x00000001L // Проецировать статусы суперсессий на подчиненные сессии
#define PRCF_STOREGOODSREST        0x00000002L // При закрытии сессий по этому процессору
	// фиксировать остатки товаров на момент закрытия сессии.
	// Остатки фиксируются в таблице TSessLine с признаками Sign=0, Flags|=TSESLF_OUTREST
#define PRCF_PRINTNEWLINE_PANE     0x00000004L // Печатать этикетку для каждой новой строки в панели
#define PRCF_ALTGROUP              0x00000008L // Альтернативная группа процессоров
#define PRCF_DEFSIGN_MINUS         0x00000010L // Знак операции по умолчанию - расход
#define PRCF_DEFSIGN_PLUS          0x00000020L // Знак операции по умолчанию - приход
	// @#{PRCF_DEFSIGN_MINUS^PRCF_DEFSIGN_PLUS}
#define PRCF_ENABLEDUPSERIAL       0x00000040L // Разрешение на ввод в строку сессии строк с одинаковым серийным номером
#define PRCF_ONECLICKTURN_PANE     0x00000080L // Проводить строку сессии в панели процессора сразу после выбора товара
	// (по штрихкоду или серийному номеру). Используется для быстрого ввода в случае, когда не надо явно задавать количество
	// и другие атрибуты строки кроме собственно товара (лота)
#define PRCF_LOCKWROFF             0x00000100L // Сессии по этому процессору не списываются //
#define PRCF_WROFFDT_START         0x00000200L // Дата документа списания - дата начала сессии
	// Если флаг не установлен, то дата конца сессии.
#define PRCF_WROFFDT_BYSUPER       0x00000400L // Дата документа списания определяется датой суперсессии
	// по правилу флага PRCF_WROFFDT_START. Если суперсессии нет, то PRCF_WROFFDT_BYSUPER игнорируется.
#define PRCF_CANSWITCHPAN          0x00000800L // Флаг группы, означающий, что в панели процессора
	// допускается переключение между процессорами этой группы. Область действия этого флага распростаняется //
	// только на процессоры, непосредственно привязанными к этой группе.
#define PRCF_ACCDUPSERIALINSESS    0x00001000L // Принимать две строки сессии с одним серийным номером
#define PRCF_TURNINCOMPLBILL       0x00002000L // Проводить документы по сессиям, даже если есть дефицит
#define PRCF_PASSIVE               0x00004000L // Пассивный процессор (флаг не наследуется от группы)
#define PRCF_ADDEDOBJASAGENT       0x00008000L // Доп объект сессии списывается как агент (только в случае, если доп объект по виду операции не определен).
#define PRCF_CLOSEBYJOBSRV         0x00010000L // Сессия процессора может быть закрыта JobServer'ом
#define PRCF_USETSESSSIMPLEDLG     0x00020000L // Использовать упрощенный диалог редактирования технологической сессии
#define PRCF_NEEDCCHECK            0x00040000L // Тех сессии по процессору требуют кассовый чек (запрет на проведение
	// сессии без чека регламентируется правом доступа по тех сессиям TSESRT_CLOSEWOCC)
#define PRCF_ALLOWCIP              0x00080000L // Тех сессии по процессору позволяют ассоциировать регистрацию персоналий
#define PRCF_AUTOCREATE            0x00100000L // Для групп процессоров. Если процессоры группы ассоциированы с объектами,
	// то при создании нового объекта автоматически создавать и процессор в этой группе, соответствующий новому объекту.
#define PRCF_HASEXT                0x00200000L // С процессором связана запись расширения в PropertyTbl
#define PRCF_ALLOWCANCELAFTERCLOSE 0x00400000L // Разрешение на перевод сессии в состояние 'ОТМЕНЕНА' из 'ЗАКРЫТА'
#define PRCF_ALLOWREPEATING        0x00800000L // @v11.0.4 Допускается ввод параметров повтора для сессий
#define PRCF_TECHCAPACITYREV       0x01000000L // @v11.3.10 Обратное представление производительности технологий. 
	// То есть, время на одну ед товара, а не количество единиц товара в единицу времени. В базе данных представление остается тем же,
	// но при вводе и выводе на экран - отображается обратная величина.
//
// Флаг передаваемый с дополнительным параметром, и сигнализирующий о том, что
// речь идет о группе процессоров
//
#define PRCEXDF_GROUP  0x80000000L

struct PPProcessorConfig { // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PRCCFG
	long   TecCounter;     // Счетчик для автоматической нумерации технологий
	long   Flags;          //
	char   Reserve[64];    //
};
//
// Descr: Идентификаторы строк расширения блока PPProcessorPacket::Ext
//
#define PRCEXSTR_DETAILDESCR 1 // Подробное описание процессора (технологической сессии)
#define PRCEXSTR_MEMO        2 // @v11.0.4 Примечание к техологической сессии (для процессоров пока не применяется)

class PPProcessorPacket { // @persistent
public:
	PPProcessorPacket();
	PPProcessorPacket & Z();

	struct PlaceDescription {
		PlaceDescription();
		PlaceDescription & Z();

		PPID   GoodsID;    // Товар, ассоциированный с диапазоном мест
		SString Range;
		SString Descr;
	};

	class ExtBlock : private SStrGroup { // @persistent
	public:
		ExtBlock();
		ExtBlock & Z();
		bool   IsEmpty() const;
		bool   IsEq(const ExtBlock & rS) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    GetExtStrData(int fldID, SString & rBuf) const;
		int    PutExtStrData(int fldID, const char * pBuf);
		int    Pack();
		uint   GetPlaceDescriptionCount() const;
		int    GetPlaceDescription(uint pos, PPProcessorPacket::PlaceDescription & rItem) const;
		int    GetPlaceDescriptionByCode(const char * pCode, PPProcessorPacket::PlaceDescription & rItem) const;
		int    PutPlaceDescription(uint pos, const PPProcessorPacket::PlaceDescription * pItem);
		PPID   GetOwnerGuaID() const;
		void   SetOwnerGuaID(PPID id);
		long   GetCipCancelTimeout() const;
		int    SetCipCancelTimeout(long t);
		long   GetCipLockTimeout() const;
		int    SetCipLockTimeout(long t);

		enum {
			tfCheckInRoundForward   = 0x0001,
			tfCheckOutRoundBackward = 0x0002,
			tfPlusOneDay    = 0x0004
		};
		SVerT  Ver;            // Номер версии для обратной совместимости
		LTIME  CheckInTime;
		LTIME  CheckOutTime;
		long   TimeFlags;
		long   InitSessStatus; // Статус, с которым создаются новые сессии процессора. 0 - по умолчанию или наследуется от группы.
	private:
		uint   ExtStrP; // Позиция строки расширения в пуле SStrGroup
		struct FlatBlock {
			FlatBlock();
			FlatBlock & Z();
			bool   FASTCALL IsEq(const FlatBlock & rS) const;

			PPID   OwnerGuaID;       // Глобальная учетная запись, владеющая процессором
			long   CipCancelTimeout; // @#{>=0} Таймаут снятия резерва (секунд).
			long   CipLockTimeout;   // @#{>=0} Таймаут блокировки резерва за заданное количество секунд до начала сессии
			uint8  FbReserve[20];    // @reserve
		} Fb;                    // @anchor
		struct InnerPlaceDescription { // @flat
			PPID   GoodsID;  // Товар, ассоциированный с диапазоном мест
			uint   RangeP;   // Идент строки расширения, определяющий диапазон посадочных мест
			uint   DescrP;   // Идент строки расширения, определяющий описание диапазона мест
		};
		TSVector <InnerPlaceDescription> Places;
	};
	ProcessorTbl::Rec Rec;
	ExtBlock Ext;
	ObjTagList TagL; // @v11.7.2 Список тегов
};
//
//
//
class ProcessorPlaceCodeTemplate {
public:
	static SString & FASTCALL NormalizeCode(SString & rCode);
	ProcessorPlaceCodeTemplate();
	void   Reset();
	int    Parse(const char * pPattern);
	void   Helper_GenerateLevel(int s, const uint32 pCounters[], SString & rBuf) const;
	int    Helper_Generate(int s, int fullRow, uint32 pCounters[], SString & rBuf) const;
	int    Generate(StringSet & rSs) const;
	int    HasCode(const char * pCode) const;
private:
	//
	// D%3[1..90]L%1[A..D]
	// %3[101..500]
	// %1[А..Я]
	//
    // ^.*\%[0-9]+\[.+\.\..+\]
	//
    struct Seq { // @flat
    	char   Prefix[8];
    	uint8  Type; // 0 - none, 1 - digit range, 2 - alpha range
    	uint8  Len;  // Длина результата
    	uint16 Reserve;
    	uint32 Start;
    	uint32 End;
    };
    TSVector <Seq> SeqList;
};

class ProcessorCore : public ProcessorTbl {
public:
	friend class PPTblEnum <ProcessorCore>;

	ProcessorCore();
	SEnum::Imp * Enum(long prcKind, PPID parentID);
	int    InitEnum(long prcKind, PPID parentID, long * pHandle);
	int    NextEnum(long enumHandle, ProcessorTbl::Rec * pRec);
private:
	PPTblEnumList EnumList;
};

class PPObjProcessor : public PPObject {
public:
	static int FASTCALL ReadConfig(PPProcessorConfig *);
	static int EditPrcPlaceItem(PPProcessorPacket::PlaceDescription * pItem);
	explicit PPObjProcessor(void * extraPtr = 0);
	~PPObjProcessor();
	//
	// Descr: Проверяет эквивалентность пакетов rS1 и rS2.
	// ARG(rS1 IN): Ссылка на первый пакет для сравнения
	// ARG(rS2 IN): Ссылка на второй пакет для сравнения
	// ARG(flags IN): @reserved
	// Returns:
	//   true - пакеты rS1 и rS2 эквивалентны (возможно, с учетом флагов flags)
	//   false - пакеты rS1 и rS2 неэквивалентны.
	//
	bool   IsPacketEq(const PPProcessorPacket & rS1, const PPProcessorPacket & rS2, long flags);
	virtual int Search(PPID, void *);
	//
	// Если *pID == 0 && parentID & PRCEXDF_GROUP, то функция создает новую группу
	//
	virtual int Edit(PPID * pID, void * extraPtr /*parentID*/);
	virtual int Browse(void * extraPtr);
	int    EditDialog(PPProcessorPacket * pData);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    Fetch(PPID id, ProcessorTbl::Rec * pRec);
	//
	// Descr: Ищет запись процессора вида kind с именем pName. Если kind == 0,
	//   то сначала ищет процессор (PPPRCK_PROCESSOR), а затем, если не находит, группу (PPPRCK_GROUP).
	//   Поиск нечувствителен к регистру символов.
	// ARG(kind   IN): Вид записи, которую надо найти. Если kind == 0, то функция будет искать
	//   сначала собственно процессоры с указанным именем, а затем группы процессоров.
	// ARG(pName  IN): Имя записи, которую необходимо найти
	// ARG(pID   OUT): @#{vptr0} По этому указателю функция возвращает ИД записи, если такая найдена.
	//   В противном случае по указателю присваивается 0.
	// ARG(pRec  OUT): @#{vptr0} По этому указателю функция возвращает найденную запись, если такая найдена.
	//   В противном случае содержимое памяти по этому указателю не меняется.
	// Returns:
	//   >0 - искомая запись найдена
	//   <0 - запись с указанным видом и наименованием не найдена
	//   0  - ошибка
	//
	int    SearchByName(int kind, const char * pName, PPID * pID, ProcessorTbl::Rec * pRec);
	int    SearchByCode(const char * pCode, PPID * pID, ProcessorTbl::Rec * pRec);
	//
	// Descr: Ищет все процессоры, которые связаны с объектом {objType; objID}
	//   Список rList после завершения функции содержит несортированный список процессоров, ассоциированных с заданным объектом.
	//   Перед исполнением функция очищает список rList.
	// Returns:
	//	 >0 - найден по крайней мере один процессор, связанный с {objType; objID}
	//   <0 - не найдено ни одного связанного с {objType; objID} процессора
	//    0 - ошибка
	//
	int    SearchListByLinkObj(PPID objType, PPID objID, PPIDArray & rList); // @v12.0.1
	int    SearchByLinkObj(PPID objType, PPID objID, PPID * pID, ProcessorTbl::Rec * pRec);
	int    SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	int    PutPacket(PPID * pID, PPProcessorPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPProcessorPacket * pPack);
	int    SerializePacket(int dir, PPProcessorPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    PutExtention(PPID id, PPProcessorPacket::ExtBlock * pExt, int use_ta);
	int    GetExtention(PPID id, PPProcessorPacket::ExtBlock * pExt);
	//
	// Descr: Извлекает запись процессора prcID и заполняет
	//   унаследованные от группы поля и флаги.
	// ARG(prcID    IN): ИД процессора
	// ARG(pRec    OUT): @#{vptr0} указатель на буфер, в который будет скопирвана запись процессора
	// ARG(useCache IN): если !0, то запись извлекается из кэша.
	// Returns:
	//   >0 - запись с идентификатором prcID найдена и скопирована в буфер pRec
	//   <0 - запись с идентификатором prcID не найдена
	//   0  - ошибка
	//
	int    GetRecWithInheritance(PPID prcID, ProcessorTbl::Rec * pRec, int useCache = 0);
	int    GetExtWithInheritance(PPID prcID, PPProcessorPacket::ExtBlock * pExt);
	int    GetParentsList(PPID prcID, PPIDArray * pList);
	//
	// Descr: Возвращает список процессоров, дочерних по отношению к prcID.
	//   Идентификатор prcID в список не заносится.
	//   Если recur != 0, то функция рекурсивная: рекурсивный вызов осуществляется //
	//   для каждого дочернего процессора, имеющего вид PPPRCK_GROUP.
	//   Идентификаторы дочерних процессоров добавляются в список pList
	//   методом addUnique, что исключает попадание в него двух одинаковых
	//   идентификаторов в пределах действия этой фукнкции.
	// ARG(prcID  IN): Идентификатор процессора, для которого необходимо найти список
	//   дочерних процессоров
	// ARG(recur  IN): Если recur != 0, то функция рекурсивно вызывает себя для каждого
	//   потомка группы prcID, который сам является группой. В противном случае функци
	//   возвращает только список прямых потомков группы prcID.
	// ARG(pList OUT): @#{vptr0} Указатель на список, в котороый заносятся идентификаторы
	//   дочерних процессоров
	// Returns:
	//   >0 - процессор prcID имеет непустое множество дочерних процессоров
	//   <0 - процессор prcID не имеет дочерних процессоров
	//   0  - ошибка
	//
	int    GetChildIDList(PPID prcID, int recur, PPIDArray * pList); // @recursion
	int    GetListByOwnerGuaID(PPID guaID, PPIDArray & rList);
	int    GetList(long parentIdent, StrAssocArray & rList);
	//
	// Descr: Выясняет, принадлежит ли процессор prcID переключаемой группе.
	//   Если да, то возвращает >0 и заполняет список pSwitchPrcList идентификаторами
	//   процессоров на которые может быть сделано переключение. В этот список попадет
	//   и prcID.
	// ARG(prcID           IN): Идентификатор процессора, для которого необходимо выяснить
	//   возможность переключения на другие процессоры.
	// ARG(pSwitchPrcList OUT): @#{vptr0} Указатель на массив, в который, в случае утвердительного
	//   ответа будут занесены идентификаторы процессоров между которыми может быть осуществлено
	//   переключение.
	// Returns:
	//   >0 - процессор prcID допускает переключение
	//   <0 - процессор prcID не допускает переключения //
	//   0  - ошибка
	//
	int    IsSwitchable(PPID prcID, PPIDArray * pSwitchPrcList);
private:
	virtual const char * GetNamePtr();
	virtual int DeleteObj(PPID);
	virtual int HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*parentID*/);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    AddListItem(StrAssocArray * pList, ProcessorTbl::Rec * pRec, PPIDArray * pRecurTrace);
		// @recursion @<<PPObjProcessor::MakeStrAssocList(PPID)
	int    SearchAutocreateGroupListByObjGroup(PPID objType, PPID objGroupID, PPIDArray & rList);
	int    AutocreateByObjGroup(PPID linkObjType, PPID linkObjID, const PPIDArray & rGrpIdList, int use_ta);
public:
	TLP_MEMB(ProcessorCore, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewProcessor)
//
struct ProcessorFilt : public PPBaseFilt {
	ProcessorFilt();
	virtual int Init(int fullyDestroy, long extraData);

	char   ReserveStart[24]; // @anchor
	long   Flags;
	PPID   OwnerGuaID;       // Глобальная учетная запись - владелец процессора
	long   Kind;             // PPPRCK_XXX
	PPID   ParentID;
	PPID   LocID;            //
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef ProcessorTbl::Rec ProcessorViewItem;

class PPViewProcessor : public PPView {
public:
	PPViewProcessor();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ProcessorViewItem *);
	int    Transmit(PPID /*id*/);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * GetEditExtraParam();
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    ExportUhtt();

	ProcessorFilt Filt;
	PPObjProcessor PrcObj;
};
//
// @ModuleDecl(PPObjTech)
//
//
// Descr: Класс, управляющий списком товаров, которые могут быть обработаны технологической
//   сессией, использующей заданную технологию.
//
class TGSArray : private SVector, private SStrGroup { // @defined(Tech.cpp)
public:
	TGSArray();
	uint   GetItemsCount() const;
	//
	// Descr: Ищет товар goodsID среди элементов контейнера.
	//   Если исходная структура содержит обобщенные товары, то goodsID ищется также
	//   среди элементов обобщения (в том числе динамического).
	// Returns:
	//   true - товар с идентификатором goodsID найден в контейнере
	//   false - товар с идентификатором goodsID НЕ найден в контейнере
	//
	bool   SearchGoods_(PPID goodsID, int * pSign, SString * pFormula) const;
	//
	// Descr: Возвращает список идентификаторов товаров, включенных в контейнер.
	//   Если встречается обобщенный товар, то вместо него в результирующий список попадают включенные в обобщение товары.
	//   Список pList (если !0) предварительно очищается.
	//
	int    GetGoodsList(PPIDArray * pList) const;
	int    AddItem(PPID goodsID, int sign, const char * pFormula);
	void   SetStrucID(PPID strucID);
	PPID   GetStrucID() const;
	TGSArray & Z();
private:
	struct Item { // @flat
		PPID   GoodsID;
		int16  Sign;
		uint16 Reserve;  // @alignment
		uint   FormulaP; // Индекс позиции формулы элемента структуры
	};
	PPID   GStrucID;
};
//
// Виды записей технологий
//
#define TECK_GENERAL    0 // Обыкновенная технология //
#define TECK_TOOLING    1 // Технология перенастройки
#define TECK_AUTO       2 // Автотехнология (правило автоматического создания) //
#define TECK_FOLDER     3 // @v11.6.2 Папка
//
// Флаги, передаваемые с дополнительным параметром
//
#define TECEXDF_AUTO    0x10000000L // Речь идет о записи автотехнологии
#define TECEXDF_TOOLING 0x20000000L // Речь идет о записи технологии перенастройки
#define TECEXDF_GSTRUC  0x40000000L // Остальная часть параметра - ИД структуры
	// Если ни один из вышеперечисленных флагов не выставлен, то параметр - ИД процессора
#define TECEXDF_GOODS   0x80000000L // Остальная часть параметра - ИД товара
#define TECEXDF_FOLDER  0x04000000L // @v11.6.3 Флаг, используемый для создания технологии верхнего уровня (folder)
#define TECEXDF_PARENT  0x08000000L // Остальная часть параметра - ИД родительской технологии
#define TECEXDF_MASK    0x00ffffffL // @v11.6.3 0x07ffffffL-->0x00ffffffL
//
// Флаги технологий
//
#define TECF_RECOMPLMAINGOODS 0x0001 // Рекомплектация основного товара.
	// Этот флаг работает если операция списания по процессору, к которому относится //
	// технология, является модификацией, и выход основного товара задан по серийному номеру.
	// В этом случае система следит за тем, чтобы в одну сессию не попало более одного
	// серийного номера основного товара со знаком +.
#define TECF_EXTSTRING        0x0002 // Технология содержит строку расширения //
#define TECF_CALCTIMEBYROWS   0x0004 // Для каждой строки сессии извлекается доступная технология //
	// для процессора и время выполнения количества, заданного по строке прибавляется к планируемому времени сессии
#define TECF_AUTOMAIN         0x0008 // Основной товар автоматически вставляется в строки сессии
#define TECF_ABSCAPACITYTIME  0x0010 // Производительность определяет абсолютное время работы процессора (не зависимо от количества обоабатываемой позиции).
#define TECF_RVRSCMAINGOODS   0x0020 // Обратный расчет количества основого товара по заданным в строках сессии компонентам
//
//
//
#define TECEXSTR_TLNGCOND          1 // Формула условия использования технологии перенастройки //
#define TECEXSTR_CAPACITY          2 // Формула производительности для автотехнологий

struct PPTechPacket {
	PPTechPacket();
	TechTbl::Rec Rec;
	SString ExtString;
	SString SMemo; // @v11.1.12
};

class PPObjTech : public PPObject {
public:
	static int   GenerateCode(int kind, SString & rBuf, int use_ta = 1);
	static int   SetupCombo(TDialog *, uint ctlID, PPID id, long olwFlags, PPID prcID, PPID goodsID);
	explicit PPObjTech(void * extraPtr = 0);
	~PPObjTech();
	virtual int Search(PPID, void *);
	virtual int Edit(PPID * pID, void * extraPtr /*parentID*/);
	virtual int Browse(void * extraPtr);
	int    InitPacket(PPTechPacket *, long extraData, int use_ta);
	int    SerializePacket(int dir, PPTechPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	SString & GetItemMemo(PPID id, SString & rBuf); // @v11.1.12
	int    Fetch(PPID id, TechTbl::Rec * pRec);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    SearchByCode(const char * pCode, TechTbl::Rec * pRec);
	int    SearchAnalog(const TechTbl::Rec & rKey, PPID * pID, TechTbl::Rec * pRec);
	int    GetPacket(PPID, PPTechPacket *);
	int    PutPacket(PPID *, PPTechPacket *, int use_ta);
	int    EditDialog(PPTechPacket * pPack);
	int    GetGoodsStruc(PPID id, PPGoodsStruc * pGs); // @>>PPObjGoodsStruc::Get
	int    GetGoodsStrucList(PPID id, int useSubst, PPGoodsStruc * pGs, TGSArray * pList); // @<<PPObjTech::GetGoodsStruc
	int    GetGoodsListByPrc(PPID prcID, PPIDArray * pList);
		// @>>PPObjTech::AddItemsToList
	int    GetListByPrc(PPID prcID, PPIDArray * pList);
	int    GetListByPrcGoods(PPID prcID, PPID goodsID, PPIDArray * pList);
	int    GetListByGoods(PPID goodsID, PPIDArray * pList);
	int    GetListByGoodsStruc(PPID goodsStrucID, PPIDArray * pList); // @v11.7.6
	int    GetToolingCondition(PPID id, SString & rFormula);
	int    SelectTooling(PPID prcID, PPID goodsID, PPID prevGoodsID, TSVector <TechTbl::Rec> * pList);
	int    CreateAutoTech(PPID prcID, PPID goodsID, PPID * pTechID, int use_ta);
	int    SearchAutoForGoodsCreation(PPID prcID, PPID * pGoodsGrpID);
	int    ChangeOrderN(PPID techID, int sow, int use_ta);
	int    IsChildOf(PPID techID, PPID parentID);
	//
	// Descr: Возвращает список технологий, прямым родителем для которых является технология techID.
	//
	int    GetChildList(PPID techID, PPIDArray & rList);
	//
	// Descr: Возвращает список технологий, которые унаследованы от родителя techID и являются терминальными (то есть, не имеют дочерних технологий)
	//
	int    GetTerminalChildList(PPID techID, PPIDArray & rList);
	int    GetNextSibling(PPID parentID, PPID siblingID, TechTbl::Rec * pNextRec);
private:
	virtual const char * GetNamePtr();
	virtual int DeleteObj(PPID);
	virtual int HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    Helper_AddItemToList(StrAssocArray * pList, PPID techID, PPID parentID, const char * pCode, LongArray & rRecurList);
	int    Helper_GetTerminalChildList(PPID techID, PPIDArray & rList, LongArray & rRecurList);
	int    AddItemsToList(StrAssocArray *, PPIDArray * pIdList, PPIDArray * pGoodsIdList, long extraParam, PPID goodsID = 0);
		// @<<PPObjTech::MakeList_
	int    SearchAuto(PPID prcID, PPID goodsID, PPID * pTechID);
public:
	TLP_MEMB(TechTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewTech)
//
struct TechFilt : public PPBaseFilt {
	enum {
		signAll = 0,
		signMinusOnly,
		signPlusOnly,
		signUsageOnly
	};
	TechFilt();

	char   ReserveStart[32]; // @anchor
	PPID   ParentID;
	PPID   PrcID;
	PPID   GoodsID;
	PPID   GStrucID;
	long   Kind;
	long   Sign;             // TechFilt::signXXX
	long   Flags;            // TechFilt::fXXX
	long   Reserve;          // @anchor
};

typedef TechTbl::Rec TechViewItem;

class PPViewTech : public PPView {
public:
	PPViewTech();
	const  TechFilt * GetFilt() const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(TechViewItem *);
	//int    ChangeFilt(int refreshOnly, BrowserWindow * pW);
	int    Transmit(PPID /*id*/);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * GetEditExtraParam();

	TechFilt Filt;
	PPObjTech TecObj;
	PPObjProcessor PrcObj;
	PPObjGoods GObj;
};
//
// @ModuleDecl(PPObjTSession)
//
// Descr: Список процессоров (групп процессоров) ранжированных в том порядке, в котором должно
//   быть реализовано списание технологических сессий по этим процессорам.
// Storage: DB/Property(PPOBJ_TSESSION, 0, TSESPRP_WROFFORDER)
//
class TSessWrOffOrder : public ObjRestrictArray { // @persistent
public:
	TSessWrOffOrder();
	TSessWrOffOrder & FASTCALL operator = (const TSessWrOffOrder &);
	//
	// Descr: Упорядочивает список сессий pSrcList в соответствии с порядком списания //
	// Returns:
	//   >0 - список pDestList явялется упорядоченной версией списка pSrcList. Причем
	//      pDestList отличается от pSrcList
	//   <0 - список pDestList не отличается от списка pSrcList
	//   0  - ошибка
	//
	int    ArrangeTSessList(const PPIDArray * pSrcList, PPIDArray * pDestList) const;

	int    IsLoaded;
private:
	struct ArrngItem {
		PPID   SessID;
		PPID   PrcID;
		LDATE  Dt;
	};
	int    GetPos(PPObjProcessor * pPrcObj, PPID prcID, uint * pPos) const;
	int    CompareProcessors(PPObjProcessor * pPrcObj, PPID prc1ID, PPID prc2ID) const;
	void   ShortSort(SArray * pPrcList) const;
};

struct PPTSessConfig { // @persistent @store(PropertyTbl)
	PPTSessConfig();
	DECL_INVARIANT_C();

	enum {
		fUpdateTimeOnStatus = 0x0001, // При изменении статуса сессии на TSESST_INPROCESS или TSESST_CLOSED
			// изменять дату и время, соответственно, начала и конца сессии на текущую
		fUsePricing          = 0x0002, // Использовать цены в техн сессиях
		fAllowLinesInPendingSessions = 0x0004, // Разрешать ввод строк в ожидающих сессиях (TSESST_PLANNED, TSESST_PENDING)
		fAllowLinesInWrOffSessions   = 0x0008, // Разрешать ввод строк в списанных сессиях
		fSnapInTimeChunkBrowser      = 0x0010, // Во временной диаграмме при щелчке мышью время отмерять с округлением до ближайшего кванта
		fUpdLinesByAutocompl = 0x0020, // При автозаполнении строк сессии по структуре изменять количество в строках, которые были введены в ручную
		fFreeGoodsSelection  = 0x0040, // Свободный выбор товаров в строках сессии
		fSetupCcPricesInCPane        = 0x0080  // При формировании кассового чека по сессии
			// цены устанавливаются через механизмы кассовой панели (цена строки в техсессии игнорируется)
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_TSESSCFG
	long   Flags;           // PPTSessConfig::fXXX
	PPID   IdleAccSheetID;  // ->Ref(PPOBJ_ACCSHEET) Таблица статей видов простоев процессоров
	long   MinIdleCont;     // Минимальная продолжительность простоя (sec). Если простой меньше,
		// этой величины, то он не регистрируется (сессия простоя удаляется).
	LTIME  InitTime;        // Время, задаваемое в новых техн сессиях по умолчанию. Используется //
		// также как расчетное время для сессий, учитывающих товар по времени (гостиницы)
	long   RoundPeriod;     // Период округления (в большую сторону) для сессий, учитывающих
		// товар по времени
	long   ViewRefreshPeriod;     // Период обновления таблиц техн сессий и строк техн сессий (sec)
	long   TimeChunkBrowserQuant; // Квант времени (сек) во временной диаграмме
	long   ColorPlannedStatus;
	long   ColorPendingStatus;
	long   ColorInProgressStatus;
	long   ColorClosedStatus;
	long   ColorCanceledStatus;
	SVerT Ver;
	PPID   DefTimeTechID;      // Технология по умолчанию для повременных сессий
	char   Reserve[16];        // @vmiller [24] --> [20]
	PPAutoSmsConfig SmsConfig; // @vmiller
};

//
// Виды технологических сессий
//
#define TSESK_SESSION   0 // Обыкновенная техн сессия  //
#define TSESK_SUPERSESS 1 // Суперсессия               //
#define TSESK_PLAN      2 // Производственный план     //
#define TSESK_IDLE      3 // Сессия простоя процессора //
#define TSESK_SUBSESS   4 // Сессия, являющаяся дочерней по отношению к обыкновенной сессии A по причине,
	// принадлежности к технологии, дочерней, по отношению к технологии, с которой связана сессия A.
//
// Статусы технологических сессий
//
#define TSESST_PLANNED         1  // Планируемая //
#define TSESST_PENDING         2  // В ожидании  //
#define TSESST_INPROCESS       3  // В работе    //
#define TSESST_CLOSED          4  // Закрытая    //
#define TSESST_CANCELED        5  // Отмененная  //
//
// Флаги технологических сессий
//
#define TSESF_WRITEDOFF    0x0001L // Сессия списана
#define TSESF_SUPERSESS    0x0002L // Суперсессия (объединяет несколько обыкновенных сессий)
#define TSESF_IDLE         0x0004L // Простой процессора
#define TSESF_PLAN         0x0008L // Произодственный план
	// 		Система следит за недопущением пересечений сессий производственных планов для одного
	// процессора (группы процессоров), однако пересечения производственных планов с обычными
	// сессиями и сессиями простоев естественны.
	// 		Производственный план не обязан быть привязан к технологии. С другой стороны, привязка к
	// виртуальной технологии, обеспечивающей список позиций, допустима и, вероятно, полезна.
	// 		Производственные планы задаются с точностью до дня, по этому, поля времени начала и
	// окончания в диалоге плана опускаются.
#define TSESF_PLAN_PHUNIT  0x0010L // Производственный план в физических единицах
	// Если этот флаг установлен, то новая строка по умолчанию получает признак TSESLF_PLAN_PHUNIT.
	// Пользоватлеь может переопределить этот признак для строки.
#define TSESF_SUBSESS      0x0020L //
#define TSESF_HASIMAGES    0x0040L // Сессия имеет по крайней мере одно прикрепленное изображение
#define TSESF_CIPREGLOCKED 0x0080L // Резервирование персональных регистраций блокировано
//
// Флаги строк технологических сессий
//
#define TSESLF_AUTOCOMPL   0x0001L // Строка сформирована автоматически процедурой PPObjTSession::Complete
#define TSESLF_OUTREST     0x0002L // Строка исходящих остатков по сессии
#define TSESLF_FIXEDREST   0x0004L // Пользователь зафиксировал значение остатка по товару
	// (автоматическое изменение недопустимо)
#define TSESLF_AUTOMAIN    0x0008L // Строка сформирована автоматически по основному товару сессии,
	// единица измерения которого является производной от секунды.
	// @v6.4.4 Либо по основному товару, если технология предусматривает его автоматическую вставку в строки.
#define TSESLF_EXPANDSESS  0x0010L // @transient Функция PPObjTSession::PutLine должна изменить время //
	// окончания сессии, если оно меньше времени, которым помечена строка. При этом время строки становится   //
	// временем окончания сессии.
#define TSESLF_REST        0x0020L // Строка остатка серийного номера по сессии. Используется в том случае,
	// если в процессе производства удобнее посчитать остаток некоторой позиции, чем фактически израсходованное
	// количество. При вводе строки остатка система проверяет, чтобы в течении сессии был расход указанного
	// серийного номера. Если так, то одновременно с вводом этой строки, из строки, с указанным серийным номером
	// вычитается количество остатка. При этом возможность модификации основной строки блокируется.
#define TSESLF_INDEPPHQTTY 0x0040L // Строка учитывает физическое количество товара независимо от
	// торгового. Этот флаг устанавливается функцией PPObjTSession::SetupLineGoods в соответствии с флагом GF_USEINDEPWT
#define TSESLF_RECOMPL     0x0080L // Строка с основным товаром технологии, подлежащая рекомплектации
	// при списании. Этот флаг предполагает, что в строке установлен серийный номер, товар является основным
	// товаром технологии и знак операции +.
#define TSESLF_PLAN_PHUNIT 0x0100L // Производственный план в физических единицах
#define TSESLF_TOOLING     0x0200L // Флаг используется в комбинации с TSESLF_AUTOCOMPL. Если установлен, то
	// строка сформирована автоматически как издержки на перенастройку.
//
// Допустимые переходы состояний сессий:
// Проверку допустимости переходов реализует функция PPObjTSession::SetSessionState()
//
// 0 -> TSESST_PLANNED
// 0 -> TSESST_PENDING
// 0 -> TSESST_INPROCESS
//
// TSESST_PLANNED -> TSESST_PENDING
// TSESST_PLANNED -> TSESST_INPROCESS   Устанавливается время начала сессии
// TSESST_PLANNED -> TSESST_CANCELED
//
// TSESST_PENDING -> TSESST_INPROCESS   Устанавливается время начала сессии
// TSESST_PENDING -> TSESST_CANCELED
//
// TSESST_INPROCESS -> TSESST_CLOSED    Устанавливается время окончания сессии и уровень завершенности в 10
//
// TSESST_CLOSED   переходы недопустимы
// TSESST_CANCELED переходы недопустимы
//
//
// Специфические флаги доступа PPObjTSession (в дополнение к общим PPR_XXX)
//
#define TSESRT_ADDLINE       0x0100 // Добавление строк сессий (в панели процессора не действует)
#define TSESRT_MODLINE       0x0200 // Изменение строк сессий
#define TSESRT_DELLINE       0x0400 // Удаление строк сессий
#define TSESRT_MODPRICE      0x0800 // Изменение цены (скидки) в строке сессии
#define TSESRT_CLOSEWOCC     0x1000 // Закрытие тех сессии без кассового чека
//
// Descr: Запись BHT-терминала, для учета операций по техн сессиям
//   Используется функцией PPObjTSession::ProcessBhtRec
//
struct BhtTSessRec {
	char   BillCode[16];
	char   PrcCode[16];
	char   ArCode[16];
	char   Barcode[32];
	double Qtty;
	LDATETIME Dtm;
};
//
//
//
class TSessionPacket : public ObjTagContainerHelper {
public:
	TSessionPacket();
	TSessionPacket(const TSessionPacket & rS);
	TSessionPacket & FASTCALL operator = (const TSessionPacket & rS);
	TSessionPacket & Z();
	int    GetTimeRange(STimeChunk & rRange) const;

	enum {
		fLinesInited = 0x0001 // Пакет содержит валидный список строк Lines. Как правило, управление строками
			// отделено от управления заголовочной записью. Но при сериализации для обмена между разделами
			// пакет содержит полный список строк.
	};
	long   Flags;
	TSessionTbl::Rec Rec;
	PPCheckInPersonArray CiList;
	TSVector <TSessLineTbl::Rec> Lines;
	ObjTagList TagL;        // Список тегов
	ObjLinkFiles LinkFiles; //
	PPProcessorPacket::ExtBlock Ext; // Некоторые параметры процессора могут быть переопределены в этом блоке.
		// Кроме того, здесь же хранится подробное описание сессии.
	//SString SMemo; // @v11.0.4 (replacement of TSessionTbl::Rec::Memo)
	double OuterTimingPrice; // @v11.7.6 @transient Цена временной сессии, передаваемая из внешнего источника.
		// Используется для форсированной установки цены в автомитически формируемых временных строках.
};
//
//
//
class PPObjTSession : public PPObject {
public:
	struct SelFilt {
		PPID   SuperSessID;
		PPID   PrcID;
		int    Kind; // TSESK_XXX (0 - any sessions, 1 - super sessions only, 2 - plans, 3 - idle)
	};
	struct WrOffAttrib {
		PPID   ArID;
		PPID   Ar2ID;
		PPID   AgentID; // ->Article.ID
		PPID   SCardID;
	};
	static int  FASTCALL ReadConfig(PPTSessConfig *);
	static int  FASTCALL WriteConfig(PPTSessConfig *, int use_ta); // @vmiller
	static int  EditConfig();
	static int  FASTCALL ValidateStatus(int status);
	static int  FASTCALL ResolveStatusSymbol(const char *);
	static int  FASTCALL GetStatusSymbol(int status, SString & rBuf);
	//
	// Descr: Возвращает вид сессии pRec.
	//   Возвращаемое значение - одно из TSESK_XXX.
	//   Если superSessAsSimple, то для суперсессий возвращет TSESK_SESSION
	//
	static int    FASTCALL GetSessionKind(const TSessionTbl::Rec & rRec, int superSessAsSimple = 1);
	static int    GetTimeRange(const TSessionTbl::Rec & rRec, STimeChunk & rRange);
	static void * FASTCALL MakeExtraParam(PPID superSessID, PPID prcID, int kind);
	static int    ConvertExtraParam(void * extraPtr, SelFilt * pFilt);
	//
	// Descr: Возвращает продолжительность сессии pRec в секундах.
	//   Если дата начала или конца сессии являются нулевыми, то возвращает 0.
	//
	static long GetContinuation(const TSessionTbl::Rec * pRec);
	//
	// Descr: Определяет, является сессия pRec незначительным простоем. Если сессия //
	//   является сессией простоя, ее длительнось определена и меньше или равна минимальной
	//   продолжительности простоя, определенной в конфигурации, то возвращает >0.
	//   В противном случае, возвращает 0.
	//
	static int  IsIdleInsignificant(const TSessionTbl::Rec * pRec, int prevStatus);
	//
	// Descr: Реализует полный цикл редактирования порядка списания технологических сессий.
	//   То есть, 1. создает объект TSessWrOffOrder; 2. извлекает его из базы данных;
	//   3. вызывает диалог редактирования; 4. если пользователь подтвердил редактирование,
	//   то сохраняет объект TSessWrOffOrder в базе данных.
	// Returns:
	//   >0 - пользователь подтвердил редактирование порядка списания техн сессий
	//   <0 - пользователь отказался от редактирования //
	//   0  - ошибка
	//
	static int  EditWrOffOrder(); // @<<(cmd)cmTSessWrOffOrder
	explicit PPObjTSession(void * extraPtr = 0);
	~PPObjTSession();
	virtual int Search(PPID id, void *);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int Browse(void * extraPtr);
	virtual int EditRights(uint bufSize, ObjRights * pRt, EmbedDialog * pDlg);
	const  PPTSessConfig & GetConfig();
	int    SearchAnalog(const TSessionTbl::Rec & rKey, PPID * pID, TSessionTbl::Rec * pRec);
	int    SearchByGuid(const S_GUID_Base & rUuid, TSessionTbl::Rec * pRec);
	//
	// Descr: Ищет сессию, закончившуюся непосредственно перед rSessRec.ID
	//
	int    GetPrevSession(const TSessionTbl::Rec & rSessRec, TSessionTbl::Rec * pPrevRec);
	int    SearchByLinkBillID(PPID linkBillID, TSessionTbl::Rec * pRec);
	//
	// Descr: Флаги функции CheckForFilt
	//
	enum {
		cfffDraft = 0x0001 // Проверять только те критерии, время обработки которых не сильно влияют на скорость.
	};

	int    CheckForFilt(const TSessionFilt * pFilt, PPID id, const TSessionTbl::Rec * pRec, long flags = 0);
	//
	// Descr: Находит список идентификаторов сессий, строки которых содержат хотя бы один товар из
	//   списка rGoodsIdList.
	//   Если аргумент pDraftTSessIdList != 0, то анализируются только те сессии, которые входят в этот список.
	//
	int    GetListByGoodsInLines(const PPIDArray & rGoodsIdList, const PPIDArray * pDraftTSessIdList, PPIDArray & rList);
	int    GetTech(PPID tecID, TechTbl::Rec *, int useCache = 0); // @>>PPObjTech::Search
	int    GetTechByGoods(PPID goodsID, PPID prcID, TechTbl::Rec * pTechRec);
	//
	// Descr: Возвращает !0 если технология pTechRec является повременной, то есть
	//   единица измерения товара, соответствующего сессии имеет базой секунду.
	//   Если технология повременная, то по указателю pBaseRatio возвращается //
	//   значение коэффициента пересчета секунд в единицу измерения товара (напр. 60 для минут).
	// Returns:
	//   >0 - технология повременная.
	//   <0 - технология не является повременной.
	//   0  - ошибка (если не найден товар, соответствующий технологии либо не найдена единица
	//     измерения, соответствующая товару).
	//
	int    IsTimingTech(const TechTbl::Rec * pTechRec, double * pBaseRatio);
	int    IsTimingSess(const TSessionTbl::Rec * pRec, long * pTiming, double * pQtty); // @v11.7.6
	int    CheckPossibilityToInsertLine(const TSessionTbl::Rec & rSessRec);
	int    AdjustTiming(const TSessionTbl::Rec & rSessRec, const STimeChunk & rChunk, STimeChunk & rResult, long * pTiming);
	int    GetPrc(PPID prcID, ProcessorTbl::Rec *, int withInheritance, int useCache = 0);
	int    GetPrcByCode(const char * pPrcCode, ProcessorTbl::Rec *);
	int    IsPrcSwitchable(PPID prcID, PPIDArray * pSwitchPrcList);
	int    GetStatusText(int statusId, SString & rBuf) const;
	int    MakeName(const TSessionTbl::Rec * pRec, SString & rName);
	SString & MakeListName(const PPIDArray * pList, SString & rBuf);
	int    SetSessionState(TSessionTbl::Rec *, int newState, int checkOnly);
		// @>>PPObjTSession::Helper_SetSessionState
	//
	// Descr: Рассчитывает плановое время выполнения сессии исходя из значения //
	//   pRec->PlannedQtty и технологии (pRec->TechID). Рассчитанное время заносится в
	//   поле pRec->PlannedTiming.
	//   Если технология предполагает аддитивность планового времени строк сессии (TECF_CALCTIMEBYROWS),
	//   то для каждой строки сессии функция пытается вычислить ожидаемое время выполнения //
	//   (исходя из первой найденной технологии, соответствующей процессору pRec->PrcID и товару,
	//   к которому привязана строка).
	//
	int    SetPlannedTiming(TSessionTbl::Rec * pRec);
	int    CalcPlannedTiming(PPID techID, double qtty, int useRounding, long * pTiming);
	int    CalcToolingTiming(const TSessionTbl::Rec * pRec, long * pTiming);
	int    CalcPlannedQtty(const TSessionTbl::Rec * pPack, long forceTiming, double * pQtty);
	int    RoundTiming(PPID techID, long * pTiming);
	int    SetSCardID(TSessionTbl::Rec * pRec, const SCardTbl::Rec * pSCardRec);
	int    InitRec(TSessionTbl::Rec *, int kind /* TSESK_XXX */, PPID prcID, PPID superSessID, int status = -1);
	int    InitPacket(TSessionPacket *, int kind /* TSESK_XXX */, PPID prcID, PPID superSessID, int status = -1);
	//
	// Descr: Опции функции PPObjTSession::NormalizePacket
	//
	enum {
		npoDBX = 0x0001 // Нормализация для передачи между резделами.
	};
	//
	// Descr: Гарантированно нормализует некоторые избыточные компоненты пакета.
	//
	int    NormalizePacket(TSessionPacket * pPack, long options);
	int    Add(PPID * pID, PPID superSessID, PPID prcID, int kind, int status = 0);
	//
	// Descr: Инициализирует строку техн сессии
	//   Прежде всего, находит техн сессию sessID. Если сессия найдена, то
	//   устанавливает следующие поля: TSessID, UserID, Dt, Tm.
	//   Если сессия не найдена, то возвращает полностью обнуленную запись.
	// Returns:
	//   >0 - сессия sessID найдена, поля - инициализированы
	//   <0 - сессия sessID не найдена. Запись полностью состоит из нулей.
	//
	int    InitLinePacket(TSessLineTbl::Rec *, PPID sessID);
	int    PutLine(PPID sessID, long * pOprNo, TSessLineTbl::Rec * pLineRec, int use_ta);
	int    Correct(PPID sessID, int use_ta);
	//
	// Descr: добавляет в сессию sessID строки, соответствующие товарам, для которых в структуре
	//   основного товара сессии установлен признак GSF_AUTOWROFF. Строка добавляется только в том случае,
	//   если в сессии не обнаружено ни одной строки, содержащей этот товар
	//   (не применяется учет этого товара по факту и не была применена эта функция ранее).
	//   Строки, добавленные этой функцией получают признак TSESLF_AUTOCOMPL.
	//   Количество рассчитывается исходя из общего количества овновного товара, использованного в сессии.
	//   Перед вставкой новых строк удаляются все строки, имеющие флаг TSESLF_AUTOCOMPL.
	//   Если sessID является суперсессией, то рекурсивно вызывает себя для каждой дочерней сессии.
	// Returns:
	//   <0 - не было добавлено ни одной новой строки
	//   >0 - была добавлена по крайней мере одна строка
	//   0  - ошибка
	// @nointeract
	//
	int    CompleteSession(PPID sessID, int use_ta);
	int    RecalcSessionPacket(TSessionPacket & rPack, LongArray * pUpdRowIdxList);
	//
	// Descr: Заменяет товар replacedGoodsID в приходных строках сессии sessID на товар substGoodsID.
	//   Замещаются только строки, имеющие знак +1 (Sign == 1)
	// ARG(sessID          IN): Идентификатор сессии, в строках которой необходимо заменить товар
	// ARG(replacedGoodsID IN): ИД товара, который будет замещаться функцией
	// ARG(substGoodsID    IN): ИД товара, который встанет на место replacedGoodsID в соответствующих строках сессии
	// ARG(flags           IN):
	//   0x0001 - ничего не менять, но лишь вернуть значение, соответствующее спецификации. Этот флаг
	//     используется для того, чтобы определить необходимость вызова этой функции с целью настоящей замены.
	// ARG(use_ta          IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 - функция изменила как минимум одну строку сессии sessID. Если flags & 0x0001, то ничего не изменилось,
	//        однако, есть строки, которые следует изменить.
	//   <0 - функция отработала без ошибок, но ни одной приходной строки с товаром replacedGoodsID не обнаружила.
	//      Соответственно ничего не изменилось.
	//   0  - ошибка
	//
	int    ReplaceGoodsInLines(PPID sessID, PPID replacedGoodsID, PPID substGoodsID, long flags, int use_ta);
	int    IsProcessorBusy(PPID prcID, PPID tsesID, int kind, const LDATETIME & dtm, long cont, PPID * pTSessID);
	//
	// Descr: Проверяет возможность переноса сессии с процессора pRec->PrcID на newPrcID.
	//   Проверяет только совместимость технологии. Не проверяет доступность процессора newPrcID
	//   по времени (для этого следует использовать функцию PPObjTSession::CheckSessionTime()
	// Returns:
	//   >0 - сессию можно перенести на процессор newPrcID
	//   <0 - сессия не межет быть перенесена на процессор newPrcID
	//   0  - ошибка
	//
	int    CheckNewPrc(const TSessionTbl::Rec * pRec, PPID newPrcID);
	int    FASTCALL CheckSessionTime(const TSessionTbl::Rec & rRec);
	//
	// Descr: проверяет, нет ли работающих сессий на процессоре prcID. Если да,
	//   то инициализирует код ошибки PPERR_PRCISBUSY.
	// ARG(prcID     IN): ИД процессора, для которого необходимо выяснить факт занятости
	// ARG(kind      IN): @#{TSESK_SESSION | TSESK_PLAN | TSESK_IDLE}
	//   Параметр, определяющий вид работающей сессии, которую надо проверить.
	//   Обычные сессии могут пересекаться с простоями и сессиями плана.
	// ARG(pSessRec OUT): @#{vptr0} Если для процессора существует сессия со статусом TSESST_INPROCESS
	//   то по этому указателю копируется запись этой сессии. В противном случае состояние памяти по
	//   этому указателю остается неизменным.
	// Returns:
	//   >0 - на процессоре выполняется сессия //
	//   <0 - на процессоре нет выполняемых сессий
	//    0 - error
	//
	int    IsProcessorInProcess(PPID prcID, int kind, TSessionTbl::Rec * pSessRec);
	int    GetCode(const TSessionTbl::Rec *, long flags, char * pBuf, size_t bufLen);
	int    GetCode(PPID sessID, long flags, char * pBuf, size_t bufLen);
		// @>>PPObjTSession::GetCode(const TSessionTbl::Rec *, long, char*, bufLen)
	//
	// Descr: Проверяет запись pRec на возможность присваивания ее суперсесси superSessID
	//   Проверяются следующие условия:
	//   1. Суперсессию нельзя делать дочерней сессей (присваивать ей ссылку на суперсессию)
	//      PPERR_CHILDCANTBESUPERSESS
	//   2. Нельзя переприсваивать закрытую или отмененную сессию другой суперсессии
	//      PPERR_INVCHILDTSESSSTATUS
	//   3. Запись по идентификатору superSessID должна существовать
	//   4. Запись суперсессии должна иметь признак TSESF_SUPERSESS
	//      PPERR_PARENTISNTSUPERSESS
	//   5. Закрытой или отмененной суперсессии нельзя присваивать дочернюю сессию
	//      PPERR_INVSUPERSESSSTATUS
	//   6. Суперсессия должна быть привязана либо к тому же процессору, что и
	//      проверяемая сессия, либо процессор суперсессии должен быть группой, к которой
	//      принадлежит процессор проверяемой сессии.
	//      PPERR_INCOMPSUPERSESSPRC
	//   7. Время начала дочерней сессии должно быть больше или равно времени начала суперсессии
	//      PPERR_CHILDOLDERSUPERSESS
	// ARG(pRec           IN): указатель на проверяемую запись
	// ARG(superSessID    IN): ИД суперсессии, которой предполагается присвоить запись pRec
	// ARG(pSuperSessRec OUT): @#{vptr0} указатель на буфер, в который будет скопирована запись суперсессии
	//   Копирование осуществляется сразу после успешного нахождения записи
	//   по идентификатору superSessID независимо от дальнейших проверок.
	// Returns:
	//   !0 - все проверки завершились успешно или superSessID == 0
	//   0  - ошибка
	//
	int    CheckSuperSessLink(const TSessionTbl::Rec * pRec, PPID superSessID, TSessionTbl::Rec * pSuperSessRec);
	//
	// Descr: проецирует некоторые параметры суперсессии на запись сессии pRec,
	//   если поле pRec->ParentID != 0. Проецируются следующие параметры: StDt, StTm, ArID
	// Returns:
	//   >0 - запись pRec была изменена (спроецировался один или более параметров)
	//   -1 - запись pRec относится к суперсессии, но ни один из параметров спроецирован не был
	//   -2 - запись pRec не содержит ссылки на суперсессию
	//
	int    InductSuperSess(TSessionTbl::Rec * pRec);
	//
	// Descr: Вспомогательная функция определяющая цену товара goodsID, применяемую для строки сессии.
	//
	int    GetGoodsPrice(PPID goodsID, PPID locID, PPID scardID, PPObjTSession::WrOffAttrib * pWrOffAttr, double outerPrice, double * pPrice, double * pDiscount);
	//
	// Descr: инициализирует поле GoodsID строки техн сессии.
	//   Пытается определить знак операции и, если операция выхода, то
	//   присваивает строке уникальный серийный номер.
	//
	int    SetupLineGoods(TSessLineTbl::Rec *, PPID goodsID, const char * pSerial, long);
	int    EvaluateLineQuantity(PPID sessID, PPID techID, const TSessLineTbl::Rec * pRec, double * pResult);
	int    GenerateSerial(TSessLineTbl::Rec *);
	int    GetGoodsStruc(PPID id, PPGoodsStruc * pGs);
		// @>>PPObjTech::GetGoodsStruc
	int    GetGoodsStrucList(PPID id, int useSubst, PPGoodsStruc * pGs, TGSArray * pList);
		// @>>PPObjTech::GetGoodsStrucList(TSession(id).TechID, useSubst, pList)
	struct SelectBySerialParam {
		SelectBySerialParam(PPID sessID, const char * pSerial);

		char   Serial[32]; // IN
		PPID   InTSesID;   // IN  Сессия, для которой запрашивается выбор по коду
		PPID   LocID;      // IN  Склад, для которого запрашивается выбор по коду. Это поле используется //
			// только в том случае, если InTSesID == 0.
		int16  CodeType;   // OUT {1 - goods code, 2 - serial code by lot, 3 - serial code by TSessLine}
		uint16 Reserve;    // @alignment
		PPID   OutTSesID;  // OUT Сессия, создавшая код Serial (CodeType == 3)
		PPID   GoodsID;    // OUT Товар, соответствующий коду Serial
		PPID   LotID;      // OUT Лот, соответствующий коду Serial (CodeType == 2)
		double Qtty;       // OUT Количество, доступное по коду Serial (CodeType == 2 || CodeType == 3)
	};
	//
	// Descr: Идентифицирует товарную позицию по серийному номеру. В качестве параметра
	//   получает указатель на структуру PPObjTSession::SelectBySerialParam.
	//   Если серийный номер идентифицирован, то проверяет, чтобы сессия pParam->InTSessID
	//   еще не расходовала указанный серийный номер. Если сессия расходовала этот серийный
	//   номер, то возвращает 2.
	// Returns:
	//   <0 - серийный номер не идентифицирован
	//   1  - серийный номер идентифицирован
	//   2  - серийный номер идентифицирован, но сессия pParam->InTSessID уже содержит строку,
	//        расходующую этот серийный номер.
	//   0  - ошибка
	//
	int    SelectBySerial(SelectBySerialParam * pParam);
	struct SerialByGoodsListItem { // @flat
		PPID   LotID;
		PPID   TSessID;
		double Qtty;
		char   Serial[32];
		char   Text[48];
	};
	int    GetSerialListByGoodsID(PPID goodsID, PPID locID, SVector * pList);
	int    SelectSerialByGoods(PPID goodsID, PPID locID, SerialByGoodsListItem * pItem);
	int    GetTagList(PPID id, ObjTagList * pTagList);
	int    SetTagList(PPID id, const ObjTagList * pTagList, int use_ta);
	int    PutExtention(PPID id, PPProcessorPacket::ExtBlock * pExt, int use_ta);
	int    GetExtention(PPID id, PPProcessorPacket::ExtBlock * pExt);
	SString & GetItemMemo(PPID id, SString & rBuf);
	//
	// Descr: Опции функции PPObjTSession::GetPacket
	//
	enum {
		gpoLoadLines = 0x0001 // Загружать строки сессии в пакет
	};
	int    GetPacket(PPID id, TSessionPacket * pPack, long options);
	int    PutPacket(PPID * pID, TSessionPacket * pPack, int use_ta);
	int    PutRec(PPID * pID, TSessionTbl::Rec *, int use_ta);
	int    EditLine(PPID tsesID, long * pOprNo, PPID goodsID, const char * pSerial, double initQtty);
	//
	// Descr: Открывает диалог редактирования записи pRec.
	//   Редактирование записи может сопряжено со специальным случаем, когда
	//   во время редактирования запись обновляется (сохраняется) в базе данных.
	//   Такой случай наступает при следующих обстоятельствах:
	//   1. Пользователь открыл таблицу редактирования строк сессии
	//   2. Пользователь выбрал из диалога режим редактирования кассового чека
	//   При этом, если пользователь в конце концев нажал [Отмена], запись
	//   осталась сохраненной. Функция в этом случае возвращает 2.
	// Returns:
	//   <0 - пользователь отменил редактирование записи
	//   1  - пользователь подтвердил редактирование записи
	//   2  - пользователь отменил редактирование записи, но она была сохранена в базе
	//        данных во время сеанса редакрирования.
	//        Поле pRec->ID содержит идентификатор сохраненной записи.
	//
	int    EditDialog(TSessionPacket * pRec);
	int    EditNewIdleSession(PPID prcID, PPID curSessID, PPID * pSessID);
	int    EditLineDialog(TSessLineTbl::Rec *, int asPlanLine);
	//
	// Descr: Интерфейсная функция, обеспечивающая обработку записей с BHT-терминала.
	// ARG(signal IN):
	//   1 - начало процесса обработки данных. pRec инициализирована первой записью потока.
	//   0 - продолжение процесса обработки данных. pRec инициализирована очередной записью потока.
	//   2 - штатное завершение процесса обработки данных.  pRec не инициализирована.
	//  -1 - нештатное (по ошибке) завершение процесса обработки данных. pRec не инициализирована.
	//
	int    ProcessBhtRec(int signal, const BhtTSessRec * pRec, PPLogger * pLogger, int use_ta);
	int    GetLabelInfo(PPID tsesID, long oprNo, PPID * pPrnID, RetailGoodsInfo *);
	//
	// Descr: Печатает этикетку по строке {tsesID, oprNo}. Если silent == 0, то перед
	//   печатью выдает на экран диалог, в котором можно указать параметры печати.
	//   Если numCopies > 0, то печатает numCopies экземпляров этикеток, в противном
	//   случае берет количество копий из записи процессора (если silent == 0, то
	//   количество экземпляров определяется пользователем).
	//
	int    PrintBarLabel(PPID tsesID, long oprNo, int numCopies, int silent = 0);
		// @>>PPObjTSession::GetLabelInfo, BarcodeLabelPrinter::PrintGoodsLabel
	//
	// Descr: Списывает сессии, список которых представлен в параметре pSessList.
	//   Если в список входят суперсессии, то списываются обычные сессии, являющиеся членами
	//   этих суперсессий.
	//   Перед списанием окночательный список сессий упорядочевается по дате и по приоритету,
	//   определяемому порядком списания сессий.
	//
	int    WriteOff(const PPIDArray * pSessList, PUGL * pDfctList, int use_ta);
	int    UndoWritingOff(PPID sessID, int use_ta);
	//
	// Descr: Создает рабочую сессию по процессору pPrcRec и привязанную к документу pBillRec.
	//
	int    CreateOnlineByLinkBill(PPID * pSessID, const ProcessorTbl::Rec * pPrcRec, const BillTbl::Rec * pBillRec);
	int    GetRgi(PPID goodsID, double qtty, const TSessionTbl::Rec & rTSesRec, long extRgiFlags, RetailGoodsInfo & rRgi);
	//
	// Descr: Разносит скидку discount по строкам сессии с одновременным изменением результирующей
	//   суммы в записи сессии.
	// ARG(sessID   IN): идентификатор сессии, по строкам которой необходимо разнести скидку
	// ARG(pct      IN): если !0, то скидка discount задана в процентах
	// ARG(discount IN): величина скидки (см. ARG(pct))
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 - скидка была изменена
	//   <0 - по каким-либо причинам (не ошибка) ничего менять не пришлось
	//   0  - ошибка
	//
	int    SetupDiscount(PPID sessID, int pct, double discount, int use_ta);
	int    GetWrOffAttrib(const TSessionTbl::Rec * pRec, WrOffAttrib * pAttr);
	//
	// Descr: Вызывает кассовую панель, которая автоматически создаст пакет
	//   кассового чека, соответствующего техн сессии sessID.
	//   Если сессия sessID не существует, либо не закрыта, либо для склада,
	//   которому принадлежит процессор сессии нет ни одного кассового узла,
	//   либо по сессии уже был проведен чек функция ничего не делает и возвращает <0.
	//   Если же все условия выполняются и кассовая панель была вызвана, то
	//   функция возвращает >0 (не зависимо от того был пользователем проведен чек по
	//   сессии или нет).
	// ARG(sessID     IN): ИД сессии, по которой необходимо сформировать чек.
	// ARG(verifyOnly IN): Если !0, то функция не вызывает кассовую панель, но
	//   лишь проверяет возможность создания чека по сессии sessID.
	// Returns:
	//   <0 - по идентификатору sessID кассовой сессии невозможно создать чек.
	//   >0 - если verifyOnly, то по сессии sessID можно создать чек, в противном
	//        случае этот код возврата означает, что чековая панель была вызвана.
	//
	int    CallCheckPaneBySess(PPID sessID, int verifyOnly = 0);
	int    CalcBalance(PPID sessID, double * pDebt, double * pBillPaym, double * pCcPaym);
	//
	// Descr: Структура, возращаемая в ответ на запрос о статусе процессорного места с заданным кодом
	//
	struct PlaceStatus {
		void   Init();
		PPID   TSessID;
		int    Status;      // 0 - место не идентифицировано, 1 - место свободно, -1 - место занято
		PPID   GoodsID;     // Товар, ассоциированный с местом
		PPID   RegPersonID; // ИД персоналии, загеристрированной на этом месте
		PPID   CipID;       // ИД позиции в таблице персональных регистраций сессии
			// (может понадобиться для осуществления дополнительных операций по регистрации: подстверждение, отмена и т.д.)
		double Price;       // Цена (по товарной котировке)
		SString PlaceCode;  // Собственно, код места
		SString Descr;      // Текстовое описание места
		SString PinCode;    // PIN-код. Если на месте никто не зарегистрирован, то - пусто.
	};
	//
	// Descr: Возвращает информацию о статусе процессорного места в контексте сессии tsessID
	// ARG(tsessID IN): Идентификатор технологической сессии
	// ARG(pPlaceCode IN): Код места
	// ARG(quotKindID IN): Вид котировки, испольуемый для получения цены
	// ARG(quotLocID IN): Склад, по которому извлекается котировка. Если 0, то применяется склад, к которому привязан процессор сессии
	// ARG(rStatus OUT): Структура, в которую заносятся параметры статуса процессорного места.
	//
	int    GetPlaceStatus(PPID tsessID, const char * pPlaceCode, PPID quotKindID, PPID quotLocID, PlaceStatus & rStatus);
	int    ImportUHTT();
	int    ConvertPacket(const UhttTSessionPacket * pSrc, long flags, TSessionPacket & rDest);
	//
	// Descr: Создает новые сессии по образу существующих, у которых есть параметры повтора.
	// ARG(pSrcSessList IN): Список идентификаторов сессий, которые следует брать за образец создаваемых сессий.
	//   Если pSrcSessList == 0, то функция самостоятельно перебирет процессоры, допускающие повтор сессий и, если
	//   найдет для этих процессоров сессии с параметрами повтора, то использует их как образцы.
	// ARG(rPeriod IN): Период, в который должны попадать создаваемые сессии. Функция не пытается
	//   самостоятельно корректировать параметры этого периода.
	// ARG(rResultList OUT): Список идентификаторов созданных сессий.
	// ARG(use_ta IN): Параметр транзактивности: 0 - не создавать собственную транзакция, 1 - создавать, -1 - по обстановке.
	// Returns:
	//   >0 - была создана по крайней мере одна новая сессия
	//   <0 - функция не создала ни одной новой сессии по штатным причинам (нечего было создавать)
	//    0 - error
	//
	int    MakeSessionsByRepeating(const PPIDArray * pSrcSessList, const DateRange & rPeriod, PPIDArray & rResultList, int use_ta);
	//
	// Descr: Реализация сохранения расширения сессии в таблице Property (посредством объекта Reference).
	//   Вынесена в отдельную функцию для унификации исполнения как штатной функции PutExtension так и
	//   для работы служебных процедур (в частности, конвертации).
	//
	static int Implement_PutExtention(Reference * pRef, PPID id, PPProcessorPacket::ExtBlock * pExt, int use_ta);
	//
	// Descr: Реализация извлечения расширения сессии из таблицы Property (посредством объекта Reference).
	//   Вынесена в отдельную функцию для унификации исполнения как штатной функции GutExtension так и
	//   для работы служебных процедур (в частности, конвертации).
	//
	static int Implement_GetExtention(Reference * pRef, PPID id, PPProcessorPacket::ExtBlock * pExt);
private:
	static  int PutWrOffOrder(const TSessWrOffOrder *, int use_ta);
	static  int GetWrOffOrder(TSessWrOffOrder *);
	virtual int DeleteObj(PPID id);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual const char * GetNamePtr();
	virtual int  HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	int    SerializePacket(int dir, TSessionPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Helper_SetSessionState(TSessionTbl::Rec *, int newState, int checkOnly, int updateChilds);
	int    Helper_WriteOff(PPID sessID, PUGL * pDfctList, PPLogger &, int use_ta);
	int    SnapshotRest(PPID sessID, PPLogger &, int use_ta);
	int    LoadExistedDeficitBills(PPID sessID, PPBillPacketCollection & rList, PPLogger & rLogger);
	int    ConvertWrOffDeficit(PPID sessID, PPID locID, const PUGL * pDfctList, PPLogger & rLogger);
	//
	// Descr: Заносит в сессию строку, соответствующую расходу основного товара, если он
	//   учитывается по времени (торговая единица основного товара приводится к секунде).
	//
	int    PutTimingLine(const TSessionTbl::Rec * pPack); // @<<PPObjTSession::PutPacket
	int    CompleteStruc(PPID sessID, PPID tecGoodsID, PPID tecStrucID,
		double tecQtty, const PPIDArray * pGoodsIdList, int tooling); // @<<PPObjTSession::Complete
	void   Helper_SetupDiscount(SVector & rList, int pct, double discount);
		// @<<PPObjTSession::SetupDiscount
	enum {
		hploInner = 0x0001
	};
	int    Helper_PutLine(PPID sessID, long * pOprNo, TSessLineTbl::Rec * pRec, long options, int use_ta);

	SString NameBuf;
	PPTSessConfig Cfg;
	//
	struct BhtCurSessData {
		BhtCurSessData();
		int    Set(PPID sessID, PPID prcID, PPID arID, const LDATETIME & rDtm);
		void   Reset();
		BhtCurSessData & FASTCALL operator = (const BhtCurSessData &);
		PPID   TSessID;
		PPID   PrcID;
		PPID   ArID;
		LDATETIME Dtm;
		int    Ta;
		int    IsProperSess; // Сессия создана самой функцией ProcessBhtRec.
			// Эта сессия закрывается при появлении новой сессии.
			// Сессии, которые не были созданы этой функцией - не закрываются.
		PPObjGoods GObj;
	};
	BhtTSess * P_BhtCurSess;
public:
	PPObjTech TecObj;
	PPObjProcessor PrcObj;
	PPObjSCard ScObj;
	PPObjGoods GObj;

	TLP_MEMB(TSessionCore, P_Tbl);
	void * ExtraPtr;
};
//
// Descr: Автоматическая обработка технологических сессий
//
class PrcssrTSessMaintenance {
public:
	struct Param { // @persistent
	public:
		Param();
		void   Init();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
            aCancelCip     = 0x0001,
			aMakeRepeating = 0x0002
		};
		SVerT  Ver; // Версия системы, создавшей запись
		uint8  Reserve[28]; // @reserve @v11.0.4 [32]-->[28]
		long   Action;      // @v11.0.4 flags
		DateRange Period;   // Период обзора сессий (по StDt)
		long   Flags_;      //
		long   Reserve2;    // @reserve
	};
	PrcssrTSessMaintenance();
	int    InitParam(Param *);
	int    EditParam(Param *);
	int    Init(const Param *);
	int    Run();
private:
	Param P;
	PPObjTSession TSesObj;
};
//
// @ModuleDecl(PPViewTSession)
//
struct TSessAnlzFilt;

struct TSessionFilt : public PPBaseFilt {
	enum {
		ordByDefault = 0,
		ordByStTime,
		ordByFnTime,
		ordByPrc,
		ordByMainGoods,
		ordByAr,
		ordByAmount
	};

	TSessionFilt();
	TSessionFilt(const TSessionFilt & rS);
	TSessionFilt & FASTCALL operator = (const TSessionFilt & s);
	bool   FASTCALL CheckIdle(long flags) const;
	bool   FASTCALL CheckWrOff(long flags) const;
	bool   FASTCALL CheckStatus(int status) const;
	int    FASTCALL GetStatusList(PPIDArray &) const;

	enum {
		fSuperSessOnly = 0x0001,
		fCurrent       = 0x0002, // Показать текущую по времени сессию по процессору PrcID. Если такая сессия //
			// является суперсессией, то показываются все подчиненные ей сессии, в противном случае показывается //
			// только эта сессия //
		fManufPlan     = 0x0004, // Показывать сессии производственных планов @#{fManufPlan^(fSuperSessOnly|fCurrent)}
		fSubSess       = 0x0008  // Если флаг установлен и SuperSessID != 0, то показываются субсессии для сессии SuperSessID.
	};
	char   ReserveStart[12]; // @anchor // @v11.7.6 [18]-->[12]
	PPID   GoodsGroupID;   // @v11.7.6 Товарная группа, ограничивающая выборку документов по содержимому
	int16  Reserve2;     // @v11.7.6 @alignment
	int16  Ft_WritedOff; // @v11.0.6
	PPID   QuotKindID;   // Вид котировки, испольуземый для извлечения цен
	PPID   UhttStoreID;  // ->Ref(PPOBJ_UHTTSTORE) Специальный критерий для передачи на онлайновый ресурс списка сессий
	int32  Order;        // Порядок сортировки
	PPID   SuperSessID;  // ->TSession.ID  ИД суперсессии. Если это поле ненулевое, то отменяются все остальные критерии
	PPID   PrcID;        // ->Processor.ID ИД процессора
	PPID   TechID;       // ->Tech.ID      ИД технологии
	PPID   ArID;         // ->Article.ID
	PPID   Ar2ID;        // ->Article.ID
	DateRange StPeriod;  // Период начала сессии
	LTIME  StTime;       // Время начала сессий. Ограничением является пара {StPeriod.low, StTime}
	DateRange FnPeriod;  // Период завершения сессии
	LTIME  FnTime;       // Время окончания сессий. Ограничением является пара {FnPeriod.upp, FnTime}
	long   StatusFlags;  // Флаги статусов, по которым нужна выборка
	long   Flags;        // Флаги (TSessionFilt::fXXX)
	int16  Ft_Idle;      // (0) ignored, (<0) не показывать простои, (>0) показывать простои
	uint16 Reserve;      // @alignment
private:
	void   Helper_Init();
};

struct TSessionTotal {
	long   Count;
	long   Duration; // Общая продолжительность сессий (сек)
};

class TSessionViewItem : public TSessionTbl::Rec {
public:
	TSessionViewItem();
	TSessionViewItem & Z();
	PPCheckInPersonItem CipItem;
	PPID   WrOffBillID;
	SString SMemo; // @v11.0.4
};

class PPViewTSession : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByStartTime,
		ordByFinishTime,
		ordByPrc,
		ordByAr,

		ordfWithCip  = 0x10000000, // Специальный флаг, предписывающий перебирать сессии с записями персональных регистраций
		ordfWithBill = 0x20000000  // Специальный флаг, предписывающий перебирать сессии с документами списания //
	};
	//
	// Descr: Расширение результатов перечисления для передачи в интернет-магазин
	//
	struct UhttStoreExt {
		UhttStoreExt();
		UhttStoreExt & Z();
		PPID   ID;
		StrAssocArray SfList;
	};

	PPViewTSession();
	~PPViewTSession();
	//
	// ARG(extraParam IN): Если этим параметром передается значение TSESK_PLAN,
	//   то в созданном фильтре устанавливается флаг fManufPlan.
	//
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(TSessionViewItem *);
	int    GetUhttStoreExtension(const TSessionTbl::Rec & rItem, PPViewTSession::UhttStoreExt & rExt);
	int    CalcTotal(TSessionTotal *);
	int    Transmit(PPID /*id*/);
	int    GetSmsLists(StrAssocArray & rPsnList, StrAssocArray & rPhoneList, StrAssocArray & rTSessIdArr); // @vmiller
	int    SendAutoSms(); // @vmiller
	int    GetSelectorListInfo(StrAssocArray & rList) const;
	int    GetSelectorListItem(long handler, PPUhttStoreSelDescr::Entry & rEntry) const;
private:
	virtual void * GetEditExtraParam();
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	bool   IsTempTblNeeded() const;
	void   MakeTempRec(const TSessionTbl::Rec * pSrcRec, TempOrderTbl::Rec * pDestRec);
	//
	// Descr: Формирует рамочный список идентификаторов сессий в соответствии с фильтром
	//   Под термином "рамочный" подразумевается то, что список не учитывает всех критериев фильтрации,
	//   но лишь те, которые можно применить для максимально быстрого построения списка.
	//
	int    MakeDraftIdList(PPIDArray & rList);
	int    WriteOff(PPID sessID);
	int    Recover();
	int    PrintList(const void * pHdr);
	int    ExportUhtt();

	struct IterBlock {
		IterBlock();
		IterBlock & FASTCALL Init(int order);

		int    Order;
		PPCheckInPersonArray CipList;
		PPIDArray WrOffBillList;
		TSessionViewItem CurItem;
	};
	static int DynFuncMemo;
	enum {
		stEmpty     = 0x0001, // Фильтр дает пустую выборку
		stSuperSessIsSimple = 0x0002  // Признак того, что Filt.SuperSessID не является в действительности
			// суперсессией. В этом случае показывается только простая сессия с ид Filt.SuperSessID
	};
	long   State;
	TSessionFilt Filt;
	PPObjTSession TSesObj;
	TempOrderTbl * P_TempTbl;
	TSessAnlzFilt * P_LastAnlzFilt; // Последний использованный фильтр по анализу сессий.
		// Применяется для того, чтобы пользователю не приходилось заново вводить парараметры
		// фильтрации при повторном анализе той же выборки сессий.
	PPUhttStorePacket * P_UhttsPack;
	IterBlock  Ib;
	ObjIdListFilt IdList;   // @v11.7.9 Список идентификаторов сессий, которые должны быть в выборке
	ObjIdListFilt PrcList;
	ObjIdListFilt TechList; // @v11.7.6
	StrAssocArray ExtSfTitleList;
};
//
// @ModuleDecl(PPViewTSessAnlz)
//
struct TSessAnlzFilt : public PPBaseFilt {
	TSessAnlzFilt();
	TSessAnlzFilt & FASTCALL operator = (const TSessAnlzFilt &);
	void   SetOuterTSessFilt(const TSessionFilt *);
	const  TSessionFilt * GetOuterTSessFilt() const;
	int    IsDiffFlag() const;

	enum {
		fAll          = 0x0004, // Отчет по всей выборке сессий. Иначе - по одной
		fPrmrGoodsOnly        = 0x0008, // Только по основным товарам (исключает DiffMg)
		fShowRest     = 0x0010, // Показывать строки фиксированных остатков
		fExtrapolToPeriod     = 0x0080, // Экстраполировать итоги анализа по плану на неполный период.
			// Эта опция используется при расчете анализа по производственному плану, работа по которому еще не закончилась.
		fAddTotalRows = 0x0100, // Показывать итоги по каждой из позиций без группировки
			// Актуальна только если DiffPrc || DiffMg || DiffDt.
		fNmgRestrictOnly      = 0x0200, // NmGoodsGrpID (если !0) только ограничивает выборку, но не замещает позиции
		fInterpolPlanToAr     = 0x0400, // Интерполировать план на статьи. Эта опция работает только в том
			// случае, когда DiffPrc == difprcAr и для статей процессора определен график дежурств.
		fNmgAllRestrict       = 0x0800, // NmGoodsGrpID (если !0) ограничивает все товары (основные и неосновные) выбранной группой
		fCalcCompParts        = 0x1000  // Рассчитывать итоговые части компонентов в производимой продукции (в физических единицах).
	};
	//
	// Варианты дифференциации отчета по процессорам
	//
	enum {
		difprcNone = 0, // Нет дифференциации
		difprcPrc,      // Дифференцировать собственно по процессорам
		difprcPrcGroup, // Дифференцировать по группам процессоров (самый близкий к процессорам уровень)
		difprcAr        // Дифференцировать по статьям сессий
	};
	//
	// Варианты дифференциации отчета по основным товарам
	//
	enum {
		difmgNone = 0, // Нет
		difmgGoods,    // Дифференцировать собственно по основным товарам
		difmgGroup     // Дифференцировать по группам основных товаров
	};
	//
	// Варианты дифференциации отчета по дате
	//
	enum {
		difdtNone = 0, // Нет
		difdtDate,     // Дифференцировать собственно по дате начала сессий
		difdtSupersess // Дифференцировать по суперсессиям
	};
	char   ReserveStart[32];  // @anchor
	DateRange Period;         // reserved
	PPID   PrcID;             // reserved
	PPID   GoodsGrpID;        // reserved
	PPID   ArID;              // reserved
	PPID   Ar2ID;             // reserved
	PPID   PlanSessID;        // ->TSession.ID Ид сессии производственного плана
	PPID   NmGoodsGrpID;      // Группа неосновных товаров, по которой ограничивается и обобщаяетс
		// либо только ограничивается отчет.
		// Остальные неосновные товары в отчет не попадают, а товары, входящие в эту группу сливаются //
		// в одну строку.
	SubstGrpGoods Sgg;        //
	long   Flags;             //
	int16  DiffPrc;           // Дифференциация по процессору
	int16  DiffMg;            // Дифференциация по основному товару
	int16  DiffDt;            // Дифференциация по дате
	int16  Reserve;           //
	ObjIdListFilt SessIdList; // @anchor
private:
	TSessionFilt * P_TSesFilt; // Используется как источник полей для отчетов. На формирование анализа не влияет.
};

struct TSessAnlzViewItem {
	PPID   __ID;
	long   DtVal;         //
	PPID   PrcID;
	PPID   PrmrGoodsID;
	int16  NotPrmrLine;   // Строка не принадлежит основному товару (GoodsID != PrmrGoodsID)
	int16  PlanPhUnit;    // План и факт представлены в физических единицах
	PPID   GoodsID;
	char   PrmrGoodsName[64];
	char   GoodsName[64];
	char   PrcName[48];
	char   DtText[48];
	double InQtty;
	double OutQtty;
	double InQttyPh;
	double OutQttyPh;
	double PlanInQtty;
	double PlanOutQtty;
	double PlanDev;
	double OutRest;
	double InCompPart;    // Часть компонента в общем входе  (в физ единицах)
	double OutCompPart;   // Часть компонента в общем выходе (в физ единицах)
};

class PPViewTSessAnlz : public PPView {
public:
	PPViewTSessAnlz();
	~PPViewTSessAnlz();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(TSessAnlzViewItem *);
	int    GetItem(PPID __id, TSessAnlzViewItem *);
	int    GetPhQtty(const TSessAnlzViewItem * pItem, PPID * pPhUnitID, double * pIn, double * pOut);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int    Print(const void *);
	int    CreateTSessFiltByPlan(const TSessionTbl::Rec * pPlanRec, TSessionFilt * pFilt) const;
	int    CreateBySess(PPID sessID, TSessAnlzList * pResult, PPIDArray * pProcessedList);
	void   RecToViewItem(const TempTSessRepTbl::Rec * pRec, TSessAnlzViewItem * pItem);
	int    IsGoodsBelongToGen(PPID goodsID, PPID * pGenID);
	int    GetPlanWithSubst(PPID arID, PPID * pGoodsID, double * pPlan, int * pSign);
	int    NmGoodsSubst(PPID prmrGoodsID, PPID * pGoodsID); // @<<ProcessSession
	int    ProcessSession(const TSessionTbl::Rec * pRec, TSessAnlzList * pResult);
	int    EditGoods(PPID goodsID);
	int    CalcArTimes(const PPDutySchedPacket * pDsPack, const STimeChunk & rBounds, RAssocArray * pDurationList);
	int    GetDutySchedPacket(PPID prcID, PPDutySchedPacket *);

	TSessAnlzFilt Filt;
	TempTSessRepTbl * P_TempTbl;
	PPObjTSession TSesObj;
	PPObjGoods  GObj;
	LAssocArray GenList;
	RAssocArray PlanList;      //
	PPIDArray   PhTagPlanList; // SORTED Список идентификаторов товаров, план по которым задан в физических единицах
	RAssocArray ArTimesList;   // Используется для интерполяции общего плана на статьи (TSessAnlzFilt::fInterpolPlanToAr)
	GoodsSubstList Gsl;
};
//
// @ModuleDecl(PPViewTSessLine)
//
struct TSessLineFilt {
	TSessLineFilt(PPID sessID = 0, PPID goodsID = 0, int showRest = 0);
	int    Init();
	enum {
		fOutRest = 0x0001   // Показывать строки, соответствующие исходящим остаткам по сессии
	};
	long   Tag;             // @#0 reserved
	uint8  Reserve[32];     // @#0 !Использовать начиная со старших адресов
	PPID   GoodsID;
	long   Flags;
	DateRange StPeriod;     // Период начала сессии. Действует только если GoodsID != 0
	ObjIdListFilt TSesList; // Если список не пустой, то все остальные критерии,
		// относящиеся к отбору сессий игнорируются.
};

typedef TSessLineTbl::Rec TSessLineViewItem;

class PPViewTSessLine : public PPView {
public:
	PPViewTSessLine();
	~PPViewTSessLine();
	const  TSessLineFilt * GetFilt() const;
	int    Init(const TSessLineFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(TSessLineViewItem *);
private:
	struct BrwHdr {
		PPID   TSesID;
		long   OprNo;
	};
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser *);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	bool   IsTempTblNeeded();
	int    CreateIterQuery();
	int    TranslateBrwHdr(const void *, BrwHdr *);
	int    AddItemExt(PPID tsesID, PPViewBrowser *);
	int    AddItemByCode(const char * pInitStr);
	int    AddCompletion(PPID sessID);

	TSessLineFilt Filt;
	PPObjTSession TSesObj;
	PPObjGoods GObj;
	PPID   NewGoodsGrpID;
	long   GoodsListIter;  // -1 - не используется //
	long   SessListIter;   // -1 - не используется //
	PPIDArray GoodsIdList; // @*PPViewTSessLine::Init() SORTED
	TSessLineTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewPrcBusy)
//
struct PrcBusyFilt : public PPBaseFilt {
	PrcBusyFilt();

	enum {
		fFree  = 0x0001, // Показывать доступные периоды (в течении которых процессоры свободны)
		fShowTimeGraph = 0x0002  // При открытии таблицы сразу открывать временную диаграмму.
	};
	char   ReserveStart[32]; // @anchor
	PPID   PrcID;            // Процессор или группа процессоров
	STimeChunk Period;       // Период, для которого показывать занятые (свободные) процессоры
	LTIME  MinDuration;      // Минимальная продолжительность. Если период занятости (свободы)
		// процессора ниже этой величины, то не показывать такой период
	long   Flags;
	long   Reserve;          // @anchor
};

struct PrcBusyViewItem {
	PPID   PrcID;
	STimeChunk Period;
	PPID   TSessID;
	long   Duration;
	char   TxtPeriod[48];
	char   TxtDuration[16];
};

class PPViewPrcBusy : public PPView {
public:
	//
	// Descr: Внешний контекст при активации экземпляра
	//
	struct OuterContext {
		OuterContext();
		PPID   PersonID;
		PPID   SCardID;
		PPID   LocID;
		SString Phone;
	};
	PPViewPrcBusy();
	~PPViewPrcBusy();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PrcBusyViewItem *);
	int    GetItem(PPID id, PrcBusyViewItem * pItem);
	int    EditTimeGridItem(PPID * pID, PPID rowID, const LDATETIME & rDtm);
	int    UpdateTimeGridItem(PPID sessID, PPID prcID, const STimeChunk & rNewChunk);
	//
	// Descr: Устанавливает внешний контекст. Если pOCtx == 0, то сбрасывает текущий контекст.
	//
	void   SetOuterContext(const OuterContext * pOCtx);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int    Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int    Print(const void *);
	virtual int    OnExecBrowser(PPViewBrowser * pBrw);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int    ProcessPrc(PPID prcID, BExtInsert * pBei);
	int    Update(const PPIDArray & rPrcList);
	void   RecToViewItem(const TempPrcBusyTbl::Rec * pRec, PrcBusyViewItem * pItem) const;
	int    AddSession(const PrcBusyViewItem * pItem);
	int    ViewTSessLines(PPID);
	int    TimeChunkBrowser();
	int    UpdateTimeBrowser(int destroy);

	PrcBusyFilt Filt;
	TempPrcBusyTbl * P_TempTbl;
	PPObjTSession TSesObj;
	PPObjStaffCal ScObj;
	PPObjStaffList SlObj;
	PPIDArray PrcList;
	PPIDArray UpdatePrcList;
	OuterContext * P_OCtx;
	//
	class PrcBusyTimeChunkGrid : public STimeChunkGrid {
	public:
		PrcBusyTimeChunkGrid(PPViewPrcBusy * pV);
		~PrcBusyTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
		virtual int GetColor(long id, STimeChunkGrid::Color * pClr);
	private:
		PPViewPrcBusy * P_View; // @notowned
		PPObjGoods GObj;
	};
	PrcBusyTimeChunkGrid Grid;

	friend class PPViewPrcBusy::PrcBusyTimeChunkGrid;
};
//
// --- Before v3.2.10 ---

// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             32
//    Количество элементов массива list                     2
//    Массив list           list.getCount() * sizeof(PPObjID)
//    Количество элементов массива addr                     2
//    Массив addr              addr.getCount() * sizeof(long)
//    Количество элементов массива commIDs                  2
//    Массив commIDs        commIDs.getCount() * sizeof(PPID)
//    Объекты                                             var
// Примечание: list.count == add.count == commIDs.count
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             32
//    PPObjectTransmit::Ack[]                          n * 32
//
// --- Since v3.2.10 ---
//
// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             64
//    Объекты                                             var
//    PPObjectTransmit::IndexItem [PPObjectTransmit::Header::IndexCount]
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             64
//    PPObjectTransmit::Ack[]                          n * 32
//
// --- Since v5.6.8 ---
//
// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             64
//    Объекты                                             var
//    PPObjectTransmit::IndexItem [PPObjectTransmit::Header::IndexCount]
//    Наименования объектов (StringSet)                   var
//      Формат списка наименований: {{uint32 size}, {char buf[size]}}
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             64
//    PPObjectTransmit::Ack[]                          n * 32
//

//
// Приоритеты приема объектов данных:
//
// DEFAULT:           1000
// PPOBJ_DYNAMICOBJS:  100
// PPOBJ_TAG:          120
// PPOBJ_BILL (приоритеты различаются в зависимости от характера операции):
//   Тип операции PPOPT_GOODSRECEIPT:                                           200
//   Любая другая приходная операция или заказ от покупателя (IsExpendOp()==0): 220
//   Тип операции PPOPT_GOODSMODIF:                                             240
//   Расходная операция (IsExpendOp()>0):                                       280
//   Все остальные документы:                                                   300
//
//

//
// Типы пакетов для передачи между разделами БД
//
#define PPOT_OBJ         1 // Пакет, содержащий объекты
#define PPOT_ACK         2 // Пакет, содержащий подтверждение о приеме объектов
#define PPOT_SYNCCMP     3 // Пакет, содержащий информацию о синхронизации объектов
//
// Флаги PPObjectTransmit::Header::Flags
//
#define PPOTF_ACK        0x0001L // Подтверждение обработки файла адресатом
#define PPOTF_ARC        0x0002L // Файл упакован
#define PPOTF_IGNACK     0x0004L // Отправитель этого пакета объектов игнорирует пакеты подтверждений
	// (в ответ на этот флаг раздел-получатель не станет создавать пакет подтверждений)
#define PPOTF_CONSOLID   0x0008L // Отправитель этого пакета считает, что отсылает данные в
	// консолидирующий раздел (при этом некоторые данные не передаются)
#define PPOTF_RECOVER    0x0010L // Специальный флаг, указывающий на то, что пакет передачи содержит
	// восстановительные данные для раздела-получателя //
//
// Object update mode in destination database devision
//
#define PPOTUP_DEFAULT             -1 //
#define PPOTUP_NONE                 0 // Don't update
#define PPOTUP_BYTIME               1 // Update by modif date/time
#define PPOTUP_FORCE                2 // Force update
#define PPOTUP_LATEUPDATINGDECISION 3 // @v11.3.0 @internal Проецируется на флаг пакета объекта PPObjPack::fLateUpdatingDecision

#define TRNSMF_DELINFILES  0x00000001L
#define TRNSMF_DELOUTFILES 0x00000002L

struct ObjTransmitParam {
	ObjTransmitParam();
	void   Init();
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long) const;

	enum {
		fSyncCmp         = 0x0001,
		fRecoverTransmission     = 0x0002, // Специальный флаг, указывающий на то, что пакет передачи содержит
			// восстановительные данные для раздела-получателя //
		//
		// В подавляющем большинстве случаев объекты передаются выборкой. Однако, иногда,
		// по-умолчанию передача осуществляется только для выбранного объекта (например, в кассовых сессиях).
		// Для ручного переопределения такого поведения применяются следущие 2 флага.
		// 1. !fQueryInmassTransmission && !fInmassTransmission) вызывающая функция ведет себя по умолчанию
		// 2. fQueryInmassTransmission && !fInmassTransmission вызывающая функция ведет себя по умолчанию (в диалоге была возможность выбрать массовую передачу)
		// 3. fQueryInmassTransmission && fInmassTransmission вызывающая функция передает всю выборку объектов
		// 4. !fQueryInmassTransmission && fInmassTransmission инвалидная комбинация: вызывающая функция ведет себя по умолчанию
		//
		fQueryInmassTransmission = 0x0004, // Запрос на необходимость передачи всей выборки объектов
		fInmassTransmission      = 0x0008  // От пользователя получено требование передачи всей выборки объектов.
	};
	ObjIdListFilt DestDBDivList;
	ObjIdListFilt ObjList;       // PPACN_XXX
	LDATETIME Since_;
	int    UpdProtocol; // PPOTUP_XXX
	long   Flags;
	long   TrnsmFlags;   // TRNSMF_XXX
};

struct ObjReceiveParam {
	ObjReceiveParam();
	void   Init();
	int    CheckDbDivID(PPID id) const;
	int    Write(SBuffer &, long) const;
	int    Read(SBuffer &, long);

	enum {
		fNonInteractive    = 0x0001,  // Не вызывать диалог редактирования параметров
		fGetFromOutSrcr    = 0x0002,  // Забирать данные из внешнего источника
		fClearInpBefore    = 0x0004,  // Очищать каталог-приемник перед приемом файлов
		fClearInpAfter     = 0x0008,  // Очищать каталог-приемник после обработки данных
		fSyncCmp   = 0x0010,  // Обрабатывать только пакеты сравнения синхронизации
		fCommitQueue       = 0x0020,  // Акцептировать очередь приема данных
		fForceDestroyQueue = 0x0040,  // Насильно разрушать очередь после акцепта (даже если не все объекты приняты)
		fCheckMqb  = 0x0080,  // Проверять очередь обмена сообщениями. Если
			// этот флаг не установлен, то даже при наличии флага DBDIVF_MQBEXCHANGE в текущем разделе базы данных
			// очередь обмена сообщениями проверяться не будет.
		fDisableLogWindow  = 0x0100,  // При обработке данных не выводить окно с сообщениями
	};
	PPIDArray SenderDbDivList;
	long   Flags;
	TempSyncCmpTbl * P_SyncCmpTbl; // Временная таблица сравнения синхронизации объектов
		// @#{((Flags & fSyncCmp) && P_SyncCmpTbl != 0) || (!(Flags & fSyncCmp) && P_SyncCmpTbl == 0)}
	StringSet SsOnlyFileNames;    // @transient Имена только тех файлов, которые должны быть обработаны (сканировать что-либо в поисках иных файлов не следует).
};

struct ObjTransmMqProps {
	ObjTransmMqProps();
	ObjTransmMqProps & Z();
	int    PutToMqbMessage(PPMqbClient::MessageProperties & rProps) const;
	int    GetFromMqbMessage(const PPMqbClient::MessageProperties & rProps);

	PPID   SrcDbDivID;
	PPID   DestDbDivID;
	S_GUID SrcDbGUID;
	S_GUID DestDbGUID;
	SString FileName;
	SString QueueName;
};

struct BillTransmitParam : public PPBaseFilt {
	BillTransmitParam();
	int    Edit();

	enum {
		fLabelOnly = 0x0001
	};
	uint8  ReserveStart[28];     // @anchor
	PPID   ArID;                 // Контрагент по документам
	DateRange Period;            //
	PPID   OpID;                 //
	PPID   ToOpID;               // Преобразовывать OpID в ToOpID
	PPID   Ar2ID;                // Дополнительный объект, по которому следует отбирать документы
	uint   Flags;                //
	long   TrnsmFlags;           // TRNSMF_XXX
	long   Reserve;              // @anchor
	ObjIdListFilt DestDBDivList; // @anchor
	BillFilt * P_BillF;          //
};

class BillTransmDeficit {
public:
	struct LocPeriod { // @flat
		PPID   LocID;
		DateRange P;
	};

	BillTransmDeficit();
	~BillTransmDeficit();
	int    ProcessDeficit(ObjTransmContext * pCtx, int * pNextPassNeeded);
	int    AddItem(ILTI * ilti, const char * pClbNumber, BillTbl::Rec *, int skipped);
	PPIDArray LookedBills;
private:
	int    TurnDeficitDialog(double * pPctAddition);
	int    TurnDeficit(PPID locID, LDATE dt, double pctAddition, const ObjTransmContext * pCtx);
	int    PrintTotalDeficit(ObjTransmContext * pCtx);
	int    Search(PPID locID, PPID goodsID, PPID supplID, TempDeficitTbl::Rec *);
	void   CalcReqSalesTax(const ILTI * pIlti, LDATE, PPID opID, double * pSalesTax);
	int    AddRec(ILTI *, const char * pClbNumber, BillTbl::Rec *, PPID supplID, double qtty);
	int    UpdateRec(TempDeficitTbl::Rec *, ILTI *, const char * pClbNumber, BillTbl::Rec *, double qtty);
	int    CompleteGoodsRest();
	int    _CompleteGoodsRest(PPID locID, PPID goodsID, SArray * pRecList, uint startPos, double supplQtty);
	int    InitDeficitBill(PPBillPacket *, PPID oprKind, LDATE, PPID locID, PPID supplID);
	int    GetGoodsDeficitList(PPIDArray * pList);
	LocPeriod * GetLocPeriod(PPID locID);

	int    DiffGoodsBySuppl;
	TSVector <LocPeriod> LocPeriodList_;
	TempDeficitTbl * Tbl;
	PPObjBill  * BObj;
	PPObjGoods   GObj;
};

class PPObjectTransmit {
public:
	enum TransmitMode {
		tmUndef = 0,
		tmWriting,
		tmReading
	};
	struct Header { // @persistent(DBX) @size=128
		Header();
		int32  Magic;           // 0x534F5050L ("PPOS")
		uint16 PacketType;      // Тип пакета (PPOT_XXX)
		int32  DBID;            // Раздел БД, создавший пакет для передачи
		int32  DestDBID;        // Раздел БД - адресат пакета для передачи
		int32  Flags;           // PPOTF_XXX
		SVerT  SwVer;           // Source software version
		uint32 IndexOffs;       // Offset from beginning of file to index list
		uint32 IndexCount;      // Count of index items
		uint32 ExtraData;       //
		SVerT  MinDestVer;      // Минимальная версия, которая может принять этот пакет данных. Если версия системы ниже указанной версии, то этот пакет будет отклонен.
		uint8  PackMethod;      // Метод сжатия пакета.  Устанавливается и проверяется в PackTransmitFile()
		uint8  CryptMethod;     // Метод шифровки пакета. Устанавливается и проверяется в PackTransmitFile()
		uint32 NameListOffs;    // Смещение до списка наименований объектов (StrAssocArray)
		uint32 CRC_;            // Контрольная сумма
		uint32 SCtxStOffs;      // Смещение до сохраненного состояния контекста сериализации
		int32  UserID;          // ИД пользователя, создавшего пакет
		uint8  Reserve[8];      //
		S_GUID SrcDivUuid;      // GUID раздела-отправителя //
		S_GUID DestDivUuid;     // GUID раздела-получателя  //
		uint8  Reserve2[32];    // @reserve
	};

	struct IndexItem { // @persistent @size=48 (before v5.6.8 - 32)
		int32  ObjType;
		union {
			int32  ObjID;       // Ид объекта в разделе-отправителе
			int32  SrcID;       // Для пакета сравнения синхронизации. Ид объекта в разделе-отправителе
		};
		PPCommSyncID CommID;
		uint16 Flags;           // PPObjPack::fXXX
		uint32 ObjNamePos;      // Позиция наименования объекта в массиве имен
		union {
			int32  ObjOffs;     // Адрес данных пакета объекта (смещение в файле)
			int32  DestID;      // Для пакета сравнения синхронизации. Ид объекта в разделе-получателе (по таблице отправителя)
		};
		LDATETIME Mod;          //
		int32  Priority;        //
		uint8  Reserve[12];     // @reserve
	};

	struct PacketStat {
		PacketStat();

		PPObjectTransmit::Header Hdr;
		SArray Items;
		StringSet NameList;
	};

	static const long DefaultPriority;
	static const long DependedPriority;
	static int FASTCALL ReadConfig(PPDBXchgConfig *);
	static int EditConfig();
	static int IncrementCharryOutCounter();
	static int TransmitModifications(PPID destDBDiv, const ObjTransmitParam *);
	static int TransmitModificationsByDBDivList(const ObjTransmitParam * pParam);
	static int TransmitBills(PPID destDBDiv, const BillTransmitParam * pParam);
	static int TransmitBillsByDBDivList(BillTransmitParam * pParam);
	static int ReceivePackets(const ObjReceiveParam *);
	static int Transmit(PPID dbDivID, const PPObjIDArray * pObjAry, const ObjTransmitParam * pParam);
	static int Transmit(const PPIDArray * pDBDivAry, const PPObjIDArray * pObjAry, const ObjTransmitParam * pParam);
	static int GetHeader(const char * pFileName, PPObjectTransmit::Header *);
	static int ReadFileStat(const char * pFileName, PacketStat & rStat);
	static SString & GetQueueFilePath(SString & rBuf);
	//
	//	Вероятные ошибки синхронизации объектов:
	//	-(1) В приемнике отсутствует синхронизация объекта, соответствующая //
	//	  синхронизации в источнике
	//	-(2) Наименования синхронизированных объектов значительно различаются //
	//	-(3) Не эквивалентны триплеты {CommID, SrcID, DestID} в источнике и приемнике
	//	-(4) В приемнике отсутствует объект, для которого, тем не менее,
	//	  существует синхронизация в источнике и в приемнике
	//
	//static int ReceiveCmpPackets(TempSyncCmpTbl * pTbl);

	enum {
		ctrfSyncCmp     = 0x0001,
		ctrfRecoverTransmission = 0x0002,
		ctrfDisableLogWindow    = 0x0004
	};
	PPObjectTransmit(TransmitMode, uint ctrFlags/*int syncCmp, int recoverTransmission*/);
	~PPObjectTransmit();
	int    SetDestDbDivID(PPID);
	int    CreateTransmitPacket(long extra = 0);
	int    PostObject(PPID objType, PPID id, int otup /* PPOTUP_XXX */, int syncCmp);
	int    CommitQueue(const PPIDArray & rSrcDivList, int forceDestroyQueue);
	int    CommitAck();
	int    UpdateSyncCmpItem(TempSyncCmpTbl *, PPID objType, PPCommSyncID commID);
	int    RegisterDependedNonObject(PPObjID objid, PPCommSyncID & rCommID, int use_ta);
	int    AcceptDependedNonObject(PPObjID foreignObjId, PPID primaryID, const LDATETIME * pModDtm, int use_ta);
	int    SearchQueueItem(PPID objType, PPID objID, PPID dbID, ObjSyncQueueTbl::Rec * pRec);
	ObjSyncCore SyncTbl;
private:
	struct OtFilePoolItem {
		long   FileId;        // ->ObjSyncQueue.ID Идентификатор файла
		SVerT  InVer;         // Версия входящего файла
		long   AckCount;      //
		SString OrgFileName;  // Имя оригинального файла (только имя и расширение)
		SFile  F;             // Input stream
		SFile  A;             // Acknowledge stream
		SBuffer SCtxState;    // С каждым входным файлом ассоциируется собственный буфер состояния контекста сериализации
	};
	struct RestoreObjItem {
		PPID   QueueID;       // Идентификатор записи в таблице ObjSyncQueue
		PPObjID Oi;           // Идентификатор "чужого" объекта
		PPCommSyncID CommID;  // Общий идентификатор объекта
		int16  Flags;         // PPObjPack::fXXX
		PPID   DBID;          // Раздел базы данных, из которого получен объект
		PPID   PrimID;        // Идентификатор объекта в собственном разделе (заполняется после акцепта объекта)
		LDATETIME Mod;        // Вреия модифификации объекта в разделе DBID
		long   FileId;        // Идентификатор файла, в котором хранится пакет объекта
		SVerT  InVer;         // Версия, создавшая входящий файл
		uint32 ObjOffs;       // Смещение пакета объекта в файле
		char   ObjName[128];  // Наименование объекта
	};
public:
	struct RestoreObjBlock {
		RestoreObjBlock(ObjSyncQueueCore * pQueue, PPObjectTransmit * pOt);
		OtFilePoolItem * SearchFile(long fileId);
		int    SetQueueItem(const ObjSyncQueueTbl::Rec &, RestoreObjItem * pItem);
		int    PushRestoredObj(PPID dbID, PPObjID oi);
		int    PopRestoredObj(PPID dbID, PPObjID oi);
		int    DetectRecur(PPID dbID, PPObjID oi) const;

		ObjSyncQueueCore * P_Queue;
		TSCollection <OtFilePoolItem> Fp;
		PPIDArray ProcessedList;
		SStack S;
		PPObjectTransmit * P_Ot; // @notowned
	};
private:
	static int FASTCALL WriteConfig(const PPDBXchgConfig * pCfg, int use_ta);
	static int FASTCALL LockReceiving(int unlock); // @<<PPObjectTransmit::ReceivePackets
	static int FASTCALL CheckInHeader(const PPObjectTransmit::Header & rHdr, int checkVer, const char * pFileName);
	PPObject * FASTCALL _GetObjectPtr(PPID objType);
	int    OpenInPacket(const char * pFileName, PPObjectTransmit::Header * = 0);
	int    CloseInPacket();
	void   CloseOutPacket();
	int    MakeTransmitFileName(SString & rFileName, S_GUID * pDbDivUuid);
	void   SetupHeader(uint type, PPID dest, PPObjectTransmit::Header *);
	int    Write(FILE * stream, const void *, size_t);
	int    Read(FILE * stream, void *, size_t);
	PPObject * GetObjectPtr(PPID obj);
	int    UpdateInHeader(FILE * stream, const PPObjectTransmit::Header *);
	int    MakeCommIDList(int use_ta);
	int    RestoreObj(RestoreObjBlock & rBlk, RestoreObjItem & rItem, PPID * pPrimID);
	int    PopRestoredObj(SStack *,  PPObjID oi);
	PPObjectTransmit::IndexItem * TmpTblRecToIdxItem(const ObjSyncQueueTbl::Rec * pRec, IndexItem * pItem);
	int    EnumObjectsByIndex(PPObjID * pObjId, ObjSyncQueueTbl::Rec * pRec);
	int    NeedRestoreObj(PPID objType, const PPObjectTransmit::RestoreObjItem & rItem, PPID * pPrimID);
	//
	// Descr: Возвращает информацию о синхронизации объекта из другого раздела БД.
	//   По указателю pPrimID присваивает первичный ид объекта, в буфер по указателю pObjName
	//   копируется наименование объекта.
	// Returns:
	//   1  - информация о синхронизации найдена и найден объект.
	//   -1 - не найдена информация о синхронизации объекта
	//   -2 - информация о синхронизации найдена, но первичный ид = 0
	//   -3 - информация о синхронизации найдена, но не найден объект с ид *pPrimID
	//   0  - ошибка
	//
	int    GetPrivateObjSyncData(PPID objType, PPCommSyncID commID, PPID * pPrimID, LDATETIME * pModDtm, char * pObjName, size_t bufLen);
	int    PutObjectToIndex(PPID obj, PPID id, int otup /* PPOTUP_XXX */, int innerUpdProtocol = PPOTUP_DEFAULT, long extra = 0);
	//
	// Descr: Заносит в поток передачи данных информацию о синхронизации объекта
	//   типа objType с идентификатором id.
	//
	int    PutSyncCmpToIndex(PPID objType, PPID id);
	int    SetupSyncCmpRec(const ObjSyncQueueTbl::Rec * pQueueRec, TempSyncCmpTbl::Rec * pRec);
	int    RestoreFromStream(const char * pInFileName, FILE * stream, TempSyncCmpTbl * pTbl);
	int    PushObjectsToQueue(PPObjectTransmit::Header & rHdr, const char * pInFileName, FILE * pInStream, int use_ta);
	int    Helper_PushObjectsToQueue(const PPObjectTransmit::Header & rHdr, long sysFileId, const TSVector <ObjSyncQueueTbl::Rec> & rList, int use_ta);
	//
	// Descr:
	// Returns:
	//   >0 - инициализация прошла успешно
	//   <0 - пакет данных отклоняется поскольку требует более позднюю версию системы
	//
	int    StartReceivingPacket(const char * pFileName, const void * /*PPObjectTransmit::Header*/);
	int    InitContextSrcDiv(PPID dbDivID);
	int    LogRcvObj(int msgId, const PPObjectTransmit::RestoreObjItem & rItem);

	struct Ack { // @persistent(DBX) @size=48
		PPID   Obj;            // If Obj == -1 then FileName contains name of received file
		PPID   Id;             //
		PPCommSyncID CommId;   //
		int16  Reserve;        // @alignment
		uint8  Reserve2[12];
		union {
			LDATETIME DT;
			char   FileName[20];
		};
	};
	TransmitMode Mode;
	int    CtrError;           // @*PPObjectTransmit::PPObjectTransmit Признак ошибки создания //
	int    SyncCmpTransmit;    // Признак передачи сравнения синхронизации объектов
	int    IamDispatcher;      // Признак того, что наш раздел является диспетчерским
	int    RecoverTransmission; // Признак восстановительной передачи
	SString InFileName;        //
	Header InHead;             //
	PPID   DestDbDivID;        //
	DBDivPack DestDbDivPack;   // @*PPObjectTransmit::SetDestDbDivID
	DBDivPack SrcDbDivPack;    // @*PPObjectTransmit::StartReceivingPacket
	DBDivPack ThisDbDivPack;   // @*PPObjectTransmit::PPObjectTransmit
	StringSet ObjNameList;     // Список имен объектов
	ObjCollection * P_ObjColl; //
	ObjTransmContext Ctx;      // Контекст обмена данными, передаваемый методам Read и Write обрабатываемых объектов
	ObjSyncQueueTbl * P_TmpIdxTbl;
	ObjSyncQueueCore * P_Queue;
	FILE * P_OutStream;
	FILE * P_InStream;
	PPObjDBDiv DObj;
	TSCollection <DBDivPack> SrcDivPool;
};
//
// Бюджеты
//
struct PPBudget {
	PPBudget();
	int32  ObjType;
	int32  ID;
	char   Name[48];
	char   Code[20];
	int32  ParentID;
	LDATE  LowDt;
	LDATE  UppDt;
	long   Flags;
	int16  Cycle;
	char   Reserve[54];
};

typedef TSArray <BudgetItemTbl::Rec> BudgetItemsList;

class BudgetItemCore : public BudgetItemTbl {
public:
	BudgetItemCore();
	int    Search(PPID id, void * = 0);
	int    Search(PPID budgetID, PPID acc, PPID kind, LDATE dt, void * pRec);
	int    PutItem(PPID * pID, BudgetItemTbl::Rec *, int useTa);
	int    GetItemsByBudget(PPID budgetID, PPID accID, long kind, BudgetItemsList * pItems);
	int    PutItems(BudgetItemsList * pItems, int useTa);
	int    PutItem_(PPID * pID, BudgetItemTbl::Rec * pRec, int useTa);
};

class PPBudgetPacket {
public:
	PPBudgetPacket();
	PPBudgetPacket & FASTCALL operator = (const PPBudgetPacket &);
	void   Init();
	int    EnumItems(uint * pIdx, BudgetItemTbl::Rec * pRec);
	int    PutItems(const BudgetItemsList * pList);
	int    AddItem(BudgetItemTbl::Rec * pRec);
	int    UpdateItem(uint pos, BudgetItemTbl::Rec * pRec);
	int    DelItem(uint pos, PPID id);

	PPBudget Rec;
	TSArray <PPBudget> ScenList;
private:
	BudgetItemsList Items;
};

#define SEL_ALL_BUDGETS -1000000000L

class PPObjBudget : public PPObjReference {
public:
	explicit PPObjBudget(void * extraPtr = 0);
	~PPObjBudget();
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	int    EditLine(PPID * pID, PPIDArray * pIdList, PPID budgetID, LDATE dt);
	int    GetPacket(PPID id, PPBudgetPacket *);
	int    PutPacket(PPID * pID, PPBudgetPacket *, int use_ta);
	int    PutRec(PPID * pID, PPBudget *, int use_ta);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    AddLineBySample(PPID * pID, PPID sampleID);
	int    GetChildBudgets(PPID parentID, PPIDArray * pChildList);
	int    ValidateItem(BudgetItemTbl::Rec * pRec);
	int    InitItemsCycleList(const BudgetItemTbl::Rec * pRec, BudgetItemsList * pList);
	int    FormatDate(PPID budgetID, int16 cycle, LDATE dt, SString & rText);

	BudgetItemCore ItemsTbl;
private:
	int Helper_Edit(PPBudgetPacket * pPack);
	int Helper_EditLine(BudgetItemTbl::Rec * pRec);
	int Helper_EditLines(PPID initID, BudgetItemsList * pList);

	SString StrWeeks;
	SString StrMonthes;
	SString StrQuarts;
	SString StrSemiYear;
};
//
// Шаблоны бизнес-показателей
//
struct PPBizScTempl {
	long   Tag;            // Const=PPOBJ_BIZSCTEMPL
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	long   Flags;          //
	char   Reserve[68];    // @reserve
};

struct PPBizScTemplCol { // @flat
	enum {
		tDate = 0,
		tPeriod       = 1,
		tPeriodChange = 2
	};
	enum {
		fInvisible = 0x00000001L
	};
	long   Id;
	long   Flags;
	LDATE  DtLow;
	LDATE  DtUp;
	int16  Type;
	int16  Reserve1;
	char   Symb[24];
	char   Name[20];
	char   Reserve2[80];
};

struct PPBizScTemplRow { // @flat
	long   Id;
	PPID   BizScId;
	char   Name[20];
	char   Symb[24];
	char   Formula[128];
};

struct PPBizScTemplCell { // @flat
	long   Id;
	long   ColId;
	long   RowId;
	PPID   BizScId;
	char   Formula[128];
};

class PPBizScTemplPacket {
public:
	PPBizScTemplPacket();
	~PPBizScTemplPacket();
	PPBizScTemplPacket & FASTCALL operator = (const PPBizScTemplPacket &);
	void   Init();
	int    AddCol(uint * pPos, PPBizScTemplCol * pCol);
	int    GetCol(PPID colId, uint * pPos, PPBizScTemplCol * pCol);
	int    RemoveCol(uint pos);
	int    GetCellListInclEmpty(long colId, long rowId, TSVector <PPBizScTemplCell> * pCells);
	int    GetCellList(long colId, long rowId, TSVector <PPBizScTemplCell> * pCells);
	int    GetRow(PPID rowId, uint * pPos, PPBizScTemplRow * pRow);
	int    AddRow(uint * pPos, PPBizScTemplRow * pRow);
	int    RemoveRow(PPID rowId);
	int    AddCell(uint * pPos, PPBizScTemplCell * pCell);
	int    UpdateCell(uint * pPos, PPBizScTemplCell * pCell);
	int    CalcValues(long colId, long rowId, BizScoreCore * pBizScTbl, RealArray & rValList);

	PPBizScTempl Rec;
	TSVector <PPBizScTemplCol>  Cols;
	TSVector <PPBizScTemplRow>  Rows;
	TSVector <PPBizScTemplCell> Cells;
};

class PPObjBizScTempl : public PPObjReference {
public:
	explicit PPObjBizScTempl(void * extraPtr = 0);
	~PPObjBizScTempl();
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    GetPacket(PPID, PPBizScTemplPacket *);
	int    PutPacket(PPID *, PPBizScTemplPacket *, int use_ta);
private:
};
//
//
//
struct ObjCollectionEntry {
	ObjCollectionEntry();
	PPID   ObjType;
	PPObject * ObjPtr;
};

class ObjCollection : private TSArray <ObjCollectionEntry> {
public:
	ObjCollection();
	~ObjCollection();
	PPObject * FASTCALL GetObjectPtr(PPID objType);
	int    FASTCALL CreateFullList(long flags /* gotlfXXX */);
private:
	virtual void FASTCALL freeItem(void * pItem);
};
//
//
//
class GCTIterator {
public:
	struct GoodsRestEntry { // @flat
        PPID   GoodsID;
        PPID   LocID;
        LDATE  Dt;
        double Rest;
	};

	class GoodsRestArray : public TSVector <GoodsRestEntry> {
	public:
		GoodsRestArray();
		void   Init();
		int    SetAccumItem(PPID goodsID, PPID locID, LDATE dt, double qtty);
		int    SetInitRest(PPID goodsID, PPID locID, double rest);
		void   Finish();
		double GetRest(PPID goodsID, PPID locID, LDATE dt) const;
		double GetRest(PPID goodsID, LDATE dt) const;
		double GetAverageRest(PPID goodsID, PPID locID, const DateRange & rPeriod) const;
		double GetAverageRest(PPID goodsID, const DateRange & rPeriod) const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	private:
		enum {
			stAccumulation = 0x0001
		};
		long   State;
		DateRange AccumPeriod;
		PPIDArray LocList; // @!Sort()
	};
	struct ItemExtension {
		PPID   LinkBillID;
		double LinkQtty;
		double LinkCost;
		double LinkPrice;
	};

	enum {
		aorfGeneric        = 0x0001,
		aorfThereAreDrafts = 0x0002,
		aorfThereAreOrders = 0x0004,
		aorfOnlyDrafts     = 0x0008,
		aorfOnlyOrders     = 0x0010,
		aorfIntrRcpt       = 0x0020
	};
	static long  AnalyzeOp(PPID opID, PPIDArray * pResultOpList);

	GCTIterator(const GCTFilt * pFilt, const DateRange * pPeriod);
	~GCTIterator();
	int    First(TransferTbl::Rec *, BillTbl::Rec *);
	int    Next(TransferTbl::Rec *, BillTbl::Rec *);
	int    First(TransferTbl::Rec *, BillTbl::Rec *, ItemExtension * pExt);
	int    Next(TransferTbl::Rec *, BillTbl::Rec *, ItemExtension * pExt);
	const  GCTIterator::GoodsRestArray * GetGoodsRestList() const;
private:
	int    Iterate(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, ItemExtension * pExt);
	int    InitQuery(int cpMode);
	int    NextOuter();
	int    TrfrQuery(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    CpTrfrQuery(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    NextTrfr(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    NextCpTrfr(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    AcceptTrfrRec(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    AcceptCpTrfrRec(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    FASTCALL CheckBillForFilt(const BillTbl::Rec & rBillRec) const;
	int    FASTCALL SetupGoodsRest(TransferTbl::Rec * pRec);
	GCTFilt Filt;
	DateRange Period; //

	enum {
		stUseGoodsList   = 0x0001,
		stThereAreDrafts = 0x0002, // Среди видов операций для анализа присутствуют драфт-операции
		stThereAreOrders = 0x0004,
		stOnlyDrafts     = 0x0008,
		stOnlyOrders     = 0x0010
	};
	enum {
		bwNone  = 0,
		bwLot   = 1,
		bwBill  = 2,
		bwGoods = 3
	};
	enum {
		iterphaseInit   = 0,
		iterphaseTrfr   = 1,
		iterphaseCpInit = 2,
		iterphaseCpTrfr = 3
	};

	class GCT_BillCache {
	public:
		GCT_BillCache();
		int    SetupFilt(const GCTFilt * pFilt, const ObjIdListFilt & rArList, int disableCaching);
		int    FASTCALL Get(PPID billID, BillTbl::Rec * pRec);
		int    FASTCALL CheckBillForAgent(PPID billID) const;
	private:
		int    FASTCALL CheckBillRec(const BillTbl::Rec *);
		int    DisableCaching;
		PPObjBill * P_BObj;
		GCTFilt   Filt;
		ObjIdListFilt OpList;
		PPIDArray ExtIdList;   // Список идентификаторов документов, соответствующих Filt.AgentID (если это поле ненулевое).
		ObjIdListFilt ArList;  // Список контрагентов, выбранных по группирующему отношению к Person(Filt.ArID)
	};

	GCTIterator::GoodsRestArray * P_GoodsRestList;
	PPID   CurrID;
	int    ByWhat_;      // bwXXX
	int    IterPhase;    // iterphaseXXX
	long   SurrOprNo;    // Так как CpTransf не содержит поля OprNo эта переменная обеспечивает
		// суррогатный счетчик для обеспечения уникальности результирующих элементов итераций.
	long   State;
	Transfer   * Trfr;
	CpTransfCore * CpTrfr;
	BillCore   * BT;
	BExtQuery  * trfr_q;
	BExtQuery  * rcpt_q;
	BExtQuery  * cptrfr_q;
    struct CurrentBillBlock {
    	CurrentBillBlock();
    	~CurrentBillBlock();
    	void   Clear();

        PPBillPacket * P_Pack;
		PPBillPacket * P_WrOffPack; // Агрегированный пакет документов списания
    };
    CurrentBillBlock Cbb;
	GCT_BillCache * BCache;
	PPIDArray BillList;
	PPIDArray SupplAgentBillList; // Список документов, сопоставленных с агентом поставщика (Filt.SupplAgentID)
	PPIDArray GoodsArray;
	ObjIdListFilt OpList;  // @!GCTIterator::GCTIterator
	ObjIdListFilt ArList;  // Список контрагентов, выбранных по группирующему отношению к Person(Filt.ArID)
};
//
//
//
struct PrcssrUnifyPriceFilt : public PPBaseFilt { // @persistent
	PrcssrUnifyPriceFilt();
	int    Setup(int _costReval, PPID _loc, PPID _suppl);
	double CalcPrice(double cost, double price) const;
	bool   IsCostBase() const;

	enum {
		//fUnify    = 0x0001,
		fConfirm  = 0x0002,
		fCostBase = 0x0004, // При изменении цены по коэффициенту за базу принимать цену поступления //
			// Этот флаг может быть установлен только тогда, когда pctVal != 0. Если это не так, то возможны проблемы.
		fAverageCost     = 0x0008, // Усреднение цен поступления //
		fExcludeGoodsGrp = 0x0010, // Исключить указанную группу
		fAbsVal  = 0x0020, // При изменении цены, AbsVal - сумма наценки, иначе процент наценки
		//fLastLotOnly     = 0x0040  // Переоценивать только последний лот (если fUnify, то данный флаг не действует)
	};
	//
	// Descr: Режимы унификации цен и переоценки
	//
	enum {
		mLastLot = 1, // Переоценить только последний лот
		mUnify   = 2, // Унифицировать цены по всем лота, опираясь на цену последнего
		mEachLot = 3  // Переоценить каждый лот
	};
	//
	// Descr: Варианты источников новых цен
	//
	enum {
		psrcImplicit = 0,
		psrcQuot,
		psrcGtPriceRestrLow, // Нижнее ограничение цены из товарного типа
		psrcGtPriceRestrUpp, // Верхнее ограничение цены из товарного типа
	};
	uint8  ReserveStart[24]; // @anchor @reserve // @v11.1.12 [28]-->[24]
	long   PriceSource; // @v11.1.12 Источник формирования цены
	long   Mode;        // Режим унификации PrcssrUnifyPriceFilt::mXXX
	int    CostReval;   // Изменение цен поступления по поставщику
	PPID   OpKindID;
	PPID   LocID;
	PPID   GoodsGrpID;
	PPID   SupplID;
	PPID   QuotKindID; // Котировка, по которой следует высчитывать цены. if QuotKindID != 0 then PctVal ignored
	long   Flags;
	double PctVal;     // Процент изменения цен
	double OldPrice;   // старая цена
	short  RoundDir;   // Направление округления //
	uint16 Reserve;    // @alignment
	double RoundPrec;  // Точность округления    //
	long   ReserveEnd; // @anchor @reserve
};

class PrcssrUnifyPrice {
public:
	PrcssrUnifyPrice();
	int    Process(const PrcssrUnifyPriceFilt *);
	int    EditParam(PrcssrUnifyPriceFilt *);
private:
	int    ProcessGoods(const Goods2Tbl::Rec * pGoodsRec, PPID * pTurnedBillID);
	int    ProcessGoods2(const Goods2Tbl::Rec * pGoodsRec, PPID * pTurnedBillID);
	int    InitBillPack();
	int    TurnBillPack();
	int    CalcNewPrice(const ReceiptTbl::Rec & rLotRec, double * pPrice);
	int    Helper_GetPriceRestrictions_ByFormula(SString & rFormula, const PPGoodsPacket * pPack, const ReceiptTbl::Rec & rLotRec, double & rBound);

	PrcssrUnifyPriceFilt P;
	PPObjBill * P_BObj;
	PPObjGoods  GObj;
	PPObjQuotKind QkObj;
	PPBillPacket BPack;
};
//
// @ModuleDecl(PPViewBill)
//
enum BrowseBillsType {
	bbtUndef            = BBT_UNDEF,            //
	bbtGoodsBills       = BBT_GOODSBILLS,       //
	bbtOrderBills       = BBT_ORDERBILLS,       //
	bbtAccturnBills     = BBT_ACCTURNBILLS,     //
	bbtInventoryBills   = BBT_INVENTORYBILLS,   //
	bbtPoolBills        = BBT_POOLBILLS,        //
	bbtClientDebt       = BBT_CLIENTDEBT,       //
	bbtClientRPayment   = BBT_CLIENTRPAYMENT,   //
	bbtDraftBills       = BBT_DRAFTBILLS,       //
	bbtRealTypes        = BBT_REALTYPES,        // Товарные, бухгалтерские документы и оплаты
	bbtWmsBills         = BBT_WMSBILLS,         // Документы складских операций
	bbtSpcChargeOnMarks = BBT_SPC_CHARGEONMARKS //
};
//
// Descr: Фильтр выборки документов.
// @todo Заменить OpID на OpList дабы можно было отбирать документы по списку видов операций.
// @todo Фильтрация по тексту в примечании
//
class BillFilt : public PPBaseFilt, public PPExtStrContainer { // @v11.7.4 (public PPExtStrContainer)
public:
	struct FiltExtraParam {
		FiltExtraParam(long setupValues, BrowseBillsType bbt);
		long   SetupValues; // Если !0 то функция PPViewBill::CreateFilt установит в создаваемом
			// фильтре разумные параметры, основываясь не текущем состоянии.
		BrowseBillsType Bbt;
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке PPExtStrContainer
	//
	enum { // @persistent // @v11.7.4
		extssMemoText   = 1,
	};

	BillFilt();
	BillFilt & FASTCALL operator = (const BillFilt &);
	virtual int Describe(long flags, SString & rBuf) const;
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	//
	// Descr: Инициализирует поля фильтра.
	// ARG(setupVal   IN): Если этот параметр не нулевой, то устанавливает значения некоторых
	//   полей таким, образом, чтобы максимально соответствовать потребностям
	//   больщинства пользователей.
	// ARG(extraParam IN): Этот параметр должен иметь одно из значений BrowseBillsType.
	// Returns:
	//   >0 - инициализация завершилась успешно
	//   0  - ошибка
	//
	// int    Init(int setupValues, long extraParam);
	void   FASTCALL SetupBrowseBillsType(BrowseBillsType);
	//
	// Descr: Возвращает true если фильтр предусматривает множественное органичение по контрагенту документа.
	//
	bool   HasMultiArRestriction() const { return (ObjList.IsExists() || (P_ContractorPsnTagF && !P_ContractorPsnTagF->IsEmpty())); }
	enum bff_tag {
		fShowDebt          = 0x00000001, // Показывать долг
		fDebtOnly          = 0x00000002, // Выводить только неоплаченные документы
		// if(fOrderOnly) then выводить только не закрытые заказы
		fPaymNeeded        = 0x00000004, // Выводить документы, требующие оплаты (независимо от операции)
		fFreightedOnly     = 0x00000008, // Только зафрахтованные документы (BillTbl::Rec.Flags & BILLF_FREIGHT)
		fCashOnly          = 0x00000010, // Документы розницы через кассовый узел
		fOrderOnly         = 0x00000020, // Заказы
		fInvOnly           = 0x00000040, // Инвентаризация //
		fAsSelector        = 0x00000080, // Если флаг fAsSelector установлен, то броузер работает как
			// селектор. При этом, если был выбран какой-то документ, то поле sel содержит его идентификатор.
		fLabelOnly         = 0x00000100, // Показывать только меченые документы
		fAllCurrencies     = 0x00000200, // Показывать все валюты
		fAccturnOnly       = 0x00000400, // Только бухгалтерские документы
		fSetupNewBill      = 0x00000800, // Формировать поля нового док в соответствии с фильтром
		fDraftOnly         = 0x00001000, // Драфт-документы
		fDebtsWithPayments = 0x00002000, // Долговые документы с оплатами
		fPoolOnly          = 0x00004000, // Только пулы документов
		fShowAck           = 0x00008000, // Показывать с номерами подтверждений
		fEditPoolByType    = 0x00010000, // Изменения пула производить с помощью AssocID
		fIgnoreRtPeriod    = 0x00020000, // @internal Функция PPViewBill::Init не должна устанавливать пересечение this->Period с периодом доступа на чтение.
		fShowWoAgent       = 0x00040000, // Показывать только документы без агента
		fBillListOnly      = 0x00080000, // Если задан список документов List, то не проверять остальные
			// критерии фильтра. Если List.IsEmpty, то это флаг игнорируется.
		fWmsOnly           = 0x00100000, // Только документы складских операций
		fUnshippedOnly     = 0x00200000, // Только не отгруженные документы !(BillTbl::Rec::Flags & BILLF_SHIPPED)
		fShippedOnly       = 0x00400000, // Только отгруженные документы (BillTbl::Rec::Flags & BILLF_SHIPPED)
		fDiscountOnly      = 0x00800000, // Только со скидкой на весь документ
		fDescOrder         = 0x01000000, // Сортировка в обратном порядке
		fAddZeroLoc        = 0x02000000, // При построении выборки добавлять нулевую локацию к списку складов, по которому фильтруется отчет.
		fExportEDI         = 0x04000000, // Специальный флаг, используемый при экспорте
		fNoTempTable       = 0x20000000, // Не создавать временную таблицу, даже если условия фильтрации этого требуют
	};
	enum {
		fDenyAdd    = 0x0001,
		fDenyUpdate = 0x0002,
		fDenyRemove = 0x0004
	};
	enum cc_mode {
		ccmDebts    = 1,   // Долговые документы контрагента
		ccmRPayments       // Зачетные документы контрагента
	};
	enum {
		ordByDate     = 0,
		ordByCode     = 1,
		ordByObject   = 2,
		ordByDateCode = 3  // @v11.0.11 Сортировка по дате и номеру
	};
	//
	// Идентификаторы (дополнительных) полей для отображения в таблице //
	//
	enum {
		dliFreightIssueDate   = 1001, // Дата отправления (из фрахта)
		dliFreightArrivalDate,        // Дата доставки (из фрахта)
		dliDueDate,                   // Дата исполнения документа
		dliAgentName,                 // Наименование агента по документу
		dliAlcoLic,                   // Регистр алкогольной лицензии, ассоциированный (прямо или косвенно) с документом
		dliDlvrAddr,                  // Адрес доставки
		dliTSessLinkTo,               // @v11.6.12 Тех сессия, к которой привязан документ
		dliStdAmtCost,                // @v12.1.0 @construction Стандартная сумма в ценах поступления // 
		dliStdAmtPrice,               // @v12.1.0 @construction Стандартная сумма в ценах реализации //
	};
	char   ReserveStart[20]; // @anchor @v11.0.11 [32]-->[28] // @v11.1.9 [28]-->[24] // @v11.9.4 [24]-->[20]
	PPID   FreightPortOfDischarge; // @v11.9.4 @construction Порт (пункт) разгрузки (из фрахта документа) //
	PPID   CliPsnCategoryID; // @v11.1.9 Категория персоналии, соответствующей контрагенту документа
	PPID   GoodsGroupID;   // @v11.0.11 Товарная группа, ограничивающая выборку документов по содержимому
	long   Tag;            // @#0 reserved
	DateRange DuePeriod;   // Период исполнения //
	uint32 Count;          // Максимальное количество документов в выборке
	int16  Ft_Declined;    // Признак BILLF2_DECLINED: (0) ignored, (< 0) off, (> 0) on
	int16  Ft_CheckPrintStatus; // @v10.7.0 reserve-->Ft_CheckPrintStatus
	PPID   StorageLocID;   // Место хранение, ассоциированное с фрахтом документа
	int16  EdiRecadvStatus;     // Статус RECADV по каналу EDI. -1 - с нулевым статусом
	int16  EdiRecadvConfStatus; // Статус подтверждения на RECADV по каналу EDI. -1 - с нулевым статусом
	int16  OrderFulfillmentStatus; // @v11.1.8 Статус выполнения заказа (-1) unused (0) ignored, (1) полностью не исполнен, (2) - полностью исполнен, (3) - исполнен частично
	uint8  Reserve[6];     // @#0 !Использовать начиная со старших адресов // @v11.1.8 [8]-->[6]
	BrowseBillsType Bbt;   // @#1f
	DateRange Period;      //
	DateRange PaymPeriod;  // Период поступления платежей (Flags & fShowDebt)
	PPID   MainOrgID;      // Главная организация //
	PPID   PoolOpID;       // Ид операции пула (ограничивает выбор вида операции)
	PPID   OpID;           //
	PPID   CurID;          // Ид валюты
	PPID   AccSheetID;     // Если из операции нельзя определить таблицу статей, то эта таблица может быть взята из этого поля //
	PPID   ObjectID;       // ->Article.ID
	PPID   Object2ID;      // ->Article.ID
	PPID   PayerID;        // ->Article.ID Плательщик
	PPID   AgentID;        // ->Article.ID Агент
	PPID   CreatorID;      // ->Ref(PPOBJ_USR) Пользователь, создавший документ
	PPID   StatusID;       // ->Ref(PPOBJ_BILLSTATUS) Статус документа
	PPID   AssocID;        //
	PPID   PoolBillID;     // Обобщающий документ
	long   Flags;          //
	uint   DenyFlags;      //
	int16  ClientCardMode; // enum cc_mode (ccmXXX)
	int16  Ft_STax;        // (0) ignored, (< 0) off, (> 0) on
	int16  Ft_ClosedOrder; // (0) ignored, (< 0) off, (> 0) on
	int16  SortOrder;      // Сортировка
	PPID   Sel;            //
	RealRange AmtRange;    // Диапазон номинальной суммы
	long   ReserveEnd;     // @anchor
	SysJournalFilt * P_SjF; //
	ObjIdListFilt List;         // Список идентификаторов документов, которые следует показать
	ObjIdListFilt LocList;      // Список складов, по которым следует показывать документы
	ObjIdListFilt ObjList;      // @v11.7.4 @reserve Список контрагентов (не используем пока не понадобится)
	ObjIdListFilt Obj2List;     // @v11.7.4 @reserve Список дополнительных статей (не используем пока не понадобится)
	ObjIdListFilt AgentList;    // @v11.7.4 @reserve Список агентов (не используем пока не понадобится)
	ObjIdListFilt ReservedList; // @v11.7.4 @reserve Резервируем еще один список на будущее.
	TagFilt * P_TagF;        // Теги документов
	TagFilt * P_ContractorPsnTagF; // @v11.9.6 Теги персоналий, соответствующих основной статье документов
	PPViewDisplayExtList Dl; // Список дополнительных полей для отображения //
};

struct BillViewItem : public BillTbl::Rec {
	BillViewItem();
	double Debit;
	double Credit;
	double Saldo;
	LDATE  LastPaymDate; // Дата последнего платежа по документу
	char   SMemo[512];   // @v11.1.12
};

typedef int (*BillViewEnumProc)(const BillViewItem * pItem, void * pExtraPtr);

struct BillTotal {
	BillTotal();
	BillTotal & Z();

	long   Count;
	double Sum;
	double Debt;
	AmtList Amounts;
	//
	// Fields for debt card
	//
	double InSaldo;
	double Debit;
	double Credit;
	double OutSaldo;
};

class PPViewBill : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByDate,
		OrdByCode,
		OrdByObjectName,
		OrdByOpName,
		OrdByDateCode // @v11.0.11
	};

	PPViewBill();
	~PPViewBill();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void ViewTotal();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	int    EditFilt(BillFilt *, long) const;
	int    Browse(int modeless);
	int    AddItem(PPID * pID, PPID opID = 0);
	int    AddItemBySample(PPID * pID, PPID sampleBillID);
	int    AddBySCard(PPID * pID);
	int    EditItem(PPID);
	int    DeleteItem(PPID);
	int    Print();
	int    PrintTotal(const BillTotal *);
	int    PrintBillInfoList();
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(BillViewItem *);
	int    GetBillIDList(PPIDArray *);
	int    CalcTotal(BillTotal *);
	int    CalcItemTotal(PPID billID, BillTotalData & rTotal);
	int    ExportBnkOrder();
	int    ViewPayments(PPID, int kind);
	int    ViewBillsByOrder(PPID);
	int    WriteOffDraft(PPID);
	int    DeleteBillFromPool(PPID billID);
	int    AddBillToPool();
	int    AttachBillToOrder(PPID billID);
	int    AttachBillToDraft(PPID billID, const BrowserWindow * pBrw);
	int    AttachBill(PPID billID, const BrowserWindow * pBrw);
	int    CalcBillVATax(BVATAccmArray *);
	int    ViewVATaxList();
	int    ShowDetails(PPID billID);
	int    ShowPoolDetail(const PPBillPacket &);
	int    ChangeFlags();
	int    PrintBill(PPID billID);
	int    PrintAllBills();
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    Transmit(PPID billID, int transmitKind);
	int    UpdateAttributes();
	int    ExportGoodsBill(const PPBillImpExpParam * pBillParam, const PPBillImpExpParam * pBRowParam);
	int    CreateMrpTab(PPID billID);
	int    GetPacket(PPID billID, PPBillPacket * pPack) const; // <<PPALDD_BillInfoList::NextIteration
	int    CheckIDForFilt(PPID id, const BillTbl::Rec *);
	int    SetIterState(const void *, size_t sz);
	void * GetIterState();
	//
	// Descr: Возвращает указатель на кэшированный экземпляр пакета документа по идентификатору billID.
	//   Используется исключительно в рамках обработки потребностей структур DL600.
	//
	const  PPBillPacket * GetIterCachedBillPack(PPID billID);

	static int TransmitByFilt(const BillFilt * pFilt, const ObjTransmitParam * pParam);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);

	struct PoolInsertionParam {
		PoolInsertionParam();
		long   Verb;   // 1 - Insert New, 2 - Insert By Filt
		BrowseBillsType AddedBillKind;
		BillFilt Filt;
	};
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	bool   IsTempTblNeeded() const;
	int    CreateTempTable(IterOrder ord, int * pIsOrdTbl);
	int    UpdateTempTable(PPID id);
	//
	// Descr: Опции функции Enumerator
	//
	enum {
		enfSkipExtssMemo = 0x0001
	};
	int    Helper_EnumProc(PPID billID, const BillTbl::Rec *, int checkForFilt, uint flags /* enfXXX */, BillViewEnumProc proc, void * pExtraPtr);
		// @<<PPViewBill::Enumerator
	int    Helper_CheckIDForFilt(uint flags /* enfXXX */, PPID id, const BillTbl::Rec *);
	int    Enumerator(uint flags /* enfXXX */, BillViewEnumProc, void * pExtraPtr);
	int    EnumerateDebtCard(BillViewEnumProc, void * pExtraPtr);
	int    CalcDebtCardInSaldo(double *);
	int    GetOpList(const BillFilt *, PPIDArray *, PPID * pSingleOpID) const;
	int    FASTCALL CheckFlagsForFilt(const BillTbl::Rec * pRec) const;
	int    InitOrderRec(IterOrder ord, const BillTbl::Rec *, TempOrderTbl::Rec *);
	void   InitTempRec(const BillTbl::Rec *, TempBillTbl::Rec *);
	int    SelectBillListForm(uint * form, int * ext, IterOrder * order);
	int    InsertIntoPool(PPID billID, int use_ta);
	int    RemoveFromPool(PPID, int use_ta);
	int    UpdateInPool(PPID);
	int    IsMemberOfPool(PPID);
	int    EnumMembersOfPool(PPID * pBillID);
	int    SetupPoolInsertionFilt(BillFilt *);
	int    CreateTempPoolPacket(PPBillPacket *);
	int    GetCommonPoolAttribs(LDATE *, PPID * pLocID, PPID * pOpID, PPID * pObjID);
	int    SendAddBillMessage(PPID);
	int    UniteReceiptBills(); // @<<PPViewBill::UniteBills
	int    UniteSellBills();    // @<<PPViewBill::UniteBills
	int    UniteInventory();    // @<<PPViewBill::UniteBills
	int    Helper_ExportBnkOrder(const char * pSection, StringSet * pResultFileList, PPLogger & rLogger);
	int    EvaluateOrderFulfillmentStatus(PPID billID);

	BillFilt Filt;
	PPIDArray UpdateBillList; // для обновления измененнных документов в броузере
	uint   _IterC;            // Количество выполненных (успешных) итераций NextIteration
	PPID   SingleOpID;        //
	PPID   SingleLocID;       //
	PPID   LastSelID;         // Последний выбранный документ. Используется функцией AttachBillToOrder()
		// для последующего позиционирования курсора в таблице заказов.
	double InSaldo;           // For debt card
	void * P_IterState;       // Сохраняемое состояние итератора
	IterOrder TempOrder;      //
	PPObjLocation LocObj;     //
	PPObjArticle  ArObj;      //
	PPObjGoods    GObj;       //
	PPObjPerson   PsnObj;     // @v11.1.9
	PPObjBill    * P_BObj;    //
	TempBillTbl  * P_TempTbl; //
	TempOrderTbl * P_TempOrd; //
	PPIDArray OpList;         //
	PPIDArray LocList_;       //
	PPIDArray GoodsList;      // @v11.0.11 Список идентификаторов товаров, которые должны содержаться в документах выборки (в каждом документе хотя бы один из товаров)
	struct ArFilterBlock { // @v11.9.6 Блок фильтрации по полю BillTbl::Object
		// Важно: Списки InclList и ExclList содержат идентификаторы персоналий, а не аналитических статей!
		ArFilterBlock();
		ArFilterBlock & Z();
		bool   CheckID(PPID arID) const { return (!IsActual || (InclList.bsearch(arID) && !ExclList.bsearch(arID))); }
		bool   IsActual; // Если false, то фильтрация блоком не применяется //
		PPIDArray InclList; 
		PPIDArray ExclList;
	};
	ArFilterBlock ArFBlk;     // @v11.9.6
	ObjIdListFilt IdList;     // Список идентификаторов документов, которые должны быть в выборке
	PPBillPoolOpEx * P_BPOX;  // @# {(!Filt.PoolBillID && !Filt.PoolOpID) => P_BPOX==0}
	PoolInsertionParam Pip;   //
	PrcssrAlcReport * P_Arp;  //
	PPBillPacket * P_Dl600BPackCache; // @v12.2.0
	enum {
		stNoTempTbl = 0x0001, // Экземпляр не будет создавать временную таблицу, даже если условия фильтрации этого требуют.
		stCtrlX     = 0x0002,
	};
	long   State;
	friend int IterProc_CrTmpTbl(const BillViewItem *, void * pExtraPtr);
};
//
// @ModuleDecl(PPViewLinkedBill)
//
class LinkedBillFilt : public PPBaseFilt {
public:
	LinkedBillFilt();
	enum {
		//PPTXT_LINKBILLVIEWKINDS                "1,Оплаты по документу;2,Начисления ренты по документу;3,Зачеты по документу;4,Зачитывающие документы;6,Документы списания драфт-документа"
		// @v10.3.0 Значения (кроме 100) увеличены на 1 для того, чтобы нулевое значение стало сигнализировать неопределенность
		lkPayments       =   1,  // Оплаты по документу
		lkCharge         =   2,  // Начисления ренты по документу
		lkReckon         =   3,  // Зачеты по документу
		lkByReckon       =   4,  // Зачитывающие документы
		lkWrOffDraft     =   6,  // Документы списания драфт-документа
		lkCorrection     =   7,  // Документы корректировки
		lkOrdersByLading =   8,  // Документы заказа, к которым привязана данная отгрузка
		lkOrdAccomplish  =   9,  // @v12.0.11 Сопутствующие документы списания заказа в отгрузку
		lkSelection      = 100   // Режим выбора просмотра связанных документов при котором программа
			// самостоятельно пытается выбрать существующие связанные документы и при неоднозначности предоставляет выбор пользователю
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   BillID;           //
	int32  Kind__;           // PPTXT_LINKBILLVIEWKINDS
	long   Flags;            // @flags
	long   ReserveEnd;       // @anchor
};

struct LinkedBillViewItem : public BillTbl::Rec {
	double Payment;    //
	double Rest;       //
	int16  LinkKind;   // 1 - link, 2 - pool, 3 - writeoff link
	int16  Pad;        // @alignment
	PPID   LinkBillID__; // @v10.3.2 @fix LinkBillID-->LinkBillID__ (дублирует BillTbl::Rec::LinkBillID)
	PPID   RcknBillID; //
	char   _Memo[512]; // @v11.1.12
};

class PPViewLinkedBill : public PPView {
public:
	PPViewLinkedBill();
	~PPViewLinkedBill();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(LinkedBillViewItem * pItem);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	struct Entry {
		PPID   ID;
		double Payment;
		double Rest;
		int16  LinkKind;
		int16  Pad;
		PPID   LinkBillID; //
		PPID   RcknBillID; //
	};
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	int    MakeList();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	LinkedBillFilt Filt;
	TSArray <Entry> List;
	PPObjBill * P_BObj;
	PPObjBillStatus BsObj;
	BillTbl::Rec Rec; // Запись документа Filt.BillID.
	double PrevPaym;  // Сумма платежей по документу Filt.BillID до вызова Init_
	int    PrevKind;
	StrAssocArray MemoList;
};
//
// @ModuleDecl(PPViewGoodsBillCmp)
//
class GoodsBillCmpFilt : public PPBaseFilt {
public:
	GoodsBillCmpFilt();
	GoodsBillCmpFilt & FASTCALL operator = (const GoodsBillCmpFilt & s);

	enum {
		fDiffQttyOnly = 0x0001
	};
	enum Ord {
		ordByGoodsName = 1,
		ordByDiffQtty,
		ordByDiffPrice
	};

	uint8  ReserveStart[20]; // @anchor
	LDATETIME LhSingleEvDtm; // Если единственный ид в LhBillList - ид сохраненной версии документа, то здесь - момент изменения/удаления
	LDATETIME RhSingleEvDtm; // Если единственный ид в RhBillList - ид сохраненной версии документа, то здесь - момент изменения/удаления
	long   Flags;
	long   Order;
	int    WhatBillIsHistory;
	long   Reserve;          // @anchor
	PPIDArray LhBillList;
	PPIDArray RhBillList;
};

typedef TempGoodsBillCmpTbl::Rec GoodsBillCmpViewItem;

class PPViewGoodsBillCmp : public PPView {
public:
	PPViewGoodsBillCmp();
	~PPViewGoodsBillCmp();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	//
	// Перед вызовом этой функции в фильтре должны быть инициализированы поля //
	// LhBillID и RhBillID.
	//
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(GoodsBillCmpViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void * pHdr);
	int    PutBillToTempTable(PPID billID, int side /* 1 - lh, 2 - rh */, int isHistory, const LDATETIME & rSjTime);
	int    GetBillCodes(const GoodsBillCmpFilt *, SString & rLhCode, SString & rRhCode);
	int    AddToBasketAll(int diffSign);

	GoodsBillCmpFilt Filt;
	TempGoodsBillCmpTbl * P_TempTbl;
	int    IterIdx;
	PPObjGoods GObj;
	PPObjBill * P_BObj;
	HistBillCore Hb_;
};
//
//
//
struct InventoryViewItem : public InventoryTbl::Rec {
	SString FullGrpName;
};

class PPViewInventory : public PPView {
public:
	PPViewInventory();
	~PPViewInventory();
	virtual int  EditBaseFilt(PPBaseFilt * pFilt);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   Print(const void *);
	void   SetOuterPack(PPBillPacket * pPack);
	int    InitIteration();
	int    FASTCALL NextIteration(InventoryViewItem *);
	int    GetZeroByDefaultStatus() const;
	int    GetUpdateStatus() const;
	//
	// Descr: Рассчитывает сумму инвентаризации и сохраняет документ.
	// Returns:
	//   >0 - документ был успешно сожранен
	//   <0 - документ не был сохранен по-скольку billID == 0
	//   0  - ошибка
	//
	int    UpdatePacket(PPID billID);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	struct BrwHdr {
		PPID   BillID;
		long   OprNo;
		long   GoodsID;
		long   Flags;
	};
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    CheckLineForFilt(const InventoryTbl::Rec * pRec) const;
	int    EditLine(PPID billID, long * pOprNo, PPID goodsID, const char * pSerial, double initQtty, int accelMode);
	int    AddItem(TIDlgInitData * pInitData);
	int    SelectByBarcode(int initChar, PPViewBrowser * pBrw);
	int    SelectGoodsByBarcode(int initChar, PPID arID, Goods2Tbl::Rec * pRec, double * pQtty, SString * pRetCode);
	int    UpdateTempTable(PPID billID, long oprno);
	int    Build();
	int    Correct();
	int    ConvertBillToBasket();
	int    ConvertBasketToBill();
	int    ConvertBasket(const PPBasketPacket & rPack, int sgoption, int priceByLastLot, int use_ta);
	int    MakeTempOrdRec(const InventoryTbl::Rec * pRec, TempDoubleIDTbl::Rec * pOutRec);

	static int DynFuncInvLnWrOff;

	InventoryFilt Filt;
	enum {
		fIsZeroByDefault = 0x0001, // Операция документа инвентаризации подразумевает нулевой остаток по умолчанию.
		fSelGoodsByName  = 0x0002,
		fWasUpdated      = 0x0004
	};
	long   Flags;
	InventoryArray IterByGoods;
	InventoryCore InvTbl;
	PPObjGoods GObj;
	GoodsIterator * P_GIter;
	GoodsGroupIterator * P_GgIter;
	PPObjBill * P_BObj;
	InventoryTbl * P_TempTbl;
	TempDoubleIDTbl * P_TempOrd;
	TempInventorySubstTbl * P_TempSubstTbl;
	//
	// Descr: Структура, ассоциирующая пару {BillID, OprNo} с суррогатным ключом SurrID.
	//   Кроме того, структура хранит StorageLocID, ассоциированный с BillID (пока в таблицу Inventory
	//   не будет введено это поле).
	//
	struct ExtraEntry { // @flat
		ExtraEntry();
		PPID   SurrID;
		PPID   BillID;
        long   OprNo;
        PPID   GoodsID;
        PPID   StorageLocID;
	};
	TSVector <ExtraEntry> ExtraList;
	PPID   CommonLocID; // Если для всех документов из фильтра склад одинаков, то его значение присваивается CommonLocID.
		// В противном случае CommonLocID = 0.
	LDATE  CommonDate; // Если для всех документов из фильтра дата одинакова, то она присваивается CommonDate.
		// В противном случае CommonDate = ZERODATE;
	long   CommonIoeFlags; // Флаги, которые установлены в видах операций всех документов фильтра
	PPID   LastSurrID;
	StrAssocArray TextPool;
	GoodsSubstList    Gsl;
	PPObjBill::SubstParam Bsp; // Параметр подстановки по документам
	PPBillPacket * P_OuterPack; // @notowned Поставляемый из-вне пакет документа, соджержащий строки в поле P_OuterPack->InvList
};
//
// @moduledecl(PPViewQuoteReq)
//
class QuoteReqAnalyzeFilt : public PPBaseFilt {
public:
	QuoteReqAnalyzeFilt();
	enum {
		ordByDefault  = 0,
		ordByLeadBill = 1,
		ordBySeqBill  = 2,
	};
	uint8  ReserveStart[128]; // @anchor
	DateRange Period;
	PPID   OpID;
	PPID   ArID;
	PPID   LocID;
	long   Flags;
	long   SortOrd;
	long   ReserveEnd;        // @anchor
};

struct QuoteReqAnalyzeViewItem {
	PPID   LeadBillID;
	int    LeadRbb;
	PPID   LinkBillID;
	int    LinkRbb;
	PPID   GoodsID;
};

class PPViewQuoteReqAnalyze : public PPView {
public:
	struct BrwItem {
		PPID   LeadBillID;
		int    LeadRbb;
		LDATE  LeadDt;
		PPID   LeadArID;
		PPID   GoodsID;
		double ReqQtty;
		double ReqPrice;
		PPID   ReqCurID;
		int    ReqShipmTerm; // Требуемый срок поставки в днях
		PPID   LinkBillID;
		int    LinkRbb;
		LDATE  LinkDt;
		PPID   LinkArID;
		int    SeqAckStatus;
		double RepQtty;
		double RepPrice;
		PPID   RepCurID;
		int    RepShipmTerm; // Возможный срок поставки в днях
	};
	PPViewQuoteReqAnalyze();
	~PPViewQuoteReqAnalyze();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(QuoteReqAnalyzeViewItem *);
	static int CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
	int    FASTCALL CmpBrwItems(int ord, const BrwItem * p1, const BrwItem * p2);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    CreateList(PPID leadBillID, int leadRbb);
	int    FinishListBySeq(PPID leadBillID, int leadRbb);
	void   SortList(int ord);
	int    MakeViewList();
	int    CreateLinkedRequest(PPID leadBillID, int leadRbb);
	int    EditSeqItem(PPID seqBillID, int seqRbb);

	QuoteReqAnalyzeFilt Filt;
	PPObjBill * P_BObj;
	PPObjCurrency CurObj;
	TSArray <BrwItem> List;
	SArray * P_DsList;
};
//
// @ModuleDecl(PPViewAccturn)
// @todo Фильтрация по тексту в примечании
//
struct AccturnFilt : public PPBaseFilt {
	enum {
		fLastOnly      = 0x0001,
		fLabelOnly     = 0x0002,
		fAllCurrencies = 0x0004
	};
	AccturnFilt();
	AccturnFilt & FASTCALL operator = (const AccturnFilt &);

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   OpID;
	PPID   CurID;
	PPID   BillID;         // Показать проводки только по одному документу
		// одновременно должен быть установлен флаг fLastOnly. Остальные поля фильтра при этом не используются.
	uint   Flags;
	RealRange AmtR;
	int    GrpAco;         // Порядок счета, по которому следует группировать отчет. Если GrpAco == 0, то не группировать.
	//
	// Параметры отбора проводок по счетам
	// (для деталировки сгруппированного отчета)
	//
	int    Aco;
	Acct   DbtAcct;
	Acct   CrdAcct;
	//
	// Параметр для получения циклического отчета по периодам
	// If (GrpAco == 0 || (Flags & fLastOnly)), then ignored.
	//
	PPCycleFilt Cycl;
	long   Reserve; // @anchor
};

struct AccturnViewItem : public PPAccTurn {
	long   OprNo;
	PPID   DbtAccRelID;
	PPID   CrdAccRelID;
};

struct AccturnTotal {
	long   Count;
	AmtList Amounts;
};

class PPViewAccturn : public PPView {
public:
	struct Hdr {
		PPID Id;
	};
	PPViewAccturn();
	~PPViewAccturn();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	int    InitIteration();
	int    FASTCALL NextIteration(AccturnViewItem *);
	int    PrintItem(PPID billID);
	int    EditItem(PPID billID);
	int    DeleteItem(PPID billID);
	int    CalcTotal(AccturnTotal *);
	void   FormatCycle(LDATE dt, char * pBuf, size_t bufLen);
	int    ConvertGenAccturnToExtAccBill();
private:
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int Browse(int modeless);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual int  Print(const void *);
	int    CreateGrouping();
	int    AddBillToList(PPID billID);
	int    RemoveBillFromList(PPID billID);
	int    InitViewItem(const AccTurnTbl::Rec *, AccturnViewItem *);
	int    InitViewItem(const TempAccturnGrpngTbl::Rec *, AccturnViewItem *);

	static int DynFuncCheckRelRestrictions;
	static int DynFuncCurSymbByAccRelID;
	TempAssocTbl * P_TmpBillTbl;
	AccturnFilt Filt;
	TempAccturnGrpngTbl * P_TmpAGTbl;
	PPObjBill  * P_BObj;
	AccTurnCore * P_ATC;
	PPObjAccount AccObj;
	uint   IterBillPos;
	int    IterRByBill;
	PPIDArray    OpList;
	PPCycleArray CycleList;
};
//
// @ModuleDecl(PPViewLotOp)
// Операции по лоту
//
class LotOpFilt : public PPBaseFilt {
public:
	LotOpFilt();
	enum {
		fZeroLotOps = 0x0001
	};
	uint8  ReserveStart[24]; // @anchor
	PPID   LotID;
	long   Flags;
	long   Reserve;
};


struct LotOpViewItem : public TransferTbl::Rec {
	LotOpViewItem() : TransferTbl::Rec(), OldQtty(0.0), OldCost(0.0), OldPrice(0.0)
	{
	}
	double OldQtty;
	double OldCost;
	double OldPrice;
};

class PPViewLotOp : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		long   OprNo;
	};
	PPViewLotOp();
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(LotOpViewItem *);
	int    GetLotRec(ReceiptTbl::Rec *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  Detail(const void *, PPViewBrowser * pW);
	int    SearchOp(const BrwHdr * pHdr, TransferTbl::Rec * pRec);
	int    MoveOp(const BrwHdr * pHdr);
	int    Recover(const BrwHdr * pHdr);

	LotOpFilt Filt;
	PPObjBill * P_BObj;   // not owned by this
	enum {
		stAccsCost = 0x0001, // Текущему пользователю разрешен доступ к ценам поступления //
		stCtrlX    = 0x0002  // Была нажата комбинация Ctrl-X (для вызова специальной функции).
	};
	long   State;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	static int DynFuncLadingBill;
};
//
// @ModuleDecl(PPViewLot)
//   Анализ лотов
//
class LotFilt : public PPBaseFilt {
public:
	struct FiltExtraParam { // @v11.5.0
		enum {
			kRegular = 0,
			kOrders  = 1
		};
		explicit FiltExtraParam(int kind);
		int    Kind;
	};
	LotFilt();
	LotFilt(const LotFilt & rS);
	LotFilt & FASTCALL operator = (const LotFilt & rS);
	virtual int Describe(long flags, SString & rBuf) const;
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	int    GetExtssData(int fldID, SString & rBuf) const;
	int    PutExtssData(int fldID, const char * pBuf);
	enum {
		fWithoutQCert       = 0x00000008, // Показывать только лоты, у которых нет сертификата
		fOrders             = 0x00000010, // Лоты заказов
		fCostAbovePrice     = 0x00000020, // Только лоты, у которых цена поступления больше цены реализации
		fWithoutClb         = 0x00000040, // Лоты без ГТД
		fDeadLots           = 0x00000080, // Только те лоты, по которым не было движения //
		fWithoutExpiry      = 0x00000100, // Лоты, для которых не указан срок годности
		fOnlySpoilage       = 0x00000200, // Только лоты с бракованными сериями
		fShowSerialN        = 0x00000400, // Показывать серийные номера лотов
		fSkipNoOp           = 0x00000800, // Не показывать лоты, по которым не было операций за операционный период. Имеет смысл только если !Operation.IsZero()
		fCheckOriginLotDate = 0x00001000, // Учитывать дату оригинального лота в соответствии с заданным периодом
		fSkipClosedBeforeOp = 0x00002000, // Пропускать лоты, закрытые до операционного периода
		fNoTempTable        = 0x00004000, // Только для внутреннего использования.
		fShowBillStatus     = 0x00008000, // Показывать статус документа соответствующего лоту заказа
		fShowPriceDev       = 0x00010000, // Показывать признак отклонения цены от предыдущего лота этого товара по этому же складу
		fRestByPaym         = 0x00020000, // Спец опция: остаток рассчитывается как количество товара, не оплаченного поставщику.
		fInitOrgLot         = 0x00040000, // @v8.3.7 @construction Если установлен, то итератор инициализируте поле LotViewItem::OrgLotID
		fLotfPrWoTaxes      = 0x00080000, // Показывать только лоты, у которых установлен флаг LOTF_PRICEWOTAXES
		fCancelledOrdersOnly = 0x00100000, // @v12.1.6 Только отмененные заказы
		fShowAgent          = 0x00200000, // @v12.1.6 Показывать агента (вероятно, это актуально только для лотов заказов)
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке ExtString
	//
	enum { // @persistent
		extssSerialText    = 1,
		extssGoodsNameText = 2,
		extssGoodsCodeText = 3
	};
	//
	// Descr: Варианты ограничения выборки по изменению цены
	//
	enum {
		drNone = 0, // Не ограничивать
		drBelow,    // Только уменьшение
		drAbove,    // Только увеличение
		drAny       // Только изменения (лоты с неизмененными ценами не показывать) //
	};
	//
	// Descr: Варианты отображения наборов дополнительных столбцов
	//
	enum {
		exvaNone = 0,
		exvaEgaisTags,
		exvaVetisTags,
		exvaOrdPrefSupplModel, // @v12.1.6 Отображение заказов для учетной модели с предпочтельным поставщиком (отгрузка "с колес")
		exvaOrdMarketplace     // @v12.1.6 Отображение заказов на маркетплейсе
	};
	uint8  ReserveStart[12]; // @#0 @anchor !Использовать начиная со старших адресов // @v11.4.4 [20]-->[16] // @v12.1. [16]-->[12]
	PPID   AgentID;          // @v12.1.6 ->Article.ID
	PPID   SupplPsnCategoryID; // @v11.4.4 Категория персоналии, соответствующей поставщику лота (клиенту в случае с лотами заказов)
	long   ExtViewAttr;      // Параметр, определяющий набор дополнительных столбцов для отображения в таблице
	int16  CostDevRestr;     // LotFilt::drXXX
	int16  PriceDevRestr;    // LotFilt::drXXX
	PPID   ParentLotID;      // Ид лота, дочерние лоты которого следует выбрать. Если это поле не нулевое, то все остальные критерии не работают.
	DateRange Period;        // Период поступления лотов
	DateRange Operation;     // Операционный период (показывает остаток на начало, приход, расход, остаток на конец этого периода)
	DateRange ExpiryPrd;     // Период истечения срока годности по лотам
	DateRange QcExpiryPrd;   // Период истечения срока действия сертификатов
	PPID   LocID_Obsolete;   // ->Location.ID // @v10.6.8 obsolete(replaced with LocList)
	PPID   SupplID;          // ->Article.ID
	PPID   GoodsGrpID;       // ->Goods2.ID
	PPID   GoodsID;          // ->Goods2.ID
	PPID   QCertID;          // ->QCert.ID  Только лоты, к которым привязан этот сертификат
	PPID   InTaxGrpID;       // Налоговая группа, ассоциированная с лотом
	long   Flags;            // Флаги (LotFilt::fXXX)
	uint   ClosedTag;        // 0 - all, 1 - opened, 2 - closed
	uint8  Reserve2[32];     // @reserve
	RealRange CostRange;     // Диапазон цен поступления //
	RealRange PriceRange;    // Диапазон цен реализации  //
	long   Reserve;          // @anchor
	TagFilt * P_TagF;        // Фильтр по тегам
	SString ExtString;       // Дополнительные текстовые поля фильтра
	ObjIdListFilt LocList;   // Список складов
private:
	int    InitInstance();
};

struct LotTotal {
	enum Status {
		Undef = 0,
		Base,
		Extended
	} Stat;
	//
	// Base fields
	//
	long   Count;            // Количество лотов
	double Qtty;             // Общее пришедшее по лотам количество товара (в торговых единицах)
	double Rest;             // Общий текущий остаток по лотам (в торговых единицах)
	double Cost;             // Сумма остатка в ценах поступления //
	double Price;            // Сумма остатка в ценах реализации  //
	double OpRestBeg;        // Остаток на начало операционного периода
	double OpRestEnd;        // Остаток на конец операционного периода
	//
	// Extended fields
	//
	PPID   LocID;            //
	long   Progress;         //
	long   DCount;           // Количество порожденных лотов
	double InCost;           // Начальная сумма поступивших по лотам товаров в ценах поступления //
	double InPrice;          // Начальная сумма поступивших по лотам товаров в ценах реализации  //
	double DRest;            // Остаток порожденных лотов в тороговых единицах
	double DCost;            // Остаток порожденных лотов в ценах поступления //
	double DPrice;           // Остаток порожденных лотов в ценах реализации  //
};

struct LotViewItem : public ReceiptTbl::Rec {
	double BegRest;    // Остаток на начало операционного периода
	double EndRest;    // Остаток на конец операционного периода
	double QttyPlus;   // Приход за операционный период (количество)
	double QttyMinus;  // Расход за операционный период (количество)
	PPID   OrgLotID;   // Ид оригинального лота. Инициализируется только если
	LDATE  OrgLotDt;   // Дата поступления оригинального лота
	char   Serial[32]; // Серийный номер по лоту
};

class PPViewLot : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByDate,
		OrdByGoodsName
	};
	struct BrwHdr {
		PPID   ID;
		LDATE  Dt;
		long   SFlags;
	};
	PPViewLot();
	~PPViewLot();
	//
	// Descr: Создает и инициализирует фильтр.
	//   Если extraParam == 1, то в фильтре устанавливается флаг LotFilt::fOrders.
	//
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(LotViewItem *);
	int    GetItem(PPID, LotViewItem *);
	int    CalcTotal(LotTotal::Status, LotTotal * pTotal);
	int    ViewBillInfo(PPID billID);
	int    CheckForFilt(const ReceiptTbl::Rec & rRec);
private:
	static int   CalcChildLots(const ReceiptTbl::Rec *, void * extraPtr);
	static int   CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	bool   IsTempTblNeeded() const;
	int    CreateTempTable();
	int    PutAllToBasket();
	int    MovLotOps(PPID lotID);
	int    Export();
	int    ExportGoodsLabelData();
	int    RecoverLots();
	int    RevalCostByLots();
	int    EditLot(PPID);
	int    Debug();
	int    Init(int noTempTbl);
	int    FASTCALL AddDerivedLotToTotal(const ReceiptTbl::Rec * pRec);
	int    InsertTempRecsByIter(BExtInsert * pBei, long * pCounter, UintHashTable * pHt, int showPercentage = 0);
	int    AcceptViewItem(const ReceiptTbl::Rec & rLotRec, LotViewItem * pItem);
	int    UpdateTempTable(PPID lotID);
	int    MakeLotListForEgaisRetReg2ToWh(PPEgaisProcessor & rEp, PPID opID, PPID locID, RAssocArray & rList);

	LotFilt     Filt;
	PPIDArray   LocList;
	struct IterData {
		IterData();
		~IterData();
		void   Reset();

		PPIDArray PsnNativeCntryList;
		PPIDArray NativeCntryList;
		PPIDArray IdBySerialList;  // Список лотов, соответствующих серийному номеру LotFilt::Serial
		PPIDArray IdList;          // Список лотов, по которым осуществляется выборка
			// Этот список имеет приоритет над всеми критериями фильтрации. Более того, при переборе
			// по этому списку критерии фильтрации не проверяются.
		UintHashTable * P_ByTagList;       // Список лотов, удовлетворяющих фильтрации по тегам
		UintHashTable * P_ByTagExclList;   // Список лотов, не удовлетворяющих фильтрации по тегам
	};
	IterData Itd;
	PPObjGoods  GObj;
	PPObjQCert  QcObj;
	PPObjArticle ArObj;
	PPObjPerson PsnObj;
	PPObjBill * P_BObj;
	SpecSeriesCore * P_SpoilTbl;
	ReceiptCore * P_Tbl;
	TempLotTbl  * P_TempTbl;
	PPObjBill::PplBlock * P_PplBlkBeg; // Блок расчета неоплаченных поставщикам остатков по лотам на начало оп периода
	PPObjBill::PplBlock * P_PplBlkEnd; // Блок расчета неоплаченных поставщикам остатков по лотам на конец оп периода
	LotTotal Total;                    //
	ObjIdListFilt SupplList;           // Список поставщиков, выбранных по группирующему отношению к Person(Filt.ArID) // @v11.4.4 или по критерию Filt.SupplPsnCategoryID
	enum {
		stAccsCost   = 0x00001, // Текущему пользователю разрешен доступ к ценам поступления //
		stNoTempTbl  = 0x00002, // Экземпляр не будет создавать временную таблицу, даже если условия фильтрации этого требуют.
		stFiltSerial = 0x00004  // Текущий фильтр имеет не пустой критерий серийного номера (для экономии времени)
	};
	long   State;
};
//
// @ModuleDecl(PPViewLotExtCode)
//
class LotExtCodeFilt : public PPBaseFilt {
public:
	LotExtCodeFilt();

	char   ReserveStart[32]; // @anchor
	PPID   LotID;
	long   Flags;            //
	long   Reserve;          // @anchor
	SString SrchStr;
};

struct LotExtCodeViewItem {
	PPID   LotID;
	char   Code[128];
};

class PPViewLotExtCode : public PPView {
public:
	PPViewLotExtCode();
	~PPViewLotExtCode();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt * pFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(LotExtCodeViewItem *);
private:
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	int    GetRec(const void * pHdr, LotExtCodeTbl::Rec & rRec);
	int    CheckDupCode(const LotExtCodeTbl::Rec & rRec);

	LotExtCodeCore Tbl; // @v10.2.9 LotExtCodeTbl-->LotExtCodeCore
	LotExtCodeFilt Filt;
	PPObjBill * P_BObj;
};
//
// @ModuleDecl(PPViewAsset)
// Анализ основных средств
//
struct AssetFilt : public PPBaseFilt {
	AssetFilt();
	AssetFilt & FASTCALL operator = (const AssetFilt & s);

	enum {
		fUnwritedOffOnly = 0x0001, // Только несписанные
		fWritedOffOnly   = 0x0002, // Только списанные
		// если !(Flags & (fUnwritedOffOnly | fWritedOffOnly)) - то показывать и те и другие
		fShowClosed      = 0x0004  // Показывать закрытые (остаток == 0)
	};
	uint8  ReserveStart[32]; // @anchor @reserved
	DateRange Period;      //
	DateRange OperPeriod;  //
	PPID   GoodsGrpID;     //
	PPID   LocID;          //
	long   Flags;          // @flags
	int16  Ft_InExpl;      // (0) ignored, (<0) только не введенные в эксплуатацию, (>0) только введенные в эксплуатацию.
	int16  Reserve;        // @anchor @alignment
};

struct AssetViewItem {
	PPID   LotID;
	PPID   GoodsID;
	char   GoodsName[64];
	char   Serial[32];
	LDATE  Dt;
	LDATE  ExplDt;
	int16  WrOffTerm;
	double Cost;
	double Price;
	double Deprec;
	double Cost2;
	double Price2;
	double Deprec2;
	double DiffCost;
	double DiffDeprec;
	const  char * P_GoodsGrpName;
};

struct AssetTotal {
	long   Count;
	double Cost;
	double Price;
	double Deprec;
	double Cost2;
	double Price2;
	double Deprec2;
};

class PPViewAsset : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};

	PPViewAsset();
	~PPViewAsset();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(AssetViewItem *);
	int    GetItem(PPID lotID, AssetViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	int    MakeItem(PPID lotID, BExtInsert * pBei, int use_ta);
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();
	int    PrintList();

	AssetFilt Filt;
	PPObjGoods  GObj;
	PPObjBill * P_BObj;
	TempAssetTbl * P_TempTbl;
	int    IterIdx;
	GoodsGroupIterator * P_GGIter;
	SString IterGrpName;
};
//
// @ModuleDecl(PPViewFreight)
//
class FreightFilt : public PPBaseFilt {
public:
	FreightFilt();
	FreightFilt & FASTCALL operator = (const FreightFilt &);
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	enum {
		fUnshippedOnly     = 0x0001, // Только неотгруженные
		fFillLaggageFields = 0x0002, // Заполнять багажные поля (Brutto, PckgCount, Volume)
			// Расчет этих полей требует дополнительного времени вычисления.
		fUseCargoParam     = 0x0004, // Документы с установленным флагом "Грузовые параметры" // AHTOXA
		fStrictPort        = 0x0008, // Фильтрация по PortID и PortOfLoading - строго по
			// пункту назначения (не принимать во внимание адрес доставки и дочерние географические объекты)
		fShippedOnly       = 0x0010  // Только отгруженные
	};
	char   ReserveStart[20]; // @anchor // @v10.5.0 [24]-->[20]
	PPID   DlvrLocID;        // @v10.5.0
	PPID   StorageLocID;     // Место хранения
	PPID   PortOfLoading;    // Пункт погрузки
	DateRange BillPeriod;
	DateRange ShipmPeriod;
	DateRange ArrvlPeriod;
	PPID   LocID;
	PPID   OpID;
	PPID   ObjectID;
	PPID   ShipID;
	PPID   PortID;           // Пункт разгрузки
	PPID   CaptainID;
	long   Flags;
	long   Order;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
	TagFilt * P_TagF;        // @v10.3.11 Теги документов
};

struct FreightViewItem {
	PPID   BillID;        // -> Bill.ID
	LDATE  BillDate;      // = Bill.ID.Dt
	char   Code[48];      // = Bill.ID.Code // @v11.1.12 [24]-->[48]
	PPID   ObjectID;      // = Bill.ID.ObjectID
	PPID   AgentID;       // Ид агента по документу
	double Amount;        // = Bill.ID.Amount
	double Brutto;        // Масса брутто
	double PackCount;     // Количество упаковок
	double Volume;        // Объем (m*m*m)
	int16  IsShipped;     // Признак отгруженного документа
	int16  Reserve;       // @alignment
	LDATE  ShipmDate;     // Дата отправления //
	LDATE  ArrvlDate;     // Дата прибытия    //
	PPID   ShipID;        // ->Goods2.ID ИД транспортного средства
	char   ShipName[64];  // Наименование транспортного средства
	long   PortID;        // ->World.ID Порт назначения //
	char   PortName[48];  // Наименование порта назначения //
	long   DlvrAddrID;    // ->Location.ID ИД адреса доставки
	char   DlvrAddr[64];  // Наименование адреса доставки
};

class PPViewFreight : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByBillID,
		OrdByBillDate,
		OrdByArrivalDate,
		OrdByPortName,
		OrdByDlvrAddr
	};
	PPViewFreight();
	~PPViewFreight();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(FreightViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	int    GetBillList(ObjIdListFilt * pList);
	int    PrintBill(PPID billID/* @v10.0.0, int addCashSummator*/);
	int    PrintBillList();
	int    PrintAllBills();
	int    PrintBillInfoList();
	int    Export();
	int    FillTempTableRec(const BillTbl::Rec *, TempFreightTbl::Rec *);
	int    UpdateTempTableRec(PPID billID);
	int    UpdateFeatures();

	FreightFilt Filt;
	TempFreightTbl * P_TmpTbl;
	PPObjBill * P_BObj;
	PPObjTransport TrObj;
	PPObjWorld WObj;
	PPObjLocation LocObj;
	SStrGroup StrPool;    // Пул строковых полей, на который ссылаются поля в TempFreightTbl
};
//
// Predict
//
//
// Методы прогнозирования //
//
#define PRMTHD_SIMPLEAVERAGE 1 // Простое среднее
#define PRMTHD_LSLIN         2 // Линейая аппроксимация по методу наименьших квадратов

struct PPPredictConfig {   // @persistent @store(PropertyTbl)
	enum {
		fAddMinStockToOrder = 0x0001, // @obsolete[@v6.2.4] При расчете рекомендуемого заказа прибавлять минимальный запас
		fRoundPckgUp        = 0x0002, // Округлять до емкости упаковки вниз
		fRoundPckgDn        = 0x0004, // Округлять до емкости упаковки вверх
			// Если (fRoundPckgUp^fRoundPckgDn)==0, то округлять до ближайшего
		fZeroPckgUp = 0x0008, // Если при округлении до емкости упаковки получили 0, то округлять до 1-й упаковки
		fPrefStockPckg      = 0x0010, // Предпочтение отдавать емкости упаковки поставки в записи товара
		fPrefLotPckg        = 0x0020, // Предпочтение отдавать емкости упаковки из последнего лота
		fUseInsurStock      = 0x0040, // При расчете заказа поставщику учитывать минимальный запас
			// (то есть, расчет ведется из предположения, что к следующей поставке должен оставаться //
			// страховочный размер запаса товара).
		fContinueBuilding   = 0x0080, // Процесс построения таблицы был прерван.
			// При следующем запуске следует продолжить.
		fMinStockAsMinOrder = 0x0100, // Минимальный остаток по товару трактовать как минимальный заказ.
			// В этом случае формула расчета заказа выглядит так: Order = (Predict > MinStock) ? (Predict-MinStock) : (MinStock-Predict)
		fRoundManualQtty    = 0x0200  // При переносе в документ заказа количество, выставленное руками,
			// округлять по тому же правилу, что и автоматически рассчитанное.
	};
	enum {
		pckgDontUse = 0,
		pckgPrefStock,
		pckgPrefLot
	};
	enum {
		pckgRoundUp = 0,
		pckgRoundDn,
		pckgRoundNear
	};
	//
	// Эти 4 метода определены как статические ради того, что бы
	// их можно было использовать для класса SStatFilt для поля SStatFilt::_CFlags
	//
	static int  FASTCALL _GetPckgUse(long f);
	static int  FASTCALL _GetPckgRounding(long f);
	static long FASTCALL _SetPckgUse(long f, int t);
	static long FASTCALL _SetPckgRounding(long f, int t);

	PPPredictConfig();
	int    GetPckgUse() const { return _GetPckgUse(Flags); }
	int    GetPckgRounding() const { return _GetPckgRounding(Flags); }
	void   SetPckgUse(int t) { Flags = _SetPckgUse(Flags, t); }
	void   SetPckgRounding(int t) { Flags = _SetPckgRounding(Flags, t); }

	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PREDICTCFG
	PPID   OpID;           // Вид операции продаж (допустима обобщенная операция)
	PPID   PurchaseOpID;   // Вид операции закупки
	int16  FixArCodes;     //
	char   Reserve[4];     // @reserve
	int16  Method;         // PredictionMethod (PRMTHD_XXX)
	LDATE  StartDate;      // Дата начала учета продаж
	int16  P;              // Количество последних точек, по которым строится прогноз
	int16  Q;              //
	int16  TrustCriterion; // Критерий надежности прогноза
	int16  ImposingDays;   // Кол-во дней наложения (перекрытия)
	long   Flags;          //
	LDATE  EndCalcDate;    // Дата окончания рассчета прогноза, поддерживается ввод через @
	int16  DefInsurStock;  // Страховочный запас в днях по умолчанию (страховочный запас,
		// установленный для товара переопределяет это значение).
	int16  MinP;           // Минимальное число точек, при которых прогноз еще считается надежным
	//
	// Следующие параметры сохраняются после формирования очередного кванта
	// заполнения таблицы одновременно с установкой флага fContinueBuilding.
	// Если процесс был прерван, то продолжение пойдет с этими параметрами,
	// начиная с товара CbLastGoodsID+1
	//
	DateRange CbPeriod;
	PPID   CbLastGoodsID;
	long   CbProcess;
	long   CbFlags;
	PPID   CorrectKoeff;
	char   Reserve3[12];   // @reserve
};

class Predictor {
public:
	struct EvalParam {
		explicit EvalParam(SStatFilt * pFilt = 0);
		EvalParam & Set(const ObjIdListFilt * pLocList, PPID goodsID, const DateRange &);

		const  ObjIdListFilt * P_LocList;
		PPID   GoodsID;
		LDATE  LoadUpDate; // Если LoadUpDate != 0 && LoadUpDate < ModelPeriod.upp
			// тогда статистика продаж для прогноза извлекается до этой даты.
		DateRange Period;
		int    Method;
		int    P;
		int    MinP;
		int    TrustCriterion;
	};
	static int FASTCALL GetPredictCfg(PPPredictConfig *);
	static int PutPredictCfg(const PPPredictConfig *, int use_ta);
	Predictor();
	int    GetStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);
	int    Predict_(const EvalParam & rParam, double * pResult, PredictSalesStat *, int * pCanTrust = 0);
	int    IsWorkDay(const ObjIdListFilt * pLocList, LDATE);
protected:
	PPPredictConfig Cfg;
	PredictSalesCore T;
};

class PrcssrPrediction : public Predictor /*, public PPProcessor*/ {
public:
	struct Param { // @transient
		enum {
			rsUpdateOnly  = 1,
			rsReplaceExistance    = 2,
			rsRemoveAndReplaceAll = 3
		};
		enum {
			prcsFillSales  = 0x0001,
			prcsFillHoles  = 0x0002,
			prcsFillModel  = 0x0004,
			prcsTest       = 0x0008  // Режим тестирования //
		};
		enum {
			fRecalcByPeriod     = 0x0001,
			fRemoveContinueMode = 0x0002, // При запуске снять режим продолжения прерванного процесса
			fTestUpdatedItems   = 0x0004, // Тестировать только те товары, которые входят в измененные и созданные
				// за период this->Period документы.
			fUsePPViewGoodsRest = 0x0008  // Для расчета начальных остатков использовать PPViewGoodsRest
				// (вместо расчета для каждого отдельного товара)
		};
		//
		// Descr: Устанавливает период заполнения.
		// ARG(period IN): Может быть задан как абсолютной, так и в относительной форме.
		//
		void   FASTCALL SetPeriod(const DateRange & rPeriod);
		//
		// Descr: Возвращает период в том виде, как он задан
		//
		DateRange GetPeriod() const;
		//
		// Descr: Возвращает период в абсолютной форме (относительную форму пересчитывает по
		//   текущей системной дате)
		//
		DateRange GetNormPeriod() const;
	private:
		//
		// Descr: Период заполнения таблицы.
		//   Этот член приватный по причине того, что значения границ периода могут быть заданы
		//   как в абсолютной, так и в относительной форме (@-x).
		//   Для доступа к полю следует использовать методы SetPeriod, GetPeriod, GetNormPeriod
		//
		DateRange Period;
	public:
		PPID   LocID;
		PPID   GoodsGrpID;
		PPID   GoodsID;
		long   Replace;    // Param::rsXXX
		long   Process;    // Param::prcsXXX
		long   Flags;      // @flags Param::fXXX
		uint   GoodsQuant; // Квант товарных идентификаторов, по которому ведется заполнение
	};
	static int   EditPredictCfg();
	static int   IsLocked();
	PrcssrPrediction();
	~PrcssrPrediction();
	int    GetLastUpdate(PPID goodsID, const ObjIdListFilt & rLocList, LDATE *);
	const  IterCounter & GetIterCounter() const { return Counter; }
	int	   InitParam(Param *);
	int	   EditParam(Param *);
	int	   Init(const Param *);
	int	   Run();
	int    RecalcStat(LDATE commonLastDate, PredictSalesCore::StatStoreErr * pErr, int use_ta);
	//
	// Descr: Структура статистики по построению таблицы продаж
	//
	struct BuildStat {
		PredictSalesCore::StatStoreErr Sse;
		long   Time;       // Время построения в (sec)
		long   GoodsCount; // Количество товаров, по которым строилась таблица
		long   LocCount;   // Количество складов, по которым строилась таблица
		long   DayCount;   // Количество дней, за которые строилась таблица
		long   GoodsQuant; // Количество товаров в одном кванте построения //
		double AvgTimeG;   // Среднее время построения на одну товарную позицию (sec)
		double AvgTimeGD;  // Среднее время построения на одну товарную позицию в день (sec)
		double AvgTimeGL;  // Среднее время построения на одну товарную позицию по одному складу (sec)
		double AvgTimeGDL; // Среднее время построения на одну товарную позицию в день по одному складу (sec)
	};
	struct _GoodsLocRestItem { // @flat
		PPID   GoodsID;
		PPID   LocID;
		double Rest;
	};

	const BuildStat & GetBuildStat() const;
private:
	struct _MassGoodsRestBlock {
		DateRange Period;
		TSVector <PrcssrPrediction::_GoodsLocRestItem> List;
	};
	static int FASTCALL Lock(int unlock);
	int    ProcessGoodsList(PPIDArray & rGoodsList, const PrcssrPrediction::_MassGoodsRestBlock * pRestBlk, int calcStat, int use_ta);
	int    StoreStatByGoodsList(const PPIDArray & rGoodsList, LDATE commonLastDate, PredictSalesCore::StatStoreErr * pErr, int use_ta);
	int    SetupGoodsSaleByLoc(LocValEntry & rLvEntry, PPID goodsID, LDATE date, __HolidayArray & rHa, SArray * pVect);
	int    DeleteAllItems();
	int    DeleteItemsByPeriod(DateRange, PPID gGrpID, int use_ta);
	int    GetContinueMode(int checkOnly, PPID * pLastGoodsID);
	int    SetContinueMode(int reset, PPID lastGoodsID, int use_ta);
	int    CheckInterruption();
	int    FlashStat(PredictSalesStat * pList, uint count, PredictSalesCore::StatStoreErr * pErr, int use_ta);

	PPObjBill  * P_BObj;
	PPIDArray OpList;
	Param P;
	IterCounter Counter;
	BExtQuery * P_IterQuery;
	//
	LDATETIME TimerStart;
	ulong  MainIterCount;
	int    MaxTime;
	SString StopFileName;
	BuildStat Stat;
};
//
// @ModuleDecl(PPViewSales)
//
struct PredictSalesFilt : public PPBaseFilt {
	PredictSalesFilt();
	void   SetGoodsList(const PPIDArray *, const char * pSubstName);
	enum {
		fShowNoData = 0x0001 // Показывать дни, в которых не было остатка
	};
	uint8  ReserveStart[32];   // @anchor
	PPID   GoodsGrpID;         //
	PPID   GoodsID;            //
	DateRange Period;          //
	int16  Cycle;              // Длина группирующих циклов
	int16  Reserve;            // @alignment
	LDATE  Watershed;          // Дата отсчета циклов назад и вперед.
	long   Flags;              //
	SString SubstName;         // @anchor
	ObjIdListFilt LocList;     //
	ObjIdListFilt GoodsIdList; //
};

struct PredictSalesViewItem  {
	LDATE  Dt;
	double Qtty;
	double Amt;
	double QttyPredict;
	double QttyAbsErr;
	double QttyPctErr;
	double AmtPredict;
	double AmtAbsErr;
	double AmtPctErr;
};

#define FILLMETHOD_ARMA      1
#define FILLMETHOD_AVERAGE   2

struct PredictSalesTotal {
	long   Count;
	double QttySum;
	double QttyAverage;
	double QttySigma;
	double QttyStdDev;
	double AmtSum;
	double AmtAverage;
	double AmtSigma;
	double AmtStdDev;
};

class PPViewPredictSales : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		PPID   LocID;
		PPID   GoodsID;
	};
	enum IterOrder {
		OrdByDefault = 0
	};
	PPViewPredictSales();
	~PPViewPredictSales();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int aOrder = 0);
	int    FASTCALL NextIteration(PredictSalesViewItem *);
	int    CalcTotal(PredictSalesTotal *);
	void   FormatCycle(LDATE dt, char * pBuf, size_t bufLen) const;
private:
	struct TestParam {
		enum {
			fForceArma = 0x0001
		};
		int16  P;
		int16  Q;
		long   Flags;
	};
	static int EnumProc_CrTmpTbl(PredictSalesItem *, long);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void ViewTotal();
	int    InitCycleList(const PPIDArray * pGoodsList);
	int    ConvertHdr(const void * pHdr, BrwHdr * pOut) const;
	int    TestPrediction(const BrwHdr *);
	int    RecalcGoods(const BrwHdr *);
	int    ViewGraph(PPViewBrowser * pBrw);

	PredictSalesCore Tbl;
	PredictSalesFilt Filt;
	TempPredictSalesTbl * P_TempTbl;
	PPCycleArray CycleList;
	uint   CurIterOrd;
	double ErrAvg;    // Средняя ошибка прогнозирования (тест)
	TestParam TP;
};
//
// Descr: Вспомогательный класс, обеспечивающий однообразную запись в журналы
//   процесса обмена данными с глобальными сервисами. В качестве параметра
//   конструктора передается идентификатор строки имени файла журнала.
//   Например: PPFILNAM_UDSTALK_LOG ("uds-talk.log").
//
class PPGlobalServiceLogTalkingHelper {
public:
	explicit PPGlobalServiceLogTalkingHelper(uint logFileNameId);
	void   Log(const char * pPrefix, const char * pTargetUrl, const SString & rMsg);
private:
	SString LogFileName;
};
//
// @todo (Исправить структуру (порядок полей, выравнивание, метод Init - THISZERO плохо из-за SString))
//   Заменить на SupplInterchangeFilt
//
/* @v12.0.5 (устарел очень давно - элиминируем) struct SupplExpFilt {
	enum {
		expBills  = 0x0001,
		expRest   = 0x0002,
		expPrice  = 0x0004,
		expDelRecentBills = 0x0008,
		expFlatStruc      = 0x0010,
		expSaldo  = 0x0020
	};
	SupplExpFilt();
	void   Init();
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long) const;
	int    OpListFromCfg(const PPSupplAgreement::ExchangeParam * pCfg);
	int    OpListToCfg(PPSupplAgreement::ExchangeParam * pCfg);

	PPID   SupplID;
	PPID   GoodsGrpID;
	PPID   ExpendOp;
	DateRange Period;
	uint32 MaxFileSizeKB;
	long   Flags;
	PPID   TechID;
	ulong  IP;
	int16  Port;
	uint16 ProtVer;
	char   AddScheme[32];
	uint   AddRecType;
	double PctDis1;
	PPID   RcptOp;
	PPID   SupplRetOp;
	PPID   RetOp;
	PPID   MovInOp;
	PPID   MovOutOp;
	double PctDis2;
	PPID   PriceQuotID;
	char   ClientCode[16];
	SString EncodeStr;       // @anchor
	ObjIdListFilt LocList;
};*/

class SupplInterchangeFilt : public PPBaseFilt, public PPExtStrContainer {
public:
    SupplInterchangeFilt();
	SupplInterchangeFilt & FASTCALL operator = (const SupplInterchangeFilt & rS);
	// @v12.0.5 SupplInterchangeFilt & FASTCALL operator = (const SupplExpFilt & rS);

	enum { // @persistent
		extssOpSymbol   = 1,
		extssParam      = 2,
		extssAddScheme  = 3, // compatibility with SupplExpFilt::AddScheme
		extssEncodeStr  = 4, // compatibility with SupplExpFilt::EncodeStr
		extssClientCode = 5, // compatibility with SupplExpFilt::ClientCode

	};
	enum { // @persistent
		opNone = 0,
		opExportStocks     = 0x0001,     // EXPSTOCK
		opExportBills      = 0x0002,     // EXPBILL
		opExportDebts      = 0x0004,     // EXPDEBT
		opExportGoodsDebts = 0x0008,     // EXPGOODSDEBT
		opExportClients    = 0x0010,     // EXPCLI
		opExportPrices     = 0x0020,     // EXPPRICE
		opImportGoods      = 0x0040,     // IMPGOODS
		opImportRouts      = 0x0080,     // IMPROUT
		opImportOrders     = 0x0100,     // IMPORDER
		opImportDesadv     = 0x0200,     //
		opExportSales      = 0x0400      // EXPSALES
	};
	enum {
		fDeleteRecentBills   = 0x0001,     // BALTIKA only
		fFlatStruc           = 0x0002,     //
		fRepeatProcessing    = 0x0004,     // Флаг повторного процессинга уже обработанных данных (применение зависит от операции и провайдера)
		fTestMode            = 0x0008,     // Тестовый режим
		fExportTimeAsNominal = 0x0010      // @v11.6.7 В качаестве номинальной временной метки документов передавать время отправки (специально для GazpromNeft)
	};
    uint8  ReserveStart[24]; // @anchor
    float  SpcDisPct1; // Специальная скидка 1, %
    float  SpcDisPct2; // Специальная скидка 2, %
    PPID   SupplID;    // ->Article.ID
	long   Actions;
    long   Flags;
    DateRange ExpPeriod;
    DateRange ImpPeriod;
    uint   MaxTransmitSize;  // Максимальный размер передаваемых данных (KByte). 0 - не ограничено
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};

class PrcssrSupplInterchange {
public:
	class ExecuteBlock {
	public:
		ExecuteBlock();
		ExecuteBlock(const ExecuteBlock & rS);
		int    GetSequence(long * pSeq, int use_ta);
		void   GetLogFileName(SString & rFileName) const;

		PPSupplAgreement::ExchangeParam Ep;
		SupplInterchangeFilt P;
		SString ArName;    // Наименование поставщика
	public: // @v11.5.11 protected-->public
		enum {
			iglfWithArCodesOnly = 0x0001
		};
        int    InitGoodsList(long flags);
        int    FASTCALL IsGoodsUsed(PPID goodsID) const;
        const  PPIDArray * GetGoodsList() const;
		SString & XmlUtf8EncText(const char * pT);
		SString & XmlCp1251EncText(const char * pT);

		enum {
			bstGoodsListInited = 0x0001, // Список товаров GoodsList инициализирован
			bstAnyGoods        = 0x0002  // Нет ограничений на товары, по которым ведется обмен с поставщиком
		};
		PPObjGoods GObj;
		PPObjUnit  UObj;
		PPObjArticle ArObj;
		PPObjLocation LocObj;
		PPObjPerson   PsnObj;
		PPObjBill * P_BObj;
		SString LogFileName;
	private:
		PPID   SeqID;
		long   BaseState;
		PPIDArray GoodsList;
	};
	PrcssrSupplInterchange();
	~PrcssrSupplInterchange();
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int    Init(const PPBaseFilt * pBaseFilt);
	int    Run();
	//
	// Descr: Временная функция для переноса существующего кода
	//
    int    InitExecuteBlock(const SupplInterchangeFilt * pParam, ExecuteBlock & rBlk);
private:
	enum {
		stInited = 0x0001 // Был успешно вызван метод Init()
	};
	long   State;
	ExecuteBlock * P_Eb;
    PPObjArticle ArObj;
};
//
// 
//
struct PPMarketplaceConfig { // @construction
	PPMarketplaceConfig();
	PPMarketplaceConfig & Z();
	bool   IsEq_ForStorage(const PPMarketplaceConfig & rS) const;

	enum {
		fValid = 0x0001 // @transient Структура извлечена из базы данных
	};

	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_MRKTPLCCFG
	uint32 Flags;          // @flags
	PPID   OrderOpID;      // Вид операции заказа на маркетплейсе  
	PPID   SalesOpID;      // Вид операции продажи на маркетплейсе  
	PPID   TransferToMpOpID; // Вид операции передачи товара на маркетплейс (не совмещенная внутренняя передача, поскольку приходы на склады мп осущетсвляются сепаратно)
	PPID   ReturnOpID;     // @v12.1.11 Вид операции возврата от покупателя //
	PPID   CompensatedLostOpID; // @v12.2.1 Вид операции потерь на маркетплейсе, которые компенсируются маркетплейсом же //
	uint8  Reserve[40];    // @reserve  // @v12.1.11 [48]-->[44] // @v12.2.1 [44]-->[40]
	long   Reserve2[2];    // @reserve
};

class PPMarketplaceInterface {
public:
	virtual ~PPMarketplaceInterface();
	virtual int Init(PPID guaID);
	//
	int    GetMarketplacePerson(PPID * pID, int use_ta);
	const  char * GetSymbol() const { return P_Symbol; }
	int    CreateWarehouseFolder(PPID * pID, int use_ta);
protected:
	PPMarketplaceInterface(const char * pSymbol, PrcssrMarketplaceInterchange & rPrc);

	uint    State;
	PPObjPerson PsnObj;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	PrcssrMarketplaceInterchange & R_Prc;
private:
	const  char * P_Symbol;
};

class PPMarketplaceInterface_Wildberries : public PPMarketplaceInterface {
	// кВВ - коэффициент вознаграждения Вайлдберриз
public:
	struct FaultStatusResult {
		FaultStatusResult();
		FaultStatusResult & Z();
		bool   FromJson(const SJson * pJs);

		int    Status;
		LDATETIME Timestamp;
		SString StatusText;
		SString Title;
		SString Detail;
		SString Code;
		SString ReqId;
		SString Origin;
	};
	struct Warehouse {
		Warehouse();
		Warehouse & Z();
		bool FromJsonObj(const SJson * pJs);

		enum {
			fAcceptsQR = 0x0001,
			fSelected  = 0x0002  // Признак того, что склад уже выбран продавцом
		};
		long   ID; // Идентификатор склада на маркетплейсе (не в нашей базе данных!)
		uint   Flags;
		int    CargoType; // Тип товара, который принимает склад:
			// 1 - обычный; 2 - СГТ (Сверхгабаритный товар); 3 - КГТ (Крупногабаритный товар). Не используется на данный момент.
		int    DeliveryType; // Тип доставки, который принимает склад:
			// 1 - доставка на склад Wildberries; 2 - доставка силами продавца; 3 - доставка курьером WB
		uint64 UedGeoLoc;
		SString Name;
		SString City;
		SString Address;
	};
	struct ProductCategory {
		ProductCategory();
		ProductCategory & Z();
		bool FromJsonObj(const SJson * pJs);

		enum {
			fVisible  = 0x0001,
			fTopLevel = 0x0002
		};
		int64  ID;
		int64  ParentID;
		uint   Flags;
		SString Name;
		TSCollection <ProductCategory> SubjectList;
	};
	struct WareBase {
		WareBase();
		WareBase & Z();
		bool FromJsonObj(const SJson * pJs);

		int64  ID;
		SString Name;
		SString TechSize;
		SString SupplArticle;
		SString Barcode;
		SString Category;
		SString Brand;
	};
	struct WareOnPromotion {
		WareOnPromotion();
		WareOnPromotion & Z();
		bool   FromJsonObj(const SJson * pJs);
		int64  ID;           // Ид товара 
		uint64 UedCurrency;  // Валюта (в json - в формате ISO 4217)
		double Price;        // Текущая розничная цена
		double Discount;     // Текущая скидка
		double PlanPrice;    // Плановая цена (цена во время акции)
		double PlanDiscount; // Рекомендуемая скидка для участия в акции
		bool   InAction;     // Участвует в акции: true — да, false — нет
		uint8  Reseve[3];
	};
	struct Promotion {
		struct RangingItem { // @flat
			enum {
				cProductsInPromotion = 1, // продвижение получат товары продавца, участвующие в акции
				cCalculateProducts   = 2, // продвижение получат любые товара продавца, предложенные к участию в акции
				cAllProducts         = 3  // продвижение получат все товары продавца
			};
			int   Condition; // cXXX
			uint  ParticipationRate; // 
			uint  Boost;             //
		};
		Promotion();
		Promotion & Z();
		bool   FromJsonObj(const SJson * pJs);

		enum {
			tUndef = 0,
			tRegular,
			tAuto
		};
		int64 ID; // @firstmember
		SString Name;
		STimeChunk DtmRange;
		int   Type; // Promotion::tXXX
		//
		// Далее следуют дополнительные атрибуты акции, доступные посредством вызова RequestPromotionDetail()
		//
		SString Description; // Описание акции
		StringSet Advantages; // Набор строк описания достоинств акции
		int   InPromoActionLeftovers; // Количество товаров с остатками, участвующих в акции
		int   InPromoActionTotal; // Общее количество товаров, участвующих в акции
		int   NotInPromoActionLeftovers; // Количество товаров с остатками, не участвующих в акции 
		int   NotInPromoActionTotal;     // Общее количество товаров, не участвующих в акции
		int   ParticipationPercentage;   // Уже участвующие в акции товары, %. Рассчитывается по товарам в акции и с остатком
		int   ExceptionProductsCount;    // Количество товаров, исключенных из автоакции до её старта. Только при "type": "auto". В момент старта акции эти товары автоматически будут без скидки
		TSVector <RangingItem> RangingList; // 
	};
	struct Campaign {
		Campaign();

		int64  ID;
		int    Type; // Тип кампании:
			// 4 - campaign in catalog (deprecated type)
			// 5 - campaign in content (deprecated type)
			// 6 - campaign in search (deprecated type)
			// 7 - campaign in recommendations on the main page (deprecated type)
			// 8 - automatic campaign 
			// 9 - Auction 
		int    Status; // Статус кампании:
			// -1 - the campaign is in the process of being deleted
			// 4 - ready to be launched
			// 7 - campaign completed
			// 8 - declined
			// 9 - displays are ongoing
			// 11 - campaign is paused.
			//   Campaign in the process of deletion. The status means that the campaign has been deleted and will disappear 
			// from the method's response within 3-10 minutes.  
		LDATETIME ChangeDtm;
		//
		DateRange ReqPeriod; // Вспомогательное поле, позволяющее задать период запроса статистики по кампании
	};
	struct CampaignStatisticsUnit { // @flat
		CampaignStatisticsUnit();
		CampaignStatisticsUnit & Z();
		bool   FromJsonObj(const SJson * pJs);

		uint   ViewCount;   // "views"
		uint   ClickCount;  // "clicks" Number of clicks.
		uint   Atbs;        // "atbs" Number of products added to the basket.
		uint   OrderCount;  // "orders" Orders number.
		uint   Shks;        // "shks" Number of ordered products, pcs.
		double CRate;       // "cr" CR(conversion rate) is the ratio of the number of orders to the total number of visits to the campaign.
		double Ctr;         // "ctr" Clickability metric. The ratio of clicks to displays. Expressed as a percentage For all days, across all WB articles and platforms.
		double Cpc;         // "cpc" Average cost per click, ₽.
		double CostAmount;  // "sum" Expenses, ₽.
		double OrderAmount; // "sum_price" Orders amount, ₽
	};
	struct CampaignStatistics_Ware {
		CampaignStatistics_Ware();
		CampaignStatistics_Ware & Z();
		bool   FromJsonObj(const SJson * pJs);

		int64  WareId; // "nmId"
		SString WareName; // "name"
		CampaignStatisticsUnit S;
	};
	struct CampaignStatistics_App {
		CampaignStatistics_App();
		CampaignStatistics_App & Z();
		bool   FromJsonObj(const SJson * pJs);

		int    AppType; // Platform type (0 - undef, 1 - website, 32 - Android, 64 - IOS)
		CampaignStatisticsUnit S;
		TSCollection <CampaignStatistics_Ware> SList_Ware;
	};
	struct CampaignStatistics_Day {
		CampaignStatistics_Day();
		CampaignStatistics_Day & Z();
		bool   FromJsonObj(const SJson * pJs);

		LDATE Dt;
		CampaignStatisticsUnit S; // total for the whole period
		TSCollection <CampaignStatistics_App> SList_App;
	};
	struct CampaignStatistics_Adv {
		CampaignStatistics_Adv();
		CampaignStatistics_Adv & Z();
		bool   FromJsonObj(const SJson * pJs);

		int64  AdvertId;
		DateRange Period; // "interval"
		CampaignStatisticsUnit S; // total for the whole period
		TSCollection <CampaignStatistics_Day> SList_Day;
	};
	struct Stock {
		Stock();
		Stock & Z();
		bool FromJsonObj(const SJson * pJs);

		enum {
			fIsSupply      = 0x0001,
			fIsRealization = 0x0002,
		};
		LDATETIME DtmLastChange;
		WareBase Ware;
		SString WarehouseName;
		double Qtty;
		double QttyFull;
		double InWayToClient;
		double InWayFromClient;
		double Price;
		double Discount;
		uint   Flags;
	};
	struct Income  {
		Income();
		Income & Z();
		bool FromJsonObj(const SJson * pJs);

		int64  IncomeID;
		LDATETIME Dtm;
		LDATETIME DtmLastChange;
		SString Number; // Номер УПД
		WareBase Ware;
		double Qtty;
		double TotalPrice;
		LDATETIME DtmClose;
		SString WarehouseName;
		SString Status;
		/*
		"incomeId": 22650325,
		"number": "",
		"date": "2024-08-31T00:00:00",
		"lastChangeDate": "2024-09-03T16:12:09",
		"supplierArticle": "Lampasunone",
		"techSize": "0",
		"barcode": "2040705818355",
		"quantity": 30,
		"totalPrice": 0,
		"dateClose": "2024-09-03T00:00:00",
		"warehouseName": "Электросталь",
		"nmId": 245313051,
		"status": "Принято"
		*/
	};
	//
	// Descr: Структура описания элемента продажи или заказа
	//
	struct Sale {
		Sale();
		Sale & Z();
		bool FromJsonObj(const SJson * pJs);

		enum {
			fIsSupply      = 0x0001,
			fIsRealization = 0x0002,
			fIsCancel      = 0x0004  // Только для заказа 
		};
		LDATETIME Dtm;
		LDATETIME DtmLastChange;
		LDATETIME DtmCancel;      // order
		WareBase Ware;
		SString WarehouseName;
		SString CountryName;
		SString DistrictName;
		SString RegionName;
		int64  IncomeID;
		uint   Flags;
		double TotalPrice;
		double DiscountPct;
		double Spp;               // Скидка WB
		double PaymentSaleAmount; // sale Оплачено с WB Кошелька
		double ForPay;            // sale К перечислению продавцу
		double FinishedPrice;     // Фактическая цена с учетом всех скидок (к взиманию с покупателя)
		double PriceWithDiscount; // Цена со скидкой продавца, от которой считается сумма к перечислению продавцу forPay (= totalPrice * (1 - discountPercent/100))
		SString SaleId;           // Уникальный идентификатор продажи/возврата // S********** — продажа, R********** — возврат (на склад WB)
		SString OrderType;        // Тип заказа:
			// Клиентский — заказ, поступивший от покупателя
			// Возврат Брака — возврат товара продавцу
			// Принудительный возврат — возврат товара продавцу
			// Возврат обезлички — возврат товара продавцу
			// Возврат Неверного Вложения — возврат товара продавцу
			// Возврат Продавца — возврат товара продавцу
			// Возврат из Отзыва — возврат товара продавцу
			// АвтоВозврат МП — возврат товара продавцу
			// Недокомплект (Вина продавца) — возврат товара продавцу
			// Возврат КГТ — возврат товара продавцу
		SString Sticker; // Идентификатор стикера
		SString GNumber; // Номер заказа
		SString SrID;    // Уникальный идентификатор заказа. Примечание для использующих API Маркетплейс: srid равен rid в ответах методов сборочных заданий.
			// Проецируется на тег PPTAG_LOT_ORGORDERIDENT
	};
	
	struct SalesRepDbpEntry { // SalesReportDetailedByPeriod
		SalesRepDbpEntry();
		SalesRepDbpEntry & Z();
		bool FromJsonObj(const SJson * pJs);
		enum {
			// is_legal_entity
			fIsLegalEntity = 0x0001
		};
		int64  RepId;                 // realizationreport_id Номер отчёта
		int    RepType;               // report_type integer Тип отчёта: 1 — стандартный, 2 — для уведомления о выкупе
		uint   Flags;                 // @v12.2.0 
		DateRange Period;             // date_from, date_to
		LDATE  CrDate;                // create_dt
		char   CurrencySymb[8];       // currency_name
		SString SupplierContractCode; // suppliercontract_code : object // Договор
		int64  RrdId;                 // rrd_id Номер строки
		int64  IncomeID;              // gi_id Номер поставки
		SString SrID;                 // srid string Уникальный идентификатор заказа. Примечание для использующих API Marketplace: srid равен rid в ответах методов сборочных заданий.
			// Проецируется на тег PPTAG_LOT_ORGORDERIDENT
		WareBase Ware;                // Наименования полей отличаются от таких же в других методах!
			/*
				subject_name string Предмет
				nm_id integer Артикул WB
				brand_name string Бренд
				sa_name string Артикул продавца
				ts_name string Размер
				barcode string Баркод
			*/
		SString DocTypeName;            // Тип документа
		SString Warehouse;              // office_name Склад
		SString SupplOpName;            // supplier_oper_name Обоснование для оплаты
			// Возмещение издержек по перевозке/по складским операциям с товаром
			// Логистика
			// Пересчет платной приемки
			// Продажа
			// Удержание
			// Хранение
		LDATETIME OrderDtm;             // order_dt <date-time> Дата заказа. Присылается с явным указанием часового пояса
		LDATETIME SaleDtm;              // sale_dt <date-time> Дата продажи. Присылается с явным указанием часового пояса
		LDATETIME RrDtm;                // rr_dt <date-time> Дата операции. Присылается с явным указанием часового пояса
		int64  ShkId;                   // shk_id Штрих-код. Это - Sticker из заказа и продажи. 
		SString BoxTypeName;            // gi_box_type_name Тип коробов
		SString SupplPromo;             // supplier_promo number
		int64  RId;                     // Уникальный идентификатор заказа 
		int    Ppvz_OfficeId;           // ppvz_office_id integer Номер офиса
		int    Ppvz_SupplierId;         // ppvz_supplier_id integer Номер партнера
		SString AcquiringBank;          // acquiring_bank string Наименование банка-эквайера
		SString Ppvz_OfficeName;        // ppvz_office_name string Наименование офиса доставки
		SString Ppvz_SupplierName;      // ppvz_supplier_name string Партнер
		SString Ppvz_Inn;               // ppvz_inn string ИНН партнера
		SString Clb;                    // declaration_number string Номер таможенной декларации
		SString BonusTypeName;          // bonus_type_name string Обоснование штрафов и доплат. Поле будет в ответе при наличии значения
		SString Sticker;                // sticker_id string Цифровое значение стикера, который клеится на товар в процессе сборки заказа по схеме "Маркетплейс"
		SString Country;                // site_country string Страна продажи
		SString RebillLogisticOrg;      // rebill_logistic_org string Организатор перевозки. Поле будет в ответе при наличии значения
		SString Kiz;                    // Марка чзн 
		SString PaymentProcessing;      // @v12.2.0 Текст, вероятно, содержащий подробности операции 'Коррекция логистики'
		int    DeliveryCount;           // delivery_amount Количество доставок
		int    ReturnCount;             // return_amount   Количество возвратов
		double Qtty;                    // Количество
		double RetailPrice;             // Цена розничная
		double RetailAmount;            // Сумма продаж (возвратов)
		double SalePct;                 // Согласованная скидка
		double CommissionPct;           // Процент комиссии
		double RetailPriceWithDiscount; // retail_price_withdisc_rub Цена розничная с учетом согласованной скидки
		double DeliveryAmount;          // delivery_rub    Стоимость логистики
		double ProductDiscount;         // Согласованный продуктовый дисконт
		double Ppvz_Spp_Prc;          // ppvz_spp_prc Скидка постоянного покупателя   
		double Ppvz_Kvw_Prc_Base;     // ppvz_kvw_prc_base number Размер кВВ без НДС, % базовый
		double Ppvz_Kvw_Prc;          // ppvz_kvw_prc number Итоговый кВВ без НДС, %
		double Sup_Rating_Prc_Up;     // sup_rating_prc_up number Размер снижения кВВ из-за рейтинга
		double IS_Kgvp_V2;            // is_kgvp_v2 number Размер снижения кВВ из-за акции
		double Ppvz_Sales_Commission; // ppvz_sales_commission number Вознаграждение с продаж до вычета услуг поверенного, без НДС
		double Ppvz_For_Pay;          // ppvz_for_pay number К перечислению продавцу за реализованный товар
		double Ppvz_Reward;           // ppvz_reward	number Возмещение за выдачу и возврат товаров на ПВЗ
		double AcquiringFee;          // acquiring_fee number Возмещение издержек по эквайрингу. Издержки WB за услуги эквайринга: вычитаются из вознаграждения WB и не влияют на доход продавца.
		double AcquiringPct;          // acquiring_percent number Размер комиссии за эквайринг без НДС, %
		double Ppvz_Vw;               // ppvz_vw number Вознаграждение WB без НДС
		double Ppvz_Vw_Vat;           // ppvz_vw_nds number НДС с вознаграждения WB
		double Penalty;               // penalty number Штрафы
		double AdditionalPayment;     // additional_payment number Доплаты
		double RebillLogisticCost;    // rebill_logistic_cost number Возмещение издержек по перевозке. Поле будет в ответе при наличии значения
		double StorageFee;            // storage_fee number Стоимость хранения
		double Deduction;             // deduction number Прочие удержания/выплаты
		double Acceptance;            // acceptance number Стоимость платной приёмки
	};

	struct ApiTokenDecodeResult {
		ApiTokenDecodeResult() : Flags(0), ExpiryDtm(ZERODATETIME)
		{
		}
		enum {
			fTest             = 0x0001, // Тестовый контур
			fAccs_Content     = 0x0002, // Доступ к категории Контент
			fAccs_Analitycs   = 0x0004, // Доступ к категории Аналитика
			fAccs_Prices      = 0x0008, // Доступ к категории Цены и скидки
			fAccs_Marketplace = 0x0010, // Доступ к категории Маркетплейс
			fAccs_Statistics  = 0x0020, // Доступ к категории Статистика
			fAccs_Promo       = 0x0040, // Доступ к категории Продвижение
			fAccs_QAndReviews = 0x0080, // Доступ к категории Вопросы и отзывы
			fAccs_Chat        = 0x0100, // Доступ к категории Чат с покупателями
			fAccs_Deliveries  = 0x0200, // Доступ к категории Поставки
			fAccs_Returns     = 0x0400, // Доступ к категории Возвраты покупателями
			fAccs_Documents   = 0x0800, // Доступ к категории Документы
			fReadOnly         = 0x1000, // Токен только на чтение
		};
		S_GUID Id;
		S_GUID SellerId;
		uint64 Flags;
		LDATETIME ExpiryDtm;
	};
	static int ParseApiToken(const char * pToken, ApiTokenDecodeResult * pResult);
	static SString & MakeSerialIdent(int64 incomeId, const WareBase & rWare, SString & rBuf);

	PPMarketplaceInterface_Wildberries(PrcssrMarketplaceInterchange & rPrc);
	virtual ~PPMarketplaceInterface_Wildberries();
	virtual int Init(PPID guaID);
	//
	// Methods
	//
	int   RequestCommission();
	int   RequestWarehouseCoeffsBox();
	int   RequestWarehouseCoeffsPallet();
	int   RequestReturnTariff();
	//
	// Замечание по поводу методов RequestWarehouseList и RequestWarehouseList2.
	// Первый использует метод WB https://supplies-api.wildberries.ru/api/v1/warehouses,
	// второй - https://marketplace-api.wildberries.ru/api/v3/offices.
	// Я не понимаю кто все это там делал, но оба метода возвращают разные количества складов, с
	// несовместимыми идентификаторами и разными наименованиями. При этом все методы WB предоставляют только
	// наименованования скадов и далеко не всегда наименование в виде ссылки может быть сопоставлено
	// с каким-либо складом, возвращенным хоть первым, хоть вторым методом.
	// 
	// Короче говоря, сейчас будем закладываться на первый вариант (methWarehouses aka https://supplies-api.wildberries.ru/api/v1/warehouses)
	// а дальше посмотрим.
	//
	int   RequestWarehouseList(TSCollection <Warehouse> & rList, FaultStatusResult * pError);
	int   RequestWarehouseList2(TSCollection <Warehouse> & rList, FaultStatusResult * pError);
	int   RequestGoodsPrices();
	int   RequestGoodsSizes(int64 wbGoodsID);
	int   RequestIncomes(TSCollection <Income> & rList, FaultStatusResult * pError);
	int   RequestStocks(TSCollection <Stock> & rList, FaultStatusResult * pError);
	int   RequestOrders(TSCollection <Sale> & rList, FaultStatusResult * pError);
	int   RequestSales(TSCollection <Sale> & rList, FaultStatusResult * pError);
	int   RequestSupplies();
	int   RequestReturns();
	int   RequestAcceptanceReport(const DateRange & rPeriod);
	int   RequestSalesReportDetailedByPeriod(const DateRange & rPeriod, TSCollection <SalesRepDbpEntry> & rList, FaultStatusResult * pError);
	int   RequestBalance();
	int   RequestDocumentsList();
	int   UploadWare();
	int   RequestWareList();
	int   RequestProductCategoryList(TSCollection <ProductCategory> & rList);
	int   RequestProductSubjectList(TSCollection <ProductCategory> & rList);
	//methContentSubjectList,  // apiContent https://content-api.wildberries.ru/content/v2/object/all
	// @v12.2.2 {
	//
	// Descr: Запрашивает список акций
	//
	int   RequestPromotionList(TSCollection <Promotion> & rList);
	//
	// Descr: Запрашивает детальную информацию по акциям в списке rList
	//
	int   RequestPromotionDetail(TSCollection <Promotion> & rList);
	int   RequestPromotionWareList(int64 actionId, bool isInAction, TSCollection <WareOnPromotion> & rList);
	int   AddWareListToPromotion();
	// } @v12.2.2 
	//
	int   RequestPromoCampaignList(TSCollection <Campaign> & rList); // @v12.2.3
	int   RequestPromoCampaignListDetail(TSCollection <Campaign> & rList); // @v12.2.4 
	int   RequestPromoCampaignListStatistics(const DateRange * pCommonReqPeriod, const TSCollection <Campaign> & rList, TSCollection <CampaignStatistics_Adv> & rResult); // @v12.2.5 @construction
	int   CreateWarehouse(PPID * pID, int64 outerId, const char * pOuterName, const char * pAddress, int use_ta);
	const Warehouse * SearchWarehouseByName(const TSCollection <Warehouse> & rWhList, const char * pWhName, bool adoptive) const;
	int   ResolveWarehouseByName(const TSCollection <Warehouse> & rWhList, const char * pWhName, PPID defaultID, PPID * pResultID, int use_ta);
	int   ImportOrders();
	int   ImportReceipts();
	int   ImportSales();
	int   ImportFinancialTransactions();
	int   ImportStocks();
private:
	int   GetLocalCachePath(SString & rBuf);
	int   FetchWarehouseList(TSCollection <Warehouse> & rList);
	int   ParseJson_WarehouseList(const SJson * pJs, TSCollection <Warehouse> & rList);
	int   Helper_RequestWarehouseList(int meth/*methWarehouses||methWarehouses2*/, TSCollection <Warehouse> & rList, const char * pFileNameToStoreJson, FaultStatusResult * pError);
	int   InsertReceiptItem(PPBillPacket & rPack, const char * pSerial, PPID goodsID, double qtty);
	//
	// Descr: 
	// ARG(surrogateAutoLot IN): Признак того, что создается суррогатный приход, не имеющий соответствия реальному документу на маркетплейсе,
	//   поскольку маркетплейс по той или иной причине не предоставил соответствующей информации.
	// Returns:
	//   0 - error
	//   >0 - ид лота
	//
	PPID  CreateReceipt(int64 incomeId, const WareBase & rWare, LDATE dt, PPID locID, PPID goodsID, double qtty, bool surrogateAutoLot, int use_ta);
	PPID  CreateBuyer(const Sale * pSaleEntry, int use_ta);
	PPID  CreateWare(const WareBase & rWare, int use_ta);
	int   FindShipmentBillByOrderIdent(const char * pOrgOrdIdent, PPIDArray & rShipmBillIdList);
	//
	// Descr: 
	// Returns:
	//   0 - error
	//   >0 - ид лота, к которому должна быть привязана продажа
	//
	PPID  AdjustReceiptOnExpend(/*const Sale & rWbItem*/const WareBase & rW, int64 incomeId, LDATE dt, PPID locID, PPID goodsID, double neededQtty, double nominalPrice, int use_ta);
	int   SearchOriginalLotForMp(const char * pSerial, LDATE dt, PPID locID, PPID goodsID, PPID * pResultLotID);
	SString & MakeHeaderFields(const char * pToken, StrStrAssocArray * pHdrFlds, SString & rBuf) const;
	//
	//
	//
	enum {
		apiUndef = 0,
		apiCommon = 1,
		apiStatistics,
		apiSellerAnalytics,
		apiAdvert,
		apiRecommend,
		apiSupplies,
		apiDiscountsPrices,
		apiContent,
		apiMarketplace,
		apiAnalytics,
		apiDocuments,
		apiDpCalendar // @v12.2.2
	};
	enum {
		methCommission = 1,   // apiCommon
		methTariffBox,        // apiCommon https://common-api.wildberries.ru/api/v1/tariffs/box
		methTariffPallet,     // apiCommon 
		methTariffReturn,     // apiCommon
		methWarehouses,       // apiSupplies
		methWarehouses2,      // apiMarketplace https://marketplace-api.wildberries.ru/api/v3/offices
		methIncomes,          // apiStatistics
		methStocks,           // apiStatistics
		methOrders,           // apiStatistics
		methSales,            // apiStatistics
		methSalesReportDetailedByPeriod, // apiStatistics https://statistics-api.wildberries.ru/api/v5/supplier/reportDetailByPeriod
		methSupples,          // apiMarketplace https://marketplace-api.wildberries.ru/api/v3/supplies Получить список поставок
		methSupply,           // apiMarketplace https://marketplace-api.wildberries.ru/api/v3/supplies/{supplyId} Получить поставку
		methSupplyOrders,     // apiMarketplace https://marketplace-api.wildberries.ru/api/v3/supplies/{supplyId}/orders Получить сборочные задания в поставке
		methAcceptanceReport, // apiAnalytics   https://seller-analytics-api.wildberries.ru/api/v1/analytics/acceptance-report
		methGoodsPrices,      // apiDiscountsPrices https://discounts-prices-api.wildberries.ru/api/v2/list/goods/filter
		methGoodsSizes,       // apiDiscountsPrices https://discounts-prices-api.wildberries.ru/api/v2/list/goods/size/nm
		methContentCardsList, // apiContent https://content-api.wildberries.ru/content/v2/get/cards/list
		methContentCategoryList, // apiContent https://content-api.wildberries.ru/content/v2/object/parent/all
		methContentSubjectList,  // apiContent https://content-api.wildberries.ru/content/v2/object/all
		methBalance,          // apiAdvert https://advert-api.wildberries.ru/adv/v1/balance
		methDocumentsList,    // apiDocuments https://documents-api.wildberries.ru/api/v1/documents/list 
		methReturns,          // apiAnalytics   https://seller-analytics-api.wildberries.ru/api/v1/analytics/goods-return
		
		methPromotions,       // apiDpCalendar  https://dp-calendar-api.wildberries.ru/api/v1/calendar/promotions
		methPromotionsDetail, // apiDpCalendar  https://dp-calendar-api.wildberries.ru/api/v1/calendar/promotions/details
		methPromotionsGoods,  // apiDpCalendar  https://dp-calendar-api.wildberries.ru/api/v1/calendar/promotions/nomenclatures
		methPromotionsAddGoods, // apiDpCalendar  https://dp-calendar-api.wildberries.ru/api/v1/calendar/promotions/upload
		methPromoCampaignCount, // apiAdvert https://advert-api.wildberries.ru/adv/v1/promotion/count
		methPromoCampaignDetail, // apiAdvert https://advert-api.wildberries.ru/adv/v1/promotion/adverts
		methPromoCampaignsStatistics, // apiAdvert https://advert-api.wildberries.ru/adv/v2/fullstats
	};
	bool   MakeTargetUrl_(int meth, int * pReq/*SHttpProtocol::reqXXX*/, SString & rResult) const;
	int    Helper_InitRequest(int meth, SString & rUrlBuf, StrStrAssocArray & rHdrFlds);

	SString Token;
	PPGlobalServiceLogTalkingHelper Lth;
	TSCollection <Warehouse> WhList;
	PPIDArray MpLocList; // Список идентификаторов складов маркетплейса, применяемых при обработке документов
	LAssocArray MpLotToOwnLotAssocList; // Специализированный кэш, хранящий ассоциации между лотами на складах маркетплейса и лотами,
		// из которых они образовались на собственных складах. Фактически, этот массив кэширует результат работы функции SearchOriginalLotForMp
};

class MarketplaceInterchangeFilt : public PPBaseFilt {
public:
	MarketplaceInterchangeFilt();
	MarketplaceInterchangeFilt & FASTCALL operator = (const MarketplaceInterchangeFilt & rS);

    uint8  ReserveStart[128]; // @anchor
	PPID   GuaID;
	long   Actions;
    long   Flags;
	long   Reserve;          // @anchor	
};

class PrcssrMarketplaceInterchange {
public:
	static int  FASTCALL ReadConfig(PPMarketplaceConfig *);
	static int  FASTCALL WriteConfig(PPMarketplaceConfig *, int use_ta);
	static int  EditConfig();

	enum {
		acfUseExOrderOp = 0x0001,
		acfUseExSaleOp  = 0x0002,
	};

	static int  AutoConfigure(PPMarketplaceConfig & rCfg, uint flags, int use_ta); // @v12.2.1 @construction
	//
	// Descr: Возвращает идентификатор таблицы аналитического учета, соответствующей маркетплейсам (вид персоналий PPPRK_MARKETPLACE).
	// Returns:
	//   0 - искомая таблица не найдена
	//  >0 - идентификатор искомой таблицы аналитических статей
	//
	static PPID   GetMarketplaceAccSheetID();

	PrcssrMarketplaceInterchange();
	~PrcssrMarketplaceInterchange();
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int    Init(const PPBaseFilt * pBaseFilt);
	int    Run();
	//
	const PPMarketplaceConfig & GetConfig() const { return Cfg; }
	const PPGlobalUserAccPacket & GetGuaPack() const { return GuaPack; }
	PPLogger & GetLogger() { return Logger; }
	PPMarketplaceInterface * GetIfc() { return P_Ifc; }
	PPID   GetOrderOpID();
	PPID   GetSaleOpID();
	PPID   GetRetOpID(); // @v12.1.11
	//
	// Descr: Возвращает ид вида операции, используемой для фиксации факта потери товара по вине маркетплейса и компенсированной 
	//   маркетплейсом. 
	//   Вид операции должен относится к типу PPOPT_GOODSEXPEND.
	//
	PPID   GetCompensatedLostOp(); // @v12.2.1
	//
	// Descr: Возвращает идентификатор таблицы аналитического учета, содержащей статьи операций на маркетплейсах.
	// Note: таблица имеет символ MARKETPLACE-OPS
	// Returns:
	//   0 - искомая таблица не найдена
	//  >0 - идентификатор искомой таблицы аналитических статей
	//
	PPID   GetMarketplaceOpsAccSheetID();
	PPID   GetMarketplaceWarehousesAccSheetID();
	PPID   Helper_GetMarketplaceOpsAccSheetID(bool createIfNExists, bool createArticles, int use_ta);
	static PPID Helper_GetMarketplaceWarehousesAccSheetID(bool createIfNExists, int use_ta);
	PPID   Helper_GetMarketplaceOpsAccount(bool createIfNExists, int use_ta);
	int    EvaluateAverageRest(PPID goodsID, const DateRange & rPeriod, double * pResult);
private:
	int    ReloadGuaPack();

	enum {
		stInited = 0x0001
	};
	PPMarketplaceInterface * P_Ifc;
	long   State;
	PPGlobalUserAccPacket GuaPack;
	PPMarketplaceConfig Cfg;
	PPObjArticle ArObj;
	PPLogger Logger;
};
//
//
//
class PrcssrAptekaRuFilt : public PPBaseFilt { // @persistent
public:
	PrcssrAptekaRuFilt();
	PrcssrAptekaRuFilt & FASTCALL operator = (const PrcssrAptekaRuFilt & rS);

	enum {
		fTest = 0x0001, // Тестовый процессинг
	};
	uint8  ReserveStart[28]; // @ancor
	PPID   LocID;
	long   Flags;
	PPID   GuaID;
	PPID   RcptOpID;
	PPID   RcptTagID;
	DateRange Period;
	uint8  ReserveEnd[32]; // @anchor
};

class PrcssrAptekaRu {
public:
	PrcssrAptekaRu();
	int    InitParam(PrcssrAptekaRuFilt * pParam);
	int    Init(const PrcssrAptekaRuFilt * pParam);
	int    EditParam(PrcssrAptekaRuFilt * pParam);
	int    Run();
private:
	PrcssrAptekaRuFilt P;
};
//
// 
// 
class PrcssrClientActivityStatisticsFilt : public PPBaseFilt { // @persistent
public:
	PrcssrClientActivityStatisticsFilt();
	PrcssrClientActivityStatisticsFilt & FASTCALL operator = (const PrcssrClientActivityStatisticsFilt & rS);

	uint8  ReserveStart[32]; // @ancor
	DateRange Period;
	PPID   PersonKindID;
	uint8  ReserveEnd[32]; // @anchor
};

class PrcssrClientActivityStatistics { // @v12.2.2
public:
	PrcssrClientActivityStatistics();
	int    InitParam(PrcssrClientActivityStatisticsFilt * pParam);
	int    Init(const PrcssrClientActivityStatisticsFilt * pParam);
	int    EditParam(PrcssrClientActivityStatisticsFilt * pData);
	int    Run();
	int    ScanDetailedActivityListForSinglePerson(PPID personID, TSVector <ClientActivityDetailedEntry> & rList);
private:
	TSVector <ClientActivityDetailedEntry> & SortDetailedEntryList(TSVector <ClientActivityDetailedEntry> & rList);
	int    Implement_ScanDetailedActivityListForSinglePerson(PPViewBill * pBillV, PPID personID, TSVector <ClientActivityDetailedEntry> & rList);
	int    Implement_ScanDetailedActivityListForSinglePerson_SCard(PPID personID, const PPIDArray * pSCardSerIdList, const DateRange & rPeriod, TSVector <ClientActivityDetailedEntry> & rList);
	int    EvaluateStorableStat(PPID personID, const TSVector <ClientActivityDetailedEntry> & rSrcList, PPObjPerson::ClientActivityStatistics & rTotalEntry, TSVector <uint16> & rDateList);
	PPObjPerson PsnObj;
	PPObjArticle ArObj;
	PPPersonConfig PsnCfg;
	PPObjPersonEvent PeObj;
	PPObjSCard ScObj;
	PPObjBill * P_BObj;
	PrcssrClientActivityStatisticsFilt P;
};
//
// @ModuleDecl(PPViewGoodsRest)
//
class GoodsRestFilt : public PPBaseFilt {
public:
	GoodsRestFilt();
	enum {
		eqxExhaustTerm = 0x0001
	};
	int    IsEqualExcept(const GoodsRestFilt & rS, long flags) const;
	virtual int Describe(long flags, SString & rBuf) const;
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver); // @v11.4.6
	//
	// Descr: Устанавливает признак использования котировки QuotKindID.
	// ARG(v IN):
	//   0 - не использовать (!(Flags & fPriceByQuot) && !(Flags2 & f2CostByQuot))
	//   1 - использовать как дополнение к цене реализации (Flags & fPriceByQuot)
	//   2 - использовать в качестве замещения цены поступления (!(Flags & fPriceByQuot) && (Flags2 & f2CostByQuot))
	//   все остальные значения трактуются как ошибочные и не изменяют состояния фильтра.
	// Returns:
	//   >0 - состояние трактовки котировок установлено
	//   <0 - состояние трактовки котировок не изменилось
	//   0 -  ошибочный параметр (состояние трактовки котировок не изменилось)
	//
	int    SetQuotUsage(int v);
	//
	// Descr: Возвращает статус трактовки котировки QuotKindID
	// Returns:
	//   0 - котировка не используется (!(Flags & fPriceByQuot) && !(Flags2 & f2CostByQuot))
	//   1 - котировка используется как дополнение к цене реализации (Flags & fPriceByQuot)
	//   2 - котировка используется в качестве замещения цены поступления (!(Flags & fPriceByQuot) && (Flags2 & f2CostByQuot))
	//
	int    GetQuotUsage() const;

	enum {
		fBarCode                = 0x00000001, // Остатки со штрих-кодами
		fNullRest               = 0x00000002, // Выводить нулевые остатки
		fCalcOrder              = 0x00000004, // Расчитывать заказанное количество
		//                      0x0008  // Occupied by GoodsRestParam
		//                      0x0010  // Occupied by GoodsRestParam
		//                      0x0020  // Occupied by GoodsRestParam
		fPriceByQuot            = 0x00000040, // Формировать цены по котировкам
		fUnderMinStock          = 0x00000080, // Показывать только те позиции, остаток по которым ниже установленного минимума
		fDisplayWoPacks         = 0x00000100, // Показывать остатки без упаковок
		fNullRestsOnly          = 0x00000200, // Только нулевые остатки
		fLabelOnly              = 0x00000400, // WL-only
		fNoZeroOrderOnly        = 0x00000800, // Только с ненулевыми заказами
		fCalcTotalOnly          = 0x00001000, // Расчитать только итоги
		fEachLocation           = 0x00002000, // Рассчитывать остатки по каждому из складов
		fComplPackQtty          = 0x00004000, // Показывать количество в упаковках
		fCWoVat                 = 0x00008000, // Показывать цены без НДС
		fCalcDeficit            = 0x00010000, // Рассчитывать дефицит
		fWoSupplier             = 0x00020000, // Рассчитывать остатки без учета поставщика
		fShowMinStock           = 0x00040000, // Показывать минимальные остатки
		fShowDraftReceipt       = 0x00080000, // Показывать остатки учитывая будущие драфт приходы
		fCalcSStatSales         = 0x00100000, // Заполнять поле среднедневных продаж из статистики продаж
		fOuterGsl               = 0x00200000, // PPViewGoodsRest::Gsl инициализирован вне функции PPViewGoodsRest::Init_
		fUseGoodsMatrix         = 0x00400000, // Применять товарную матрицу при выборе товаров для отчета
		fExtByArCode            = 0x00800000, // Выборка товаров, по которым строится отчет ДОПОЛНЯЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
		fRestrictByArCode       = 0x01000000, // Выборка товаров, по которым строится отчет ОГРАНИЧИВАЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
			// Если SupplID == 0, то перебираются только те товары, которые имеют собственные коды.
		// @#{fExtByArCode^fRestrictByArCode}
		fCrosstab               = 0x02000000, // Кросстаб, если включена опция fEachLocation
		fShowGoodsMatrixBelongs = 0x04000000, // Отображать принадлежность товарной матрице
		fCalcUncompleteSess     = 0x08000000, // Рассчитывать с учетом незавершенных сессий
		fZeroSupplAgent         = 0x10000000, // Только с нулевым агентом поставщика
		fCalcCVat               = 0x20000000, // Рассчитывать валовую сумму НДС в ценах поступления //
		fCalcPVat               = 0x40000000, // Рассчитывать валовую сумму НДС в ценах реализации //
		fForceNullRest          = 0x80000000  // Предписывает показывать товар с нулевым остатком даже если не было ни одного лота
	};
	//
	// Descr: Значения флагов, хранящихся в поле Flags2
	//
	enum {
		f2CalcPrognosis = 0x00000001, // Рассчитывать прогноз продаж (специальная форма диалога фильтра и отчета)
		f2CostByQuot    = 0x00000002, // Котировку трактовать как цены поступления
		f2RetailPrice   = 0x00000004, // @v10.3.2 Цены реализации рассчитывать по правилам, применяемым для определения розничных цен
		f2BelowOneRest  = 0x00000008, // @v11.4.6 Показывать только те позиции, остаток которых менее 1.0
		f2FractRest     = 0x00000010  // @v11.4.6 Показывать только дробные остатки  
	};
	//
	// Descr: Опции экспорта Universe-HTT
	//
	enum {
		uefRest          = 0x0001, // Экспортировать значения остатков
		uefPrice         = 0x0002, // Экспортировать цены
		uefZeroAbsPrices = 0x0004  // Обнулять цены для позиций, которые есть на сервере, но отсутствуют в отчете
	};
	enum {
		evfShowLastSaleDate = 0x0001 // Показывать дату последней продажи
	};
	char   ReserveStart[64]; // @anchor // @v11.4.6 [4]-->[64]
	int32  InitOrder;        // @v11.4.6 Инициирующий порядок сортировки
	uint32 DiffParam;        // Параметр дифференциации записей отчета
	PPID   UhttExpLocID;     // Склад, по которому синхронизируется загрузка данных на сервер Universe-HTT
		// Если UhttExpLocID == 0, то синхронизируется по LocList.GetSingle()
	int16  UhttExpFlags;     // Опции экспорта в Universe-HTT
	uint16 ExtViewFlags;     // Дополнительные опции просмотра
	int16  PrgnTerm;         // Количество дней, на которые необходимо спрогнозировать продажи.
		// По смыслу, это поле конфликтует с PrgnPeriod, однако имеет несколько отличное применение:
		// используется для расчета дополнительного поля прогноза продаж без признака CalcPrognosis.
	int16  ExhaustTerm;      // Срок истощения остатков (<0 - количество дней, прошедшее после истощения остатка)
	PPID   DiffLotTagID;     // Тип тега лотов, по значениям которого следует дифференцировать отчет
	DateRange DraftRcptPrd;  // Период расчета будущих драфт приходов
	uint   CalcMethod;       // GoodsRestParam::pcmXXX
	long   Flags;            //
	int    AmtType;          // 0 - в обеих ценах, 1 - поступления, 2 - реализации
	long   Flags2;           // GoodsRestFilt::f2XXX
	DateRange PrgnPeriod;    // период прогноза
	LDATE  Date;             //
	PPID   SupplID;          //
	PPID   GoodsGrpID;       //
	PPID   QuotKindID;       //
	PPID   AgentID;          // Агент поставщика
	PPID   BrandID;          //
	SubstGrpGoods Sgg;       //
	LDATE  DeficitDt;        //
	uint   WaitMsgID;        //
	RealRange RestRange;     // @v11.4.6 Диапазон значений остатка 
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;   //
	ObjIdListFilt GoodsList; // Для вывода детализации по ид подстановки
};

class GoodsRestTotal {
public:
	GoodsRestTotal();
	void   Init();
	GoodsRestTotal & FASTCALL operator = (const GoodsRestTotal &);
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	long   Count;
	double Quantity;
	double PhQtty;
	double Order;
	double SumCost;
	double SumPrice;
	double SumCVat;
	double SumPVat;
	double PctAddedVal;
	double DraftRcpt;        //
	double SumDraftCost;     //
	double SumDraftPrice;    //
	AmtList Amounts;
};

struct GoodsRestViewItem { // @transient
	GoodsRestViewItem();
	PPID   GoodsID;
	PPID   GoodsGrpID;
	PPID   LocID;
	PPID   LotID;          //
	char   GoodsName[128]; //
	char   GoodsGrpName[128]; //
	char   UnitName[48];   // Наименование единицы измерения //
	char   Serial[24];     //
	int16  IsPredictTrust; // Прогноз продаж удовлетворяет требованиям надежности
	int16  Reserve;        // @alignment
	double Rest;           //
	double Deficit;        //
	double PhRest;         //
	double Order;          //
	double UnitPerPack;    //
	double Cost;           //
	double Price;          //
	double SumCost;        //
	double SumPrice;       //
	double SumCVat;        // Сумма НДС в ценах поступления
	double SumPVat;        // Сумма НДС в ценах реализации
	double PctAddedVal;    // Средняя наценка на позицию
	double Predict;        // Прогноз продаж
	double RestInDays;     // Остаток товаров в днях
	double MinStock;       //
	double SupplOrder;     // Предлагаемый заказ поставщику
	double SStatSales;     // Среднедневные продажи из статистики продаж
	double DraftRcpt;      //
	long   SubstAsscCount; //
	LDATE  LastSellDate;   //
	LDATE  Expiry;         //
};
//
// Структура, передаваемая объекту PPALDD_GoodsRestTotal для печати
// Used: V_GREST2.CPP
//
struct GoodsRestTotalPrintData {
	const GoodsRestTotal * P_Total;
	const GoodsRestFilt * P_Filt;
};

class PPViewGoodsRest : public PPView {
public:
	struct BrwHdr {
		PPID __ID;
		PPID GoodsID;
		PPID LocID;
	};

	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsID,
		OrdByGoodsName,
		OrdByGrp_GoodsName,
		OrdByPrice,
		OrdByGrp_Price,
		OrdByBarCode,
		OrdByGrp_BarCode,
		OrdByRest // @v11.4.6
	};

	PPViewGoodsRest();
	~PPViewGoodsRest();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	//
	// Descr: Инициализирует выборку остатков товаров в соответствии с фильтром.
	// ARG(pFilt     IN): Фильтр, определяющий расчет товарных остатков
	//
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	//
	// ARG(pOuterGsl IN): Если этот параметр не нулевой и фильтр pFilt предполагает
	//   подстановку товара, то использование этого параметра позволит передать
	//   объекту список подстановок. Благодаря этому подстановки созданные этим
	//   объектом будут соответствовать переданному списку подстановок.
	//   Например: объект PPViewGoodsOpAnalyze строит отчет с остатками, вызывая //
	//   этот метод. Если он не передаст сюда свой список подстановок, то
	//   остатки по подстановкам могут не соответствовать основной часть отчета.
	//   Вызывать перед вызовом функции Init_
	//
	void   SetGsl(const GoodsSubstList * pOuterGsl);
	int    InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(GoodsRestViewItem *);
	int    AllocInnerIterItem(); // @v11.0.4
	const  GoodsRestViewItem * GetInnerIterItem() const; // @v11.0.4
	int    GetItem(PPID goodsID, PPID locID, GoodsRestViewItem *);
	int    GetItem(PPID goodsID, const ObjIdListFilt * pLocList, GoodsRestViewItem * pItem);
	int    GetItem(PPID __id, GoodsRestViewItem *);
	int    GetGoodsStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);
	//
	// Descr: Рассчитывает заказы на товар goodsID в соответствии с условиями внутреннего фильтра
	//
	int    CalcOrder(PPID goodsID, GoodsRestParam * pOutData);
	int    SetSupplOrderValues(PPID goodsID, PPID locID, double predict, double minStock, double order, int canTrust);
	int    GetTableName(SString & rBuf) const;
	int    GetGoodsBarcode(PPID goodsID, SString & rBuf);
	int    GetTotal(GoodsRestTotal *);
	virtual int Print(const void *);
	void   GetTabTitle(long tabID, SString & rBuf);
	void   GetEditIds(const void * pRow, PPID * pLocID, PPID * pGoodsID, long col);
	int    ExportUhtt(int silent);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	struct LotQueryBlock {
		LotQueryBlock();
		~LotQueryBlock();
		int   Idx;
		int   SpMode;
		int   Reverse;
		BExtQuery * P_Q;
		// @v10.6.8 uint8 Key[ALIGNSIZE(MAXKEYLEN, 2)];
		BtrDbKey Key_; // @10.6.8
	};
	class ProcessLotBlock {
	public:
		explicit ProcessLotBlock(int forceUseLotRest);
		~ProcessLotBlock();
		int    ForceUseLotRest; // Остаток брать из лота (ReceiptTbl::Rec::Rest) даже если в фильтре установлена дата
		const PPIDArray * P_GrpGoodsList;
		PPIDArray ExtBillList;
		Transfer::GetLotPricesCache * P_LpCache;
		IterCounter Cntr;
		PPIDArray GrpGoodsList;
	};
public:
	struct CacheItem { // @flat
		CacheItem();

		PPID   GoodsID;       // @anchor По этому и следующему элементам
		PPID   LocID;         // @anchor осуществляется поиск
		PPID   LotID;         //
		double UnitPerPack;
		double Order;
		double Rest;
		double PhRest;
		double Cost;
		double Price;
		double SumCVat;       // Сумма НДС в ценах поступления //
		double SumPVat;       // Сумма НДС в ценах реализации //
		double Deficit;       //
		double DraftRcpt;     //
		uint32 Counter;
		uint   SerialP;       // Позиция серийного номера в пуле строк
		uint   LotTagP;       // Позиция строки тега лота в пуле строк
		LDATE  Expiry;        // Дата истечения срока годности (из лота)
		DBRowId  DBPos;
	};
private:
	class Cache : public TSVector <CacheItem>, public SStrGroup {
	public:
		Cache();
		Cache & Clear();
		int    SetupCacheItemSerial(PPViewGoodsRest::CacheItem & rItem, const char * pSerial);
		bool   GetCacheItemSerial(const PPViewGoodsRest::CacheItem & rItem, SString & rBuf) const;
		int    SetupCacheItemLotTag(PPViewGoodsRest::CacheItem & rItem, const char * pTagVal);
		bool   GetCacheItemLotTag(const PPViewGoodsRest::CacheItem & rItem, SString & rBuf) const;
	};

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    ViewLots(PPID __id, const BrwHdr * pHdr, int orderLots);
	int    ViewPrediction(PPID goodsID, PPID /*locID*/);
	int    ConvertLinesToBasket();
	int    PrintTotal(const GoodsRestTotal *);
	int    CreateTempTable(int use_ta, double * pPrfMeasure);
	int    CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    ProcessLots2(const PPIDArray * pGrpGoodsList);
	int    ProcessGroup(const PPIDArray * pGroupGoodsList);
	int    AddGoodsThruCache(PPID goodsID, PPID locID, int isGenGoods, double order, double phUPerU, const GoodsRestVal *, BExtInsert *);
		// @<<PPViewGoodsRest::CreateTempTable @<<PPViewGoodsRest::ProcessGoods
	int    AddTotal(const PPViewGoodsRest::CacheItem & rItem);
	int    ProcessGoods(PPID goodsID, BExtInsert *, const PPIDArray * pAgentBillList);
	int    CalcTotal(GoodsRestTotal *);
	int    InitGroupNamesList();
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();
	int    InitAppBuff(const TempGoodsRestTbl::Rec *, GoodsRestViewItem *);
	void   InitCache();
	int    FASTCALL AddCacheItem(PPViewGoodsRest::CacheItem & rItem);
	int    CompareNthCacheItem(uint n, const PPViewGoodsRest::CacheItem *) const;
	int    FlashCacheItem(BExtInsert *, const PPViewGoodsRest::CacheItem & rItem);
		// @<<PPViewGoodsRest::FlashCacheItems
		// @<<PPViewGoodsRest::AddGoodsThruCache
	int    FlashCacheItems(uint);
	int    GetLastLot_p(PPID goodsID, PPID locID, PPID supplID, LDATE dt, ReceiptTbl::Rec *);
	int    GetLastLot_(PPID goodsID, PPID locID, ReceiptTbl::Rec & rRec);
	double GetDeficit(PPID goodsID);
	double GetDraftRcptByLocList(PPID goodsID, const PPIDArray * pLocList, int addToExclList = 1);
	double GetDraftReceipt(PPID goodsID, PPID locID, int addToExclList = 1);
	double EnumDraftRcpt(PPID goodsID, uint * pIdx, DraftRcptItem * pItem);
	double GetUncompleteSessQttyByLocList(PPID goodsID, const PPIDArray * pLocList, int addToExclList =1);
	double GetUncompleteSessQtty(PPID goodsID, PPID locID, int addToExclList =1);
	double EnumUncompleteSessQtty(PPID goodsID, uint * pIdx, DraftRcptItem * pItem);
	int    InitProcessLotBlock(ProcessLotBlock & rBlk, const PPIDArray * pGrpGoodsList);
	int    Helper_ProcessLot(ProcessLotBlock & rBlk, ReceiptTbl::Rec & rRec);
	int    MakeLotQuery(LotQueryBlock & rBlk, int lcr, long lowId, long uppId);
	int    SelectLcrLots(const PPIDArray & rIdList, const UintHashTable & rLcrList, SVector & rList);
	int    UpdateGoods(PPID goodsID);
	int    SetContractPrices();
	static BExtQuery & FASTCALL MakeLotSelectFldList(BExtQuery & rQ, const ReceiptTbl & rT);

	GoodsRestFilt  Filt;
	OpGroupingFilt * P_OpGrpngFilt; // Фильтр для просмотра отчета "Группировка операций"
	PPObjBill   * P_BObj;
	PPObjGoods    GObj;
	PPObjUnit     UObj;
	PPObjLocation LocObj;
	TempGoodsRestTbl * P_Tbl;
	TempOrderTbl * P_TempOrd;
	CCheckCore    CCheckTbl;
	GoodsSubstList Gsl;
	Predictor * P_Predictor;
	SpecSeriesCore * P_SpoilTbl; // @v11.1.8
	enum {
		fAccsCost      = 0x0001,
		fExclAltFold   = 0x0002,
		fTotalInited   = 0x0004,
		fScalePrefixAltGroup = 0x0008, // Товарная группа, установленная в фильтре требует генерации дианмических
			// весовых штрихкодов. При этом инициализируется ScalePrefixID
		fExhaustTermInited   = 0x0010, // Сроки истощения запасов инициализированы.
			// Это означает, что можно фильтровать строки отчета по сроку истощения без
			// перестройки всего отчета
		fOnceInited  = 0x0020  // Экземпляр уже был инициализирован вызовом Init_
			// (этот флаг устанавливается безусловно при успешном вызове Init_())
	};
	long   Flags;
	PPID   ScalePrefixID;
	PPID   SellOpID; // Вид операции продажи для идентификации даты последней продажи товаров
	SString WaitMsg;
	//
	// Отношение количества товаров в группе к общему числу товаров (промилле),
	// ниже которого расчет ведется перебором товаров, а не перебором лотов.
	// По умолчанию DEFAULT_GROUPRESTCALCTHRESHOLD (V_GREST.CPP)
	//
	long   GroupCalcThreshold;
	int    IterIdx;
	GoodsRestViewItem * P_InnerIterItem; // @v11.0.4 Внутренний собственнй экземпляр элемента текущей итерации. Если необходим, должен быть распределен функцией AllocInnerIterItem()
	GoodsGroupIterator * P_GGIter;
	SString IterGrpName;
	UintHashTable GoodsIDs;
	GoodsRestTotal Total;
	PPViewGoodsRest::Cache CacheBuf;
	uint32 MaxCacheItems;
	uint32 CacheDelta;
	uint32 LastCacheCounter;

	struct {
		long   SearchCount;
		long   CacheMissesCount;
		long   DbMissesCount;
		long   InsertCount;
		long   UpdateCount;
		long   NotChangedUpdateCount;
	} CacheStat;
	RAssocArray DeficitList;          //
	SStrGroup StrPool;                // Пул строковых полей, на который ссылаются поля в TempGoodsRestTbl
	PPIDArray ExclDeficitList;        //
	DraftRcptArray DraftRcptList;     //
	LAssocArray    ExclDraftRcptList; //
	DraftRcptArray UncompleteSessQttyList;
	LAssocArray    ExclUncompleteSessQttyList;
	ObjIdListFilt  LocList;           // @!PPViewGoodsRest::Init_
		// Проекция Filt.LocList (LocList = PPObjLocation::ResolveWarehouseList(&Filt.LocList.Get()))
	RetailPriceExtractor * P_Rpe; // @v10.3.2 @transient
	//
	// Descr: Элемент списка пар {товар, склад}, индицирующий факт замещения цены котировкой. 
	//    Введен для цветового отображения значений, которые были реально замещены с целью отличить
	//    от тех, для которых котировка найдена не была.
	//
	struct SubstPriceQuotEntry { // @v11.7.11
		SubstPriceQuotEntry(PPID goodsID, PPID locID) : GoodsID(goodsID), LocID(locID)
		{
		}
		PPID   GoodsID;
		PPID   LocID;
	};
	TSVector <SubstPriceQuotEntry> SubstPriceQuotList; // @v11.7.11 применяется когда Filt.GetQuotUsage() != 0
};
//
//
//
class PPStockOpt {
public:
	enum {
		pgEstimateInRest = 1,
		pgOptimize,
		pgDecrement
	};
	//
	// Descr: типы величин, вычисляемых для товара функциями Evaluate()
	//
	enum {
		evvAll = 0,
		evvTarget = 1,       // evvIncome, evvExpend
		evvOptRestDiscr,     // Оптимальный остаток (с дискретностью, заданной емкостью упаковки)
		evvOptRest,          // Абсолютный оптимальный остаток (без дискретности)
		evvMinValAdd,        // Минимальная цена продажи при заданных средних ежедн продажах
		evvMinDemand,        // Минимальные средние ежедн продажи при заданных себестоимости и цене реализации
		evvIncome,           // Сумма ожидаемого дохода от продажи запаса. param - значение остатка
		evvExpend,           // Сумма расходов на закупку, содержание и продажу запаса. param - значение остатка
		evvProfit,           // Разница между evvIncome и evvExpend. param - значение остатка
		evvMinStock,         // Минимальный допустимый запас. param - текущий остаток
		evvMaxStock,         // Максимальный допустимый запас. param - текущий остаток
		evvStockBounds       // evvMinStock, evvMaxStock
	};
	struct Config { // @persistent
		Config();

		double RateOfRet;          // Требуемая норма прибыли (годовая в долях от единицы)
		double ExpirySafetyFactor; // Коэффициент запаса при учете срока годности товара. Нормально, должен быть >0.0 && <=1.0
		uint   MaxItems;           // Максимально количество товаров
		double MaxCost;            // Максимальная сумма остатков (в ценах поступления)
		double MaxSales;           // Максимальная сумма продаж за день (в ценах реализации)
		uint8  Reserve[128];       // @reserve
	};
	struct Item {
		explicit Item(PPID goodsID = 0);
		int    CanProcess() const;

		enum {
			fUndefDemand = 0x0001, // Не определен спрос
			fUndefCost   = 0x0002, // Не определена себестоимость
			fUndefPrice  = 0x0004, // Не определена цена реализации
			fPckgSynth   = 0x0008, // Размер упаковки синтезирован
			fPreproc     = 0x8000  // Структура обработана функцией PPStockOpt::PreporcessGoods
		};
		PPID   GoodsID;        // Ид товара
		double Cost;           // Себестоимость единицы товара
		double Price;          // Цена продажи единицы товара
		double AvgD;           // Средний ежедневный спрос на товар (в торговых единицах)
		double StdDev;         // Стандартное отклонение ежедневного спроса на товар.
		double InRest;         // Входящий остаток на начало анализируемого периода.
		//
		// Ограничения //
		//
		double MinRest;        // Минимальный остаток
		double Pckg;           // Размер упаковки
		int16  ExpiryPeriod;   // Срок годности в днях
		int16  Reserve;        // @alignment
		long   Flags;          //
	};
	//
	// Descr: Результаты расчетов по товару. Структура отделена от GoodsItem с целью оставить GoodsItem
	//   константной величиной на время расчета.
	//
	struct GoodsResult {
		enum {
			stMinMaxBoundError = 0x0001, // Минимальная граница превышает максимальную.
			stMinBound = 0x0002, // Значение R находится на нижней допустимой границе
			stMaxBound = 0x0004  // Значение R находится на верхней допустимой границе
		};
		GoodsResult();

		PPID   GoodsID;        //
		long   State;
		RealRange Bounds;      // Допустимые границы изменения остатка.
		double R0;             // Абсолютный оптимум запаса
		double R0p;            // Оптимум запаса с учетом кратности упаковки
		double R;              // Текущее расчетное значение оптимального запаса в объемной оптимизации
		double Period;         // Количество дней, в течении которых ожидается ликвидация остатка R.
		double Income;         // Ожидаемый доход от остатка R
		double Expend;         // Ожидаемые издержки по закупке и хранению количества R
		double LastDelta;      // Разность в критерии оптимальности, полученная в результате последней
			// итерации. Нобходима для быстрого поиска позиции, которая может быть частично выведена из
			// ассортимента для увеличения доли иной позиции.
	};
	struct TotalResult {
		TotalResult();
		void   Init();
		TotalResult & Add(const PPStockOpt::Item & rGi, const GoodsResult & rGr);
		TotalResult & Sub(const PPStockOpt::Item & rGi, const GoodsResult & rGr);

		uint32 Count;
		double Income;
		double Expend;
		double SumCost;
		double SalesPerDay;
	};

	static int FASTCALL WriteConfig(const PPStockOpt::Config * pCfg);
	static int FASTCALL ReadConfig(PPStockOpt::Config * pCfg);
	static int EditConfig();

	PPStockOpt();
	~PPStockOpt();
	int    SetConfig(const PPStockOpt::Config * pCfg);
	const  PPStockOpt::Config & GetConfig() const;
	int    AddGoodsItem(const PPStockOpt::Item & rItem);
	int    UpdateGoodsItem(uint pos, const PPStockOpt::Item & rItem);
	const  TSArray <PPStockOpt::Item> & GetItems() const;
	const  TSArray <PPStockOpt::GoodsResult> & GetResult() const;
	const  PPStockOpt::TotalResult & GetTotal() const;
	int    Run();
	int    Test();
private:
	int    PreprocessGoods(PPStockOpt::Item & rItem);
	int    ProcessGoods(const PPStockOpt::Item & rItem, long mode, GoodsResult & rResult) const;
	double FASTCALL Evaluate(const PPStockOpt::Item & rItem, int evv, double param) const;
	int    Evaluate(const PPStockOpt::Item & rItem, int evv, double param, GoodsResult & rResult) const;
	double GetRate() const;
	int    CheckTotalRestrictions(const TotalResult & rTotal);

	PPStockOpt::Config Cfg;
	TSArray <PPStockOpt::Item> Items;
	TSArray <PPStockOpt::GoodsResult> Result;
	TotalResult Total;
	RAssocArray DecrIndex;
};
//
// @ModuleDecl(PPViewStockOpt)
//
struct StockOptFilt : public PPBaseFilt {
	StockOptFilt();
	enum {
		modeGoods = 1,
		modePreproc,
		modeOptimum
	};
	uint8  ReserveStart[32]; // @anchor
	int32  Mode;
	int32  InitOrder;
	long   Flags;
	PPStockOpt::Config SoCfg;
	uint8  Reserve[64];      // @anchor
};
//
//
//
struct StockOptViewItem {
	PPID   GoodsID;        // Ид товара
	double Cost;           // Себестоимость единицы товара
	double Price;          // Цена продажи единицы товара
	double AvgD;           // Средний ежедневный спрос на товар (в торговых единицах)
	double StdDev;         // Стандартное отклонение ежедневного спроса на товар.
	//
	// Ограничения //
	//
	double MinRest;        // Минимальный остаток
	double Pckg;           // Размер упаковки
	int16  ExpiryPeriod;   // Срок годности в днях
	int16  Reserve;        // @alignment
	long   Flags;          //
	//
	// Результаты препроцессинга и (или) оптимизации
	//
	long   State;          // Состояние результата оптимизации //
	double InRest;         // Входящий остаток на начало анализируемого периода.
	RealRange Bounds;      // Допустимые границы изменения остатка.
	double R0;             // Абсолютный оптимум запаса
	double R0p;            // Оптимум запаса с учетом кратности упаковки
	double R;              // Текущее расчетное значение оптимального запаса в объемной оптимизации
	double Period;         // Количество дней, в течении которых ожидается ликвидация остатка R.
	double Income;         // Ожидаемый доход от остатка R
	double Expend;         // Ожидаемые издержки по закупке и хранению количества R
	double LastDelta;      // Разность в критерии оптимальности, полученная в результате последней
		// итерации. Нобходима для быстрого поиска позиции, которая может быть частично выведена из
		// ассортимента для увеличения доли иной позиции.
};

class PPViewStockOpt : public PPView {
public:
	PPViewStockOpt();
	~PPViewStockOpt();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(StockOptViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    EditItem(PPStockOpt::Item * pItem);
	SArray * Helper_CreateBrowserArray();

	PPStockOpt So;
	StockOptFilt Filt;
};
//
// @ModuleDecl(PPViewGoodsTaxAnalyze)
//
struct GoodsTaxAnalyzeFilt : public PPBaseFilt {
	GoodsTaxAnalyzeFilt();
	bool   HasCycleFlags() const;

	enum {
		fNozeroExciseOnly = 0x0001,
		fLabelOnly        = 0x0002,
		fVATByTrnovr      = 0x0004,
		fIgnoreVatFreeTag = 0x0008,
		fDayly    = 0x0010, // Книга учета частного предпринимателя (по дням)
		fMonthly  = 0x0020, // Книга учета частного предпринимателя (по месяцам)
		fByPayment        = 0x0040, // Рассчитывать операции по оплатам
		fDiffAll  = 0x0080, //
		fDiffByInVAT      = 0x0100, //
		fDiffByOutVAT     = 0x0200, //
		fOldStyleLedger   = 0x0400, // Книга учета частного предпринимателя без масштабирования отгрузок по оплатам поставщику.
		fLedgerByLots     = 0x0800  // Книга учета частного предпринимателя по приходам
	};
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	DateRange LotsPeriod;
	PPID   LocID;
	PPID   GoodsGrpID;
	PPID   SupplID;
	PPID   SupplAgentID;
	PPID   OpID;
	PPID   ObjectID;
	PPCycleFilt Cycl;
	long   Flags;           // GoodsTaxAnalyzeFilt::fXXX
	SubstGrpGoods Sgg;      // Подстановка товара
	ObjIdListFilt BillList; // @anchor
};

struct GoodsTaxAnalyzeViewItem {
	LDATE  Dt;
	char   BillNo[24];     // Номер документа
	PPID   GoodsID;
	PPID   GoodsGrpID;
	char   Name[128];
	char   TaxStr[48];
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsTaxAnalyze instance
	double Qtty;
	double PhQtty;
	double TrnovrCost;
	double TrnovrPrice;
	double Income;
	PPID   LotTaxGrpID;
	PPID   GoodsTaxGrpID;
	long   TaxFlags;
	double ExciseSum;
	double C_VATSum;
	double C_STaxSum;
	double VATSum;
	double IncVATSum;
	double STaxSum;
	double ExpQtty;
	double Rest;
};

struct GoodsTaxAnalyzeTotal {
	long   Count;          // Количество строк в отчете
	double TrnovrCost;     // Оборот в ценах поступления //
	double TrnovrPrice;    // Оборот в ценах реализации  //
	double Income;         // Доходность
	double ExciseSum;      // Сумма акциза
	double C_VATSum;       // Сумма НДС в ценах поступления //
	double VATSum;         // Сумма НДС в ценах реализации  //
	double IncVATSum;      // Сумма НДС с дохода
	double STaxSum;        // Сумма налога с продаж
	//
	// Три поля итогов для тетради частного предпринимателя по приходам
	//
	double PilRcptSum;     // Сумма оплаченных приходов
	double PilExpSum;      // Сумма оплаченных расходов
	double PilRestSum;     // Сумма неоплаченного остатка
};

//
// Структура, передаваемая объекту PPALDD_GoodsTaxAnlz для печати
// Used: V_GTANLZ.CPP
//
struct GTaxAnlzTotalPrintData {
	const GoodsTaxAnalyzeTotal * P_Total;
	const GoodsTaxAnalyzeFilt  * P_Filt;
	const BVATAccmArray   * P_VATList;
};

class PPViewGoodsTaxAnalyze : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByName,
		OrdByGrp_Name
	};
	PPViewGoodsTaxAnalyze();
	~PPViewGoodsTaxAnalyze();
	const  BVATAccmArray * GetInOutVATList() const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(GoodsTaxAnalyzeViewItem *);
	void   FormatCycle(LDATE, char * pBuf, size_t bufLen);
	int    PrintTotal(const GoodsTaxAnalyzeTotal * pTotal);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    CalcTotal(GoodsTaxAnalyzeTotal *);
	void   MakeTaxStr(GoodsGrpngEntry *, char * pBuf, size_t bufLen); // @<<PPViewGoodsTaxAnalyze::AddEntry
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();

	GoodsTaxAnalyzeFilt Filt;
	TempGoodsTaxAnlzTbl * P_TempTbl;
	GoodsGroupIterator  * P_GGIter;
	PPCycleArray CycleList;
	PPIDArray    OpList;
	int    IterIdx;
	BVATAccmArray * P_InOutVATList;
	SString  IterGrpName;
	PPObjGoods GObj;
	GoodsSubstList Gsl;
};
//
// @ModuleDecl(PPViewPriceList)
//
struct PriceListConfig {       // @persistent @store(PropertyTbl)
	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_PLISTCFG
	long   Flags;              // PLISTF_XXX
	PPID   AddPriceQuot[6];    // Used only first 3
	PPID   ExtFldMemoSubst;    // Дополнительное поле товара, которое следует подставлять вместо примечания к строке (GDSEXSTR_XXX)
	long   Reserve1[8];        // @reserve
	PPID   GoodsGrpID;         //
	PPID   LocID;              //
	char   OrgName[48];        //
	char   Business[48];       //
	char   PublisherMail[48];  //
	char   Reserve[32];        //
	char   ExportSpec[256];    //
};

int FASTCALL ReadPriceListConfig(PriceListConfig *);

#define PLISTF_PRESENTONLY  0x0001L  // Отфильтровывает только те строки, товар по которым присутствует на складе
#define PLISTF_BYQUOT       0x0002L  // Позволяет формировать прайс-лист по котировкам, в противном случае - только по базовым ценам
#define PLISTF_FILLQCERT    0x0004L  // Заполнять поле PriceListViewItem::QCertID
	// Этот флаг влияет только на инициализацию функцией
	// PPViewPriceList::NextIteration() поля PriceListViewItem::QCertID,
	// по этому может быть установлен после вызова PPViewPriceList::Init,
	// но до вызова PPViewPriceList::InitIteration().
#define PLISTF_EXCLGGRP     0x0008L  // Исключить из прайс-листа группу PriceListFilt::GoodsGrpID
#define PLISTF_NEWP         0x0010L  // Только те товары, которых не было на дату (LotPeriod.low-1)
#define PLISTF_SENDINXML    0x0020L
#define PLISTF_NOTCFMDEL    0x0040L  // Не запрашивать подтверждение перед удалением строки
#define PLISTF_USECOMMON    0x0080L  // Использовать общий прайс-лист
#define PLISTF_CALCREST     0x0100L  // Рассчитывать остатки
#define PLISTF_IGNZEROQUOT  0x0200L  // Если QuotKindID >= 0, то будут показаны те товары, которые не имеют подходящей котировки

class PriceListFilt : public PPBaseFilt {
public:
	PriceListFilt();
	PriceListFilt & FASTCALL operator = (const PriceListFilt &);
	int    Setup();

	char   ReserveStart[24];   // @anchor
	RealRange PriceRange;
	LDATE  Dt;
	PPID   ArticleID;
	PPID   LocID;
	PPID   QuotKindID;
	PPID   PListID;
	PPID   GoodsGrpID;
	PPID   ManufID;
	PPID   LotSupplID;         // Поставщик, товары которого должны быть включены в прайс-лист
	PPID   UserID;             // разделение прайса по пользователям (для каждого пользователя свой прайс-лист)
	long   Flags;              // PLISTF_XXX
	DateRange  LotPeriod;      // Период прихода товаров, которые должны быть включены в прайс-лист
	SubstGrpGoods Sgg;         // Подстановка товара
	double PctAdd;
	SString Memo;              // @anchor
	ObjIdListFilt GrpIDList;   // Список групп, которые должны быть включены в прайс-лист
	ObjIdListFilt GoodsIDList; // Список товаров, которые должны быть включены в прайс-лист
		// для печати ценников из броузера товаров, используется в функциях InitIteration(), NextIteration().
};

struct PriceListViewItem {
	PriceListViewItem();
	void   Clear();

	PPID   PListID;        //
	int16  LineNo;         //
	int16  Reserve;        // @alignment
	long   LN;             // Номер строки по итератору
	PPID   GoodsGrpID;     //
	PPID   GoodsID;        //
	PPID   QuotKindID;     //
	PPID   ManufID;        //
	PPID   UnitID;         //
	PPID   QCertID;        // if(!(PriceListFilt::Flags & PLISTF_FILLQCERT)) then 0
	long   GoodsCode;      //
	LDATE  Expiry;         //
	double UnitsPerPack;   //
	double Price;          //
	double AddPrice1;      //
	double AddPrice2;      //
	double AddPrice3;      //
	double Rest;           //
	SString GoodsName_;    // @anchor
	SString GoodsGrpName_;
	SString Memo_;
};

typedef TSVector <Sdr_PriceList> Sdr_PriceListArray;

class PPViewPriceList : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrpName_GoodsName,
		OrdByGrpCode_GoodsName
	};

	PPViewPriceList();
	~PPViewPriceList();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(PriceListViewItem *);
	virtual int  Print(const void * pHdr);
	int    SearchListByFilt(PriceListFilt *, PPID * pID, PriceListTbl::Rec *);
	int    UpdatePriceList(LDATE date, int rmvOld, int use_ta); // @>>PriceListCore::Add
	int    AddPriceList(PPID * pListID, PriceListTbl::Rec * pRec, int useTa);
	int    SearchLine(PriceLineIdent *, PriceLineTbl::Rec *);
	int    AddLine(PriceLineIdent *);
	int    EditLine(PriceLineIdent *);
	//
	// Descr: Remove line by pIdent. If !pIdent then removed all lines by Filt.PListID
	//
	int    RemoveLine(PriceLineIdent * pIdent);
	int    GetLastQCertID(PPID goodsID, LDATE dt, PPID * pQCertID);
	int    SendPList();
	int    Export();
	// @v12.1.2 int    Export_Pre9302();
	int    ExportUhtt();
	int    ConvertLinesToBasket();
	int    ConvertBasketToLines();

	struct RecalcParamBlock {
		PPObjQuotKind QkObj;
		int    GoodsPriceWoTaxes;
		int    LotPriceWoTaxes;
		LDATE  Dt;
		PPID   GoodsID;
		PPID   GoodsGrpID; // = Goods(GoodsID).ParentID
		PPID   TaxGrpID;
		double TaxFactor;
		double Cost;
		double BasePrice;
		double AddPrices[6];
		LDATE  Expiry;
		double Rest;
	};
	int    InitRPB(RecalcParamBlock *, Goods2Tbl::Rec *, int lotPriceWoTaxes, double cost, double price, LDATE);
	int    SetByQuot(RecalcParamBlock *, double price, int isPresent, int use_ta);
	int    GetPriceByQuot(RecalcParamBlock *, PPID, double *);
	int    UpdatePriceList(LDATE date, const Sdr_PriceListArray * pList, int useTa);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    UpdateTempTbl(PriceLineIdent *);
	int    SetGoodsPrice(const RecalcParamBlock * pRPB, PPID quotKindID, double unitsPerPack, double price, int isPresent, int use_ta);
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();
	int    NextIterationByList(PriceListViewItem * pItem); // используется для печати ценника по списку товаров
	int    SendPListInXmlFormat();
	double GetRest(PPID goodsID);
	int    SubstGoods(PPID goodsID, PPID * pSubstID, char * pBuf, size_t bufSize);

	PriceListFilt Filt;
	PriceListCore Tbl;
	PPObjBill * P_BObj;
	PPObjGoods  GObj;
	PPObjGoodsClass GCObj;
	PriceLineTbl * P_TempTbl;
	GoodsGroupIterator * P_GGIter;
	int    IterIdx;
	SString IterGrpName_;
	GoodsSubstList Gsl;
	enum {
		stFiltArIsSupple = 0x0001 // Статья Filt.ArticleID является поставщиком
	};
	long   State;         // stXXX
	PPID   NewGoodsGrpID; // Идентификатор последней группы, из которой добавляли новую строку
public:
	PriceListConfig Cfg; // Realy private. Used only from PPALDD_PriceListData
};

//
// @ModuleDecl(PPViewDebtTrnovr)
//
class DebtTrnovrFilt : public PPBaseFilt {
public:
	DebtTrnovrFilt();

	enum {
		fDebtOnly       = 0x0001, // Только по документам с ненулевым долгом
		fPrintExt       = 0x0002, // Печатать долговые документы с каждым клиентом. Учитывать только те оплаты, которые сделаны за период Period
		fNoForwardPaym  = 0x0004, //
		fLabelOnly      = 0x0008, // Только по WL-документам
		fByReckoning    = 0x0010, //
		fAllCurrencies  = 0x0020, //
		fByCost         = 0x0040, // В ценах поступления (COST)
		fExtended       = 0x0080, // Расширенный отчет с зачетными операциями
		fInclZeroDebt   = 0x0100, // Включать контрагентов с нулевыми долгами
		fDeliveryAddr   = 0x0200, // Использовать адрес доставки
		fCalcTotalDebt  = 0x0400, // Рассчитывать значение общего долга до конца
			// периода оплаты (независимо от периода отгрузки и периода срока оплаты)
			// Этот флаг несколько увеличивает время обработки
		fSkipPassive    = 0x0800, // Пропускать пассивные аналитические статьи
		fShowExpiryDebt = 0x1000, // Показывать сумму просроченного долга
		fNoTempTable    = 0x2000, // @v11.5.4 @internal
	};
	//
	// Виды цикличности отчета
	//
	enum {
		ckNone   = 0,
		ckExpiry = 1, // Долги по количеству дней, прошедших с установленного срока оплаты
		ckDelay,      // Долги по количеству дней, прошедших с дня отгрузки (даты документа)
		ckShipments,  // Отгрузки по циклам
		ckPayments    // Оплаты по циклам
	};
	enum {
		ekNone = 0,
		ekExpiryPart, // Отчет по доле просроченных долгов
			// Максимальный срок оплаты определяется полем ExpiryTerm.
			// Если ExpiryTerm == 0, то из даты оплаты по документу
			// При использовании этого вида отчета
			//   сумма отгрузки подменяется общей суммой долга,
			//   сумма долга - просроченной суммой долга,
			//   сумма оплаты - разницей между общей суммой долга и просроченной суммой долга.
		ekTurnover,   // Оборачиваемость дебиторской задолженности
	};

	char   ReserveStart[20]; // @anchor
	PPID   GoodsGrpID;       // Товарная группа, ограничивающая расчет
	SubstGrpBill Sgb;        // Подстановка документа.
	DateRange Period;        // Период отгрузки
	DateRange PaymPeriod;    // Период оплаты
	DateRange ExpiryPeriod;  // Период срока оплаты
	PPID   AccSheetID;       //
	PPID   CurID;            //
	PPID   AgentID;          //
	PPID   PayerID;          //
	long   InitOrder;        // PPViewDebtTrnovr::OrdByXXX
	long   Flags;            // @flags
	PPID   OpID;             // Вид операции
	int32  Reserve;          // @reserve
	PPID   CityID;           // Город
	PPID   CategoryID;       // Категория персоналии
	long   CycleKind;        // DebtTrnovrFilt::ckXXX
	PPCycleFilt Cf;          //
	long   ExtKind;          // ekXXX
	long   ExtExpiryTerm;    // ExtKind == ekExpiryPart
		// Максимальный срок оплаты для расширения отчета
		// ExtKind == ekExpiryPart. Если ExtExpiryTerm == 0, то срок оплаты берется из документа.
	double ExtExpiryMinPart; // ExtKind == ekExpiryPart
		// Минимальный процент просроченной задолженности, меньше
		// которого не следует добавлять данные в отчет
	PPID   Article2ID;       // Дополнительный объект
	PPID   AccSheet2ID;      // Таблица статей дополнительного объекта
	PPIDArray LocIDList;     // @anchor Список складов, по которым следует рассчитывать долги
	PPIDArray CliIDList;     // Список контрагентов, по которым необходимо поднять отчет
	//
	// Следующие два списка, если не пустые, то имеют приоритет над остальными условиями
	// фильтрации. Фактически, они применяются для детализации отчета.
	//
	ObjIdListFilt BillList;     // Список документов, по которым следует построить отчет
	ObjIdListFilt RcknBillList; // Список зачетных документов, по которым следует построить отчет
	ObjIdListFilt DebtDimList;  // Список долговых размерностей, которыми следут ограничить построение отчета
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};

struct DebtTrnovrViewItem { // @transient
	long   ID_;            // Ведущий идентификатор элемента. Это может быть как ид статьи, так и ид иного
		// типа объекта. Для выяснения к какому типу отностися данный идентификатор необходимо
		// воспользоваться функцией PPObjBill::GetSubstObjType().
	PPID   ObjType;        // Тип объекта, которым представляется поле ID_
	long   Ar;             //
	PPID   PersonID;       //
	char   ArName[128];    //
	PPID   BillID;         //
	PPID   CurID;          //
	long   TabID;          //
	char   TabText[32];    //
	LDATE  PayDate;        // if BillID == 0 then PayDate == 0
	LDATE  LastPaymDate;   // Дата последнего платежа по документу (if BillID == 0 then LastPAymDate == 0)
	double Debit;          // Shipment
	double Credit;         // Payment
	double Debt;           // Shipment - Payment
	double RPaym;          // Платежи по зачету
	double Reckon;         // Зачтенные платежи
	double RDebt;          // Долг по зачету
	double TDebt;          // Общий долг (Debt-RDebt)
	double ExpiryDebt;     // Просроченный долг
	long   DebitCount;     //
	long   CreditCount;    //
	double _AvgPaym;       // Средняя оплата по табуляторам без учета нулевых значений
	int8   IsStop;         // По статье установлен признак "Стоп"
	int8   Reserve;        // @reserve
	int16  MaxDelay;       // Максимальная задержка платежа
};

struct DebtTrnovrTotal {
	DebtTrnovrTotal();
	void   Init();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	long    Count;         //
	AmtList Debit;         //
	AmtList Credit;        //
	AmtList Debt;          //
	AmtList RPaym;         // Платежи по зачету
	AmtList Reckon;        // Зачтенные платежи
	AmtList RDebt;         // Долг по зачету
	AmtList TDebt;         // Общий долг
	AmtList ExpiryDebt;    // Просроченный долг
};

class PPViewDebtTrnovr : public PPView {
public:
	struct BrwHdr {
		PPID   ArID;
		PPID   CurID;
		long   TabID;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByArticleID,
		OrdByArticleName,
		OrdByDebit,
		OrdByDebt,
		OrdByStop
	};

	PPViewDebtTrnovr();
	~PPViewDebtTrnovr();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(DebtTrnovrViewItem *);
	int    GetItem(PPID arID, PPID curID, long tabID, DebtTrnovrViewItem *);
	//
	// Descr: Режимы детализации
	//
	enum {
		dmDebt = 0,    // Показать долговые документы (а также, детализация по умолчанию - например детализация группировки).
		dmDebtCard,    // Показать долговую карточку контрагента (хронологическое перечисление документов долгов и оплат).
		dmReckon,      // Показать зачетные документы
		dmDebtOnline,  // Показать долговые документы с обновлением
		dmReckonOnline // Показать зачетные документы с обновлением
	};
	int    Detail(const BrwHdr *, int mode);
	//
	// ARG(what IN):
	//   0 - show article
	//   1 - show person
	//
	int    ViewArticleInfo(const BrwHdr * pHdr, int what);
	int    GetPayableBillList(PPID arID, PPID curID, PayableBillList * pList);
		// @>>PPViewDebtTrnovr::GetPayableBillList_
	void   GetTabTitle(long tabID, SString & rBuf) const;
	int    GetTotal(DebtTrnovrTotal * pTotal);
	const  PPObjBill::SubstParam & GetBillSubstBlock() const { return Bsp; }

	LDATE  ExpiryDate;
private:
	struct DebtEntry {
		DebtEntry(PPID ident = 0);

		PPID   ID;             // @anchor Идентификатор блока. Фактический смысл этого идентификатора
			// определяется параметром Filt.Sgb (подставновкой по долговому документу)
		double _AvgPaym;       // Средняя оплата по табуляторам без учета нулевых значений
		AmtList DbtList;
		AmtList PaymList;
		AmtList ExpiryDebtList; // Компонент для учета общей суммы просроченного долга
		AmtList RDbtList;
		AmtList RcknList;
		// Следующие два поля используются если (Filt.Flags & DebtTrnovrFilt::fCalcTotalDebt)
		AmtList TotalDbtList;  // Отгрузки для расчета общего долга
		AmtList TotalPaymList; // Оплаты для расчета общего долга
	};
	struct ProcessBlock : public TSCollection <DebtEntry> {
		ProcessBlock(const DebtTrnovrFilt & rF);
		~ProcessBlock();
		ProcessBlock & ResetIter();
		ProcessBlock & ResetStep();
		int    AddStepItem(PPID tabID, double paym, double expiryDebt);
		double MultCostCoef(double val, int zeroIfDivZero) const;
		//
		// Общие параметры расчета
		//
		const  DebtTrnovrFilt & R_F;    //
		const  LDATE CurrentDate;       // = NZOR(Filt.PaymPeriod.upp, LConfig.OperDate)
		const  int   DoCheckAddr;       // = BIN(Filt.CityID)
		const  int   ByLinks;           // = BIN(Filt.Flags & DebtTrnovrFilt::fNoForwardPaym || !Filt.PaymPeriod.IsZero())
		const  int   ByCost;            // = BIN(Filt.Flags & DebtTrnovrFilt::fByCost)
		const  DateRange * P_PaymPeriod; // = (Filt.Flags & DebtTrnovrFilt::fNoForwardPaym && Filt.PaymPeriod.IsZero()) ? &Filt.Period : &Filt.PaymPeriod
		//
		uint   FullArListCount;         // Общее количество статей в аналитической таблице Filt.AccSheetID.
			// Значение необходимо для правильного выбора алгоритма расчета.
		PPIDArray ArList;
		PPIDArray ExtBillList;   // Список документов, связанных с Filt.AgentID || Filt.PayerID

		enum Itp {
			ipUndef  = 0,
			ipOp     = 1,
			ipArticle        = 2,
			ipReckonOp       = 3,
			ipByAgentList    = 4,  // Перебор по списку документов, связанных с заданным агентом
			ipBillList       = 10,
			ipReckonBillList = 13
		};
		Itp    IterPath; // 0 - undef, 1 - by oprkind, 2 - by article, 3 - by reckon op
		uint   IterN;    // Номер итерации
		IterCounter Cntr; // Счетчик для вывода хода выполнения процесса
		SString IterMsgPrefix; // Префекс текста сообщения о ходе выполнения процесса
		PPID   ReckonOpID;
		PPID   ReckonAccSheetID; // == PPOprKind(ReckonOpID).AccSheetID
		BExtQuery * P_Q;
		//
		// Step specific data {
		//
		long   Flags;
		LDATE  Date;
		LDATE  PayDate;
		PPID   CurID;
		double Amount;
		double Paym;
		double Debt;
		double ExpiryDebt;
		double Cost;
		PPBillExt Ext;
		RAssocArray PaymList;
		DebtEntry * P_Entry;
		// }
	};

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    GetPayableBillList_(const PPIDArray *, PPID arID, PPID curID, PayableBillList * pList);
	int    CheckBillRec(const BillTbl::Rec * pRec, const PPIDArray * pOpList);
	int    GetReceivableBillList(PPID arID, PayableBillList * pList);
	int    NextInnerIteration(int initList, DebtTrnovrViewItem * pItem);
	int    SetupRecVals(PPID curID, long tabID, const DebtEntry *, TempSellTrnovrTbl::Rec *);
	void   InitViewItem(const TempSellTrnovrTbl::Rec *, DebtTrnovrViewItem *);
	int    FASTCALL CheckAddress(PPID locID); // AHTOXA @<<PPViewDebtTrnovr::GetPayableBillList_
	int    GetDlvrAddrList();
	int    GetDlvrAddr(PPID billID, PPID * pAddrID);
	int    NextProcessIteration(PPID reckonOpID, ProcessBlock & rBlk);
	int    NextProcessStep(BillTbl::Rec & rRec, ProcessBlock & rBlk);
	int    PreprocessBill(const BillTbl::Rec & rRec, const ProcessBlock & rBlk, PPID * pArID, PPBillExt * pBillExt, double * pPart);
	int    ProcessBill(const BillTbl::Rec & rRec, ProcessBlock & rBlk);
	//
	// ARG(inverseSign IN): @v11.7.1 если true, то суммы документа и оплаты должны инвертироваться с минуса на плюс. Это - 
	//   специальный случай зачета корректировочного документа.
	//
	int    ProcessBillPaymPlanEntry(const BillTbl::Rec & rRec, const PayPlanTbl::Rec & rPayPlanEntry, PPID arID, bool inverseSign, ProcessBlock & rBlk);

	const int UseOmtPaymAmt;        // = BIN(CConfig.Flags2 & CCFLG2_USEOMTPAYMAMT)
	DebtTrnovrFilt  Filt;           // @viewstatefilt
	PPIDArray PayableOpList;        // @!Init_() Список операций, требующих оплаты для таблицы Filt.AccSheetID. // @viewstate
	PPIDArray GoodsList;            // @!Init_() Список товаров, ограничивающих отчет
	DebtTrnovrTotal Total;          // @viewstate
	PPObjBill * P_BObj;             //
	PPObjPerson PsnObj;             //
	PPObjArticle ArObj;             //
	PPObjWorld WObj;                //
	int    IterBillCounter;         //
	DebtTrnovrViewItem IterCurItem; //
	// PayableBillList * IterBillList; // @viewstate
	PPIDArray * P_IterBillList;     //
	LAssocArray * P_DebtDimAgentList; // Блок, реализующий быструю идентификацию принадлежности документа долговой размерности
	TempSellTrnovrTbl * P_TempTbl;  // @viewstatetable
	LAssocArray DlvrAddrList;       // @viewstate
	int    IsDlvrAddrListInited;    // @viewstate
	PPObjBill::SubstParam Bsp;      // @viewstate Параметр подстановки по документам
	PPObjBill::SubstParam RcknBsp;  // @viewstate Параметр подстановки по зачетным документам RcknBsp отличается от Bsp только внутренним списком ассоциаций Подстановка-Документ
	PPIDArray DaySieve;             // Решето, фильтрующее документы по периоду (дней) задолженности
	PPCycleArray CycleSieve;        // Решето, фильтрующее документы по дате оплаты (отгрузки и т.д.)
};
//
//
//
struct PaymDelayEntry {
	PPID   ArID;
	int16  Term;
	int16  Delay;
	int16  Expiry;
	int16  Reserve;
};

struct PPDebtorStat {
	enum {
		fAgent   = 0x0001, // Запись относится к агенту (агрегат)
		fHolding = 0x0002  // Запись относится к холдингу (агрегат)
	};
	explicit PPDebtorStat(PPID arID);
	int    AddPayment(PPID debtDimID, LDATE dt, double amount);
	int    Finish();
	int    IsAggregate() const;
	//
	// Descr: Возвращает коэффициент вариации задержки платежа.
	//   Если мат ожидание нулевое, то возвращает SMathConst::Max
	//
	double GetDelayVarRate() const;

	PPID   ArID;
	PPID   RelArID;
	double DelayMean;
	double DelayVar;
	double DelayGammaAlpha;
	double DelayGammaBeta;
	double DelayGammaTest;
	double ExpiryMean;
	double PaymAmount;
	double PaymDensity;
	double Limit;
	double DebtCost;
	double SigmFactor;
	LDATE  FirstPaymDate;  // Дата первого платежа от контрагента
	LDATE  LastPaymDate;   // Дата последнего платежа от контрагента
	long   PaymPeriod;     // = (LastPaymDate - FirstPaymDate + 1)
	long   LimitTerm;      // Срок (в днях), на который рассчитан кредитный лимит
	long   Flags;
	char   Rating[12];
	LongArray DelayList;
	LongArray ExpiryList;
	//
	// Descr: Элемент статистики, дифференцированный по долговой размерности
	//
	struct DebtDimItem { // @flat
		long   GetPaymPeriod() const;
		double CalcPaymDensity() const;

		PPID   DebtDimID;
		LDATE  FirstPaymDate;  // Дата первого платежа от контрагента
		LDATE  LastPaymDate;   // Дата последнего платежа от контрагента
		double PaymAmount;
		double Limit;
	};
	TSVector <DebtDimItem> DdList;
};

class PPDebtorStatArray : public TSCollection <PPDebtorStat> {
public:
	struct Total {
		double PaymPeriodMean;   // Средний период платежей по всей выборке (без учета общей строки)
		double ExpiryMean;       // Средняя просрочка платежей по всей выборке (без учета общей строки)
		double DelayVarRateMean; // Средний коэф вариации задержки платежей по всей выборке (без учета общей строки)
		double PaymRatingMean;   // Среднее значение меры рейтинга по плотности платежей
		double PaymRatingBar;    // Шарина полосы рейтинга по плотности платежей
		double DelayRatingMean;  // Среднее значение меры рейтинга по задержкам платежей
		double DelayRatingBar;   // Ширина полосы рейтинга по задержкам платежей
		double SigmFactor;       // =PPDebtorStatConfig::PaymSigmFactor
	};
	PPDebtorStatArray();
	PPDebtorStat * FASTCALL Get(PPID arID);

	enum {
		omUndef = 0,
		omLimitByPaymDensity = 1, // Комбинация точек: {PaymDensity, PaymPeriod, Limit}
		omDelayExpiryDots,        // Комбинация точек: {DelayMean, DelayVar, ExpiryMean}
		omRatingData,             // Комбинация точек: {PaymRatingVariable, DelayRatingVariable, RatingRgbColor}
		omSigmFactor              // Комбинация точек: {PaymPeriod, SigmFactor, 0.0}
	};
	int    CalcRating(Total * pTotal, int outMatrixStyle = 0, TSVector <SPoint3R> * pOutMatrix = 0);
	double GetSigmFactor(double sigmA, long paymPeriod, double paymPeriodMean) const;
	int    CalcDelayIndex(const PPDebtorStat * pItem, const Total * pTotal, double expWeight, double * pResult) const;
private:
	double PreprocessRatingVal(double val) const;
	int    LogRating; // Для расчета рейтингов используется логарифмическая шкала
};

struct PPDebtorStatConfig { // @persistent @store(PropertyTbl) @flat
	static int Read(PPDebtorStatConfig *);
	static int Edit();
	PPDebtorStatConfig();

	enum {
		fLimitTermFromAgreement = 0x0001, // Если у контрагента есть соглашение, то
			// расчетный срок для кредитного лимита брать из поля PPClientAgreement::DefPayPeriod //
		fProcessAgents  = 0x0002, // Собирать статистику так же и по агентам, к которым относятся документы
		fLogRatingVal   = 0x0004, // Логарифмировать индексы для выстраивания рейтингов
		fSimpleLimitAlg = 0x0008  // Упрощенный метод расчета кредитного лимита.
			// Заключается в делении суммарных платежей за период на длительность периода в днях.
			// При этом сигма-фактор не учитывается.
			// Работает только в случае, если определен период расчета.
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_DEBTORSTATCFG
	double PaymSigmFactor;  // Параметр сигмоидальной функции коэффициента плотности платежей
	double FinRate;         // Процентная ставка финансирования для расчета стоимости дебиторской задолженности
	uint32 LimitTerm;       // Срок, на который рассчитывается кредитный лимит
	long   LimitRoundPrec;  // .01 @#{0..50000} Точность округления кредитного лимита //
	int16  LimitRoundDir;   // Направление округления кредитного лимита
	int16  LimitAddedTerm;  // Дополнительный период для которого рассчитывается производное значение кредитного лимита для отображения //
	float  DelayBar;        // @def{0.5f} Ширина градации разбивки дебиторов на сегменты по задержкам платежей (в долях от StdDev)
	float  PaymBar;         // @def{1.0f} Ширина градации разбивки дебиторов на сегменты по плотности платежей (в долях от StdDev)
	float  ExpiryWeight;    // @def{0.5f} Весовой коэффициент средней величины просрочки платежей в общем рейтинге.
	long   Flags;           //
	PPID   HoldingRelTypeID; // ->PPRef(PPOBJ_PERSONRELTYPE) Тип персонального отношения для подстановки холдинга
		// вместо статьи
	float  LimitFactor;     // @#[0..10] @def{1.0} Поправочный коэффициент для кредитного лимита
	DateRange Period;       // Период сбора статистики платежей
	LDATETIME LastDtm;      // Время последнего сбора статистики
	int32  Reserve2;
};
//
//
//
class DebtStatCore : public DebtStatTbl {
public:
	DebtStatCore(const char * pFileName = 0);
	int    GetLastDate(PPID accSheetID, LDATE * pDt);
	int    SetList(PPID accSheetID, LDATE date, const PPDebtorStatArray &, int use_ta);
	int    GetList(PPID accSheetID, PPDebtorStatArray &);
};
//
//
//
class DebtorStatFilt : public PPBaseFilt {
public:
	enum {
		ordByDefault = 0,
		ordByArName,
		ordByDelayMean,
		ordByDelaySd,
		ordByDelayGammaTest,
		ordByPaymPeriod,
		ordByPaymDensity,
		ordByRating,
		ordByExpiryMean
	};
	enum {
		fTimeLine     = 0x0001, // Показывать динамику показателей по статье ArID
		fIncludeTotal = 0x0002, // Включать в выборку итоговую строку
		fIncludeRel   = 0x0004, // Включать в выборку агрегации по отношению
		fIncludeAgent = 0x0008, // Включать в выборку агрегации по агентам
		fIncludeTerm  = 0x0010  // Включать в выборку терминальные статьи
	};
	DebtorStatFilt();

	uint8  ReserveStart[28]; // @anchor @reserve
	PPID   ArID;             // ->Article.ID
	PPID   AccSheetID;       // ->Ref(PPOBJ_ACCSHEET)
	DateRange Period;
	long   Flags;
	long   Order;
	ObjIdListFilt ArList;    // @anchor
};

struct DebtorStatViewItem {
	PPID   ArID;
	PPID   RelArID;
	LDATETIME Dtm;
	long   Flags;
	double DelayMean;
	double DelaySd;
	double DelayTestGamma;
	double DelayTestChSq;
	double ExpiryMean;
	long   PaymPeriod;     // Период платежей (в днях, начиная с первого платежа до последнего платежа включительно)
	double PaymDensity;    // Плотность платежей (сумма / день)
	double SigmFactor;
	long   LimitTerm;      // Срок (в днях), на который рассчитан кредитный лимит
	double Limit;          // Рассчитанный кредитный лимит
	double DebtCost;       // Стоимость кредитов
	SString Rating;
	SString ArName;
};

struct DebtorStatTotal {
	long   ArCount;
};

class PPViewDebtorStat : public PPView {
public:
	PPViewDebtorStat();
	~PPViewDebtorStat();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(long ord);
	int    FASTCALL NextIteration(DebtorStatViewItem * pItem);
	int    FASTCALL CheckForFilt(const DebtStatTbl::Rec & rRec) const;
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	int    UpdateTempTable();
	void   MakeTempRec(long order, const DebtorStatViewItem * pItem, TempOrderTbl::Rec * pRec);
	int    MakeViewItem(const DebtStatTbl::Rec * pRec, DebtorStatViewItem * pItem);
	int    ViewGraph(const PPViewBrowser *);

	DebtorStatFilt Filt;
	DebtStatCore Tbl;
	TempOrderTbl * P_TempTbl;
	LDATE  LastDate;
};
//
// Descr: Процессор обработки должников
//
class PrcssrDebtRate {
public:
	struct Param {         // @persistent
		Param();
		int    Read(SBuffer & rBuf, long);
		int    Write(SBuffer & rBuf, long);

		enum {
			fReportOnly    = 0x0001, // Не изменять признак СТОП, а лишь выдать сообщение о том, что это следует сделать
			fReportAgtAbsence      = 0x0002, // Информировать об отсутствии клиентского соглашения //
			fAllowForMaxCredit     = 0x0004, // Учитывать максимальную сумму кредита по соглашению
			fGatherPaymDelayStat   = 0x0008, // Собирать статистику по дебиторам
			fProcessAgents = 0x0010, // Собирать статистику по агентам
			fSetupLimit    = 0x0020, // Устанавливать кредитный лимит в соглашения //
			fUpdateLimitDebtDim    = 0x0040, // Изменять кредитный лимит дифференцированный по долговым размерностям
			fCreateLimitDebtDim    = 0x0080, // Создавать кредитный лимит дифференцированный по долговым размерностям
			fUpdateStopDebtDim     = 0x0100, // Изменять признаки STOP по долговым размерностям
			fProjCommStopToDebtDim = 0x0200  // Проецировать общий STOP на размерность, если по ней частный STOP не зафиксирован
		};
		/*
			Матрица перехода для частного STOP'а
			COMM   (_cs) - рассчитанное значение общего STOP'а
			DIM    (_ds) - рассчитанное значение частного STOP'а
			DIMEXT (_dx) - признак наличия размерности в соглашении
			DIMEFF       - эффективное (устанавливаемое) значение частного STOP'а
			---------------------------------------
			_cs    _ds     _dx | DIMEFF
				0    0       0 |      x    // Ничего не делать
				0    0       1 |      0    // Следует отключить частный STOP в соглашении
				0    1       0 |      .    // Невозможный случай: нельзя вычислить частный STOP не имея параметров размерности
				0    1       1 |      1    // Следует включить частный STOP в соглашении
				1    0       0 |     ?1+   // Если fCreateLimitDebtDim && fProjCommStopToDebtDim, то следует создать размерность с признаком STOP, в противном случае - ничего не делать
				1    0       1 |     ?1    // Если fProjCommStopToDebtDim, то включить частный STOP в соглашении
				1    1       0 |      .    // Невозможный случай: нельзя вычислить частный STOP не имея параметров размерности
				1    1       1 |      1    // Следует включить частный STOP в соглашении
		*/
		uint32 Ver;
		uint8  Reserve[32]; // @reserve
		PPID   AccSheetID;  // ->Ref(PPOBJ_ACCSHEET)
		long   Gandicap;    // Дополнительный допуск к сроку оплаты (в днях)
		long   Flags;       //
		long   Reserve2;    // @reserve
	};
	PrcssrDebtRate();
	~PrcssrDebtRate();
	int    InitParam(Param * pParam);
	int    EditParam(Param * pParam);
	int    Init(const Param * pParam);
	int    Run();
private:
	int    GatherPaymDelayStat(PPLogger * pLogger, int use_ta);
	int    IsThereDebtRateLic;
	PPObjArticle ArObj;
	Param P;
	PPDebtorStatConfig Cfg;
};
//
//
//
class ShipmAnalyzeFilt : public PPBaseFilt {
public:
	ShipmAnalyzeFilt();
	int    TranslateToBillFilt(BillFilt *);
	virtual int Init(int fullyDestroy, long extraData);

	enum shaknd_tag {
		shakndByOrder = 1,
		shakndByShipment,
		shakndByAck
	};
	enum shaflg_tag {
		fDebtOnly     = 0x0001, // Только по неоплаченным документам
		fLabelOnly    = 0x0002, // Только по меченым документам
		fDiffByBill   = 0x0004
	};
	char      ReserveStart[16]; // @anchor
	DateRange Period;
	PPID      LocID;
	PPID      OpID;
	PPID      AccSheetID;
	PPID      ObjectID;
	long      Flags;
	char      ReserveEnd[16];   // @anchor
};

typedef TempShipmentAnlzTbl::Rec ShipmAnalyzeViewItem;

class PPViewShipmAnalyze : public PPView {
public:
	struct BrwHdr {
		PPID   BillID;
		PPID   GoodsID;
	};
	PPViewShipmAnalyze();
	~PPViewShipmAnalyze();
	const ShipmAnalyzeFilt * GetFilt() const { return &Filt; }
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ShipmAnalyzeViewItem *);
protected:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    Print(const void * pHdr);

	ShipmAnalyzeFilt Filt;
	PPObjBill   * BObj;
	PPObjGoods    GObj;
	TempShipmentAnlzTbl * Tbl;
	LAssocArray GbList;  // Ассоциации товар-документы для детализации списка документов по товару
};
//
// @ModuleDecl(PPViewAccount)
//
struct AccountFilt : public PPBaseFilt {
	AccountFilt();
	AccountFilt & FASTCALL operator = (const AccountFilt &);

	char   ReserveStart[32];  // @anchor
	long   Type;   // ACY_XXX
	long   Flags;
	long   Reserve;           // @anchor
};

class AccountViewItem : public PPAccount {
public:
	char   CurList[48];
};

class PPViewAccount : public PPView {
public:
	struct Hdr {
		PPID Id;
	};
	struct BrwEntry {
        PPID   ID;
        int16  Type;
        int16  Kind;
        PPAccount::_A_ A;
        PPID   CurID;
        PPID   MainOrgID;
        PPID   ParentID;
        PPID   AccSheetID;
		long   Flags;
		LDATE  OpenDate;
		LDATE  Frrl_Date;
		double Limit;
		double Overdraft;
		char   Code[20];
	};

	PPViewAccount();
	~PPViewAccount();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	int    InitIteration();
	int    FASTCALL NextIteration(AccountViewItem *);
	int    FASTCALL CheckForFilt(const PPAccount & rItem) const;
	int    ViewArticles(PPID);
	int    ViewAccAnalyze(PPID);
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    Transmit(PPID id, int transmitKind);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	static void FASTCALL MakeListEntry(const PPAccount & rSrc, PPViewAccount::BrwEntry & rEntry);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void * GetEditExtraParam();
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    FetchData(long id);

	static int DynFuncCheckRights;

	TSArray <BrwEntry> Data;
	AccountFilt Filt;
	PPObjAccount AccObj;
	AccAnlzFilt * P_AnlzFilt;
};
//
// @ModuleDecl(PPViewCurRate)
//
struct CurRateFilt : public PPBaseFilt {
	CurRateFilt();

	enum {
		fActualOnly = 0x0001   // Показывать актуальные курсы
	};
	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   CurID;
	PPID   RateTypeID;
	PPID   BaseCurID;
	long   Flags;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef CurrencyRateTbl::Rec CurRateViewItem;

class PPViewCurRate : public PPView {
public:
	PPViewCurRate();
	//
	// ARG(extraParam IN): Ид валюты
	//
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(CurRateViewItem *);
	int    EditRecord(CurrencyRateTbl::Rec *, int isNew);
	int    AddItem(CurRateIdent *);
	int    EditItem(const CurRateIdent *);
	int    DeleteItem(const CurRateIdent *);
	int    GetRate(const CurRateIdent *, double * pRate);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   Print(const void *);

	CurRateFilt Filt;
	CurRateCore Tbl;
};
//
// @ModuleDecl(PPViewBalance)
//
#define BALFORM_IGNOREZEROTURNOVER 0x00000200L //
#define BALFORM_IGNOREZEROREST     0x00000400L //
#define BALFORM_THOUSAND           0x00000800L // Баланс в тысячах
#define BALFORM_ACO1GROUPING       0x00001000L // Группировать по счетам 1-го порядка
#define BALFORM_IGNOREZERO         0x00002000L //
#define BALFORM_ALLCUR             0x00004000L // Все валюты
#define BALFORM_SPREADBYSUBACC     0x00008000L // Разворачивать сальдо по субсчетам
#define BALFORM_SPREADBYARTICLE    0x00010000L // Разворачивать сальдо по субконто
#define BALFORM_SPREAD             (BALFORM_SPREADBYSUBACC|BALFORM_SPREADBYARTICLE)

struct BalanceFilt : public PPBaseFilt {
	BalanceFilt();

	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   AccID;
	PPID   CurID;
	uint   AccType;          // Тип счетов (ACY_BAL || ACY_OBAL || ACY_REGISTER)
	long   Flags;
	uint32 ReserveEnd;       // @anchor
};

struct BalanceViewItem {
	LDATE  Dt;
	PPID   AccID;
	PPID   CurID;
	int16  Ac;
	int16  Sb;
	char   CurSymb[8];
	double InDbtRest;
	double InCrdRest;
	double DbtTrnovr;
	double CrdTrnovr;
	double OutDbtRest;
	double OutCrdRest;
};

class PPViewBalance : public PPView {
public:
	PPViewBalance();
	~PPViewBalance();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(BalanceViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    FASTCALL _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();

	BalanceFilt Filt;
	PPObjCurrency CurObj;
	PPObjAccount  AccObj;
	uint   IterPos;
	AccTurnCore * P_ATC;
	TSArray <BalanceViewItem> List;
	BalanceViewItem Total;
};
//
// @ModuleDecl(PPViewAccAnlz)
//
enum AccAnlzKind {
	aakndGeneric     = AAKND_GENERIC,     // Общая форма анализа счета
	aakndCashBook    = AAKND_CASHBOOK,    // Кассовая книга
	aakndAccTrnovr   = AAKND_ACCTRNOVR,   // Обороты по аналитическим статьям счета
	aakndSupplTrnovr = AAKND_SUPPLTRNOVR  // Обороты по поставщикам
};

class AccAnlzFilt : public PPBaseFilt {
public:
	enum {
		aafgByAco1        = ACO_1,
		aafgByAco2        = ACO_2,
		aafgByAco3        = ACO_3,
		aafgByOp  = 101,     // Группировка по операции
		aafgByLoc = 102,     // Группировка по складу
		aafgByExtObj      = 103,     // Группировка по дополнительному объекту документа
		aafgByAgent       = 104,     // Группировка по агенту документа
		aafgFirstRelation = 10000
	};
	enum {
		fAsCashBook      = 0x0001, // Кассовая книга
		fLabelOnly       = 0x0002, // Анализ только по проводкам, принадлежащим WL-документам
		//
		// Если флаг fAllCurrencies установлен, то анализ счета поднимаетс
		// по всем валютам, в которых номинировались проводки подпадающие
		// под остальные критерии фильтра.
		// В противном случае анализ осуществляется только по валюте,
		// заданной параметром CurID.
		//
		fAllCurrencies   = 0x0004,
		//
		// Флаг fGroupByCorAcc предусматривает группировку анализа счета по
		// корреспондирующим к AccID счетам. В зависимости от CorAco это:
		//    CorAco = aafgByAco1 - по счетам первого порядка
		//    CorAco = aafgByAco2 - по счетам второго порядка
		//    CorAco = aafgByAco3 - по терминальным счетам
		//
		//    CorAco = aafgByOp (=101) - по виду операции @v3.7.1
		//
		fGroupByCorAcc   = 0x0008,
		//
		// Если флаг fTrnovrBySheet установлен, то формируетс
		// оборотная ведомость по всем статьям балансового счета AccID.
		// При этом флаге автоматически полагается Aco = ACO_2, CorAco = 0,
		// !fGroupByCorAcc.
		//
		fTrnovrBySheet   = 0x0010,
		//
		// Следующий флаг имеет смысл только если установлен fTrnovrBySheet
		// При этом кроме бухгалтерской оборотки расчитываются остатки
		// товаров по каждому из поставщиков в ценах поступления на конец
		// заданного фильтром периода.
		//
		fTrnovrBySuppl   = 0x0020,
		//
		// Следующие два флага существенны только для оборотных ведомостей
		// по статьям (fTrnovrBySheet, fTrnovrBySuppl)
		//
		fSpprZTrnovr     = 0x0040, // Не показывать строки с нулевыми оборотами
		fSpprZSaldo      = 0x0080, // Не показывать строки с нулевым исходящим остатком
		fTotalOnly       = 0x0100, // Если флаг fTotalOnly установлен, то PPViewAccAnlz::Init
			// подсчитывает только итоги по фильтру, но не готовит данные для просмотра и печати
		fExclInnerTrnovr = 0x0200  // Исключать обороты, сделанные между подсчетами выбранного счета
	};
	AccAnlzFilt();
	AccAnlzFilt & FASTCALL operator = (const AccAnlzFilt & s);
	char * GetAccText(char * pBuf, size_t bufLen) const;

	char   ReserveStart[8]; // @anchor
	PPID   DlvrLocID;      // @v10.5.0 Адрес доставки документов, по которым осуществляется фильтрация проводок
	PPID   Object2ID_;     // Дополнительный объект по документу
	PPID   SubstRelTypeID; // Подстановка статьи по персональному отношению
	PPID   AgentID;        // ->Article.ID Агент по документу
	DateRange Period;      //
	long   Aco;            // Порядок ведущего счета ACO_XXX
	PPID   AccID;          // Ведущий счет (aco == ACO_3 ? AcctRel.ID : Account.ID)
	PPID   SingleArID;     // (fTrnovrBySheet only) Оборотка только по одной статье
	long   CorAco;         // Группировка (AccAnlzFilt::aafgXXX)
	Acct   CorAcc;         // Корр счет
	PPCycleFilt Cycl;      // Цикл анализа (If CorAco == 0 then ignored)
	long   InitOrder;      // PPViewAccAnlz::IterOrder
	long   Flags;          // Опции (AccAnlzFilt::fXXX)
	AcctID AcctId;         //
	PPID   AccSheetID;     //
	//
	// If (Flags & AccAnlzFilt::fAllCurrencies) then CurID = -1.
	// В применении к PPViewAccAnlz это делает функция PPViewAccAnlz::Init.
	// Все функции PPViewAccAnlz, которым логически должна предшествовать
	// Init полагаются на это.
	//
	PPID   CurID;          //
	PPID   LocID;          // Склад
	int    LeafNo;         // Для кассовой книги
	long   ReserveEnd;     // @anchor
};

struct AccAnlzViewItem {
	LDATE  Dt;
	long   OprNo;
	char   OrderText[32];
	PPID   BillID;
	short  RByBill;
	short  Reverse;
	PPID   ThisAccRelID;      //
	PPID   AccID;
	PPID   AccRelID;          // If grouping by ACO_1 or ACO_2 then AccRelID = 0
	PPID   RelPersonID;       // Связанная со статьей счета персоналия //
		// Для оборотки по статьям счета, то это - персоналия, связанная со статьей
		// Для анализа - это персоналия, связанная с корр счетом.
	PPID   CurID;             // Валюта
	char   AccName[128];      // Наименование счета
	long   Count;             // In case of grouping Count > 1
	double InRest;            // Входящий остаток
	double DbtAmt;            // Оборот по кредиту
	double CrdAmt;            // Оборот по кредиту
	double OutRest;           // Исходящий остаток
	double SupplGoodsRestAmt; // Остаток товара по поставщику в ценах поступления //
};

struct AccAnlzTotal {
	struct Cut {
		long   CDbtCount;
		long   CCrdCount;
		double CInRest;
		double CDbtTrnovr;
		double CCrdTrnovr;
		double COutRest;
	};
	AccAnlzTotal();
	void   Init();
	int    GetCurList(PPIDArray *) const;
	int    GetCut(PPID curID, AccAnlzTotal::Cut *) const;
	void   AddTrnovr(int dbt, PPID curID, double amt);

	long    Count;
	long    DbtCount;
	long    CrdCount;
	//
	// В следующих списках разложены суммы и счетчики по валютам.
	// Суммы храняться по идентификаторам 0L, счетчики храняться в
	// списках DbtTrnovr и CrdTrnovr с идентификаторами 1L.
	//
	AmtList InRest;
	AmtList DbtTrnovr;
	AmtList CrdTrnovr;
	AmtList OutRest;
	AmtList InRestDbt;
	AmtList InRestCrd;
	AmtList OutRestDbt;
	AmtList OutRestCrd;
};

typedef int (*AccAnlzViewEnumProc)(AccTurnTbl::Rec *, void *);

class PPViewAccAnlz : public PPView {
public:
	enum IterOrder {
		OrdByDefault,
		OrdByBillCode_Date, // for simple analyze only
		OrdByCorrAcc_Date   // for simple analyze only
	};
	enum {
		fIterNegRest = 0x0001 // В итераторе менять
		// знак входящего и исходящего сальдо
	};
	struct BrwHdr {
		LDATE  Dt;
		long   OprNo;
		PPID   BillID;
		PPID   AccRelID;
		PPID   CorAccID;
		PPID   CurID;
		Acct   A;
	};
	PPViewAccAnlz();
	~PPViewAccAnlz();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Browse(int modeless);
	int    InitIteration();
	int    FASTCALL NextIteration(AccAnlzViewItem *);
	int    GetTotal(AccAnlzTotal *) const;
	void   FormatCycle(LDATE, char * pBuf, size_t bufLen);
	int    GetBrwHdr(const void * pRow, BrwHdr * pHdr) const;

	LDATE  ExpiryDate; //
	uint   IterFlags;  // PPViewAccAnlz::fIterXXX
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	int    EditSupplTrnovrFilt(AccAnlzFilt *);
	int    EnumerateByIdentifiedAcc(long aco, PPID accID, AccAnlzViewEnumProc, void * extraPtr);
	int    GetAcctRel(PPID accID, PPID arID, AcctRelTbl::Rec * pRec, int use_ta);
	int    CalcTotalAccTrnovr(AccAnlzTotal *);
	int    ViewGraph(const PPViewBrowser * pBrw);
	bool   IsDedicatedRestEvaluationNeeded() const;
	struct BillEntry {
		PPID   ID;
		PPID   LocID;
		PPID   OpID;
		PPID   Object2ID;
		PPID   AgentID;
		long   Flags;
		PPID   LinkBillID; // Связанный документ
	};
	int    FetchBill(PPID billID, BillEntry * pEntry);

	AccAnlzFilt Filt;
	int    IsGenAcc;                // @*Init_()
	int    IsRegister;              // @*Init_()
	int    IsGenAr;                 // @*Init_()
	PPID   EffDlvrLocID;            // Проекция Filt.DlvrLocID (так как этот критерий применим ни при любых условиях, возможно EffDlvrLocID != Filt.DlvrLocID)
	ObjRestrictArray ExtGenAccList; // @*Init_()
	PPCycleArray CycleList;         // @*Init_()
	AccAnlzTotal Total;
	PPObjAccount AccObj;
	PPObjArticle ArObj;
	PPObjBill   * P_BObj;
	AccTurnCore * P_ATC;
	TempAccAnlzTbl   * P_TmpAATbl;
	TempAccTrnovrTbl * P_TmpATTbl;
};
//
// @ModuleDecl(PPViewVatBook)
//
class VatBookFilt : public PPBaseFilt {
public:
	VatBookFilt();
	VatBookFilt & FASTCALL operator = (const VatBookFilt & s);
	bool   IsSimpleLedger() const { return (Kind == PPVTB_SIMPLELEDGER); }

	enum {
		fShowLink     = 0x0001,
		fShowFree     = 0x0002,
		fPaymPeriod   = 0x0004,   // Период указан по дате оплаты
		fShowExcluded = 0x0008,   // Показывать исключенные записи
		fIterateClb   = 0x0010,   // Итератор книги покупок должен на каждую запись книги перебрать все номера ГТД
		fOnlyEmptyExtAr = 0x0020  // Только с пустой дополнительной статьей
	};
	char   ReserveStart[28]; // @anchor
	PPID   LocID;          // ->Location.ID
	PPID   Kind;           // PPVTB_XXX
	DateRange Period;      //
	PPID   ArticleID;      //
	PPID   Article2ID;     // Дополнительная статья
	PPID   AccSheet2ID;    // Таблица статей дополнительного объекта
	long   Flags;          //
	int    Page;           //
	long   Reserve;        // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct VatBookTotal {      // @transient
	long   Count;
	double Amount;
	double Export;
	double Excise;
	double Vat0Amount;
	double Vat1Amount;
	double Vat2Amount;
	double Vat3Amount;
	double Vat4Amount; // @v12.2.7 
	double Vat5Amount; // @v12.2.7
	double Vat1Sum;
	double Vat2Sum;
	double Vat3Sum;
	double Vat4Sum; // @v12.2.7
	double Vat5Sum; // @v12.2.7
};

#define VBV_CLB_ITEM_SIZE 64

struct VatBookViewItem : VATBookTbl::Rec { // @transient
	char   ManufCountry[32];
	char   CLB[28];
};

class PPViewVatBook : public PPView {
public:
	enum AutoBuildFlags {
		abfWL     = 0x0001, // Только по документам, отмеченным WL
		abfByPayment      = 0x0002, // Формирование книги строго по оплатам
		abfByPaymAtPrd    = 0x0004, // Формирование книги по оплатам документов, попадающим в период ExtPeriod.
		abfOnlyEmptyExtAr = 0x0008  // Только с пустой дополнительной статьей
	};
	struct AutoBuildFilt {
		DateRange Period;
		DateRange ShipmPeriod;
		DateRange ExtPeriod;
		PPID   AccSheetID;
		PPID   ObjectID;
		PPID   AccSheet2ID;
		PPID   Object2ID;
		PPID   LocID;
		long   Flags; // AutoBuildFlags
	};

	PPViewVatBook();
	~PPViewVatBook();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	int    InitIteration();
	int    FASTCALL NextIteration(VatBookViewItem *);
	int    CalcTotal(VatBookTotal *);
	int    DeleteItem(PPID);
	int    AutoBuild();
	int    Export();
	int    GetNalogRuOpIdent(const VatBookViewItem & rItem, SString & rBuf);
private:
	struct OpEntry {
		OpEntry();
		PPID   OpID;
		PPID   AmtTypeID;
		int    SignFilt; // @v11.0.3 -1 только отрицательные, +1 только положительные, 0 - все равно
	};
	class OpEntryVector : public TSVector <OpEntry> {
	public:
		OpEntryVector();
		int    Search(PPID opID, PPID amtTypeID, uint * pIdx) const;
		int    AddEntry(PPID opID, PPID amtTypeID, int signFilt);
		int    AddOpList(const LongArray & rOpList, PPID amtTypeID, int signFilt);
		int    RemoveByAnotherList(const OpEntryVector & rOtherList);
		int    RemoveExcludedByConfig(const VATBCfg & rCfg);
	};
	//int    SearchEntryInList(const TSVector <OpEntry> & rList, )
	//int    AddOpEntryToList(TSVector <OpEntry> & rList, PPID opID, PPID amtTypeID);
	//int    AddOpListToList(TSVector <OpEntry> & rList, const LongArray & rOpList, PPID amtTypeID);
	//int    RemoveEntriesFromListByAnotherList(TSVector <OpEntry> & rList, const TSVector <OpEntry> & rOtherList);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    EditAutoBuildFilt(AutoBuildFilt *);
	// @v11.0.3 int    ProcessOp(uint, const PPIDArray *, const PPIDArray * pNegOpList,
		// @v11.0.3 const AutoBuildFilt *, int byPayment, PPObjBill::PplBlock * pEbfBlk, PPID mainAmtTypeID);
	int    ProcessOp2(const OpEntryVector & rList, uint listIdx, const OpEntryVector * pNegList, const AutoBuildFilt *, int byPayment, PPObjBill::PplBlock * pEbfBlk);
	//
	// ARG(slUseCostVatAddendum IN): параметр определяет специальный вариант формирования записей расходов с НДС для книги доходов/расходов
	//   0 - нет специального формирования - запись расходов вносится с НДС
	//   1 - запись расходов вносится без НДС, а функция возвращает 100 дабы вызывающая процедура вызвала снова эту же функцию 
	//      с параметром slUseCostVatAddendum==2 для формирования дополнительной записи с суммой НДС
	//   2 - специальный прогон функции для формирования записи расходос с суммой НДС (см. комментарий выше к значению аргумента 1)
	//   3 - запись расходов вносится без НДС без дополнительной записи с суммой НДС
	//
	int    _SetVATParams(VATBookTbl::Rec *, const BVATAccmArray & rVatArray, double scale, bool isSelling, int slUseCostVatAddendum);
	int    CheckBillRec(const AutoBuildFilt *, const BillTbl::Rec *);
	int    RemoveZeroBillLinks(int use_ta);
	void   ConvertOpList(const VATBCfg & rCfg, PPIDArray & rList);
	int    MRBB(PPID, BillTbl::Rec * pPaymRec, const TaxAmountIDs *, long mrbbf, PPObjBill::PplBlock * pEbfBlk, /*PPID mainAmtTypeID*/const OpEntry & rOpEntry);
	int    NextInnerIteration(VatBookViewItem *);
	int    LoadClbList(PPID billID);
	void   ResetMainOrgBlock();
	PPObjVATBook VBObj;
	PPObjBill  * P_BObj;
	VatBookFilt  Filt;
	VatBookTotal Total;

	class MainOrgBlock {
	public:
		MainOrgBlock();
		MainOrgBlock & Z();
		int    Init();
		bool   FetchSpcTaxEntry(LDATE dt, PPGoodsTaxEntry & rGtx) const;
		bool   IsVatFree_(LDATE dt) const;
		bool   IsSpecialVatRate(LDATE dt, double * pRate) const;
	private:
		PPID   MainOrgID;
		PPID   SpecialTaxGroupID;
		bool   Initialized;
		bool   IsVatFree;
		uint8  Reserve[2]; // @alignment
	};
	MainOrgBlock MOBlk;
	//int    IsMainOrgVatFree;
	UintHashTable AbBillList; // Список идентификаторов документов, которые уже были просмотрены при
		// автоматическом построении книги. Необходим для того, чтобы избежать удаления записей, принадлежащих
		// одному документу, но сформированных за один цикл.
	//
	PPObjGoods * P_GObj;
	PPObjPerson PsnObj;
	PPObjAmountType AmtTObj;
	VatBookViewItem InnerItem;
	SArray * P_ClbList;       // items char[VBV_CLB_ITEM_SIZE]
	uint   ClbListIterPos;
	LAssocArray TaxOpSymbAssoc; // Список ассоциаций {вид операции - экспортный символ} Используется при экспорте
};
//
// @ModuleDecl(PPViewOpGrouping)
//
#define OPGRPNG_TOTAL_ID  1000000L
#define OPGRPNG_INREST    -1
#define OPGRPNG_OUTREST   10000

#define CYCLESTAT_NONE      0
#define CYCLESTAT_AVERAGE   1
#define CYCLESTAT_MIN       2
#define CYCLESTAT_MAX       3
#define CYCLESTAT_TREND     4 // Коэффициент наклона линейного тренда
#define CYCLESTAT_TRENDBASE 5 // Независимое слагаемое линейного тренда
#define CYCLESTAT_TRENDREL  6 // Отношение TREND / TRENDBASE

struct OpGroupingFilt : public PPBaseFilt {
	OpGroupingFilt();
	OpGroupingFilt & FASTCALL operator = (const OpGroupingFilt & s);
	enum {
		eqxCycleStat = 0x0001
	};
	int    IsEqualExcept(const OpGroupingFilt & rS, long flags) const;

	enum {
		fLabelOnly  = 0x0001,  // Только по WL-документам
		fCalcRest   = 0x0002,  // Рассчитывать входящие и исходящие остатки
		fPrnBillList        = 0x0004,  // Печать с реестром документов
		fAllCurrencies      = 0x0008,  // Все валюты
		fCalcAvgLn  = 0x0010,  // Рассчитывать среднее кол-во строк в док-тах
		fCostByPaym = 0x0020,  // Рассчитывать себестоимость в пропорции к оплатам поставщикам
		fSkipNUpdLotRestOps = 0x0040,  // Не включать в отчет операции, не изменяющие остатки по лотам (OPKF_NOUPDLOTREST)
		fInclAccOps = 0x0080   // Включать в отчет бухгалтерские операции (OPG_INCLACCOPS)
	};
	char   ReserveStart[28];  // @anchor
	long   CycleStat;         //
	DateRange Period;         //
	DateRange LotsPeriod;     //
	DateRange ShipmentPeriod; // Период отгрузки
	PPID   OpID;              //
	PPID   CurID;             // Валюта
	PPID   SupplID;           //
	PPID   ArID;              //
	PPID   GoodsGrpID;        //
	PPID   GoodsID;           //
	PPID   ExtGoodsTypeID;    // Тип товара по которому дополнительно показывать суммы.
		// только для группировки по документам (GoodsGrpID == 0 && GoodsID == 0)
	PPID   SupplAgentID;      //
	long   Flags;             //
	PPCycleFilt Cycl;         //
	ObjIdListFilt LocList;    // @anchor Список складов
};

struct OpGroupingViewItem { // @flat
	OpGroupingViewItem();
	LDATE  Dt;
	PPID   ObjectID;
	PPID   OpID;
	char   OpName[48];
	PPID   GoodsTaxGrpID;
	PPID   LotTaxGrpID;
	short  fVatFreeSuppl;
	short  fToggleSTax;
	short  Sign;
	uint16 Reserve2;      // @alignment
	long   Flags;         //
	long   Count;         //
	long   LnCount;       // Суммарное количество строк  turistti
	long   AvgLn;         // Среднее количество строк в документах turistti
	double Qtty;
	double PhQtty;
	double Amount;
	double Cost;
	double Price;
	double Discount;
	double Income;
	double ExtCost;       // Сумма в ценах поступления дополнительного типа товара
	double ExtPrice;      // Сумма в ценах реализации дополнительного типа товара
	double VatSum;
	double ExciseSum;
	double STaxSum;
};
//
// Descr: Структура, в которой собираются сведения товарных док-тов
//
struct BillStatFunc { // @flat
	PPID   OpID;      // Тип операции
	long   Count;     // Количество документов с этим типом операции
	long   LnCount;   // Суммарное количество товарных строк в этих документах
	long   AvgLines;  // Среднее количество строк в док-тах с таким типом операции
};

typedef TSVector <BillStatFunc> BillStatArray;

class PPViewOpGrouping : public PPView {
public:
	PPViewOpGrouping();
	~PPViewOpGrouping();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(OpGroupingViewItem *);
	void   FormatCycle(LDATE dt, char * pBuf, size_t bufLen);
	void   GetGdsOpTotal(OpGroupingViewItem *);
	int    InitBillList(PPID opID);
	int    EnumBillList(uint * pos, OpGroupingViewItem * pItem);
	int    CalcStat(BillStatArray * pList);
private:
	struct OpGroupingStatEntry {
		OpGroupingStatEntry();
		PPID   OpID;
		int    Sign;
		StatBase S;
	};
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int    Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int    Print(const void * pHdr);
	int    ViewGraph(const void * pHdr, PPViewBrowser * pBrw);
	int    CreateStatList(LAssocArray * pOpList, TSVector <OpGroupingViewItem> * pItemList, TSCollection <OpGroupingStatEntry> * pStatList);
	int    AddStatItem(PPID opID, int sign, double val, uint si, TSCollection <OpGroupingStatEntry> * pList);
	double GetStatItem(int stat, PPID opID, int sign, uint si, const TSCollection <OpGroupingStatEntry> * pList);
	void   RecalcGdsOpTotal(TempOpGrpngTbl::Rec * pRec);
	int    GetRecSign(const TempOpGrpngTbl::Rec *, int * pSign) const;

	OpGroupingFilt Filt;
	PPCycleArray CycleList;
	ObjIdListFilt LocList_;    // @v12.1.5
	TempOpGrpngTbl * P_TempTbl;
	TempOpGrpngTbl * P_TempStatTbl;
	TempOpGrpngTbl::Rec  GdsOpTotal;
	TempOpGrpngTbl::Rec  LastOutRest;
	PPViewTrfrAnlz * P_ViewTrfrAnlz;
	PPViewBill * P_ViewBill;
	PPLogger Logger;
};
//
// @ModuleDecl(PPViewGoodsMov)
//
class GoodsMovFilt : public PPBaseFilt {
public:
	enum {
		fCostWoVat      = 0x0001, // Цены поступления без НДС
		fLabelOnly      = 0x0002, //
		fUseOldAlg      = 0x0004, //
		fInited = 0x0008, // for inthernal use
		fPriceWoVat     = 0x0010  // @v10.6.6 Цены реализации без НДС
	};
	enum {
		prkBasePrice = 0,
		prkCost      = 1,
		prkPrice     = 2
	};

	GoodsMovFilt();
	GoodsMovFilt & FASTCALL operator = (const GoodsMovFilt & s);

	char   ReserveStart[14];  // @anchor
	int16  PriceKind; // prk...
	PPID   OpID;
	DateRange Period;
	PPID   SupplID;
	PPID   SupplAgentID;
	PPID   GoodsGrpID;
	PPID   BrandID;
	long   Flags;
	ObjIdListFilt LocList;    //
};

struct GoodsMovViewItem {
	PPID   GoodsID;
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsMov instance
	double PhPerU;
	double UnitsPerPack;

	double InRest_Qtty;
	double InRest_Cost;
	double InRest_Price;

	double Rcpt_Qtty;
	double Rcpt_Cost;
	double Rcpt_Price;

	double _Rcpt_Qtty;
	double _Rcpt_Cost;
	double _Rcpt_Price;

	double Rlz_Qtty;
	double Rlz_Cost;
	double Rlz_Price;

	double SRlz_Qtty;
	double SRlz_Cost;
	double SRlz_Price;

	double Expnd_Qtty;
	double Expnd_Cost;
	double Expnd_Price;

	double TRcpt_Qtty;
	double TRcpt_Cost;
	double TRcpt_Price;

	double TExpnd_Qtty;
	double TExpnd_Cost;
	double TExpnd_Price;

	double OutRest_Qtty;
	double OutRest_Cost;
	double OutRest_Price;
};

struct GoodsMovTotal {
	GoodsMovTotal();
	void   Init();
	bool   IsEmpty() const;
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	double InRestQtty;
	double InRestPhQtty;
	double InRestCost;
	double InRestPrice;
	double OutRestQtty;
	double OutRestPhQtty;
	double OutRestCost;
	double OutRestPrice;
};

class PPViewGoodsMov : public PPView {
public:
	enum IterOrder {
		OrdByDefault,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};
	PPViewGoodsMov();
	~PPViewGoodsMov();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsMovViewItem *);
	int    GetIterationCount(long * pNumIterations, long * pLastCount);
	int    EditGoods(PPID goodsID);
	// Realy private. Used from PPALDD_GoodsMov::NextItaration()
	int    PrintWoPacks;
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    InitGroupNamesList();
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();
	double GetUnitsPerPack(PPID goodsID);

	GoodsMovFilt Filt;
	PPObjBill    * P_BObj;
	TempGoodsMovTbl   * P_TempTbl;
	GoodsMovTotal     Total;
	long    IterCount;
	long    NumIters;
	int     IterIdx;
	GoodsGroupIterator * P_GGIter;
	SString IterGrpName;
};
//
// @ModuleDecl(PPViewGoodsMov2)
//
struct GoodsMov2ViewItem : TempGoodsMov2Tbl::Rec {
	double UnitsPerPack;
};

class PPViewGoodsMov2 : public PPView {
public:
	struct BrwHdr {
		PPID   OpID;
		PPID   GoodsID;
	};
	enum IterOrder {
		OrdByDefault,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};
	PPViewGoodsMov2();
	~PPViewGoodsMov2();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsMov2ViewItem *);
	int    GetIterationCount(long * pNumIterations, long * pLastCount);
	int    EditGoods(PPID goodsID);
	void   GetTabTitle(long opID, SString & rBuf);
	// Realy private. Used from PPALDD_GoodsMov::NextItaration()
	int    PrintWoPacks;
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	double GetUnitsPerPack(PPID goodsID);
	void   GetEditIds(const void * pRow, PPViewGoodsMov2::BrwHdr * pHdr, long col);

	GoodsMovFilt Filt;
	PPObjBill    * P_BObj;
	TempGoodsMov2Tbl  * P_TempTbl;
	GoodsMovTotal     Total;
	SString InRestText;
	SString OutRestText;
};
//
// @ModuleDecl(PPViewCSess)
//
class CSessFilt : public PPBaseFilt { // @persistent
public:
	enum {
		fExtBill       = 0x0001,
		fOnlySuperSess = 0x0002
	};
	CSessFilt();
	CSessFilt & FASTCALL operator = (const CSessFilt &);

	char   ReserveStart[28]; // @anchor
	long   InitOrder;        // PPViewCSess::ordByXXX Порядок сортировки
	DateRange Period;
	long   CashNumber;
	PPID   SuperSessID;
	long   Flags;
	ObjIdListFilt NodeList_;  // Список кассовых узлов, к котороым привязаны сессии
};

struct CSessViewItem : public CSessionTbl::Rec {
	long   ChkCount;
	double WORetAmount;
	double WORetBnkAmount;
	double BnkDiscount;
};
//
// Descr: Структура параметров создания драфт-документов по кассовым сессиям на основе правил.
//   Используется как при ручном вызове функции, так и для определения задания Job-сервера.
//
class CSessCrDraftParam { // @persistent(JobServer)
public:
	CSessCrDraftParam();
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long);

	enum {
		fAllSessions   = 0x0001,
		fSuperSessOnly = 0x0002
	};
	uint32 Ver;
	uint8  Reserve[32];
	DateRange Period;
	int32  RuleGrpID;      //
	int32  RuleID;         //
	int32  Flags;          //
	ObjIdListFilt NodeList;
};

class PPViewCSess : public PPView {
public:
	//
	// Descr: Порядок сортировки
	//
	enum {
		ordByDefault = 0,
		ordByID,
		ordByDtm_CashNode,
		ordByDtm_CashNumber,
		ordByDtm_SessNumber,
		ordByCashNode_Dtm,
		ordByCashNumber_Dtm,
		ordBySessNumber,
		ordByAmount
	};
	static int EditCreateDraftParam(CSessCrDraftParam * pParam);

	PPViewCSess();
	~PPViewCSess();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    InitIteration(long ord);
	int    FASTCALL NextIteration(CSessViewItem *);
	int    CalcTotal(CSessTotal *);
	int    CloseSession();
	int    CompleteSession(PPID);
	int    PosPrint(PPID curID);
	int    PrintSession(PPID sessID);
	int    ImportSessions();
	int    AddItem();
	int    EditItem(PPID);
	int    DeleteItem(PPID);
	int    DetachSessFromSuperSess(PPID);
	int    RecalcSession(PPID);
	int    ViewExcesses(PPID);
	int    ViewChecks(PPID);
	int    ViewGoodsTaxAnlz(PPID);
	int    ViewGoodsOpAnlz(PPID);
	int    Transmit(PPID, int transmitKind);
	int    CreateDrafts(PPID ruleGrpID, PPID ruleID, PPID sessID); // AHTOXA
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    FASTCALL IsNotDefaultOrder(int ord) const;
	int    CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	int    InitCSessIteration();
	int    NextCSessIteration(CSessionTbl::Rec *);
	int    Add(BExtInsert *, const CSessionTbl::Rec *);
	int    CalcCheckAmounts(TempCSessChecksTbl::Rec *);
	//
	// Если pFlags == 0, вызывается диалог DLG_SELCSESS (Товарный отчет по операции),
	// иначе DLG_SELCSESSEXC (Излишки по кассовым сессиям)
	//
	int    SelectOneOrAll(uint * pResult, long * pFlags);
	int    GetBillList(PPID sessID, ObjIdListFilt &);
	int    GetSessList(PPIDArray * pList);
	int    CreateDraft(PPID ruleID, PPID sessID, const SString &, const SString &, int use_ta);
	int    ViewAllChecks();

	BExtQuery * P_CSessIterQuery;
	CSessFilt Filt;
	ObjIdListFilt NodeList;
	int    CurrentViewOrder;
	TempCSessChecksTbl * P_TempTbl;
	TempOrderTbl * P_TempOrd;
	SArray * P_SessAmtAry;
	PPObjCSession CsObj;
};
//
// PPViewCSessExc
// Дефицит по кассовым сессиям
//
class CSessExcFilt : public PPBaseFilt {
public:
	enum {
		fNoZeroAltGoods = 0x0001 // Если этот флаг установлен то выбираются все       //
			// строки, содержащие альтернативный товар, при этом игнорируется наличия излишков по этим строкам. //
	};
	CSessExcFilt();

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   CashNodeID;
	PPID   GoodsGrpID;
	PPID   GoodsID;
	long   Flags;
	PPIDArray SessIDList;    // @anchor
};

typedef TempCSessExcTbl::Rec CSessExcViewItem;

class PPViewCSessExc : public PPView {
public:
	PPViewCSessExc();
	~PPViewCSessExc();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(CSessExcViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	int    MakeTempTable(PPID sessID);
	int    _MakeTempTable(int clearBefore);
	int    AddItemToTempTable(const  PPID, CGoodsLineTbl::Rec *, LAssocArray * pRgAssoc);
	int    GatherGoodsLines(int sign, PPID goodsID, CSessDfctList *);
		// @<<PPViewCSessExc::SetAltGoods
	PPID   GetCommonLoc();
	int    GetAltGoodsPrice(PPID goodsID, double * pPrice);
	int    SetRecValues(TempCSessExcTbl::Rec &, const CGoodsLineTbl::Rec *, int add);
	int    SetAltGoods(int sign, PPID goodsID);
	int    ConvertDeficitToBasket();

	CGoodsLine Tbl;
	PPObjGoods GObj;
	PPObjCSession CsObj;
	TempCSessExcTbl * P_TempTbl;
	PPID   CommonLocID; // Склад, соответствующий фильтру. Если нельзя однозначно
	// определить склад по условиям фильтра, то CommonLocID = 0.
	// В Init() устанавливается -1. При необходимости определения следует вызвать
	// GetCommonLoc().
	CSessExcFilt Filt;
};
//
// @ModuleDecl(PPViewCCheck)
//   Анализ кассовых чеков
//
class CCheckFilt : public PPBaseFilt, public PPExtStrContainer { // @persistent // @v11.9.1 (public PPExtStrContainer) 
public:
	enum Grouping {
		gNone = 0,        //
		gTime,            //
		gDate,            //
		gDayOfWeek,       // Группировать по дням недели.
		gDowNTime,        // Группировать по дням недели и часам.
		gCash,            //
		gCard,            //
		gDscntPct,        // Группировать по проценту скидки
		gAmount,          // Группировать по диапазону сумм. Дробность группировки определяется полем AmountQuant.
		gQtty,            // Группировать по диапазону количества. Дробность группировки определяется полем AmountQuant.
		gGoods,           // Группировать по товарам.
		gGoodsDate,       // Группировать по товару/дате
		gCashiers,        // Группировать по кассирам.
		gAgents,          // Группировать по агентам.
		gLinesCount,      // Группировать по количеству строк в чеке
		gDiv,             // Группировать по номеру отдела (по строкам)
		gGuestCount,      // Группировать по количеству гостей
		gTableNo,         // Группировать по номеру стола
		gAgentsNHour,     // Группировать по агентам и часам
		gCashNode,        // Группировать по кассовым узлам
		gAgentsNGoods,    // Группировать по агентам и товарам
		gCashiersNGoods,  // Группировать по кассирам и товарам
		gDlvrAddr,        // Группировать по адресу доставки
		gGoodsSCSer,      // Группировка по товару и серии карт
		gAmountNGoods,    //
		gAgentGoodsSCSer, // Группировать по агентам, товарам и сериям карт
		gGoodsDateSerial, // Группировать по товару/дате/серийному номеру
		gGoodsCard,       // @erik Группировка по товару и картам
		gLnMark           // @v11.9.1 Группировать по маркам в строках чеков
	};
	enum {
		fZeroSess         = 0x00000001, // Чеки по неопределенным кассовым сессиям
		fActiveSess       = 0x00000002, // Чеки активной синхронной кассовой сессии
			// Допускается добавление и удаление чеков через кассовую панель.
		fCheckLines       = 0x00000004, // Просматривать строки чеков (для группировки по товарам)
		fImmOpenPanel     = 0x00000008, // Если этот флаг установлен и группировки выключены и
			// SessIDList содержит одну сессию и Flags & CCheckFilt::fActiveSess, то сразу открывается панель ввода чеков.
		fShowSuspended    = 0x00000010, // Показывать отложенные
		fSuspendedOnly    = 0x00000020, // Только отложенные
		fRetOnly          = 0x00000040, // Показывать только возвраты
		fJunkOnly         = 0x00000080, // Только отложенные чеки, которые были загружены в панель чеков.
			// Если панель аварийно завершила работу, то этот чек зависнет.
		fFillCashNodeID   = 0x00000100, // заполнять поле CashNodeID
		fNotPrintedOnly   = 0x00000200, // Показывать только ненапечатанные чеки
		fCashOnly         = 0x00000400, // Только чеки, проведенные за наличные
		fBankingOnly      = 0x00000800, // Только чеки, проведенные по безналичной оплате
		fDontCount        = 0x00001000, // Функция InitIteration не должна рассчитывать общее количество итераций (ради экономии времени)
		fGoodsCorr        = 0x00002000, // Просмотр корреляции товаров
		fFiltByCheck      = 0x00004000, // Фильтрация по AmtR, QttyR, PcntR на весь чек, а не по строкам
		fInitLinesCount   = 0x00008000, // Инициализировать в CCheckViewItem количество строк в чеке
		fGiftOnly         = 0x00010000, // CCHKF_HASGIFT Только по чекам, имеющим признак CCHKF_HASGIFT
		fOrderOnly        = 0x00020000, // CCHKF_ORDER   Только чеки заказов
		fCTableStatus     = 0x00040000, // Специальный флаг, необходимый для извлечения чеков, которые определяют статус занятости столов
		fCalcSkuStat      = 0x00080000, // Подсчитывать статистику по строкам чеков
		fWithoutSkipTag   = 0x00100000, // Пропускать чеки, имеющие признак CCHKF_SKIP
		fDlvrOnly         = 0x00200000, // Только чеки с доставкой
		fDlvrOutstandOnly = 0x00400000, // Только отложенные неисполенные
		fStartOrderPeriod = 0x00800000, // Поле Period трактуется как период времени начала обслуживания по чеку
		fShowSrvcDuration = 0x01000000, // Отображать продолжительность обслуживания по чеку
		fZeroDlvrAddr     = 0x02000000, // Только с пустым адресом доставки
		fInner            = 0x04000000, // @internal
		fLostJunkAsSusp   = 0x08000000, // Специальный флаг, предписывающий отбирать чеки, имеющие признак CCHKF_JUNK,
			// получившие такой признак аварийно завершенной сессией. UUID'ы незавершенных сессий извлекаются из реестра по ключу
			// HKEY_CURRENT_USER\\Software\\Papyrus\\Sessions
			// UUID сессии, присвоившей чеки признак CCHKF_JUNK извлекается из зарезервированного тэга чека PPTAG_CCHECK_JS_UUID
		fPrintDetail      = 0x10000000, // По умолчанию печатать детализированный отчет по структуре CCheckViewDetail
		fNotSpFinished    = 0x20000000, // На чеке не установлен флаг CCHKF_SPFINISHED
		fAvoidExt         = 0x40000000, // @v10.2.1 По возможности избегать чтения расширенных данных чека для улучшения производительности
		fWithMarkOnly     = 0x80000000  // @v11.0.0 Только чеки, среди строк которых имеются маркированные
	};
	enum { // @v11.9.1
		f2ImportedOnly    = 0x00000001 // @v11.9.1 Только импортированные чеки (в записи установлен флаг CCHKF_IMPORTED)
	};
	enum {
		ctNone = 0,
		ctDate = 1
	};
	enum {
		ctvChecksSum = 1,
		ctvChecksCount,
		ctvSKUCount
	};
	static bool FASTCALL HasGoodsGrouping(Grouping grp)
		{ return oneof9(grp, gGoods, gGoodsDate, gAgentsNGoods, gCashiersNGoods, gGoodsSCSer, gAmountNGoods, gAgentGoodsSCSer, gGoodsDateSerial, gGoodsCard); } //@erik v10.5.2 add{gGoodsCard}
	CCheckFilt();
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	CCheckFilt & FASTCALL operator = (const CCheckFilt & src);
	//
	// Descr: Устанавливает список кассовых узлов (NodeList) в соответствии
	//   со списком идентификаторов складов pLocList. Для каждого идентификатора
	//   склада из списка извлекается список кассовых узлов, принадлежащих ему
	//   и вставляется в список NodeList.
	//
	int    SetLocList(const PPIDArray * pLocList);
	bool   HasGoodsGrouping() const { return CCheckFilt::HasGoodsGrouping(Grp); }
	bool   HasExtFiltering() const
		{ return (AgentID || TableCode || CreationUserID || GuestCount > 0 || (Flags & fStartOrderPeriod && !Period.IsZero()) || (DlvrAddrID || Flags & fZeroDlvrAddr)); }

	uint8  ReserveStart[16]; // @#0 !Использовать начиная со старших адресов // @v11.9.1 [4]-->[16]
	PPID   CreationUserID;   // 
	uint32 CountOfLastItems; // Специализированный критерий, предписывающий извлекать не более CountOfLastItems
		// последних чеков выборки. Нужен для оптимизации информационных списков, где полная выборка менее важна,
		// нежели время извлечения.
		// @attention Опция работает очень ограниченно и, в целом, не верно. В регулярных задачах не использовать!
	S_GUID LostJunkUUID;     // GUID по которому следует распознавать потерянные чеки (fLostJunkAsSusp)
	PPID   GcoExcludeGrpID;  // Группа товаров, исключаемая из рассмотрения для попарных включений товаров
	PPID   DlvrAddrID;       // Адрес доставки
	DateRange Period;
	TimeRange TimePeriod;    // Временной промежуток, за который выбирать чеки.
	uint16 LowLinesCount;    // Нижнаяя граница количества строк в чеке
	uint16 UppLinesCount;    // Верхняя граница количества строк в чеке
	int8   HourBefore;       // Use for function PPViewCCheck::ViewDetail if CCheckFilt::Grp = gTime
	uint8  WeekDays;         // Маска дней недели, по которым выбирать чеки. Если WeekDays == 0, то все.
		// Пнд (WeekDays & (1 << 1)), Вт (WeekDays & (1 << 2)), ..., Вскр (WeekDays & (1 << 0))
	int16  GuestCount;       // Количество гостей за столом
	int16  Div;              // Номер отдела (по строкам)
	int8   AltRegF;          // >0 - только то, что по альт регистратору, <0 - только то, что не по альт регистратору, 0 - без разницы
	uint8  Reserve;          // @alignment
	long   CashNumber;       //
	long   Flags;            //
	long   Flags2;           // @v11.9.1
	PPID   GoodsGrpID;       //
	PPID   GoodsID;          // ->Goods2.ID
	PPID   SCardSerID;       //
	PPID   SCardID;          // ->SCard.ID
	PPID   CashierID;        //
	PPID   AgentID;          // ->Article.ID Агент
	long   TableCode;        // Номер стола (для ресторанов)
	IntRange  CodeR;         // Диапазон номеров чеков
	RealRange AmtR;          //
	RealRange QttyR;         //
	RealRange PcntR;         // Диапазон процента скидки
	double    AmountQuant;   // Дробность группировки чеков по сумме или по количеству
	enum {
		ordIterLines = 0x8000000, // Специальный флаг, предписывающий функциям
			// PPViewCCheck::InitIteration, PPViewCCheck::NextIteration перебирать строки чеков
		ordByDef   = 0,
		ordByCount = 1,
		ordByName  = 2,
		ordByQtty  = 3,
		ordByAmt   = 4
	};
	long   SortOrder;        // Сортировка
	Grouping Grp;            //
	long   CtKind;           // CCheckFilt::ctXXX  Вид кросстабулированного отчета
	long   GcoMinCount;      // Параметры расчета попарных включений товаров в один чек
	SubstGrpGoods Sgg;       // Подстановка товара для попарных товаров
	PPIDArray SessIDList;    // @anchor
	ObjIdListFilt NodeList;  // Список узлов.
	ObjIdListFilt CorrGoodsList; // Список кореллирующих товаров
	ObjIdListFilt CtValList;     // CCheckFilt::ctvXXX Показатель, вычисляемый в кросстаб-отчете
	ObjIdListFilt ScsList;       // Список серий карт, по которым следует извлекать выборку чеков
};

struct CCheckTotal {
	long   Count;
	long   CountAltReg; // @v10.0.02 Количество чеков, проведенных через альтернативный регистратор
	double Amount;
	double Discount;
	double AmtCash;   // Сумма, оплаченная наличными
	double AmtBank;   // Сумма, оплаченная банковскими картами
	double AmtSCard;  // Сумма, оплаченная по корпоративным кредитным картам
	double AmtReturn; // Сумма возвратов
	double AmtAltReg; // @v10.0.02 Сумма, проведенная через альтернативный регистратор
	double Qtty;
	//
	// Статистики по суммам чеков
	//
	double MinCheckSum;
	double AvrgCheckSum;
	double MaxCheckSum;
	long   GuestCount;
};

struct CCheckViewItem : public CCheckTbl::Rec { // @transient // @flat
	CCheckViewItem();
	long   TableCode;      // Номер стола
	int16  Div;            // Номер отдела (по строкам)
	int16  GuestCount;     // Количество гостей за столом
	PPID   AgentID;        // ->Article.ID ИД агента (официаната)
	PPID   AddrID;         // ->Location.ID ИЛ адреса доставки для чека с доставкой
	double BnkAmt;         // Сумма, уплаченная банковской картой
	double CrdCardAmt;     // Сумма, уплаченная корпоративной кредитной картой
	long   G_GoodsID;      //
	long   G_Goods2ID;     //
	long   G_Count;        // Коичество чеков в группировке
	double G_Amount;       // Итоговая сумма чеков в группировке
	double G_Price;        // Цена по строке (строкам) чеков (с учетом скидки)
	double G_Discount;     // Итоговая скидка по чека в группировке
	double G_PctPart;      // Процентаня доля группировке в общей выборке по сумме чеков
	double G_Qtty;         // Суммарное количество торговых единиц товаров в группировке
	long   G_SkuCount;     // Суммарное количество (различных) товаров в группировке
	long   G_LinesCount;   // Суммарное количество чековых строк в группировке // @v10.8.0 double->long
	long   CashNodeID;     //
	long   LinesCount;     // Количество строк в чеке (инициализируется только если в фильтре установлен флаг fInitLinesCount
	long   LinkCheckID;    // Связанный чек (обычно, чек заказа)
	long   RByCheck;       // Номер строки по чеку
	long   LineFlags;      // Флаги строки чека
	long   LineQueue;      // Очередь подачи (для ресторанов)
	STimeChunk OrderTime;  // Отрезок времени, на который заказан стол
	LDATETIME CreationDtm; // Время создания чека (начало обслуживания)
	PPID   CreationUserID; // @v10.6.8 Пользователь, создавший чек
	char   G_Text_[128];   // Текст наименования группы. При итерации по строкам - серийный номер
	char   Serial[32];     // @v10.2.6 Серийный номер (при итерации по строкам)
};

DECL_CMPFUNC(CCheckViewItem_Dtm_Desc);

class PPViewCCheck : public PPView {
public:
	static int EditCCheckSystemInfo(CCheckPacket & rPack);
	static int CreateDraftBySuspCheck(PPViewCCheck * pV, PPID chkID);

	struct BrwHdr {
		PPID  ID;
		LDATE Dt;
		LTIME Tm;
		PPID  GoodsID;
		PPID  Goods2ID;
	};
	PPViewCCheck();
	PPViewCCheck(CCheckCore & rOuterCc);
	~PPViewCCheck();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(CCheckViewItem *);
	int    CalcTotal(CCheckTotal *);
	int    AddItem();
	int    EditItemInfo(PPID);
	int    RemoveAll();
	int    GetPacket(PPID id, CCheckPacket * pPack); // @<<PPViewCSess::CreateDraft
	int    ViewGraph();
	void   GetTabTitle(long tabID, SString & rBuf) const;
	const  BVATAccmArray * GetInOutVATList() const;
	CCheckCore * GetCc();
	int    AllocInnerIterItem();
	const  CCheckViewItem * GetInnerIterItem() const;
	const  LAssocArray & GetProblems() const;
private:
	static int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	void   Helper_Construct();
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	SString & GetCtColumnTitle(int ct, SString & rBuf);
	bool   IsTempTblNeeded() const;
	int    DoProcessLines() const;
	void   PreprocessCheckRec(const CCheckTbl::Rec * pRec, CCheckTbl::Rec & rResultRec, CCheckExtTbl::Rec & rExtRec);
	int    ProcessCheckRec(const CCheckTbl::Rec * pRec, BExtInsert * pBei);
	int    FASTCALL CheckForFilt(const CCheckTbl::Rec * pRec, const CCheckExtTbl::Rec * pExtRec);
	int    FASTCALL CheckLineForFilt(const CCheckLineTbl::Rec & rLnRec);
	int    PosPrint(PPID checkID, long);
	int    CalcVATData();
	int    ChangeFilt(PPViewBrowser * pBrw);
	int    CreateGoodsCorrTbl();
	int    ViewGoodsCorr();
	int    EditGoods(const void * pHdr, int goodsNo);
	int    AddGoodsByCCheckToBasket(PPID checkID);
	int    GetBrwHdr(const void * pRow, BrwHdr * pHdr) const;
	int    ToggleDlvrTag(PPID checkID);
	int    GetReportId() const;
	int    Recover();
	int    ExportToChZn();

	static int DynFuncPosText;

	CCheckCore  * P_CC;
	PPObjCSession CsObj;
	PPObjGoods  GObj;
	PPObjPerson PsnObj;
	PPObjSCard ScObj;
	TempCCheckQttyTbl * P_TmpTbl;
	TempCCheckGrpTbl  * P_TmpGrpTbl;
	TempCCheckGdsCorrTbl * P_TmpGdsCorrTbl;
	CCheckViewItem * P_InnerIterItem; // Внутренний собственнй экземпляр элемента текущей итерации. Если необходим, должен быть распределен функцией AllocInnerIterItem()
	CCheckFilt  Filt;
	enum {
		stHasExt        = 0x0001,
		stUseGoodsList  = 0x0002,
		stIterLines     = 0x0004, //
		stOuterCc       = 0x0008, //
		stSkipUnprinted = 0x0010  // Если в фильтре заданы конкретные кассовые узлы
			// и все они имеют установленный флаг CASHF_SKIPUNPRINTEDCHECKS, то чеки, не имеющие
			// флага CCHKF_PRINTF считаются неучитываемым (как будто имеют флаг CCHKF_SKIP).
	};
	long   State;              // @*Init_
	CCheckPacket CcPack;       //
	uint   CurLine;
	ObjIdListFilt CcIdList;    // @*Init_ Список идентификаторов чеков, ограничивающих выборку.
		// Список необходим для оптимизации выборки по неиндексированным полям (в частноси, из расширения чеков)
	ObjIdListFilt NodeIdList;  // @*Init_ Список кассовых узлов, по которым строится отчет. Может отличаться от Filt.NodeList за счет группирующих узлов
	ObjIdListFilt SessIdList;  // @*Init_
	ObjIdListFilt SCardList;   // @*Init_
	UintHashTable GoodsList;   // @*Init_ Список товаров, по которым следует фильтровать строки чеков
	LAssocArray SessCnList;    // Список ассоциация Кассовая сессия - Кассовый узел. Используется для быстрой идентификации принадлежности чека кассовому узлу.
	BVATAccmArray * P_InOutVATList; //
	GoodsSubstList Gsl;        //
	LAssocArray Problems;      // Список чеков, ассоциированных с ошибками, обнаруженными функцией корректировки
};
//
// @ModuleDecl(PPViewObjSync)
//
struct ObjSyncFilt : public PPBaseFilt {
	ObjSyncFilt();
	virtual int  Init(int fullyDestroy, long extraData);
	virtual int  Write(SBuffer &, long) const;
	virtual int  Read(SBuffer &, long);
	virtual int  Copy(const PPBaseFilt *, int);
	virtual bool IsEq(const PPBaseFilt *, int) const;

	char   ReserveStart[32]; // @anchor
	PPID   ObjType;
	PPID   DbDivID;
	long   Flags;
	PPIDArray   ObjIDList;   // @anchor
	LAssocArray CommIDList;
};

typedef ObjSyncTbl::Rec ObjSyncViewItem;

class PPViewObjSync : public PPView {
public:
	PPViewObjSync();
	~PPViewObjSync();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ObjSyncViewItem *);
	int    AddItem();
	int    EditItem(const ObjSyncIdent *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    EditRecord(ObjSyncTbl::Rec *);

	ObjSyncFilt Filt;
	ObjSyncCore * P_Tbl; // @notowned
	ObjSyncTbl  * P_TmpTbl;
};
//
// @ModuleDecl(PPViewObjSyncCmp)
//
struct ObjSyncCmpFilt : public PPBaseFilt {
	ObjSyncCmpFilt();

	enum {
		fErrOnly    = 0x0001,
		fInitialize = 0x0002  // Если этот флаг установлен, то забираются данные из файлов,
			// в противном случае просто зименяется сортировка и фильтрация этих данных
	};
	enum {
		ordByError,
		ordByCommID,
		ordBySrcID,
		ordBySrcName,
		ordByDestID,
		ordByDestName
	};
	char   ReserveStart[32]; // @anchor
	PPID   ObjType;
	long   Flags;
	long   Order;
	int    ErrCode;
	RealRange Score;
	long   Reserve;          // @anchor
};

struct ObjSyncCmpTotal {
	long   Count;    // Общее количество элементов
	long   NeCount;  // Количество безошибочных элементов
	long   N1Count;  // Количество ошибок #1
	long   N2Count;  // Количество ошибок #2
	long   N3Count;  // Количество ошибок #3
	long   N4Count;  // Количество ошибок #4
};

typedef TempSyncCmpTbl::Rec ObjSyncCmpViewItem;

class PPViewObjSyncCmp : public PPView {
public:
	PPViewObjSyncCmp();
	~PPViewObjSyncCmp();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt * pFilt);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ObjSyncCmpViewItem *);
	int    CalcTotal(ObjSyncCmpTotal *);
	int    RemoveAllSync();
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();

	ObjSyncCmpFilt Filt;
	TempSyncCmpTbl * P_TmpTbl;
	PPObjectTransmit * P_Ot;
};
//
// @ModuleDecl(PPViewObjSyncQueue)
//
struct ObjSyncQueueFilt : public PPBaseFilt {
	ObjSyncQueueFilt();

	char   ReserveStart[32]; // @anchor
	long   Flags;
	long   Reserve;          // @anchor
};

typedef ObjSyncQueueTbl::Rec ObjSyncQueueViewItem;

class PPViewObjSyncQueue : public PPView {
public:
	PPViewObjSyncQueue();
	~PPViewObjSyncQueue();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ObjSyncQueueViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);

	ObjSyncQueueFilt Filt;
	ObjSyncQueueCore Tbl;
};
//
// @ModuleDecl(PPViewTrfrAnlz)
//   Анализ товарных операций
//
class TrfrAnlzFilt : public PPBaseFilt {
public:
	enum Grouping {
		gNone = 0,
		gGoods,
		gCntragent,
		gCntragentDate,
		gGoodsCntragent,
		gGoodsCntragentDate,
		gGoodsBill,
		gDateCntragentAgentGoods,
		gGoodsDate,
		gBillCntragent,
		gGoodsSuppl // @v10.1.6 По товару и поставщику
	};
	enum {
		fLabelOnly           = 0x00000001,   // Только помеченные операции
		fGByDate             = 0x00000002,   // Группировка по дате (только если выбран товар - GoodsID)
		fGetRest             = 0x00000004,   // Рассчитывать товарные остатки
		fSubstPersonRAddr    = 0x00000008,   // При подстановке персоналии использовать фактический адрес
		fSubstDlvrAddr       = 0x00000010,   // При подстановке персоналии использовать адрес доставки
		fDiffByDlvrAddr      = 0x00000020,   // При группировке по контрагенту заменять контрагента на конкатенацию (контрагент+адрес доставки)
		fDontInitSubstNames  = 0x00000040,   // Не инициализировать имена подставляемых объектов
			// Эта опция экономит время подготовки данных если нет необходимости сортировать записи
			// или выводить отчет на экран.
		fInitLocCount        = 0x00000080,   // Рассчитывать количество адресов доставки для каждого
			// элемента группировки. Внутренний флаг (инициализируется программно)
		fCalcRest            = 0x00000100,   // Для группировки gGoods, gGoodsBill, gGoodsDate рассчитывать остатки
		fShowAllArticles     = 0x00000200,   // Показывать отсутствующие позиции контрагентов
		fShowAllAgents       = 0x00000400,   // Показывать отсутствующие позиции агентов
		fShowAllGoods        = 0x00000800,   // Показывать отсутствующие позиции товаров
		fByZeroAgent         = 0x00001000,   // Фильтрация по нулевому агенту по документу
		fCalcVat             = 0x00002000,   // Рассчитывать суммы НДС
		fCWoVat              = 0x00008000,   // Показывать цены без НДС
		fByZeroDlvrAddr      = 0x00010000,   // Фильтрация по пустому адресу доставки
		fForceInitDlvrAddr   = 0x00020000,   // Инициализировать адрес доставки без группировки
		fShowGoodsCode       = 0x00040000,   // Показывать код (single) товара
		fShowSerial          = 0x00080000,   // Показывать серийный номер лота
		fCalcAvgRest         = 0x00100000,   // Рассчитывать среднедневные остатки (предполагает наличие флага fCalcRest)
		fCmpWrOff            = 0x00200000,   // Если отчет строится по драфт-документам, то выводить результаты сравнения с документами списания.
		fCmpWrOff_DiffOnly   = 0x00400000,   // Если отчет строится со сравнением драфт-документов и документов списания, то отображать только различающиеся позиции.
		fUnclosedDraftsOnly  = 0x00800000,   // @v10.1.10 Если отчет строится по драфт-документам, то пропускать списанные документы
		fShowCargo           = 0x01000000,   // @v10.3.4 Отображать грузовые параметры (брутто и объем)
		fExtValQuotSkipTmVal = 0x02000000    // @v11.9.4 Если в качестве дополнительного значения (ExtValueParam) задан вид котировки и
			// установлен этот флаг, то значения котировок, привязанные к периоду, будут игнорироваться.
	};
	enum {
		ctNone       = 0,  // Без кросстаба
		ctDate       = 1,  // Кросстаб по дате
		ctCntragent  = 2,  // Кросстаб по контрагенту
		ctLocation   = 3   // Кросстаб по складу
	};
	//
	// Виды показателей, используемых в кросстаб-отчете
	//
	enum {
		ctvCost = 1,
		ctvNetPrice,
		ctvIncome,
		ctvPctIncome,
		ctvLocCount,
		ctvPctMargin,
		ctvQtty
	};
	//
	// Descr: Варианты расчета дополнительных показателей отчета
	//
	enum {
		extvNone        = 0,
		extvLinkOrderDiscount   = 1, // Величина скидки в связанном со строкой продажи заказе
		extvLinkOrderPriceAbove = 2, // Превышение цены в связанном заказе над итоговой ценой продажи
		extvQuotBias    = 1000 // Смещение, обозначающее вид котировки, применяемой для вычисления дополнительного показателя
	};
	//
	// Descr: Варианты отображения дополнительных факторов отчета
	//
	enum {
		extfNone        = 0, //
		extfPersonTag   = 1, // [0x40000000] Тег персоналии
		extfPersonRegister      = 2, // [0x20000000] Регистр персоналии
		extfLocTag      = 3, // @v11.1.0 [0x10000000] Тег локации (Flags & fDiffByDlvrAddr only)
		extfLocRegister = 4, // @v11.1.0 [0x08000000] Регистр локации (Flags & fDiffByDlvrAddr only)
	};
	//
	//
	//
	TrfrAnlzFilt();
	TrfrAnlzFilt & FASTCALL operator = (const TrfrAnlzFilt & rS);
	int    HasCntragentGrouping() const;
	int    HasGoodsGrouping() const;
	int    HasDateGrouping() const;
	int    HasBillGrouping() const;
	enum {
		eqxOrder    = 0x0001,
		eqxCrosstab = 0x0002
	};
	int    IsEqualExcept(const TrfrAnlzFilt & rS, long flags) const;
	virtual int Describe(long flags, SString & rBuf) const;

	enum {
		ravNothing      = 0,
		ravRest         = 0x0001, // Простой остаток
		ravAvgRest      = 0x0002, // Среднедневной остаток
		ravTurnoverRate = 0x0004, // Коэффициент оборачиваемости (движение / остаток)
	};

	uint8  ReserveStart[32];     // @anchor // @v10.0.04 [12]-->[4] // @v11.0.1 [4]-->[32]
	DateRange DueDatePeriod;     // @v10.0.04 Период даты исполнения документов
	long   ExtValueParam[2];     // Параметры, определяющие вычисление дополнительных показателей отчета
	long   RestAddendumValue;    // Параметр, определяющий варинат отображения значений, базирующихся на остатках
	long   ExtFactorParam[3];    // @v11.0.1
	long   ExtFactorAddendum[3]; // @v11.0.1
	PPID   AcsID;                // Таблица статей для выбора контрагента (если не выбран вид операции)
	PPID   SupplAgentID;         // Агент поставщика
	DateRange Period;
	DateRange LotsPeriod;
	PPID   OpID;
	PPID   SupplID;      //
	// @v11.0.1 PPID   ArID_;        // Если !0, то перебираются только те документы, у которых ObjectID == ArID
	PPID   DlvrAddrID;   // Адрес доставки. Если ArID == 0, то не используется //
		// Если Flags & fByZeroDlvrAddr, то перебираются только документы, в которых адрес доставки не указан
	// @v11.0.1 PPID   AgentID_;     // Если !0, то перебираются только те документы, в которых установлен этот агент
		// Если Flags & fByZeroAgent, то перебираются только те документы, в которых не установлен агент
	PPID   PsnCatID;     // Категория персоналии
	PPID   CityID;       // Город контрагентов, по которым перебираются операции
	PPID   GoodsGrpID;   // Товарная группа, по которой ведется перебор операций. Если GoodsID != 0,
		// то этот параметр игнорируется (используется только как ограничение выбора товара в диалоге) //
	PPID   GoodsID;      // Товар, по которому ведется перебор операций (может быть обобщенным)
	long   Flags;        // TrfrAnlzFilt::fXXX
	int    InitOrd;      // PPViewTrfrAnlz::IterOrder
	long   CtKind;       // TrfrAnlzFilt::ctXXX  Вид кросстабулированного отчета
	PPID   BrandID;      //
	Grouping Grp;        // Параметр группировки
	SubstGrpGoods   Sgg; // Подстановка товара
	SubstGrpPerson  Sgp; // Подстановка персоналии
	SubstGrpDate    Sgd; // Подстановка даты
	ObjIdListFilt   BillList;     // @anchor Список документов, по которым строится отчет
	ObjIdListFilt   RcptBillList; // Список приходных документов, которыми ограничивается перебор расходных операций
	ObjIdListFilt   LocList;      // Список складов
	ObjIdListFilt   CtValList;    // TrfrAnlzFilt::ctvXXX Показатель, вычисляемый в кросстаб-отчете
	ObjIdListFilt   ArList;       // Список статей контрагентов
	ObjIdListFilt   AgentList;    // Список статей агентов
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};

struct TrfrAnlzViewItem {
	TrfrAnlzViewItem();
	TrfrAnlzViewItem & Z();

	LDATE  Dt;             // Дата операции
	long   OprNo;          // Номер операции за день (с группировкой - 0)
	PPID   BillID;         // ИД документа
	PPID   LocID;          // ИД склада
	PPID   ArticleID;      // ИД статьи документа
	PPID   PersonID;       // ИД персоналии, соответствующей статье документа (возможна подстановка)
	PPID   OpID;           // ИД вида операции
	PPID   GoodsID;        // ->Goods2.ID   ИД товара
	PPID   SubGoodsClsID;  // ИД класса товара (только для позиций, в которых товар был подстановлен по классификатору)
	PPID   LotID;          // ->Receipt.ID  ИД лота
	PPID   LinkBillID;     //
	PPID   DlvrLocID;      // ->Location.ID ИД адреса доставки
	long   LocCount;       // Количество адресов доставки, попавших эту строку
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double Rest;           // Остаток (если фильтр не предусматривает расчет остатка, то - 0)
	double Cost;           // Сумма в ценах поступления или цена поступления (в зависимости от фильтра)
	double Price;          // Сумма в ценах реализации или цена реализации (в зависимости от фильтра)
	double Discount;       // Сумма в скидки или скидка на одну единицу (в зависимости от фильтра)
	double Amount;         // Номинальная сумма (зависит от вида операции)
	double SaldoQtty;      // Товарное сальдо в торговых единицах (для отдельных опций фильтрации)
	double SaldoAmt;       // Суммовое сальдо в номинальных ценах (для отдельных опций фильтрации)
	double PVat;           // Сумма НДС в ценах реализации
	double Brutto;         //
	double LinkQtty;       //
	double LinkCost;       //
	double LinkPrice;      //
	double ExtValue[2];    // Дополнительные показатели, определяемые специальными опциями фильтра
	SString BillCode_;     // @anchor Номер документа
	SString DtText_;       // Текстовое представление даты (при подстановке возможны вариации)
	SString GoodsText_;    // Текстовое представление товара (при подстановке возможны вариации)
	SString PersonText_;   // Текстовое представление персоналии (при подстановке возможны вариации)
};

struct TrfrAnlzTotal {
	TrfrAnlzTotal();
	void   destroy();

	enum {
		stProblemPhQtty = 0x0001, // Физическое количество задано не для всех товаров
		stProblemBrutto = 0x0002  // Масса брутто определена не для всех товаров
	};
	long   Count;          // Количество строк
	long   State;	       // Флаги, индицирующие особенности в расчете итогов
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double Cost;           // Сумма в ценах поступления //
	double Price;          // Сумма в ценах реализации
	double Discount;       // Сумма скидки
	double Amount;         // Номинальная сумма
	double SaldoQtty;      // Суммарное сальдо в торговых единицах
	double SaldoAmt;       // Суммарное сальдо в номинальных ценах
	double PVat;           // Сумма НДС в ценах реализации
	double Brutto;         // Масса брутто товарных позиций в отчете
	double ExtValue[2];    // Дополнительные показатели, определяемые специальными опциями фильтра
};

struct AlcReportParam {
	long   ImpExpTag;
	long   ManufOptBuyerTag;
	long   ManufKindID;
	long   ImportKindID;
};

struct TrfrAnlzViewItem_AlcRep {
	TrfrAnlzViewItem_AlcRep();
	void   Init();

	TrfrAnlzViewItem  Item;
	Goods2Tbl::Rec    GoodsRec;
	PPGdsClsPacket    GCPack;
	GoodsStockExt     GoodsStock;
	GoodsExtTbl::Rec  GoodsExt;
	BillTbl::Rec      BillRec;
	ReceiptTbl::Rec   OrgLotRec;
	long   PersonID;
	long   OrgLot_Prsn_SupplID;
	enum {
		fIsImport   = 0x0001,
		fIsExport   = 0x0002,
		fIsManuf    = 0x0004,
		fIsOptBuyer = 0x0008
	};
	long   Flags;
};

class PPViewTrfrAnlz : public PPView {
public:
	struct BrwHdr {
		PPID   __ID;       // ID записи таблицы TempTrfrGrpng
		PPID   GoodsID;
		PPID   ArID;
		PPID   DlvrAddrID;
		PPID   BillID;
		LDATE  Dt;
		long   OprNo;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByDate,
		OrdByGoods,
		OrdByArticle
	};

	PPViewTrfrAnlz();
	~PPViewTrfrAnlz();
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(TrfrAnlzViewItem *);
	int    Export();
	int    CalcTotal(TrfrAnlzTotal *);
	int    ViewGraph();
	int    GetBrwHdr(const void * pRow, BrwHdr *) const;
	void   GetTabTitle(long tabID, SString & rBuf) const;
	void   SetAlcRepParam(const AlcReportParam * pParam);
	int    NextIteration_AlcRep(TrfrAnlzViewItem_AlcRep *);
	int    AllocInnerIterItem();
	const TrfrAnlzViewItem * GetInnerIterItem() const;
private:
	static int   DynFuncGetRest;
	static int   DynFuncGetAvgRest;
	static int   DynFuncGetTrnovr;
	static int   DynFuncExtFactor;

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw); // @<<PPView::Browse
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual int  SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    CreateTempTable();
	int    CreateOrderTable(IterOrder);
	int    Add(BExtInsert * pBei, long * pOprNo, TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    InitGrpngNames();
	int    NextOuterIteration();
	int    NextInnerIteration(TrfrAnlzViewItem *);
	void   FASTCALL InitAppData(TrfrAnlzViewItem *);
	//
	// If billID != 0 (Filt.Grp == gGoodsBill) then function suppose pBuf
	// too contains bill.Code and write date format at front of them
	// (function Add must write bill code to field TempTrfrGrpngTbl.DtText).
	//
	void   InitDateText(LDATE, PPID billID, SString & rBuf);
	//int    InitDateText(LDATE, PPID billID, char * pBuf, size_t bufLen);
	//
	// Descr: возвращает сальдо на указанную дату. Если дата не указана (ZERODATE), тогда на текущую дату.
	//
	int    GetSaldo(PPID goodsID, PPID artID, PPID dlvrLocID, LDATE dt, double * pSaldoQtty, double * pSaldoAmt);
	int    AddAbsentSaldo();
	int    GetArticlesBySaldo(PPID gdsID, PPIDArray * pArtAry);
	int    GetDlvrLocID(const BillTbl::Rec *, PPID * pDlvrLocID);
	int    InitDlvrLocID(const BillTbl::Rec *, PPID * pDlvrLocID, TempTrfrGrpngTbl::Rec *);
	int    CalcInRest(PPID goodsID, double * pRest);
	SString & GetCtColumnTitle(int ct, SString & rBuf);
	TagrCacheItem & FASTCALL GetCacheItem(uint pos) const;
	int    FlashCacheItems(uint count);
	int    FlashCacheItem(BExtInsert * pBei, const TagrCacheItem & rItem);
	bool   IsExtFactorEmpty() const;
	int    GetExtFactorTitle(SString & rTitle) const;

	TrfrAnlzFilt Filt; // @viewstatefilt
	enum {
		fAsGoodsCard = 0x0001,  // Работает как карточка товара с расчетом остатка после каждой операции
		fShowSaldo   = 0x0002,  // Рассчитывать и показывать товарное сальдо по операциям с клиентом
		fAccsCost    = 0x0004,  // Разрешен доступ к ценам поступления //
		fOnceInited  = 0x0008   // Объект как минимум один раз был инициализирован вызовом Init_
	};
	long   Flags;         // @viewstate
	double InRest;        // @viewstate
	IterOrder CurViewOrd; // @viewstate
	IterOrder CurIterOrd;
	PPIDArray LocList;    // @viewstate
	GoodsSubstList Gsl;   // @viewstate
	PPObjPerson::SubstParam Psp;
	TempTrfrAnlzTbl  * P_TrAnlzTbl;  // @viewstatetable
	TempTrfrGrpngTbl * P_TrGrpngTbl; // @viewstatetable
	TempOrderTbl * P_OrderTbl;   // @viewstatetable
	BExtQuery * P_IterOrderQuery;
	GCTIterator::GoodsRestArray GctRestList; // @viewstate
	TrfrAnlzTotal Total;
	PPID   PrevOuterID;
	PPID   CurOuterID;
	TrfrAnlzViewItem * P_InnerIterItem; // Внутренний собственнй экземпляр элемента текущей итерации.
		// Если необходим, должен быть распределен функцией AllocInnerIterItem()
	LAssocArray LocCountList;
	PPObjArticle ArObj;
	SArray Cache;
	CompFunc Cf;  // @*PPViewTrfrAnlz::Init_
	long   GrpIdCounter;
	long   LastCacheTouch;
	const uint MaxCacheItems; // Максимальное количество элементов в кэше
	const uint CacheDelta;    // Количество элементов, сбрасываемое из кэша в базу данных при переполнении кэша
	AlcReportParam AlcRepParam; // Для алкогольной декларации
	PPObjGoods  GObj;
	PPObjGoodsClass GdsClsObj;
	PPObjBill * P_BObj;
	PPObjPerson PsnObj;
	PPObjTag    TagObj;
};
//
// Descr: Универсальная параметрическая структура для автоматического создания документов.
// Note: Это, кроме прочего - попытка унифицировать механизмы автоматического создания документов, разбросанные
//   на текущий момент по всему проекту.
//PPViewCCheck::CreateDraftBySuspCheck(PPID chkID)
//PPViewSStat::CreateDraftBySupplOrders(const SStatFilt *)
//PPViewCSess::CreateDraft(const CSessCrDraftParam *);
//
class PPBillAutoCreateParam : public PPBaseFilt {
public:
	PPBillAutoCreateParam();
	PPBillAutoCreateParam(const PPBillAutoCreateParam & rS);
	PPBillAutoCreateParam & FASTCALL operator = (const PPBillAutoCreateParam & rS);
	//
	// Descr: Возвращает внутренний фильтр для обработки данных, в зависимости от
	//   параметра a. Если a == -1, то возвращает фильтр, зависящий от текущего значения A.
	//
	PPBaseFilt * FASTCALL GetInnerFilt(int a) const;
	//
	// Descr: Типы функционала по созданию документов
	//
	enum {
		aNone = 0,
		aDraftByTrfrAnlz = 1, // Драфт-документы по анализу товарных операций
		aDraftBySuspCc,       // Драфт-документы по отложенным кассовым чекам
		aDraftBySupplOrders,  // Драфт-документы заказов поставщикам
		aDraftByCcRule        // Драфт-документы по правилам на основе кассовых чеков
	};
	uint8  ReserveStart[64];
    PPID   OpID;
    long   A;                  // Тип функционала, вызываемого по данному параметру
    long   Flags;
	int32  RuleGrpID;          // CSessCrDraftParam
	int32  RuleID;             // CSessCrDraftParam
    long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
	TrfrAnlzFilt * P_TaF;
	SStatFilt * P_SsF;
	CCheckFilt * P_CcF;
	CSessFilt  * P_CsF;
private:
	int    InitInstance();
};

class PrcssrBillAutoCreate {
public:
	PrcssrBillAutoCreate();
	~PrcssrBillAutoCreate();
	int    InitParam(PPBillAutoCreateParam *);
	int    EditParam(PPBillAutoCreateParam *);
	int    Init(const PPBillAutoCreateParam *);
	int    Run();
	int    CreateDraftByTrfrAnlz();
	static int CreateDraftByCSessRule(const CSessCrDraftParam * pParam);
	static int CreateDraftBySupplOrders(const SStatFilt * pFilt);
private:
    PPViewTrfrAnlz * P_TaV;
    PPViewSStat * P_SsV;
    PPViewCCheck * P_CcV;
    PPViewCSess * P_CsV;
	PPBillAutoCreateParam P;
};
//
// @ModuleDecl(PPViewGoodsOpAnalyze)
//   Товарный отчет по операции
//
#define ABC_GRPSCOUNT 5L

struct ABCAnlzFilt {
	enum {
		GroupByCostSum  = 0,
		GroupByPriceSum = 1,
		GroupByQtty     = 2,
		GroupByIncome   = 3
	};
	int    CheckFracts(double * pFractsSum);
	int    GetGroupName(short abcGroup, char * pBuf, size_t bufLen);
	void   SortGrpFract();

	double GrpFract[ABC_GRPSCOUNT];
	long   GroupBy;
};

struct GoodsOpAnalyzeFilt : public PPBaseFilt {
	GoodsOpAnalyzeFilt();
	virtual int Describe(long flags, SString & rBuff) const;
	SString & FASTCALL GetOpName(SString & rName) const;
	bool   FASTCALL IsValidABCGroup(short abcGroup) const;
	//
	// Descr: Возвращает !0 если фильтр предполагает расчет анализа вход/выход с заданными лидирующими товарами
	//   (OpGrpID == ogInOutAnalyze && Flags & fLeaderInOutGoods && GoodsIdList.GetCount())
	//
	bool   IsLeadedInOutAnalyze() const;
	void   ZeroCompareItems();
	void   FASTCALL AddTradePlanBillID(PPID);

	enum { // OpGrp
		ogSelected                = 0, // На выбор (opr)
		ogIncoming                = 1, // Все операции, приносящие доход (расход товара)
		ogProfitable              = 2, // Все доходные операции, включая возвраты
		ogPayed                   = 3, // Все оплаченные доходные операции
		ogInOutAnalyze            = 4, // Анализ вход-выход (по обобщенной операции или по модификации)
		ogMarketplaceSalesAnalyze = 5, // @v12.1.6 Анализ продаж на маркетплейсе
	};
	enum {
		fLabelOnly           = 0x00000001, // Только по WL-документам
		fDiffByPrice         = 0x00000002, // Разбивать по ценам реализации
		fDiffByNetPrice      = 0x00000004, // Разбивать по чистым ценам реализации
		fIntrReval           = 0x00000008, // Разница цен при межскладском перемещении
		fPriceWithoutExcise  = 0x00000010, // Из цены реализации вычитать акциз
		fUseABCAnlz          = 0x00000020, // Использовать ABC анализ
		fCalcRest            = 0x00000040, // Рассчитывать колонку остатков
		fPriceDeviation      = 0x00000080, // Отклонение цен
		fDisplayWoPacks      = 0x00000100, // Количество показывать без упаковок
		fEachLocation        = 0x00000200, // Раздельно по каждому складу
		fCalcOrder           = 0x00000400, // Рассчитывать незакрытые заказы (количество)
		fShowSStatSales      = 0x00000800, // Показывать средне-дневные продажи из статистики продаж
		fCompareWithReceipt  = 0x00001000, // Сравнивать с документами закупки
		fUnprofitableGoods   = 0x00002000, // Убыточные товары
		fBadSellingGoods     = 0x00004000, // Плохо продающиеся товары
		fComparePctDiff      = 0x00008000, // При расчете сравнения разницу показывать в %
		fBillListAsTradePlan = 0x00010000, // @internal Список документов трактуется как набор документов планов продаж
		fTradePlanObjAsSuppl = 0x00020000, // @internal Интерпретировать контрагента документов плана продаж как поставщика (план продаж по поставщикам)
		fTradePlanGoodsOnly  = 0x00040000, // Показывать только те позиции, которые есть в торговом плане
		fAddNzRestItems      = 0x00080000, // Дополнить отчет позициями, которые есть на остатке (при наличии флага fCalcRest)
		fCrosstab            = 0x00100000, // Кросстаб
		fABCAnlzByGGrps      = 0x00200000, // ABC анализ рассчитывать для каждой товарной группы отдельно
		fCalcCVat            = 0x00400000, // Рассчитывать валовую сумму НДС в ценах поступления //
		fCalcPVat            = 0x00800000, // Рассчитывать валовую сумму НДС в ценах реализации //
		fLeaderInOutGoods    = 0x01000000  // Список товаров GoodsIdList является ведущим для анализа вход/выход
	};
	//
	// Ид. дополнительных полей товарного точета по операции
	//
	enum {
		fldidQtty  = 1,
		fldidRest,
		fldidCostRest,
		fldidPriceRest,
		fldidCostAmount,
		fldidPriceAmount,
		fldidIncome,
		fldidPctProfitable,
		fldidPctMargin
	};
	//
	// Флаги дополнительных полей
	//
	enum {
		ffldMainPeriod = 0x00000001L,
		ffldCmpPeriod  = 0x00000002L,
		ffldDiff       = 0x00000004L
	};

	char   ReserveStart[4];    // @anchor // @v12.1.12 [8]-->[4]
	PPID   MarketplaceGuaID;   // @v12.1.12 Ид глобальной учетной записи для взаимодействия с маркетплейсом. Используется если OpGrpID==ogMarketplaceSalesAnalyze
	PPID   FreightAgentID;     // ->Person.ID Транспортный брокер
	SubstGrpBill Sgb;          // Подстановка документа.
		// Если !!Sgb то отчет строится не в разрезе товаров (или их подстановок), а в разрезе подстановочного
		// атрибута документов.
		// При этом отключаются следующие возможности:
		// -- расчет остатков (fCalcRest)
		// -- подстановка товара (Sgg)
		// -- среднедневные продажи (fShowSStatSales)
		// -- разбивка по ценам (fDiffByPrice, fDiffByNetPrice)
	LDATE  CmpRestCalcDate;    // Дата расчета остатков для сравнения (используется если Flags & fCalcRest)
	DateRange CmpPeriod;       // Период для сравнения //
	DateRange Period;          // Период документов
	PPID   OpID;               // ->Ref(PPOBJ_OPRKIND) Вид операции, по которой следует анализировать документы
	PPID   OpGrpID;            // GoodsOpAnalyzeFilt::opXXX Группа операций
	PPID   AccSheetID;         // ->Ref(PPOBJ_ACCSHEET).ID
	PPID   ObjectID;           // ->Article.ID Контрагент по документам
	PPID   ObjCityID;          // ->City.ID    Город нахождения контрагента
	PPID   SupplID;            // ->Article.ID Поставщик
	PPID   AgentID;            // ->Article.ID Агент по документам
	PPID   SupplAgentID;       // ->Article.ID Агент поставщика
	PPID   GoodsGrpID;         // ->Goods2.ID  Товарная группа. Если GoodsIdList.IsExists(), то GoodsGrpID не используется //
	long   Flags;              // @flags
	SubstGrpGoods Sgg;         // Подстановка товара
	LDATE  RestCalcDate;       // Дата расчета остатков (используется если Flags & fCalcRest)
	ABCAnlzFilt ABCAnlz;       // Параметры ABC-анализа
	short  ABCAnlzGroup;       // 0 - no ABC, 1 - grouping recs name, 2 - grouping recs and detail, -1, -2 .. - belong to group
	uint16 Pad;                // @alignment
	PPID   QuotKindID;         // ->Quotation.ID Вид котировки, который следует использовать вместо цены реализации
	PPID   Object2;            // Дополнительный объект. Таблица статей для данного объекта берется из вида операции.
	ObjIdListFilt GoodsIdList; // Список товаров. Если GoodsIdList.IsExists() то GoodsGrpID не используется.
	ObjIdListFilt BillList;    // Список документов. Если BillList.IsExists(), то поля OpID, OpGrpID, AccSheetID, LocList и ObjectID игнорируются.
	ObjIdListFilt LocList;     // Список складов
	ObjRestrictArray CompareItems;
};

struct GoodsOpAnalyzeViewItem {
	struct CmVal {
		CmVal() : Val(0.0), Cm(0.0)
		{
		}
		operator double() const { return Val; }
		double FASTCALL operator = (double val) { Val = val; return Val; }
		void   SetCm(double cm) { Cm = cm; }
		double GetDiff() const { return (Val - Cm); }
		double GetPctDiff() const { return fdivnz(Val - Cm, Cm); }

		double Val;     // Основное значение
		double Cm;      // Значение из сравнительного периода
	};
	PPID   ID__;
	PPID   LocID;          //
	int16  InOutTag;       // -1 - in, 1 - out, 0 - undef
	int16  Reserve;        // @alignment
	PPID   GoodsID;        // Если используется подстановка инородного объекта (производитель, атрибуты класса), то поле содержит маску 0x40000000L
	PPID   GoodsGrpID;     //
	PPID   SubstArID;      // Статья, подставленная вместо GoodsID
	PPID   SubstPsnID;     // Персоналия, подставленная вместо GoodsID
	PPID   SubstLocID;     // Склад, подставленный вместо GoodsID
	char   GoodsName[128]; //
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsTaxAnalyze instance
	double UnitPerPack;
	CmVal  Qtty;
	double PhQtty;
	union {
		double OldCost;    // Старая цена поступления (для переоценки)
		double PlanQtty;   // Плановое количество
	};
	union {
		double OldPrice;   // Старая цена реализации (для переоценки)
		double PlanSumPrice; // Плановая сумма продаж (закупок)
	};
	double Cost;
	double Price;
	CmVal  SumCost;
	CmVal  SumPrice;
	CmVal  Income;         // SumPrice-SumCost
	CmVal  SumCVat;        // Валовая сумма НДС в ценах поступления
	CmVal  SumPVat;        // Валовая сумма НДС в ценах реализации
	double PctVal;         //
	CmVal  Rest;           // Остаток в торговых единицах
	CmVal  PhRest;         // Остаток в физических единицах
	CmVal  RestCostSum;
	CmVal  RestPriceSum;
};

struct GoodsOpAnalyzeTotal {
	GoodsOpAnalyzeTotal();
	void   Init();
	GoodsOpAnalyzeTotal & FASTCALL operator = (const GoodsOpAnalyzeTotal &);

	long   Count;
	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
	double Income;
	double SumCVat;        // Валовая сумма НДС в ценах поступления
	double SumPVat;        // Валовая сумма НДС в ценах реализации
	double Rest;           // Остаток в торговых единицах
	double PhRest;         // Остаток в физических единицах
	double RestCost;
	double RestPrice;
	double PlanQtty;
	double PlanSum;
	AmtList Amounts;
	long   InCount;
	double InQtty;
	double InPhQtty;
	double InCost;
	double InPrice;
	double InIncome;
	BzsValVector IndicatorVect; // @v12.1.11
};

class PPViewGoodsOpAnalyze : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrp_GoodsName,
		OrdByQtty,
		OrdByCostSum,
		OrdByPriceSum,
		OrdByIncome,
		OrdByRest     // Только если Filt.Flags & fCalcRest
	};
	struct BrwHdr {
		PPID   RowId;
		PPID   LocID;
		PPID   GoodsID;
		char   Text[128];
		double Quantity;
		double PhQtty;
		double SumCost;
		double SumPrice;
		double Income;
		short  InOutTag;
	};

	PPViewGoodsOpAnalyze();
	~PPViewGoodsOpAnalyze();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	int    InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsOpAnalyzeViewItem *);
	int    ChangeOrder(BrowserWindow *);
	int    CalcTotal(GoodsOpAnalyzeTotal *);
	int    ConvertLinesToBasket();
	int    ABCGrpToAltGrp(short abcGroup);
	void   GetTempTableName(SString & rBuf) const;
	int    GetByID(PPID id, TempGoodsOprTbl::Rec * pRec);
	int    InitUniq(const SArray * pUniq);
	void   CopyUniq(SArray * pUniq) const;
	void   GetTabTitle(long tabID, SString & rBuf);
	void   GetEditIds(const void * pRow, PPID * pLocID, PPID * pGoodsID, long col);
private:
	static  int  FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk); // @v12.1.7
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk); // @v12.1.7
	int    CreateTempTable(double * pUfpFactors);
	int    CreateOrderTable(IterOrder, TempOrderTbl **);
	int    InitGoodsRestView(PPViewGoodsRest * pGrView);
	int    FASTCALL CheckBillRec(const BillTbl::Rec *);
	int    PutBillToTempTable(PPBillPacket *, double part, int sign, const PPIDArray * pSupplBillList);
	int    InitIterQuery(PPID grpID);
	int    NextOuterIteration();
	int    SetupCrosstabColumns(PPViewBrowser * pBrw);
	PPViewGoodsOpAnalyze::IterOrder GetIterOrder() const;
	void   InitAddingBlock(const PPBillPacket * pPack, double part, int sign, GoaAddingBlock * pBlk);
		// @<<PutBillToTempTable
	int    PreprocessTi(const PPTransferItem * pTi, const PPIDArray * pSupplBillList, long substBillVal, GoaAddingBlock * pBlk);
		// @<<PutBillToTempTable
	GoaCacheItem * FASTCALL GetCacheItem(uint pos) const;
	int    FlashCacheItems(uint count);
	int    FlashCacheItem(BExtInsert * pBei, const GoaCacheItem * pItem);
	int    AddItem(const GoaAddingBlock & rBlk);
	int    ViewGraph();
	int    ViewDetail(PPViewBrowser * pBrw, PPID rowIdent, PPID locID, PPID goodsID, short abcGroup, bool viewAllLots/*=false*/);

	GoodsOpAnalyzeFilt Filt;
	PPObjBill   * P_BObj;
	PPObjGoods    GObj;
	PPObjPerson   PsnObj;
	PPObjLocation LocObj;
	PredictSalesCore * P_Psc;
	TempGoodsOprTbl * P_TempTbl;
	TempOrderTbl    * P_TempOrd;
	GoodsSubstList    Gsl;
	PPObjBill::SubstParam Bsp;           // Параметр подстановки по документам
	GoodsOpAnalyzeTotal Total;
	TrfrAnlzFilt * P_TrfrFilt;
	PPTrfrArray  * P_TradePlanPacket;
	PPViewGoodsOpAnalyze * P_CmpView;
	CompFunc Cf;                         // @*PPViewGoodsOpAnalyze::Init_
	CompFunc Cf_UniqItem;                // @*PPViewGoodsOpAnalyze::Init_
	enum {
		sFiltAltGrp     = 0x0001,        // @*PPViewGoodsOpAnalyze::Init_
		sFiltExclFolder = 0x0002,        // @*PPViewGoodsOpAnalyze::Init_
		sTotalInited    = 0x0004,
		sAccsCost       = 0x0008,
		sReval          = 0x0010         // Отчет строится по операции переоценки
	};
	long   State;
	SArray * P_Cache;
	SArray * P_Uniq;
	ObjIdListFilt LocList_; // @v12.1.5
	UintHashTable * P_GoodsList;         // @*PPViewGoodsOpAnalyze::Init_
	GoodsGroupIterator * P_GGIter;
	IterOrder CurrentViewOrder;
	int    IterIdx;
	SString IterGrpName;

	class IndicatorVector : public BzsValVector {
	public:
		IndicatorVector();

		int    Sign;
		PPID   GoodsID;
		PPID   ArID;
		PPID   LocID;
	};
	TSCollection <IndicatorVector> IndicatorList; // @v12.1.7

	IndicatorVector * GetIndicatorEntry(const GoaAddingBlock & rBlk);
	IndicatorVector * GetIndicatorEntry(PPID goodsID, PPID arID, PPID locID, int sign);
	//
	// Descr: Возвращает элемент списка IndicatorList, имеющий идентификатор равный ident.
	// Note: Поскольку поиск бинарный, то список обязательно должен быть отсортирован по идентификатору методом 
	//   IndicatorList.sort2(PTR_CMPFUNC(BzsValVector_Ident)).
	//
	const IndicatorVector * GetIndicatorEntryC(PPID ident) const;
	
	struct MarketplaceDetailBlock {
		MarketplaceDetailBlock & Z()
		{
			OrdList.Z();
			ShipmList.Z();
			RetList.Z(); // @v12.1.11
			CancelledOrdList.Z();
			return *this;
		}
		PPIDArray OrdList;           // Список документов заказа
		PPIDArray ShipmList;         // Список документов отгрузки  
		PPIDArray RetList;           // @v12.1.11 Список документов возврата от покупателей
		PPIDArray CancelledOrdList;  // Список документов заказа которые были отменены 
	};
	MarketplaceDetailBlock MpDBlk;
};
//
// Descr: unit-анализ (пока только по товарам)
//
class UnitEcFilt : public PPBaseFilt {
public:
	UnitEcFilt();
	UnitEcFilt & FASTCALL operator = (const UnitEcFilt & rS);
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;        //
	PPID   GoodsGroupID;     // Товарная группа, ограничивающая список анализируемых товаров
	long   Flags;            //
	long   Reserve;          // @anchor
};

struct UnitEcViewItem {
	PPID   ID;
};

class PPViewUnitEc : public PPView {
public:
	struct BrwItem {
		PPID   ID;
		PPID   GStrucID;
	};
	PPViewUnitEc();
	~PPViewUnitEc();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(UnitEcViewItem * pItem);
private:
	struct InitialGoodsParam {
		InitialGoodsParam();
		bool   FASTCALL operator == (const InitialGoodsParam & rS) const { return IsEq(rS); }
		bool   FASTCALL operator != (const InitialGoodsParam & rS) const { return !IsEq(rS); }
		bool   FASTCALL IsEq(const InitialGoodsParam & rS) const;
		double RcptQtty;
		double ExpectedDemandPerWeek;
	};
	struct Indicator {
		Indicator();
		long   ID;    // Ид бизнес-показателя (PPObjBizScore2)
		long   Cls;   // Класс бизнес-показателя (если таковой определен для ID)
		double Value;
	};
	class IndicatorVector : public TSVector <Indicator> {
	public:
		IndicatorVector();
		int    Add(long bizScoreId, long bizScoreCls, double value);
		void   GetClsList(LongArray & rList) const;
		const  Indicator * GetClsEntryC(long cls) const;
		const  Indicator * GetBsEntryC(long bsID) const;
		Indicator * GetClsEntry(long cls);
		Indicator * GetBsEntry(long bsID);
		double GetTotalIncome() const;
		double GetTotalExpense() const;
		PPID   ID;
		PPID   AddendumID; // Для товара это - ид структуры
		InitialGoodsParam IgP;
	};
	//
	// Descr: Набор факторов для расчета итоговых значений по бизнес-показателям.
	//
	struct FactorSet {
		FactorSet() : DaysCount(0), SaleQtty(0.0), RcptQtty(0.0), StorageDaysQtty(0.0)
		{
		}
		FactorSet & Z()
		{
			DaysCount = 0;
			SaleQtty = 0.0;
			RcptQtty = 0.0;
			StorageDaysQtty = 0.0;
			return *this;
		}
		uint   DaysCount;
		double SaleQtty;
		double RcptQtty;
		double StorageDaysQtty;
	};

	static  int  FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeEntry(IndicatorVector * pVec, BrwItem * pItem);
	int    MakeList(PPViewBrowser * pBrw);
	int    MakeProcessingList(TSCollection <IndicatorVector> & rList); 
	int    EvaluateFactors(const IndicatorVector * pVec, FactorSet & rSet);
	int    GetCommonIndicatorClsList(LongArray & rList);
	const  IndicatorVector * GetEntryByID_Const(long id) const;
	IndicatorVector * GetEntryByID(long id);
	int    EditInitialGoodsParam(const BrwItem * pItem);

	TSCollection <IndicatorVector> IndicatorList; // @v12.1.7
	UnitEcFilt Filt;
	//PPIDArray GoodsIdList; // Список товаров, по которым проводится анализ
	SArray * P_DsList;
	//TSVector <InitialGoodsEntry> IgeList;
	//
	PPObjGoods GObj;
	PPObjGoodsStruc GsObj;
	PPObjBizScore2 BsObj;
};
//
// @ModuleDecl(PPViewSCard)
//
struct SCardFilt : public PPBaseFilt {
	SCardFilt();
	SCardFilt & FASTCALL operator = (const SCardFilt & rS);
	PPID   GetOwnerPersonKind() const;

	enum {
		fSinceLastPDisUpdating = 0x0001,
		fWoOwner       = 0x0002,
		fShowOwnerAddrDetail   = 0x0004,
		fWithAddressOnly       = 0x0008, // Показывать только карты с адресами (если !fShowOwnerAddrDetail, то не применяется)
		fNumberFromBeg = 0x0010, // this->Number трактовать как строку, содержащуюся с начала кода
		fNoTempTable   = 0x0020, // @internal
		fNoEmployer    = 0x0040, // @internal Не заполнять поле SCardViewItem::EmployerID (для увеличения производительности)
		fInnerFilter   = 0x0080  // Внутренний флаг, используемый для ограничений редактирования внутреннего фильтра
	};
	uint8  ReserveStart[12]; // @anchor
	PPID   LocID;            // -->Location.ID Локация, которой принадлежат карты
	DateRange IssuePeriod;   // Период даты выпуска карты
	DateRange ExpiryPeriod;  // Период срока истечения годности карты
	DateRange TrnovrPeriod;  // Показывать обороты за указанный период
	PPID   SeriesID;      // Серия карт. Если ScsList.NotEmpty(), то SeriesID игнорируется.
	PPID   PersonID;      //
	PPID   EmployerID;    // Работодатель, чьи сотрудники владеют картами
	RealRange PDisR;      //
	RealRange TurnoverR;  //
	int16  Ft_Inherited;  //
	int16  Ft_Closed;     //
	long   Order;         // PPViewSCard::IterOrder
	long   Flags;         //
	long   Reserve;       // @anchor Заглушка для отмера плоского участка фильтра
	SString Number;       // Номер дисконтной карты
	ObjIdListFilt ScsList;     // @v8.4.2 @construction Список серий
	SysJournalFilt * P_SjF;    //
	SCardFilt * P_ExludeOwnerF; // Фильтр, по которому из выборки исключаются владельцы карт, под него подпадающие
	PersonFilt * P_OwnerF;      // @v8.4.2 @construction Фильтр по владельцам
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
};

struct SCardTotal {
	SCardTotal() : Count(0), Turnover(0.0)
	{
	}
	long   Count;
	double Turnover;       // Суммарный оборот
};

struct SCardViewItem : public SCardTbl::Rec {
	PPID   EmployerID;
};

struct SCardSelPrcssrParam { // @persistent
	enum {
		fSetClosed     = 0x0001,
		fZeroDiscount  = 0x0002, // Если установлен, но по всем картам скидку требуется обнулить
		fZeroExpiry    = 0x0004, // Пустое значение даты истечения срока действия
		fUhttSync      = 0x0008, // Синхронизировать (некоторые атрибуты) с сервисом Universe-HTT
		fAppendEan13CD = 0x0010  // Дополнить недостающей контрольной цифрой EAN-13
	};
	SCardSelPrcssrParam();
	bool   IsEmpty() const;
	void   Init();
	bool   Validate(PPID srcSeriesID);
	int    Write(SBuffer & rBuf, long) const;
	int    Read(SBuffer & rBuf, long);
	//
	// Соображения по обратной совместимости:
	//    Если в поле Ver стоит номер версии, меньший, чем 7.6.12, то считавыем это поле как Flags и пропускаем AutoGoodsID.
	//    Здесь приходится закладываться на то, что Flags мог иметь значение либо 0 либо 1.
	//
	SVerT  Ver;         //
	int32  Flags;
	LDATE  DtEnd;
	int32  NewSerID;
	int32  AutoGoodsID; //
	//
	int32  FlagsSet;    // Флаги, которые следует установить
	int32  FlagsReset;  // Флаги, которые следует снять
	int16  PeriodTerm;  // Тип периода длительности срока действия //
	int16  PeriodCount; // Количество периодов длительности срока действия //
	double Discount;    // Процент скидки //
	//
	SCardFilt SelFilt;
};

class PPViewSCard : public PPView {
public:
	enum IterOrder {
		OrdBySeries_Code = 0,
		OrdByDiscount,
		OrdByTrnovr,
		OrdByPerson,
		OrdByExpiry
	};
	struct BrwHdr {
		PPID   ID;
	};

	PPViewSCard();
	~PPViewSCard();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int  EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(SCardViewItem *);
	int    DeleteItem(PPID);
	int    ViewOps(PPID);
	int    ChargeCredit();       // Начисление на выборку кредитных карт
	int    ChangeDiscount();     // Изменение процента скидки по выборке карт
	int    RecalcTurnover();
	int    RecalcRests();
	int    Transmit(PPID);
	int    ReplaceCardInChecks(PPID destCardID);
	int    ChangeFlags();
	int    RenameDup(PPIDArray * pIdList);
	int    PreprocessTempRec(const SCardTbl::Rec * pSrcRec, TempSCardTbl::Rec * pDestRec, RAssocArray * pTrnovrList/*, int calcTrnovr*/);
	int    ProcessSelection(const SCardSelPrcssrParam * pParam, PPLogger *);
	const  StrAssocArray & GetList() const { return List; }
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle);
private:
	struct PreprocessScRecBlock {
		PreprocessScRecBlock();

		PPID   ScID;
		double InTurnover;
		double Turnover;
	};
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * GetEditExtraParam();
	virtual void ViewTotal();
	int    CheckForFilt(const SCardTbl::Rec * pRec, PreprocessScRecBlock * pBlk);
	bool   IsTempTblNeeded() const;
	int    CreateTempTable();
	int    CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	int    UpdateTempTable(PPIDArray * pIdList);
	int    MakeTempOrdEntry(long ord, const SCardTbl::Rec * pRec, TempOrderTbl::Rec * pOrdRec);
	int    GetPDisUpdateDate(PPID cardID, LDATE before, LDATE * pDate);

	SCardFilt Filt;
	PPObjSCard SCObj;
	PPObjPerson PsnObj;
	PPObjStaffList * P_StffObj;
	PPLocAddrStruc Las;
	StrAssocArray List;
	ObjIdListFilt ExcludeOwnerList;
	ObjIdListFilt SeriesList; // эффективный список фильтрующих серий (с учетом группирующих)
	TempSCardTbl * P_TmpTbl;
	TempOrderTbl * P_TempOrd;
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в TempSCardTbl
};
//
// Descr: Диалог редактирования параметров для массового изменения персональных карт
//
class SCardSelPrcssrDialog : public TDialog {
public:
	SCardSelPrcssrDialog(PPViewSCard * pView, int editSCardFilt);
	int    setDTS(const SCardSelPrcssrParam * pData);
	int    getDTS(SCardSelPrcssrParam * pData);
private:
	DECL_HANDLE_EVENT;
	int    EditSCardFilt;
	SCardSelPrcssrParam Data;
	PPViewSCard * P_View;
};
//
// @ModuleDecl(PPViewSCardOp)
//   Operations by card
//
struct SCardOpFilt : public PPBaseFilt {
	SCardOpFilt();

	uint8  ReserveStart[32]; // @anchor
	PPID   SCardID;
	PPID   SCardSerID;
	DateRange Period;
	RealRange AmtR;
	long   Flags;
	long   Order;
	long   Reserve;          // @anchor Заглушка для отмера плоского участка фильтра
};

typedef SCardOpTbl::Rec SCardOpViewItem;

struct SCardOpTotal {
	long   Count;
	double InRest;
	double OutRest;
	double Debit;
	double Credit;
};

class PPViewSCardOp : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByDate,
		ordByCard,
		ordByOwner,
		ordByAmount
	};
	struct BrwHdr {
		PPID   SCardID;
		LDATE  Dt;
		LTIME  Tm;
	};
	PPViewSCardOp();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int  EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(SCardOpViewItem *);
	int    CalcTotal(SCardOpTotal *);
	int    AddItem(int freezing);
private:
	static int DynFuncExtObjName;

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    Recover();

	SCardOpFilt Filt;
	PPObjSCard SCObj;
	LDATETIME IterPos;
};
//
// @ModuleDecl(PPViewUhttSCardOp)
//
class UhttSCardOpFilt : public PPBaseFilt {
public:
	UhttSCardOpFilt();

	enum {
		gNone = 0,
		gTotal,
		gDate,
		gSCard,
		gDlvrLoc
	};
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   GlobalAccID;
	PPID   DlvrLocID;
	int    Grp;
	long   Reserve;          // @anchor
};

struct UhttSCardOpViewItem {
	LDATETIME Dtm;
	PPID   SCardID;
	PPID   DlvrLocID;
	long   SellCount;
	double SellAmt;
	long   ChargeCount;
	double ChargeAmt;
	long   WithdrawCount;
	double WithdrawAmt;
	double SCardRest;
};

class PPViewUhttSCardOp : public PPView {
public:
	PPViewUhttSCardOp();
	~PPViewUhttSCardOp();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(UhttSCardOpViewItem *);
	int    CalcTotal(UhttSCardOpViewItem *, int) const;
	const TSArray <UhttSCardOpViewItem> * GetList() const { return &List; };
private:
	int    Helper_AddItem(UhttSCardOpViewItem &);
	TSArray <UhttSCardOpViewItem> List;
	UhttSCardOpFilt Filt;
	PPObjSCard ScObj;
	SString ScPrefix;
};
//
// @ModuleDecl(PPViewArticle)
//
typedef ArticleTbl::Rec ArticleViewItem;

#define DEBTDIM_BRW_SHOWCOUNT 15

class PPViewArticle : public PPView {
public:
	enum {
		ordByName    = 0,
		ordByArticle = 1,
		ordByDefault = 2
	};
	PPViewArticle();
	~PPViewArticle();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual int  EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(ArticleViewItem *);
private:
	virtual int   ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * GetEditExtraParam();
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void  PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   OnExecBrowser(PPViewBrowser * pBrw); // @v10.2.8
	virtual int   Print(const void *);
	int    UpdateTempTable(PPID arID);
	int    EditLinkObject(PPID arID);
	int    InitDebtLim(TempArAgtTbl::Rec * pRec, const PPClientAgreement * pCliAgt);
	int    EditDebtDimList(PPID arID);
	int    Transmit(PPID id);
	int    UpdateAll();
	int    RecoverLinkObjects();

	StrAssocArray * P_DebtDimList;
	PPObjArticle ArObj;
	ArticleFilt  Filt;
	int    CurIterOrd;
	int    CtrlX;
	long   LimitTerm;      // @*Init_
	long   AddedLimitTerm; // @*Init_
	PPID   AgtProp; // @#[ARTPRP_CLIAGT2, ARTPRP_SUPPLAGT]
	TempArAgtTbl * P_TempTbl;
};
//
// Beignig of Basket's Headers PPObj.h
//
#define GBASKF_DEFAULT   0x0001L // Корзина используемая по умолчанию
#define GBASKF_SORTITEMS 0x0002L // Сортировать строки по наименованию товаров
#define GBASKF_PRIVATE   0x0004L // @transient Приватная корзина. Удерживается в текущем
	// сеансе и не сохраняется в базе пока пользователь не завершит сеанс или не снимет признак приватности.
//
// Descr: Заголовочная струкутра товарной корзины
//
struct PPGoodsBasket2 {    // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_GOODSBASKET
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve1[56];   // @reserve
	long   Num;            // Внутренний номер (не используется, но инициализируется)
	long   Flags;          // GBASKF_XXX
	PPID   User;           // ->Ref(PPOBJ_USR) Пользователь, создавший корзину
	PPID   SupplID;        // ->Article.ID
};

class PPBasketPacket : public ILBillPacket {
public:
	PPBasketPacket();
	~PPBasketPacket();
	void   Init();
	PPBasketPacket & FASTCALL operator = (const PPBasketPacket &);
	//
	// Descr: Инициализирует внутренние структуры для поддержки корректного
	//   добавления элементов функцией AddItem.
	//
	void   InitInsertion();
	//
	// Descr: Добавляет элемент в корзину
	// ARG(pItem         IN): Элемент, добавляемый в корзину.
	// ARG(pPos         OUT): Позиция, в которой находится элемент после вставки в корзину
	// ARG(replaceOption IN): Опции обработки наличия товара pItem->GoodsID в корзине.
	//   1 - возвращает ошибку (PPErrCode = PPERR_DUPBASKETITEM)
	//   2 - заменяет существующий элемент в корзине
	//   3 - удаляет существующий в корзине элемент, а на его место вставляет pItem
	//       с количеством (Quantity) равным сумме количества в существующем и вставляемом элементах
	//   other - возвращает ошибку (PPErrCode = PPERR_DUPBASKETITEM)
	//
	int    AddItem(const ILTI * pItem, uint * pPos, int replaceOptions = 1);
	int    DelItem(long);
	int    SearchGoodsID(PPID goodsID, uint * pPos) const;

	PPID   GoodsID;
	PPGoodsBasket Head;
private:
	PPIDArray InsertedGoodsList; // Список товаров, добавленных в корзину
};

#define SRCH_DEFBASKET      1
#define SRCH_BASKET         2
#define SRCH_LOCKEDBASKET   3
#define SRCH_UNLOCKEDBASKET 4

// @v5.8.11 VADIM {
//   int action = 1 - disable selection;
//      = 2 - dialog to cascade;
//      = 3 - edit basket name and flags
// } @v5.8.11 VADIM
int  GoodsBasketDialog(PPBasketCombine & rBasket, int action);

class PPObjGoodsBasket : public PPObjReference {
public:
	enum {
		ordByDefault = 0,
		ordByGoods,
		ordByGroup
	};
	static int   IsLocked(PPID);
	static int   ForceUnlock(PPID);
	static int   IsPrivate(PPID id);

	class Locking {
	public:
		explicit Locking(PPID id = 0);
		~Locking();
		int    Lock(PPID);
		int    Unlock();
	private:
		PPID   ID;
		int    L;
	};
	struct SelFilt { // @flat
		SelFilt();
		//
		// Descr: Реализует обычную семантику методов Z().
		// Note: Важно! Метод включен в класс для использования в качестве упреждающего конструктора
		//   для применения в PPObjGoodsBasket::CreateObjListWin() поскольку базовый класс объекта отображения //
		//   формируется при инициализации ранее, чем вызывается конструктор SelFilt.
		//   До тех пор, пока этот класс плоский (@flat) все будет хорошо, но если здесь появятся члены,
		//   требующие сложной инициализации, то описанное использование метода Z() приведет к тяжелым проблемам.
		//
		SelFilt & Z();

		enum {
			fOwnOnly = 0x0001, // Показывать только те, корзины, которые ассоциированы с текущим пользователем
		};
		long   Flags;
		uint8  Reserved[64];
	};
	explicit PPObjGoodsBasket(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr /*goodsID*/);
	virtual int  Browse(void * extraPtr);
	int    Select(PPID * pID, const char * pMsg);
	//
	// Descr: Опции функции PPObjGoodsBasket::GetPacket
	//
	enum {
		gpoProcessPrivate = 0x0001 // Если корзина приватная, то извлекать ее из буфера, а не из БД
	};

	int    GetPacket(PPID id, PPBasketPacket * pData, long options = 0);
	int    PutPacket(PPID * pID, PPBasketPacket * pData, int use_ta);
	int    SerializePacket(int dir, PPBasketPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    Print(PPBasketPacket *);
	int    ClearDefForBaskets(int use_ta);
	int    SearchDefaultBasket(PPID * pID, PPGoodsBasket * pRec);
	int    SearchByName(PPID *, const char * pName, PPBasketPacket * = 0);
	int    GetPreferredBasket(PPBasketCombine & rC);
	int    SelectBasket(PPBasketCombine & rBasket);
	int    Transfer(PPID);
private:
	static  void SetAddLockErrInfo(PPID mutexID);
	static  ILTI & ObjAssocRecToBasketEntry(const ObjAssocTbl::Rec & rSrcRec, ILTI & rDest);
	static  void BasketEntryToObjAssocRec(const ILTI & rSrc, long internalNum, bool dontResetDestRecBefore, ObjAssocTbl::Rec & rDestRec);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr); // @v11.4.1
	virtual void FASTCALL Destroy(PPObjPack * pPack);
	virtual int HandleMsg(int, PPID, PPID, void * extraPtr); // @v11.4.0
	virtual int Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void * CreateObjListWin(uint flags, void * extraPtr);
	virtual int ProcessReservedItem(TVRez &);
};

class PPBasketCombine {
public:
	PPBasketCombine();
	PPID   BasketID;
	PPBasketPacket Pack;
	PPObjGoodsBasket::Locking Lck;
};

class PPViewGoodsBasket {
public:
	enum {
		fHideCost = 0x0001
	};
	explicit PPViewGoodsBasket(PPBasketPacket * pPacket);
	~PPViewGoodsBasket();
	int    Init(int ord);
	int    InitIteration();
	int    FASTCALL NextIteration(ILTI *);
	const  IterCounter & GetIterCounter() const;
	int    Print();
	const  PPBasketPacket * GetPacket() const;
private:
	int    CreateOrderTable();
	int    Sort();
	IterCounter Counter;
	TempOrderTbl * P_OrdTbl;
	BExtQuery * P_IterQuery;
	PPBasketPacket * P_GBPacket;
	long   IterCount;
	long   NumIters;
	int    Order;
	long   Flags; // PPViewGoodsBasket::fXXX
};
//
// @ModuleDecl(PPViewGoodsTrnovr)
//
typedef GCTFilt GoodsTrnovrFilt;

struct GoodsTrnovrViewItem { // @flat
	union {
		LDATE  Dt;
		char   Title[12];
	};
	double RcptSuppl;
	double RcptIntr;
	double RetRetail;
	double RetClient;
	double RetSuppl;
	double XpndRetail;
	double XpndClient;
	double XpndIntr;
	double PayClient;
	double Income;
};

class PPViewGoodsTrnovr {
public:
	PPViewGoodsTrnovr();
	~PPViewGoodsTrnovr();
	const  GoodsTrnovrFilt * GetFilt() const;
	int    EditFilt(GoodsTrnovrFilt *);
	int    Init(const GoodsTrnovrFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(GoodsTrnovrViewItem *);
	int    GetIterationCount(long *, long *);
	int    ViewGrouping(LDATE);
	int    Browse(int);
	int    Print();
private:
	SArray * CreateBrowserQuery();

	SArray * P_Items;
	GoodsTrnovrFilt Filt;
	IterCounter Cntr;
};
//
// Descr: План платежей
//   Отчет, рассчитывающий планируемые к оплате суммы, исходя из сроков
//   платежей по документам.
//
struct PaymPlanFilt : public PPBaseFilt {
	PaymPlanFilt();

	enum {
		fLabelOnly   = 0x0001,
		fCurrentDebt = 0x0002, // Долг контрагента по попадающим в интервал
		// документам ограничивать текущим долгом.
		// В противном случае долг рассчитывается на начало цикла.
		fDetail  = 0x0004,
		fCrosstab        = 0x0008,
		fDetailByBill    = 0x0010 // Детализация по документам (для каждого документа отдельная запись при вызове NextIteration)
	};
	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPCycleFilt Cycl;
	PPID   AccSheetID; // Таблица статей, к которой относятся долговые документы if AccSheetID == 0 then AccSheetID = GetSellAccSheet()
	PPID   ObjectID;
	SubstGrpPerson Sgp;      // Подстановка персоналии
	long   Flags;            // PaymPlanFilt::fXXX
	PPID   AgentID;          // Агент по документу
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;   //
};

struct PaymPlanTotal {
	long   Count;
	double Amount;
	double Paym;
	double Debt;
};

struct PaymPlanViewItem {
	LDATE  Dt;         // Дата принадлежности к циклу
	LDATE  PayPlanDt;  // Дата предполагаемого платежа
	PPID   BillID;
	PPID   ObjID;
	char   Name[128];  //
	double Amount;
	double Paym;
	double Debt;
};

class PPViewPaymPlan : public PPView {
public:
	friend int IterProc_PPViewPaymPlan_ProcessPeriod(PayPlanTbl::Rec * pRec, void * extraPtr);

	struct BrwHdr {
		PPID   BillID;
		PPID   ObjID;
		LDATE  Dt;
	};
	PPViewPaymPlan();
	~PPViewPaymPlan();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PaymPlanViewItem *);
	void   FormatCycle(LDATE, char * pBuf, size_t bufLen);
	void   GetTabTitle(long tabID, SString & rBuf) const;
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Print(const void *);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	void   NextInnerIteration(PaymPlanViewItem * pItem);
	int    GetBillList(PPID objID, LDATE dt, ObjIdListFilt * pBillList, RPairArray * pPaymList, int allowZeroPeriod);
	void   GetEditIds(const void * pRow, LDATE * pDt, PPID * pObjID, long col);
	int    ViewArticleInfo(const BrwHdr * pHdr, int what);

	IterCounter InnerCounter;
	PPIDArray   BillList;
	RPairArray  PaymList;
	PPObjBill * P_BObj;
	PPObjArticle ArObj;
	PPObjPerson  PsnObj;
	PPObjPerson::SubstParam Psp;
	PaymPlanFilt  Filt;
	PPCycleArray  CycleList;
	PaymPlanTotal Total;
	TempPaymPlanTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewSStat)
//   Статистика по продажам товаров
//
class SStatFilt : public PPBaseFilt {
public:
	SStatFilt();
	SStatFilt & FASTCALL operator = (const SStatFilt & s);
	int    IsEqualExceptOrder(const SStatFilt *) const;
	void   SetupCfgOptions(const PPPredictConfig & rCfg);
	int    GetPckgUse() const;
	int    GetPckgRounding() const;
	void   SetPckgUse(int t);
	void   SetPckgRounding(int t);

	enum {
		fSkipZeroNhCount   = 0x0001,
		fSupplOrderForm    = 0x0002,  // Отчет выводить в виде формы заказа поставщику
		fRoundOrderToPack  = 0x0004,  // Расчетный заказ округлять до емкости упаковки вверх
		fUseInsurStock     = 0x0008,  // При расчете заказа учитывать страховочный запас
		fExtByArCode       = 0x0010,  // Выборка товаров, по которым строится отчет ДОПОЛНЯЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
		fRestrictByArCode  = 0x0020,  // Выборка товаров, по которым строится отчет ОГРАНИЧИВАЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
			// Если SupplID == 0, то перебираются только те товары, которые имеют собственные коды.
		// @#{fExtByArCode^fRestrictByArCode}
		fOverrideCfgParams = 0x0040   // Поля _XXX переопределяют соответствующие
			// параметры конфигурации. Если флаг не установлен, то метод PPViewSStat::Init_
			// присваивает этим полям значения из конфигурации.
	};

	uint8  ReserveStart[16]; // @anchor
	//
	// Следующие 4 поля могут переопределять соответствующие параметры конфигурации PPPredictConfig
	//
	long   _CFlags;          // PPPredictConfig::fXXX
	int16  _Method;          // PredictionMethod (PRMTHD_XXX)
	int16  _P;               // Количество последних точек, по которым строится прогноз
	int16  _TrustCriterion;  // Критерий надежности прогноза
	int16  _MinP;            // Минимальное количество точек, при которых прогноз еще считается надежным
	//
	int16  DefInsurStock;    // Минимальный запас по умолчанию (в днях)
	int16  UpRestriction;    // Если !0, то заказ рассчитывается только для тех позиций,
		// которые закончатся в течении заданного этим полем количества дней.
	DateRange Period;        //
	PPID   GoodsGrpID;       //
	PPID   SupplID;          // Поставщик
	SubstGrpGoods Sgg;       //
	LDATE  RestDate;         // Дата расчета остатков
	PPCycleFilt Cycl;        // Группирующие циклы
	int16  OrdTerm;          // Период заказа товара
	int16  DlvrTerm;         // Период доставки заказа от поставщика
	long   Order;            // PPViewSStat::IterOrder
	long   Flags;            //
	RealRange CountRange;    // Количество точек
	RealRange QttyAvgRange;  // Средние продажи в кол-ом выражении
	RealRange AmtAvgRange;   // Средние продажи в суммовом выражении
	RealRange QttyVarRange;  // Коэффициент вариации
	ObjIdListFilt LocList;   // @anchor
};

struct SStatViewItem {
	PPID   GoodsID;
	char   GoodsName[128]; //
	LDATE  Dt;             // Если фильтр определяет группировку по циклам, то дата начала цикла, иначе - 0
	long   Count;
	double QttySum;
	double QttyAvg;
	double QttySigma;
	double QttyVar;
	double QttyTrnovr;
	double AmtSum;
	double AmtAvg;
	double AmtSigma;
	double AmtVar;
	double AmtTrnovr;
	LDATE  LastCalcDate;
	double Rest;           // Остаток товара (только если Filt.Flags & fSupplOrderForm)
	double Predict;        // Прогноз продаж (только если Filt.Flags & fSupplOrderForm)
	double SupplOrder;     // Расчетный заказ (только если Filt.Flags & fSupplOrderForm)
	double MinStock;       // Минимальный запас (только если Filt.Flags & SStatFilt::fUseInsurStock)
	double PriceAvg;       // Средняя цена
	double CostAvg;        // Средняя цена поступления позиции
	int16  IsPredictTrust; // Признак надежности прогноза (только для формы заказа поставщику)
	int16  Reserve;        // @alignment
};

struct SStatTotal {
	long   LinesCount;     // Количество строк в выборке
	long   Count;          // Общее количество элементов продаж по всей выборке
	double Qtty;           // Общее количество проданных торговых единиц
	double Amount;         // Общая сумма продаж
	long   OrderCount;     // Суммарное количество строк, предлагаемых к заказу
	double OrderQtty;      // Суммарное количество торговых единиц, предлагаемых к заказу
	double OrderAmount;    // Ценовая сумма товаров, предлагаемых к заказу
	double OrderCost;      // Сумма товаров, предлагаемых к заказу с ценах поступления //
	long   UncertCount;    // Количество недостоверных элементов
};

class PPViewSStat : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByCount,
		OrdByQttyAvg,
		OrdByQttyVar,
		OrdByAmtAvg,
		OrdByAmtVar,
		OrdByPriceAvg,
		OrdByQttyAvgCount
	};
	//static int CreateDraftBySupplOrders(const SStatFilt * pFilt);
	PPViewSStat();
	~PPViewSStat();
	//
	// Descr: Создает новый экземпляр фильтра.
	//   Инициализируется следующее:
	//     1. в список складов устанавливается текущий склад (если не ноль)
	//     2. устанавливается флаг SStatFilt::fSkipZeroNhCount
	//     3. если extraParam & 0x0001 (форма расчета заказа поставщику), то устанавливаются флаги
	//        (SStatFilt::fSupplOrderForm | SStatFilt::fRoundOrderToPack)
	//
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(SStatViewItem *);
	int    GetItem(PPID goodsID, SStatViewItem * pItem);
	int    GetRestItem(PPID goodsID, const ObjIdListFilt * pLocList, GoodsRestViewItem *);
	int    ConvertLinesToBasket();
	int    CreatePurchaseBill(LDATE docDt, int autoOrder, PPBillPacket * pPack, int useTa);
	int    EditOrder(PPID ctID, PPID goodsID);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	virtual int  Print(const void *);
	virtual void ViewTotal();
	int    CalcTotal(SStatTotal * pTotal);
	void   RecToViewItem(const TempGoodsStatTbl::Rec * pRec, SStatViewItem * pItem);
	int    EditDlvrOrderFilt(SStatFilt *);
	int    CreateTempTable(int use_ta);
	int    CreateOrderTable(long ord, TempOrderTbl ** ppTbl, int use_ta);
	int    AddStat(PPID goodsID, LDATE, int setTotal, const PredictSalesStat *, BExtInsert *);
	int    AddStatByCycles(PPID goodsID, const PPIDArray * pIdList, int setTotal, BExtInsert *, PredictSalesStat *);
	int    CalcOrder(double prediction, double minStock, const GoodsRestViewItem * pItem, double * pOrder);
	int    AddPurchaseBill();
	int    ViewCreatedBills();
	double PreprocessOrderQuantity(double order, PPID goodsID, double unitPerPack/*const GoodsRestViewItem & rItem*/);

	SStatFilt Filt;
	TempGoodsStatTbl * P_TempTbl;
	TempOrderTbl * P_TempOrd;
	PPViewGoodsRest * P_VGr;
	PredictSalesCore PsT;
	PPObjGoods GObj;
	GoodsSubstList Gsl;
	PPCycleArray CycleList;
	PPPredictConfig PrCfg;
	PPIDArray CreatedBillList; // Список документов, созданных из отчета для просмотра и экспорта
};
//
//
//
#define PPINETCONN_DIRECT    0
#define PPINETCONN_PRECONFIG 1
#define PPINETCONN_PROXY     2

struct PPInetConnConfig {  // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_INETCONNCFG
	char   Agent[48];
	char   ProxyHost[48];
	char   ProxyPort[10];
	long   MaxTries;
	long   AccessType;
	long   Flags;
	char   Reserve[126];
	char   URLDir[64];
};
//
// @ModuleDecl(PPViewOprKind)
//
struct OprKindFilt : public PPBaseFilt {
	OprKindFilt();

	enum {
		sortByName     = 1,
		sortByTypeName = 2
	};
	enum {
		fOnlyPassive     = 0x0001, // Показывать только операции с флагом OPKF_PASSIVE
		fOnlyProfitable  = 0x0002, // Показывать только операции с флагом OPKF_PROFITABLE
		fOnlyNeedPayment = 0x0004, // Показывать только операции с флагом OPKF_NEEDPAYMENT
		fOnlyReckon      = 0x0008, // Показывать только операции с флагом OPKF_RECKON
		fUseRank         = 0x1000  // При сортировке ранг операции является приоритетным критерием.
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   OpTypeID;
	PPID   LinkOpID;
	PPID   AccSheetID;
	long   Flags;            // OPKF_XXX Флаги видов операций для фильтрации (@todo надо пересматривать этот подход)
	long   SortOrd;
	long   Reserve;          // @anchor
};

struct OprKindBrwItem {
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	char   AccSheet[48];
	char   OpType[48];
	char   FlagsMnems[32];
	int16  Rank;
	int16  Reserve;        // @alignment
};

struct OprKindViewItem : public OprKindBrwItem {
	char   Template[84];
};

class PPViewOprKind : public PPView {
public:
	PPViewOprKind();
	~PPViewOprKind();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(OprKindViewItem *);
	int    CreateFlagsMnemonics(const PPOprKind * pOdData, char * pBuf, size_t bufSize);
	int    AddBySample(PPID sampleID);
	int    ViewLinkOps(PPID opID);
	int    ViewBills(PPID opID);
	int    Transmit(PPID id);
	int    CmpSortIndexItems(PPViewBrowser * pBrw, const OprKindBrwItem * pItem1, const OprKindBrwItem * pItem2);
private:
	int    InnerIteration(OprKindViewItem * pItem);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * GetEditExtraParam();
	int    MakeEntry(const PPOprKind & rOpRec, OprKindBrwItem & rEntry);
	int    MakeList(PPViewBrowser * pBrw);

	SArray * P_DsList;
	uint   OpListIdx;
	uint   TmplsIdx;
	PPAccTurnTemplArray ATTmpls;
	OprKindFilt  Filt;
	PPObjOprKind OpObj;
	PPObjAccSheet AcsObj;
};
//
// @ModuleDecl(PPObjMrpTab)
//
// Специальные значения поля SrcID таблицы MrpLine
//
#define MRPSRCV_TOTAL  0 // Полное итоговое требование на DestReqQtty единиц товара DestID
#define MRPSRCV_DEP   -1 // Итоговое зависимое требование на DestReqQtty единиц товара DestID
#define MRPSRCV_INDEP -2 // Итоговое независимое требование на DestReqQtty единиц товара DestID
//
// Флаги записей MrpTabTbl::Rec
//
#define MRPTF_SUBST         0x0001L // Таблица замещения одного товара другим
	// Таблица замещения обязательно имеет ссылку (ParentID) на ту таблицу, в
	// которой осуществляет замещение. Если основная таблица имеет потомков, то
	// замещающая таблица - одна для всего дерева и крепится к корневой таблице.
	// Все строки замещающей таблицы имеют признак MRPLF_SUBST
//
// Флаги записей MrpLineTbl::Rec
//
#define MRPLF_TERMINAL      0x0001L // Терминальная строки (товар DestID не может быть скомплектован)
#define MRPLF_REST          0x0002L // Остаток по строке рассчитан
#define MRPLF_SUBST         0x0004L // Замещающий элемент таблицы
#define MRPLF_REPLACED      0x0008L // К элементу таблицы применена операция замещения //
#define MRPLF_UNLIM         0x0010L // Товар, с которым связана строка, является нелимитируемым
#define MRPLF_IGNOREREST    0x0020L // По строке не следует учитывать доступный остаток (строка комплектуется независимо от остатка)

struct MrpReqItem { // @flat
	MrpReqItem(PPID goodsID, long flags, double req, double price);
	PPID   GoodsID;
	long   Flags;   // MRPLF_XXX
	double Req;
	double Price;
};

class MrpReqArray : public TSVector <MrpReqItem> {
public:
	MrpReqArray();
	int    Add(PPID goodsID, long flags, double req, double price);
};

class MrpTabCore : public MrpTabTbl {
public:
	MrpTabCore();
	int    Search(PPID, MrpTabTbl::Rec * = 0);
	int    SearchByLink(PPID objType, PPID objID, PPID locID, LDATE dt, MrpTabTbl::Rec * pRec);
	int    SearchLine(PPID tabID, PPID destID, PPID srcID, MrpLineTbl::Rec * pRec);
	int    SearchLineByID(PPID lineID, MrpLineTbl::Rec * pRec);
	int    GetTotalLine(PPID tabID, PPID goodsID, MrpLineTbl::Rec *);
	int    GetSubList(PPID tabID, PPIDArray *);
	int    GetParentID(PPID tabID, PPID * pParentID);
	int    EnumLinesByDest(PPID id, PPID destID, PPID * pSrcID, MrpLineTbl::Rec *);
	int    EnumLinesBySrc(PPID id, PPID srcID, PPID * pDestID, MrpLineTbl::Rec *);
	int    GetSrcList(PPID tabID, PPID destID, RAssocArray *);
	int    GetDestList(PPID tabID, PPID srcID, int minusSrcReq, MrpReqArray * pList);
	int    IsTerminalGoods(PPID tabID, PPID goodsID); // @>>MrpTabCore::IsGoodsFlagged
	int    IsReplacedGoods(PPID tabID, PPID goodsID); // @>>MrpTabCore::IsGoodsFlagged
	//
	// Descr: Извлекает из таблицы tabID список дефицитных позиций
	// ARG(tabID    IN): ИД таблицы, по которое необходимо получить список дефицитных позиций
	// ARG(terminal IN): Фильтрующий параметр, допускающий следующие значения:
	//   -1 - извлекать дефицит только по НЕТЕРМИНАЛЬНЫМ (non-terminal) позициям
	//    0 - не обращать внимание на признак терминальности
	//   +1 - извлекать дефицит только по ТЕРМИНАЛЬНЫМ (terminal) позициям
	// ARG(replacePassiveGoods IN): Если !0, то дефицитная позиция, если она является обобщенным
	//   или пассивным товаром, по возможности замещается первым встретившемся для подстановки
	//   компонентом (который также не является пассивным или обобщенным). Компоненты для подстановки
	//   определяются функцией PPObjGoods::GetSubstList().
	// ARG(pList   OUT): Массив, в который добавляются позиции по таблице tabID
	//   Функция не очищает содержимое этого массива, по-этому, полседовательный вызов
	//   функции позволяет получить итоговый дефицит по списку таблиц
	// Returns:
	//   >0 - в список была занесена информация по крайней мере по одной дефицитной позиции
	//   <0 - список pList остался неизменным - по затребованным условиям таблица
	//        дефицита не содержит
	//   0  - ошибка
	//
	int    GetDeficitList_(PPID tabID, PPID srcID, int terminal, int replacePassiveGoods, PUGL * pList);
	int    GetSubst(PPID tabID, GoodsReplacementArray * pGra);
	int    GetDependencyList(PPID tabID, PPID destGoodsID, PUGL * pList);
	int    Create(PPID * pID, const MrpTabTbl::Rec * pRec, int use_ta);
	int    Update(PPID id, const MrpTabTbl::Rec * pRec, int use_ta);
	int    AddLine(PPID id, PPID destID, PPID srcID, double destReqQtty, double srcReqQtty, double price, long flags, int use_ta);
	int    AddCTab(const CMrpTab *, int use_ta);
	//
	// Descr: Устанавливает значения остатка и дефицита для товара destID
	//   в таблице tabID в соответствии с параметром pVal.
	//   Если указатель pVal == 0, то считает что товар destID является нелимитируемым ресурсом,
	//   соответственно, дефицит отсутствует.
	//
	int    SetRest(PPID id, PPID destID, const GoodsRestVal * pVal, double * pDeficit, int use_ta);
		// @<<PPObjMrpTab::SetupRest
	int    SetSubstRest(PPID id, PPID destID, PPID srcID,
		const GoodsRestVal * pVal, double ratio, double * pDeficit, int use_ta);
	int    RemoveSubst(PPID tabID, PPID destID, PPID srcID, int use_ta);
	int    RemoveLines(PPID, int use_ta);
	int    Remove(PPID, int use_ta);
	int    Aggregate(PPID destTabID, PPID srcTabID, int use_ta);
		// @<<MrpTabPacket::Aggregate

	MrpLineTbl Lines;
private:
	int    Helper_GetDeficit(const MrpLineTbl::Rec & rRec, int terminal, int replacePassiveGoods, PUGL * pList);
	int    SetFlag(PPID tabID, PPID destID, PPID srcID, long flag, int set, int use_ta);
	int    IsGoodsFlagged(PPID tabID, PPID goodsID, long flag);
};
//
// Descr: Массив, кэширующий MRP-таблицу на этапе формирования требований
//   по товарам и расчета зависимых требований.
//
class CMrpTab : public SArray {
public:
	struct Row { // Size=40
		PPID   TabID;
		PPID   DestID;
		PPID   SrcID;
		double DestReq;
		double SrcReq;   // Если SrdID == 0, то здесь хранится доступный остаток товара DestID
			// При развертывании структур используется требуемое количество (DestReq-SrcReq)
		int16  Flags;    // MRPLF_XXX
		int16  Pad;      // @alignment
		double Price;
	};
	CMrpTab();
	Row  & FASTCALL at(uint i) const;
	void   Sort();
	int    Search(PPID tabID, PPID destID, PPID srcID, uint * pPos, CMrpTab::Row * pRow) const;
	int    Add__(PPID tabID, PPID destID, PPID srcID, double destReqQtty, double srcReqQtty, double price, /*int term*/long flags);
	int    SetRest(PPID tabID, PPID destID, double rest);
	int    Aggregate(PPID destTabID); // @<<MrpTabPacket::Aggregate
	int    SetFlag(PPID tabID, PPID destID, PPID srcID, long flag, int set);
};

struct MrpTabLeaf { // @flat
	MrpTabLeaf(PPID tabID, PPID locID, LDATE dt);
	PPID   TabID;
	PPID   LocID;
	LDATE  Dt;
};

class MrpTabPacket : public TSVector <MrpTabLeaf> {
public:
	MrpTabPacket();
	MrpTabPacket & FASTCALL operator = (const MrpTabPacket &);
	void   Init(PPID objType, PPID objID, const char * pName);
	void   Destroy();
	bool   IsTree() const;
	const  char * GetName() const;
	PPID   GetBaseID() const;
	void   FASTCALL SetBaseID(PPID);
	int    GetTabID(PPID locID, LDATE dt, PPID * pTabID) const;
	int    FASTCALL AddLeaf(const MrpTabTbl::Rec *);
	void   CreateLeafRec(PPID locID, LDATE dt, MrpTabTbl::Rec & rRec) const;
	int    GetLeaf(PPID tabID, MrpTabLeaf *) const;
	int    GetList(PPIDArray *) const;
	//
	// Descr: Сортирует листья пакета в следующем порядке: {TabID, Dt, LocID}
	//
	void   Sort(); // @>>SArray::sort
	//
	// Descr: Для внутреннего использования. Сортирует элементы Cache для ускорения поиска.
	//
	void   SortCache();
	//
	// Descr: Определяет общие характеристики дерева таблиц:
	//   список складов, начальную и конечную даты.
	//   Предварительно очищает список pLocList и присваивает периоду pPeriod
	//   значения pPeriod->low = MAXDATE, pPeriod->upp = ZERODATE
	//
	void   GetCommonParam(PPIDArray * pLocList, DateRange * pPeriod) const; // @<<PPObjMrpTab::FinishPacket
	int    AddLine__(PPID tabID, PPID destID, PPID srcID, double destReq, double srcReq, double price, long flags/*int term*/);
	int    SetTerminal(PPID tabID, PPID destID, int terminal);
	int    IsTerminal(PPID tabID, PPID destID) const;
	int    GetDestList(PPID tabID, PPID srcID, int minusSrcReq, MrpReqArray *) const;
	int    ProcessReq(const MrpTabLeaf * pLeaf, const MrpReqItem & rReq, double * pExtReq, int dep, long cflags /* PPObjMrpTab::cfXXX */);
	int    Aggregate();
	int    Flash(MrpTabCore *, int use_ta);
	int    GetAvailGoodsRest(PPID goodsID, const MrpTabLeaf * pLeaf, double * pRest) const;
	//
	// Descr: Извлекает список терминальных позиций из кэша по идентификаторму tabID
	//
	int    GetCTerminalList(PPID tabID, CMrpTab & rList) const;
private:
	CMrpTab Cache;
	PPID   ObjType;
	PPID   ObjID;
	PPID   BaseID;
	char   Name[48];
};

struct PPMrpTabConfig {    // @persistent @store(PropertyTbl)
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_MRPTABCFG
	long   Counter;
	long   Flags;
	char   Reserve[64];
};

class PPObjMrpTab : public PPObject {
public:
	//
	// Descr: Флаги формирования таблиц
	//
	enum {
		cfIgnoreRest = 0x0001 // Не рассчитывать остатки (считать, что доступный остаток нулевой)
	};

	static int  FASTCALL ReadConfig(PPMrpTabConfig *);
	static int  GetCounter(long * pCounter, int use_ta);
	static void GenerateName(PPID linkObjType, PPID linkObjID, SString *, int use_ta);
	static int  GetAvailGoodsRest(PPID goodsID, const MrpTabLeaf * pLeaf, LDATE afterDate, double * pRest);

	PPObjMrpTab(void * extraPtr = 0);
	~PPObjMrpTab();
	virtual int  Search(PPID, void * = 0);
	virtual int  Browse(void * extraPtr);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  DeleteObj(PPID id);
	//
	// Descr: Проверяет запись pRec на соответствие фильтру pFilt. Если pRec == 0,
	//   то запись извлекается по идентификатору id из базы данных (функцией PPObjMrpTab::Search).
	//   Если запись по этому идентификатору не найдена, то возвращается 0.
	// Returns:
	//   >0 - запись pRec (или та, что соответствует идентификатору id) удовлетворяет фильтру pFilt.
	//        Если pFilt == 0, то всегда возвращается (>0), то есть, отсутвтующему фильтру удовлетворяет
	//        любая запись.
	//   0 - запись не удовлетворяет фильтру pFilt. Если pRec == 0 и запись по идентификатору id не
	//       нейдена, также возвращается 0 (несуществующая запись не удовлетворяет ни каким условиям).
	//
	int    CheckForFilt(const MrpTabFilt * pFilt, PPID id, MrpTabTbl::Rec * pRec);
	int    EditDialog(MrpTabTbl::Rec *);
	int    CreateByGoods(PPID * pID, const char * pName, PPID goodsID, PPID locID, LDATE, int use_ta);
	int    CreateByBill(PPID * pID, const char * pName, PPID billID, int use_ta);
	int    CreateByDraftWrOff(PPID * pID, const char * pName, PPID dwoID, PPID locID, LDATE, int use_ta);
	int    LoadPacket(PPID tabID, MrpTabPacket *);
	int    DestroyPacket(MrpTabPacket *, int use_ta);
	int    GetTabID(MrpTabPacket *, PPID locID, LDATE dt, PPID * pTabID, int use_ta);
	int    AddIndep(MrpTabPacket *, PPID tabID, PPID goodsID, double req, double price, int ignoreRest);
	int    FinishPacket(MrpTabPacket * pPack, long cflags /* PPObjMrpTab::cfXXX */, int use_ta);
	int    GetDeficitList(const MrpTabPacket * pPack, PPID srcID, int terminal, int replacePassiveGoods, PUGL * pList);
		// @>>MrpTabCore::GetDeficitList
	//
	// Descr: инициализирует комбо-бокс ctlID в диалоге dlg списком типов связанных
	//   объектов. В списке перечисляются только те объекты, с которыми может быть связана
	//   запись в таблице MrpTab
	//
	static int SetupLinkObjTypeCombo(TDialog * dlg, uint ctlID, PPID initObjType);
		// @>>SetupObjListCombo
	int    CreateModif(const MrpTabLeaf * pMrpLeaf, PPID mrpSrcID, PPID opID, const PUGL::SetLotManufTimeParam *, PPIDArray * pBillList, PPLogger *, int use_ta);
	int    DoMaintain(LDATE toDt);
		// @>>DoDBMaintain
private:
	virtual const char * GetNamePtr();
	int    CreateTreeLeaf(MrpTabPacket * pTree, PPID locID, LDATE dt, PPID * pTabID);
	int    Helper_ExpandReq(MrpTabPacket *, const MrpTabLeaf *, const MrpReqItem & rReq, int dep, long cflags, PPIDArray * pRecurTrace);
	int    ExpandReq(MrpTabPacket * pPack, const MrpTabLeaf * pLeaf, long cflags);
	int    SetupRest(const MrpTabPacket * pPack, const MrpTabLeaf * pLeaf, long cflags, int use_ta); // @>>MrpTabCore::SetRest
	int    ArrangePugl(PPID tabID, PUGL * pSrc, uint pos, PUGL * pDest);
		// @recursion, @<<PPObjMrpTab::CreateModif
public:
	TLP_MEMB(MrpTabCore, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewMrpTab)
//
struct MrpTabFilt : public PPBaseFilt {
	enum {
		fSkipChilds = 0x0001 // Исключаются таблицы, имеющие ненулевого родителя.
			// Этот флаг игнорируется если MrpTabFilt::ParentID != 0
	};
	MrpTabFilt();

	uint8  ReserveStart[32]; // @anchor
	PPID   ParentID;
	PPID   LinkObjType;
	PPID   LinkObjID;
	PPID   LocID;
	DateRange Period;
	long   Flags;
	PPID   SingleID;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef MrpTabTbl::Rec MrpTabViewItem;

class PPViewMrpTab : public PPView {
public:
	PPViewMrpTab();
	~PPViewMrpTab();
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(MrpTabViewItem *);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	//int    ChangeFilt(int refreshOnly, BrowserWindow *);
	int    UpdateTempTable(PPID);

	MrpTabFilt Filt;
	PPObjMrpTab MrpObj;
	TempOrderTbl * P_TempOrd;
};
//
// @ModuleDecl(PPViewMrpLine)
//
struct MrpLineFilt : public PPBaseFilt {
	MrpLineFilt();
	enum {
		fShowTotalReq     = 0x0001, // Показывать только итоговые потребности (MrpLine.SrcGoodsID == MRPSRCV_TOTAL)
		fShowDeficitOnly  = 0x0002, // Показывать только дефицитные позиции
		fShowTerminalOnly_Obsolete1156 = 0x0004, // Показывать только терминальные строки
		fShowSubst        = 0x0008  // @v4.8.6 Показывать замещения по товару DestGoodsID
	};
	uint8  ReserveStart[30]; // @anchor
	int16  Ft_Terminal;      // @v11.5.6 (0 - ignored, <0 - только нетерминальные, >0 - только терминальные)
	PPID   TabID;            // ->MrpTab.ID
	PPID   DestGoodsID;      // ->Goods2.ID
	PPID   SrcGoodsID;       // ->Goods2.ID || MRPSRCV_XXX
	long   Flags;
	//
	// Если DestGoodsID != 0, то показывается выборка
	// (TabID == Filt.TabID && DestID == Filt.DestGoodID && SrcID == Filt.SrcGoodsID),
	// Иначе (TabID == Filt.TabID && SrcID == Filt.SrcGoodsID)
	//
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef MrpLineTbl::Rec MrpLineViewItem;

struct MrpLineTotal {
	long   Count;       // Общее количество позиций
	long   TermCount;   // Количество терминальных позиций
	long   DfctCount;   // Количество дефицитных позиций
	double ReqQtty;     // Требуемое количество
	double Deficit;     // Дефицит
	double Cost;        // Сумма в ценах поступления //
	double Price;       // Сумма в ценах реализации  //
};

class PPViewMrpLine : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByReq,
		OrdByDeficit
	};
	PPViewMrpLine();
	~PPViewMrpLine();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(MrpLineViewItem *);
	int    CalcTotal(MrpLineTotal *);
	int    GetItem(PPID lineID, MrpLineViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    ChangeFilt(int refreshOnly, BrowserWindow *);

	MrpLineFilt Filt;
	PPObjMrpTab MrpObj;
	TempOrderTbl * P_TempOrd;
};
//
// @ModuleDef(PPObjDraftCreateRule)
// AHTOXA {
//
#define PPDFCRRULE_ONLYGROUPS -1L // показывать только группы, передается как extra для selector'а
#define PPDFCRRULE_ONLYRULES  -2L // показывать только правила, передается как extra для selector'а

struct PPDraftCreateRule2 {  // @persistent @store(Reference2Tbl+)
	PPDraftCreateRule2();
	enum PriceAlgoritm {  // агоритм образования цены реализации
		pByLastLot   = 1, // из последнего лота
		pByAvgSum    = 2, // среднее по выборке чеков
		pByAvgSumDis = 3, // среднее по выборке чеков минус скидка
		pByQuot        = 4, // по котировке
		pByCostPctVal  = 5 // из цены поступления плюс некоторый процент
	};
    enum CostAlgoritm {      // алгоритм образования цены поступлени
		cByLastLot      = 1, // из последнего лота
		cByPricePctVal  = 2, // из цены реализации минус некоторый процент
		cByQuot = 3  // по котировке
	};
	enum {
		fExclGoodsGrp     = 0x0001,
		fIsRulesGroup     = 0x0002,
		fWoSCard  = 0x0004,
		fOnlyBanking      = 0x0008,
		fOnlyNotBanking   = 0x0010,
		fExcludeSCardSer  = 0x0020,
		fUseGoodsLocAssoc = 0x0040,
		// @v10.3.5 @#{fRetOnly^fSalesOnly} (fRetOnly && fSalesOnly) трактуется как отсутствие обоих флагов (и продажи и возвраты)
		fRetOnly  = 0x0080, // @v10.3.5 Только чеки возвратов
		fSalesOnly        = 0x0100  // @v10.3.5 Только чеки продаж (без возвратов).
	};
	PPID   Tag;            // Const=PPOBJ_DFCREATERULE
	PPID   ID;             // @id
	char   Name[48];       // @offse(28) @name @!refname
	char   Symb[20];       //
	char   Reserve[12];    // @reserve
	PPID   OpID;           // ->Ref(PPOBJ_OPRKIND)
	PPID   ArID;           // ->Article.ID
	PPID   AgentID;        // ->Article.ID
	PPID   GoodsGrpID;     // ->Goods2.ID
	PPID   CQuot;          // ->Ref(PPOBJ_QUOTKIND)
	PPID   PQuot;          // ->Ref(PPOBJ_QUOTKIND)
	int16  CostAlg;        //
	int16  PriceAlg;       //
	float  CPctVal;        //
	float  PPctVal;        //
	double MaxSum;         //
	long   MaxPos;         //
	long   Flags;          //
	PPID   ParentID;       //
	PPID   SCardSerID;     //
};

class PPDfCreateRulePacket {
public:
	PPDfCreateRulePacket();
	PPDfCreateRulePacket & Z();
	void   GetCashNN(SString * pBuf, int delim = ',') const;
	void   GetCashNN(PPIDArray * pAry) const;
	int    SetCashNN(const char * pBuf, int delim = ',');
	void   SetCashNN(const PPIDArray * pAry);
	int    CheckCash(PPID cash) const;

	PPDraftCreateRule Rec;
private:
	PPIDArray CashNN;
};

class PPObjDraftCreateRule : public PPObjReference {
public:
	explicit PPObjDraftCreateRule(void * extraPtr = 0);
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	int    AddBySample(PPID * pID, PPID sampleID);
	int    GetPacket(PPID, PPDfCreateRulePacket *);
	int    PutPacket(PPID *, PPDfCreateRulePacket *, int use_ta);
	void   GetRules(PPID ruleGrpID, PPIDArray * pRules);
};
// } AHTOXA
//
// @ModuleDecl(PrcssrWrOffDraft)
//
class PrcssrWrOffDraftFilt : public PPBaseFilt {
public:
	PrcssrWrOffDraftFilt();
	void   SetLotManufTimeParam(const PUGL::SetLotManufTimeParam * pS);
	void   GetLotManufTimeParam(PUGL::SetLotManufTimeParam * pS) const;

	enum {
		fCreateMrpTab = 0x0001,
		fSetManufDate = 0x0002 // @v10.5.12 Проекция PPDraftWrOff::Flags & DWOF_SETMANUFDATE
	};
	uint8  ReserveStart[28]; // @anchor // @v10.5.12 [32]-->[28]
	int16  SetManufDateOffsDays; // @v10.5.12 Проекция PPDraftWrOff::SetManufDateOffsDays с возможностью изменения
	int16  SetManufFixedTime;    // @v10.5.12 Проекция PPDraftWrOff::SetManufFixedTime с возможностью изменения
	DateRange Period;
	PPID   DwoID;
	PPID   PoolLocID;
	long   Flags;
	SString MrpTabName;      // @anchor
	PPIDArray CSessList;     // Список кассовых сессий, по которым надо списать документы.
		// Если список не пуст, то поле Period игнорируется.
};

class PrcssrWrOffDraft {
public:
	PrcssrWrOffDraft();
	int    InitParam(PrcssrWrOffDraftFilt *);
	int    EditParam(PrcssrWrOffDraftFilt *);
	int    Init(const PrcssrWrOffDraftFilt *);
	int    Run();
private:
	int    WriteOff(const PPDraftWrOffPacket * pPack,
		PPIDArray * pWrOffBillList, PPIDArray * pDfctList, PUGL * pPugl, PPID * pErrBillID, int use_ta);
		// @<<PrcssrWrOffDraft::Run
	int    UniteToPool(PPID poolOpID, const PPIDArray *, int use_ta);
	int    ProcessDeficit(const PPDraftWrOffPacket *, const PUGL * pPugl, int use_ta);
	int    CreateMrpTab(const PPDraftWrOffPacket *, PPID * pMrpTabID, MrpTabPacket *, int use_ta);
	int    GetWrOffBillList(const PPDraftWrOffEntry *, PPIDArray * pDfctList, PPIDArray *);
	int    GetWrOffBillList(const PPDraftWrOffPacket *, PPIDArray * pDfctList, PPIDArray *);
		// @>>PrcssrWrOffDraft::GetWrOffBillList(const PPDraftWrOffEntry *, PPIDArray *, PPIDArray *);
	int    ArrangeBillList(PPIDArray * pList);
	int    WriteOffMrp(const PPDraftWrOffPacket *, PUGL *);

	PrcssrWrOffDraftFilt P;
	PPObjBill * P_BObj;
	PPObjDraftWrOff DwoObj;
	PPObjOprKind OpObj;
	PPObjMrpTab MrpObj;
	PPLogger Logger;
};
//
// @ModuleDecl(PPObjRFIDDevice)
//
struct PPRFIDDevice {      // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_RFIDDEV
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // @symb
	char   Port[16];
	long   Flags;          //
	long   ProtocolVer;
	CommPortParams Cpp;    // Size=6 (default cbr=57600, StopBits=1, Parity=none, DataBits=8)
	uint16 Reserve;        // @alignment
	uint16 Get_NumTries;
	uint16 Get_Timeout;
	uint16 Put_NumTries;
	uint16 Put_Timeout;
	uint8  ReleCount;
	long   GoodsID;
	uint8  Reserve2[19];
	long   DeviceNumber;
	long   Reserve3;
};

class PPObjRFIDDevice : public PPObjReference {
public:
	PPObjRFIDDevice(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	virtual int  Browse(void * extraPtr);
	int    Test(const PPRFIDDevice & rRec, SString & rRetBuf);
	//int PPObjRFIDDevice::ExecOper(PPAbstractDevice * pDvc, int cmd, StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
};
//
// @ModuleDecl(PPObjGenericDevice)
//
struct PPGenericDevice {   // @persistent @store(Reference2Tbl+)
	PPGenericDevice();

	long   Tag;            // Const=PPOBJ_GENERICDEVICE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // @symb
	uint8  Reserve[60];
	long   Flags;
	long   DeviceClass;
	long   Reserve2;
};

#define GENDVCEXSTR_ENTRY    1
#define GENDVCEXSTR_PORT     2
#define GENDVCEXSTR_INITSTR  3

class PPGenericDevicePacket {
public:
	PPGenericDevicePacket();
	int    GetExtStrData(int fldID, SString & rBuf) const;
	int    PutExtStrData(int fldID, const char *);

	PPGenericDevice Rec;
	SString ExtString;
};

class PPObjGenericDevice : public PPObjReference {
public:
	//
	// Для селекторов в качестве extraParam передается класс устройства (или 0 для выбора устройства любого класса).
	//
	PPObjGenericDevice(void * extraPtr = 0);
	virtual int  Edit(PPID * pID, void * extraPtr);
	int    PutPacket(PPID * pID, PPGenericDevicePacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPGenericDevicePacket * pPack);
	int    Test(const PPGenericDevice & rRec, SString & rRetBuf);
private:
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
};
//
// @ModuleDecl(PPObjProject)
//
#define PRJCFGF_NEWTASKNOTICE        0x0001
#define PRJCFGF_NEWTASKNOTICEONLOGIN 0x0002
#define PRJCFGF_INCOMPLETETASKREMIND 0x0004
#define PRJCFGF_VALID                0x0008L  // @transient Запись инициализирована

struct PPProjectConfig { // @persistent @store(PropertyTbl) @size=90
	PPProjectConfig();
	PPProjectConfig & Z();

	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PROJECTCFG
	PPID   PrjCntrID;      // ->Ref(PPOBJ_OPCOUNTER)
	PPID   PhaseCntrID;    // ->Ref(PPOBJ_OPCOUNTER)
	PPID   TaskCntrID;     // ->Ref(PPOBJ_OPCOUNTER)
	PPID   TemplCntrID;    // ->Ref(PPOBJ_OPCOUNTER)
	int16  NewTaskTerm;    // Количество дней с даты создания, в течении которых задача
		// имеет признак "Новая" (TODOSTTS_NEW). После этого срока задача переводистя в статус
		// "В ожидании" (TODOSTTS_ONHOLD). Если NewTaskTerm == 0, то задача автоматически
		// не теряет статус TODOSTTS_NEW.
		// Отсчет дней идет с текущей системной даты
	int16  RejTaskTerm;    // Количество дней с даты начала исполнения (StartDt), в течении которых задача
		// остатется актуальной (имеет один из статусов: TODOSTTS_NEW, TODOSTTS_ONHOLD, TODOSTTS_INPROGRESS)
		// После этого периода задача переводится в статус "Отменена" (TODOSTTS_REJECTED).
		// Если StartDt == 0, то отсчет начинается с даты создания (Dt)
		// Если RejTaskTerm == 0, то задача автоматически не переводится в статус TODOSTTS_REJECTED.
		// Отсчет дней идет с текущей системной даты
	int16  TemplGenTerm;   // Период (в днях) на который следует сгенерировать задачи по шаблонам
		// при вызове функции обслуживания задач. Отсчет дней идет с текущей системной даты
	char   Text[38];       //
	long   Flags;          // PRGCFGF_XXX
	long   WorkHoursBeg;   //
	long   WorkHoursEnd;   //
	int16  RefreshTime;    //
	PPID   BillOpID;       //
	IntRange RemindPrd;    // Период напоминания о не выполненных задачах [-x..y]
};

//
// Виды записей таблицы ProjectTbl (Kind)
//
#define PPPRJK_PROJECT              1L // Проект
#define PPPRJK_PHASE                2L // Фаза
#define PPPRJK_PRJTEMPLATE          3L // Шаблон проекта
#define PPPRJK_PHSTEMPLATE          4L // Шаблон фазы
#define PPPRJK_GLBSVCPROMOCAMPAIGN  5L // @v12.2.6 Промо-кампания, осуществляемая на внешнем глобальном сервисе (маркетплейс, поисковый сервис, etc) 
	// Инициирующая задача - учет промо-кампаний на маркетплейсе
//
// Статусы проектов
//
#define PPPRJSTS_ACTIVE      1L // Проект/фаза в активной стадии работы
#define PPPRJSTS_NONACTIVE   2L // Проект/фаза завершен
#define PPPRJSTS_ARCHIVED    3L // Архивированный проект (только для проектов)

class PPProjectPacket {
public:
	PPProjectPacket();
	PPProjectPacket & Z();
	ProjectTbl::Rec Rec;
	SString SDescr;
	SString SMemo;
	ObjTagList TagL;        // @v12.2.6 Список тегов
};

class PPObjProject : public PPObject {
public:
	static int FASTCALL ReadConfig(PPProjectConfig *);
	static int EditConfig();
	static int FASTCALL FetchConfig(PPProjectConfig * pCfg);
	static int DirtyConfig();
	static SString & FASTCALL MakeCodeString(const ProjectTbl::Rec * pRec, SString & rBuf);

	explicit PPObjProject(void * extraPtr = 0);
	~PPObjProject();
	virtual int    Search(PPID id, void * b = 0);
	virtual int    Browse(void * extraPtr);
	//
	// Если параметр parentPrjID != 0 and *pID == 0, это означает, что
	// необходимо создать элемент типа Phase.
	//
	virtual int    Edit(PPID * pID, void * extraPtr/* parentPrjID */);
	virtual int    DeleteObj(PPID id);
	SString & GetItemDescr(PPID id, SString & rBuf);
	SString & GetItemMemo(PPID id, SString & rBuf);
	int    PutPacket(PPID * pID, PPProjectPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPProjectPacket * pPack);
	int    SerializePacket(int dir, PPProjectPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    InitPacket(PPProjectPacket * pPack, int kind /* PPPRJK_XXX */, PPID parentID, int use_ta);
	int    GetFullName(PPID id, SString & rBuf);
private:
	virtual const char * GetNamePtr();
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*parentPrjID*/);
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	//virtual int    HandleMsg(int, PPID, PPID, void * extraPtr);
	SString NameBuf;
public:
	TLP_MEMB(ProjectTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewProject)
//
struct ProjectFilt : public PPBaseFilt {
	ProjectFilt();

	enum {
		fShowNonActive = 0x0001,
		fShowArchived  = 0x0002,
		fPrintPrjTasks = 0x0004
	};
	enum {
		ordByName = 0,
		ordByBegDt
	};
	char   ReserveStart[32];   // @anchor
	PPID   ParentID;
	DateRange StartPeriod;
	DateRange EstFinishPeriod;
	PPID   ClientID;
	PPID   MngrID;
	long   Flags;
	long   SortOrd;
	long   Reserve;            // @anchor
};

struct ProjectViewItem : public ProjectTbl::Rec {
	PPID   PrjTaskID; // Для иерархической печати проект-фазы-задачи
};

class PPViewProject : public PPView {
public:
	PPViewProject();
	~PPViewProject();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ProjectViewItem *);
	int    InitPrjTaskIterations(PPID prjID);
	SString & GetItemDescr(PPID id, SString & rBuf); // @>>PPObjProject::GetItemDescr
	SString & GetItemMemo(PPID id, SString & rBuf); // @>>PPObjProject::GetItemMemo
private:
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void ViewTotal();
	virtual void * GetEditExtraParam();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    Export();
	int    Transmit(PPID);
	int    PrintProjectTasks(PPID prjID);
	PPViewPrjTask * P_PrjTaskView;
	ProjectFilt Filt;
	PPObjProject PrjObj;
};
//
//
//
#define TODOF_OPENEDBYEMPL       0x0001 // Исполнитель видел задачу
#define TODOF_ACTIONVIEWED       0x0002 // @transient В журнал выводить событие "исполнитель видел задачу", вместо - объект изменен

#define PRJTASKRT_MULTCHANGE     0x0100

#define PRJTASKBIAS_CLIENT       0x20000000L
#define PRJTASKBIAS_EMPLOYER     0x40000000L
#define PRJTASKBIAS_TEMPLATE     0x80000000L

#define TODOPSN_CREATOR          1
#define TODOPSN_EMPLOYER         2
#define TODOPSN_CLIENT           3

class PPPrjTaskPacket {
public:
	PPPrjTaskPacket();
	PPPrjTaskPacket & Z();

	PrjTaskTbl::Rec Rec;
	SString SDescr;
	SString SMemo;
};

struct iCalendarImportParam {
	iCalendarImportParam();
	iCalendarImportParam & Z();
	PPID   TodoDefCreatorID;
	PPID   TodoDefClientID;
	PPID   TodoDefEmployerID;
	SString FilePath;
};

class PPObjPrjTask : public PPObject {
public:
	static SString & GetStatusText(int statusId, SString &);
	static SString & GetPriorText(int priorId, SString &);
	static int ImportFromVCal();
	//
	// Descr: восстанавливает CreatorID, EmployerID, ClientID если такой персоналии не существует
	//
	static int RecoverAbsencePerson();

	explicit PPObjPrjTask(void * extraPtr = 0);
	~PPObjPrjTask();
	virtual int Search(PPID id, void * pRec = 0);
	virtual int Browse(void * extraPtr);
	//
	// Descr: интерактивная функция редактирования новой или существующей задачи.
	// ARG(pID     IN/OUT): указатель на ИД редактируемой записи. Если *pID == 0, то создается новая запись.
	//   Если *pID != 0, то извлекается запись с этим идентификатором и редактируется.
	// ARG(parentPrjID IN): актуально только в случае, если *pID == 0.
	//   Если (parentPrjID & 0x7fffffff) != 0, то новая запись создается в привязке к
	//   проекту (фазе проекта) с таким идентификатором.
	//   Если parentPrjID & 0x80000000, то создается запись шаблона задачи.
	//
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int DeleteObj(PPID id);
	virtual int EditRights(uint bufSize, ObjRights * buf, EmbedDialog * pDlg = 0);
	int    SerializePacket(int dir, PPPrjTaskPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    WritePacketWithPredefinedFormat(const PPPrjTaskPacket * pPack, int format, SString & rBuf, void * pCtx);
	int    ImportFromOuterFormat(const char * pInput, const iCalendarImportParam * pParam, TSCollection <PPPrjTaskPacket> & rList); // @v11.0.3
	int    SearchAnalog(const PPPrjTaskPacket * pPack, PPID * pAnalogID);
	int    InitPacket(PPPrjTaskPacket * pPack, int kind /* TODOKIND_XXX */, PPID prjID, PPID clientID, PPID employerID, int use_ta);
	int    InitPacketByTemplate(const PPPrjTaskPacket * pTemplPack, LDATE startDt, PPPrjTaskPacket * pPack, int use_ta);
	int    AddBySample(PPID * pID, PPID sampleID);
	SString & GetItemDescr(PPID id, SString & rBuf);
	SString & GetItemMemo(PPID id, SString & rBuf);
	int    PutPacket(PPID * pID, PPPrjTaskPacket * pPack, int use_ta);
	int    GetPacket(PPID id, PPPrjTaskPacket * pPack);
	int    CreateByTemplate(PPID templID, const DateRange * pPeriod, PPIDArray * pIdList, int use_ta);
	//
	// Descr: Осуществляет функции обслуживания базы данных задач:
	//   - Изменение статусов, согласно конфигурации PPProjectConfig
	//   - Формирование задач по шаблонам, имеющим статус отличный от TODOSTTS_REJECTED
	//     Задачи по шаблона формируются на период [curdate..curdate+PPProjectConfig::TemplGenTerm-1]
	//
	int    Maintain(); // @nointeract @ta
	int    GetLinkTasks(PPID taskID, PPIDArray * pAry);
	int    EditDialog(PPPrjTaskPacket * pPack); // @v10.7.2
private:
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr);
	virtual const char * GetNamePtr();
	virtual int  Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SubstDescr(PPPrjTaskPacket * pPack);
	int    DetermineNewStatus(const PPProjectConfig * pCfg, const PrjTaskTbl::Rec * pRec, int * pNewStatus);
	int    ResolveAbsencePersonHelper_(PPID newID, PPID prevID, int todoPerson);
public:
	TLP_MEMB(PrjTaskCore, P_Tbl);
	void * ExtraPtr;
	PPID   LinkTaskID;
};
//
// @ModuleDecl(PPViewPrjTask)
//
struct PrjTaskFilt : public PPBaseFilt {
public:
	PrjTaskFilt();
	virtual int Init(int fullyDestroy, long extraData);
	int    IncludeStatus(long status);
	int    ExcludeStatus(long status);
	int    IncludePrior(long prior);
	int    ExcludePrior(long prior);
	int    GetStatusList(PPIDArray *) const;
	int    GetPriorList(PPIDArray *) const;
	SString & GetStatusListText(SString &) const;
	SString & GetPriorListText(SString &) const;
	//
	char   ReserveStart[32];   // @anchor
	enum EnumOrder {
		// Строки, соответствующие порядку сортировки перечислены в PPTXT_TODOORDER
		ordByDefault = 0,
		ordByDt,
		ordByStartDt,
		ordByEstFinishDt,
		ordByFinishDt,
		ordByCreator,
		ordByEmployer,
		ordByClient,
		ordByCode
	} Order;
	enum EnumTabType {
		// Строки, соответствующие кросстабу перечислены в PPTXT_TODOCROSSTAB
		crstNone = 0,
		crstDateHour,
		crstClientDate,
		crstEmployerDate,
		crstClientEmployer,
		crstEmployerHour,
	} TabType;
	enum EnumTabParam {
		ctpNone   = 0,
		ctpUnComplTask    = 1,
		ctpComplTaskRatio = 2,
		ctpWrofBillPrct   = 3,
		ctpTaskCount      = 4
	} TabParam;
	enum {
		fUnbindedOnly = 0x0001, // Показывать только задачи, не привязанные к проектам
		fUnviewedOnly = 0x0002, // Показывать только те задачи, которые не были кем-либо просмотрены
		fUnviewedEmployerOnly = 0x0004, // Показывать только те задачи, которые не были просмотрены исполнителем
		fNotShowPPWaitOnInit  = 0x0008, // Не выдавать сообщение "Подождите" в PPViewPrjTask::Init()
		fNoTempTable  = 0x0010  // Не строить временную таблицу
	};
	long   Kind;               // TODOKIND_XXX
	PPID   ProjectID;          // ->Project.ID Проект, к которому привязана задача
	PPID   ClientID;           // ->Person.ID  Клиент
	PPID   EmployerID;         // ->Person.ID  Исполнитель
	PPID   TemplateID;         // ->PrjTask.ID (Kind=TODOKIND_TEMPLATE)
	PPID   CreatorID;          // ->Person.ID  Персоналия, создавшая задачу
	PPID   CliCityID;          // ->City.ID Город клиента
	PPID   LinkTaskID;         // ->PrjTask.LinkTaskID Связанная задача. Если != 0, Kind = TODOKIND_TASK, другие поля фильтра не используютс
	int16  PriorList[10];      // TODOPRIOR_XXX Список приоритетов, по которым необходимо получить выборку
	int16  StatusList[10];     // TODOSTTS_XXX  Список статусов, по которым необходимо получить выборку
	DateRange Period;          //
	DateRange StartPeriod;     //
	DateRange EstFinishPeriod; //
	DateRange FinishPeriod;    //
	long   Flags;              //
		// @<< PPViewPrjTask::ViewCrosstabDetail
	LTIME  StartTmPeriodBeg;   // период начала выполнения задани
	LTIME  StartTmPeriodEnd;   // используется только для построения детализации кросстаба
	SubstGrpDate Sgd;          //
	long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
private:
	int    InclInList(int16 * pList, size_t listSize, int16 val);
	int    ExclFromList(int16 * pList, size_t listSize, int16, int16, int16 val);
	int    GetList(const int16 * pList, size_t listSize, PPIDArray *) const;
};

typedef PrjTaskTbl::Rec PrjTaskViewItem;

class PPViewPrjTask : public PPView {
public:
	PPViewPrjTask();
	~PPViewPrjTask();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PrjTaskViewItem *);
	int    CheckIDForFilt(PPID id, const PrjTaskTbl::Rec * pRec);
	int    GetItem(PPID id, PrjTaskViewItem * pItem);
	void   GetTabTitle(PPID tabID, SString & rBuf);
	int    ChangeTasks(PPIDArray *);
	int    GetTimeGridItemText(PPID taskID, SString & rBuf);
	int    EditTimeGridItem(PPID * pID, PPID rowID, const LDATETIME & rDtm);
	SString & GetItemDescr(PPID id, SString & rBuf); // @>>PPObjPrjTask::GetItemDescr
	SString & GetItemMemo(PPID id, SString & rBuf); // @>>PPObjPrjTask::GetItemMemo
	//
	// ARG(id   IN): ignored
	// ARG(kind IN): 0 - передать данные синхронизации; 2 - экспорт в формате vCalendar
	//
	int    Transmit(PPID id, int kind);
private:
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual void ViewTotal();
	virtual int  Print(const void *);
	virtual void * GetEditExtraParam();
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    ViewCrosstabDetail(PPID tabID, const DBFieldList * pFldList);
	TempOrderTbl::Rec & MakeTempEntry(const PrjTaskTbl::Rec & rRec, TempOrderTbl::Rec & rTempRec);
	int    CheckRecForFilt(const PrjTaskTbl::Rec * pRec);
	int    UpdateTempTable(const PPIDArray * pIdList, int use_ta);
	int    Export();
	int    CreateByTemplate();
	int    PutRecToTempTable(PPID tabID, int taskNotFinished, long tabType, PrjTaskTbl::Rec *);
	int    SearchTempRec(PPID tabID, long tabType, void * pAddInfo, TempPrjTaskTbl::Rec * pRec);
	int    NextOuterIteration();
	int    NextInnerIteration(PrjTaskViewItem *);
	int    AddItemToTimeGrid(const PrjTaskViewItem *, int rmv);
	int    TimeChunkBrowser();
	int    UpdateTimeBrowser(int destroy);

	PrjTaskViewItem Item;
	PrjTaskFilt Filt;
	PPObjPrjTask TodoObj;
	PPObjPerson PsnObj;
	int    UndefPriorList;
	int    UndefStatusList;
	PPIDArray PriorList;
	PPIDArray StatusList;
	TempOrderTbl   * P_TempOrd;
	TempPrjTaskTbl * P_TempTbl;
	PPIDArray UpdateTaskList;
	//
	class PrjTaskTimeChunkGrid : public STimeChunkGrid {
	public:
		PrjTaskTimeChunkGrid(PPViewPrjTask * pV);
		~PrjTaskTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
	private:
		PPViewPrjTask * P_View; // @notowned
	};
	PrjTaskTimeChunkGrid Grid;
	ObjIdListFilt CreatorList;
	ObjIdListFilt EmployerList;
	ObjIdListFilt ClientList;
	SStrGroup StrPool; // Пул строковых полей, на который ссылаются поля в TempPrjTask
};
//
// @ModuleDecl(PPViewPriceAnlz)
//
class PriceAnlzFilt : public PPBaseFilt {
public:
	PriceAnlzFilt();
	PriceAnlzFilt & FASTCALL operator = (const PriceAnlzFilt & s);
	enum {
		fShowDiffAsPrc     = 0x00000001,
		fExclWOCntrCost    = 0x00000002,
		fExclWOCostOREqualBaseCost = 0x00000004,
		fDivideBySuppl     = 0x00000008
	};
	//
	// Правило расчета фактической цены
	//
	enum {
		caByFirstLot,      // По первому лоту
		caByAverageLot,    // Средняя по лотам
		caByLastLot,       // По последнему лоту
		caByMinLot,        // Минимальная по лотам
		caByMinLoc         // Минимальная по складам (по последним лотам до конца периода)
	};
	//
	// Правило расчета базовой цены
	//
	enum {
		bcByLoc,           // По лотам
		bcByContract,      // По контрактной цене
		bcByAvgLocs,       // Средняя по складам
		bcByPrevLot        // По предыдущему лоту
	};
	char   ReserveStart[32]; // @anchor
	long   CostAlg;        // Правило расчета фактической цены
	long   BaseCost;       // Правило расчета базовой цены
	PPID   SupplID;
	PPID   GoodsGrpID;
	DateRange Period;
	long   Flags;
	PPID   BaseLoc;
	ObjIdListFilt LocList; // @anchor
};

typedef TempPriceAnlzTbl::Rec PriceAnlzViewItem;

class PPViewPriceAnlz : public PPView {
public:
	PPViewPriceAnlz();
	~PPViewPriceAnlz();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PriceAnlzViewItem *);
	void   GetTabTitle(PPID tabID, SString & rBuf);
private:
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int    SetContractPrices();

	PriceAnlzFilt Filt;
	PPObjGoods    GObj;
	TempPriceAnlzTbl * P_TempTbl;
};
//
// Descr: Фасадный класс для управления полнотекстовым поиском
//
class PPFtsInterface {
public:
	enum { // @persistent
		scopeUndef     = 0, // Не определен
		scopePPDb      = 1, // База данных Papyrus 
		scopeStyloQSvc = 2, // Сервис Stylo-Q
		scopeTest      = 3  // Don't use: for testing only
	};
	struct Entity {
		Entity();
		Entity(const Entity & rS);
		Entity & FASTCALL operator = (const Entity & rS);
		bool   FASTCALL operator == (const Entity & rS) const { return IsEq(rS); }
		Entity & Z();

		bool   FASTCALL IsEq(const Entity & rS) const;
		bool   IsValid() const;
		//int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    MakeSurrogateScopeIdent(SBinaryChunk & rSsi) const;
		int    SetSurrogateScopeIdent(const SBinaryChunk & rSsi);

		uint32 Scope;
		uint32 ObjType;
		uint64 ObjId;
		SString ScopeIdent;
	};
	class SurrogateScopeList : public TSCollection <SBinaryChunk> {
	public:
		SurrogateScopeList();
		bool   Search(const SBinaryChunk & rKey, uint * pPos) const;
	};
	struct SearchResultEntry : public Entity {
		SearchResultEntry();
		uint64 DocId;
		uint64 Rank;
		double Weight;
		SString Text; // Текст, ассоциированный с найденным документом
	};
	class TransactionHandle {
	public:
		explicit TransactionHandle(PPFtsInterface & rS);
		~TransactionHandle();
		bool   operator !() const;
		int    Commit();
		int    Abort();
		int    Restart();
		//
		// Returns:
		//   >0 - идентификатор документа в базе данных
		//    0 - error
		//
		uint64 PutEntity(PPFtsInterface::Entity & rEnt, StringSet & rSsUtf8, const char * pOpaqueData);
	private:
		SPtrHandle H;
		PPFtsInterface & R_Ifc;
	};
	//
	// ARG(pDbLoc IN): Если аргумент не пустой, то указывает на путь к каталогу, где находятся (или должны находиться) данные.
	//   Если isempty(pDbLoc), то путь определяется автоматически по внутренней конфигурации (workspace\supplementaldata)
	//
	explicit PPFtsInterface(const char * pDbLoc, bool writer, long lockTimeout);
	~PPFtsInterface();
	bool   operator !() const;
	bool   IsWriter() const;
	int    Search(const char * pQueryUtf8, uint maxItems, TSCollection <PPFtsInterface::SearchResultEntry> & rResult);
private:
	class Ptr {
	public:
		//
		// ARG(pDbLoc IN): Если аргумент не пустой, то указывает на путь к каталогу, где находятся (или должны находиться) данные.
		//   Если isempty(pDbLoc), то путь определяется автоматически по внутренней конфигурации (workspace\supplementaldata)
		//
		Ptr(const char * pDbLoc, bool writer, long lockTimeout);
		~Ptr();
		bool operator !() const { return (P == 0); }
		bool IsWriter() const { return Writer; }
		operator PPFtsDatabase *() { return P; }
		PPFtsDatabase * operator ->() { return P; }
	private:
		PPFtsDatabase * P;
		const  bool Writer;
		uint8  Reserve[3]; // @alignment
		const  long LockTimeout; // Таймаут ожидания завершения блокирующего процесса (если я - "читатель", то жду завершения работы "писателя",
			// если я - "писатель", то жду завершения работы всех "читателей" и "писателей")
			// default: 500ms
	};
	PPFtsInterface::Ptr H;
};
//
//
//
class StyloQConfig {
public:
	enum { // @persistent
		tagUnkn            =  0,
		tagUrl             =  1, // URL сервера централизованной обработки
		tagMqbAuth         =  2, // Login MQ-брокера сервера централизованной обработки
		tagMqbSecret       =  3, // Secret MQ-брокера сервера централизованной обработки
		tagLoclUrl         =  4, // URL локальной обработки запросов (отдельная машина или сеанс)
		tagLoclMqbAuth     =  5, // Login MQ-брокера локальной обработки запросов (отдельная машина или сеанс)
		tagLoclMqbSecret   =  6, // Secret MQ-брокера локальной обработки запросов (отдельная машина или сеанс)
		tagFeatures        =  7, // Флаги особенностей сервиса
		//
		// Замечание по сроку действия: одна сторона передает другой период истечения срока действия в секундах.
		//   Принимающая сторона складывает это значение с текущим epoch-временем и сохраняет на своей стороне
		//   для того, чтобы в последующем принять решение о запросе обновления.
		//
		tagExpiryPeriodSec =  8, // @v11.2.3 Период истечения срока действия в секундах
		tagExpiryEpochSec  =  9, // @v11.2.3 Время истечения срока действия (секунды с 1/1/1970)
		tagPrefLanguage    = 10, // @v11.2.5 (private config) Предпочтительный язык
		tagDefFace         = 11, // @v11.2.5 (private config) Лик, используемый клиентом по умолчанию
		tagRole            = 12, // @v11.2.8 StyloQConfig::roleXXX Роль записи 
		tagCliFlags        = 13, // @v11.6.0 StyloQConfig::clifXXX Флаги клиента на стороне сервиса. То есть, после сопоставления клиента, сервис может
			// присвоить ему какие-либо флаги, например, с целью наделить его какими-то полномочиями
		tagNotificationActualDays  = 14, // @v11.7.4 (private config) Количество дней актуальности уведомлений
		tagUserFlags       = 15, // @v12.0.11 StyloQConfig::userfXXX Флаги пользовательского сеанса. Хранятся только на стороне локального приложения (сервису не передаются).
	};
	enum { // @persistent
		featrfMediator = 0x0001 // Сервис выполняет функции медиатора (обслуживание других сервисов и клиентов)
	};
	enum { // @persistent
		roleUndef             = 0, // Инвалидное неопределенное значение
		roleClient            = 1, // Клиент. Не может иметь флаг featrfMediator
		rolePublicService     = 2, // Публичный сервис. Может иметь флаг featrfMediator
		rolePrivateService    = 3, // Приватный сервис. Может иметь флаг featrfMediator
		roleDedicatedMediator = 4  // @v11.2.12 Выделенный медиатор. Обязательно имеет флаг featrfMediator, но не обрабатывает "потребительские" запросы.
	};
	//
	// Descr: Флаги для тега tagCliFlags
	//
	enum { // @persistent
		clifDisableFaceSelfModifying = 0x0001, // Явное разрешение на автоматическое изменение лика клиентом. Это флаг избыточен, так как
			// вопрос изменения лика клиента решается автоматически на остновании признака StyloQCore::styloqfAutoObjMatching. 
			// Но в том, случае, если сервис "хочет" явно разрешить клиенту обновлять свой лик, то может установить этот флаг.
		clifSvcGPS            = 0x0002, // Клиенту разрешается установить GPS-координаты сервиса
		clifPsnAdrGPS         = 0x0004, // Клиенту разрешается устанавливать GPS-координаты адресов доставки перосналий (контакты, покупатели etc)
		clifShareDoc          = 0x0008, // @v11.9.0 Клиенту разрешается делиться документами
	};
	//
	// Descr: Приватные флаги конфигурации, применяемые только на стороне отдельного клиента
	//
	enum {
		userfNetworkDisabled  = 0x0001, // @v12.0.11 Пользователь намеренно отключил функции сетевого обмена
		userfSvcArchived      = 0x0002, // @v12.2.2  Сервис архивирован (более не используется)
	};

	static int MakeTransmissionJson(const char * pSrcJson, const void * pClientPacket, SString & rTransmissionJson);
	//
	// ARG(pClientPacket IN): Если !0 то функция извлекает из этого пакета конфигурацию ассоциации клиента с сервисом
	//   с целью дополнить передаваемую конфигурацию параметрами из клиентской конфигурации (а именно, на первых порах, полем флагов tagCliFlags).
	//
	static SJson * MakeTransmissionJson_(const char * pSrcJson, const void * pClientPacket);
	StyloQConfig();
	bool   FASTCALL IsEq(const StyloQConfig & rS) const;
	StyloQConfig & Z();
	uint   GetCount() const { return L.getCount(); }
	//
	// Descr: Устанавливает значение тега tag. Не обрабатывает теги tagFeatures и tagRole (see SetFeatures() and SetRole())
	//
	int    Set(int tag, const char * pText);
	//
	// Descr: Возвращает значение тега tag в буфере rResult. Не обрабатывает теги tagFeatures и tagRole (see GetFeatures() and GetRole())
	//
	int    Get(int tag, SString & rResult) const;
	//
	// Descr: Устанавливает флаги особенностей сервиса. Проверяет непротиворечивость заданного значения ff 
	//   другим атрибутам сервиса.
	//
	int    SetFeatures(uint64 ff);
	uint64 GetFeatures() const;
	//
	// Descr: Устанавливает значение роли сервиса (roleXXX). Проверяет непротиворечивость заданного значения 
	//   другим атрибутам сервиса.
	//
	int    SetRole(uint role);
	uint   GetRole() const;
	int    FromJson(const char * pJsonText);
	int    FromJsonObject(const SJson * pJsObj);
	//
	// Descr: Формирует json-объект представления конфигурации. Используется для хранения в базе данных и 
	//   передачи клиентам по сети.
	// Note: Полученный экземпляр объекта должен быть разрушен вызывающей функцией.
	//
	SJson * ToJson() const;
	int    ToJson(SString & rResult) const;
private:
	StrAssocArray L;
};

class StyloQFace {
public:
	enum { // @persistent
		statusUndef = 0,
		statusPrvMale = GENDER_MALE, // 1
		statusPrvFemale = GENDER_FEMALE, // 2
		statusPrvGenderQuestioning = GENDER_QUESTIONING, // 3
		statusEnterprise = 1000 // Обобщенный статус юридического лица
	};
	enum { // @persistent
		tagUnkn    =  0, //
		tagVerifiable_Deprecated = 1, // verifiable : bool ("true" || "false")
		tagCommonName         =  2, // cn : string with optional language shifted on 16 bits left
		tagName               =  3, // name : string with optional language shifted on 16 bits left
		tagSurName            =  4, // surname : string with optional language shifted on 16 bits left
		tagPatronymic         =  5, // patronymic : string with optional language shifted on 16 bits left
		tagDOB                =  6, // dob : ISO-8601 date representation
		tagPhone              =  7, // phone : string
		tagGLN                =  8, // gln : string (numeric)
		tagCountryIsoSymb     =  9, // countryisosymb : string
		tagCountryIsoCode     = 10, // countryisocode : string (numeric)
		tagCountryName        = 11, // country : string with optional language shifted on 16 bits left
		tagZIP                = 12, // zip : string
		tagCityName           = 13, // city : string with optional language shifted on 16 bits left
		tagStreet             = 14, // street : string with optional language shifted on 16 bits left
		tagAddress            = 15, // address : string with optional language shifted on 16 bits left
		tagImage              = 16, // image : mimeformat:mime64
		tagRuINN              = 17, // ru_inn : string (numeric)
		tagRuKPP              = 18, // ru_kpp : string (numeric)
		tagRuSnils            = 19, // ru_snils : string (numeric)
		tagModifTime          = 20, // modtime : ISO-8601 date-time representation (UTC)
		tagDescr              = 21, // descr : string
		tagLatitude           = 22, // lat : real
		tagLongitude          = 23, // lon : real
		//
		// Замечание по сроку действия: одна сторона передает другой период истечения срока действия в секундах.
		//   Принимающая сторона складывает это значение с текущим epoch-временем и сохраняет на своей стороне
		//   для того, чтобы в последующем принять решение о запросе обновления.
		//
		tagExpiryPeriodSec    = 24, // @v11.2.3 Период истечения срока действия в секундах
		tagExpiryEpochSec     = 25, // @v11.2.3 Время истечения срока действия (секунды с 1/1/1970)
		tagEMail              = 26, // @v11.3.0 
		tagVerifiability      = 27, // @v11.3.2 arbitrary || anonymous || verifiable
		tagStatus             = 28, // @v11.3.6 statusXXX : string
		tagImageBlobSignature = 29, // @v11.3.8 Сигнатура изображения tagImage для передачи клиенту (само изображение клиент получит от медиатора, предъявив сигнатуру)
	};
	/*enum {
		// @#(fVerifiable^fAnonym)
		fVerifiable = 0x0001,
		fAnonym     = 0x0002  // @v11.3.2 
	};*/
	enum {
		vArbitrary  = 0,
		vAnonymous  = 1,
		vVerifiable = 2
	};
	int32  Id;
	//int32  Flags;

	static bool IsTagLangDependent(int tag)
	{
		return oneof9(tag, tagCommonName, tagName, tagSurName, tagPatronymic, tagCountryName, tagCityName, tagStreet, tagAddress, tagDescr);
	}
	static int MakeTransmissionJson(PPID id, const SBinaryChunk & rOwnIdent, const char * pSrcJson, SString & rTransmissionJson);
	static SJson * MakeTransmissionJson(PPID id, const SBinaryChunk & rOwnIdent, const char * pSrcJson);
	StyloQFace();
	~StyloQFace();
	bool   FASTCALL IsEq(const StyloQFace & rS) const;
	StyloQFace & Z();
	uint  GetCount() const { return L.getCount(); }
	//
	// Descr: Прикладная функция, формирующая однострочное представление лика для отображения в списках и т.д.
	//
	int   GetRepresentation(int lang, SString & rBuf) const;
	int   Set(int tag, int lang, const char * pText);
	int   SetVerifiability(int v);
	int   SetDob(LDATE dt);
	int   SetStatus(int status);
	int   SetImage(int imgFormat/*SFileFormat::XXX*/, const SImageBuffer * pImg);
	bool  Has(int tag, int lang) const;
	int   Get(int tag, int lang, SString & rResult) const;
	int   GetExactly(int tag, int lang, SString & rResult) const;
	LDATE GetDob() const;
	int   SetGeoLoc(const SGeoPosLL & rPos);
	int   GetGeoLoc(SGeoPosLL & rPos) const;
	int   GetVerifiability() const;
	//
	// Descr: Возвращает целочисленное значение тега tagStatus.
	// Returns:
	//   >= 0 - статус лика (statusXXX)
	//    < 0 - error
	//
	int   GetStatus() const;
	int   GetImage(SImageBuffer * pImg, int * pImgFormat) const;
	int   FromJson(const char * pJsonText);
	int   FromJsonObject(const SJson * pJsObj);
	//
	// Descr: Преобразует внутреннее представление лика в текстовый json-объект.
	// ARG(forTransmission IN): Если true, то формирует результат с небольшими модификациями.
	//   В частности, изображение, если есть, не передается, но вместо него вставляется тег tagImageBlobSignature
	//   с сигнатурой изображения чтобы клиент самостоятельно его получил от медиатора.
	// ARG(rResult OUT): Строковый буфер, в который записывается текстовое представление JSON.
	// Returns:
	//   >0 - преобразование успешно
	//   <0 - лик пустой
	//   0 - error
	//
	int   ToJson(bool forTransmission, SString & rResult) const;
	//
	// Descr: Преобразует внутреннее представление лика в json-объект.
	//   Объект json, который возвращен функцией должен быть разрушен вызывающей функцией.
	// ARG(forTransmission IN): Если true, то формирует результат с небольшими модификациями.
	//   В частности, изображение, если есть, не передается, но вместо него вставляется тег tagImageBlobSignature
	//   с сигнатурой изображения чтобы клиент самостоятельно его получил от медиатора.
	// Returns:
	//   !0 - json-объект лика
	//   0  - ошибка
	//
	SJson * ToJsonObject(bool forTransmission) const;
private:
	int   GetLanguageList(LongArray & rList) const;
	int   Implement_Get(int tag, int lang, SString * pResult) const;

	StrAssocArray L;
};

class StyloQCore : public StyloQSecTbl {
public:
	//
	// Карта соответствия идентификатора сервиса символу базы данных.
	// Необходима для того, чтобы можно было понять в какой базе данных авторизоваться серверу
	// для обработки запроса к сервису.
	//
	struct SvcDbSymbMapEntry {
		SvcDbSymbMapEntry();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		enum {
			fHasUserAssocEntries = 0x0001
		};
		SBinaryChunk SvcIdent;
		SString DbSymb;
		uint32 Flags;
	};

	class SvcDbSymbMap : public TSCollection <SvcDbSymbMapEntry> {
	public:
		SvcDbSymbMap();
		SvcDbSymbMap(const SvcDbSymbMap & rS);
		SvcDbSymbMap & FASTCALL operator = (const SvcDbSymbMap & rS);
		int    FASTCALL Copy(const SvcDbSymbMap & rS);
		int    Store(const char * pFilePath);
		//
		// Descr: Загружает экземпляр из файла pFilePath.
		// ARG(pFilePath IN): Имя файла, из которого следует загрузить экзмепляр.
		//   Если isempty(pFilePath), то читает из штатного хранилища, определяемого методом this->InitFilePath().
		// ARG(loadTimeUsage IN): Опция, определяющая использования времени последней загрузки LoadTime:
		//   0 - загружает в любом случае
		//   >0 - загружает только если LoadTime == 0
		//   <0 - загружает только в случае, если время модификации файла больше чем LoadTime
		// Returns:
		//   >0 - загрузка осуществлена успешно
		//   <0 - файл-источник отсутствует, либо загрузки не было по причине, определяемой параметром loadTimeUsage
		//    0 - error
		//
		int    Read(const char * pFilePath, int loadTimeUsage);
		bool   IsLoaded() const { return (LoadTime > 0); }
		bool   FindSvcIdent(const SBinaryChunk & rIdent, SString * pDbSymb, uint * pFlags) const;
		bool   HasDbUserAssocEntries(const char * pDbSymb) const;
		static int Dump(const char * pInputFileName, const char * pDumpFileName);
	private:
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		SString & InitFilePath(const char * pOuterPath, SString & rResultBuf);
		int64  LoadTime; // @transitive epoch-time since last loading. zero - isn't loaded. Used for global instance only.
	};
	//
	// Descr: Виды записей реестра объектов Stylo-Q
	//
	enum { // @persistent
		kUndef          = 0,
		kNativeService  = 1, // Собственная идентификация. Используется для любого узла, включая клиентские, которые никогда не будут сервисами //
		kForeignService = 2, //
		kClient         = 3, //
		kSession        = 4, //
		kFace           = 5, // Параметры лика, которые могут быть переданы серверу для ассоциации с нашим клиентским аккаунтом
		kDocIncoming    = 6, // Входящие документы
		kDocOutcoming   = 7, // Исходящие документы
		kCounter        = 8, // @v11.2.10 Специальная единственная запись для хранения текущего счетчика (документов и т.д.)
		kNotification_before90v = 9, // @obsolete since @v11.7.5 (Stylo-Q v90) @v11.5.9  Документ извещения. Главным образом, предполагаются извещения от сервисов к клиентам. Но, вероятно,
			// будут возможны и извещения в обратном направлении (клиент о чем-то информирует сервис).
	};
	//
	// Descr: Флаги записи таблицы данных StyloQ bindery (StyloQSec::Flags)
	//
	enum {
		styloqfMediator          = 0x0001, // Запись соответствует kForeignService-медиатору. Флаг устанавливается/снимается при создании или обновлении
			// записи после получения соответствующей информации от сервиса-медиатора
		styloqfDocStatusFlags    = (0x02|0x04|0x08|0x10|0x20|0x40), // 6 bits используются для кодирования статуса документа
		//styloqfDocFinished       = 0x0002, // @v11.3.12 Для документа: цикл обработки для документа завершен. Не может содержать флаги (styloqfDocWaitForOrdrsp|styloqfDocWaitForDesadv|styloqfDocDraft)
		//styloqfDocWaitForOrdrsp  = 0x0004, // @v11.3.12 Для документа заказа: ожидает подтверждения заказа. Не может содержать флаги (styloqfDocFinished|styloqfDocDraft)
		//styloqfDocWaitForDesadv  = 0x0008, // @v11.3.12 Для документа заказа: ожидает документа отгрузки. Не может содержать флаги (styloqfDocFinished|styloqfDocDraft)
		//styloqfDocDraft          = 0x0010, // @v11.3.12 Для документа: драфт-версия. Не может содержать флаги (styloqfDocFinished|styloqfDocWaitForOrdrsp|styloqfDocWaitForDesadv)
		//styloqfDocCancelledByCli = 0x0040, // @v11.4.0 Для документа: документ отменен клиентом
		//styloqfDocCancelledBySvc = 0x0080, // @v11.4.0 Для документа: документ отменен сервисом
		//styloqfDocStatusFlagsMask = (styloqfDocDraft|styloqfDocTransmission|styloqfDocFinished|styloqfDocWaitForOrdrsp|styloqfDocWaitForDesadv)
		styloqfDocTransmission     = 0x0080, // @v11.4.0  Для документа: технический флаг, устанавливаемый перед отправкой документа контрагенту и снимаемый после того, как 
			// контрагент подтвердил получение. Необходим для управления документами, передача которых не завершилась.
		styloqfPassive             = 0x0100, // @v11.4.6 Флаг для kForeignService. Означает, что сервис пассивен (относительно клиента) и не должен отображаться в регулярном списке у клиента.
		styloqfUnprocessedDoc_     = 0x0200, // @v11.5.0 
		styloqfAutoObjMatching     = 0x0400, // @v11.5.6 Объект (обычно, персоналия), соответствующий клиентской записи, был создан автоматически.
			// Флаг необходим для дифференцированного изменения записи объекта в зависимости от того, пришел он изначально от клиента или же существует
			// в базе данных серсиса самостоятельно (матчинг с клиентом был осуществлен вручную).
		styloqfProcessed           = 0x0800, // @v11.5.10 Запись обработана. Флаг изначально введен для пометки записей типа kNotification_before90v как прочитанных. 
			// В дальнейшем будет, вероятно, применяться и для других типов записей.
	};
	//
	// Descr: Флаги записей реестра Stylo-Q
	// @attention - этот флаг введен и используется по ошибке. Вместо него следует использовать styloqfUnprocessedDoc_
	// Для этого необходимо конвертировать таблицу базы данных.
	enum {
		fUnprocessedDoc_Misplaced = 0x0001, // Необработанный документ. Изначально введен для идентификации документов поискового контента (doctypIndexingContent), 
			// которые не были проиндексированы. В дальнейшем возможны дополнительные применения.
	};
	// 
	// Статусы документов заказа клиент-->сервис
	// 
	enum {
		styloqdocstUNDEF                 =  0, // неопределенный статус. Фактически, недопустимое состояние.
		styloqdocstDRAFT               	 =  1, // драфт. Находится на стадии формирования на стороне эмитента
		styloqdocstWAITFORAPPROREXEC   	 =  2, // ждет одобрения или исполнения от акцептора
		styloqdocstAPPROVED            	 =  3, // одобрен акцептором
		styloqdocstCORRECTED           	 =  4, // скорректирован акцептором (от акцептора поступает корректирующий документ, который привязывается к оригиналу)
		styloqdocstCORRECTIONACCEPTED  	 =  5, // корректировка акцептора принята эмитентом 
		styloqdocstCORRECTIONREJECTED  	 =  6, // корректировка акцептора отклонена эмитентом (документ полностью отменяется и цикл документа завершается)
		styloqdocstREJECTED            	 =  7, // отклонен акцептором (цикл документа завершается)
		styloqdocstMODIFIED            	 =  8, // изменен эмитентом (от эмитента поступает измененная версия документа, которая привязывается к оригиналу)
		styloqdocstCANCELLED           	 =  9, // отменен эмитентом (цикл документа завершается). Переход в это состояние возможен с ограничениями.
		styloqdocstEXECUTED            	 = 10, // исполнен акцептором
		styloqdocstEXECUTIONACCEPTED   	 = 11, // подтверждение от эмитента исполнения документа акцептором (цикл документа завершается)
		styloqdocstEXECUTIONCORRECTED    = 12, // корректировка от эмитента исполнения документа акцептором (от эмитента поступает документ согласования)
		styloqdocstEXECORRECTIONACCEPTED = 13, // согласие акцептора с документом согласования эмитента
		styloqdocstEXECORRECTIONREJECTED = 14, // отказ акцептора от документа согласования эмитента - тупиковая ситуация, которая должна быть
			// разрешена посредством дополнительных механизмов (escrow счета, полный возврат с отменой платежей и т.д.)
		styloqdocstFINISHED_SUCC         = 15, // Финальное состояние документа: завершен как учтенный и отработанный.
		styloqdocstFINISHED_FAIL         = 16, // Финальное состояние документа: завершен как отмененный.
		styloqdocstCANCELLEDDRAFT        = 17, // @v11.4.1 Драфт отмененый эмитентом. Переход в это состояние возможен только после styloqdocstDRAFT || styloqdocstUNDEF.
		styloqdocstINCOMINGMOD           = 18, // @v11.4.9 Входящий (по отношению к клиенту) документ, над которым осуществлена частичная модификация
		styloqdocstINCOMINGMODACCEPTED   = 19, // @v11.4.9 Входящий (по отношению к клиенту) документ, над которым осуществлена частичная модификация, которая, в свою очередь, акцептирована сервисом.
		styloqdocstPARTIALLYEXECUTED     = 20, // @v11.6.8 частично исполнен акцептором
	};
	//
	// Descr: Типы документов, хранящихся в реестре Stylo-Q
	//
	enum { // @persistent
		doctypUndef           = 0,
		doctypCommandList     = 1,
		doctypOrderPrereq     = 2, // Предопределенный формат данных, подготовленных для формирования заказа на клиентской стороне
		doctypReport          = 3, // @v11.2.10 Отчеты в формате DL600 export
		doctypGeneric         = 4, // @v11.2.11 Общий тип для документов, чьи характеристики определяются видом операции (что-то вроде Bill в Papyrus'е)
		doctypIndexingContent = 5, // @v11.3.4 Документ, содержащий данные для индексации медиатором
		doctypIndoorSvcPrereq = 6, // @v11.4.5 Предопределенный формат данных, подготовленных для формирования данных для обслуживания внутри помещения сервиса (INDOOR)
		doctypIncomingList    = 7, // @v11.4.8 
		doctypDebtList        = 8, // @v11.5.4 Реестр долговых документов по контрагентам. Специфичный документ: на клиентской стороне хранится единый реестр по всем
			// контрагентам. При этом запрос сервису отправляется по одному контрагенту, а ответ (корректный) встраивается в общий реестр.
		doctypCurrentState    = 9, // @v11.7.0 Внутренний документ, сохраняющий состояние и, возможно, какие-то конфигурационные параметры.
			// Применим только для клиентской базы данных.
	};
	struct StoragePacket {
		StoragePacket();
		StoragePacket(const StoragePacket & rS);
		StoragePacket & FASTCALL operator = (const StoragePacket & rS);
		bool   FASTCALL IsEq(const StoragePacket & rS) const;
		bool   IsValid() const;
		bool   SetDocStatus(int styloqDocStatus);
		int    GetDocStatus() const;
		//
		// Descr: Возвращает идентификатор лика в пуле пакета в зависимости от типа пакета.
		//
		uint32 GetFaceTagID() const 
		{
			return oneof2(Rec.Kind, kClient, kForeignService) ? SSecretTagPool::tagFace : SSecretTagPool::tagSelfyFace;
		}
		int    GetFace(uint32 tag, StyloQFace & rF) const;
		const  uint32 Signature; // @v11.6.0 @transient сигнатура экземпляра для верификации корректности указателя, передаваемого как (void *)
		StyloQSecTbl::Rec Rec;
		SSecretTagPool Pool;
	};
	struct IgnitionServerEntry {
		SBinaryChunk Ident;
		SString Url;
	};

	static PPIDArray & MakeLinkObjTypeList(bool addUnaddignedObj, PPIDArray & rList);
	static int  BuildSvcDbSymbMap();
	static int  ReadIgnitionServerList(TSCollection <IgnitionServerEntry> & rList);
	static bool GetDbMapBySvcIdent(const SBinaryChunk & rIdent, SString * pDbSymb, uint * pFlags);
	//
	// Descr: Возвращает копию ассоциаций идентификаторов сервисов с символами баз данных.
	//
	static bool GetDbMap(SvcDbSymbMap & rMap);
	//
	// Descr: Возвращает true если статус документа status является завершающим.
	//   По документу с таким статусом любые операции невозможны либо бессмысленны.
	// @todo Потребуются уточнения спецификации!
	//
	static bool IsDocStatusFinished(int status);
	static bool ValidateStatusTransition(int status, int newStatus);
	static void MakeDocExtDescriptionText(long docType, long flags, SString & rBuf);

	StyloQCore();
	int    PutPeerEntry(PPID * pID, StoragePacket * pPack, int use_ta);
	int    GetPeerEntry(PPID id, StoragePacket * pPack);
	int    SearchSession(const SBinaryChunk & rOtherPublic, StoragePacket * pPack);
	int    PutDocument(PPID * pID, const SBinaryChunk & rContractorIdent, int direction, int docType, const SBinaryChunk & rIdent, const SSecretTagPool & rPool, int use_ta);
	//
	// Descr: Вариант PutDocument, возвращающий сохраненную запись по указателю pResultRec.
	//   Применяется тогда, когда нужно получить атрибуты записи, автоматически сформированные функцией.
	//
	int    PutDocument(PPID * pID, StyloQSecTbl::Rec * pResultRec, const SBinaryChunk & rContractorIdent, int direction, int docType, const SBinaryChunk & rIdent, const SSecretTagPool & rPool, int use_ta);
	//
	// Descr: Ищет самый последний документ типа docType с направлением direction (-1 - входящие, +1 - исходящие).
	//   Если pIdent != 0, то дополнительное условие - равенство StyloQSec::BI указанному значению.
	// Returns:
	//   >0 - искомый документ найден
	//   <0 - искомый документ не найден
	//    0 - error
	//
	int    GetDocByType(int direction, int docType, const SBinaryChunk * pIdent, StoragePacket * pPack);
	int    GetDocIdListByType(int direction, int docType, const SBinaryChunk * pIdent, LongArray & rIdList);
	//
	// Descr: Возвращает список идентификаторов входящих документов с контентом для индексации, которые еще не были обработаны (Flags & fUnprocessedDoc).
	//
	int    GetUnprocessedIndexindDocIdList(LongArray & rIdList);
	int    GetMediatorIdList(LongArray & rIdList);
	//
	// OwnPeerEntry содержит следующие теги:
	//    SSecretTagPool::tagPrimaryRN - первичный ключ (длинное случайное число)
	//    SSecretTagPool::tagSvcIdent - публичный идентификатор. Это - идентификатор, которым узел представляется в широковещательном контексте.
	//    SSecretTagPool::tagAG
	//    SSecretTagPool::tagFPI
	//
	int    GetOwnPeerEntry(StoragePacket * pPack);

	enum {
		gcisfMakeSecret = 0x0001
	};
	//
	// Descr: Генерирует клиентский идентификатор для сервиса с идентификатором pSvcId[svcIdLen].
	//   Исходный пул rOwnPool должен содержать SSecretTagPool::tagPrimaryRN и SSecretTagPool::tagAG.
	//   В результирующий пул rPool вставляется сгенерированный клиентский идентификатор resultIdentTag (SSecretTagPool::tagClientIdent || SSecretTagPool::tagSvcIdent).
	//   SSecretTagPool::tagSvcIdent применяется при генерации собственного набора параметров участника (и для клиента и для сервиса).
	//   Если аргумент flags содержит битовый флаг gcisfMakeSecret, то так же генерируется секрет (SSecretTagPool::tagSecret).
	//
	int    GeneratePublicIdent(const SSecretTagPool & rOwnPool, const SBinaryChunk & rSvcIdent, uint resultIdentTag, long flags, SSecretTagPool & rPool); // @v11.2.7
	int    SetupPeerInstance(PPID * pID, int use_ta); // @v11.2.7
	int    SearchGlobalIdentEntry(int kind, const SBinaryChunk & rIdent, StoragePacket * pPack);
	int    ReadCurrentPacket(StoragePacket * pPack);
	int    MakeTextHashForCounterparty(const StoragePacket & rOtherPack, uint len, SString & rBuf);
	int    MakeDocumentStorageIdent(const SBinaryChunk & rOtherIdent, const S_GUID & rCmdUuid, SBinaryChunk & rDocIdent) const;
	int    IndexingContent();
	int    IndexingContent_Json(PPFtsInterface::TransactionHandle * pFtsTra, PPTextAnalyzer * pTa, const char * pJsText);
	int    GetMediatorList(TSCollection <StyloQCore::IgnitionServerEntry> & rList);
	//
	// @v12.3.1
	// Descr: Тестовая процедура для проверки и отладки индексации контента в условиях максимально близких к реальным.
	//
	static int Test_IndexingContent(const char * pDbLoc, const char * pJsText);
private:
	int    Helper_PutDocument(PPID * pID, StyloQSecTbl::Rec * pResultRec, const SBinaryChunk & rContractorIdent, int direction, int docType, const SBinaryChunk & rIdent, const SSecretTagPool & rPool, int use_ta);
	static SJson * PreprocessIndexingContent(const char * pJsText, SString & rSvcIdent);
	static int  Helper_IndexingContent_Json(PPFtsInterface::TransactionHandle * pFtsTra, PPTextAnalyzer * pTa, const SJson * pJs, const SString & rSvcIdent, int64 svcId);
	static ReadWriteLock _SvcDbMapRwl; // Блокировка для защиты _SvcDbMap
	static SvcDbSymbMap _SvcDbMap;
};
//
// Descr: Список команд сервиса Stylo-Q. Внутренний объект StyloQCommandList::Item определяет одиночную команду.
//
class StyloQCommandList {
public:
	//
	// Descr: Идентификаторы базовых типов команд
	//
	// Префиксы sqbcRsrv имеют команды, определяющие специализированный формат данных для того, чтобы было
	// проще реализовать 2-фазное взаимодействие между клиентом и сервисом. Фактически, это hardcoding-варианты
	// для ускорения начального этапа разработки и они несколько выпадают из общего концептуального замысла.
	//
	enum { // @persistent
		sqbcEmpty                =  0,
		sqbcRegister             =  1,
		sqbcDtLogin              =  2, // Команда авторизации в desktop-сеансе Papyrus с мобильного телефона
		sqbcPersonEvent          =  3,
		sqbcReport               =  4,
		sqbcSearch               =  5, // Поисковый запрос
		sqbcObjTransmit          = 21, // @special Передача данных между разделами papyrus. Кроме этой, мы резервируем
			// еще 9 (до 30 включительно) номеров для этой технологии, поскольку там достаточно разнообразных вариантов.
		// last obj transmit command = 30
		sqbcPosProtocolHost      = 31, // @special Данные в формате papyrus-pos-protocol со стороны хоста
		sqbcPosProtocolFront     = 32, // @special Данные в формате papyrus-pos-protocol со стороны кассового узла
			// Резервируем еще 8 (до 40 включительно) номеров для этого протокола.
		// last pos protocol command = 40
		sqbcRsrvOrderPrereq      = 101, // Модуль данных, передаваемых сервисом клиенту чтобы тот мог сформировать 
			// заказ. Дополнительные параметры определяют особенности модуля: заказ от конечного клиента, 
			// агентский заказ, заказ на месте и т.д.
		sqbcRsrvAttendancePrereq = 102, // Модуль данных, передаваемых сервисом клиенту для формирования записи на обслуживаение.
		sqbcRsrvPushIndexContent = 103, // @v11.3.4 Параметры передачи сервисам-медиаторам данных для поисковой индексации
		sqbcRsrvIndoorSvcPrereq  = 104, // @v11.4.4 Параметры обслуживания внутри помещения сервиса (horeca, shop, etc)
			// Буфер параметров команды содержит идентификатор кассового узла.
			// Данные строятся на основании параметров, определяемых кассовым узлом.
		sqbcGoodsInfo            = 105, // @v11.4.4 Параметры, определяющие вывод информации об одном товаре 
		sqbcLocalBarcodeSearch   = 106, // @v11.4.5 Поиск в пределах сервиса (преимущественно) по штрихкоду. 
			// Если сервис предоставляет такую функцию, то она отображается в виде иконки на экране мобильного устройства, а не в общем списке.
		sqbcIncomingListOrder    = 107, // @v11.4.6 Список входящих заказов (команда обязательно ассоциируется с внутренним объектом данных: персоналией, пользователем etc)
		sqbcIncomingListCCheck   = 108, // @v11.4.7 Список входящих кассовых чеков (команда обязательно ассоциируется с внутренним объектом данных: персоналией, пользователем etc)
		sqbcIncomingListTSess    = 109, // @v11.4.7 Список входящих технологических сессий (команда обязательно ассоциируется с внутренним объектом данных: персоналией, пользователем etc)
		sqbcIncomingListTodo     = 110, // @v11.4.7 Список входящих задач (команда обязательно ассоциируется с внутренним объектом данных: персоналией, пользователем etc)
		sqbcDebtList             = 111, // @v11.5.4 Список долговых документов по контрагенту. В общем случае, это могут быть как долги и покупателей, так и наша 
			// задолженность перед поставщиками. Пока предполагается использовать как вспомогательную команду для получения долговой ведомости по клиенту в рамках
			// работы с более высокоуровневыми командами (eg sqbcRsrvOrderPrereq)
		sqbcTest                 = 112, // @v12.3.1 Тестовая команда
	};
	//
	// Descr: Идентификаторы типов документов обмена
	//
	enum { // @persistent
		sqbdtNone       = 0,
		// Диапазон [1..500] зарезервирован за типами документов EDI в соответствии с идентификацией PPEDIOP_XXX
		// Только небольшая часть из тех операций будут применены для Stylo-Q, но для обеспечения соответствия и
		// минимизации дублирования мы резервируем диапазон с запасом.
		sqbdtCCheck     = 501, // Кассовый чек
		sqbdtContact    = 502, // Контактные данные персоналии
		sqbdtTodo       = 503, // Задача (todo)
		sqbdtSvcReq     = 504, // Запрос на обслуживание
	};
	struct Item {
		Item();
		bool   FASTCALL IsEq(const Item & rS) const;
		//
		// T must be inherited from PPBaseFilt (StyloQAttendancePrereqParam, StyloQIncomingListParam, etc)
		//
		template <typename T> int GetSpecialParam(T & rP) const
		{
			rP.Init(0, 0);
			int    ok = 1;
			PPBaseFilt * p_base_filt = 0;
			SBuffer _param(Param); // Функция должна быть const и дабы не менять состояние Param при чтении просто сделаем его дубликат.
			const T pattern_filt;
			if(_param.GetAvailableSize()) {
				THROW(PPView::ReadFiltPtr(_param, &p_base_filt));
				if(p_base_filt) {
					THROW(p_base_filt->GetSignature() == pattern_filt.GetSignature());
					rP = *static_cast<T *>(p_base_filt);
				}
			}
			else
				ok = -1;
			CATCHZOK
			delete p_base_filt;
			return ok;
		}
		bool   CanApplyPrepareAheadOption() const;
		bool   CanApplyNotifyFlag(long f) const;
		enum {
			fResultPersistent = 0x0001,
			fPrepareAhead     = 0x0002, // @v11.4.6 Данные команды готовятся заранее чтобы при запросе от клиента отдать их максимально быстро.
				// Эта опция не может быть применена в случае, если параметры команды содержат ссылку на контекстные данные!
				// Поскольку не ясно какой именно результат должен быть подготовлен заранее.
			fNotify_ObjNew    = 0x0004, // @v11.5.9 Опция извещения: извещать о новых объектах
			fNotify_ObjUpd    = 0x0008, // @v11.5.9 Опция извещения: извещать об измененных объектах
			fNotify_ObjStatus = 0x0010, // @v11.5.9 Опция извещения: извещать об изменении статусов объектов
			fPassive          = 0x0020  // @v11.9.12 Команда является пассивной (не загружается на устройства)  

		};
		int32  Ver;                 //
		int32  BaseCmdId;           //
		int32  Flags;               //
		S_GUID Uuid;                //
		int32  ObjTypeRestriction;  //
		int32  ObjGroupRestriction; //
		int32  ObjIdRestriction;    // @v11.2.6
		int32  ResultExpiryTimeSec; // @v11.2.5 Период истечения срока действия результата в секундах. (<=0 - undefined)
			// Если ResultExpiryPeriodSec то клиент может пользоваться результатом запроса в течении этого времени без
			// повторного обращения к сервису.
		SString DbSymb;             // Символ базы данных
		SString Name;               // utf8
		SString ViewSymb;           //
		SString Description;        // utf8 Подробное описание команды
		SString Image;              // Ссылка на изображение, ассоциированное с командой
		SBuffer Param;              // Фильтр для ViewSymb и(или) ViewId
			// sqbcPersonEvent: PPPsnEventPacket
			// sqbcRsrvOrderPrereq: int32 id of StyloPalm
			// 
		PPNamedFilt::ViewDefinition Vd;
	};
	//
	// Descr: Возвращает регулярное имя файла, в котором хранится список команд
	//
	static int GetCanonicalFileName(SString & rFileName);
	static SString & GetBaseCommandName(int cmdId, SString & rBuf);
	//
	// Descr: Возвращает копию полного списка команд, управляемого глобальным объектом класса SCachedFileEntity.
	//
	static bool  GetFullList(const char * pDbSymb, StyloQCommandList & rList);
	StyloQCommandList();
	StyloQCommandList(const StyloQCommandList & rS);
	~StyloQCommandList();
	StyloQCommandList & FASTCALL operator = (const StyloQCommandList & rS);
	bool   FASTCALL operator == (const StyloQCommandList & rS) const { return IsEq(rS); }
	StyloQCommandList & Z();
	bool   FASTCALL Copy(const StyloQCommandList & rS);
	bool   FASTCALL IsEq(const StyloQCommandList & rS) const;
	Item * CreateNewItem(uint * pIdx);
	uint   GetCount() const;
	Item * Get(uint idx);
	const  Item * GetC(uint idx) const;
	const  Item * GetByUuid(const S_GUID & rUuid) const;
	int    Set(uint idx, const Item * pItem);
	//
	// Descr: Верифицирует список команд на предмет логических ошибок.
	//   Если pSelectedItem != 0, то фокусирует проверку на этом элементе.
	//   Кроме того, проверяется принадлежность элемента pSelectedItem списку.
	// Returns:
	//   0 - error
	//  !0 - проверка пройдена успешно
	//
	bool   Validate(const Item * pSelectedItem) const;
	int    Store(const char * pFileName) const;
	bool   Load(const char * pDbSymb, const char * pFileName);
	StyloQCommandList * CreateSubListByContext(PPObjID oid, int baseCmdId, bool skipInternalCommands) const;
	StyloQCommandList * CreateSubListByDbSymb(const char * pDbSymb, int baseCmdId) const;
	bool   GetSubListByDbSymb(const char * pDbSymb, int baseCmdId, StyloQCommandList & rList) const;
	//
	// Descr: Формирует json-объект по списку команд для передачи клиенту.
	//   Если pParent == 0, то формирует автономный безымянный json-объект,
	//   в противном случае вставляет объект с именем pName в родительский json-контейнер.
	//   Если pParent != 0, то для аргумента pName должно выполнятся условие isempty(pName) == false
	// ARG(expirationSec IN): если > 0, то в json-описание вставляется параметр expiration_period_sec=expirationSec.
	// Returns:
	//   0 - error
	//   !0 - Если pParent == 0, то возвращает указатель на сформированный json-объект, который должен быть
	//      разрушен вызывающей функцией.
	//      Если же pParent != 0, то возвращает pParent который, естественно, полностью управляется вызывающей функцией.
	//
	static SJson * CreateJsonForClient(const StyloQCore::StoragePacket & rOwnPack, const StyloQCommandList * pSelf, SJson * pParent, const char * pName, long expirationSec);
private:
	SString DbSymbRestriction;
	TSCollection <Item> L;
};

class StyloQProtocol : public PPJobSrvProtocol {
public:
	StyloQProtocol();
	StyloQProtocol & Z();
	enum {
		psubtypeForward           = 0,
		psubtypeForwardError      = 1,
		psubtypeReplyOk           = 2,
		psubtypeReplyError        = 3,
		psubtypeIntermediateReply = 4  // @v11.2.12 Промежуточный ответ сервера с просьбой подождать либо отчет о ходе выполнения процесса
	};
	int    StartWriting(int cmdId, int subtype);
	int    FinishWriting(const SBinaryChunk * pCryptoKey);
	int    Read(SBuffer & rMsgBuf, const SBinaryChunk * pCryptoKey);
	int    Read(PPMqbClient::Message & rMsg, const SBinaryChunk * pCryptoKey);
	int    ReadMime64(const SString & rSrcMime64, const SBinaryChunk * pCryptoKey);
	static int Test();

	SSecretTagPool P;
};

//
// Descr: Информация о BLOB'е используемая в проекте Stylo-Q
//
struct StyloQBlobInfo {
	StyloQBlobInfo();
	StyloQBlobInfo & Z();
	PPObjID Oid;        // Идентификатор объекта данных, которому соответствует BLOB
	uint   BlobN;       // [1..] Номер BLOB'а в "обойме" объекта Oid
	SFileFormat Ff;     // Идентификатор формата данных  
	int    HashAlg;     // Хэш-алгоритм, используемый для расчета хэша BLOB'а
	SBinaryChunk Hash;  // Хэш BLOB'а
	SString SrcPath;    // Путь файла, в котором находится оригинальная версия BLOB'а
	SString Signature;  // Сигнатура, используемая для идентификации BLOB'а сервисами и клиентами Stylo-Q
};

class PPStyloQInterchange {
public:
	static int64 EvaluateExpiryTime(int expiryPeriodSec);
	static bool  IsExpired(int64 expiration);

	struct ServerParamBase {
		ServerParamBase();
		ServerParamBase & Z();
		enum {
			capRegistrationAllowed = 0x0001,
			capVerifiableFaceOnly  = 0x0002,
			capAnonymFaceDisabled  = 0x0004
		};
		uint32 Capabilities; // capXXX
		SBinaryChunk SvcIdent;
		SBinaryChunk LoclAddendum; // @v11.2.3 Специальное дополнение, индицирующее локальный сервер (то есть, ассоциированный с конкретной машиной или сеансом)
		SString AccessPoint;
		SString MqbAuth;   // @v11.2.8 ???
		SString MqbSecret; // @v11.2.8 ???
	};
	struct RunServerParam : public ServerParamBase {
		RunServerParam();
		RunServerParam & Z();
		uint   MakeMqbQueueIdent(SBinaryChunk & rResult) const;
		PPMqbClient::InitParam MqbInitParam;
	};
	struct InterchangeParam : public ServerParamBase {
		InterchangeParam();
		InterchangeParam(const RunServerParam & rRsP);
		InterchangeParam & Z();
		//
		// Descr: Очищает только CommandJson и Blob. Компоненты родительского класса остаются нетронутыми.
		//   Функция нужна для повторного обращения к тому же сервису.
		//
		void   ClearParam();
		bool   FASTCALL IsEq(const InterchangeParam & rS) const;

		SString CommandJson;
		SBinaryChunk Blob; // @v11.3.8
	};
	struct DocumentDeclaration {
		DocumentDeclaration(const StyloQCommandList::Item * pCmdItem, const char * pDl600Symb);
		DocumentDeclaration & Z();
		int    FromJsonObject(const SJson * pJsObj);
		int    FromJson(const char * pJson);
		SJson * ToJsonObject() const;
		int    ToJson(SString & rResult) const;
		LDATETIME Dtm;
		uint   ActionFlags;
		int32  ResultExpiryTimeSec; // mirror of StyloQCommandList::Item::ResultExpiryTimeSec
		SString Type;
		SString Format;
		SString DisplayMethSymb;
		SString ViewSymb;
		SString Dl600Symb;
	};
	struct Document {
		struct CliStatus {
			static int GetFromBill(const TSVector <CliStatus> & rList, const PPBillPacket & rBp);
			static int SetToBill(const TSVector <CliStatus> & rList, int surrId, PPBillPacket & rBp);

			CliStatus();
			bool   IsValuable() const { return ((StatusID || (Flags & fBillFlagDeclined)) && !isempty(NameUtf8)); }
			CliStatus & Z();
			SJson * ToJsonObj() const;
			bool   FromJsonObj(const SJson * pJs);
			//
			// Descr: Зарезервированные варианты статусов, проецируемые на клиента
			//
			enum {
				rUndef    = 0,
				rAccepted = 1,
				rRejected = 2
			};
			enum {
				fBillFlagDeclined = 0x0001 // Вместо (или одновременно) указания статуса, документу присваивается флаг BILLF2_DECLINED
			};
			long   SurrogateId;  // Суррогатный идентификатор элемента в списке, передаваемом клиенту. Если на клиенте устанавливается 
				// соответствующее значение, то сервису передается информация для смены статуса.
			PPID   StatusID;
			long   ReservedCase; // DocStatus::rXXX
			long   Flags;
			uint8  Reserve[32];
			char   NameUtf8[128]; // utf8 Наименование для клиента 
		};
		Document();
		Document & Z();
		int    FromBillPacket(const PPBillPacket & rS, const TSVector <CliStatus> * pCliStatusList, PPIDArray * pGoodsIdList);
		int    FromCCheckPacket(const CCheckPacket & rS, PPID posNodeID, PPIDArray * pGoodsIdList);
		int    FromTSessionPacket(const TSessionPacket & rS, PPIDArray * pGoodsIdList); // @v11.6.5
		int    FromJsonObject(const SJson * pJsObj);
		int    FromJson(const char * pJson);
		SJson * ToJsonObject() const;
		int    ToJson(SString & rResult) const;
		SString & MakeCodeString(SString & rBuf) const;
		static uint  IncomingListActionsFromString(const char * pStr);
		static SString & IncomingListActionsToString(uint actionFlags, SString & rBuf);
		struct LotExtCode {
			LotExtCode();
			int    Flags;
			int    BoxRefN;
			char   Code[256];
		};
		//
		// Так как одна строка может иметь более одного набора значений {qtty, cost, price},
		// то выделяем такой набор в отдельную структуру.
		//
		struct ValuSet {
			ValuSet();
			double Qtty;
			double Cost;
			double Price;
			double Discount;
		};
		struct __TransferItem {
			//
			// Descr: Битовые флаги, выставляемые в поле Flags
			//
			enum {
				// Следующие 5 флагов - проекция флагов CCheckPacket::LineExt::fXXX
				// Хотя их значения совпадают с прототипами, это - не существенно и для других флагов может быть не так.
				fCcGroup         = 0x0001,
				fCcModifier      = 0x0002,
				fCcPartOfComplex = 0x0004,
				fCcQuotedByGift  = 0x0008,
				fCcFixedPrice    = 0x0010,
				fHasAcceptance   = 0x0020, // @v11.7.0 Флаг нужен для правильной обработки
					// документа на стороне сервиса: если установлен, то считается, что SetAccepted инициализирован
					// даже если SetAccepted.Qtty == 0. На стороне клиента такой проблемы нет поскольку
					// неинициализированный SetAccepted == null
			};
			__TransferItem();
			int    RowIdx;  // [1..], 0 - undefined
			int    GoodsID; // service-domain-id
			int    UnitID;  // service-domain-id
			int    Flags;
			int    CcQueue; // @v11.5.2 Проекция поля CCheckPacket::LineExt::Queue
			SString Serial; // @v11.5.2
			ValuSet Set;
			ValuSet SetAccepted; // @v11.4.8 Набор величин, с которыми согласна принимающая сторона (например при инвентаризации, приемке приходного документа и т.д.)
			TSVector <LotExtCode> XcL;
		};
		struct BookingItem {
			BookingItem();
			int    RowIdx; // [1..], 0 - undefined
			int    PrcID;
			int    GoodsID;
			int    Flags;
			LDATETIME ReqTime;
			int    EstimatedDurationSec;
			ValuSet Set;
			SString Memo;
		};
		int64  ID;
		LDATETIME CreationTime;
		LDATETIME Time;
		LDATETIME DueTime;
		SGeoPosLL CreationGeoLoc; // @v11.6.2
		int    InterchangeOpID; // @v11.4.9 OpID-->InterchangeOpID
		int    SvcOpType; // @v11.7.2 Тип операции, определенный на стороне сервиса.
			// Это значение - только для входящих (по отношению к клиенту) документов.
			// if SvcOpID == 0 then SvcOpType == 0
		int    SvcOpID;   // @v11.4.9 Ид вида операции, определенный на стороне сервиса.
			// Если клиент создает новый документ (в смысле PPObjBill), но не знает точный ид вида операции на
			// стороне сервиса, то определяет InterchangeOpID.
		int    ClientID;  // service-domain-id
		int    DlvrLocID; // service-domain-id
		int    AgentID;   // @v11.4.6 service-domain-id
		int    QuotKindID; // @v11.7.1 "quotkindid"
		int    PosNodeID; // @v11.4.6 service-domain-id
		int    StatusSurrId; // @v11.5.1 Специальное суррогатное значение, идентифицирующее клиентский статус документа.
			// Значение ссылается на поле BusinessEntity.DocStatus.SurrId.
		double Amount;    // @v11.3.10 Номинальная сумма документа
		SString Code;
		SString BaseCurrencySymb; // @v11.3.12
		SBinaryChunk SvcIdent;
		S_GUID Uuid; // Уникальный идентификатор, генерируемый на стороне эмитента
		S_GUID OrgCmdUuid; // @v11.4.0 Идентификатор команды сервиса, на основании данных которой сформирован документ.
			// Поле нужно для сопоставления сохраненных документов с данными сервиса.
		SString Memo;
		TSCollection <__TransferItem> TiList;
		TSCollection <BookingItem> BkList; // @v11.3.6
		TSVector <LotExtCode> VXcL; // Валидирующий контейнер спецкодов. Применяется для проверки кодов, поступивших с документом в XcL
	};
	//
	// Descr: Так получилось, что эта структура стала часто используемой в качестве сборщика важных параметров
	//  при подготовке данных.
	//
	struct Stq_CmdStat_MakeRsrv_Response {
		static void RegisterOid(Stq_CmdStat_MakeRsrv_Response * pThis, PPObjID oid);
		static void RegisterBlobOid(Stq_CmdStat_MakeRsrv_Response * pThis, PPObjID oid);

		Stq_CmdStat_MakeRsrv_Response();
		uint   GoodsCount;
		uint   GoodsGroupCount;
		uint   BrandCount;
		uint   ClientCount;
		uint   DlvrLocCount;
		uint   PrcCount; // @v11.3.8
		PPObjIDArray OidList; // @v11.4.7 Список объектов, обработанных при подготовке данных
		PPObjIDArray BlobOidList; // @v11.3.8 Список объектов, имеющих blob'ы, обработанных при подготовке данных
	};
	//
	// Descr: intermediate-структура для представления уведомления от сервиса к клиенту.
	//
	class SvcNotification {
	public:
		SvcNotification();
		int    GenerateIdent();
		SJson * ToJson() const;
		
		binary160 Ident;
		LDATETIME EventOrgTime;
		LDATETIME EventIssueTime;
		LDATETIME ObjNominalTime; // Номинальная метка времени объекта. Необходима для адекватной сортировки. Для документа это - номинальная дата документа.
		S_GUID CmdUuid; // @v11.5.11 Этот uuid возвращается клиенту (он запрашивает извещения в привязке к команде) для того, чтобы он мог правильно обрабатывать
			// клики по извещениям.
		int    EventId;
		PPObjID Oid;
		SString Message;
		int    MessageId;
	};

	PPStyloQInterchange();
	explicit PPStyloQInterchange(StyloQCore * pStQC);
	~PPStyloQInterchange();
	//
	// Descr: Высокоуровневая функция, реализующая полный раунд клиентского запроса к сервису.
	//
	int    DoInterchange(InterchangeParam & rParam, SSecretTagPool & rReply);
	//
	// Descr: Возвращает номинальное время жизни сессии в секундах.
	//   Клиент и сервис при установке сессии обмениваются своими значениями
	//   номинального времени жизни сессии и оба принимают минимальное значение
	//   из двух. Если один из участников передал нулевое или пустое значение,
	//   то принимается величина второго участника, если же оба участника
	//   передали нулевое значение, то время жизни сессии принимается равной
	//   значению по умолчанию (24 * 60 * 60, то есть сутки).
	//
	uint   GetNominalSessionLifeTimeSec() const;
	int    RunStyloQLocalMqbServer(RunServerParam & rP, const DbLoginBlock * pDlb);
	static int StopStyloQServer();
	//
	// Descr: Флаги функции SetupMqbParam
	//
	enum {
		smqbpfInitAccessPoint = 0x0001, // Инициализировать
		smqbpfLocalMachine    = 0x0002, // Локальный сервер, ассоциированный с компьютером
		smqbpfLocalSession    = 0x0004, // Локальный сервер, ассоциированный с сеансом
			// Flags smqbpfLocalMachine and smqbpfLocalSession mutualy exclusive
	};

	static int SetupMqbParam(const StyloQCore::StoragePacket & rOwnPack, long flags, PPStyloQInterchange::RunServerParam & rP);
	//
	// Descr: Функция реализует первоначальную генерацию необходимых ключей
	//   и значений с сохранением их в базе данных.
	// Returns:
	//   >0 - функция успешно выполнила первоначальную инициализацию
	//   <0 - инсталляция клиента/сервера уже инициализирована
	//    0 - error
	//
	int    SetupPeerInstance(PPID * pID, int use_ta);
	//
	// Descr: Публикация приглашения сервисом
	//
	int    MakeInvitation(const InterchangeParam & rSource, SString & rInvitationData);

	enum {
		fsksError = 0,      // Ошибка
		fsksNewEntry,       // Запись с идентификатором rForeignIdent не найдена
		fsksNewSession,     // Запись с идентификатором rForeignIdent найдена, но требуется инициация новой сессии
		fsksSessionById,    // Найдена сессия по идентификатору rForeignIdent
		fsksSessionByCliId, // Найдена сессия, соответствующая клиентскому ид rForeignIdent
		fsksSessionBySvcId  // Найдена сессия, соответствующая серверному ид rForeignIdent
	};

	int    FetchSessionKeys(int kind, SSecretTagPool & rSessCtx, const SBinaryChunk & rForeignIdent);
	//
	// Descr: Генерирует публичный и приватный ключи для обмена с контрагентом с целью формирования общего секрета шифрования //
	//   В случае успеха функция в аргумент rSessCtx заносит атрибуты SSecretTagPool::tagSessionPrivateKey и SSecretTagPool::tagSessionPublicKey.
	//   Никаких исходных данных в rSessCtx функция не требует.
	// Returns:
	//   >0 - success
	//    0 - error
	//
	int    KexGenerateKeys(SSecretTagPool & rSessCtx, BIGNUM * DebugPubX, BIGNUM * DebugPubY);
	int    KexGenerageSecret(SSecretTagPool & rSessCtx, const SSecretTagPool & rOtherCtx);

	class RoundTripBlock {
	public:
		RoundTripBlock();
		RoundTripBlock(const SBinaryChunk * pSvcIdent, const SBinaryChunk * pSvcLoclAddendum, const char * pSvcAccsPoint);
		~RoundTripBlock();

		SSecretTagPool Other; // Блок параметров сервиса, к которому осуществляется запрос
		SSecretTagPool Sess;  // Блок параметров сессии
		StyloQCore::StoragePacket StP; // Блок собственных данных, извлеченных из хранилища
		PPMqbClient * P_Mqbc; // Экземпляр клиента MQ уже "заряженный" на прослушку регулярной очереди от визави
		PPMqbClient::RoutingParamEntry * P_MqbRpe; // Параметры маршрутизации при использовании брокера MQ
		SlSRP::Verifier * P_SrpV; // @v11.2.0 SRP-верификатор для серверной части. При асинхронной обработке
			// он нужен для обслуживания процесса верификации клиента в несколько заходов запрос-ответ.
		PPID   InnerSvcID;
		PPID   InnerSessID;
		PPID   InnerCliID;
		uint   State;
		S_GUID Uuid; // Идентификатор текущего сеанса обмена. Не путать с сессией, которая может сохраняться:
			// сеанс обмена обрабатывает одинарную серию запросов-ответов. Идентификатор нужен для правильной
			// обработки сообщений при асинхронном режиме.
		InetUrl Url; // Для клиента. Инициализируется в методе InitRoundTripBlock() на основании
			// значения SSecretTagPool::tagSvcAccessPoint в Other.
		int32  LastRcvCmd; // Последняя полученная команда. Необходимо для отслеживания состояний //
		int32  LastSndCmd; // Последняя отправленная команда. Необходимо для отслеживания состояний //
	};
	int    InitRoundTripBlock(RoundTripBlock & rB);
	//
	// Descr: Устанавливает параметры регулярного обмена для RoundTripBlock.
	//
	int    SetRoundTripBlockReplyValues(RoundTripBlock & rB, PPMqbClient * pMqbc, const PPMqbClient::RoutingParamEntry & rRpe);
	//
	// Returns:
	//   0 - error
	//   !0 - статус, который был возвращен внутренним вызовом FetchSessionKeys
	//
	int    KexServiceReply(SSecretTagPool & rSessCtx, const SSecretTagPool & rCli, BIGNUM * pDebugPubX, BIGNUM * pDebugPubY);
	//
	// Descr: Акцепт приглашения сервиса клиентом
	//
	int    AcceptInvitation(const char * pInvitationData, InterchangeParam & rInv);
	int    Registration_ClientRequest(RoundTripBlock & rB);
	//
	// ARG(pCliPack OUT): Если pCliPack != 0, то по этому адресу присваивается пакет клиента.
	//
	int    Registration_ServiceReply(const RoundTripBlock & rB, const StyloQProtocol & rPack, StyloQCore::StoragePacket * pCliPack);
	int    KexClientRequest(RoundTripBlock & rB);
	int    Session_ClientRequest(RoundTripBlock & rB);
	int    Verification_ClientRequest(RoundTripBlock & rB);
	int    SearchSession(const SBinaryChunk & rOtherPublic, StyloQCore::StoragePacket * pPack);
	int    Command_ClientRequest(RoundTripBlock & rB, const char * pCmdJson, const SBinaryChunk * pBlob, SSecretTagPool & rReply);
	int    GetOwnPeerEntry(StyloQCore::StoragePacket * pPack);
	int    SearchGlobalIdentEntry(int kind, const SBinaryChunk & rIdent, StyloQCore::StoragePacket * pPack);
	//
	// Descr: Высокоуровневая процедура, реализующая регистрацию или обновление собственных данных
	//   у сервиса-медиатора.
	//
	int    ServiceSelfregisterInMediator(const StyloQCore::StoragePacket & rOwnPack, SysJournal * pSjOuter);
	//
	// Descr: Сохраняет в базе данных параметры сессии для того, чтобы в следующий раз можно было бы
	//   быстро установить соединение с противоположной стороной.
	//   Пакет pPack (если не нулевой) должен содержать следующие теги:
	//     SSecretTagPool::tagSessionPublicKey
	//     SSecretTagPool::tagSessionPrivateKey
	//     SSecretTagPool::tagSessionPublicKeyOther
	//     SSecretTagPool::tagSessionSecret
	//     SSecretTagPool::tagSvcIdent || SSecretTagPool::tagClientIdent в зависимости от того, на какой стороне мы находимся //
	//   Ключом записи будет значение тега SSecretTagPool::tagSessionPublicKeyOther
	//
	int    StoreSession(PPID * pID, StyloQCore::StoragePacket * pPack, int use_ta);
	int    ExecuteInvitationDialog(InterchangeParam & rData);
	int    Dump();
	int    TestDatabase();
	int    TestClientInteractive(PPID svcID);

	typedef int (*ProcessCmdCallbackProc)(StyloQProtocol & rPack, void * pExtra);
	//
	// Descr: Головная функция, реализующая исполнение клиентских команд.
	// Returns:
	//  >0 - обработка завершена и клиенту следует отправить ответ (даже если обработка была с ошибкой)
	//   0 - функция отработала с ошибкой и клиенту ответ отсылать не следует.
	//
	int    ProcessCmd(const StyloQProtocol & rRcvPack, const SBinaryChunk & rCliIdent, const SBinaryChunk * pSessSecret, StyloQProtocol & rReplyPack,
		ProcessCmdCallbackProc intermediateReplyProc, void * pIntermediateReplyExtra);
	//
	SlSRP::Verifier * InitSrpVerifier(const SBinaryChunk & rCliIdent, const SBinaryChunk & rSrpS, const SBinaryChunk & rSrpV, const SBinaryChunk & rA, SBinaryChunk & rResultB) const;
	SlSRP::Verifier * CreateSrpPacket_Svc_Auth(const SBinaryChunk & rMyPub, const SBinaryChunk & rCliIdent, const SBinaryChunk & rSrpS,
		const SBinaryChunk & rSrpV, const SBinaryChunk & rA, StyloQProtocol & rP);
	int    MakeIndexingRequestCommand(const StyloQCore::StoragePacket * pOwnPack, const StyloQCommandList::Item * pCmd, long expirationSec, 
		S_GUID & rDocUuid, SString & rResult, Stq_CmdStat_MakeRsrv_Response * pStat);
	//
	// Descr: Флаги функции GetBlobInfo
	//
	enum {
		gbifSignatureOnly = 0x0001 // Вызывающей функции нужна только сигнатура blob'а (не надо считать хэш и всякие иные сложные вещи)
	};
	bool   GetBlobInfo(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, uint flags, StyloQBlobInfo & rInfo, SBinaryChunk * pBlobBuf) const;
	bool   FetchBlobSignature(const SBinaryChunk & rOwnIdent, PPObjID oid, uint blobN, SString & rSignature);
	static void  SetupMqbReplyProps(const RoundTripBlock & rB, PPMqbClient::MessageProperties & rProps);
	static int   Edit_RsrvAttendancePrereqParam(StyloQAttendancePrereqParam & rParam);
	static int   Edit_IndexingParam(StyloQIndexingParam & rParam);
	static int   Edit_GoodsInfoParam(StyloQGoodsInfoParam & rParam);
	static int   Edit_IncomingListParam(StyloQIncomingListParam & rParam);
	static int   Edit_RsrvDocumentPrereqParam(StyloQDocumentPrereqParam & rParam);
	static int   Edit_PersonEventParam(StyloQPersonEventParam & rParam);
	static int   Edit_TestCmdParam(StyloQTestCmdParam & rParam); // @v12.3.1
	//
	// Descr: Отправляет одному из медиаторов Stylo-Q запрос на индексацию данных из всех
	//   баз данных, которые содержат сервисы Stylo-Q.
	// ARG(useCurrentSession IN): отладочный параметр. Если true, то запрос отправляется только
	//   от той базы данных, в которой авторизован текущий сеанс.
	//
	static int   ExecuteIndexingRequest(bool useCurrentSession);
	//
	// Descr: Вызывает функции предварительного построения данных для команд, у которых
	//   задан признак StyloQCommandList::Item::fPrepareAhead.
	// ARG(useCurrentSession IN): отладочный параметр. Если true, то запрос отправляется только
	//   от той базы данных, в которой авторизован текущий сеанс.
	//
	static int   PrepareAhed(bool useCurrentSession);
	static int   GetBlobStoragePath(SString & rBuf);
	//
	// Descr: Имитирует исполнение команды с выводом данных в каталог OUT
	// 
	int    Debug_Command(const StyloQCommandList::Item * pCmd); // @debug
	
	static const uint InnerBlobN_Face;
private:
	struct Stq_ReqBlobInfoEntry : public StyloQBlobInfo {
		Stq_ReqBlobInfoEntry();
		Stq_ReqBlobInfoEntry & Z();
		bool  Missing;       // При получении ответа от медиатора true означает, что у медиатора нет такого blob'а
		bool  RepDiffHash;   // При получении ответа от медиатора, если у медиатора хэш blob'а отличается от нашего, то это поле устанавливается в true  
		uint8 Reserve[2];    // @alignment
	};
	class Stq_ReqBlobInfoList : public TSCollection <Stq_ReqBlobInfoEntry> {
	public:
		Stq_ReqBlobInfoList();
		bool   SearchSignature(const char * pSignature, uint * pPos) const;
		SJson * MakeRequestInfoListQuery() const;
		bool   ParseRequestInfoListReply(const SJson * pJs);
	};
	struct InnerGoodsEntry { // @flat
		explicit InnerGoodsEntry(PPID goodsID);
		InnerGoodsEntry & Z();

		enum { // Copy of RetailGoodsInfo
			fDisabledQuot    = 0x0001, // Котировка QuotKindUsedForPrice является блокирующей - продажа товара запрещена.
			fDisabledExtQuot = 0x0002, // Котировка
			//
			fNoDiscount      = 0x0004, // OUT (устанавливается в результате вычислений) - на товар не распространяется скидка
			fEgais           = 0x0008, // @v11.5.0 Товар является алкогольным, попадающим под маркировку егаис
			fDontShowRest    = 0x0010  // @11.6.4 Специальный флаг, используемые при экспорте данных для индикации того, что блокировать 
				// отображение остатков для товарной позиции
		};
		PPID   GoodsID;
		long   Flags;
		int    ChZnMarkCat;          // @v11.5.0 GTCHZNPT_XXX Категория маркировки честный знак
		LDATE  Expiry;               // Copy of RetailGoodsInfo
		LDATETIME ManufDtm;
		PPID   QuotKindUsedForPrice; // Вид котировки, использованной для получения цены Price.
			// Данное поле гарантированно имеет смысл только после вызова PPObjGoods::GetRetailGoodsInfo
		PPID   QuotKindUsedForExtPrice; // Вид котировки из блока RetailPriceExtractor::ExtQuotBlock, примененный для формиования ExtPrice.
		double Rest;
		double Cost;
		double Price;         // Цена реализации
		double ExtPrice;      // Цена по дополнительной котировке
		double UnitPerPack;
		double OrderQtyMult;
		double OrderMinQty;
		double Brutto;        // @v11.4.5
	};	
	int    AddImgBlobToReqBlobInfoList(const SBinaryChunk & rOwnIdent, PPObjID oid, Stq_ReqBlobInfoList & rList);
	int    ExtractSessionFromPacket(const StyloQCore::StoragePacket & rPack, SSecretTagPool & rSessCtx);
	int    StqInsertIntoJs_BaseCurrency(SJson * pJs); // @v11.3.12
	//
	// Descr: Флаги семейства функция MakeObjJson_XXX
	//
	enum {
		mojfForIndexing  = 0x0001, // Формировать объект исходя из того, что результат предназначен для индексации
		mojfHierarchical = 0x0002  // @v11.6.4
	};
	SJson * MakeObjJson_OwnFace(const StyloQCore::StoragePacket & rOwnPack, uint flags);
	SJson * MakeObjJson_Goods(const SBinaryChunk & rOwnIdent, const PPGoodsPacket & rPack, const InnerGoodsEntry * pInnerEntry, uint flags, 
		const StyloQGoodsInfoParam * pGi, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjArrayJson_Uom(const SBinaryChunk & rOwnIdent, PPIDArray & rIdList, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjJson_GoodsGroup(const SBinaryChunk & rOwnIdent, const Goods2Tbl::Rec & rRec, uint flags, Stq_CmdStat_MakeRsrv_Response * pStat);
	//
	// Note: Функция выполнит операция sortAndUndup над rIdList
	//
	SJson * MakeObjArrayJson_GoodsGroup(const SBinaryChunk & rOwnIdent, PPIDArray & rIdList, bool hierarchical, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjJson_Brand(const SBinaryChunk & rOwnIdent, const PPBrandPacket & rPack, uint flags, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjArrayJson_Brand(const SBinaryChunk & rOwnIdent, PPIDArray & rIdList, uint flags, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjJson_Prc(const SBinaryChunk & rOwnIdent, const ProcessorTbl::Rec & rRec, uint flags, Stq_CmdStat_MakeRsrv_Response * pStat);
	SJson * MakeObjJson_Address(PPID addrID);
	int    MakeInnerGoodsList(const PPIDArray & rGoodsIdList);
	int    MakeDocDeclareJs(const StyloQCommandList::Item & rCmdItem, const char * pDl600Symb, SString & rDocDeclaration);
	//
	// Descr: Блок параметров функции MakePrcJsList()
	//
	struct MakePrcJsListParam {
		MakePrcJsListParam(const SBinaryChunk & rBcOwnIdent);
		MakePrcJsListParam(const SBinaryChunk & rBcOwnIdent, const StyloQAttendancePrereqParam & rOuterParam);
		MakePrcJsListParam(const SBinaryChunk & rBcOwnIdent, const StyloQIncomingListParam & rOuterParam);
		const  SBinaryChunk & R_BcOwnIdent;
		PPID   QuotKindID;
		PPID   LocID;
		int    MaxScheduleDays;
	};

	int    MakePrcJsList(const MakePrcJsListParam & rParam, SJson * pJsObj, const PPIDArray & rPrcList, PPObjTSession & rTSesObj, Stq_CmdStat_MakeRsrv_Response * pStat);
	//
	// Descr: Флаги функций ProcessCommand_XXX
	//
	enum {
		prccmdfDebugOutput     = 0x0001, // Команда выполняется в отладочном режиме для тестирования вывода
		prccmdfReqNotification = 0x0002  // Запрос извещений, связанных с командой
	};
	int    GetPrcList(const StyloQCore::StoragePacket & rCliPack, const StyloQIncomingListParam & rParam, PPObjTSession & rTSesObj, PPIDArray & rList);
	int    ProcessCommand_PersonEvent(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const SJson * pJsCmd, const SGeoPosLL & rGeoPos);
	int    ProcessCommand_Report(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const SGeoPosLL & rGeoPos, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_RsrvOrderPrereq(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_RsrvAttendancePrereq(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const SGeoPosLL & rGeoPos, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_RsrvIndoorSvcPrereq(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_IncomingListOrder(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const LDATETIME * pIfChangedSince, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_IncomingListCCheck(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const LDATETIME * pIfChangedSince, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_IncomingListTSess(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, const LDATETIME * pIfChangedSince, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    ProcessCommand_RequestNotificationList(const StyloQCommandList::Item & rCmdItem, const StyloQCore::StoragePacket & rCliPack, SJson * pJsArray);
	//
	// Descr: Обрабатывает команду создания документа по инициативе клиента.
	// Returns:
	//    !0 - json-объект для возврата клиенту
	//     0 - error
	//    //PPOBJ_BILL - функция успешно завершена. идентификатор созданного или уже существующего документа присвоен по указателю pResultID.
	//    //PPOBJ_TSESSION - функция успешно завершена. идентификатор созданной или уже существующей техсессии присвоен по указателю pResultID.
	//    //0 - error
	//
	SJson * ProcessCommand_PostDocument(const SBinaryChunk & rOwnIdent, const StyloQCore::StoragePacket & rCliPack, const SJson * pDeclaration, const SJson * pDocument, PPID * pResultID);
	SJson * ProcessCommand_RequestDocumentStatusList(const SBinaryChunk & rOwnIdent, const StyloQCore::StoragePacket & rCliPack, const SJson * pCommand);
	SJson * MakeRsrvAttendancePrereqResponse_Prc(const SBinaryChunk & rOwnIdent, PPID prcID, PPID mainQuotKindID, PPObjTSession & rTSesObj, long maxScheduleDays, 
		LAssocArray * pGoodsToPrcList, Stq_CmdStat_MakeRsrv_Response * pStat);
	//
	// Returns:
	//   >0 - идентификатор созданного документа (PPOBJ_STYLOQBINDERY)
	//    0 - error
	//
	PPID   ProcessCommand_IndexingContent(const StyloQCore::StoragePacket & rCliPack, const SJson * pDocument, SString & rResult);
	int    ProcessCommand_StoreBlob(const StyloQCore::StoragePacket & rCliPack, const SJson * pDocument, const SBinaryChunk & rBlob, SString & rResult);
	SJson * ProcessCommand_GetBlob(const StyloQCore::StoragePacket & rCliPack, const SJson * pDocument, SBinaryChunk & rBlob);
	SJson * ProcessCommand_ReqBlobInfoList(const StyloQCore::StoragePacket & rCliPack, const SJson * pDocument);
	int    ProcessCommand_Search(const StyloQCore::StoragePacket & rCliPack, const SJson * pDocument, SString & rResult, SString & rDocDeclaration);
	SJson * ProcessCommand_GetGoodsInfo(const SBinaryChunk & rOwnIdent, const StyloQCore::StoragePacket & rCliPack, const StyloQCommandList::Item * pGiCmd, PPID goodsID, const char * pGoodsCode);
	int    ProcessCommand_DebtList(const StyloQCommandList::Item & rCmdItem, const SJson * pJsCmd, const StyloQCore::StoragePacket & rCliPack, SString & rResult, SString & rDocDeclaration, uint prccmdFlags);
	int    Helper_PrepareAhed(const StyloQCommandList & rFullCmdList);
	bool   AmIMediator(const char * pCommand);
	SJson * MakeQuery_StoreBlob(const void * pBlobBuf, size_t blobSize, const SString & rSignature);

	struct MakeInnerGoodsEntryBlock {
		MakeInnerGoodsEntryBlock();
		~MakeInnerGoodsEntryBlock();
		int    Make(PPID goodsID, double cost, double price, double rest, double unitPerPack, InnerGoodsEntry & rItem);
		PPIDArray  GrpIdList;
		PPIDArray  BrandIdList;
		PPIDArray  UnitIdList;		
		PPObjGoods GObj;
		PPEgaisProcessor * P_Ep;
	};

	int    FetchPersonFromClientPacket(const StyloQCore::StoragePacket & rCliPack, PPID * pPersonID, bool logResult);
	int    FetchProcessorFromClientPacket(const StyloQCore::StoragePacket & rCliPack, PPID * pPrcID, bool logResult);
	int    AcceptStyloQClientAsPerson(const StyloQCore::StoragePacket & rCliPack, PPID personKind, PPID * pPersonID, int use_ta);
	int    QueryConfigIfNeeded(RoundTripBlock & rB);
	int    QuerySvcConfig(const SBinaryChunk & rSvcIdent, StyloQConfig &);
	int    Helper_DoInterchange(InterchangeParam & rParam, SSecretTagPool & rReply);
	int    Helper_ExecuteIndexingRequest(const StyloQCore::StoragePacket & rOwnPack, const TSCollection <StyloQCore::IgnitionServerEntry> & rMediatorList, const StyloQCommandList::Item * pCmdItem);
	int    StoreOidListWithBlob(const PPObjIDArray & rList);
	int    GetOidListWithBlob(PPObjIDArray & rList);
	int    MakeRsrvPriceListResponse_ExportClients(const SBinaryChunk & rOwnIdent, const StyloQDocumentPrereqParam & rParam, SJson * pJs, Stq_CmdStat_MakeRsrv_Response * pStat);
	int    MakeRsrvPriceListResponse_ExportGoods(const StyloQCommandList::Item & rCmdItem, const SBinaryChunk & rOwnIdent, const StyloQDocumentPrereqParam & rParam, SJson * pJs, Stq_CmdStat_MakeRsrv_Response * pStat);
	//
	// Descr: Флаги функции MakeRsrvIndoorSvcPrereqResponse_ExportGoods
	//
	enum {
		egpnfAdditionalIdListOnly = 0x0001 // Список товаров формировать только по набору идентификаторов pAdditionalIdList
	};
	int    MakeRsrvIndoorSvcPrereqResponse_ExportGoods(const SBinaryChunk & rOwnIdent, const PPSyncCashNode * pPack, 
		const PPIDArray * pAdditionalIdList, uint flags, SJson * pJs, Stq_CmdStat_MakeRsrv_Response * pStat);
	int    GetAndStoreClientsFace(const StyloQProtocol & rRcvPack, const SBinaryChunk & rCliIdent);
	//
	// Descr: Отправляет сообщение клиенту о том, что необходимо подождать результатов запроса в течении waitPeriodMs 
	//   с дополнительными опросами готовности в pollIntervalMs.
	//
	int    IntermediateReply(int waitPeriodMs, int pollIntervalMs, const SBinaryChunk * pSessSecret, ProcessCmdCallbackProc intermediateReplyProc, void * pIntermediateReplyExtra);
	SJson * ReplyGoodsInfo(const SBinaryChunk & rOwnIdent, const SBinaryChunk & rCliIdent, PPID goodsID, const char * pBarcode);
	bool   GetOwnIdent(SBinaryChunk & rOwnIdent, StyloQCore::StoragePacket * pOwnPack);
	//
	// Descr: Определяет вид операции, используемый для формирования документов заказа.
	//   Если параметр palmID != 0, то пытается извлечь вид операции из записи агентского устройства с этим идентификатором (PPObjStyloPalm)
	//
	int    GetContextualOpAndLocForOrder(const StyloQDocumentPrereqParam & rParam, PPID * pOpID, PPIDArray * pLocList);
	//
	// Descr: Возвращает дополнение для идентфикации локального (относящегося к машине или сеансу) сервера.
	// ARG(flag IN): Уточняет о какой локальности идет речь. Если flag == smqbpfLocalMachine то дополнение
	//   извлекается из реестра, если же flag == smqbpfLocalSession то в качестве дополнения используется GUID сессии SLIB.
	// Returns:
	//   GUID дополнения. Если возвращенный GUID оказался нулевым, то это - признак ошибки.
	//
	static S_GUID GetLocalAddendum(long flag/*smqbpfLocalMachine || smqbpfLocalSession*/);
public: // @debug временно
	//
	// Descr: Утилитная функция, отправляющая http запрос сервису.
	// ARG(rB IN):
	// ARG(rPack IN/OUT): Протокольный пакет для отправки. При успешном завершении ответ будет скопирован
	//   в этот же пакет.
	// Return:
	//   >0 - success
	//    0 - error
	//
	int    SendHttpQuery(RoundTripBlock & rB, StyloQProtocol & rPack, const SBinaryChunk * pCryptoKey);
private:
	SlSRP::User * InitSrpAuth(const SBinaryChunk & rIdent, const SBinaryChunk & rSecret) const;
	int    CreateSrpPacket_Cli_Auth(SlSRP::User * pU, const SBinaryChunk & rSvcIdent, const SBinaryChunk & rCliIdent, const SBinaryChunk & rSessPubKey, const SBinaryChunk * pSessSecret, StyloQProtocol & rP);
	int    CreateSrpPacket_Cli_Auth2(const SBinaryChunk & rM, const SBinaryChunk & rCliIdent, StyloQProtocol & rP, int * pSrpProtocolFault);
	int    CreateSrpPacket_Cli_HAMK(SlSRP::User * pU, const SBinaryChunk & rHamk, StyloQProtocol & rP, int * pSrpProtocolFault);
	int    CreateSrpPacket_Svc_Auth(StyloQProtocol & rP);
	int    LoadViewSymbList();
	StyloQCore * P_T;
	enum {
		stOuterStqC  = 0x0001, // Экземпляр использует внешний указатель на StyloQCore (не следует разрушать)
		stViewSymbListLoaded = 0x0002  // ViewSymbList и ViewDescrList загружены из ресурсов
	};
	uint   State;
	StrAssocArray ViewSymbList;  // Список ассоциация {ViewID->ViewSymb}
	StrAssocArray ViewDescrList; // Список ассоциация {ViewID->ViewDescription}
};
//
//
//
class StyloQPersonEventParam { // @v11.6.2 not a child of PPBaseFilter
public:
	StyloQPersonEventParam();
	StyloQPersonEventParam(const StyloQPersonEventParam & rS);
	StyloQPersonEventParam & FASTCALL operator = (const StyloQPersonEventParam & rS);
	StyloQPersonEventParam & Z();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	const  uint32 Signature; // PPConst::Signature_StyloQPersonEventParam
	uint32 Flags;
	double MaxGeoDistance;
	//
	PPPsnEventPacket PePack;
	struct FlatBlock {
		uint8  Reserve[64];
	} Fb;
};
//
//
//
class StyloQDocumentPrereqParam : public PPBaseFilt {
public:
	static StyloQDocumentPrereqParam * Read(SBuffer & rBuf);
	StyloQDocumentPrereqParam();
	StyloQDocumentPrereqParam(const StyloQDocumentPrereqParam & rS);
	StyloQDocumentPrereqParam & FASTCALL operator = (const StyloQDocumentPrereqParam & rS);

	enum {
		fUseBarcodeSearch   = 0x0001, // На клиенте будет доступна функция поиска по штрихкоду
		fUseBrands          = 0x0002, // Отправлять клиенту список брендов. Флаг действителен только если PalmID == 0, в противном случае этим управляют опции записи StyloPalm
		fDlvrDateAsNominal  = 0x0004, // @v11.6.1 Трактовать дату исполнения заказа как номинальную дату документа
		fUseHierarchGroups  = 0x0008, // @v11.6.4 На клиенте товарные группы представлены иерархическим списком. Сервис отправляет данные по группам со ссылками
			// на родительские группы.
		fHideStock          = 0x0010, // @v11.6.4 Не отображать остатки на клиентском устройстве
		fExpPsnAddresses    = 0x0020, // @v11.8.1 Экспортировать собственные адреса персоналий (основной и фактический). Этот флаг не влияет на экспорт списка адресов доставки!
	};

	uint8    ReserveStart[64]; // @anchor
	PPID     PalmID;
	long     Flags;
	PPID     OpID;
	PPID     LocID;
	PPID     QuotKindID;
	long     Reserve;           // @anchor  
private:
	int    InitInstance();
};
//
// Descr: Параметры подготовки данных для заказа услуг в рамках проекта Stylo-Q
//
class StyloQAttendancePrereqParam : public PPBaseFilt {
public:
	StyloQAttendancePrereqParam();
	StyloQAttendancePrereqParam(const StyloQAttendancePrereqParam & rS);
	StyloQAttendancePrereqParam & FASTCALL operator = (const StyloQAttendancePrereqParam & rS);

	uint8  ReserveStart[50]; // @reserve
	uint16 TimeSheetDiscreteness; // @v11.4.3 Дискретность таблицы для выбора времени в минутах. Пока допустимы только: 15, 10, 5мин
	int32  LocID;            // @v11.3.12 Склад (для идентификации процессоров и котировок)
	int32  QuotKindID;       // @v11.3.12 Вид котировки для определения цены услуги     
	int32  MaxScheduleDays;  // @v11.3.10 Максимальное количество дней от текущего, доступные для заказа услуги
	ObjIdListFilt PrcList;   // @anchor 
	SString PrcTitle;        // Строка, используемая для именования процессоров (мастера, врачи и т.д.)
private:
	int    InitInstance();
};
//
// Descr: Параметры тестовой команды Stylo-Q
//
class StyloQTestCmdParam : public PPBaseFilt { // @v12.3.1
public:
	StyloQTestCmdParam();
	StyloQTestCmdParam(const StyloQTestCmdParam & rS);
	StyloQTestCmdParam & FASTCALL operator = (const StyloQTestCmdParam & rS);

	uint8  ReserveStart[128]; // @reserve
	SString ReplyText;        // @anchor 
private:
	int    InitInstance();
};
//
//
//
class StyloQIncomingListParam : public PPBaseFilt {
public:
	StyloQIncomingListParam();
	StyloQIncomingListParam(const StyloQIncomingListParam & rS);
	StyloQIncomingListParam & FASTCALL operator = (const StyloQIncomingListParam & rS);
	void   NormalizeStatusList();
	//
	// Descr: Действия над документами из входящего списка
	//
	enum {
		actionDocStatus           = 0x0001, // Изменение статуса 
		actionDocAcceptance       = 0x0002, // Приемка товара (приходные накладные)
		actionDocAcceptanceMarks  = 0x0004, // Проверка марок в строках входящего документа (приходные накладные)
		actionDocSettingMarks     = 0x0008, // Расстановка марок на строках исходящего документа (расходные накладные)
		actionDocInventory        = 0x0010, // Ввод документа инвентаризации
		actionGoodsItemCorrection = 0x0020, // Корректировка позиций (количество, цена, удаление позиции, замена товара)
		actionCCheckCreat         = 0x0040, // @v11.5.2 Создание чека
		actionCCheckMod           = 0x0080, // @v11.5.2 Модификация чека
		actionCCheckRegPrint      = 0x0100, // @v11.5.2 Печать чека на регистраторе
		actionTSessCreat          = 0x0200, // @v11.6.5
		actionTSessTmSet          = 0x0400, // @v11.6.5
	};
	enum {
		fBillWithMarksOnly        = 0x0001, // Только документы, в которых есть марки честный знак или егаис
		fBillWithMarkedGoodsOnly  = 0x0002  // Только документы, содержащие товары, подлежащие маркировке
	};
	//
	// Descr: Варианты проведения приемки входящих документов
	//
	enum {
		acceptanceNone         = 0, // Ничего не делать
		acceptanceTags         = 1, // Расставить теги по строкам
		acceptanceModifyOrgDoc = 2, // Изменить оригинальный документ
		acceptanceLinkDraft    = 3  // Привязать к оригинальному документу драфт с информацией о приемке (oprkind=PPOPK_EDI_RECADV)
	};
	uint8  ReserveStart[44];
	int    Acceptance; // @v11.7.0 (acceptanceXXX) Способ обработки приемки документа
	DateRange Period;  // Это - отладочный критерий. В реальности должен использоваться LookbackDays, но так как тестовые 
		// базы данных не меняются, то LookbackDays при разработке использовать затруднительно.
	uint32 Flags;
	uint32 ActionFlags;
	int    StQBaseCmdId;
	int    LookbackDays; // Количество дней с отсчетом назад от текущей системной даты. Данные захватываются за период,
		// начиная от now-LookbackDays до бесконечности (данные будущими числами так же захватываются).
	long   Reserve;
	//
	// Фильтры, представленные здесь не подлежать прямому интерактивному редактированию пользователем.
	// Наружу выводится лишь часть критериев этих фильтров, остальные параметры будут задаваться автоматически.
	//
	BillFilt * P_BF;
	PrjTaskFilt * P_TdF;
	TSessionFilt * P_TsF;
	CCheckFilt * P_CcF;
	TSVector <PPStyloQInterchange::Document::CliStatus> StatusList; // @v11.4.12 Список правил установки статуса
private:
	virtual int ReadPreviousVer(SBuffer & rBuf, int ver);
	int    InitInstance();
};

class StyloQIndexingParam : public PPBaseFilt {
public:
	StyloQIndexingParam();
	StyloQIndexingParam(const StyloQIndexingParam & rS);
	StyloQIndexingParam & FASTCALL operator = (const StyloQIndexingParam & rS);

	enum {
		fGoods       = 0x0001,
		fGoodsGroups = 0x0002,
		fBrands      = 0x0004,
		fProcessors  = 0x0008
	};

	uint8  ReserveStart[64]; // @reserve
	long   Flags;
	PPID   GoodsGroupID;
	PPID   PersonKindID;
	ObjIdListFilt PrcList;   // @anchor 
private:
	int    InitInstance();
};

class StyloQGoodsInfoParam : public PPBaseFilt {
public:
	StyloQGoodsInfoParam();
	StyloQGoodsInfoParam(const StyloQGoodsInfoParam & rS);
	StyloQGoodsInfoParam & FASTCALL operator = (const StyloQGoodsInfoParam & rS);

	enum {
		fShowRest         = 0x0001,
		fShowCost         = 0x0002,
		fShowPrice        = 0x0004,
		fShowDescriptions = 0x0008,
		fShowCodes        = 0x0010 
	};
	uint8  ReserveStart[64]; // @reserve
	PPID   LocID;
	PPID   PosNodeID;
	long   Flags;
	uint32 Reserve;          // @anchor  
private:
	int    InitInstance();
};
//
//
//
class PPObjStyloQBindery : public PPObject {
public:
	explicit PPObjStyloQBindery(void * extraPtr = 0);
	~PPObjStyloQBindery();
	virtual int Edit(PPID * pID, void * extraPtr);
	virtual int Browse(void * extraPtr);
	virtual int Search(PPID id, void * b = 0);
	//
	// Descr: Интерактивная функция, вызывающая диалог ассоциации клиентской записи с каким-либо объектом
	//
	int    AssignObjToClientEntry(PPID id);
	//
	// Descr: Интерактивная функция редактирования конфигурации, ассоциированной с записью id
	//
	int    EditConfig(PPID id);
	//
	// Descr: Интерактивная функция редактированя параметров лика записи
	//
	int    EditFace(PPID id);
public:
	TLP_MEMB(StyloQCore, P_Tbl);
	void * ExtraPtr;
};
//
//
//
class StyloQBinderyFilt : public PPBaseFilt {
public:
	StyloQBinderyFilt();
	//
	// Descr: В списке по ссылке rList возвращает списко видов записей, соответствующих
	//   полю KindFlags, по которому следует фильтровать выборку реестра.
	// Returns:
	//   0 - нет ни одного вида, по которому следует фильтровать реестр
	//  -1 - выбраны все возможные виды записей
	//   1 - выбран один или более видов, но не все возможные
	//
	int    GetKindList(LongArray & rList) const;

	uint8  ReserveStart[64];
	uint32 KindFlags;         // Flags: (1 << StyloQCore::kXXX)
	uint8  Reserve[64]; // @anchor
};

struct StyloQBinderyViewItem { // @flat
	long   ID;
	long   Kind;
	long   CorrespondID;
	long   DocType; // @v11.4.5
	long   Flags;   // @v11.4.5
	uchar  BI[20];
	LDATETIME Expiration;
	PPObjID LinkOid;
};

class PPViewStyloQBindery : public PPView {
public:
	struct BrwItem : public StyloQBinderyViewItem { // @flat
		uint   ObjNameP;
		uint   FaceP;
	};
	PPViewStyloQBindery();
	~PPViewStyloQBindery();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
	static int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr); // @really-private
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  Detail(const void *, PPViewBrowser * pBrw);
	int    MakeList(PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    Invitation();

	StyloQBinderyFilt Filt;
	SArray * P_DsList;
	SStrGroup StrPool;
	PPObjStyloQBindery Obj;
	ObjCollection ObjColl;
	enum {
		stMatchingUpdated  = 0x0001, // Были изменены привязки записей (надо обновить глобальную карту соответствий объектов StyloQ)
		stSvcConfigUpdated = 0x0002, // @v12.3.0 Была изменена конфигурация сервиса
		stSvcFaceUpdated   = 0x0004, // @v12.3.0 Был изменен лик сервиса
	};
	uint   State;
};

class StyloQCommandFilt : public PPBaseFilt {
public:
	StyloQCommandFilt();

	uint8  ReserveStart[64];
	int32  BaseCmdId;
	uint8  Reserve[64]; // @anchor
};

struct StyloQCommandViewItem { // @flat
	S_GUID Uuid;
	int32  BaseCmdId;
	int32  Flags;
	int32  ViewId;              //
	int32  ObjTypeRestriction;  //
	int32  ObjGroupRestriction; //
	char   Name[128];
	char   DbSymb[48];
	char   ViewSymb[48];
};

class PPViewStyloQCommand : public PPView {
public:
	struct BrwItem : public StyloQBinderyViewItem { // @flat
		uint   ObjNameP;
		uint   FaceP;
	};
	PPViewStyloQCommand();
	~PPViewStyloQCommand();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
	static int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr); // @really-private
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  OnExecBrowser(PPViewBrowser *);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    MakeList(PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    AddItem(uint * pIdx);
	int    EditItem(uint idx);
	int    DeleteItem(uint idx);
	//
	// ARG(pData INOUT): Команда подлежащая редактированию
	//
	int    EditStyloQCommand(StyloQCommandList::Item * pData, const StyloQCommandList & rWholeList);

	StyloQCommandFilt Filt;
	StyloQCommandList List; // list in utf8 encoding
	SArray * P_DsList;
	SStrGroup StrPool;
	PPObjStyloQBindery Obj;
	ObjCollection ObjColl;
	PPNamedFiltMngr NfMgr;
};
//
// @ModuleDecl(PPViewReport)
//
class ReportFilt : public PPBaseFilt {
public:
	ReportFilt();
	enum {
		fShowObjects  = 0x0001
	};
	enum {
		rpttAll = 0,
		rpttStandart,
		rpttLocal
	};
	enum {
		ordByName = 1,
		ordByType,
		ordByStruc
	};

	char   ReserveStart[24];
	DateRange Period;
	long   Type;
	long   Order;
	SString StdName;
	SString StrucName;
};

typedef TempReportTbl::Rec ReportViewItem; // @v10.7.3 Закладываемся на то, что имеет конструктор и убираем везде MEMSZERO()
typedef TSArray <ReportViewItem> ReportViewItemArray;

class PPViewReport : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};

	PPViewReport();
	~PPViewReport();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(ReportViewItem *);
	int    SaveChanges(int remove);
	int    CreateStdRptList(ReportViewItemArray *);
	int    CreateRptList(ReportViewItemArray *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	void   MakeTempRec(const ReportViewItem *, TempReportTbl::Rec *);
	int    CheckForFilt(const ReportViewItem *);
	int    EditItem(PPID * pID);
	int    DelItem(PPID);
	int    SendMail(PPID id);
	int    Verify(PPID id);
	int    CallCR(PPID id);
	int    GetAltPath(PPID type, const char * pPath, const char * pStdName, SString & rPath);
	int    SplitLocalRptStr(PPIniFile * pFile, int codepage, const SString & rSect, SString & rBuf, ReportViewItem * pItem);

	int     LocalRptCodepage;
	SString SystemSect;
	SString CodepageParam;
	SString FmtParam;
	SString DestParam;
	SString SilentParam;
	SString DataParam;
	SString DescrParam;
	SString ModifDtParam;

	ReportFilt Filt;
	PPIniFile * P_StdRptFile;
	PPIniFile * P_RptFile;
	TempReportTbl * P_TempTbl;
};
//
//
//
class PersonRelFilt : public PPBaseFilt {
public:
	PersonRelFilt();
	PersonRelFilt & FASTCALL operator = (const PersonRelFilt &);

	enum {
		psnfByPrmrPerson = 1,
		psnfByScndPerson
	};

	enum {
		ordByPrmrPerson = 1,
		ordByScndPerson,
		ordByRelationType
	};
	enum {
		fApplyPsnFiltToScnd  = 0x0001,
		fAddedSelectorByPrmr = 0x0002,
		fAddedSelectorByScnd = 0x0004
			// @#{fAddedSelectorByPrmr^fAddedSelectorByScnd)
	};
	char   ReserveStart[32];      // @anchor
	long   Flags;
	long   SortOrd;
	PPID   RelTypeID;
	PPID   PrmrPersonID;
	PPID   ScndPersonID;
	PersonFilt * P_PsnFilt;       // @anchor
};

struct PersonRelViewItem {
	PPID   ID;
	PPID   PrmrPersonID;
	PPID   ScndPersonID;
	PPID   RelTypeID;
	char   RelName[48];
};

class PPViewPersonRel : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
		PPID   PrmrPersonID;
    	PPID   ScndPersonID;
		PPID   RelTypeID;
	};
	PPViewPersonRel();
	~PPViewPersonRel();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PersonRelViewItem *);
	int    CheckForFilt(const PersonCore::RelationRecord * pRec);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int OnExecBrowser(PPViewBrowser * pBrw);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    UpdateTempTable(PPID prmrID, const PPIDArray & rScndList, PPID relation, int reverse);
	int    CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	TempPersonRelTbl::Rec & MakeTempEntry(const PersonCore::RelationRecord & rRec, TempPersonRelTbl::Rec & rTempRec);
	int    MakeTempOrdEntry(long ord, const TempPersonRelTbl::Rec * pTempRec, TempOrderTbl::Rec * pOrdRec);
	int    ViewReverseRelations(PPID personID);

	PersonRelFilt Filt;
	ObjIdListFilt PersonList;
	PPObjPerson   PsnObj;
	UintHashTable PrmrList; // Список первичных персоналий, попавших в выборку
	UintHashTable ScndList; // Список вторичных персоналий, попавших в выборку
	TempPersonRelTbl * P_TempTbl;
	TempOrderTbl * P_TempOrd;
};
//
//
//
class ObjLikenessFilt : public PPBaseFilt {
public:
	ObjLikenessFilt();
	ObjLikenessFilt & FASTCALL operator = (const ObjLikenessFilt &);

	char   ReserveStart[32]; // @anchor
	PPID   ObjTypeID;
	double Rate;
	long   Reserve;          // @anchor
};

typedef ObjLikenessTbl::Rec ObjLikenessViewItem;

class PPViewObjLikeness : public PPView {
public:
	struct BrwHdr {
		PPID   ObjType;
		PPID   ID1;
    	PPID   ID2;
	};

	static int CreateLikenessTable();

	PPViewObjLikeness();
	~PPViewObjLikeness();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ObjLikenessViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int Print(const void *);
	int    UniteObjects(PPID objType, PPID srcID, PPID destID);

	ObjLikenessFilt Filt;
	PPObjPerson PsnObj;
	PPObjGoods GObj;
	ObjLikenessTbl Tbl;
};
//
//
//
class ScaleFilt : public PPBaseFilt {
public:
	enum {
		protAll   = 0,
		protTcpIp = 1,
		protCom   = 2
	};

	ScaleFilt();
	ScaleFilt & FASTCALL operator = (const ScaleFilt &);

	char   ReserveStart[24];
	char   Reserve[24];
	PPID   LocID;
	PPID   ScaleTypeID;
	PPID   AltGoodsGrpID;
	long   Protocol;
	PPID   GroupID;         //
	long   Flags;           // SCALF_XXX
	long   ReserveEnd;
};

//typedef PPScale ScaleViewItem;

class ScaleViewItem : public PPScale {
public:
	SString Port;
};

class PPViewScale : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewScale();
	~PPViewScale();
	virtual int    EditBaseFilt(PPBaseFilt *);
	virtual int    Init_(const PPBaseFilt * pBaseFilt);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	int    InitIteration();
	int    FASTCALL NextIteration(ScaleViewItem *);
	int    CheckScaleStatus(PPID scaleID, int statusFromList);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    UpdateTempTable(const PPIDArray * pIdList);
	TempScaleTbl::Rec & MakeTempEntry(const PPScalePacket & rPack, TempScaleTbl::Rec & rTempRec);
	int    CheckForFilt(const PPScalePacket * pPack) const;

	LAssocArray  ScaleStatusList;
	SString      ScaleTypeNames;
	ScaleFilt    Filt;
	PPObjScale   ObjScale;
	TempScaleTbl * P_TempTbl;
};
//
//
//
struct BudgetFilt : public PPBaseFilt {
	BudgetFilt();
	virtual int Init(int fullyDestroy, long extraData);
	BudgetFilt & FASTCALL operator = (const BudgetFilt & s);

	enum {
		kBudget      = 0,
		kBudgetItems = 1
	};

	uint8     ReserveStart[32]; // @anchor
	PPID      BudgetID;
	PPID      ParentAcctID;
	long      ParentKind;
	LDATE     ParentDt;
	DateRange Period;
	uint16    Kind;
	long      Reserve;
};

struct BudgetViewItem {
	PPBudget Budget;
	BudgetItemTbl::Rec Item;
};

class PPViewBudget : public PPView {
public:
	struct Hdr {
		PPID  ID;
		PPID  AccID;
		LDATE Dt;
		long  Kind;
	};
	PPViewBudget();
	~PPViewBudget();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void ViewTotal();
	int    InitIteration();
	int    FASTCALL NextIteration(BudgetViewItem *);
	void   GetTabTitle(long tabID, SString & rBuf);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * GetEditExtraParam();
	virtual int   Detail(const void *, PPViewBrowser * pBrw);
	virtual int   Print(const void *);
	virtual int   OnExecBrowser(PPViewBrowser * pBrw);
	void   GetEditIds(const void * pRow, Hdr * pHdr, long col);
	int    UpdateTempTable(const PPIDArray & rIdList);
	void   MakeTempRec(const void * pRec, void * pTempRec);
	int    CheckForFilt(void * pRec);

	PPID   UpdateID;
	BudgetFilt Filt;
	PPObjAccount ObjAcct;
	PPObjBudget  ObjBudg;
	TempBudgetTbl    * P_TempBudgTbl;
	TempBudgItemTbl  * P_TempBudgItemTbl;
};
//
// PPViewBizScTempl
//
class BizScTemplFilt : public PPBaseFilt {
public:
	BizScTemplFilt();
	BizScTemplFilt & operator = (const BizScTemplFilt &);

	long ReserveStart;
	long Flags;
	char ReserveEnd[32];
};

typedef PPBizScTempl BizScTemplViewItem;

class PPViewBizScTempl : public PPView {
public:
	PPViewBizScTempl();
	~PPViewBizScTempl();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(BizScTemplViewItem * pItem);
private:
	virtual int ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	int    UpdateTempTable(PPID id);
	void   MakeTempRec(const PPBizScTempl * pInRec, TempBizScTemplTbl::Rec * pOutRec);
	int    CheckIDForFilt(PPID id, PPBizScTempl * pRec);

	BizScTemplFilt Filt;
	PPObjBizScTempl Obj;
	TempBizScTemplTbl * P_TempTbl;
};
//
// PPViewBizScValByTempl
//
struct BizScValByTemplViewItem {
	BizScValByTemplViewItem();
	~BizScValByTemplViewItem();
	BizScValByTemplViewItem & FASTCALL operator = (const BizScValByTemplViewItem & rSrc);

	long   Id;
	char   Name[32];
	char * P_Vals;
};

class BizScValByTemplFilt : public PPBaseFilt {
public:
	BizScValByTemplFilt();
	BizScValByTemplFilt & FASTCALL operator = (const BizScValByTemplFilt &);

	long   ReserveStart;
	PPID   TemplateID;
	char   ReserveEnd[32];
};


class PPViewBizScValByTempl : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};

	PPViewBizScValByTempl();
	~PPViewBizScValByTempl();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(BizScValByTemplViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	int    FetchData();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    CheckForFilt(const PPAmountTypePacket * pPack) const;

	TSCollection<BizScValByTemplViewItem> Data;
	BizScValByTemplFilt Filt;
	PPBizScTemplPacket  Pack;
	PPObjBizScTempl BizScTObj;
	BizScoreCore    BizScTbl;
};
//
// PPViewCheckOpJrnlFilt
//
class CheckOpJrnl : public CheckOpJrnlTbl {
public:
	explicit CheckOpJrnl(CCheckCore * pCc);
	~CheckOpJrnl();
	int    LogEvent(int16 action, const CCheckPacket * pPack, const CCheckLineTbl::Rec * pLineRec, int useTa);
	int    Search(LDATE dt, LTIME tm, CheckOpJrnlTbl::Rec * pRec);
	int    GetListSince(const LDATETIME & rSince, TSVector <CheckOpJrnlTbl::Rec> & rRecList);
	// int    GetEvent(PPID action, int mode, LDATETIME * pDtm, int maxDays, CheckOpJrnlTbl::Rec * pRec = 0);
	// int    GetLastEvent(PPID action, LDATETIME * pDtm, int maxDays, CheckOpJrnlTbl::Rec * = 0);
	// int    GetLastUserEvent(PPID action, PPID userID, PPID sessID, const DateRange * pSrchPeriod, LDATETIME *, void * = 0);
private:
	CCheckCore * P_Cc; // @notowned
};

class CheckOpJrnlFilt : public PPBaseFilt {
public:
	CheckOpJrnlFilt();
	virtual bool IsEmpty() const;

	char   ReserveStart[32];
	PPID   UserID;
	PPID   AgentID;
	DateRange Period;
	LTIME  BegTm;
	PPIDArray ActionIDList;
};

typedef CheckOpJrnlTbl::Rec CheckOpJrnlViewItem;

class PPViewCheckOpJrnl : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		LTIME  Tm;
		int16  Action;
	};
	PPViewCheckOpJrnl();
	~PPViewCheckOpJrnl();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(CheckOpJrnlViewItem *);
	int    FASTCALL CheckRecForFilt(const CheckOpJrnlTbl::Rec * pRec);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int Print(const void *);

	CheckOpJrnlFilt Filt;
	CCheckCore CC;
	CheckOpJrnl * P_Tbl;
	PPObjGoods GObj;
};
//
//
//
class CashNodeFilt : public PPBaseFilt {
public:
	enum {
		sAll       = 0,
		sOnlySync  = 1,
		sOnlyASync = 2
	};

	CashNodeFilt();
	CashNodeFilt & FASTCALL operator = (const CashNodeFilt &);

	char   ReserveStart[24];
	char   Reserve[24];
	PPID   CashTypeID;        // Тип ККМ (PPCMT_XXX)
	PPID   LocID;
	int16  SyncType;
	int16  Reserve2;
	long   ReserveEnd;
};

typedef PPCashNode CashNodeViewItem;

class PPViewCashNode : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewCashNode();
	~PPViewCashNode();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(CashNodeViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    UpdateTempTable(const PPIDArray * pIdList);
	TempCashNodeTbl::Rec & MakeTempEntry(const PPCashNode & rRec, TempCashNodeTbl::Rec & rTempRec);
	int    CheckForFilt(const PPCashNode * pRec) const;
	// @v10.1.0 (inlined) int    ExecCPanel(uint ppvCmd, PPID cashID);

	SString         CashTypeNames;
	CashNodeFilt    Filt;
	PPObjCashNode   ObjCashN;
	TempCashNodeTbl * P_TempTbl;
};
//
//
//
class PalmFilt : public PPBaseFilt { // @styloagentfilt
public:
	enum {
		devtAll        = 0,
		devtOnlyGroups = 1,
		devtOnlyDevs   = 2
	};

	PalmFilt();
	PalmFilt & FASTCALL operator = (const PalmFilt &);

	char   ReserveStart[24];
	PPID   GroupID;
	PPID   GoodsGrpID;
	PPID   OrderOpID;
	PPID   AgentID;
	PPID   FTPAcctID;
	int16  Type;
	int16  Reserve;
	long   ReserveEnd;
	ObjIdListFilt LocList;
};

struct PalmViewItem : public PPStyloPalm {
	char   Path[MAX_PATH];
	char   FtpPath[MAX_PATH];
};

class PPViewPalm : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewPalm();
	~PPViewPalm();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(PalmViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    UpdateTempTable(const PPIDArray * pIdList);
	TempPalmTbl::Rec & MakeTempEntry(const PPStyloPalmPacket & rPack, TempPalmTbl::Rec & rTempRec);
	int    CheckForFilt(const PPStyloPalm * pRec);
	int    ExportUhtt();

	PalmFilt        Filt;
	PPObjStyloPalm  ObjPalm;
	TempPalmTbl   * P_TempTbl;
};
//
//
//
struct ServerStatViewItem {
	uint32 TId;
	int32  Kind;
	int32  State;
	LDATETIME StartMoment;
	char   Text[256];
	char   LastMsg[512];
};

class ServerStatFilt : public PPBaseFilt {
public:
	ServerStatFilt();
	ServerStatFilt & FASTCALL operator = (const ServerStatFilt &);

	char   ReserveStart[32]; // @anchor
	long   Flags;
	uint32 RefreshTime;
	SString ServerAddr;     // @anchor
};

class PPViewServerStat : public PPView {
public:
	PPViewServerStat();
	~PPViewServerStat();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	//int    InitIteration();
	//int    FASTCALL NextIteration(ServerStatViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    StopThread(long tid);
	int    ResetCache();
	int    LogLockStack();
	int    FetchStat();

	SArray Data;
	ServerStatFilt Filt;
};
//
// PPViewTransport
//
typedef PPTransport TransportViewItem;

class TransportFilt : public PPBaseFilt {
public:
	TransportFilt();
	int    InitInstance();
	virtual bool IsEmpty() const;
	virtual int  Describe(long flags, SString & rBuf) const;

	char   ReserveStart[32];
	long   TrType;
	PPID   ModelID;
	PPID   OwnerID;
	PPID   CaptainID;
	PPID   CountryID;
	SString Code;
	SString TrailCode;
};

class PPViewTransport : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	PPViewTransport();
	~PPViewTransport();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int aOrder = 0);
	int    FASTCALL NextIteration(TransportViewItem *);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void ViewTotal();
	bool   IsTempTblNeeded();
	int    CheckForFilt(TransportFilt * pFilt, PPID transpID, const PPTransportPacket * pRec);
	void   MakeTempRec(const PPTransportPacket * pTranspPack, TempTransportTbl::Rec * pTempRec);
	int    UpdateTempTable(PPID transpID, PPViewBrowser * pBrw);
	int    DeleteItem(PPID id);
	int    Transmit(PPID);

	TransportFilt  Filt;
	PPObjTransport TObj;
	TempTransportTbl * P_TempTbl;
};
//
// PPViewAmountType
//
class AmountTypeFilt : public PPBaseFilt {
public:
	AmountTypeFilt();
	AmountTypeFilt & FASTCALL operator = (const AmountTypeFilt &);
	bool   IsComplementary() const;

	char   ReserveStart[24];
	long   Flags;
	PPID   RefAmtTypeID;
	PPID   TaxID;
	long   ReserveEnd;
};

struct AmountTypeViewItem {
	int32  ID;
	int32  RefAmtTypeID;
	int32  Flags;
	int32  Tax;
	double TaxRate;
	char   Formula[256];
};

class PPViewAmountType : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewAmountType();
	~PPViewAmountType();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(AmountTypeViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	int    FetchData(long id);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeListEntry(const PPAmountTypePacket * pPack, AmountTypeViewItem * pItem);
	int    CheckForFilt(const PPAmountTypePacket * pPack) const;
	int    Transmit(bool isCharry);

	SArray            Data;
	AmountTypeFilt    Filt;
	PPObjAmountType   ObjAmtT;
};
//
// PPViewRegisterType
//
struct RegTypeViewItem {
	RegTypeViewItem();
	int32  ID;
	int32  RegOrgKind;
	int32  PersonKindID;
	int32  ExpiryPrd;
	char   Format[256];
};

class RegisterTypeFilt : public PPBaseFilt {
public:
	RegisterTypeFilt();
	RegisterTypeFilt & FASTCALL operator = (const RegisterTypeFilt &);

	char   ReserveStart[24];
	PPID   RegOrgKind;
	PPID   PersonKindID;
	long   St;
	long   ReserveEnd;
};

class PPViewRegisterType : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	PPViewRegisterType();
	~PPViewRegisterType();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(RegTypeViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    FetchData(long id);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeListEntry(const PPRegisterTypePacket * pPack, RegTypeViewItem * pItem);
	int    CheckForFilt(const PPRegisterTypePacket * pPack) const;
	int    Transmit(bool isCharry);

	RegisterTypeFilt  Filt;
	PPObjRegisterType ObjRegT;
	SArray Data;
};
//
// @ModuleDecl(PPViewDialog)
//
class DialogFilt : public PPBaseFilt {
public:
	DialogFilt();

	uint8  ReserveStart[64]; // @anchor
	long   Flags;
	uint8  ReserveEnd[32];   // @anchor
	SString DlFileName;
	SString Serial;
	SString SubText;
};

struct DialogViewItem {
	long   Id;
	char   Symb[64];
	char   Serial[64];
	char   Text[128];
};

class PPViewDialog : public PPView {
public:
	PPViewDialog();
	~PPViewDialog();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(DialogViewItem * pItem);
private:
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int Detail(const void * pHdr, PPViewBrowser * pBrw);

	DialogFilt Filt;
	DlContext Ctx;
	TSArray <DialogViewItem> List;
};
//
// @ModuleDecl(PPViewSpecSeries)
//
class SpecSeriesFilt : public PPBaseFilt {
public:
	SpecSeriesFilt();
	SpecSeriesFilt & FASTCALL operator = (const SpecSeriesFilt &);

	uint8  ReserveStart[64]; // @anchor
	DateRange Period;
	PPID    GoodsGrpID;
	PPID    GoodsID;
	long    InfoKind;
	long    Flags;
	uint8   ReserveEnd[32];   // @anchor
	SString Serial;
};

typedef SpecSeries2Tbl::Rec SpecSeriesViewItem;

class PPViewSpecSeries : public PPView {
public:
	PPViewSpecSeries();
	~PPViewSpecSeries();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(SpecSeriesViewItem *);
	int    ExportUhtt();
	int    ImportUhtt();
private:
	static int DynFuncSpcSnTextFld;

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);

	int    AddItem();
	int    EditItem(PPID id);
	int    DeleteItem(PPID id);
	int    Import();
	SpecSeriesFilt Filt;
	SpecSeriesCore Tbl;
};
//
// @ModuleDecl(PPViewDBDiv)
//
class DBDivFilt : public PPBaseFilt {
public:
	DBDivFilt();
	DBDivFilt & FASTCALL operator = (const DBDivFilt &);

	uint8  ReserveStart[64]; // @anchor
	uint32 Flags;
	uint8  ReserveEnd[32];   // @anchor
	ObjIdListFilt LocList;
};

typedef PPDBDiv DBDivViewItem;

class PPViewDBDiv : public PPView {
public:
	PPViewDBDiv();
	~PPViewDBDiv();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(DBDivViewItem *);
	int    ExportUhtt();
	int    ImportUhtt();
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    UpdateTempTable(const PPIDArray * pIdList);
	TempDBDivTbl::Rec & MakeTempEntry(const DBDivPack & rPack, TempDBDivTbl::Rec & rTempRec);
	int    CheckForFilt(const DBDivPack * pPack) const;

	TempDBDivTbl * P_TempTbl;
	DBDivFilt Filt;
	PPObjDBDiv ObjDBDiv;
};
//
// PPViewDBMonitor
//
typedef DBFileInfo DBMonitorViewItem;

class DBMonitorFilt : public PPBaseFilt {
public:
	DBMonitorFilt();
	DBMonitorFilt & FASTCALL operator = (const DBMonitorFilt & s);

	char   ReserveStart[128]; // @anchor
	char   ReserveEnd[128];   // @anchor
};

class PPViewDBMonitor : public PPView {
public:
	PPViewDBMonitor();
	~PPViewDBMonitor();
	virtual int   EditBaseFilt(PPBaseFilt *);
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration(int order);
	int    FASTCALL NextIteration(DBMonitorViewItem *);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	SString YesWord;
	SString NoWord;
	TSArray <DBMonitorViewItem> Items;
	PervasiveDBCatalog DBCat;
	DBMonitorFilt      Filt;
};
// @vmiller {
//
// PPViewSuprWare
//
typedef PPSuprWare SuprWareViewItem;

class SuprWareFilt : public PPBaseFilt {
public:
	SuprWareFilt();
	int    InitInstance();
	virtual bool IsEmpty() const;
	virtual int  Describe(long flags, SString & rBuf) const;

	char   ReserveStart[20];  // @anchor
	PPID   PrmrID;
	PPID   ScndID;
	long   Flags;
	PPID   SuprWareType;
	PPID   SuprWareCat;
	SString SrchStr;           // @anchor Строка, содержащаяся в имени
	PPIDArray TypeIDList;      // Список групп
};

class PPViewSuprWare : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	PPViewSuprWare();
	~PPViewSuprWare();
	virtual int  EditBaseFilt(PPBaseFilt *);
	virtual int  Init_(const PPBaseFilt * pBaseFilt);
	virtual void ViewTotal();
	int    InitIteration();
	int    FASTCALL NextIteration(SuprWareViewItem * pItem);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int Detail(const void *, PPViewBrowser * pBrw);
	int    DeleteAll();

	SuprWareFilt  Filt;
	PPObjSuprWare SwObj;
};
//
// } @vmiller
//
//
//
//
struct ClientActivityDetailsFilt : public PPBaseFilt {
	ClientActivityDetailsFilt();
	char   ReserveStart[32];
	PPID   PersonID;
	DateRange Period;
	long   Flags;
	long   ReserveEnd; // @anchor
};

struct ClientActivityDetailsViewItem {
	ClientActivityDetailsViewItem() : Dtm(ZERODATETIME), Amount(0.0), Flags(0)
	{
		TransactionOp[0] = 0;
		TransactionCode[0] = 0;
		TransactionEtc[0] = 0;
	}
	PPObjID Oid;
	LDATETIME Dtm;
	char   TransactionOp[48];
	char   TransactionCode[48];
	char   TransactionEtc[128];
	double Amount;
	long   Flags;
};

class PPViewClientActivityDetails : public PPView {
public:
	typedef ClientActivityDetailsViewItem BrwItem;

	PPViewClientActivityDetails();
	~PPViewClientActivityDetails();
	virtual int   Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(ClientActivityDetailsViewItem * pItem);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
private:
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	int    MakeList();
	ClientActivityDetailsFilt Filt;
	TSVector <ClientActivityDetailedEntry> IList; // "Сырые" данные детализации, полученные в функции Init_()
	TSArray <BrwItem> * P_DsList;
	PPObjSCard ScObj;
	PPObjPersonEvent PeObj;
};
//
// PPViewUserProfile
//
typedef TempUserProfileTbl::Rec UserProfileViewItem;

class UserProfileFilt : public PPBaseFilt {
public:
	UserProfileFilt();

	char   ReserveStart[32];  // @anchor
	long   Flags;
	long   FuncID;
	long   UserID;
	S_GUID DbID;
	DateRange Period;
	TimeRange TmPeriod;
	long   ReserveEnd;        // @anchor
};

class PPUserProfileCore : public UserFuncPrfTbl {
public:
	PPUserProfileCore();
	~PPUserProfileCore();
	int    Load(const char * pPath);
	int    ClearState(const S_GUID * pDbId, int use_ta);

	struct UfpDbEntry {
		S_GUID DbID;
		char   DbSymb[128];
	};
	int    GetDbEntyList(TSArray <UfpDbEntry> & rList);

	UserFuncPrfSessTbl UfpSessT;
private:
	struct UfpLine {
		UfpLine();
		UfpLine & Z();

		int    Kind;      // Profile::fkXXX
		S_GUID DbUuid;
		S_GUID SessUuid;
		long   ThreadId;
		int64  Seq;
		long   FuncId;
		SVerT Ver;
		LDATETIME Start;
		int64  Clock;
		MACAddr MAddr;
		uint8  Reserve[18];  // @alignment + @reserve
		double Factors[8];
		SString DbSymb;      // @anchor
		SString UserName;
		SString MachineName;
	};
	static int ParseUfpLine(StringSet & rSs, SString & rTempBuf, int kind, PPUserProfileCore::UfpLine & rItem);
	int    WriteState(int use_ta);
	int    ReadState();
	int    SetupSessItem(long * pSessID, const UfpLine & rLine, long funcId = 0);
	int    OpenInputFile(const char * pFileName, int64 offset, SFile & rF);
	int    AddAggrRecs(BExtInsert * pBei, const UserFuncPrfTbl::Rec & rRec, const UfpLine & rLine);
	int    Helper_StoreFinishList(const UfpFileSet * pSet, const void * pFinishList, const UfpLine & rUfpLine);

	struct StateItem_Internal { // @persistent
		S_GUID DbID;
		LDATETIME SessCrDtm;
		LDATETIME StartCrDtm;
		LDATETIME FinishCrDtm;
		int64  SessOffs;
		int64  StartOffs;
		int64  FinishOffs;
		uint   DbSymbP;
	};
	struct StateItem {
		StateItem();
		StateItem & Z();

		S_GUID DbID;
		LDATETIME SessCrDtm;
		LDATETIME StartCrDtm;
		LDATETIME FinishCrDtm;
		int64  SessOffs;
		int64  StartOffs;
		int64  FinishOffs;
		SString DbSymb;
	};
	class StateBlock : public SStrGroup {
	public:
		StateBlock();
		StateBlock & Z();
		uint   GetCount() const { return L.getCount(); }
		uint   GetItem(uint p, StateItem & rItem) const { return Helper_GetItem(p, rItem); }
		int    SetItem(StateItem & rItem);
		int    GetItem(const S_GUID & rDbId, StateItem & rItem) const;
		int    RemoveItem(const S_GUID & rDbId);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	private:
		int    Helper_GetItem(uint pos, StateItem & rItem) const;

		SVerT Ver;
		TSArray <PPUserProfileCore::StateItem_Internal> L;
	};

	StateBlock StB;
};

class PPViewUserProfile : public PPView {
public:
	struct BrwHdr {
		long   SessID;
		int64  SeqID;
		long   Flags;
		char   SessUUID_s[40];
	};
	PPViewUserProfile();
	~PPViewUserProfile();
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(UserProfileViewItem * pItem);
private:
	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int LoadFromFile(PPIDArray * pIdList);
	int RemoveAll();

	int    ParserBusy;
	TSArray <PPUserProfileCore::UfpDbEntry> UfpDbList;
	PPUserProfileCore Tbl;
	UserProfileFilt Filt;
};
//
// PPViewJobPool
//
class JobFilt : public PPBaseFilt {
public:
	JobFilt();
	enum {
		fForAllDb = 0x00000001L
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   CmdId;
	long   Flags;
	long   ReserveEnd;       // @anchor
};

struct JobViewItem {
	PPID   ID;
	char   Name[64];
	char   DbSymb[64];
	char   Dtr[64];             // План повторений запуска
	long   Flags;              //
	long   EstimatedTime;
	LDATETIME LastRunningTime;
	long   Ver;
	char   NextJob[64];
	char   Symb[20];
};

class PPViewJob : public PPView {
public:
	PPViewJob();
	~PPViewJob();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt *);
	int    InitIteration();
	int    FASTCALL NextIteration(JobViewItem *);
	int    AddItem(PPID *);
	int    EditItem(PPID);
	int    DeleteItem(PPID);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	static int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void   PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int    Print(const void *);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
	int    CheckForFilt(PPJob & rJob);
	int    MakeList();
	int    SavePool();
	int    LoadPool();
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	int    IsChanged;
	TSArray <JobViewItem> List;
	StrAssocArray CmdSymbList;
	JobFilt Filt;
	PPJobMngr Mngr;
	PPJobPool * P_Pool;
};
//
//
//
class UserMenuFilt : public PPBaseFilt {
public:
	UserMenuFilt();
	enum {
		kMenu = 1,
		kDesktop = 2
	};
	uint8  ReserveStart[64]; // @anchor
	long   Kind;
	long   Flags;
	long   Reserve;          // @anchor
	SString DbSymb;
};

struct UserMenuViewItem { // @flat
	enum {
		fReservedMenu = 0x0001
	};
	PPID   ID;
	S_GUID Uuid;
	long   Kind;
	long   Flags;
	char   DbSymb[64];
	char   Name[128];
};

class PPViewUserMenu : public PPView {
public:
	struct BrwItem : public UserMenuViewItem { // @flat
	};
	PPViewUserMenu();
	~PPViewUserMenu();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    CmpSortIndexItems(PPViewBrowser * pBrw, const BrwItem * pItem1, const BrwItem * pItem2);
private:
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    MakeList(PPViewBrowser * pBrw);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	//
	// Descr: Интерактивное создание нового элемента.
	// ARG(kind        IN): Категория нового элемента. Если kind == cmdgrpcUndef то
	//   пользователю предлагается выбрать что создавать: меню или рабочий стол.
	// ARG(rSampleUuid IN): Если !IsZero(), то новый элемент создается по образцу элемента с этим идентификатором.
	//   Если по заданному идентификатору образец не найден, то - ошибка.
	// ARG(sampleId    IN): В случае, если необходимо создать новое меню по образцу зарезервированного
	//   меню (хранящегося в ресурсах и не имеющего UUID'а), то этот идентификатор будет рассматриваться как ссылка на образец.
	// ARG(pUuid      OUT): UUID созданного элемента.
	//
	int    AddItem(PPCommandGroupCategory kind, const S_GUID & rSampleUuid, long sampleId, S_GUID * pUuid);
	int    EditItem(const S_GUID & rUuid);
	int    DeleteItem(const S_GUID & rUuid);
	PPCommandGroup * GetEntryByUuid(const S_GUID & rUuid);
	UserMenuFilt Filt;
	SArray * P_DsList;
	PPCommandGroup * P_MenuList;
	PPCommandGroup * P_DesktopList;
};
//
// @ModuleDecl(PPMail)
//
#define WIN32_LEAN_AND_MEAN
// @v11.8.4 #define ORDEXT            ".ord"
// @v11.8.4 (unused) #define MAILHDREXT        ".mhd"
#define SUBJSIZE          96L
#define SUBJECTFRONTOL    "ATOL_RMK_CHANGE_"
#define MIN_INET_PSW_SIZE 1

#define POP3CMD_SUBJECT 3L
#define POP3CMD_RETR    4L
#define POP3CMD_QUIT    5L
#define POP3CMD_STAT    6L
#define POP3CMD_DELE    7L
#define POP3CMD_LIST    8L
#define POP3CMD_TOP     9L

#define SMTPCMD_MAIL   32L
#define SMTPCMD_RCPT   33L
#define SMTPCMD_DATA   34L
#define SMTPCMD_RSET   36L
#define SMTPCMD_AUTH   37L
#define SMTPCMD_STRING 38L

class PPMailFile {
public:
	PPMailFile(const char * pFileName = 0);
	~PPMailFile();
	int    Open(const char * pFileName);
	int    Close();
	const  char * ReadLine();
	const  SMailMessage & GetHeader() const { return Msg; }
	int    SaveAttachment(const char * pAttachName, const char * pDestPath);
private:
	int    ReadHeader();
	int    ReadDisposition(SMailMessage & rMsg, SMailMessage::ContentDispositionBlock * pD);
	int    SkipHeader();
	int    GetField(const char * pLine, uint fldID, SString & rBuf) const;
	int    GetFieldTitle(uint id, SString & rBuf) const;
	int    ProcessMsgHeaderLine(const char *);
	//
	// ARG(start IN): 0 - pure boundary, 1 - start boundary, 2 - finish boundary
	//
	int    IsBoundaryLine(int start) const;

	SMailMessage Msg;
	size_t LineBufSize;
	char * P_LineBuf;
	char * P_FieldStrBuf; // PPTXT_MAILFILEDS
	FILE * Stream;
};

class PPMail {
public:
	PPMail(const PPInternetAccount *);
	~PPMail();
	//
	// Descr: Инициирует запись учетной записи.
	//   Не реализует никаких действий по соединению.
	//
	void   Init(const PPInternetAccount *);
	int    Connect();
	int    Disconnect();
protected:
	virtual int FinalizeServerUrl(InetUrl & rUrl) = 0;
	int    PutLine(const char *);
	int    GetLine(SString & rBuf);
	int    GetFieldTitle(uint id, SString & rBuf) const;
	int    GetField(const char * pLine, uint fldID, SString & rBuf) const;
	int    PutField(uint fldId, const char * pVal, SString & rResult) const;
	//MailSession * P_Sess;
	SMailClient Sess;
	PPInternetAccount MailAcc;
private:
	char * P_FieldStrBuf; // PPTXT_MAILFILEDS
};

class PPMailPop3 : public PPMail {
public:
	explicit PPMailPop3(const PPInternetAccount *);
	int    Login();                                                // cmd USER & PASS
	int    GetStat(long * pCount, long * pSize);                   // cmd STAT
	int    GetMsgInfo(long msgN /* 1.. */, SMailMessage *);           // cmd TOP
	int    GetMsg(long msgN, SMailMessage *, const char * pFileName, MailCallbackProc, const IterCounter & msgCounter); // cmd RETR
	int    DeleteMsg(long msgN);                                   // cmd DELE
	int    SaveAttachment(const char * pMsgFileName, const char * pAttachName, const char * pDestPath);
protected:
	virtual int FinalizeServerUrl(InetUrl & rUrl);
private:
	int    SendCmd(long cmd, const char * pAddedInfo, long addedInfo, SString & rReplyBuf);
	int    ProcessMsgHeaderLine(const char * pLine, SMailMessage * pMsg);
	//int    Logged;
};

int SendMailWithAttach(const char * pSubj, const char * pPath, const char * pLetter, const char * pMail, PPID accountID);
int SendMail(const char * pSubj, const char * pLetter, const char * pMail, PPID mailAccId, SStrCollection * pFilesList, PPLogger * pLogger);
int SendMail(const char * pSubj, const char * pLetter, StrAssocArray * pMailList, PPInternetAccount * pAccount, SStrCollection * pFilesList, PPLogger * pLogger);
//
//
//
class PPPosProtocol {
public:
	friend class ACS_PAPYRUS_APN;

	struct RouteBlock {
		RouteBlock();
		void   Destroy();
		bool   IsEmpty() const;
		//
		// Descr: Функция сравнивает this с rS по критериям равенства Uuid или, если Uuid пустой,
		//   по равенству Code (если не пустой).
		//   Если и Uuid и Code у обоих экземпляров пустые, то экземпляры считаются эквивалентными.
		//
		bool   FASTCALL IsEq(const RouteBlock & rS) const;

		S_GUID Uuid;
		SString System;
		SString Version;
		SString Code;
	};
	class QueryBlock { // @flat
	public:
		QueryBlock();
		void   SetQueryCSessionLast();
		void   SetQueryCSessionCurrent();
		void   SetQueryCSessionByID(PPID sessID);
		void   SetQueryCSessionByNo(long sessN);
		void   SetQueryCSessionByDate(const DateRange & rPeriod);
		void   SetQueryRefs();
		void   SetQueryTest();
        enum {
        	qUnkn = 0, // Не известный тип запроса
			qTest = 1, // Тестовый запрос для проверки обмена данными
        	qCSession, // Запрос кассовых сессий
        	qRefs,     // Запрос справочников
        };
        enum {
        	fCSessN       = 0x0001, // CSess - номер сессии
        	fCSessLast    = 0x0002,
        	fCSessCurrent = 0x0004
        };
        int    Q;
        long   Flags;
		DateRange Period;
		PPID   CSess;   // Идентификатор или номер сессии (в зависимости от флага fCSessN)
		PPID   ObjType; // Если Q==qRef, то здесь может быть указан тип объекта ()
	private:
		void   FASTCALL Init(int q);
	};
	struct QueryProcessBlock {
		QueryProcessBlock();
		PPID   PosNodeID;
		RouteBlock R;
		TSVector <QueryBlock> QL;
	};
	class ProcessInputBlock {
	public:
		friend class PPPosProtocol;

		enum {
			fProcessRefs        = 0x0001, // Акцептировать справочники в базу данных
			fProcessSessions    = 0x0002, // Акцептировать кассовые сессии (P_ACS != 0)
			fProcessQueries     = 0x0004, // Ответить на запросы
			fBackupProcessed    = 0x0008, // Сделать резервную копию обработанных файлов
			fRemoveProcessed    = 0x0010, // Удалить обработанные файлы
			fStoreReadBlocks    = 0x0020, // Если установлен, то все ReadBlock считанные в пределах одного вызова
				// ProcessInput сохраняются во внутренней коллекции (P_RbList).
			fSilent     = 0x0040  // Не выдавать на экран уведомления и сообщения (при исполнении фоновыв потоком или на сервере)
		};
		ProcessInputBlock();
		ProcessInputBlock(PPAsyncCashSession * pAcs);
		~ProcessInputBlock();
		void   FASTCALL SetOuterProcessedFileList(SymbHashTable * pT);
		int    FASTCALL CheckFileForProcessedFileList(const SDirEntry & rDe);
		int    FASTCALL RegisterProcessedFile(const SFileEntryPool::Entry & rFe);
		const  void * GetStoredReadBlocks() const;
		long   Flags;            // IN
		PPID   PosNodeID;        // IN Кассовый узел, запрашивающий вызов обработки входных данных.
		uint   SessionCount;     // OUT
		DateRange SessionPeriod; // OUT
		TSCollection <QueryProcessBlock> QpBlkList; // OUT
	private:
		void   Helper_Construct();
		void * P_RbList; // Список ReadBlock считанных в процессе вызова ProcessInput. Так как
			// структура PPPosProtocol::ReadBlock приватная и определена ниже, используем трюк с opaque-указателем.
			// Фактически, это TSCollection <PPPosProtocol::ReadBlock>
		PPAsyncCashSession * P_ACS;
		SymbHashTable * P_ProcessedFiles; // @notowned
	};

	static int EditPosQuery(TSVector <PPPosProtocol::QueryBlock> & rQList);

	PPPosProtocol();
	~PPPosProtocol();
    //int    SendReferences(PPID nodeID, int updOnly, PPID sinceDlsID, DeviceLoadingStat * pDls, const char * pFileName);
	int    SendQuery(PPID posNodeID, const PPPosProtocol::QueryBlock & rQ);
	//
	int    ExportDataForPosNode(PPID nodeID, int updOnly, PPID sinceDlsID);
	int    ExportPosSession(const PPIDArray & rSessList, PPID srcPosNodeID, const PPPosProtocol::RouteBlock * pSrc, const PPPosProtocol::RouteBlock * pDestination);
	int    ProcessInput(ProcessInputBlock & rPib);
private:
	friend DECL_CMPFUNC(ObjBlockRef_);

	struct WriteBlock {
		WriteBlock();
		~WriteBlock();
		void   Destroy();

		PPID   LocID;
		xmlTextWriter * P_Xw;
		SXml::WDoc * P_Xd;
		SXml::WNode * P_Root;
		S_GUID FileUUID;
		LDATETIME FileDtm;
		PPIDArray NeededQkList;
		PPIDArray UsedQkList;
		AsyncCashGoodsIterator * P_Acgi; // @notowned
	};
	enum {
		obUnkn = 0,
		obGoods = 1,
		obGoodsGroup,
		obPerson,
		obGoodsCode,
		obSCardSeries,
		obSCard,
		obParent,
		obQuotKind,
		obQuot,
		obSource,
		obDestination,
		obCSession,
		obCCheck,
		obCcLine,
		obPosNode,
		obQuery,
		obLot,
		obPayment,
		obUnit,
		obAddress // @v10.7.5
	};

	struct ObjectBlock { // @flat
		ObjectBlock();
		enum {
			fReady   = 0x0001,
			fRefItem = 0x0002  // Блок создан как внутренняя ссылка. По такому блоку объект следует создавать
				// только после того, как были перебраны блоки не имеющие такого флага.
		};
		long   Flags_;
		long   ID;       // Идентификатор объекта в источнике данных
		long   NativeID; // Идентификатор объекта в нашей базе данных
		uint   NameP;
	};
	struct ParentBlock { // @flat
        ParentBlock();

        long   ID;
        uint   CodeP;
	};
	struct GoodsCode { // @flat
		GoodsCode();

		uint   GoodsBlkP;
		uint   CodeP;
        long   Pack;
		long   BarcodeType; // @v11.0.0
	};
	struct QuotBlock { // @flat
		QuotBlock();
		enum {
			fGroup  = 0x0001 // Котировка относится к товарной группе (иначе - к товару)
		};
		long   BlkFlags; // Флаги, определяющие специфику блока (не проецируются на флаги котировок)
		union {
			uint   GoodsBlkP;
			uint   GoodsGroupBlkP;
		};
		uint   QuotKindBlkP;
		long   MinQtty;
		DateRange Period;
		double Value;
		long   QuotFlags;
	};
	struct PosNodeBlock : public ObjectBlock { // @flat
		PosNodeBlock();
        uint   CodeP; // Символьное представление кода узла
        long   CodeI; // Целочисленное значение кода узла
		S_GUID Uuid;  // GUID кассового узла
	};
	struct QuotKindBlock : public ObjectBlock { // @flat
        QuotKindBlock();
		uint   CodeP;
		int16   Rank;
		uint16  Reserve;
		TimeRange TimeRestriction;
		DateRange Period;
		RealRange AmountRestriction;
	};
	struct UnitBlock : public ObjectBlock { // @flat
		UnitBlock();
		uint   CodeP;
		uint   SymbP;
		uint   PhUnitBlkP; // Ссылка на вложенную физическую единицу (для PHUNIT в блоке товара)
		long   UnitFlags;
		PPID   BaseId; // Идентификатор базовой единицы
		double BaseRatio;
		double PhRatio;   // Соотношение вложенной физической единицей (для PHUNIT в блоке товара)
	};
	struct GoodsBlock : public ObjectBlock { // @flat
		enum {
			spcfUnlim  = 0x0001, // (goodstype)
			spcfLookBackPrices = 0x0002, // (goodstype)
			spcfDefault        = 0x0004, // Признак единственного товара, используемого в качестве default при продаже по цене.
			spcfMarked = 0x0008  // @v10.7.3 (goodstype)
		};
		GoodsBlock();
		PPID   ParentBlkP;
		long   InnerId;
		long   GoodsFlags;   //
		long   SpecialFlags; // Специальные флаги, определяющие признаки товаров,
			// не характерные для собственно товара (что-то определяется типом, что-то классом, что-то конфигурациями).
		uint   UnitBlkP;     //
		uint   PhUnitBlkP;   //
		double PhUPerU;      //
		double Price;
		double Rest;
		long   AlcoProof;    // @fixedpoint2 Для алкоголя - крепость в %об
		long   VatRate;      // @fixedpoint2 Ставка НДС в процентах
		long   SalesTaxRate; // @fixedpoint2 Ставка налога с продаж в процентах
		//
		// Следующие 2 ИД необходимы на этапе разрешения элемента товара. На одной фазе они
		// приобретают временные значения, ссылающиеся на специальные контейнеры, затем -
		// становятся идентификаторами в акцептируемой БД.
		//
		long   TaxGrpID;     //
		long   GoodsTypeID;  //
		uint   AlcoRuCatP;   // Код категории алкогольной продукции по версии РАР РФ
		long   ChZnProdType; // (goodstype)
	};
	struct GoodsGroupBlock : public ObjectBlock { // @flat
		GoodsGroupBlock();
		uint   CodeP;
		PPID   ParentBlkP;
	};
	struct LotBlock : public ObjectBlock { // @flat
		LotBlock();

		uint   GoodsBlkP;
		LDATE  Dt;
		LDATE  Expiry;
		double Cost;
		double Price;
		double Rest;
		uint   SerialP;
	};
	struct PersonBlock : public ObjectBlock { // @flat
		PersonBlock();
		uint   CodeP;
	};
	struct SCardSeriesBlock : public ObjectBlock { // @flat "scardseries"
		SCardSeriesBlock();
		uint   RefP;     // Позиция указателя на блок в ReadBlock::RefList. Используется для быстрого поиска ссылки.
		uint   CodeP; // code
		uint   QuotKindBlkP;
	};
	struct SCardBlock : public ObjectBlock { // @flat
		SCardBlock();
		uint   CodeP;
		uint   OwnerBlkP;
		uint   SeriesBlkP;
		uint   PhoneP;
		double Discount;
		double FixedBonus;
	};
	struct CSessionBlock : public ObjectBlock { // @flat
		CSessionBlock();
        long   Code;
        uint   PosBlkP;
        LDATETIME Dtm;
	};
	struct AddressBlock : public ObjectBlock { // @flat
		AddressBlock();
		S_GUID Uuid;  // Проецируется в базу данных как тег PPTAG_LOC_UUID
		uint   CCheckBlkP; // Ссылка на чек, которому принадлежит
		uint   CityP;
		uint   ZipP;
		uint   TextP;
		uint   PhoneP;
		uint   EMailP;
		uint   ContactP;
	};
	struct CCheckBlock : public ObjectBlock { // @flat
		CCheckBlock();
		long   Code;
		long   CcFlags;   // CCHKF_XXX Значения флагов чека, принимаемые из общего тега <flags>
		long   SaCcFlags; // CCHKF_XXX Значения флагов чека, принимаемые из специализированных тегов. Например <return>
			// Необходимо проверить, что бы CcFlags и SaCcFlags не конфликтовали
		long   CTableN;
		long   GuestCount;
		uint   CSessionBlkP;
		uint   AddrBlkP;
		uint   AgentBlkP;
		double Amount;
		double Discount;
		LDATETIME CreationDtm;
		LDATETIME Dtm;
		uint   SCardBlkP;
		uint   MemoP;
	};
	struct CcLineBlock : public ObjectBlock { // @flat
		CcLineBlock();
		long   CcID;
        long   RByCheck; // (id)
        long   CclFlags;
        long   DivN;
        long   Queue;
        uint   GoodsBlkP; // ware
        double Qtty;
        double Price;
        double Discount;
        double SumDiscount;
		double Amount;
        uint   CCheckBlkP;
        uint   SerialP;
        uint   EgaisMarkP;
		uint   ChZnMarkP; // @v10.7.3
		uint   RemoteProcessingTaP; // @v10.7.3
	};
	struct CcPaymentBlock : public ObjectBlock { // @flat
		CcPaymentBlock();
		long   CcID;
		long   PaymType; // CCAMTTYP_XXX
		double Amount;
		uint   SCardBlkP;
		uint   CCheckBlkP;
	};
	struct RouteObjectBlock : public ObjectBlock { // @flat
		RouteObjectBlock();

		int    Direction; // 0 - undef, 1 - source, 2 - destination
		uint   SystemP;
		uint   VersionP;
		uint   CodeP;
        S_GUID Uuid;
	};
	struct ObjBlockRef { // @flat
		ObjBlockRef(int t, uint pos);
		int    Type;
		uint   P;
	};
	struct ReadBlock : SStrGroup {
		ReadBlock();
		~ReadBlock();
		void   Destroy();
		//
		// Descr: Копирует структуры, необходимые для анализа данных после разбора xml-потока
		//
		ReadBlock & FASTCALL Copy(const ReadBlock & rS);
		template <class B> int Helper_CreateItem(TSVector <B> & rList, int type, uint * pRefPos)
		{
			B new_blk;
			return Implement_CreateItem(rList, &new_blk, type, pRefPos);
		}
		int    CreateItem(int type, uint * pRefPos);
		void * GetItem(uint refPos, int * pType) const;
		void * GetItemWithTest(uint refPos, int type) const;
		int    SearchRef(int type, uint pos, uint * pRefPos) const;
		//void   SortRefList();
		int    SearchAnalogRef_QuotKind(const QuotKindBlock & rBlk, uint exclPos, uint * pRefPos) const;
		int    SearchAnalogRef_SCardSeries(const SCardSeriesBlock & rBlk, uint exclPos, uint * pRefPos) const;
		const  QuotKindBlock * FASTCALL SearchAnalog_QuotKind(const QuotKindBlock & rBlk) const;
		//
		// Descr: Находит входящий аналог блока персоналии rBlk с идентифицированным
		//   NativeID.
		// Returns:
		//   Указатель на найденный блок-аналог
		//   Если поиск оказался безуспешным, то возвращает 0
		//
		const  PersonBlock * FASTCALL SearchAnalog_Person(const PersonBlock & rBlk) const;
		int    GetRouteItem(const RouteObjectBlock & rO, RouteBlock & rR) const;
		int    IsTagValueBoolTrue() const;

		xmlParserCtxt * P_SaxCtx;
		//
		// Descr: Флаги состояния процесса чтения
		//
		enum {
			stHeaderOccured = 0x0001,
			stError = 0x0002,
			stRefsOccured   = 0x0004,
			stQueryOccured  = 0x0008,
			stCSessOccured  = 0x0010
		};
		//
		// Descr: Значения поля Phase
		//
		enum {
			phUnkn       = 0, // Не определенная фаза
			phPreprocess = 1, // Предварительная обработка (чтение заголовка, источника, получателя и списка присутствующих объектов)
			phProcess    = 2  // Полная обработка
		};
		int    State; // stXXX Состояние процесса чтения
		int    Phase; // phXXX Фаза обработки входящего файла

		const SymbHashTable * P_ShT; // Таблица символов, полученная вызовом PPGetStringHash(int)
		SString TempBuf; // @allocreuse
		SString TagValue;
		SString SrcFileName;
		S_GUID  SrcFileUUID;  // Uuid файла, считанный из заголовочной части xml-сообщения (file/uuid)
		LDATETIME SrcFileDtm; // Время создания файла, считанное из заголовочной части xml-сообщения (file/timestamp)
		TSStack <int> TokPath;
		TSStack <uint> RefPosStack; //
		StrAssocArray AttrList; // @v11.0.0 Список атрибутов текущего тега. Сбрасывается и заполняется функцией StartElement
		TSVector <RouteObjectBlock> SrcBlkList;
		TSVector <RouteObjectBlock> DestBlkList;
		TSVector <GoodsBlock> GoodsBlkList;
		TSVector <GoodsGroupBlock> GoodsGroupBlkList;
		TSVector <LotBlock> LotBlkList;
		TSVector <GoodsCode> GoodsCodeList;
		TSVector <QuotKindBlock> QkBlkList;
		TSVector <UnitBlock> UnitBlkList;
		TSVector <QuotBlock> QuotBlkList;
		TSVector <PersonBlock> PersonBlkList;
		TSVector <SCardSeriesBlock> ScsBlkList;
		TSVector <SCardBlock> SCardBlkList;
		TSVector <ParentBlock> ParentBlkList; // Список абстрактных блоков, идентифицирующих родительских элементов объектов
		TSVector <PosNodeBlock> PosBlkList;
		TSVector <CSessionBlock> CSessBlkList;
		TSVector <CCheckBlock> CcBlkList;
		TSVector <CcLineBlock> CclBlkList;
		TSVector <CcPaymentBlock> CcPaymBlkList;
		TSVector <QueryBlock> QueryList;
		TSVector <ObjBlockRef> RefList;
		TSVector <AddressBlock> AddressList;
	private:
		int    Implement_CreateItem(SVector & rList, const void * pNewBlk, int type, uint * pRefPos);
	};
	struct PosNodeUuidEntry {
		S_GUID Uuid;
		PPID   PosNodeID;
	};
	struct PosNodeISymbEntry {
		long   ISymb;
		PPID   PosNodeID;
	};
	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);
	static void Scb_Characters(void * ptr, const uchar * pC, int len);
	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    Characters(const char * pS, size_t len);
	void   SaxStop();
	//
	// Descr: Разбирает входящий документ из файла pFileName и складывает данные в объект RdB.
	//   После разбора данные в RdB могут быть импортированы.
	//
	int    SaxParseFile(const char * pFileName, int preprocess, int silent);
	int    AcceptData(PPID posNodeID, int silent);
    void   DestroyReadBlock();
	const  PPPosProtocol::ReadBlock & GetReadBlock() const { return RdB; }
	struct ResolveGoodsParam {
		ResolveGoodsParam();
		void   SetupGoodsPack(const PPPosProtocol::ReadBlock & rRB, const GoodsBlock & rBlk, PPGoodsPacket & rPack) const;
		PPID   DefParentID;
		PPID   DefUnitID;
		PPID   LocID;
		PPID   SrcArID; // Статья аналитического учета, соответствующая источнику данных
		PPID   AlcGdsClsID; // Класс алкогольных товаров
		int    AlcProofDim;  // Размерность класса алкогольных товаров, отвечающая за крепость
		int    AlcVolumeDim; // Размерность класса алкогольных товаров, отвечающая за емкость
		int    AlcRuCatDim;  // Размерность класса алкогольных товаров, отвечающая за категорию продукции
		PPGdsClsPacket GcPack;
	};
	int    ResolveGoodsBlock(const GoodsBlock & rBlk, uint refPos, int asRefOnly, const ResolveGoodsParam & rP, PPID * pNativeID);
	const  SString & FASTCALL EncText(const char * pS);
	const  SString & FASTCALL CorrectAndEncText(const char * pS);
	uint   PeekRefPos() const;
	void * PeekRefItem(uint * pRefPos, int * pType) const;
	int    Helper_GetPosNodeInfo_ForInputProcessing(const PPCashNode * pCnRec, TSVector <PosNodeISymbEntry> & rISymbList, TSVector <PosNodeUuidEntry> & rUuidList);
	void   FASTCALL Helper_AddStringToPool(uint * pPos);
	int    FASTCALL Helper_PushQuery(int queryType);
	QueryBlock * Helper_RenewQuery(uint & rRefPos, int queryType);
	int    Accept_Person(PPPosProtocol::PersonBlock & rBlk, PPID kindID);
	int    CreateGoodsGroup(const GoodsGroupBlock & rBlk, uint refPos, int isFolder, PPID * pID);
	int    CreateParentGoodsGroup(const ParentBlock & rBlk, int isFolder, PPID * pID);
	int    InitSrcRootInfo(PPID posNodeID, PPPosProtocol::RouteBlock & rInfo);
	//int    SelectOutFileName(PPID srcPosNodeID, const char * pInfix, StringSet & rResultSs);
	int    StartWriting(const char * pFileName, PPPosProtocol::WriteBlock & rB);
	int    FinishWriting(WriteBlock & rB);
	int    WriteGoodsInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashGoodsInfo & rInfo, const PPQuotArray * pQList);
	int    WriteGoodsGroupInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashGoodsGroupInfo & rInfo, const PPQuotArray * pQList);
	int    WriteSCardInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashSCardInfo & rInfo);
	int    WritePersonInfo(WriteBlock & rB, const char * pScopeXmlTag, PPID codeRegTypeID, const PPPersonPacket & rPack);
	int    WriteQuotInfo(WriteBlock & rB, const char * pScopeXmlTag, PPID parentObj, const PPQuot & rInfo);
	int    WriteQuotKindInfo(WriteBlock & rB, const char * pScopeXmlTag, const PPQuotKind & rInfo);
	int    WriteRouteInfo(WriteBlock & rB, const char * pScopeXmlTag, const RouteBlock & rInfo);
	int    WritePosNode(WriteBlock & rB, const char * pScopeXmlTag, const PPCashNode & rInfo);
	int    WriteCSession(WriteBlock & rB, const char * pScopeXmlTag, const CSessionTbl::Rec & rInfo);
	int    TransportFileOut(const SString & rOutFileName, PPID srcPosNodeID, const char * pInfix);
	int    PreprocessInputSource(PPID cnID, const char * pSrc, StringSet & rSs, StrAssocArray & rRemoteAssocList);
	int    PreprocessFtpDescriptor(const SString & rDescriptor, PPID posNodeID, PPInternetAccount & rInaRec, SString & rFtpExtPath);

	SString EncBuf;
	PPObjPerson PsnObj;
	PPPosProtocol::ReadBlock RdB;
	PPObjBill * P_BObj;
	PPObjGoods GObj;
	PPObjGoodsGroup GgObj;
	PPObjQuotKind QkObj;
	PPObjCSession CsObj;
	PPObjSCard ScObj;
	PPObjCashNode CnObj;
};
//
//
//
class AlcoDeclRuFilt : public PPBaseFilt {
public:
	AlcoDeclRuFilt();
	enum {
		eqxOrder    = 0x0001, // @reserve
		eqxShowMode = 0x0002
	};
	int    IsEqualExcept(const AlcoDeclRuFilt & rS, long flags) const;
	void   SetParentView(PPViewAlcoDeclRu * pView);
	PPViewAlcoDeclRu * GetParentView();

	enum {
		fOnlyBeer        = 0x0001,
		fOnlyNonBeerAlco = 0x0002,
		fShowAsRcpt      = 0x0004, // Показывать таблицу приходов (иначе - движение)
		fDetail  = 0x0008  // Специальный вариант детализации для анализа содержимого строк отчета
	};
	char   ReserveStart[104]; // @anchor
private:
	uint64 ParentViewPtr;     // @v11.0.7 Указатель на родительский объект PPViewAlcoDeclRu. Используется при отображении детализации.
public:
	PPID   ManufID;           // @v11.0.7 For detail
	PPID   DivID;             // @v11.0.7 For detail
	PPID   MainOrgID;         // ->Person.ID Главная организация. Если 0, то из текущего состояния //
	uint32 CorrectionNo;      // Номер корректировки. Если ноль, то - основная выгрузка, иначе - корректирующая //
	DateRange Period;         //
	long   Flags;
	long   Reserve;           // @anchor Заглушка для отмера "плоского" участка фильтра
	ObjIdListFilt DivList;    // Список подразделений
	SString AlcoCodeList;     // Список символов видов алкогольной продукции, которыми следует ограничить отчет
};

struct AlcoDeclRuViewItem {
	struct SupplEntry {
		LDATE  Dt;
		char   InvcCode[32];
		char   CLB[32];      // ГТД
		double Qtty;         // ДАЛ
	};
	struct MovEntry {
		double StockBeg;  // П100000000006 Остаток на начало отчетного периода (дал)
		double StockEnd;  // П100000000020 Остаток на конец отчетного периода (дал)
		double RcptManuf; // П100000000007 Поступление - закупки от организаций- производителей (дал)
		double RcptWhs;   // П100000000008 Поступление - закупки от организаций оптовой торговли (дал)
		double RcptImp;   // П100000000009 Поступление - закупки по импорту (дал)
		// П100000000010 Поступление - закупки итого (дал)
		double SaleRet;   // П100000000011 Поступление - возврат от покупателей (дал)
		double RcptEtc;   // П100000000012 Прочие поступления (дал)
		double RcptIntr;  // П100000000013 Поступление - перемещение внутри одной организации (дал)
		// П100000000014 Поступление - всего (дал)
		double ExpRetail; // П100000000015 Расход - объем розничной продажи (дал)
		double ExpEtc;    // П100000000016 Прочий расход (дал)
		double SupplRet;  // П100000000017 Возврат поставщику (дал)
		double ExpIntr;   // П100000000018 Расход - перемещение внутри одной организации (дал)
		// П100000000019 Расход всего (дал)
	};
	char   AlcoCode[16];
	PPID   ManufID; // Импортер/производитель
	int    ItemKind;
	SupplEntry SE;
	MovEntry   ME;
};

class PPViewAlcoDeclRu : public PPView {
public:
	enum {
		kUndef = 0,
		kReceipt,
		kReceiptRet,
		kMov
	};
	PPViewAlcoDeclRu();
	~PPViewAlcoDeclRu();
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	virtual int EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    FASTCALL NextIteration(AlcoDeclRuViewItem *);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw); // really private
	struct InnerRcptEntry {
		InnerRcptEntry();
		PPID   DivID;
		PPID   GoodsID;
		long   AlcoCodeId;
		int16  ItemKind; // 0 - receipt, 1 - suppl return
		int16  Reserve;
		PPID   ManufID;
		PPID   SupplID;
		PPID   BillID;
		LDATE  BillDt;
		uint   ClbP;
		double Qtty;
	};
private:
	struct InnerMovEntry {
		InnerMovEntry();
		double CalcBalance() const;
		int    Adjust();
		PPID   DivID;
		PPID   GoodsID;
		long   AlcoCodeId;
		int16  ItemKind; // 0
		int16  Reserve;
		PPID   ManufID;
		double StockBeg;
		double StockEnd;
		double RcptManuf;
		double RcptWhs;
		double RcptImp;
		double SaleRet;
		double RcptEtc;
		double RcptIntr;
		double ExpRetail;
		double ExpEtc;
		double SupplRet;
		double ExpIntr;
	};
	struct DetailEntry {
		DetailEntry();
		//
		// Descr: Возвращает true если операция является расходной
		//
		bool   IsNegativeOp() const;
		enum {
			opcatStockBeg = 1,
			opcatStockEnd,
			opcatRcptManuf,
			opcatRcptWhs,
			opcatRcptImp,
			opcatSaleRet,
			opcatRcptEtc,
			opcatRcptIntr,
			opcatExpRetail,
			opcatExpEtc,
			opcatSupplRet,
			opcatExpIntr
		};
		PPID   DivID;
		PPID   AlcoCodeId;
		PPID   ManufID;
		PPID   SupplID;
		PPID   GoodsID;
		PPID   BillID;
		LDATE  Dt;         // Дат
		uint   OpCat;      // opcatXXX Категория операции
		double Qtty;       // Количество (дал)
		double Rest;       // Остаток после операции (дал)
	};
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    FASTCALL _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	void   ProcessStock(int startOrEnd, PPID divID, const ObjIdListFilt & rWhList, const PPIDArray & rGoodsList);
	uint   GetMovListItemIdx(PPID divID, long alcoCodeIdent, PPID manufID);
	long   GetAlcoCodeIdent(const char * pCode);
	int    GetAlcoCode(long id, SString & rBuf) const;
	void   GetDivisionList(PPIDArray & rList) const;
	void   GetAlcoCodeList(PPID divID, PPIDArray & rList) const;
	void   GetRcptChunkForExport(PPID divID, long alcoCodeId, PPID manufID, PPID supplID, TSVector <InnerRcptEntry> & rList) const;
	void   GetManufList(PPID divID, long alcoCodeId, PPIDArray & rList) const;
	void   GetSupplList(PPID divID, long alcoCodeId, PPID manufID, PPIDArray & rList) const;
	int    Diagnose();
	int    Export();
	enum {
		stOnceInited = 0x0001 // Объект как минимум один раз был инициализирован вызовом Init_
	};
	long   State;         // @viewstate
	AlcoDeclRuFilt Filt;
	PrcssrAlcReport Arp;
	PPIDArray GoodsList; // Список товаров, по которым строится отчет
	StrAssocArray AlcoCodeList; // Список соответствий алкогольных кодов суррогатным целочисленным идентификаторам
	SStrGroup StrPool;
	TSArray <InnerRcptEntry> RcptList;
	TSArray <InnerMovEntry> MovList;
	TSArray <DetailEntry> DetailList;
	enum {
		stNotFound   = 0x0001,
		stInnInv     = 0x0002,
		stInnAbs     = 0x0004,
		stKppInv     = 0x0008,
		stKppAbs     = 0x0010,
		stAddrAbs    = 0x0020,
		stCeoAbs     = 0x0040,
		stCAcctntAbs = 0x0080,
		stEmailAbs   = 0x0100,
		stPhoneAbs   = 0x0200
	};
	long   MainOrgStatus; // Состояние главной организации
	LAssocArray DivStatusList;   // Список состояний подразделений
	LAssocArray ManufStatusList; // Список состояний производителей/импортеров
	LAssocArray SupplStatusList; // Список состояний поставщиков
	PPObjBill * P_BObj;
};
//
// @ModuleDecl(DL200)
//
#define DL200_SIGNATURE  0x42324C44L // "DL2B"
#define DL200_VERSION    1

typedef uint16 dl2cit;

// CI - Calculated Item

#define DL2CIT_CONST_FIRST_ 1
#define DL2CIT_REAL         1 // Вещественное число
#define DL2CIT_INT          2 // Целое число
#define DL2CIT_DATE         4 // Дата
#define DL2CIT_TIME         5 // Время //
#define DL2CIT_PERIOD       6 // Период
#define DL2CIT_STRING       7 // Строка
#define DL2CIT_CONST_LAST_ 20

#define DL2CIT_METAVAR     21 // Метапеременная //
#define DL2CIT_ACC         22 // Переменная бух счета
#define DL2CIT_SCORE       23 // Показатель. Расчетная формула для вычисления показателей,
	// отличных от бухгалтерских счетов (тованые остатки, суммы по документам, чекам и т.д.)

#define DL2CIT_OP_FIRST_  101
#define DL2CIT_OP_UPLUS   101 // Unary +
#define DL2CIT_OP_UMINUS  102 // Unary -
#define DL2CIT_OP_PLUS    103 // Binary +
#define DL2CIT_OP_MINUS   104 // Binary -
#define DL2CIT_OP_MULT    105 // Binary *
#define DL2CIT_OP_DIV     106 // Binary /
#define DL2CIT_OP_LAST_  1000

#define DL2CIT_FUNC      1001
//
//
//
// @mainorg     Полное наименование главной организации
// @mainorgaddr Адрес главной организации
// @mainorginn  ИНН
// @mainorgokpo ОКПО
// @director    Директор
// @accountant  Гл. бухгалтер
// @dbname      User-friendly наименование базы данных
// @dbsymb      Символ базы данных
//
//
//
struct MetavarDecl {
	long   ID;         // Generated macro PPMETAVAR_XXX [XXX = strupr(Name)]
	dl2cit Type;       // DL2CIT_XXX
	char   Name[36];
};

class MetavarList : public SCollection {
public:
	MetavarList();
	~MetavarList();
	int    SetVal(long id, const char * pVal);
	int    GetStr(long id, char *, size_t) const;
	int    GetInt(long id, long *) const;
	int    GetReal(long id, double *) const;
	int    GetAcc(long id, Acct *) const;
};
//
// Descr: Показатель, основанный не на бухгалтерских счетах
//   (остатки товаров, суммы по документам, текст персонального события и т.д.)
//
// @loclist(...)
// @bill(period, op, [loc])
// @paym(period, op, [loc]) // op - операция, к которой привязаны оплаты
// @personevent(period, op)
// @ccheck(period, [loc])
// @goodsrest.cost(period, [loc])
// @debt(period, accsheet)
// @bizscore(period, scoresymb)
//
class DL2_Score {
public:
	void   Init(DL2_Resolver * pCtx);
	int    GetFromStr(const char *, size_t * pOffs);
	int    PutToStr(SString & rBuf) const;

	enum {
		kMetavar     = 1, // Метапеременная //
		kBill        = 2, // Документы
		kPaym        = 3, // Оплаты по документам
		kCCheck      = 4, // Кассовые чеки
		kGoodsRest   = 5, // Остатки товаров
		kPersonEvent = 6, // Персональные события //
		kDebt        = 7, // Долги
		kBizScore    = 8, // Бизнес-показатели
		kMarketplace = 9, // @v12.1.6 Торговля через маркетплейс
	};
	enum {
		subsubAverage      // "average"   kBill, kPaym, kCCheck, kGoodsRest
	};
	enum {
		cmpNone = 0,
		cmpDD,             // День/День
		cmpMM,             // Месяц/Месяц
		cmpQQ,             // Квартал/Квартал
		cmpYY,             // Год/Год
		cmpPrev            // Предыдущий примыкающий период
	};
	dl2cit CiType;         // Тип показателя //
	int16  Kind;           // kXXX   Показатель
	int16  Sub;            // subXXX
	int16  Modifier;       // modXXX Модификатор показателя //
	int16  Cmp;            // cmpXXX Сравнение с предыдущим периодом
	DateRange Period;      // Период
	int32  LocListID;      // Идентификатор списка складов
	int32  GoodsGrpListID; // Идентификатор списка товарных групп
	char   OpCode[32];     // Символ вида операции (Kind == kBill, kPaym, kPersonEvent, kDebt, kBizScore)
	DL2_Resolver * P_Ctx;  // @notowned Контекст разрешения формулы
private:
	void   Helper_Init();
	int    ScanArg(SStrScan & rScan, SString & rBuf);
	int    ScanArgList(const char * pStr, size_t * pOffs);
};

struct DL2_Acc {
public:
	void   Init();
	int    GetFromStr(const char *, int substAr = -1);
	int    GetAco() const;
	int    GetCorrAco() const;

	enum {
		fRest     = 0x0001, // 'R' Исключает fTurnover fInRest
		fInRest   = 0x0002, // 'I' Исключает fTurnover fRest
		fTurnover = 0x0004,	// 'T' Исключает fRest fInRest
		fDebit    = 0x0008, // 'D' Дебетовое сальдо или оборот
		fCredit   = 0x0010, // 'C' Кредитовое сальдо или оборот
		fSpread   = 0x0020, // 'S' Развернутое сальдо по субконто (подразумевает fRest или fInRest)
		fAco1     = 0x0100, // 'O1' Счет 1-го порядка
		fAco2     = 0x0200, // 'O2' Счет 2-го порядка
		fAco3     = 0x0400, // 'O3' Терминальный счет
		fCorAco1  = 0x1000, // ':O1' Корр счет 1-го порядка
		fCorAco2  = 0x2000, // ':O2' Корр счет 2-го порядка
		fCorAco3  = 0x4000, // ':O3' Терминальный корр счет
	};
	Acct   Acc;	         // Счет (натуральное представление)
	char   Code[32];
	Acct   CorrAcc;      // Корреспондирующий счет
	char   CorrCode[32]; // Код корреспондирующего счета
	uint16 Flags;        // Флаги
	uint16 PrdOfs;       // Период сдвига
	int16  NumPrdOfs;    // Количество периодов сдвига
private:
	int    GetAcc(char ** ptr, int isCorr, int substAr = -1);
};

struct DL2_CI {
	static DL2_CI * MakeStr(const char *);
	static DL2_CI * Copy(const DL2_CI *);
	static void Destroy(DL2_CI *);
	void * operator new(size_t, const char * = 0);
	int    IsConst() const;
	void   InitOp(uint16 op, uint16 argCount);
	void   Init(double v);
	void   Init(long v);
	void   Init(LDATE v);
	void   Init(LTIME v);
	void   Init(const DateRange * pV);
	void   Init(const DL2_Acc * pV);
	void   Init(const DL2_Score * pV);
	void   InitMetavar(long id);
	size_t Size() const;
	int    GetStr(char * pBuf, size_t bufLen) const;
	const  char * GetStr() const;
	int    ToStr(char * pBuf, size_t bufLen) const;

	dl2cit CiType;
	union {
		uint16 ArgCount;
		double R;
		long   I;
		LDATE  D;
		LTIME  T;
		DateRange P;
		DL2_Acc A;
		DL2_Score Score;
		long   MvID; // Metavar ID
		uint16 Len;
	};
};
//
//
//
class DL2_Storage {
public:
	struct IndexItem {
		uint16 EntryType;
		char   Name[36];
		uint32 Offs;
	};

	static int IsDL200File(const char *);
	DL2_Storage();
	~DL2_Storage();
	int    Open(const char * pFileName, int readOnly);
	int    Close();
	int    GetDataEntriesList(SStrCollection *);
	int    WriteEntry(const DL2_Entry *);
	int    ReadEntry(uint type, const char * pName, DL2_Entry *);
	int    ReadEntryHeader(uint type, const char * pName, DL2_Entry *);
	int    AddSymb(const DL2_Entry *);
	int    LookupSymb(uint type, const char * pName, uint * pPos, uint32 * pOffs);
	int    CheckDupSymb(uint type, const char * pName);
	int    EnumSymb(uint type, char * pName, uint * pPos);
private:
	friend class DL2_Entry;
	friend class DL2_Row;
	friend class DL2_Group;
	friend class DL2_Data;

	struct Header {
		uint32 Signature;
		uint32 DL200_Ver;
		uint32 IndexOffs;
		uint8  Reserve[20];
	};
	int    AddSymb(const DL2_Entry *, uint32 offs);
	int    ReadHeader();
	int    WriteHeader();
	int    ReadIndex();
	int    WriteIndex();
	int    _ReadEntry(uint type, const char * pName, int hdrOnly, DL2_Entry *);

	Header   Head;
	SArray * P_Index;
	int    RO_Mode;   // ReadOnly mode
	char   FileName[MAX_PATH];
	FILE * P_Stream;
};
//
//
//
#define DL2ENT_DATA  1
#define DL2ENT_GROUP 2
#define DL2ENT_ROW   3

class DL2_Entry {
public:
	static uint16 ReadEntryType(FILE *);

	enum { // Flags values
		fRef = 0x0001
	};
	DL2_Entry(uint16 type);
	DL2_Entry & FASTCALL operator = (const DL2_Entry &);
	int    Setup(const char * pName, const char * pDescript, int isRef);
	virtual void destroy();
	//
	// Order of writing to stream:
	//   {(uint32)EntryType, (uint32)Flags, Name, (uint32)sstrlen(P_Descript), P_Descript[sstrlen(P_Descript)]}
	//   if(P_Descript == 0) then { (uint32)EntryType, (uint32)Flags, Name, (uint32)0 }
	//
	virtual int  Write(DL2_Storage *) const;
	//
	// if (readed EntryType) != EntryType then error (PPERR_DL200_INVENTRYTYPE)
	//
	virtual int  Read(FILE *);
	virtual int  Print(FILE *) const; // @debug
/*private:
	enum {
		signEntry = 0x5D07F9A0,
		signGroup = 0x5D07F9A1,
		signRow   = 0x5D07F9A2
	};
	uint32 Sign; // Подпись экземпляра
public:*/
	uint16 EntryType;
	uint16 Flags;
	char   Name[36];
	char * P_Descript;
};

struct DL2_Column {
	uint16 CiType;         // DL2CIT_XXX
	uint16 MaxOutSize;     // Максимальный размер выходной строки
	uint32 Flags;
	DL2_Acc CiAc;
	char * P_Title;
};
//
//
//
class DL2_Formula {
public:
	DL2_Formula();
	DL2_Formula(const DL2_Formula &);
	~DL2_Formula();  // no delete P_Stack (use destroy())
	void   destroy();
	int    FASTCALL Copy(const DL2_Formula *);
	bool   IsEmpty() const;
	int    GetCount() const;
	//
	// Construction methods
	//
	int    PushItem(const DL2_CI *);            // Imply only one expression
	int    PushExpression(const DL2_Formula *); // Imply only one expression
	int    AddExpression(const DL2_Formula *);  // Put new expr at tail of list
	int    AddItem(const DL2_CI *);             // Imply only one expression
	//
	// Processing methods
	//
	DL2_CI * Calc(int exprNo, DL2_Resolver *) const;
	const DL2_CI * GetByN(uint /* 1.. */) const;
	//
	// Order of writing to stream:
	//   {(uint32)Size, (uint32)Count, P_Stack[Size bytes]}
	//   if(P_Stack == 0 or Size == 0) then
	//     only {(uint32)Size, (uint32)Count}
	//
	int    Write(FILE *) const;
	int    Read(FILE *);
	int    Print(FILE *) const; // @debug
private:
	int    Push(const void * pSrc, size_t srcSize);
	DL2_CI * Calc(int exprNo, size_t pos, size_t *, DL2_Resolver *) const;
	const DL2_CI * Get(size_t pos, size_t * pNextPos) const;
	DL2_CI * ResolveOp(const DL2_CI *, const DL2_Formula *) const;
	//
	// Format of storing :
	// ExprList : Count times ( ExprSize [2] Expr [ExprSize-2] )
	// Expr : n times ( ItemSize [2] Item [ItemSize-2] )
	//
	uint32 Count;    // Number of Expressions
	uint32 Size;     // Total size of buffer P_Stack
	uint8 * P_Stack; // Buffer (for allocation used 'realloc', not 'new')
};

class DL2_Row : public DL2_Entry {
public:
	DL2_Row();
	DL2_Row & FASTCALL operator = (const DL2_Row &);
	virtual void destroy();
	//
	// Order of writing to stream:
	//   {[DL2_Entry], P_F}
	//   if(P_F == 0) then writing empty DL2_Formula
	//
	virtual int  Write(DL2_Storage *) const;
	virtual int  Read(FILE *);
	virtual int  Print(FILE *) const; // @debug

	DL2_Formula * P_F;
};

class DL2_Group : public DL2_Entry {
public:
	DL2_Group();
	virtual void destroy();
	//
	// Order of writing to stream:
	//   { (uint32)getCount(), DL2_Group[getCount] }
	//
	virtual int  Write(DL2_Storage *) const;
	virtual int  Read(FILE *);
	virtual int  Print(FILE *) const; // @debug
	uint   GetMaxNesting() const;
	size_t GetMaxDescriptionSize(uint level) const;

	uint   GetCount() const;
	int    AddItem(DL2_Entry *);
	int    RemoveAll();
	DL2_Entry * GetItem(uint) const;
protected:
	DL2_Group(uint16 type);
private:
	SCollection Items; // <DL2_Row> | <DL2_Group>
	//virtual void FASTCALL freeItem(void * pItem);
};

class DL2_Data : public DL2_Group {
public:
	DL2_Data();
	~DL2_Data();
	virtual void destroy();
	virtual int  Write(DL2_Storage *) const;
	virtual int  Read(FILE *);
	virtual int  Print(FILE *) const; // @debug
	//
	// Insert pColumn into columns list.
	// ! Caution: Don't destroy pColumn->P_Title after passing to this function !
	//
	int    AddColumn(const DL2_Column * pColumn);
	int    SearchColumnByName(const char *, uint * pPos, DL2_Column *) const;
	uint   GetColumnsCount() const;
	const  DL2_Column * GetColumn(uint) const;
private:
	void   DestroyColumns();
	SArray * P_Columns;
};

class DL2_GroupStack : public SStack {
public:
	DL2_GroupStack();
};

struct DL2_Filt {
	char   DataSymb[36];
	DateRange Period;
	int16  Cycle;
	int16  NumCycles;
	long   Flags;
};
//
// Descr: Контейнер списков объектов. Основное назначение - заменять текстовый список
//   объектов идентификатором.
//
class DL2_ObjList : private SCollection {
public:
	DL2_ObjList();
	int    Set(PPID objType, const StringSet * pSs, int32 * pId);
	int    Get(int32 id, PPID * pObjType, ObjIdListFilt & rList);
	int    FromString(const char * pStr, PPID & rObjType, int32 * pId);
	int    ToStr(int32 id, SString & rBuf) const;
private:
	struct Item {
		int32  Id;
		int32  ObjType;
		StringSet Ss;
	};
	static int FASTCALL GetObjToken(PPID objType, SString & rToken);
	virtual void FASTCALL freeItem(void *);
};

class DL2_Resolver {
public:
	enum {
		fDoLogging = 0x0001 // Заносить в журнал процесс разбора и вычисления выражений
	};
	class SPD {
	public:
		SPD(int kind, DL2_Resolver * pR);
		virtual ~SPD();
		virtual int IsEqHdr(const SPD *) const = 0;
		virtual int Init(const DL2_Score & rS, LDATE actualDate) = 0;
		virtual DL2_CI * Resolve(const DL2_Score & rS) = 0;
		int    ResolveWarehouseList_(int32 listId, ObjIdListFilt & rList);
		int    ResolveGoodsGroupList(int32 listId, ObjIdListFilt & rList);

		int    Kind;
		enum {
			fResolved = 0x0001
		};
		long   Flags;
		DL2_Score Sc;
		DL2_Resolver * P_R; // @notowned
	};

	explicit DL2_Resolver(long flags = 0);
	~DL2_Resolver();
	virtual DL2_CI * Resolve(int exprNo, const DL2_CI * pCi);
	DL2_CI * Resolve(const DL2_CI * pCi);
	DL2_CI * ResolveScore(const DL2_Score & rSc);
	int    ResolveName(const char * pExpression, SString & rName);
	double Resolve(const char * pExpression);
	int    SetPeriod(DateRange period);
	int    SetActualDate(LDATE);
	LDATE  GetActualDate() const;
	int    SetCurArticle(long arID);
	long   GetCurArticle() const;
	int    FASTCALL Log(const char * pMsg);
	int    ReverseFormula(const char * pFormula, SString & rResult);

	DL2_ObjList Oc; //
protected:
	DL2_CI * Helper_Resolve(const DL2_Column * pCol, const DL2_CI * pCi);

	DateRange CurPeriod;
	long   CurArID;      // Номер аналитической статьи, используемый для подстановки вместо символа '*'
	long   Flags;
	PPObjAccTurn AtObj;
	PPObjPerson PsnObj;
private:
	friend class DL2_Resolver::SPD;

	PPObjLocation LocObj;
	StrAssocArray NameVars;
	LDATE  ActualDate;
	TSCollection <SPD> SpdList; // Список уже разрешенных показателей.
		// Список необходим для того, чтобы сократить время на вычисление
		// одинаковых по расчетным критериям показателей.
};

class PrcssrDL200 : public DL2_Resolver {
public:
	struct Param {
		char   FileName[MAX_PATH];
		char   DataName[36];
		DateRange Period;
		PPCycleFilt Cycl;
	};
	PrcssrDL200();
	~PrcssrDL200();
	virtual DL2_CI * Resolve(int exprNo, const DL2_CI * pCi);
	int    InitParam(Param *);
	int    EditParam(Param *);
	int    Init(const Param *);
	int    Run();
private:
	int    ProcessRow(const DL2_Row *);
	int    ProcessGroup(const DL2_Group *);
	int    InitOutput();
	int    FinishOutput();
	DBTable * CreateHeaderDBTable();
	DBTable * CreateIterDBTable();
	int	   FillHeader();
	int    Print();
	int    CreateFileSelCombo(TDialog *, uint ctlID, char * pPath, size_t pathBufLen);
	int    CreateFormSelCombo(TDialog *, uint ctlID, const char * pFileName, char * pSingleFormName, size_t bufLen);

	Param  P;
	DL2_Data D;
	DL2_GroupStack GStack;
	DL2_Storage Strg;
	SString OutPath;
	BDictionary * P_Dict;
	DBTable * P_HdrTbl;
	DBTable * P_IterTbl;
};
//
//
//
class BillTotalBlock {
public:
	BillTotalBlock(BillTotalData & rData, /*PPID opID*/const PPBillPacket & rBPack, PPID goodsTypeID, int outAmtType, long flags);
	//
	// Note: Функция принимает non-const аргумент rTi поскольку может изменить 
	//   значение флага PPTFR_SELLING в поле rTi.Flags.
	//
	void   FASTCALL Add(PPTransferItem & rTi);
	void   AddPckg(const PPTransferItem *);
	void   FASTCALL Add(const PPAdvBillItemList::Item &);
	void   Finish(/*const PPBillPacket * pPack*/);
	//
	// Descr: Сравнивает this->R_Data с rS.R_Data. Если они эквивалентны (R_Data.IsEq(rS.R_Data)) то возвращает true.
	//
	bool   FASTCALL IsResultEq(const BillTotalBlock & rS) const;
private:
	void   SetupStdAmount(PPID stdAmtID, PPID altAmtID, double stdAmount, double altAmount, long replaceStdAmount, int in_out);
	void   SetupStdAmount(PPID stdAmtID, double stdAmount, int in_out);
	enum {
		stSelling    = 0x0001,
		stAllGoodsUnlim      = 0x0002,
		stAllGoodsUnlimUndef = 0x0004,
		stExtCost    = 0x0008
	};
	const  int OutAmtType;
	// @v12.2.4 (replaced with R_BPack.Rec.OpID) PPID   OpID;
	PPID   GoodsTypeID;
	PPID   DynGoodsTypeForSupplAgent; // ==PPCommConfig::DynGoodsTypeForSupplAgent
	long   State;
	long   Flags;
	PPIDArray GoodsList;
	PPObjGoodsType  GtObj;
	PPObjGoods      GObj;
	PPObjAmountType ATObj;
	BillTotalData & R_Data;
	const PPBillPacket & R_BPack; // @v12.2.4
};
//
//
//
class BillContext : public ExprEvalContext {
public:
	enum {
		funcAmountByVat   = EXRP_EVAL_FIRST_FUNC + 1, // amountbyvat(x)
		funcAmountByGVat  = EXRP_EVAL_FIRST_FUNC + 2, // amountbygvat(x)
			// Сумма документа по строкам, товары которых облагаются указанной ставкой НДС.
			// Отличается от amountbyvat тем, что суммируются строки, по которым не эффективная,
			// но номинальная (то есть, заданная для товара) ставка НДС равна указанной.
		funcAmountByTVat  = EXRP_EVAL_FIRST_FUNC + 3, // amountbytvat(oid(GOODSTYPE, id), x)
			// Сумма документа по строкам, товары которых принадлежат типу oid(GOODSTYPE, id) и
			// облагаются ставкой НДС x%. То есть, результат аналогичен amountbyvat с той
			// разницей, что суммирование ограничивается товарами с типом oid(GOODSTYPE, id).
		funcCostByVat     = EXRP_EVAL_FIRST_FUNC + 4, // costbyvat(x)
		funcCostVat       = EXRP_EVAL_FIRST_FUNC + 5, // costvat(x)
		funcPriceByVat    = EXRP_EVAL_FIRST_FUNC + 6, // pricebyvat(x)
		funcPriceVat      = EXRP_EVAL_FIRST_FUNC + 7, // pricevat(x)
		funcHasWhiteLabel = EXRP_EVAL_FIRST_FUNC + 8, // haswhitelabel()
	};

	BillContext(const PPBillPacket * p, PPID curID, uint advLineIdx);
	virtual int Resolve(const char * pSymb, double * pVal);
	virtual int IsFunc(const char * pSymb, int * pFuncId);
	virtual int ResolveFunc(int funcId, FC & rFc);
private:
	int    CalcTotalBlock();
	int    ProcessLink(PPID linkBillID, PPID amtID, int artefactSymb, PPID addCurID, bool errOnDefault, double * pResult);

	const  PPBillPacket * P_Pack;
	BillTotalData Bt;
	PPID   LinkID;
	PPID   ReckonID;
	PPID   CurID;
	uint   AdvLineIdx;
};
//
//
//
class DL200_Context : public ExprEvalContext {
public:
	explicit DL200_Context(DL2_Resolver * pResolver, BillContext * pBillCtx = 0);
	virtual int Resolve(const char * pSymb, double * pVal);
	virtual int IsFunc(const char * pSymb, int * pFuncId);
	virtual int ResolveFunc(int funcId, FC & rFc);
private:
	DL2_Resolver * P_Resolver;
	BillContext * P_BillCtx;   // @notowned
	StrAssocArray FuncList;
	long   LastFuncId;
};
//
// @ModuleDecl(Generator_GnuPlot)
//
class PPGpStyle {
public:
	PPGpStyle();
	int    SetLine(COLORREF c, float width);
	int    SetPoint(COLORREF c, int type, float size);
	//
	// Descr: Устанавливает стиль точки с переменным цветом.
	//   Цвет определяется одной из переменных входящих данных.
	//
	int    SetPointVarColor(int type, float size);
	int    SetFill(int type, long ext, int noborder);
	int    ToStr(SString & rBuf) const;

	enum {
		kLine = 1,
		kPoint,
		kFill
	};
	enum {
		fIndex = 0x0001, // Используется предопределенный стиль индексом Idx
		fVariableColor = 0x0002, // variable color (последний индекс данных должен содержать ссылку на колонку, определяющую цвет)
		fNoBorder      = 0x0004  // kFill noborder
	};
	//
	// Descr: Типы точек графика
	//
	enum {
		ptNone = -1,
		ptDot = 0,
		ptCross,
		ptX,
		ptAsterix,
		ptSq,           // Квадрат
		ptSqF,          // Закрашенный квадрат
		ptCircle,
		ptCircleF,
		ptTrUp,         // Треугольник (угол вверх)
		ptTrUpF,        // Закрашенный треугольник (угол вверх)
		ptTrDn,         // Треугольник (угол вниз)
		ptTrDnF         // Закрашенный треугольник (угол вниз)
	};
	//
	// Descr: Стили заполнения (fill style) //
	//
	enum {
		ftDefault = -1, // По умолчанию
		ftEmpty = 0,    // Пустое
		ftSolid,        // Сплошное. Цвет определяется текущим стилем линии.
			// Ext определяет процент интенсивности цвета. Если Ext == 100 или Ext == 0,
			// то полная интенсивность
		ftPattern       // Шаблон заполнения. Ext - индекс шаблона [1..7]
	};
	int   Kind;
	long  Idx;
	int   T;
	long  Ext;   // Дополнительный параметр типа стиля //
	long  Flags; // fXXX
	COLORREF C;
	float Sz;    // Размер. Для линий [1..6]
};

class PPGpPlotItem {
public:
	PPGpPlotItem(const char * pSrc, const char * pTitle, int plotStyle = 0);
	int    AddDataIndex(int idx);
	int    AddDataIndex(const char * pFunc);
	int    ToStr(SString & rBuf) const;
	enum {
		sDefault,
		sLines,
		sPoints,
		sLinesPoints,
		sImpulses,
		sDots,
		sSteps,
		sFSteps,
		sHiSteps,
		sErrorBars,
		sLabels,
		sXErrorBars,
		sYEerrorBars,
		sXYErrorBars,
		sErrorLines,
		sXErrorLines,
		sYErrorLines,
		sXYErrorLines,
		sBoxes,
		sHistograms,
		sFilledCurves,
		sBoxErrorBars,
		sBoxXYErrorBars,
		sEnanceBars,
		sCandleSticks,
		sVectors,
		sImage,
		sRgbImage,
		sPm3d
	};
	enum {
		fDataFile = 0x0001
	};
	int    S;
	long   Flags;
	PPGpStyle Style;
	SString DataSrc; // Источник данных. Если Flags & fDataFile, то это - имя файла (если пусто, то '-').
	SString Title;
private:
	LongArray IdxList;
	StrAssocArray StrIdxList;
};

class PPGpTicsList {
public:
	PPGpTicsList(int type);
	int    Add(double val, const char * pText, int level = 0);
	int    Add(const LDATETIME & rVal, const char * pText, int level = 0);
	int    ToStr(SString &) const;
private:
	union V {
		double R;
		LDATETIME D;
	};
	struct Item {
		V      Val;
		int    Level;
		SString Text;
	};
	int    T; // 0 - real, 1 - datetime
	TSCollection <Item> List;
};

class Generator_GnuPlot : public SFile {
public:
	enum {
		axX,
		axY,
		axZ,
		axX2,
		axY2,
		axZ2,
		axCB,
	};
	struct PlotParam {
		PlotParam();
		enum {
			fLines     = 0x00000001,
			fDots      = 0x00000002,
			fPoints    = 0x00000004,
			// @#{fLines^fDots^fPoints}
			fNoTitle   = 0x00000008,
			fHistogram = 0x00000010,
			fPm3D      = 0x00000020,
			fDGrid3D   = 0x00000040,
			fStereo    = 0x00000080
		};
		long   Flags;
		StrAssocArray Legend;
	};
	struct StyleFont {
		StyleFont();
		SString Face;
		uint   Size;
	};
	struct StyleTics {
		StyleTics();
		long   Flags;
		int    Rotate;
		StyleFont Font;
	};
	struct Coord {
		Coord() : CS(csUndef), V(0.0)
		{
		}
		Coord(double v) : CS(csUndef), V(v)
		{
		}
		Coord(int cs, double v) : CS(cs), V(v)
		{
			assert(oneof6(CS, csUndef, csFirst, csSecond, csGraph, csScreen, csChar));
		}
		enum {
			// first places the x, y, or z coordinate in the system defined by the left and bottom axes; 
			// second places it in the system defined by the second axes (top and right); 
			// graph specifies the area within the axes -- 0,0 is bottom left and 1,1 is top right (for splot, 0,0,0 is bottom left of plotting area; use negative z to get to the base -- see set ticslevel (p. [*])); 
			// screen specifies the screen area (the entire area -- not just the portion selected by set size), with 0,0 at bottom left and 1,1 at top right; 
			// and character gives the position in character widths and heights from the bottom left of the screen area (screen 0,0), character coordinates depend on the chosen font size.
			// If the coordinate system for x is not specified, first is used. If the system for y is not specified, the one used for x is adopted. 
			csUndef = 0,
			csFirst = 1, // "first"
			csSecond,    // "second"
			csGraph,     // "graph"
			csScreen,    // "screen"
			csChar       // "character"
		};
		int    CS; // Coordinate System
		double V;
	};

	static SString & ColorToStr(COLORREF c, SString & rBuf);
	explicit Generator_GnuPlot(const char * pFileName);
	const char * GetDataFileName() const;
	int    Preamble();
	int    Cmd(const char *);
	int    SetTitle(const char *);
	int    SetAxisTitle(int axis, const char *);
	int    SetAxisRange(int axis, double lo, double hi);

	enum {
		autoscaleDefault = 0, 
		autoscaleMin,
		autoscaleMax,
		autoscaleFixMin,
		autoscaleFixMax,
		autoscaleFix,
	};

	int    SetAxisAutoscale(int axis, int option = autoscaleDefault/*autoscaleXXX*/);
	int    UnsetTics(int axis);
	int    SetTics(int axis, const StyleTics * pStyle);
	int    SetTicsInc(int axis, double inc);
	int    SetTicsInc(int axis, double inc, double low, double upp);
	int    SetTicsInc(int axis, long incSec, LDATE low, LDATE upp);
	int    SetTicsList(int axis, const PPGpTicsList &);
	int    AddTicsExplicit(int axis, double val, const char * pText, int level = 0);
	int    AddTicsExplicit(int axis, const LDATETIME & rVal, const char * pText, int level = 0);
	int    SetGrid();
	int    SetStyleFill(const char * pFillStyle);
	//
	// Descr: Стиль стрелок для линий в функии SetArrao
	//
	enum {
		arrhNoHead = 0, // 
		arrhHead,       // 
		arrhBackhead,   //
		arrhTwoHeads    //
	};

	int    SetArrow(const Coord & rFromX, const Coord & rFromY, const Coord & rToX, const Coord & rToY, int head/*arrhXXX*/);
	int    SetDateTimeFormat(int axis, int usingTime = 0);
	int    DeclareLineStyle(long idx, const PPGpStyle * pStyle);
	int    AddPlotItem(const PPGpPlotItem & rItem);
	int    StartData(int putLegend);
	void   FASTCALL PutData(LDATE);
	void   FASTCALL PutData(LTIME);
	void   FASTCALL PutData(long);
	void   PutData(LDATETIME);
	void   PutData(double);
	void   PutData(const char *, int withoutQuot = 0);
	int    PutEOR();
	void   PutEndOfData();
	int    Plot(const PlotParam *);
	int    Run();
private:
	SString & Set();
	SString & SetStyle();
	SString & AxisLetter(int axis);
	SString & Font(const StyleFont & rFont);
	SString & Color(COLORREF);
	SString & SetTics(int axis);
	SString & Coordinate(const Coord & rC);
	int    PutLine();
	int    PutDataLine();

	SString LineBuf;
	SString DataFileName;
	SFile  DataFile;
	PlotParam Param;
	TSCollection <PPGpPlotItem> Items;
};
//
//
//
class PPGravityModule {
public:
	PPGravityModule();
	~PPGravityModule();
	int    RunFile(const char * pFileName, PPLogger * pOuterLogger, GravityValue * pResult);
	int    RunBuffer(const char * pText, PPLogger * pOuterLogger, GravityValue * pResult);
	void   LogToOuterLogger(const char * pMsg); // @temporary
	static void CbLog(void * pVm, const char * pMsg, void * pExtra);
	static void CbLogClear(void * pVm, void * pExtra);
	static void CbError(void * pVm, int errorType, const char * pMsg, GravityErrorDescription * pErrorDesc, void * xdata);
	static const char * CbLoadFile(const char * pFileName, size_t * pSize, uint32 * pFileId, void * pExtra, bool * pIsStatic);
protected:
	int    LoadFile(const char * pFileName, SBuffer & rBuffer);

	PPLogger * P_OuterLogger;
public:
	void * P_Utd; // unit test data. Really private, but there is nessesery for accessing this member from callback function
};
//
// Descr: Класс, управляющий шаблонизированным выводом данных DL600
//
//#define USE_TDDO_2 // Временный макрос на период модификации модуля TDDO. Для сборки релиза закомментировать!

struct TddoProcessBlock {
	TddoProcessBlock();

	SString SrcDataName;
	DlRtm::ExportParam Ep;
	DlRtm * P_Rtm;
	PPFilt F;
};

class Tddo {
public:
	enum {
		tNone = 0,
		tRem,
		tStart,
		tEnd,
		tIter,
		tVar,
		tFunc,
		tVarArgN,
		tCodepage,
		//
		// Далее следуют простые токены, распознаваемые ScanMeta(meta, scanSimpleToken)
		//
		tString,
		tSymbol,
		tNumber,
		tExpr,
		tPragma,
		tIf,
		tElse,
		tElif,
		tEndif,
		tText,      //
		tInclude,   //
		tIterCount, //
		tMacro,     // #macro(MACRONAME $arg1, $arg2) $foo($arg1, $arg2, $request) #end
		tMacroCall, // #macrosymb(arg_list) Вызов макроса
		tSet,       // #set($var = value)
		tBreak,
		tStop,
		tForEach,
		tComment,   // ##
		tLiteral,
		tDollarBrace, // ${ - начало выражения. В один проход всю конструкцию ${expr} не разобрать ибо внутри могут быть сложные подвыражения
		tOperator = 1000 // Значения выше tOperator содержат и сам оператор как слагаемое результата.
			// Например 1000+_DIVIDE_ (=1022) означает оператор деления.
	};
	enum {
		ftTddo = 1,
		ftTddt
	};
	static int GetFileName(const char * pFileName, int fileType, const char * pInputFileName, SString & rResult);
	static int LoadFile(const char * pName, SString & rBuf);

	Tddo();
	~Tddo();
	//
	// Descr: Реализует обработку шаблона из буфера pBuf. Данные извлекаются из
	//   структуры данных DL600, определенной в теле шаблона. Если эта структура
	//   или ее родитель не совпадает со структурой, заданной наименованием pDataName,
	//   то возвращает ошибку. Данные инициализируются посредством параметров dataId и pDataPtr.
	//   Результат выводится в буфер rOut.
	//
	int    Process(const char * pDataName, const char * pBuf, DlRtm::ExportParam & rEp, const StringSet * pExtParamList, SBuffer & rOut);
	//
	// Descr: Устанавливает имя входного файла. В общем случае, имя входного файла может быть
	//   пустым (поскольку функция Process обрабатывает входной поток символов из RAM), но при обработке
	//   ошибок и для правильной идентификации пути внутренних файлов имя файла может быть востребовано.
	//
	void   SetInputFileName(const char * pFileName);

	struct Meta {
		Meta();
		void   Clear();

		int    Tok;
		SString Text;
		SString Param;
	};
private:
	friend class TddoExprSet;
	friend class TddoContentGraph;

	struct Result {
		Result();
		Result & Z();

		SString S;
		DLSYMBID RefType;
		long    RefID;
	};
	int    FASTCALL ScanMeta(Meta & rM);
	int    Helper_RecognizeMetaKeyword();
	//
	// Descr: Флаги функции Helper_RecognizeExprToken
	//
	enum {
		rexptfMetaOnly = 0x0001 // Идентифицировать только метасимволы (натуральные строки и числа не рассматривать)
	};

	//int    Helper_RecognizeExprToken(long flags, SString & rText);
	void   Skip();
	int    Helper_Process(TddoProcessBlock & rBlk, SBuffer & rOut, Meta & rMeta, const DlScope * pScope, int skipOutput);
	int    ResolveVar(const SString & rText, const DlScope * pScope, Result & rR);
	int    ResolveArgN(const SString & rText, Result & rR);
	int    ResolveExpr(DlRtm * pRtm, const DlScope * pScope, DlRtm * pCallerRtm, SStrScan & rScan, Result & rR);
	int    GetVar(const SString & rInput, SString & rBuf) const;
	int    IsTextSection(const SString & rLineBuf, const char * pPattern, SString * pRet);
	int    ExtractText(const char * pFileName, const char * pTextIdent, int langId, SBuffer & rOut);

	enum {
		stStart = 0x0001
	};
	enum {
		fHtmlEncode  = 0x0001 // Кодировать специальные символы в извлекаемых полях html-сущностями
	};
	SStrScan Scan;
	long   ReH_Meta;
	long   ReH_Var;
	long   ReH_VarShort;
	long   ReH_VarArgN;
	long   ReH_VarArgNShort;
	long   ReH_RemLine;
	long   ReH_If;
	long   ReH_Elif;
	long   ReH_String;
	long   Flags;
	uint   LineNo;
	SCodepageIdent Cp;
	DlContext * P_Ctx;
	SString InputFileName;
	StringSet ExtParamList;
	StringSet ErrMsgList;
};
//
//
//
extern "C" typedef int (*TextAnalyzerSignalProc)(const char * pResource, int64 orgOffs, const char * pOrgStr, const char * pSignalStr, void * pExtraPtr);

// %/тушь%&(синяя%|синий%|син%.)%/%!keyword синяя тушь для ресниц

class PPTextAnalyzer : public STokenizer {
public:
	class Replacer {
	public:
		friend class PPTextAnalyzer;

		struct Term { // @flat
			int16  Type;
			int16  Tok;
			uint32 Id;
		};
		class Chain : public TSVector <Term> {
		public:
			Chain();
			Chain & FASTCALL operator = (const Chain & rS);
			int    Add(int type, int tok, uint32 id);
			//
			// Descr: Вспомогательная функция, используемая для формирования сложных выражений,
			//   сформулированных в инфиксной форме.
			//   Сначала в список добавляется 'лемент {type, 0, rInner.getCount}, а вслед
			//   за ним сразу следуют записи из rInner.
			//
			int    Add(int type, const PPTextAnalyzer::Replacer::Chain & rInner);
		};

		static int FASTCALL IsOp(int termType);
		static int FASTCALL IsLex(int termType);
		Replacer();
		~Replacer();
		void   InitParsing(const char * pFileName);
		void   IncLineNo();
		long   SetState(long st, int set);
		long   GetState() const { return State; }
		uint   SearchTarget(const Replacer::Chain & rChain) const;
		LongArray * SearchCortege(uint cortegeId) const;
		int    AddCortegeItem(uint cortegeId, uint srcListIdx);

		enum {
			stError   = -1, // Ошибка в терме
			stLiteral = 0,
			// 1..100 - номер группы для замены %1..%100
			stSpace = 101,     // %s [ \t]+
			stSpaceMul,        // %z [ \t]*
			stSpaceSingle,     // %_ ' '
			stEmpty,           // %E Пустое выражение (только для целевого определения)
			stTab,             // %t Табуляция //
			stDotOpt,          // %. Опциональная точка
			stHyphenOpt,       // %- Опциональный дефис
			stBegin,           // %^ Начало текста
			stEnd,             // %$ Конец текста
			stNum,             // %d term [0-9]+
			stNumL,            // %D[0-9][0-9] term Число с заданным количеством знаков. Длина хранится в Term::Tok
			stFloat,           // %f term [0-9]+(.[0-9]+)?
			stWord,            // %w term любая последовательность символов, отличная от разделителя //
			stLPar,            // %( начало группы
			stRPar,            // %) завершение группы
			stAny,             // %* Любая (не пустая) последовательность токенов
			stCortege,         // %@cortegename. Совпадение с одним из элементов кортежа (нельзя использовать в целевом определении)
			stPercent,         // %% литеральный '%'
			stLastLex,         // Служебное значение для отделения лексических типов термов от операторов
			//
			// Note: Принципиально важно, чтобы операторы stOpTo, stOpFrom, stOpOr имели меньшее значение чем
			//   stOpCapital, stOpLower, stOpUpper: после сортировки списка TSCollection <Replacer::SrcItem>
			//   сначала будут обрабатываться элементы с меньшим значением оператора.
			//
			stOpTo,            // %> single infix
			stOpFrom,          // %< single infix
			stOpOr,            // %| multi  infix
			stOpAnd,           // %& AND (применяется только внутри контекста)
			stOpCortege,       // %= single infix Один или более образцов, ассоциированных с именующим символом
			stOpSignal,        // %! single infix Аналогично stOp, но преобразованный текст не замещает оригинальный,
				// а возвращается посредством callback-процедуры вызывающей функции для специализированной обработки.
			stOpCapital,       // %K single suffix Слово преобразовывать к виду: первый символ прописной, остальные - строчные
			stOpLower,         // %a single suffix Слово преобразовывать к виду: все символы строчные
			stOpUpper,         // %A single suffix Слово преобразовывать к виду: все символы прописные
			stOpClusterStart,  // %{
			stOpClusterEnd,    // %}
			stOpComment,       // %--
			stOpPragma,        // %#
			stOpContext        // %/ Контекст (обрамляется с обеих сторон такими символами: %/apple%/
		};

		struct SrcItem {
			SrcItem();
			const  SSzChunk * FASTCALL GetTermGroup(uint termIdx, uint * pGrpIdx) const;

			enum {
				fContext = 0x0001 //
			};
			int    Op;
			uint   TargetIdx; // Если Op == stOpCortege, то TargetIdx равен индексу токена имени кортежа
			long   Flags;
			Chain  List;
			TSVector <SSzChunk> GL; // Список групп
		};
		struct TargetItem {
			Chain  List;
		};
		TSCollection <Replacer::SrcItem> SrcList;
		TSCollection <Replacer::TargetItem> TargetList;
		//
		// Descr: Элемент списка кортежей. Индексирует соответствие идентификатора кортежа списку
		//   записей SrcList.
		//
		struct CortegeItem {
			uint   CortegeId;
			LongArray SrcListIdxList;
		};

		TSCollection <CortegeItem> CrtgList;
		//
	private:
		Replacer::SrcItem * MakeSrcItem(Replacer::SrcItem * pOuterSrcItem, int op, uint targetIdx, const Chain & rList, const TSVector <SSzChunk> & rGl) const;
		int    AddClusterItem(Replacer::SrcItem * pItem);
		int    BuildSrcIndex();

		LongArray SrcListIndex; // Позиции элементов SrcList в том порядке, в котором должны обрабатываться при обработке текста
		//
		// Поля, используемые при разборе файла определения правил замены
		//
		enum {
			psCluster      = 0x0001, // Разбор находится в состоянии открытого кластера %{%}
			psSyntaxSimple = 0x0002,
			psContext      = 0x0003  // Разбор находится в состянии обработки контекста %/%/
		};
		SString FileName; // Имя исходного файла
		uint   LineNo;    // Номер строки исходного файла
		long   State;     // Флаги состояния разбора
		TSCollection <Replacer::SrcItem> * P_Cluster;
	};
	//
	// Descr: Элемент списка результатов поиска образца Replacer::SrcItem в тексте this
	//
	struct FindItem { // @flat
		uint   GrpIdx;    // Позиция группы в Replacer::SrcItem. 0 - общий результат
		uint   IdxFirst;  // Индекс первого найденного в this элемента
		uint   IdxLast;   // Индекс последнего найденного в this элемента
	};
	class TextIndex {
	public:
		enum {
			spcDigital    = -1,
			spcSpaceOrTab = -2,
			spcSpace      = -3,
			spcTab        = -4,
			//spcDot        = -5,

			spcDigL_First = -1001,
			spcDigL_Last  = -1099,
		};
		TextIndex();
		void   Reset();
		int    FASTCALL Add_(uint position, int textId);
		void   Finish();

		int    FASTCALL HasTextId(int textId) const;
		const  LongArray * FASTCALL GetTextIndex(int textId) const;
	private:
		struct Item {
			int    TextId;
			LongArray PosList;
		};
		TSCollection <Item> L;
	};
	class FindBlock : public TSVector <FindItem> {
	public:
		FindBlock(const Replacer & rR);
		~FindBlock();
		FindBlock & Init(const Replacer::SrcItem * pItem, uint idxFirst, uint idxLast);
		//
		// Descr: Сбрасывает список найденных отрезков, но сохраняет неимзенными P_Item, IdxFirst, IdxLast
		//
		FindBlock & Reset();
		const  FindItem * FASTCALL GetGroupItem(uint grpIdx) const;
		void   Sort();
		FindBlock * GetRecursiveBlock();

		const Replacer & R;
		const Replacer::SrcItem * P_Item;
		uint   IdxFirst; // Индекс позиции в PPTextAnalyzer с которой надо начать поиск
		uint   IdxLast;  // Индекс позиции в PPTextAnalyzer на которой поиск заканчивается //
		enum {
			stStop = 0x0001, // Сигнализирует о том, что продвигаться дальше по тексту с целью найти образец не имеет смысла.
				// Устанавливается функцией PPTextAnalyzer::Match(). Сбрасывается FindBlock::FindBlock(), FindBlock::Reset(), FindBlock::Init().
			stTest = 0x0002, // Используется при рекурсивных вызовах PPTextAnalyzer::Match()
				// для пропуска ненужных операций с целью оптимизации производительности
			stParentIndex  = 0x0008  // Указатель P_Idx принадлежит родительскому 'кзмемпляру
		};
		int    State;
		uint   NextPos; // Если текст проиндексирован то очередной вызов Match может инициализировать
			// данное поле для иноформирования вызывающей функции о том, на какую позицию в тексте следует
			// переместиться для быстрого нахождения токена.
		//
		SString TempBuf; // @allocreuse
		STokenizer::Item Item_;
		TextIndex * P_Idx;
	private:
		FindBlock * P_Next; // Блок используемый для 'кономии ресурсов при рекурсивных
			// вызовах PPTextAnalyzer::Match()
	};
	PPTextAnalyzer();
	~PPTextAnalyzer();
	void   SetSignalProc(TextAnalyzerSignalProc proc, void * pProcExtra);
	int    ParseReplacerLine(const SString & rLine, Replacer & rReplacer);
	int    ParseReplacerFile(const char * pFileName, Replacer & rRpl);
	//
	// Descr: Создает специальный индекс текста [idxFirst, idxLast] для оптимизации поиска.
	//
	int    IndexText(PPTextAnalyzer::FindBlock & rBlk, uint idxFirst, uint idxLast) const;
	//
	// Descr: Выводит описание дескриптора замены в строку.
	//   Отладочная функция.
	//
	int    ReplacerSrcItemToStr(const Replacer & rR, const Replacer::SrcItem * pItem, SString & rBuf) const;
	int    FindReplacerSrcItem(PPTextAnalyzer::FindBlock & rBlk) const;
	int    DoReplacement(const PPTextAnalyzer::Replacer & rR, PPTextAnalyzer::FindBlock & rBlk, SString & rBuf) const;
	//
	// Descr: Реализует обработку строки rOrg по правилам, заданным в блоке rR.
	// ARG(rR         IN): Блок правил обработки текста (замены, сигналы и т.д.)
	// ARG(pResource  IN): @{vptr0} Необязательный строковый идентификатор текста.
	// ARG(rOrg       IN): Строка, подлежащая обработке
	// ARG(rResult   OUT): Результирующая строка после применения всех замен, перечисленных в rR
	// ARG(pOuterFb   IN): Вспомогательный параметр, позволяющий ускорить обработку большого количества
	//   строк за счет снижения издержек на распределение и освобождение памяти.
	// ARG(pDebugFile IN): Необязательный параметр, указывающий на дескриптор текстового файла,
	//   в который будет выводиться отладочная информация о процессе обработки.
	// Returns:
	//   >0 - была осуществлена по крайней мере одна замена в тексе rOrg
	//   <0 - не было сделано ни одной замены (возможно, были обработаны сигналы)
	//    0 - error
	//
	int    ProcessString(const PPTextAnalyzer::Replacer & rR, const char * pResource, const SString & rOrg,
		SString & rResult, PPTextAnalyzer::FindBlock * pOuterFb, SFile * pDebugFile);
	int    ProcessGoods();
	int    ProcessGoodsNN();
	int    ProcessPerson();
	int    ProcessCtx(const char * pIdent, const char * pText, STokenizer::Context * pCtx);
	int    MakeGoodsNameList(const char * pOutFileName);
	int    Test();
private:
	int    GetTrT(const PPTextAnalyzer::Replacer & rReplacer, SStrScan & rScan, SString & rExtBuf) const;
	int    Match(FindBlock & rBlk, uint termIdx, const uint termLast, uint idxFirst, uint idxLast) const;
	int    Helper_FindReplacerSrcItem(FindBlock & rBlk, const uint termFirst, const uint termLast, uint idxFirst, const uint idxLast, uint * pFoundIdx) const;
	int    ParseContext(const Replacer & rReplacer, SStrScan & rScan, Replacer::Chain * pChain, int recur);
	int    Helper_ReplacerSrcItemToStr(const Replacer & rR, const Replacer::SrcItem * pItem,
		const Replacer::Chain & rC, uint start, uint count, SString & rBuf) const;

	TextAnalyzerSignalProc SignalProc;
	void * P_SignalProcExtra;
};
//
// Descr: Упрощенная обертка для класса PPTextAnalyze для замены текста по правилам,
//   заданным в исходном файле. Сигналы не отрабатываются.
//
class PPTextAnalyzerWrapper {
public:
	enum {
		fInited   = 0x0001, // @internal
		fEncInner = 0x0002  // Входящая строка и результат кодируются в INNER-кодировке
	};
	PPTextAnalyzerWrapper();
	int    Init(const char * pRuleFileName, long flags);
	int    ReplaceString(const char * pText, SString & rResult);
private:
	PPTextAnalyzer A;
	PPTextAnalyzer::Replacer R;
	PPTextAnalyzer::FindBlock Fb;
	long   Flags;
	SString TempBuf; // @allocreuse
};
//
//
//
class IntermediateImportedGoodsCollection : private SStrGroup {
private:
	friend DECL_CMPFUNC(IntermediateImportedGoodsCollection_Entry_ByName);
	friend DECL_CMPFUNC(IntermediateImportedGoodsCollection_Entry_ByGroup);
	friend DECL_CMPFUNC(IntermediateImportedGoodsCollection_Entry_ByBrand);
	friend DECL_CMPFUNC(IntermediateImportedGoodsCollection_Entry_ByCode);

	struct InnerEntry {
		InnerEntry();
		long   Ident;
		uint   ProcessFlags;
		char   Code[32];
		uint   NameP;
		uint   GrpNameP;
		uint   BrandNameP;
	};
public:
	struct Entry {
		enum {
			fRemove      = 0x0001,
			fUpdName     = 0x0002,
			fUpdCategory = 0x0004,
			fUpdBrand    = 0x0008
		};
		Entry();
		Entry & Z();

		long   Ident;        // @v11.5.11
		uint   ProcessFlags; // @v11.5.11
		SString Name;
		SString Code;
		SString GrpName;
		SString BrandName;
	};
	IntermediateImportedGoodsCollection();
	uint   GetCount() const;
	int    Get(uint idx, Entry & rEntry) const;
	int    Add(const Entry & rEntry);
	void   UpdateProcessFlags(uint idx, uint flags);
	int    UpdateCategory(uint idx, const SString & rText);
	int    UpdateBrand(uint idx, const SString & rText);
	void   FinalizeImport();
	const  LongArray & GetGroupList();
	const  LongArray & GetBrandList();
	int    GetTextById(long id, SString & rBuf) const;

	enum {
		ordByName = 0,
		ordByGroup,
		ordByBrand,
		ordByCode
	};
	void Sort(int ord);
private:
	TSVector <InnerEntry> L;
	SymbHashTable Ht;
	uint    LastId;
	LongArray GroupList;
	LongArray BrandList;
};

class UhttGoodsProcessor { // @v11.5.10 @construction
public:
	UhttGoodsProcessor();
	int    Init();
	int    AddEntry(const char * pCode, const char * pName, const char * pCategory, const char * pBrand);
	int    Run();
	uint   GetResultCount() const;
	int    GetResult(uint idx, IntermediateImportedGoodsCollection::Entry & rEntry);
private:
	void   ProcessDupCodeList(const LongArray & rDupCodeIdxList);
	IntermediateImportedGoodsCollection L;
	IntermediateImportedGoodsCollection Result;
};
//
//
//
class PPObjectTokenizer : public PPTextAnalyzer {
public:
	PPObjectTokenizer();
	~PPObjectTokenizer();
	int    AddObject(PPObjID oi, const char * pName);
	int    SearchObjects(const char * pText, PPID objType, long flags, RAssocArray & rObjIdScoreList);
	int    ProcessSuprWare(PPID swType, PPID swCls);
	int    ProcessGoods(const GoodsFilt * pFilt);
	int    SearchGoodsAnalogs(PPID goodsID, PPIDArray & rList, SString * pTransitComponentBuf);
private:
	SString TextBuf;  // @allocreuse
	SString IdentBuf; // @allocreuse
};
//
//
//
class PrcssrObjTextFilt : public PPBaseFilt { // @persistent
public:
	PrcssrObjTextFilt();
	PrcssrObjTextFilt & FASTCALL operator = (const PrcssrObjTextFilt & rS);
	virtual bool IsEmpty() const;

	enum {
		fLog  = 0x0001,
		fReplace      = 0x0002,
		fSignal       = 0x0004,
		fDebug        = 0x0008,
		fNnClassifier = 0x0010  // @construction Нейронный классификатор товаров
	};
	enum {
		otiName = 1
	};
	uint8  ReserveStart[32]; // @ancor
	PPID   ObjType;
	long   ObjTextIdent;
	long   Flags;
	uint8  ReserveEnd[32];
	SString RuleFileName;    // @ancor
	GoodsFilt * P_GoodsF;
	BrandFilt * P_BrandF;
	PersonFilt * P_PsnF;
};

class PrcssrObjText {
public:
	static int VerifyRuleFile(const char * pFileName);

	PrcssrObjText();
	~PrcssrObjText();
	int    InitParam(PPBaseFilt *);
	int    EditParam(PPBaseFilt *);
	int    Init(const PPBaseFilt *);
	int    Run();
private:
	struct SignalProcBlock {
		SignalProcBlock();
		enum {
			stOuterTransaction = 0x0001
		};
		int    State;
		PPObjGoods GObj;
	};
	static int SignalProc(const char * pResource, int64 orgOffs, const char * pOrgStr, const char * pSignalStr, void * pExtraPtr);

	PrcssrObjTextFilt P;
	PPTextAnalyzer Ta;
	PPTextAnalyzer::Replacer * P_Rpl;
	SFile  LogF;
};
//
//
//
class PPAutoTranslSvc_Microsoft {
public:
	struct Stat {
        uint   ReqCount;
        uint   InpChrCount;
        uint   OutpChrCount;
        uint64 TotalTiming;
	};
	PPAutoTranslSvc_Microsoft();
	~PPAutoTranslSvc_Microsoft();
	int    Auth(const char * pIdent, const char * pSecret);
    int    Request(int srcLang, int destLang, const SString & rSrcText, SString & rResult);
    PPAutoTranslSvc_Microsoft::Stat & GetStat() const;
private:
	Stat   S;
	long   ExpirySec;
	int    LastStatusCode;
	SString LastStatusMessage;
	LDATETIME AuthTime;
	SString AuthName;
	SString AuthSecret;
	SString Token;
	xmlParserCtxt * P_XpCtx;
};
//
// PpyInetDataPrcssr
//
class PpyInetDataPrcssr {
public:
	PpyInetDataPrcssr();
	~PpyInetDataPrcssr();
	int    Init();
	void   Uninit();
	//int  ImportBankList();
	static int EditCfg();
	static int GetCfg(PPInetConnConfig * pCfg);
	static int PutCfg(const PPInetConnConfig * pCfg, int use_ta);
protected:
#ifdef __WIN32__
	void   SetInetError();
	HINTERNET InetSession;
	HANDLE    WinInetDLLHandle;
	PPInetConnConfig IConnCfg;
#endif // __WIN32__
};
//
// FTP via wininet.lib implementation
//
class WinInetFTP {
public:
	WinInetFTP();
	~WinInetFTP();
	int    Init();
	int    Init(const PPInetConnConfig * pCfg);
	int    UnInit();
	int    ReInit();
	int    Connect(PPInternetAccount * pAccount);
	int    Disconnect();
	int    CreateDir(const char * pDir);
	int    Exists(const char * pPath);
	int    GetFileList(const char * pDir, StrAssocArray * pFileList, const char * pMask = 0);
	int    SafeGet(const char * pLocalPath, const char * pFTPPath, int checkDtTm, PercentFunc pf, PPLogger * pLogger);
	int    SafePut(const char * pLocalPath, const char * pFTPPath, int checkDtTm, PercentFunc pf, PPLogger * pLogger);
	int    SafeCD(const char * pPath, int isFullPath, PPLogger * pLogger);
	int    SafeDelete(const char * pPath, PPLogger * pLogger);
	int    SafeDeleteWOCD(const char * pPath, PPLogger * pLogger);
	int    SafeCreateDir(const char * pDir, PPLogger * pLogger);
	int    SafeGetFileList(const char * pDir, StrAssocArray * pFileList, const char * pMask, PPLogger * pLogger);
private:
	int    TransferFile(const char * pLocalPath, const char * pFTPPath, int send, int checkDtTm, PercentFunc pf);
	int    ReadResponse();
	//int    Get(const char * pLocalPath, const char * pFTPPath, int checkDtTm = 0, PercentFunc pf = 0);
	//int    Put(const char * pLocalPath, const char * pFTPPath, int checkDtTm = 0, PercentFunc pf = 0);
	int    Delete(const char * pPath);
	//int    DeleteWOCD(const char * pPath);
	int    CheckSizeAfterCopy(const char * pLocalPath, const char * pFTPPath);
	int    CD(const char * pDir, int isFullPath = 1);

	HINTERNET InetSession;
	HINTERNET Connection;
	PPInetConnConfig IConnCfg;
	HANDLE    WinInetDLLHandle;
	PPInternetAccount Account;
};
//
// Descr: Модуль разбора и обработки po-файлов 
//
class PoBlock : SStrGroup {
public:
	enum {
		fMsgIdToLow  = 0x0001,
		fMsgTxtToLow = 0x0002
	};
	explicit PoBlock(uint flags);
	int    Import(const char * pFileName, const char * pSrcIdent, uint * pSrcId);
	int    GetLangList(LongArray & rList) const;
	int    SearchSourceIdent(const char * pSrcIdent, uint * pSrcId) const;
	int    SearchSourceId(uint srcId, SString * pSrcIdent) const;
	int    Search(const char * pMsgId, uint lang, SString & rMsgText) const;
	int    Search(const char * pSrcIdent, const char * pMsgId, uint lang, SString & rMsgText) const;
	int    Search(uint srcId, const char * pMsgId, uint lang, SString & rMsgText) const;	
	SJson * ExportToJson() const;
	//
	// Descr: Следует вызвать после завершения вставки данных. Функция выполяет 
	//   всякие индексирующие операции. В целом, можно и без этого, но все будет медленно.
	//
	void   Finish();
	//
	// Descr: Сортирует внутренний массив в порядке {msgid; lang; msgtext}
	//   При этом lang сравнивается как целочисленное значение (не как текстовое представление).
	//
	void   Sort();
private:
	struct Entry {
		explicit Entry(uint lang = 0) : SrcId(0), MsgId(0), Lang(lang), TextP(0)
		{
		}
		uint   SrcId; // Ид источника данных (если контейнер не дифференцирует источники, то 0)
		uint   MsgId;
		uint   Lang;
		uint   TextP;
	};
	static DECL_CMPFUNC(PoBlock_Entry_Sort);
	static DECL_CMPFUNC(PoBlock_Entry_Sort_Internal);
	static DECL_CMPFUNC(PoBlock_Entry_Srch_Internal);
	int    RegisterSource(const char * pSrcIdent, uint * pSrcId);
	int    Add(uint lang, const char * pMsgId, const char * pText);
	void   SortInternal();

	uint   Flags;
	uint   Order; // 0 - undef, 1 - user, 2 - internal (for binary search)
	uint   LastMsgId;
	SString Ident; // 
	TSVector <Entry> L;
	SymbHashTable MsgIdHash; // Здесь же храняться текстовые идентификаторы источников (с префиксом /S/)
};
//
//
//
class PPOsm : public SStrGroup {
public:
	enum {
		otUnkn = 0,
		otNode,
		otWay,
		otRelation
	};
	struct Tile { // @persistent @flat
		Tile();
		Tile(const Tile & rS);
		Tile & FASTCALL operator = (const Tile & rS);
		void   SetInvisible();
		void   FASTCALL SetLevel(uint8 level);
		uint8  GetLevel() const;
		uint32 GetZValue() const;

		uint32 V;
	};
	//
	// Descr: Представление точки карты
	//
    struct NPoint { // @flat
    	NPoint();
		bool   FASTCALL IsEq(const NPoint & rS) const;
		bool   FASTCALL operator == (const NPoint & rS) const;
		bool   FASTCALL operator != (const NPoint & rS) const;

    	uint64 ID;
		SGeoPosLL_Int C;
    };
	//
	// Descr: Представление точки карты с дополнительным атрибутом - Tile
	//
    struct Node : public NPoint { // @flat
    	Node();
		bool   FASTCALL IsEq(const Node & rS) const;
		bool   FASTCALL operator == (const Node & rS) const;
		bool   FASTCALL operator != (const Node & rS) const;

		Tile   T;
    };
    class NodeRefs {
	public:
		NodeRefs();
		bool   FASTCALL IsEq(const NodeRefs & rS) const;
		int    AddWayRef(uint64 nodeID, uint64 wayID);
		int    AddRelRef(uint64 nodeID, uint64 relID);
		void   Clear();
		void   Sort();

		LLAssocArray WayRefs;
		LLAssocArray RelRefs;
    };
    struct Way {
    	Way();
		void   Clear();
    	bool   FASTCALL IsEq(const Way & rS) const;
		bool   FASTCALL operator == (const Way & rS) const;
		bool   FASTCALL operator != (const Way & rS) const;

		uint64 ID;
		Tile   T;
		Int64Array NodeRefs;
    };
	struct RelMember { // @flat
		RelMember();
		uint64 RefID;
		uint   TypeSymbID;
		uint   RoleSymbID;
	};
    struct Relation {
    	Relation();
		uint64 ID;
		Tile   T;
		TSVector <RelMember> MembList;
    };
    struct Tag { // @flat
    	Tag();
        uint   KeySymbID; // Идентификатор символа
        uint64 ValID;     // Идентификатор значения (в варианте теста все значения хранятся в таблице символов)
    };

	struct NodeClusterStatEntry { // @flat
		uint   LogicalCount;
		uint64 ClusterCount;
		uint64 ActualCount;
		uint64 ProcessedCount; // Количество узлов, которые уже находились в БД при попытке их добавить
		uint64 Size;
	};
	struct WayStatEntry { // @flat
		uint   RefCount;
		uint64 WayCount;
		uint64 ProcessedCount; // Количество элементов, которые уже находились в БД при попытке их добавить
		uint64 Size;
	};
	//
	// Descr: Специализированная структура для упакованного хранения группы точек, принадлежащих
	//   одному тайлу. Формат хранения проще всего определяется функциями
	//   NodeCluster::Put и NodeCluster::Implement_Get
	//
	class NodeCluster : private SBuffer {
	public:
		NodeCluster();
		~NodeCluster();
        static uint GetPossiblePackCount(const Node * pN, size_t count, uint * pPossibleCountLogic);

		struct Put__Param {
			Put__Param(const Node * pN, uint nodeCount);

			const  Node * P_N;
			const  LLAssoc * P_NrWayRefs;
			const  LLAssoc * P_NrRelRefs;
			uint   NCount;
			uint   NrWayRefsCount;
			uint   NrRelRefsCount;
		};
		struct Put__Result {
			Put__Result();

			uint   ActualCount;
			uint   ActualNrWayCount;
			uint   ActualNrRelCount;
			uint   NrWayShift; // Количество проверенных элементов из Put__Param::P_NrWayRefs.
				// На это значение надо сдвинуть вперед соответствующий счетчик при следующей итерации.
			uint   NrRelShift; // Количество проверенных элементов из Put__Param::P_NrRelRefs.
				// На это значение надо сдвинуть вперед соответствующий счетчик при следующей итерации.
		};

        int    Put__(const Put__Param & rP, uint64 * pOuterID, Put__Result * pResult, uint forceLogicalCount);
		int    Get(uint64 outerID, TSVector <Node> & rList, NodeRefs * pNrList);
		int    Get(uint64 outerID, TSVector <Node> & rList, NodeRefs * pNrList, Node * pHead, uint * pCountLogic, uint * pCountActual);
		size_t GetSize() const;
		int    GetCount(uint64 outerID, uint * pLogicCount, uint * pActualCount);
		//
		// Descr: Возвращает заголовочный идентификатор кластера.
		// Note: Функция non-const из-за операций чтения SBuffer, которые
		//   меняют его смещение. Однако, в реальности, состояние объекта не меняется - смещения
		//   восстанавливаются в изначальном виде.
		// Returns:
		//   0 - error
		//   4 - идентификатор может быть представлен 4-байтовым значением
		//   8 - идентификатор может быть представлен только 8-байтовым значением
		//
		int    FASTCALL GetHeaderID(uint64 * pID);
		//
		// Descr: Возвращает заголовочный тайл кластера.
		// Note: Так же как и GetHeaderID эта функция non-const по спецификации,
		//   но фактически состояния объекта не меняет.
		//
		int    FASTCALL GetTile(uint64 outerID, Tile * pT);
		const void * FASTCALL GetBuffer(size_t * pSize) const;
		//
		// Descr: Формирует блок кластера из "сырого" буфера данных.
		// Note: Функция опасная - она не проверяет корректности устанавливаемых данных.
		//   Используется для обмена данными с базой данных.
		//
		int    SetBuffer(const void * pData, size_t size);
	private:
		enum {
			indfCountMask   = (0x01 | 0x02 | 0x04), // Маска битов, представляющих количество точек в пакете.
				// 0: 1, 1: 2, 2: 4, 3: 8, 4: 16, 5: 32, 6: 64, 7: 128
			indfId32        = 0x08, // Идентификатор точки представлен 32-битным значением
			indfOuterId     = 0x10, // Идентификатор точки хранится отдельно (специально для K-V хранилищ: ид держится в ключе)
			indfHasRefs     = 0x20, // В конце кластера могут быть ссылки Way->Node и(или) Relation->Node. Если флаг установлен, то
				// в любом случае последним байтом буфера будет терминатор refindfTerminal
		};
		enum {
			infindfEmpty = 0x01, // Точка отсутствует (пропуск идентификатора). Все остальные флаги в этом случае незначимы.
			infindfPrevLatIncr8  = 0x02, // Широта представлена int8-инкрементом относительно предыдущей точки
			infindfPrevLatIncr16 = 0x04, // Широта представлена int16-инкрементом относительно предыдущей точки
			infindfPrevLonIncr8  = 0x08, // Долгота представлена int8-инкрементом относительно предыдущей точки
			infindfPrevLonIncr16 = 0x10, // Долгота представлена int16-инкрементом относительно предыдущей точки
			infindfHasTags       = 0x20, // Точка имеет теги
			infindfDiffTileLevel = 0x80  // Точка имеет отличный от заголовочной уровень тайла
		};
		enum {
			refindfIdSizeMask     = (0x01 | 0x02 | 0x04), // Маска размера идентификатора (в байтах)
			refindfTerminal       = 0x08, // Терминальный индикатор (определяет конец серии ссылок - все остальные биты нулевые)
			refindfWay    = 0x10,
			refindfRelation       = 0x20
		};
		// Формат серии ссылок: [(indicator:byte) (position: byte) (id)] (terminal_indicator:byte)
		int    Implement_Get(uint64 outerID, TSVector <Node> * pList, NodeRefs * pNrList, Node * pHead, uint * pCountLogic, uint * pCountActual);
	};
	class WayBuffer : private SBuffer {
	public:
		WayBuffer();
		int    Put(const Way * pW, uint64 * pOuterID);
		int    Get(uint64 outerID, Way * pW);
		const  void * FASTCALL GetBuffer(size_t * pSize) const;
		int    SetBuffer(const void * pData, size_t size);
		size_t GetSize() const;
	private:
		// (IND) [ID] (TileLevel) [COUNT] ([INFIND] (POINT-ID))+
        enum {
        	indfLoop  = 0x01, // Замкнутый контур (последняя точка равна первой и не хранится в буфере)
            indfIncremental8  = 0x02, // Первая точка хранится как есть, все последующие - байтовый инкремент от предыдущей точки
            indfIncremental16 = 0x04, // Первая точка хранится как есть, все последующие - 2-байтовый инкремент от предыдущей точки
				// Если !(indfIncremental8|indfIncremental16), то идентификаторы всех точек хранятся с байтовым префиксом
				// определяющим способ хранения соответствующего значения.
            indfRectangle     = 0x08, // Замкнутый контур из 4 точек (предполагает одновременную установку indfLoop)
            indfCount8        = 0x10, // Количество точек байтовое (иначе - 4 байтовое)
				// Если !indfRectangle, то количество точек указывается явно (общее, включая замыкающую для контура)
            indfFirstId32     = 0x20, // Идентификатор первой точки 4-байтовый (в противном случае - 8-байтовый)
			indfId32  = 0x40, // Идентификатор объекта представлен 32-битным значением
			indfOuterId       = 0x80  // Идентификатор объекта хранится отдельно (специально для K-V хранилищ: ид держится в ключе)
        };
        enum {
        	infindfSizeMask      = (0x01|0x02|0x04),
        	infindfIncremental   = 0x08
        };
	};
	enum {
		stGridLoaded = 0x0001
	};

	PPOsm(const char * pDbPath);
	~PPOsm();
	long   FASTCALL CheckStatus(long) const;
	uint   FASTCALL SearchSymb(const char * pSymb) const;
	uint   FASTCALL CreateSymb(const char * pSymb);
	int    GetSymbByID(uint id, SString & rSymb) const;
	int    BuildHashAssoc();
	int    LoadGeoGrid();
	const  SGeoGridTab & GetGrid() const { return Grid; }
	int    OpenDatabase(const char * pDbPath);
	SrDatabase * GetDb();
	static int FASTCALL SetNodeClusterStat(NodeCluster & rCluster, TSVector <NodeClusterStatEntry> & rStat);
	static int FASTCALL SetProcessedNodeStat(uint logicalCount, uint qtty, TSVector <NodeClusterStatEntry> & rStat);
	static int FASTCALL SetWayStat(WayBuffer & rWayBuf, TSVector <WayStatEntry> & rStat);
	static int FASTCALL SetProcessedWayStat(uint refCount, uint qtty, TSVector <WayStatEntry> & rStat);
private:
	SrDatabase * P_SrDb;
	long   Status;
	uint   LastSymbID;
	SymbHashTable Ht;
	SGeoGridTab Grid;
};

class PrcssrOsmFilt : public PPBaseFilt { // @persistent
public:
	PrcssrOsmFilt();
	PrcssrOsmFilt & FASTCALL operator = (const PrcssrOsmFilt & rS);
	virtual bool IsEmpty() const;

	enum {
		fPreprocess        = 0x0001, // Предварительная обработка osm-файла с выводом текстовых данных для дальнейшей обработки
		fSortPreprcResults = 0x0002, // Сортировка файлов, полученных в фазе препроцессинга
		fAnlzPreprcResults = 0x0004, // Анализ данных, полученных в фазах препроцессинга и сортировки
		fImport    = 0x0008, // Импорт данных osm во внутреннюю базу данных
		fExtractSizes      = 0x0010  // Извлечение размеров объектов и вывод их в файл
	};
	uint8  ReserveStart[32]; // @ancor
	long   Flags;
	uint8  ReserveEnd[32];
	SString SrcFileName;     // @anchor
};

class PrcssrOsm {
public:
	PrcssrOsm(const char * pDbPath);
	~PrcssrOsm();
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int    Init(const PPBaseFilt * pBaseFilt);
	int    Run();
	void   Reset();
private:
	struct CommonAttrSet {
		CommonAttrSet();
		void   Reset();

		int64  ID;
		double Lat;
		double Lon;
        LDATETIME T;
        int    Ver;
        int    Visible;
        int64  ChangeSet;
        int64  UserID;
		uint   TypeSymbID;
		uint   RoleSymbID;
		int64  RefID;
        SString User;
	};
	struct StatBlock { // @persistent
		StatBlock();
		void   Clear();
		int    Serialize(int dir, SBuffer & rBuffer, SSerializeContext * pSCtx);
		uint64 GetNcActualCount() const;
		uint64 GetNcProcessedCount() const;
		uint64 GetNcClusterCount() const;
		uint64 GetNcSize() const;
		uint64 GetWsCount() const;
		uint64 GetWsProcessedCount() const;
		uint64 GetWsSize() const;

		uint64 NodeCount;
		uint64 NakedNodeCount; // Количество узлов без тегов
		uint64 WayCount;
		uint64 RelationCount;
		uint64 TagNodeCount;
		uint64 TagWayCount;
		uint64 TagRelCount;
		TSVector <PPOsm::NodeClusterStatEntry> NcList;
		TSVector <PPOsm::WayStatEntry> WayList;
	};
	struct RoadStone { // @persistent
		RoadStone();
		int    Serialize(int dir, SBuffer & rBuffer, SSerializeContext * pSCtx);
		SString SrcFileName;
		long   Phase;
		PrcssrOsm::StatBlock Stat;
	};
	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);
	static int  SortCbProc(const SFileSortProgressData * pInfo);
	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    SaxParseFile(xmlSAXHandler * sax, const char * pFileName);
	void   SaxStop();
	int    GetPhaseSymb(long phase, SString & rSymb) const;
	int    ReadCommonAttrSet(const char ** ppAttrList, CommonAttrSet & rSet);
	int    FASTCALL FlashNodeAccum(int force);
	int    LogCoord(const SGeoPosLL_Int & rC);
	int    LogTag(int osmObjType, const PPOsm::Tag & rTag);
	int    SortFile(const char * pSrcFileName, const char * pSuffix, CompFunc fcmp);
	int    CreateGeoGridTab(const char * pSrcFileName, uint lowDim, uint uppDim, TSCollection <SGeoGridTab> & rGridList);
	int    OutputStat(int detail);
	int    ProcessWaySizes();
	int    WriteRoadStone(RoadStone & rRs);
	int    ReadRoadStone(long phase, RoadStone & rRs);
	//
	enum {
		stError = 0x0001
	};
	long   State;
	enum {
		phaseUnkn              = 0,
		phasePreprocess        = 1,
		phaseSortPreprcResults = 2,
		phaseAnlzPreprcResults = 3,
		phaseImport            = 4,
		phaseExtractSizes      = 5
	};
	long   Phase;
	PrcssrOsmFilt P;
	const SymbHashTable * P_ShT; // Таблица символов, полученная вызовом PPGetStringHash(int)
	xmlParserCtxt * P_SaxCtx;
	TSStack <int> TokPath;
	SGeo   G;
	PPOsm  O;
	CommonAttrSet TempCaSet;
	TSVector <PPOsm::Tag> CurrentTagList;
	PPOsm::Node LastNode;
	PPOsm::Way  LastWay;
	PPOsm::Relation LastRel;
	StatBlock Stat;
	StatBlock RestoredStat;
	RoadStone * P_RoadStoneStat;
	LongArray LatAccum;
	LongArray LonAccum;
	TSVector <PPOsm::Node> NodeAccum;
	TSCollection <PPOsm::Way> WayAccum;
	LLAssocArray NodeWayAssocAccum;
	SGeoGridTab::Finder GgtFinder;
	SString FmtMsg_SortSplit;
	SString FmtMsg_SortMerge;
	LLAssoc LastNodeToWayAssoc; // Последняя ассоциация node-way считанная из P_NodeToWayAssocInF (и не попавшая в предыдущую порцию сохранения)
	SFile * P_LatOutF;
	SFile * P_LonOutF;
	SFile * P_NodeToWayAssocOutF;
	SFile * P_TagOutF;
	SFile * P_TagNodeOutF;
	SFile * P_TagWayOutF;
	SFile * P_TagRelOutF;
	SFile * P_SizeOutF; // Файл вывода размерностей (максимальных расстояний внутри Way-ев).
	SFile * P_NodeToWayAssocInF;
	SFile * P_TestNodeBinF;
	SFile * P_TestNodeF;
	PPUserFuncProfiler * P_Ufp;

	struct ProcessBlock {
		SString TempBuf;   // @allocreuse
		SString AttrBuf;   // @allocreuse
		SString LineBuf;   // @allocreuse
		SString TagKeyBuf; // @allocreuse Временный буфер для хранения ключа тега
		SString TagValBuf; // @allocreuse Временный буфер для хранения значения тега
		LLAssocArray NodeToWayAsscList;
	};

	ProcessBlock Pb;
	LongArray TempTagKeyList;
	LongArray TagKeyList; // Отладочный список ключевых символов тегов.
	PPLogger Logger;
};
//
//
//
class PrcssrSartreFilt : public PPBaseFilt { // @persistent
public:
	PrcssrSartreFilt();
	PrcssrSartreFilt & FASTCALL operator = (const PrcssrSartreFilt & rS);
	virtual bool IsEmpty() const;

	enum {
		fImportFlexia      = 0x0001,
        fImportConcepts    = 0x0002,
        fImportHumNames    = 0x0004,
        fTestFlexia        = 0x0008,
        fTestConcepts      = 0x0010,
		fTestSyntaxParser  = 0x0020,
		fImportBioTaxonomy = 0x0040, //
		fImportTickers     = 0x0080, //
		fImport_UED_Llcc   = 0x0100  // Технология UED: импорт языков/локалей/государств/валют
	};
	uint8  ReserveStart[32]; // @ancor
	long   Flags;
	uint8  ReserveEnd[32];
	SString SrcPath;         // @anchor
};

class PrcssrSartre {
public:
	PrcssrSartre(const char * pDbPath);
	~PrcssrSartre();
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int    Init(const PPBaseFilt * pBaseFilt);
	int    Run();
	//int    ResolveSyntaxRules(SrSyntaxRuleSet & rSet, SrDatabase & rDb);
private:
	int    ImportHumanNames(SrDatabase & rDb, const char * pSrcFileName, const char * pLinguaSymb, int properNameType, int specialProcessing);
	int    ImportBioTaxonomy(SrDatabase & rDb, const char * pFileName);
	int    ImportTickers(SrDatabase & rDb, const char * pExchangeSymb, const char * pFileName);
	int    TestSearchWords();
	int    TestConcept();
	int    TestSyntax();
	int    PreprocessCountryNames(const char * pBaseSrcPath);
	int    PreprocessCurrencyNames(const char * pBaseSrcPath);
	int    PreprocessLocaleNames(const char * pBaseSrcPath);
	int    PreprocessLanguageNames(const char * pBaseSrcPath);
	enum {
		llccBaseListOnly = 0x0001
	};
	int    UED_Import_Lingua_LinguaLocus_Country_Currency(uint llccFlags);
	int    UED_Import_PackageTypes();
	int    UED_Import_Atoms();
	int    UED_ImportIcuNames();
	int    UED_Import_Scripts();
	int    UED_Import_DataTypesCompatibleWithSLIB();

	PrcssrSartreFilt P;
};
//
// Descr: Шаблон функции получения указателя на объектный кэш, локальный по отношению к базе данных
//   Используется при обращении объекта PPObject к кэшу.
// Example:
//	int PPObjArticle::Fetch(PPID id, ArticleTbl::Rec * pRec)
//	{
//		ArticleCache * p_cache = GetDbLocalCachePtr <ArticleCache> (Obj);
//		return p_cache ? p_cache->Get(id, pRec) : Search(id, pRec);
//	}
//
template <class C> C * FASTCALL GetDbLocalCachePtr(PPID objType, int doCreate = 1)
{
	C * p_cache = static_cast<C *>(DS.GetDbLocalObjCache(objType));
	if(doCreate && !p_cache) {
		ENTER_CRITICAL_SECTION
		if(!p_cache && !DS.SetDbLocalObjCache(p_cache = new C)) ZDELETE(p_cache);
		LEAVE_CRITICAL_SECTION
	}
	return p_cache;
}
//
//
//
#include <dl600.h>
#include <..\Rsrc\DL600\ppexp.h>
#include <..\Rsrc\DL600\ppifc.h>
//
// PPDLGS-START
//
class PPApp : public TProgram {
public:
	PPApp(HINSTANCE hInst, const char * pAppSymb, const char * pAppName, uint ctrflags);
	void   login(int processCmdLine /*= 1*/);
	int    processCommand(uint);
	//
	// Descr: Находит открытое окно ассистирования телефонному разговору
	//
	TWindow * FindPhonePaneDialog();
	uint   LastCmd;
private:
	DECL_HANDLE_EVENT;
	virtual int  InitStatusBar();
	// @v11.9.2 virtual int  LoadVectorTools(TWhatmanToolArray * pT);
	virtual const TWhatmanToolArray * GetVectorTools() const; // @v11.9.2 
	virtual SPaintToolBox * GetUiToolBox(); // @v11.9.2
	int    InitDeskTop();
	int    InitMenuBar();
	int    RegisterComServer();
	int    SetDatetimeByServer(PPIniFile * pIniFile, int force);
	enum {
		lsLockSettingTimeByServer = 0x0001
	};
	long   LocalState;
};
//
//
//
class PPViewBrowser : public BrowserWindow {
public:
	static int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, void * extraProcPtr);

	PPViewBrowser(uint brwId, DBQuery *, PPView *, int dataOwner);
	PPViewBrowser(uint brwId, SArray *, PPView *, int dataOwner);
	~PPViewBrowser();
	void   Update(); // @>>PPViewBrowser::updateView()
	int    SetRefreshPeriod(long);
	//
	// Descr: Экспортирует содержимое таблицы в Excel
	//
	int    Export(); 
	int    SetupToolbarCombo(PPID objType, PPID id, uint flags, void * extraPtr);
	int    SetupToolbarCombo(PPID objType, PPID id, uint flags, const PPIDArray & rObjList);
	int    SetupToolbarStringCombo(uint strId, PPID id);
	int    GetToolbarComboData(PPID * pID);
	int    Advise(int kind, PPID action, PPID objType, long flags);
	//
	// Descr: Отменяет свойство владение данными (IsDataOwnership).
	//   Вызывается при необходимости разрушить объект таким образом, чтобы
	//   данные, которыми он владеет (P_View) остались нетронутыми.
	// Attention:
	//   Использовать крайне осторожно. При неправильном вызове вероятна значительная потеря памяти.
	//
	int    ResetDataOwnership();
	int    InsColumnWord(int atPos, uint wordId, uint fldNo, TYPEID typ, long fmt, uint opt);
	int    InsColumn(int atPos, const char * pText, uint fldNo, TYPEID typ, long fmt, uint opt);
	//
	// Descr: Устанавливает динамическую альтернативную товарную группу как временную.
	//   Деструктор класса должен удалить все такие группы.
	//
	int    SetTempGoodsGrp(PPID grpID);
	//
	// Descr: Утилитная функция, объявляющая все колонки таблицы сортируемыми.
	//   Используется только из тех контроллеров данных, которые реализуют механизм сортировки по выбранным колонкам.
	//   Прямое использование недопустимо.
	//
	void   Helper_SetAllColumnsSortable();
	PPView * P_View;
protected:
	DECL_HANDLE_EVENT;
	virtual void updateView();
	virtual int  getCurHdr(void *);
	enum {
		vbsDataOwner = 0x0001,
		vbsKbF10     = 0x0002,
		vbsTagPreKey = 0x0004  // @v11.2.8 Нажата клавиша, предваряющая последующее нажатие горячей клавиши для редактирования тега.
			// Так как теги используются многими объектами данных и это состояние требует переопределения базовой функции
			// поиска по вводу первой буквы, то флаг внесен именно в базовый класс, а не множится по производным классам.
	};
	long   VbState;
private:
	int    Advise();
	void   Unadvise();
	int    GetToolbarComboRect(RECT * pRect);
	int    Helper_SetupToolbarCombo(PPID objType, PPID id, uint flags, void * extraPtr, const PPIDArray * pObjList);
	int    Helper_SetupToolbarStringCombo(uint strID, PPID id);
	//
	// Descr: Создает строку с именем результата экспорта. В этой строке исключены символы, недопустимые для имен файлов.
	//   Само имя не содержит никакого расширения.
	//
	SString & Helper_Export_MakeResultName(bool toUtf8, SString & rBuf);
	SString & Helper_Export_MakeResultFilePath(bool toUtf8, const char * pName, SString & rBuf);
	int    Helper_Export_Excel(SString & rResultFileName);
	int    Helper_Export_Excel_OXLSX(SString & rResultFileName);
	//
	// Returns:
	//   !0 - хандлер родительского окна
	//   0 - error
	//
	void * Helper_InitToolbarCombo();

	SCycleTimer RefreshTimer;
	PPIDArray TempGoodsGrpList;  // Список временных товарных групп, которые должны быть разрушены при разрушении браузера
	TInputLine * P_InputLine;    //
	ComboBox   * P_ComboBox;     //
	HFONT        H_ComboFont;    //
	PPIDArray Cookies;           //
};
//
// Descr: Наследник STimeChunkBrowser, реализующий некоторые механизмы,
//   для которых нет инструментария в слое SLIB.
//
class PPTimeChunkBrowser : public STimeChunkBrowser {
public:
	PPTimeChunkBrowser();
protected:
	virtual int ExportToExcel();
};
//
//
//
class ObjViewDialog : public TDialog {
public:
	ObjViewDialog(uint dlgRez, PPObject * aObj, void * extraPtr);
protected:
	DECL_HANDLE_EVENT;
	//
	// Descr: вызывается в ответ на сообщение cmaMore или на нажатие CtrlEnter.
	//   В качестве параметра передается ИД текущего элемента списка.
	//
	virtual void extraProc(long);
	//
	// Descr: вызывается в ответ на сообщение cmTransmit.
	//   Базовая реализация предполагает передачу всех объектов с типом P_Obj->Obj.
	//   Если P_Obj == 0 || !IS_REF_OBJTYPE(P_Obj->Obj) базовая реализация функции
	//   возвращает -1 ничего не делая //
	//
	virtual int  transmit(PPID);
	virtual void addItem();
	virtual void removeItem();
	virtual void editItem();
	virtual int  Print();
	void   updateList(PPID id);
	PPID   getCurrID();

	SmartListBox * P_List;
	PPObject * P_Obj;
	void * ExtraPtr;
	int    Rt;                 // Access rights flags (PPR_XXX)
private:
	int    RemoveAll();
};
//
// Диалог для просмотра объектов унаследованных от PPObjReference с возможностью отправки данных charry
//
class RefObjViewDialog : public ObjViewDialog {
public:
	RefObjViewDialog(uint dlgRez, PPObject * aObj, long charryID, void * extraPtr);
private:
	DECL_HANDLE_EVENT;
	long   CharryID;
};
//
//
//
class PPObjListWindow : public ListWindow {
public:
	//
	// ~PPObjListWindow обязан разрушить объект, передаваемый
	// в качестве параметра конструктору. Немножко нелогично разрушать
	// то, что сам не создавал, однако иногда приходится.
	//
	PPObjListWindow(PPObject *, uint aFlags, void * extraPtr);
	PPObjListWindow(PPID objType, StrAssocArray *, uint aFlags, void * extraPtr);
	~PPObjListWindow();
protected:
	DECL_HANDLE_EVENT;
	// @v12.2.6 virtual int FASTCALL valid(ushort command);
	virtual int Transmit(PPID);
	void   PostProcessHandleEvent(int update, PPID focusID);

	uint   Flags;
	uint   DefaultCmd; // Команда по умолчанию. Вызывается по двойному клику, либо нажатию клавиши Enter.
	void * ExtraPtr;
	PPObject * P_Obj;
private:
	void   Init(PPObject * aPPObj, uint aFlags, void * extraPtr);
	bool   ValidateCommand(TEvent & rEv);
};

class PPObjBrowser : public BrowserWindow {
public:
	PPObjBrowser(uint rezID, DBQuery * q, PPObject * _ppobj, uint _flags, void * extraPtr);
protected:
	DECL_HANDLE_EVENT;
	PPID   currID();
	void   updateView();
	void   SetPPObjPtr(PPObject *);

	uint   flags;
	void * ExtraPtr;
	PPObject * ppobj;
};

struct ListToListUIData {
	ListToListUIData();
	enum {
		fCanInsertNewItem = 0x0001,
		fIsTreeList       = 0x0002
	};
	uint   LeftCtlId;
	uint   RightCtlId;
	uint   Flags;
	uint   TitleStrID; // PPSTR_TEXT
	char * P_Title;
};

class Lst2LstDialogUI : public TDialog {
public:
	Lst2LstDialogUI(uint rezID, ListToListUIData *);
protected:
	DECL_HANDLE_EVENT;
	virtual int  addItem();
	virtual int  addNewItem();
	virtual int  removeItem();
	virtual int  addAll();
	virtual int  removeAll();
	SmartListBox  * GetLeftList();
	SmartListBox  * GetRightList();
	uint   GetLeftSelectionList(LongArray * pList);
	uint   GetRightSelectionList(LongArray * pList);
private:
	enum defButton {
		b_ok = 0,
		b_fw = 1,
		b_bw = 2
	};
	int    setup();
	ListToListUIData Data;
};

struct ListToListAryData : public ListToListUIData {
	ListToListAryData(uint rezID = 0, SArray * pLList = 0, SArray * pRList = 0);
	uint   RezID;
	SArray * P_LList;
	SArray * P_RList;
};

class Lst2LstAryDialog : public Lst2LstDialogUI {
public:
	Lst2LstAryDialog(uint rezID, ListToListUIData * pData, SArray * pLeft, SArray * pRight);
	int    getDTS(SArray * /*LstItem array*/);
protected:
	int    setupLeftList();
	int    setupRightList();
	virtual int SetupList(SArray *, SmartListBox *);
	virtual int addItem();
	virtual int addAll();
	virtual int removeItem();
	virtual int removeAll();
	SArray * GetRight() const;
	SArray * GetLeft() const;
private:
	SArray * P_Right;
	SArray * P_Left;
};

struct ListToListData : public ListToListUIData {
	ListToListData(PPID objType, void * extraPtr, PPIDArray * pList);
	ListToListData(const StrAssocArray * pSrcList, PPID objType, PPIDArray * pList);

	PPID   ObjType;
	void * ExtraPtr;
	const  StrAssocArray * P_SrcList;
	PPIDArray * P_List;
};

class Lst2LstObjDialog : public Lst2LstDialogUI {
public:
	Lst2LstObjDialog(uint rezID, ListToListData *);
	~Lst2LstObjDialog();
	int    getDTS(PPIDArray *);
protected:
	DECL_HANDLE_EVENT;
	int    setup();
	int    setupLeftList();
	int    setupRightList();
	int    setupRightTList();
	int    FASTCALL Helper_AddItemRecursive(PPID id, StdTreeListBoxDef * pDef);
	int    FASTCALL Helper_RemoveItemRecursive(PPID id, StdTreeListBoxDef * pDef);
	void   GetItemText(long id, SString & rBuf);
	int    SelectByTag();
	bool   IsSelectionByTagEnabled(PPID * pRealObjType);
	virtual int addItem();
	virtual int addNewItem();
	virtual int removeItem();
	virtual int addAll();
	virtual int removeAll();

	ListToListData Data;
	PPObject * P_Object;
};
//
//
//
class SCardSeriesView : public ObjViewDialog {
public:
	SCardSeriesView(PPObjSCardSeries * _ppobj);
	virtual void extraProc(long id);
	int    InitIteration();
	int    FASTCALL NextIteration(PPSCardSeries * pRec);
	int    Print();
	uint   CurPrnPos;
};

class PPObjSCardSeriesListWindow : public PPObjListWindow {
public:
	PPObjSCardSeriesListWindow(PPObject * pObj, uint flags, void * extraPtr);
	int    InitIteration();
	int    FASTCALL NextIteration(PPSCardSeries * pRec);
private:
	DECL_HANDLE_EVENT;

	uint   CurIterPos;
	SCardSeriesFilt Filt;
};
//
//
//
class SpecialInputCtrlGroup : public CtrlGroup {
public:
	explicit SpecialInputCtrlGroup(uint ctlId, uint rdDelay = 1000);
	~SpecialInputCtrlGroup();
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlId;
	uint   RdDelay;
	SCycleTimer RdTimer;
	PPAbstractDevice * P_Ad;
	StrAssocArray Out;
};
//
//
//
class AcctCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		AcctID AcctId;      // @INOUT
		PPID   AccSheetID;  // @INOUT
		long   AccSelParam; // @IN (ACY_SEL_XXX, -1, -100)
		long   AccType;     // @OUT Type of selected account (ACY_XXX). -1 - undefined
	};
	AcctCtrlGroup(uint _ctl_acc, uint _ctl_art, uint _ctlsel_accnam, uint _stlsel_artnam);
	~AcctCtrlGroup();
	virtual int setData(TDialog *, void *); // (AcctCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (AcctCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   setup(TDialog *, const Acct * acct, int sheetChanged, int accSelParamChanged = 0);
	void   processAccCombo(TDialog *);
	void   processArtCombo(TDialog *);
	int    processAccInput(TDialog *);
	int    processArtInput(TDialog *);

	PPObjAccTurn * ppobj;
	AcctID AcctId;
	PPID   AccSheetID;
	PPID   CurID;
	long   AccSelParam;
	uint   ctl_acc;
	uint   ctl_art;
	uint   ctlsel_accname;
	uint   ctlsel_artname;
};

class ArticleCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		Rec(PPID acsID, PPID opID, const ObjIdListFilt * pArList);
		Rec(PPID acsID, PPID opID, PPID arID);

		PPID   AcsID;
		PPID   OpID;
		ObjIdListFilt ArList;
	};
	enum {
		fByOpAccSheet2        = 0x0001, // При выборе вида операции брать дополнительную таблицу статей операции
		fNonEmptyExchageParam = 0x0002, // Показывать только статьи с не пустой конфигурацией обмена в соглашении
			// Проекция флага sacfNonEmptyExchageParam
		fUseByContextValue    = 0x0004  // @v11.4.7  
	};
	ArticleCtrlGroup(uint ctlselAcs, uint ctlselOp, uint ctlselAr, uint cmEditList, PPID accSheetID, long flags = 0);
	void   SetAccSheet(long accSheetID);
	virtual int setData(TDialog *, void *); // (ArticleCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (ArticleCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    selectByCode(TDialog *);
	void   SetupAccSheet(TDialog * pDlg);
	void   SetupOp(TDialog * pDlg);

	Rec    Data;
	PPID   OpID;
	PPID   AccSheetID;
	long   Flags;
	const uint   CtlselAcs;
	const uint   CtlselOp;
	const uint   CtlselAr;
	const uint   CmEditList;
};

class TextHistorySelExtra : public WordSel_ExtraBlock {
public:
	explicit TextHistorySelExtra(const char * pKey);
	virtual StrAssocArray * GetList(const char * pText);
	virtual StrAssocArray * GetRecentList();
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
	virtual void OnAcceptInput(const char * pText, long id);
private:
	const SString Key;
};

class SCardSelExtra : public WordSel_ExtraBlock {
public:
	explicit SCardSelExtra(PPID serId);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   SerID;
	PPObjSCard ScObj;
};

class PhoneSelExtra : public WordSel_ExtraBlock {
public:
	enum {
		lfPerson    = 0x0001,
		lfLocation  = 0x0002,
		lfStandaloneLocOnly = 0x0004
	};
	explicit PhoneSelExtra(long localFlags);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	long   LocalFlags;
	//EAddrCore * P_Eac;
	PPObjPerson PsnObj;
};

class FiasSelExtra : public WordSel_ExtraBlock {
public:
	explicit FiasSelExtra(PPFiasReference * pOuterFiasRef);
	~FiasSelExtra();
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	enum {
		stOuterFiasRef = 0x0001
	};
	long   State;
	PPFiasReference * P_Fr;
};

class PersonSelExtra : public WordSel_ExtraBlock {
public:
	PersonSelExtra(PPID accSheetID, PPID personKindID);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   PersonKindID;
	PPID   AccSheetID;     // Если != 0, то означает что поиск будет вестись по статьям, иначе по персоналиям.
	PPID   SrchRegTypeID;
	PPIDArray InhRegTypeList; // список наследуемых регистров для отношения филиал<->главная организаци
	PPObjPerson PsnObj;
	PPObjArticle ArObj;
};

class ObjTagSelExtra : public WordSel_ExtraBlock {
public:
	enum {
		lfOpenedSerialsOnly = 0x0001 // Только для objType == PPOBJ_LOT и tagID == PPTAG_LOT_SN: отображать только серии открытых лотов
	};
	ObjTagSelExtra(PPID objType, PPID tagID);
	void   SetupLotSerialParam(PPID locID, long flags);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   ObjType;
	PPID   TagID;
	long   LocalFlags;
	PPID   LocID;
	PPObjTag TagObj;
	StrAssocArray TextBlock;
};

class PersonCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();

		enum {
			fAnonym = 0x0001
		};
		PPID   PsnKindID;
		PPID   PersonID;
		PPID   SCardID;
		long   Flags;
	};
	enum {
		fCanInsert = 0x0001, // OLW_CANINSERT
		fLoadDefOnOpen     = 0x0002, // OLW_LOADDEFONOPEN
		fDefComboFlags     = fCanInsert,
		fUseByContextValue = 0x0004  // @v11.1.10 OLW_INSCONTEXTEDITEMS
	};
	PersonCtrlGroup(uint ctlsel, uint ctlSCardCode, long psnKindID, long flags = fDefComboFlags);
	void   SetAnonymCtrlId(uint ctl);
	void   SetPersonKind(long psnKindID);
	virtual int setData(TDialog * pDlg, void *);
	virtual int getData(TDialog * pDlg, void *);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent &);
	int    SelectByCode(TDialog * pDlg);
	void   SetupAnonym(TDialog * pDlg, int a);

	uint   Ctlsel;
	uint   CtlSCardCode; //
	uint   CtlAnonym;    //
	long   Flags;
	Rec    Data;
	PPObjPerson PsnObj;
	PPObjSCard ScObj;
};

class PersonListCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(PPID psnKindID = 0, const PPIDArray * pPersonList = 0);
		void   Init(PPID psnKindID = 0, const PPIDArray * pPersonList = 0);

		PPID   PsnKindID;
		PPIDArray List;
	};
	PersonListCtrlGroup(uint ctlsel, uint ctlSelPsnKind, uint cmPsnList, long flags);
	~PersonListCtrlGroup();
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    SelectByCode(TDialog *);
	int    Setup(TDialog * pDlg, long psnKindID, int force = 0);

	uint   Ctlsel;
	uint   CtlselPsnKind;
	uint   CmPsnList;
	long   Flags;
	Rec    Data;
	PPObjPerson PsnObj;
};

class SCardCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();

		PPID   SCardID;
		PPIDArray SCardSerList;
	};
	SCardCtrlGroup(uint ctlselSCardSer, uint ctlSCard, uint cmScsList);
	virtual int setData(TDialog *, void *); // (SCardCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (SCardCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg, int onInit);

	Rec    Data;
	const  uint CtlselSCardSer;
	const  uint CtlSCard;
	const  uint CmSCSerList;
};

class FiasAddressCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();

		SString InputLine;
		PPID   TerminalFiasID;
        S_GUID TerminalFiasUUID;
	};
	FiasAddressCtrlGroup(uint ctlEdit, uint ctlInfo);
	virtual int setData(TDialog *, void *); // (FiasAddressCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (FiasAddressCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg, int event);
	Rec    Data;
	const  uint CtlEdit;
	const  uint CtlInfo;

	PPFiasReference Fr;
};
//
// Descr: Группа управляющих элементов для выбора товара. Содержит собственно комбо-бокс для выбора товара, а так же
//   комбо-бокс для выбора товарной группы.
//
class GoodsCtrlGroup : public CtrlGroup {
public:
	enum { // flags
		disableEmptyGoods         = 0x0001, // Сообщать об ошибке если товар не выбран
		enableSelUpLevel          = 0x0002, // Разрешать выбор группы верхнего уровня //
		existsGoodsOnly           = 0x0004, // Выбирать только те товар, которые есть на складе
		enableInsertGoods         = 0x0008, // Разрешить создание нового товара
		activateGoodsListOnGroupSelection = 0x0010, // Активизировать список товаров при выборе группы
		ignoreRtOnlyGroup         = 0x0020  // Игнорировать ограничение правам доступа единственной группы
	};
	struct Rec {
		explicit Rec(PPID grpID = 0, PPID goodsID = 0, PPID locID = 0, uint flags = 0);
		PPID   GoodsID;
		PPID   GoodsGrpID; //
		PPID   LocID;      // Склад (используется только если задан флаг existsGoodsOnly). Если 0, то предполагается текущий склад (LConfig.Location)
		PPID   ArID;       // Контекстная статья для поиска товара по артикулу
		uint   Flags;
	};
	GoodsCtrlGroup(uint _ctlsel_grp, uint _ctlsel_goods);
	~GoodsCtrlGroup();
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
	int    setFlagExistsOnly(TDialog *, int on);
	int    setFlag(TDialog * pDlg, long flag, int on);
	int    setFilt(TDialog * pDlg, const GoodsFilt * pFilt);
private:
	virtual void   handleEvent(TDialog *, TEvent &);
	void   SetupCtrls(TDialog *);
	uint   CtlselGrp;
	uint   CtlselGoods;
	uint   CtlGrp;
	uint   CtlGoods;
	uint   Flags;
	PPID   LocID;
	PPID   ArID;         // Контекстная статья для поиска товара по артикулу
	PPID   TempAltGrpID;
	GoodsFilt * P_Filt;
};
//
// Descr: Группа управляющих элементов для выбора товара. Содержит собственно комбо-бокс для выбора товара, а так же
//   комбо-бокс для выбора товарной группы. В отличии от GoodsCtrlGroup может содержать кнопку вызова фильтра товаров
//   для расширенного выбора набора товаров.
//
class GoodsFiltCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(PPID grpID = 0, PPID goodsID = 0, PPID locID = 0, long flags = 0, void * extraPtr = 0);
		PPID   GoodsID;
		PPID   GoodsGrpID;
		PPID   LocID;
		long   Flags;       // @flags GoodsCtrlGroup::
		void * ExtraPtr;
	};
	GoodsFiltCtrlGroup(uint ctlselGoods, uint ctlselGGrp, uint cm);
	virtual int setData(TDialog *, void *); // (GoodsFiltCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (GoodsFiltCtrlGroup::Rec*)
	int    IsGroupSelectionDisabled() const;
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    EditFilt(TDialog *);
	void   SetupCtrls(TDialog * pDlg);

	int    DisableGroupSelection;
	Rec    Data;
	GoodsFilt Filt;
	const uint CtlselGoods;
	const uint CtlselGoodsGrp;
	const uint Cm;
	PPObjGoods GObj;
};

class BrandCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(const PPIDArray * pList = 0);
		PPIDArray List;
	};
	BrandCtrlGroup(uint ctlsel, uint cmSelList);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg);

	uint   Ctlsel;
	uint   CmSelList;
	Rec    Data;
};

class EmbedDialog : public TDialog {
public:
	explicit EmbedDialog(uint resID);
	~EmbedDialog();
	int    Embed(TDialog * pDlg);
protected:
	virtual void setChildPos(uint neighbourCtl);
	TDialog * P_ChildDlg;
};
//
// Перенесен из Cshmchn.cpp
//
class CSPanel : public TDialog {
public:
	enum {
		fcspZReport   = 0x0001,
		fcspZRepCopy  = 0x0002,
		fcspXReport   = 0x0004,
		fcspCheckCopy = 0x0008
	};
	CSPanel(uint rezID, PPID aNodeID, char * nodeName, int fZReport /* fcspXXX, -1 - is locked */);
private:
	DECL_HANDLE_EVENT;
	void   ResetButtons();

	int    UseKeyboardWKey;
};

class CurAmtCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();

		double Amount;
		PPID   CurID;
		double CRate;
		double BaseAmount;
		LDATE  CRateDate;
	};
	CurAmtCtrlGroup(uint amtCID, uint curSelCID, uint crateCID, uint baseAmtCID, uint dateCID, uint selCRateCmd, AmtList * pAmtList);
	~CurAmtCtrlGroup();
	virtual int setData(TDialog *, void *); // (CurAmtCtrlGroup::Rec *)
	virtual int getData(TDialog *, void *); // (CurAmtCtrlGroup::Rec *)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   setupCurRate(TDialog *, int fromBase);
	void   setupCurrencyCombo(TDialog *, PPIDArray *);

	const uint AmtCID;
	const uint CurSelCID;
	const uint CRateCID;
	const uint BaseAmtCID;
	const uint SelCRateCmd;
	const uint DateCID;
	LDATE  CRateDate;
	Rec    Data;
	AmtList * P_AL;
};

class AccTurnDialog : public TDialog {
public:
	AccTurnDialog(uint rezID, PPObjBill * pBObj);
	int    setDTS(const PPAccTurn * pData, PPBillPacket * pPack, long templFlags = 0);
	int    getDTS(PPAccTurn * pData);
private:
	DECL_HANDLE_EVENT;
	void   setupCurrencyCombo();

	PPObjBill    * P_BObj;
	PPObjAccount AccObj;
	PPBillPacket * P_Pack;
	PPAccTurn      Data; // В форме идентификаторов
};

class DivisionCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(PPID orgID = 0, PPID divID = 0, PPID staffID = 0, PPID postID = 0);
		PPID   OrgID;
		PPID   DivID;
		PPID   StaffID;
		PPID   PostID;
	};
	DivisionCtrlGroup(uint _ctlsel_org, uint _ctlsel_div, uint _ctlsel_staff, uint _ctlsel_post);
	int    setData(TDialog *, void *);
	int    getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	const uint CtlselOrg;
	const uint CtlselDiv;
	const uint CtlselStaff;
	const uint CtlselPost;
	uint   flags;
	Rec    Data;
	LocationFilt DivF;
};

class CycleCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		PPCycleFilt C;
	};
	CycleCtrlGroup(uint ctlSelCycle, uint ctlNumCycles, uint ctlPeriod);
	CycleCtrlGroup(uint ctlSelCycle, uint ctlPdc, uint ctlNumCycles, uint ctlPeriod);
	CycleCtrlGroup(uint ctlSelCycle, uint ctlNumCycles, TDialog * pPeriodDlg, uint ctlPeriod);
	virtual int setData(TDialog *, void *); // (CycleCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (CycleCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    setupCycleCombo(TDialog *, int);
	int    Recalc(TDialog * pDlg, uint leaderCtl);

	uint   CtlSelCycle;
	uint   CtlPdc;        // Контрол для ввода точной продолжительности периода (дней)
	uint   CtlNumCycles;
	uint   CtlPeriod;
	long   InpUpdLock;
	TDialog * P_PrdDialog; // don't owned by CycleCtrlGroup
};

class QCertCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(PPID qCertID = 0);
		PPID   QCertID;
	};
	explicit QCertCtrlGroup(uint ctlInput, uint selCmd = cmSelQc);
	~QCertCtrlGroup();
	virtual int setData(TDialog *, void *); // (QCertCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (QCertCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   selectQCert(TDialog *);
	void   setupQcNumber(TDialog *);

	const uint CtlInput;
	const uint SelCmd;
	QCertCtrlGroup::Rec Data;
	PPObjQCert QcObj;
};

class MailAccCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		PPID   MailAccID;
		void * ExtraPtr;
	};
	explicit MailAccCtrlGroup(uint ctlSelInput, uint editCmd = cmEditMailAcc);
	virtual int setData(TDialog *, void *); // (MailAccCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (MailAccCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlSelInput;
	uint   EditCmd;
	MailAccCtrlGroup::Rec Data;
};

class LocationCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(const ObjIdListFilt * pLocList = 0, PPID parentID = 0, PPID ownerID = 0);
		ObjIdListFilt LocList;
		PPID   OwnerID;
		PPID   ParentID;
	};
	enum {
		fEnableSelUpLevel  = 0x0001, // Допускается выбор группы складов
		fWarehouseCell     = 0x0002, // Применять для выбора складской ячейки
		fStandaloneByPhone = 0x0004, // Выбор автономной локации по номеру телефона
		fDivision  = 0x0008  // @v11.0.7 Применять для выбора подразделения //
	};
	LocationCtrlGroup(uint ctlselLoc, uint ctlCode, uint ctlPhone, uint cmEditLocList, uint cmEditLoc, long flags, const PPIDArray * pExtLocList);
	void   SetExtLocList(const PPIDArray * pExtLocList);
	void   SetInfoCtl(uint ctlId);
	virtual int setData(TDialog *, void *); // (LocationCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (LocationCtrlGroup::Rec*)
	int    SetWarehouseCellMode(TDialog * pDlg, int enable);
	int    SetCellSelectionByGoods(TDialog * pDlg, PPID goodsID);
private:
	void   Helper_Construct();
	virtual void handleEvent(TDialog *, TEvent &);
	int    EditLocList(TDialog * pDlg, uint ctlID, ObjIdListFilt * pLocList);
	void   SetupInfo(TDialog * pDlg, PPID locID);

	Rec    Data;
	uint   CtlselLoc;
	uint   CmEditLocList;
	uint   CmEditLoc;
	uint   CtlCode;        // Поле ввода кода склада
	uint   CtlPhone;       // Поле ввода номера телефона для выбора автономной локации
	uint   CtlInfo;        // Поле с информацией об адресе
	long   Flags;          // @flags
	PPID   GoodsID;        // Товар, по наличию которого следует отбирать ячейки
	PPIDArray ExtLocList;  // Список дополнительных локаций, которые не относятся к основному списку.
	PPObjLocation LocObj;  //
};
//
// Descr: Группа выбора кассового (POS) узла либо списка узлов.
//   Состоит из комбо-бокса и кнопки выбора списка.
//
class PosNodeCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	PosNodeCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (PosNodeCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (PosNodeCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	const uint Ctlsel;
	const uint CmEditList;
};

class QuotKindCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	QuotKindCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (QuotKindCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (QuotKindCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	const uint Ctlsel;
	const uint CmEditList;
};

class StaffCalCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	StaffCalCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (StaffCalCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (StaffCalCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	const  uint Ctlsel;
	const  uint CmEditList;
};

class PersonOpCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(const ObjIdListFilt * pPsnOpList = 0, PPID prmrID = 0, PPID scndID = 0);
		PPID   PrmrID;
		PPID   ScndID;
		ObjIdListFilt PsnOpList;
	};
	PersonOpCtrlGroup(uint ctlselPsnOp, uint ctlselPsn1, uint ctlselPsn2, uint cmEditPsnList);
	virtual int setData(TDialog *, void *); // (PersonOpCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (PersonOpCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    EditList(TDialog * pDlg);
	int    ReplySelection(TDialog *);

	Rec    Data;
	uint   CtlselPsnOp;
	uint   CtlselPsn1;
	uint   CtlselPsn2;
	uint   CmEditPsnOpList;
	PPObjPsnOpKind PokObj;
};
//
//
//
class WLDialog : public TDialog {
public:
	WLDialog(uint rezID, uint _wlCtlID);
	void   setWL(int s);
	int    getWL() const;
protected:
	DECL_HANDLE_EVENT;
	void   toggleWL(int);
	uint   wlCtlID;
	long   wl;
};
//
// GoodsDialog
//
class GoodsDialog : public TDialog {
	enum {
		ctlgroupIBG = 1
	};
public:
	GoodsDialog(uint rezID);
	int    setDTS(const PPGoodsPacket *);
	int    getDTS(PPGoodsPacket *);
private:
	DECL_HANDLE_EVENT;
	void   editBarcodeList();
	void   setupBarcode();
	int    getBarcode();
	void   printLabel();     // F7
	void   printInfoLabel(); // Ctrl-K
	void   completeByClass();
	void   setupInhTaxGrpName();
	void   SetupAddedInfo();

	GoodsPacketKind gpk;
	PPGoodsPacket   Data;
	PPObjGoods GObj;
	enum {
		stWoTaxFlagDisabled   = 0x0001,
		stOrgWoTaxFlagsIsTrue = 0x0002,
		stPrevGenTag  = 0x0004   // Значение признака "Обобщенный" до начала редактирования //
			// Инициализируется в setDTS, используется в getDTS
	};
	long   St;
	StringSet SSExts;
	enum {
		dummyFirst = 1,
		brushPriorBarcode    // Цвет поля штрихкода, если там установлен приоритетный штрихкод
	};
	SPaintToolBox Ptb;
};

class ClsdGoodsDialog : public TDialog {
public:
	ClsdGoodsDialog(uint dlgID, PPGdsClsPacket * pGcPack, int modifyOnlyExtRec);
	int    setDTS(const PPGoodsPacket *);
	int    getDTS(PPGoodsPacket *);
private:
	DECL_HANDLE_EVENT;
	int    setupGdsClsProp(uint selID, uint labelID, uint flag, PPGdsClsProp *, PPID dataID);
	int    setupGdsClsDim(uint inpID, uint selCmd, uint labelID, uint zeroID, uint flag, PPGdsClsDim *, long val);
	void   setupZeroDim(uint zeroCtlId, uint inpId, uint selCmd);
	int    selectDim(uint inpID, PPGdsClsDim *);
	int    getDim(uint ctlID, uint zeroID, long f, const PPGdsClsDim * pDim, long * pVal);
	void   printLabel();

	int    ModifyOnlyExtRec;
	long   ZeroFlags;         // Поле для установки признаков обнуления числовых классификаторов при массовом изменении.
	PPGoodsPacket Data;
	PPGoodsPacket Org;
	PPGdsClsPacket GcPack;
};
//
// Descr: Структура редактирования маски параметров класса товаров
//
struct GdsClsParamMask {
	//
	// ARG(options IN):
	//   0x0001 - запретить изменение класса
	//
	int    Edit(long options);

	PPID   ClsID;
	long   Mask;
};
//
//
//
class GoodsMovFiltDialog : public WLDialog {
	enum {
		ctlgroupGoodsFilt = 1,
		ctlgroupLoc       = 2,
	};
public:
	GoodsMovFiltDialog();
	int    setDTS(const GoodsMovFilt *);
	int    getDTS(GoodsMovFilt *);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls();

	GoodsMovFilt Data;
};
//
// Диалог расширенного выбора товара для товарной операции
//
#define TIDIF_PACKS            0x00000001L // TIDlgInitData::Quantity in packs
#define TIDIF_AUTOCLOSE        0x00000002L // Автоматом закрывать диалог если Quantity != 0
#define TIDIF_DSBLGSEL         0x00000004L // Запретить выбор товара, отличного от TIDlgInitData::GoodsID
#define TIDIF_AUTOQTTY         0x00000008L // автоматическое добавление 1-цы товара, без вывода диалога
#define TIDIF_SEQQREQ          0x00000010L // Последовательный запрос котировки
#define TIDIF_RECURUNROLLMODIF 0x00000020L // @v11.2.4 Рекурсивная декомплектация товаров по структурам

struct TIDlgInitData {
	TIDlgInitData();
	void   FASTCALL SetTiSign(int tisign);
	int    GetTiSign() const;
	//
	// Descr: Режим ввода строки модификации
	//
	enum {
		mmUndef    = 0, // Не определен
		mmExpend   = 1, // Расход
		mmIncoming = 2, // Выход
		mmRecompl  = 3  // Рекомплектация
	};
	PPID   GoodsGrpID;
	PPID   GoodsID;
	PPID   LotID;      // Используется при выборе по серийному номеру лота
	PPID   ArID;       // Контекстная статья для поиска по артикулу и проверки принадлежности товара матрице (для внутренней передачи)
	long   Flags;      // @flags
	int    ModifMode;  // Режим ввода строки модификации TISIGN_MINUS||TISIGN_PLUS||TISIGN_RECOMPLETE
	char   Serial[32]; // Выбранный пользователем серийный номер
	double Quantity;
	RealRange QttyBounds;
};

class ExtGoodsSelDialog : public TDialog {
public:
	enum {
		fExistsOnly       = 0x0001, // Показывать только те товары, которые есть на остатке
			// Если opID является расходной операцией, либо переоценкой, либо товарным заказом
			// в котором установлен флаг OPKF_ORDEXSTONLY, и не установлен флаг fForceExhausted,
			// то и без флага fExistsOnly в списке будут только товары, которые есть на остатке.
		fForceExhausted   = 0x0002, // Если установлен, то будут безусловно показаны товары, которых нет на остатке.
		fByName           = 0x0004,
		fHidePassive      = 0x0008,
		fForcePassive     = 0x0010,
		fSelByPrice       = 0x0020, // @internal В конструкторе игнорируется //
		fSelByList        = 0x0040, // @internal В конструкторе игнорируется //
		fMatrix           = 0x0080, // @internal В конструкторе игнорируется //
		fSelByStrList     = 0x0100, // @internal В конструкторе игнорируется //
		fUseLotSelOnExp   = 0x0200, // Если fExistsOnly, то выбирать из лотов
		fSelectModifMode  = 0x0400, // В диалог включается выбор знака операции (для модификации): расход/выход/рекомплектация
		fHideGeneric      = 0x0800, // @construction Не отображать обобщенные товары
		fForceMatrixUsage = 0x1000  // @v11.2.8 Диалог применяет органичения по товарной матрице независимо от других параметров
	};
	static long GetDefaultFlags();
	ExtGoodsSelDialog(PPID opID, PPID initGoodsGrpID/*= 0*/, long flags/*= 0*/);
	~ExtGoodsSelDialog();
	void   setSelectionByPrice(double price);
	void   setSelectionByGroup();
	void   setSelectionByGoodsList(const PPIDArray *, const char * pInfoText = 0);
	void   setSelectionByGoodsList(const StrAssocArray *, const char * pInfoText = 0);
	void   setLocation(PPID locID);
	int    setDTS(TIDlgInitData *);
	int    getDTS(TIDlgInitData *);
private:
	DECL_HANDLE_EVENT;
	void   updateList(int pos);
	void   searchBarcode();
	//
	// Returns:
	//   >0 - список был обновлен
	//   <0 - список не был обновлен из-за того, что grp==0 && gooodsID==0
	//
	int    selectGoods(PPID grp, PPID goodsID);
	PPID   getSelectedItem();

	SmartListBox * P_List;
	PPObjGoods GObj;
	PPIDArray IdList;
	StrAssocArray StrIdList;
	PPID   OpID;
	PPID   LocID;
	PPID   ArID;             // Контекстная статья для поиска товара по артикулу
	PPID   InnerSelectionID; // Идентификатор товара, выбранный в результате вывода внутреннего диалога
	long   Flags;
	double Price;
	PPObjTSession::SerialByGoodsListItem SerialData;
	int    UseBrand;
	RECORDNUMBER G2RecCount; // @*ExtGoodsSelDialog::ExtGoodsSelDialog Количество записей в таблице Goods2
	PPObjectTokenizer * P_ObjTkn;
	enum {
		dummyFirst = 1,
		bmMatrix,          // Символ включенной товарной матрицы
		brushModMode_Expend,
		brushModMode_Incoming,
		brushModMode_Recompl
	};
	SPaintToolBox Ptb;
};
//
//
//
struct PickLotParam {
	explicit PickLotParam(int mode);

	enum {
		mByGoodsList = 1,
		mBySerial,
		mByPrice
	};
	int    Mode;
	PPID   LocID;
	double Price;
	SString Text;
	SString SubTitle;
	StrAssocArray GoodsList;
};
//
// Descr: Отображает таблицу выбора открытого лота в соответствии с параметрами rParam
//
int PickLot(PickLotParam & rParam, TIDlgInitData * pResult);

class SysJFiltDialog : public TDialog {
public:
	SysJFiltDialog(uint resID);
	int    setDTS(const SysJournalFilt *);
	int    getDTS(SysJournalFilt *);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls();

	SysJournalFilt Filt;
};
//
//
//
class FileBrowseCtrlGroup : public CtrlGroup {
public:
	static int Setup(TDialog * dlg, uint btnCtlID, uint inputCtlID, uint grpID, int titleTextId, int patternId, long flags);
	enum {
		fbcgfFile         = 0x0001,
		fbcgfLogFile      = 0x0002,
		fbcgfPath         = 0x0004,
		fbcgfAllowNExists = 0x0008, // Позволяет выбирать несуществующие файлы
		fbcgfSaveLastPath = 0x0010
	};
	struct Rec {
		Rec();
		char   FilePath[MAX_PATH];
	};

	FileBrowseCtrlGroup(uint buttonId, uint inputId, const char * pTitle, long flags);
	//
	// Descr: Устанавливает фильтрацию выбора файлов по расширению в соответствии со строкой,
	//   хранящейся в строковых ресурсах.
	//   Строка должна быть определена в группе PPSTR_TEXT в форме "description:*.ex1;*.ex2..."
	//   Рекомендуемый префикс мнемоники строки PPTXT_FILPAT_XXX.
	//
	int    addPattern(uint strID);
	void   setInitPath(const char * pInitPath);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent&);
	int    showFileBrowse(TDialog *);

	uint   ButtonCtlId;
	uint   InputCtlId;
	StringSet Patterns;
	SString   InitDir;
	SString   InitFile;
	SString   Title;
	long   Flags;       // FileBrowseFlags::fbfXXX
	Rec    Data;
};

class ImageBrowseCtrlGroup : public CtrlGroup {
public:
	enum {
		fUseExtOpenDlg = 0x0001,
		fDisableDetail = 0x0002  // Запрет на увеличенное отображение картинки
	};
	struct Rec {
		enum {
			fUpdated     = 0x0001, // Изображение было изменено
			fImageBuffer = 0x0002  // @v11.3.4 Если флаг установлен, то запись оперирует буфером изображения ImgBuf, а не файлом Path
		};
		explicit Rec(const SString * pBuf = 0);
		explicit Rec(SImageBuffer * pImgBuf);

		int    Flags;
		SString Path;
		SImageBuffer ImgBuf;
	};
	// Формат строки расширений: Имя:*.ext;*.ext2;*.ext3,Имя:*.ext4;*.ext5;*.ext6, ...
	ImageBrowseCtrlGroup(uint ctlImage, uint cmChgImage, uint cmDeleteImage, int allowChangeImage = 1, long flags = 0);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlImage;
	uint   CmChgImage;
	uint   CmDelImage;
	int    AllowChangeImage;
	long   Flags;
	Rec    Data;
	SString DefWaitFolder;
	StringSet Patterns;
};

class PrcCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(PPID prcID = 0);

		PPID   PrcID;
	};
	explicit PrcCtrlGroup(uint ctlSelPrc);
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
private:
	uint   CtlSelPrc;
	Rec    Data;
	PPObjProcessor PrcObj;
};

class PrcTechCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		PPID   PrcID;
		PPID   PrcParentID;
		PPID   TechID;
		PPID   ArID;
		PPID   Ar2ID;
		bool   IdleStatus; // @v12.3.6 int-->bool
		uint8  Reserve[3]; // @v12.3.6 @alignment
	};
	PrcTechCtrlGroup(uint ctlSelPrc, uint ctlSelTech, uint ctlStGoods, uint ctlSelAr, uint ctlSelAr2, uint cmdSelTechByGoods, uint cmdCreateGoods = 0);
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
	void   setIdleStatus(TDialog *, bool s);
	//
	// Descr: Устанавливает возможность выбора группы процессоров в комбо-боксе процессора.
	//   По умолчанию ВКЛЮЧЕНО.
	//
	void   enablePrcSelUpLevel(bool enbl);
	void   enableTechSelUpLevel(bool enbl); // @v11.7.6
	//
	// Descr: Устанавливает возможность создания нового процессора в списке
	//   комбо-бокса процессора.
	//
	void   enablePrcInsert(bool enbl);
	int    getGoodsID(TDialog *, PPID * pGoodsID);
private:
	virtual void   handleEvent(TDialog *, TEvent &);
	void   onPrcSelection(TDialog *, int onIdleStatus = 0);
	void   setupArticle(TDialog *, const ProcessorTbl::Rec *);
	void   setupGoodsName(TDialog *);
	void   setupCreateGoodsButton(TDialog *);
	void   selTechByGoods(TDialog *);
	long   GetTechComboOlwFlags() const; // @v11.7.6
	enum {
		fEnablePrcSelUpLevel  = 0x0001,
		fEnablePrcInsert      = 0x0002,
		fEnableTechSelUpLevel = 0x0004, // @v11.7.6
	};
	const  uint CtlselPrc;
	const  uint CtlselTech;
	const  uint CtlStGoods;
	const  uint CtlselAr;
	const  uint CtlselAr2;
	const  uint CmdSelTechByGoods;
	const  uint CmdCreateGoods;
	PPID   SelGoodsID;
	PPID   AutoGoodsGrpID; // @!PrcTechCtrlGroup::setupCreateGoodsButton()
		// ИД товарной группы, для которой по выбранному процессору
		// существует автотехнология и, следовательно, можно создать новый товар с
		// автоматическим созданием технологии.
		// Если AutoGoodsGrpID && CmdCreateGoods тогда кнопка создания товара
		// становится видимой и доступной для использования.
		//
	Rec    Data;
	bool   IdleStatus; // @v12.3.6 int-->bool
	uint8  Reserve[3]; // @v12.3.6 @alignment
	long   Flags;
	PPObjGoods GObj;
	PPObjTech  TecObj;
};

class SpinCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		long   Value;
	};
	SpinCtrlGroup(uint ctlEdit, uint cmdUp, uint ctlUp, uint cmdDown, uint ctlDown, long minVal, long maxVal);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlEdit;
	uint   CmdUp;
	uint   CmdDown;
	uint   CtlUp;
	uint   CtlDown;
	long   MinVal;
	long   MaxVal;
	Rec    Data;
};

class ColorCtrlGroup : public CtrlGroup {
public:
	struct Rec {
	public:
		static const COLORREF UndefC;

		Rec();
		void   SetupStdColorList();
		int    AddColorItem(SColor c, const char * pName);
		int    AddColorItem(COLORREF rgb, const char * pName);
		int    AddUndefColorItem();
		uint   GetColorItemsCount() const;
		int    GetColorItem(uint pos, COLORREF & rC, SString & rNameBuf) const;
		int    SearchColorItem(COLORREF c, uint * pPos) const;

		COLORREF C;
		StrAssocArray ColorList;
	};
	ColorCtrlGroup(uint ctl, uint ctlSel, uint cmNewColor, uint ctlNewColor);
	~ColorCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	uint   CmNewColor;
	uint   Ctl;
	uint   CtlSel;
	uint   CtlNewColor;
	Rec    Data;
	StrAssocArray ListData;
	HBRUSH H_BrBkList;
	HBRUSH H_BrSelList;
	HBRUSH H_BrFrameList;
	HBRUSH H_BrBkInput;
};

class TimePickerCtrlGroup : public CtrlGroup {
public:
	TimePickerCtrlGroup(uint ctl, uint ctlSel, TDialog * pDlg);
	~TimePickerCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	int    Edit(TDialog *);

	LTIME  Data;
	ushort Cmd;
	uint16 Reserve; // @alignment
	const  uint Ctl;
	const  uint CtlSel;
};
//
//
//
class PalletCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		PPID   GoodsID;
		PPID   PalletTypeID;
		uint   PalletCount;
		double Qtty;
	};
	PalletCtrlGroup(uint ctlselPalletType, uint ctlPallet, uint ctlPalletCount, uint ctlPckg, uint ctlPckgCount, uint ctlQtty, uint ctlselGoods);
	void   SetupGoods(TDialog * pDlg, PPID goodsID);
private:
	virtual void handleEvent(TDialog*, TEvent&);
	virtual int setData(TDialog*, void*);
	virtual int getData(TDialog*, void*);
	void   RecalcQtty(TDialog * pDlg, int cargoUnit);
	void   SetupPallet(TDialog * pDlg, int doSelect);

	uint   CtlselPalletType;
	uint   CtlPallet;
	uint   CtlPalletCount;
	uint   CtlPckg;
	uint   CtlPckgCount;
	uint   CtlQtty;
	uint   CtlselGoods;

	enum {
		stInputUpdLock = 0x0002  // Блокировка обработки события ввода (во избежании рекурсии)
	};
	long   State;
	Rec    Data;
	GoodsStockExt Gse; // Карго-факторы текущего выбранного товара
	PPObjGoods GObj;
};
//
//
//
class QuantityCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		bool   FASTCALL operator == (const Rec & rS) const;

		double UnitPerPack;
		double Packs;
		double PackTail;
		double Qtty;
	};
	QuantityCtrlGroup(uint ctlUpp, uint ctlPacks, uint ctlQtty);
private:
	virtual int setData(TDialog*, void*);
	virtual int getData(TDialog*, void*);
	virtual void handleEvent(TDialog*, TEvent&);
	int    ReadFld(TDialog * pDlg, uint master, uint ctl);
	void   SetupQuantity(TDialog * pDlg, uint master, int readFlds);

	uint   CtlUpp;
	uint   CtlPacks;
	uint   CtlQtty;
	int    LockUpdByInput;
	Rec    Data;
};

struct TagDlgParam {
	TagDlgParam();
	bool   GetDlgID(const ObjTagItem & rTagItem/*long tagDataType*/, uint * dlgCtl) const;
	int    SetDlgData(TDialog *, const ObjTagItem *);
	int    GetDlgData(TDialog *, ObjTagItem *);

	PPID   ObjType;
	PPID   ObjID;
	uint   BoolDlgID;
	uint   NmbDlgID;
	uint   LnkDlgID;
	uint   LnkPersonLocationDlgID; // @v12.2.10 // По сути то же, что и LnkDlgID, но требует дополнительно выбора персоналии ибо без нее адрес выбрать затруднительно.
	uint   StrDlgID;
	uint   DateDlgID;
	uint   TimestampDlgID;
	uint   GuidDlgID;
	uint   ImgDlgID;
	uint   IntDlgID; // @v11.8.12
	uint   ObjNameCtl;
	uint   TagNameCtl;
	uint   ValBoolCtl;
	uint   ValNmbCtl;
	uint   ValLnkCtl;
	uint   ValStrCtl;
	uint   ValDateCtl;
	uint   ValTimeCtl;
	uint   ValGuidCtl;
	uint   ValImgCtl;
	uint   ValIntCtl; // @v11.8.12
private:
	ObjTagFilt LinkTagFilt; // Для установки фильтра ссылочных тегов
};
//
//
//
class PPListDialogBaseInterface {
public:
	int    addStringToList(long id, const char * pText);
	int    getSelection(long * pID);
protected:
	PPListDialogBaseInterface();
	virtual ~PPListDialogBaseInterface();
	virtual int  setupList();
	virtual int  addItem(long * pPos, long * pID);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	virtual int  sendItem(long pos, long id);
	//
	// Descr: Должна переместить элемент в позиции pos и идентификатором id вверх или вниз по списку.
	//   Если параметр up != 0, то функция должна переместить элемент вверх по списку, если up == 0,
	//   то функция должна переместить элемент вниз по списку.
	//   Класс вызывает эту функцию в ответ на команду cmUp или cmDown
	// Returns:
	//   >0 - элемент был успешно перемещен
	//   <0 - функция не поддерживается, либо элемент не может быть перемещен в силу причин,
	//        не являющихся ошибочными (не куда или нечего перемещать).
	//   0  - ошибка
	//
	virtual int  moveItem(long pos, long id, int up);
	virtual SmartListBox * GetListBoxCtl() const;
	//
	int    getCurItem(long * pPos, long * pID) const;
	int    getCurString(SString & rBuf) const;
	int    getText(long itemN /* 0.. */, SString & rBuf);
	void   updateList(long pos);
	void   updateListById(long id);
};

#if 0 // @v12.3.6 (Этот блок отработал свою функцию - переходим на регулярное описание диалогов в DL00) {
//
// Descr: Базовая реализация эксперименталных диалоговых окон для работы со списками данных, реализованных посредством layout'ов
// 
class LayoutedListDialog_Base : public PPListDialogBaseInterface {
public:
	enum {
		fcedCreate        = 0x0001, // Если установлен, то в окне есть кнопка [Create Item]
		fcedEdit          = 0x0002, // Если установлен, то в окне есть кнопка [Edit Item]
		fcedDelete        = 0x0004, // Если установлен, то в окне есть кнопка [Delete Item]
		fcedCED           = fcedCreate|fcedEdit|fcedDelete,
		fOkCancel         = 0x0008, // Если установлен, то в окне есть кнопки [ok] && [cancel], иначе только [close]
		fHeaderStaticText = 0x0010, // В заголовочной части окна отобразить статический текст
	};
	struct Param {
		Param() : Flags(0)
		{
		}
		Param(const TRect & rBounds, uint flags) : Bounds(rBounds), Flags(flags)
		{
		}
		uint   Flags; // LayoutedListDialog_Base::fXXX
		TRect  Bounds;
		SString Symb; // Строка, идентифицирующая экземпляр для сохранения параметров, измененных пользователем (размеры и, может, еще что)
		SString Title;
		SString ColumnDescription;
	};

	static int Exec(TWindow * pView);
protected:
	static constexpr uint CtlListGroupBox = 1001; // GroupBox вокруг списка
	static constexpr float DefMargin = 4.0f;
	static const char * GetWindowTitle(const char * pOuterTitle);
	LayoutedListDialog_Base(const Param & rParam, ListBoxDef * pDef, TWindow * pTW);
	~LayoutedListDialog_Base();
	void   OnInit2(TWindowBase::CreateBlock * pBlk);
	void   DrawLayout(TCanvas2 & rCanv, const SUiLayout * pLo);
	virtual SmartListBox * GetListBoxCtl() const;
	Param  P;
private:
	enum {
		lldsDefBailed = 0x0001 // P_Def__ передан экземпляру SmartListBox, стало быть разрушать P_Def__ в деструкторе нельзя!
	};
	uint    LldState;
	ListBoxDef * P_Def__;
	TWindow * P_TW;
};
//
// Descr: Экспериментальная реализация окна со списком данных, реализованного посредством layout'ов
//
class LayoutedListWindow : public TWindowBase, public LayoutedListDialog_Base {
public:
	LayoutedListWindow(const Param & rParam, ListBoxDef * pDef);
	~LayoutedListWindow();
protected:
	DECL_HANDLE_EVENT;
};
//
// Descr: Экспериментальная реализация диалога со списком данных, реализованного посредством layout'ов
//
class LayoutedListDialog : public TDialog, public LayoutedListDialog_Base { 
	// @attention Первое наследование должно быть от TDialog(TView) иначе - будут вылеты сеансов на вызове виртуального метода TView::handleWindowsMessage
	// (я не понимаю как это - debug норм, release сбоит)
public:
	LayoutedListDialog(const Param & rParam, ListBoxDef * pDef);
	~LayoutedListDialog();
protected:
	DECL_HANDLE_EVENT;
};
#endif // } 0 @v12.3.6 (Этот блок отработал свою функцию - переходим на регулярное описание диалогов в DL600) {
//
//
//
class PPListDialog : public TDialog, public PPListDialogBaseInterface {
public:
	//
	// Descr: Флаги конструктора
	//
	enum {
		fOnDblClkOk            = 0x0001, // При двойном щелчке, если выбран элемент списка завершать работу диалога как по cmOK
		fOmitSearchByFirstChar = 0x0002, // Не выводить окно поиска в ответ на нажатие символьной клавиши
		fOwnerDraw             = 0x0004, // Если установлен, то конструктор вызывает SetOwnerDrawState()
		fMultiselect           = 0x0008  // @v11.4.3 Допускается множественный выбор в списке
	};
	PPListDialog(uint rezID, uint aCtlList, long flags = 0);
protected:
	DECL_HANDLE_EVENT;
	virtual SmartListBox * GetListBoxCtl() const { return P_Box; }

	uint   CtlList;
	uint   ContextMenuID;
	enum {
		oHasOkButton   = 0x0001,
		oHasEditButton = 0x0002,
		oOnDblClkOk    = 0x0004
	};
	long   Options;
	SmartListBox * P_Box;
};

class ObjRestrictListDialog : public PPListDialog {
public:
	ObjRestrictListDialog(uint dlgID, uint listCtlID);
	void   setParams(PPID objType, ObjRestrictArray *);
protected:
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pPos, long * pID);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	virtual void getObjName(PPID objID, long objFlags, SString & rBuf);
	virtual void getExtText(PPID objID, long objFlags, SString & rBuf);
	virtual int  editItemDialog(ObjRestrictItem *) { return -1; }

	PPID   ObjType;
	ObjRestrictArray * P_ORList; // ObjRestrictListDialog not owner of P_ORList
};

class AmtListDialog : public PPListDialog {
public:
	AmtListDialog(uint resID, uint listCtlID, int useCurCol, AmtList *, PPIDArray *, const char * aTitle, uint o);
	void   setCRateDate(LDATE);
	int    getDTS(AmtList *);
protected:
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	int    editAmount(int pos);
	int    setupListEntry(PPID idx, const AmtEntry *);

	int    UseCurColumn;
	uint   Options;
	LDATE  CRateDate;
	AmtList   Data;
	int       HasRestrict;
	PPIDArray RestrictList;
	PPIDArray PosList;
	PPObjAmountType AmtObj;
};

class ExtStrContainerListDialog : public PPListDialog {
	DECL_DIALOG_DATA(PPExtStrContainer);
	const SIntToSymbTabEntry * P_DescrList;
	const size_t DescrListCount;
public:
	ExtStrContainerListDialog(uint dlgId, uint listCtlId, const char * pTitle, bool readOnly, const SIntToSymbTabEntry * pDescrList, size_t descrListCount);
	DECL_DIALOG_SETDTS();
	DECL_DIALOG_GETDTS();
private:
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	const bool ReadOnly;
};

class BankingOrderDialog : public TDialog {
public:
	BankingOrderDialog();
	int    setDTS(const PPBankingOrder * pData);
	int    getDTS(PPBankingOrder * pData);
private:
	DECL_HANDLE_EVENT;
	int    setupPerson(int payerOrRcvr, PPID personID, PPID * pBnkAccID);
	int    setupBnkAcc(int payerOrRcvr, PPID bnkAccID);
	int    editTaxMarkers();
	void   setupVAT();
	void   swapPersons();

	enum {
		dummyFirst = 1,
		brushValidNumber,
		brushInvalidNumber
	};

	int    PayerValidCode;
	int    RcvrValidCode;
	SPaintToolBox  Ptb;
	PPBankingOrder Data;
	PPObjPerson PsnObj;
	RegisterFilt BnkAccFilt;
};

struct GoodsGroupItem : Goods2Tbl::Rec {
	long   Level;
	char   Code[24];
};

class GoodsGroupView : public PPListDialog {
public:
	explicit GoodsGroupView(PPObjGoodsGroup * _ppobj);
	~GoodsGroupView();
	//
	// Returns:
	//   0 - all groups,
	//   1 - normal groups,
	//   2 - alt groups
	//
	int    GetGrpType();
	int    InitIteration();
	int    FASTCALL NextIteration(GoodsGroupItem * pItem);
private:
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	PPID   getCurrID();
	void   ViewGoodsByGroup(long);
	void   editQuotations(long, int quotCls);
	void   setupButtons();
	void   updateList(long);
	int    Print();
	void   ViewTotal();

	PPID   CurIterID;
	GoodsGroupIterator * P_Iter;
	PPObjGoodsGroup GGObj;
	SPoint2S mouse;
};
//
//
//
class PsnOpKindView : public PPListDialog {
public:
	explicit PsnOpKindView(PPObjPsnOpKind * _ppobj);
	~PsnOpKindView();
	int    InitIteration();
	int    FASTCALL NextIteration(PPPsnOpKind * pItem);
	long   GetLevel(PPID opKindID);
	int    CopyList(PPID parentID, StrAssocArray * pSrc, StrAssocArray * pDest);
private:
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	PPID   getCurrID();

	uint   IterNo;
	StrAssocArray * P_Items;
	PPObjPsnOpKind Obj;
};
//
// Диалог отправки электронного письма
//
class SendMailDialog : public PPListDialog {
public:
	struct Rec {
		Rec();
		Rec & FASTCALL operator = (const Rec & rSrc);

		PPID   MailAccID; // Аккаунт, с которого отправляются письма
		uint32 Delay;     // Задержка между отправкой писем
		SString Subj;
		SString Text;
		StrAssocArray  AddrList;
		SStrCollection FilesList;
	};
	SendMailDialog();
	int    setDTS(const Rec *);
	int    getDTS(Rec *);
private:
	enum {
		ctlgroupEmailList = 1
	};
	virtual int  setupList();
	virtual int  addItem(long * pPos, long * pID);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);

	Rec    Data;
};

class EmailCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		explicit Rec(StrAssocArray * pAddrList = 0);
		StrAssocArray AddrList;
	};
	EmailCtrlGroup(uint ctl, uint cm);
	~EmailCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	void   SetLine(TDialog *);
	int    Edit(TDialog *);

	const uint Cm;
	const uint Ctl;
	Rec    Data;
};

struct EmailToBlock {
	EmailToBlock();
	enum {
		efDisableAccount = 0x0001 // Запретить выбор аккаунта (актуально в случае, если в момент использования сеанс не будет авторизован)
	};
	int    Edit(long flags);

	PPID   MailAccID;
	SString Subj;
	StrAssocArray AddrList;
};
//
//
//
class TVMsgLog : public PPMsgLog {
public:
	// only for dos, for windows do nothing if winDestroy = 0
	static void Delete_(TVMsgLog * pMsgLog, int winDestroy = 0);

	TVMsgLog();
	virtual ~TVMsgLog();
	virtual long ImplPutMsg(const char * pText, long flags);
	virtual int  ShowLogWnd(const char * pTitle = 0);
	void   RefreshList();
protected:
	LogListWindowSCI * P_LWnd;
	long   HorzRange;
};
//
// LotQCertDialog (Defined in V_LOT2.CPP)
//
struct LotQCertData {
	PPID   LotID;
	PPID   QCertID;
	LDATE  Expiry;
	char   Serial[32];
	char   CLB[32];
	int    IsInheritedClb;
};

class LotQCertDialog : public TDialog {
public:
	explicit LotQCertDialog(PPObjBill * pBObj);
	int    setDTS(const LotQCertData *);
	int    getDTS(LotQCertData *);
private:
	DECL_HANDLE_EVENT;
	void   generateSerial();

	LotQCertData Data;
	PPObjBill * P_BObj;
};
//
// Descr: Диалог редактирования параметров повторения DateRepeating
//
class RepeatingDialog : public EmbedDialog {
public:
	enum {
		fEditTime    = 0x0001,
		fEditDuration        = 0x0002,
		fEditRepeatAfterItem = 0x0004
	};
	explicit RepeatingDialog(uint options = 0 /* RepeatingDialog::fXXX */);
	~RepeatingDialog();
	void   setInitDate(LDATE);
	int    setDTS(const DateRepeating *);
	int    getDTS(DateRepeating *);
	int    setDuration(long);
	int    getDuration(long * pDuration);
private:
	DECL_HANDLE_EVENT;

	int    embedChild(long prd);
	int    embedOneChild(TDialog * pDlg);
	void   test();
	DateRepeating * P_Data;
	long   PrevPrd;
	LDATE  InitDate;
	long   Duration;
	uint   Options;
};
//
//
//
class PsnEventDialog : public PPListDialog {
public:
	struct Param : public TagDlgParam {
		Param();
		char   DlgTitle[48];
		uint   ExValGrp;
		bool   AsTemplate; // Режим редактирования шаблона (но не реального пакета, предназначенного для сохранения в базе данных)
		uint8  Reserve[3]; // @alignment
	};
	static int GetParam(PPID pokID, Param * pParam);

	PsnEventDialog(Param * pParam, PPObjPersonEvent * pPeObj);
	int    setDTS(const PPPsnEventPacket *);
	int    getDTS(PPPsnEventPacket *);
private:
	enum {
		ctlgroupIBG        = 1,
		ctlgroupPersonPrmr = 2,
		ctlgroupPersonScnd = 3
	};
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pPos, long * pID);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	void   editRegister();
	int    setupPost(int fromDialog);
	int    setupPair();
	int    Print();
	int    GetReportID();
	void postVK(); //@erikTEMP VK API

	PPObjTag TagObj;
	Param  P;
	PPPsnOpKindPacket PokPack;
	PPPsnEventPacket  Pack;
	PPObjPersonEvent * P_PeObj;
};

struct RemoveAllParam {
	enum {
		aRemoveAll = 1,
		aMoveToGroup
	};
	int    Action;
	PPID   DestGrpID;
};

class RemoveAllDialog : public TDialog {
public:
	explicit RemoveAllDialog(uint resID);
	int    setDTS(const RemoveAllParam *);
	int    getDTS(RemoveAllParam *);
private:
	DECL_HANDLE_EVENT;
	RemoveAllParam Data;
};
//
//
//
class PsnSelAnalogDialog : public TDialog {
public:
	explicit PsnSelAnalogDialog(PPObjPerson * pPsnObj);
	void   setSrchString(const char * pStr);
	void   getResult(PPID * pID);
private:
	DECL_HANDLE_EVENT;
	void   setupList();
	PPObjPerson * P_PsnObj;
	PPID   Selection;
};
//
// Descr: Таблица выбора лота
//
class SelLotBrowser : public BrowserWindow {
public:
	struct Entry {
		PPID   LotID;
		LDATE  Dt;
		long   OprNo;
		PPID   GoodsID;
		LDATE  Expiry;      // Дата истечения срока годности
		PPID   SupplID;
		double Qtty;        // Поступившее с лотом количество
		double Rest;        // Остаток
		double Cost;        //
		double Price;
		char   Serial[32];
		char   Barcode[20];
	};
	enum {
		fShowEgaisTags         = 0x0001,
		fShowBarcode           = 0x0002,
		fShowQtty              = 0x0004,
		fShowPhQtty            = 0x0008,
		fShowVetisTag          = 0x0010,
		fShowManufTime         = 0x0020,
		fDisableSelectionSpoiledSeries = 0x0040  // @v11.1.8 Запрет выбора лотов и испорченными сериями
	};
	static SArray * CreateArray();
	static int FASTCALL AddItemToArray(SArray * pAry, const ReceiptTbl::Rec * pRec, LDATE billDate, double rest, int onlyWithSerial = 0);
	SelLotBrowser(PPObjBill * pBObj, SArray * pAry, uint pos, long flags);
	~SelLotBrowser(); // @v11.1.8
private:
	DECL_HANDLE_EVENT;
	static int FASTCALL GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	static int StyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	int    _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	enum {
		stMultipleGoods  = 0x0001,
		stMultipleSerial = 0x0002,
		stNoSerials      = 0x0004  // Ни один лот не содержит серийных номеров
	};

	long   State;
	long   Flags;
	PPObjBill * P_BObj;
	SpecSeriesCore * P_SpcCore; // @v11.1.8
	PPObjGoods GObj;
	PPObjTag TagObj;
	SString Serial_;
};
//
//
//
class PPXmlFileDetector : public SXmlSaxParser {
public:
	enum {
		Unkn = 0,          //
		Eancom,            // "DESADV" "ALCDES" "ORDRSP" "ORDERS"
		KonturEdi,         // "eDIMessage"
		EgaisDoc,          // "Documents"
		EgaisCheque,       // "Cheque"
		PpyAsyncPosIx,     // "PapyrusAsyncPosInterchange"
		Sitemap,           // "urlset"
		ProjectAbstract,   // "project"
		ResourcesAbstract, // "resources"
		ValuesAbstract,    // "values"
		TimezonesAbstract, // @v11.3.6 "timezones"
		NalogRu_Generic,   // @v11.9.4 Файл в формате nalog.ru (cp-1251). Это семейство форматов используется в России для обмена данными.
	};
	PPXmlFileDetector();
	~PPXmlFileDetector();
	int    Run(const char * pFileName, int * pResult);
protected:
	virtual int StartElement(const char * pName, const char ** ppAttrList);

	TSStack <int> TokPath;
	uint   ElementCount;
	int    Result;
	const  SymbHashTable * P_ShT; // Токены перечислены в строковом ресурсе PPSTR_HASHTOKEN 
	const  SymbHashTable * P_ShT_C; // Токены перечислены в строковом ресурсе PPSTR_HASHTOKEN_C (русскоязычные токены)
};
//
// Панель чеков
//
//
// Округление скидки
//
enum {
	fDisRoundNo,           // Округления нет
	fDisRoundDef,          // До ближайшего
	fDisRoundUp,           // В большую сторону
	fDisRoundDown          // В меньшую сторону
};
//
// Методы оплаты чека
//
enum CheckPaymMethod {
	cpmUndef     = 0,      // Неопределенный
	cpmCash      = 1,      // Наличными
	cpmBank      = 2,      // Банковская платежная карта
	cpmIncorpCrd = 3       // Корпоративная кредитная карта
};
//
//
//
struct PosPaymentBlock {
	DECL_INVARIANT_C();

	PosPaymentBlock(const CcAmountList * pCcPl, double bonusMaxPart);
	PosPaymentBlock & Z();
	PosPaymentBlock & Init(const CPosProcessor * pCpp);
	bool   SetBuyersEAddr(int addrType, const char * pAddr);
	double GetTotal() const;
	double GetDiscount() const;
	double GetPctDiscount() const;
	double GetUsableBonus() const;
	int    EditDialog2();

	CheckPaymMethod Kind;  // Основной способ оплаты
	double Amount;         // Сумма к оплате
	double CashAmt;        // Сумма платежа наличными
	double BankAmt;        // Сумма платежа по банку
	double ScAmt;          // Сумма доплаты по кредитной карте
	double NoteAmt;        // Сумма полученная от покупателя наличными
	double DeliveryAmt;    // Сумма сдачи DeliveryAmt = NoteAmt - CashAmt
	double SCardRest;      // Текущий остаток по карте (без учета суммы ScAmt)
	double BonusRest;      // Сумма бонуса, доступная для использования //
	double BonusAmt;       // Сумма бонуса, которую покупатель будет использовать для платежа //
	PPID   SCardID;        // ИД кредитной карты
	PPID   ExclSCardID;    // ИД карты, которую нелья применять для приема платежа
		// Причина - эта карта уже присвоена чеку. То есть, по ней уже основная часть
		// платежа сделана (либо на нее начисляются средства).
	long   DisabledKinds;  // Биты установлены в позициях со смещением, равным запрещенному виду оплаты.
	// @v11.3.6 int    AltCashReg;     // Признак использования альтернативного кассового регистратора: -1 - disabled, 0 - не использовать, 1 - использовать
	//
	// Следующие поля используются новой реализацией
	//
	double BonusMaxPart;
	double AmtToPaym;      // Сумма к уплате (наличными или через банк). То есть, сумма чека за минусом доступных бонусов и остатка на кредитной карте.
	enum {
		fPaperless               = 0x0001, // OUT Не печатать бумажный чек
		fAltCashRegEnabled       = 0x0002, // IN  Разрешается использование альтернативного регистратора
		fAltCashRegUse           = 0x0004, // OUT Если (Flags & fAltCashRegEnabled) и (Flags & fAltCashRegUse) то печатать чека на альтернативном регистраторе
		fCashlessBypassEqEnabled = 0x0008, // @v12.0.6 IN  Безналичная оплата в обход банковского терминала разрешена
		fCashlessBypassEq        = 0x0010, // @v12.0.6 OUT Безналичная оплата в обход банковского терминала
		fPreferCashlessPayment   = 0x0020, // @v12.1.10 IN Безналичная оплата является более предпочтительной, нежели наличная (сложная проекция PPEquipConfig::fPreferBankingPayment)
	};
	long   Flags;        // @v11.3.6
	CCheckPacket::BuersEAddr_ EAddr;  // Электронный адрес покупателя (email or phone)
	CcAmountList CcPl;
private:
	double Total;          // Итоговая сумма чека     @*CPosProcessor::GetTotal())
	double Discount;       // Итоговая скидка по чеку @*CPosProcessor::GetTotal())
	double UsableBonus;    // Сумма бонуса, которая может быть использована для оплаты чека
};

struct SaModifEntry { // @flat
	enum {
		fChecked = 0x0001 // Позиция выбрана (используется для организации UI где модификаторы отображаются списком)
	};
	PPID   GoodsID;
	long   Flags;
	double Price;
	double Qtty;
};

typedef TSVector <SaModifEntry> SaModif;

class CPosProcessor {
	friend class CPosProcessor_MsgToDisp_Frame;
public:
	//
	// Descr: Состояния панели
	//
	enum {
		sUNDEF              = 0, // Неопределенное (такое состояние недопустимо)
		sEMPTYLIST_EMPTYBUF = 1, // Пустой список строк, пустой буфер ввода
		sEMPTYLIST_BUF      = 2, // Пустой список строк, в буфере ввода есть товар
		sLIST_EMPTYBUF      = 3, // Непустой список строк, пустой буфер ввода
		sLIST_BUF           = 4, // Непустой список строк, в буфере ввода есть товар
		sLISTSEL_EMPTYBUF   = 5, // Режим выбора строк из чека продажи, пустой буфер ввода
		sLISTSEL_BUF        = 6, // Режим выбора строк из чека продажи, в буфере ввода есть товар
		sSCARD              = 7, // Режим ввода номера дисконтной карты
		sWAITER             = 8, // Режим ввода кода официанта
		sTABLE              = 9  // Режим ввода кода стола
	};
	//
	// Descr: Операционные права кассира
	//
	enum OperRights {
		orfReturns                 = 0x00000001, // Чек возврата
		orfEscCheck        		   = 0x00000002, // Удаление чека
		orfEscChkLine      		   = 0x00000004, // Удаление строки из чека
		orfBanking         		   = 0x00000008, // Безналичный расчет
		orfZReport         		   = 0x00000010, // Закрытие сессии (Z-отчет)
		orfPreCheck        		   = 0x00000020, // Печать пре-чека
		orfSuspCheck       		   = 0x00000040, // Отложить чек
		orfCopyCheck       		   = 0x00000080, // Печать копии чека
		orfCopyZReport     		   = 0x00000100, // Печать копии Z-отчета
		orfPrintCheck      		   = 0x00000200, // Печать чека
		orfRowDiscount     		   = 0x00000400, // Скидка на строку чека
		orfXReport         		   = 0x00000800, // Снятие X-отчета
		orfCTblOrd         		   = 0x00001000, // Снятие X-отчета
		orfSplitCheck      		   = 0x00002000, // Разделение чека
		orfChgPrintedCheck 		   = 0x00004000, // Изменение чека, по которому отпечатан счет
		orfRestoreSuspWithoutAgent = 0x00008000, // CSESSOPRT_RESTORESUSPWOA
		orfChgAgentInCheck         = 0x00010000, // CSESSOPRT_CHGCCAGENT
		orfMergeChecks             = 0x00020000, // CSESSOPRT_MERGECHK
		orfEscChkLineBeforeOrder   = 0x00040000, // CSESSOPRT_ESCCLINEBORD
		orfReprnUnfCc              = 0x00080000, // CSESSOPRT_REPRNUNFCC
		orfArbitraryDiscount       = 0x00100000  // @v11.0.9 CSESSOPRT_ARBITRARYDISC
	};
	struct ExtCcData {
		enum {
			fDelivery           = 0x0001,
			fFixedPrice         = 0x0002, // Проекция флага CCHKF_FIXEDPRICE
			fAttachPhoneToSCard = 0x0004, // @transient Привязать номер телефона к выбранной карте
			fSpFinished         = 0x0008, // Проекция флага CCHKF_SPFINISHED
			fCreateCardByPhone  = 0x0010, // @transient Создать новую карту, привязанную к телефону
			fImported           = 0x0020, // @v11.8.11 Проекция флага CCHKF_IMPORTED
		};
		ExtCcData();
		ExtCcData & Z();

		long   Flags;
		PPID   SCardID_;   // Ид карты, ассоциированной с адресом доставки.
			// Если карта не привязана к иному адресу или персоналии, то при проведении чека
			// она будет связана с созданной или существующей локацией Addr
		PPID   InitUserID; // Пользователь, создавший чек
		LDATETIME DlvrDtm;
		LDATETIME InitDtm; // Время создания чека.
		// @v11.8.11 (moved to ExtStr) S_GUID Uuid; // @v11.5.8 Uuid чека
		// @v11.8.11 (moved to ExtStr) S_GUID LinkBillUuid; // @v11.8.8 extssLinkBillUuid
		LocationTbl::Rec Addr_;
		SString Memo;
	};
	//
	// Descr: Флаги конструктора CPosProcessor
	//
	enum { // @v11.4.5
		ctrfTouchScreen        = 0x0001, // Использовать сенсорный монитор. Применяется в комбинации со ссылкой на запись такого монитора в кассовом узле.
		ctrfForceInitGroupList = 0x0002  // Форсировать инициализацию списка товарных групп, ассоциированных с сенсорным монитором (независимо от ctrfTouchScreen)
	};
	CPosProcessor(PPID cashNodeID, PPID checkID, CCheckPacket * pOuterPack, uint flags/*isTouchScreen*/, void * pDummy);
	virtual ~CPosProcessor();
	enum {
		eomMsgWindow = 1,
		eomStatusLine,      // Сообщение выдается в строке состояния //
		eomPopup,           // Сообщение выдается во всплывающем немодальном окне
		eomBeep = 0x8000
	};
	virtual int MessageError(int errCode, const char * pAddedMsg, long outputMode);
	virtual int ConfirmMessage(int msgId, const char * pAddedMsg, int defaultResponse);
	//
	//
	//
	enum {
		cdispcmdClear = 1,         // Очищает дисплей. Дополнительные параметры не используются.
		cdispcmdText,              // Выводит текстовое сообщение. iVal - идентификатор текста.
		cdispcmdCurrentItem,       // Выводит информацию о текущей введенной чек позиции. Дополнительные параметры не используются.
		cdispcmdCurrentGiftItem,   // Выводит информацию о текущей введенной чек подарочной позиции. Дополнительные параметры не используются.
		cdispcmdTotal,             // Выводит информацию об общей сумме покупки. rv1 - значение суммы
		cdispcmdTotalDiscount,     // Выводит информацию о скидки по чеку. rv1 - процентное значение скидки, rv2 - абсолютное значение скидки.
		cdispcmdChange             // Выводит информацию о полученной сумме и сдаче. rv1 - полученная сумма, rv2 - сдача
	};
	//
	// Идентификаторы текстовых строк, выводимых на дисплее покупателя командой cdispcmdText
	//
	enum {
		cdisptxtOpened = 1,
		cdisptxtClosed
	};
	virtual int CDispCommand(int cmd, int iVal, double rv1, double rv2);
	//
	// Descr: Режимы функции AcceptCheck
	//
	enum {
		accmRegular         = 0, // Обычное проведение кассового чека
		accmSuspended       = 1, // Сохранение отложенного чека
		accmAveragePrinting = 2, // Аварийная печать уже проведенного чека (до этого печать завершилась с ошибкой)
		accmJunk            = 3, // Сохранение временной копии чека (с флагами CCHKF_SUSPENDED|CCHKF_JUNK)
	};

	virtual int    AcceptCheck(PPID * pCcID, const CcAmountList * pPl, PPID altPosNodeID, double cash, int mode);
	virtual void   ClearCheck();
	virtual void   ClearRow();
	virtual void   OnUpdateList(int goBottom);

	int    TurnCorrectionStorno(PPID * pCcID, int ccOp /*CCOP_XXX*/, PPID ccToStornoID); // @v12.2.12
	//
	// Descr: Структура, обрабатываемая функцией CheckPaneDialog::PreprocessGoodsSelection
	//   и передаваемая в CPosProcessorCPosProcessor::SetupNewRow()
	//
	struct PgsBlock {
		explicit PgsBlock(double qtty);
		enum {
			fMarkedBarcode = 0x0001 // Товар был выбран по маркированному штрихкоду
		};
		long   Flags; //
		double Qtty;
		double PriceBySerial; // Если PriceBySerial != 0 && Serial.Empty() это означает, что выбрана
			// одна из look-back-price (фиксированные цены, меняющиеся со временем)
		double AbstractPrice; // Цена, определенная оператором, без выбора товара.
		SString Serial;
		SString EgaisMark;
		SString ChZnMark;     // Марка 'честный знак'
		SString ChZnGtin;     // GTIN код товара, считанный из марки 'честный знак'
		SString ChZnSerial;   // Серийный номер марки 'честный знак'
		S_GUID ChZnPm_ReqId;        // @v12.1.1 ответ разрешительного режима чзн: уникальный идентификатор запроса
		int64  ChZnPm_ReqTimestamp; // @v12.1.1 ответ разрешительного режима чзн: дата и время формирования запроса. Параметр возвращает дату и время с точностью до миллисекунд.
		RealRange AllowedPriceRange; // @v12.2.2 диапазон допустимых цен на товар (пока только по результату запроса разрешительного режима марки chzn)
	};
	//int    SetupNewRow(PPID goodsID, double qtty, double priceBySerial, const char * pSerial, PPID giftID = 0);
	int    SetupNewRow(PPID goodsID, PgsBlock & rBlk, PPID giftID = 0);
	int    AcceptRow(PPID giftID = 0);
	//
	// Descr: Заполняет пакет чека по указателю pPack данными из текущего состояния панели.
	//   Поле CCheckPacket::Rec::CashID получает идентификатор кассового узла, к которому привязан текущий чек.
	//
	int    GetCheckInfo(CCheckPacket * pPack);
	struct CcTotal {
		CcTotal();
		double Amount;
		double Discount;
	};
	CcTotal CalcTotal() const;
	double GetUsableBonus() const;
	double GetBonusMaxPart() const;
	int    GetState() const { return State_p; }
	bool   FASTCALL IsState(int s) const;
	PPID   GetPosNodeID() const;
	long   GetTableCode() const;
	int    GetGuestCount() const;
	PPID   GetAuthAgentID() const;
	PPID   FASTCALL GetCnLocID(PPID goodsID) const;
	int    CheckRights(long rights) const;
	int    InitIteration();
	int    FASTCALL NextIteration(CCheckItem * pItem);
	int    SetupCTable(int tableNo, int guestCount);
	int    SetupUuid(const S_GUID & rUuid);
	int    SetupAgent(PPID agentID, int asAuthAgent);
	void   SetupSessUuid(const S_GUID_Base & rUuid);
	int    OpenSession(LDATE * pDt, int ifClosed);
	int    RestoreSuspendedCheck(PPID ccID, CCheckPacket * pPack, int unfinishedForReprinting); // private->public
	int    Print(int noAsk, const PPLocPrinter2 * pLocPrn, uint rptId);
	//
	// Descr: Печатает текущий чек на локальный принтер.
	// ARG(selPrnType IN):
	//   1 - предварительно вызывается диалог выбора принтера (локальные или по умолчанию). Недоступно в неинтерактивном режиме
	//  -1 - печать на локальные принтеры (если они есть)
	//   0 - печать на принтер по умолчанию
	// ARG(ignoreNonZeroAgentReq IN): @v11.8.6 Игнорировать требование установки агента (для неинтерактивного режима)
	// Returns:
	//   >0 - печать чека (чеков)
	//   <0 - печать не призводится (не то состояние чека, нет локальных принтеров и т.п.)
	//    0 - error
	//
	int    PrintToLocalPrinters(int selPrnType, bool ignoreNonZeroAgentReq);
	int    CalculatePaymentList(PosPaymentBlock & rBlk, int interactive);
	//
	// Descr: Возвращает указатель на блок дополнительных котировок, ассоциированных
	//   с персональной картой.
	//   В зависимости от признака GF_NODISCOUNT товара и дополнительных
	//   параметров, может вернуть ноль, даже если с картой котировки ассоциированы.
	// Note: nonconst из-за вызова GObj.Fetch
	//
	const  RetailPriceExtractor::ExtQuotBlock * GetCStEqb(PPID goodsID, bool * pNoDiscount);
	const  RetailPriceExtractor::ExtQuotBlock * GetCStEqbND(bool nodiscount) const;
	int    GetRgi(PPID goodsID, double qtty, long extRgiFlags, RetailGoodsInfo & rRgi);
	//
	// Descr: Режимы распознавания кода функцией RecognizeCode
	//
	enum {
		crmodeAuto  = 0,
		crmodeGoods = 1,
		crmodeAgent = 2,
		crmodeSCard = 3
	};

	int    RecognizeCode(int mode, const char * pCode, int autoInput);
	static SCardSpecialTreatment::IdentifyReplyBlock * GetSpecialTreatmentBlock(const TSVector <SCardSpecialTreatment::IdentifyReplyBlock> & rScpRbList, PPID scID);
	int    Backend_RemoveRow(int rowNo);
	int    Backend_SetRowQueue(int rowNo, int queue);
	int    Backend_SetModifList(const SaModif & rList);
	int    ResetCurrentLine();
	const CCheckItem * FindLine(int rbycheck) const;
	int    UpdateLine(const CCheckItem * pItem);
	//
	// Descr: Очищает процессор. Функция должна быть вызвана перед разрушением
	//   объекта при использовании вне кассовой панели.
	//
	int    Backend_Release();
	//
	// Descr: Возвращает список чеков. 
	// ARG(pPeriod IN): Если pPeriod != 0, то чеки извлекаются за заданный период. В противном случае чеки извлекаются за период от
	//   даты, начиная с (сегодняшней минус PPSyncCashNode::SuspCheckFilt::DaysPeriod). Эти параметры извлекаются из записи кассового узла.
	// ARG(ctblId IN): Номер стола, к которому должны быть привязаны чеки. Если ctblId == 0, то номер стола в чеках не принимается во внимание.
	// ARG(rList OUT): Результатный список чеков.
	//
	int    Backend_GetCCheckList(const DateRange * pPeriod, long ctblId, TSVector <CCheckViewItem> & rList);
	int    Backend_GetGoodsList(PPIDArray & rList); // @v11.4.5
	long   Backend_GetCnFlags() const { return CnFlags; }
	long   Backend_GetCnExtFlags() const { return CnExtFlags; }
	//
	// Descr: Устанавливает или снимает ограничение на операции с чеком при неопределенном агенте.
	// Note: Функция нужна для программного проведения импортированных чеков.
	// Returns:
	//   предшествующее вызову функции значение параметра.
	//
	bool   Backend_SetZeroAgentRestriction(bool set);
	//
	int    ExportCurrentState(SString & rBuf) const;
	int    ExportCTblList(SString & rBuf);
	int    ExportCCheckList(long ctblId, SString & rBuf);
	int    ExportModifList(PPID goodsID, SString & rBuf);
	void   GetTblOrderList(LDATE lastDate, TSVector <CCheckViewItem> & rList);
	int    AutosaveCheck();
	CCheckCore & GetCc();
	PPObjSCard & GetScObj();
	//
	// Descr: Реализует CalcSCardOpBonusAmount. Вынесена в отдельный блок для использования
	//   другими модулями.
	//
	static double Helper_CalcSCardOpBonusAmount(const CCheckLineTbl::Rec & rItem, PPObjGoods & rGObj, PPID bonusGoodsGrpID, double * pNonCrdAmt);
	static bool   IsValidOp(int op) { return oneof6(op, CCOP_GENERAL, CCOP_RETURN, CCOP_CORRECTION_SELL, CCOP_CORRECTION_SELLSTORNO, CCOP_CORRECTION_RET, CCOP_CORRECTION_RETSTORNO); }
	static bool   IsCorrectionOp(int op) { return oneof4(op, CCOP_CORRECTION_SELL, CCOP_CORRECTION_SELLSTORNO, CCOP_CORRECTION_RET, CCOP_CORRECTION_RETSTORNO); }

	LongArray CTblList;
	PPObjCSession CsObj;
protected:
	//
	// Descr: Узкоспециализированный блок для исполнения функции AcceptCheck().
	//   Необходимость в этом блоке обусловлена тем, что пришлось разделить функцию AcceptCheck
	//   на, собственно, процесс проведения чека и внедренную внутрь операцию взаимодействия с
	//   оборудованием, которая должна быть имплементирована порожденным классом.
	//
	struct AcceptCheckProcessBlock {
		AcceptCheckProcessBlock();
		enum {
			fIsPack    = 0x0001,
			fIsExtPack = 0x0002,
			fAltReg    = 0x0004
		};

		int    R;
		int    RExt;
		int    SyncPrnErr;
		int    ExtSyncPrnErr;
		long   Flags;
		CCheckTbl::Rec LastChkRec;
		CCheckPacket Pack;
		CCheckPacket ExtPack;
	};
	virtual int    SetupState(int st);
	virtual void   SetupInfo(const char * pErrMsg);
	virtual void   SetupRowData(bool doCalcRest);
	virtual int    Implement_AcceptCheckOnEquipment(const CcAmountList * pPl, AcceptCheckProcessBlock & rB);
	virtual void   NotifyGift(PPID giftID, const SaGiftArray::Gift * pGift);
	virtual void   SetPrintedFlag(int set);
	int    InitCashMachine();
	bool   InitCcView();
	int    InitGroupList(const PPTouchScreenPacket & rTsPack);
	int    MakeGroupEntryList(StrAssocArray * pTreeList, PPID parentID, uint level); // @recursion
	bool   FASTCALL F(long f) const;
	void   SetupExt(const CCheckPacket * pPack);
	bool   FASTCALL BelongToExtCashNode(PPID goodsID) const;
	PPID   FASTCALL GetChargeGoodsID(PPID scardID);
	double CalcSCardOpAmount(const CCheckLineTbl::Rec & rItem, PPID chargeGoodsID, PPID crdGoodsGrpID, double * pNonCrdAmt);
	double CalcSCardOpBonusAmount(const CCheckLineTbl::Rec & rItem, PPID bonusGoodsGrpID, double * pNonCrdAmt);
	double CalcCreditCharge(const CCheckPacket * pPack, const CCheckPacket * pExtPack, const CCheckItem * pCurItem, double * pNonCrdAmt, double * pBonusChargeAmt);
	int    CalcRestByCrdCard_(int checkCurItem);
	int    GetNewCheckCode(PPID cashNodeID, long * pCode);
	int    GetNewCheckCode(PPID cashNodeID, int * pCode) { return GetNewCheckCode(cashNodeID, reinterpret_cast<long *>(pCode)); }
	enum {
		iccpSetCurTime    = 0x0001,
		iccpDontFillLines = 0x0002,
		iccpFinish        = 0x0004  // Финишное формирование (не отложенного) чека перед сохранением в БД
	};
	//
	// Descr: Вспомогательная функция инициализации чека по состоянию кассовой панели.
	// Returns:
	//   0 - error
	//   1 - ok
	//   2 - ok and pExtPack is only settled. Специальное значение, означающее, что пакет по указателю pExtPack
	//     инициализирован вместо основного пакета (поскольку у последнего нет ни одной строки).
	//     Значение может быть использовано для обхода повторной инициализации pExtPack.
	//
	int    Helper_InitCcPacket(CCheckPacket * pPack, CCheckPacket * pExtPack, const CcAmountList * pCcPl, long options);
	int    StoreCheck(CCheckPacket * pPack, CCheckPacket * pExtPack, int suspended);
	int    PreprocessRowBeforeRemoving(/*IN*/long rowNo, /*OUT*/double * pResultQtty);
	int    AcceptCheckToBeCleared();
	int    Helper_RemoveRow(long rowNo, const CCheckItem & rItem);
	int    Helper_PrintRemovedRow(const CCheckItem & rItem);
	//
	// Descr: Флаги функций семейства AcceptSCard
	//
	enum {
		ascfFromInput    = 0x0001, // Извлечь код карты из поля ввода
		ascfExtPane      = 0x0002, // Открыть расширенный диалог выбора карты
		ascfIgnoreRights = 0x0004  // Игнорировать права доступа
	};
	int    Backend_AcceptSCard(PPID scardID, const SCardSpecialTreatment::IdentifyReplyBlock * pStirb, uint ascf);
	int    Implement_AcceptSCard(const SCardTbl::Rec & rScRec, const SCardSpecialTreatment::IdentifyReplyBlock * pStirb);
	double RoundDis(double d) const;
	void   Helper_SetupDiscount(double roundingDiscount, int distributeGiftDiscount);
	//
	// Descr: Хелпер, вызываемый из Helper_SetupDiscount для предварительной обработки строк чека.
	// ARG(mode IN): Режим обработки строк чека
	//   0 - основной режим
	//   1 - режим запроса к строронним службам
	//
	int    Helper_PreprocessDiscountLoop(int mode, void * pBlk);
	void   SetupDiscount(int distributeGiftDiscount);
	int    VerifyPrices();
	int    ProcessGift();
	int    AddGiftSaleItem(TSVector <SaSaleItem> & rList, const CCheckItem & rItem) const;
	double CalcCurrentRest(PPID goodsID, bool checkInputBuffer);
	int    LoadComplex(PPID goodsID, SaComplex & rComplex);
	int    LoadPartialStruc(PPID goodsID, PPGoodsStruc & rGs);
	int    SetupSCard(PPID scID, const SCardTbl::Rec * pScRec);
	void   ResetSCard();
	int    MakeDbgPrintLogList(int event, const SString & rFmtBuf, const SString & rChkBuf, const SString & rPrnName, SStrCollection & rList);
	int    Helper_SetupSessUuidForCheck(PPID checkID);
	//
	// Descr: Определяет являются ли все товары, находящиеся в пакете pPack или, если pPack == 0, то в P,
	//   специальными товарами начисления на карту scID.
	// Returns:
	//   true  - пакет пуст либо все товары в нем - начисление на карту scID
	//   false - в пакете есть по крайней мере один обыкновенный товар (не начисляющий средства на карту scID)
	//
	bool   IsOnlyChargeGoodsInPacket(PPID scID, const CCheckPacket * pPack);
	int    LoadModifiers(PPID goodsID, SaModif & rModif);
	int    Helper_GetPriceRestrictions_ByFormula(SString & rFormula, const CCheckItem & rCi, double & rBound) const;
	int    CheckPriceRestrictions(PPID goodsID, const CCheckItem & rCi, double price, RealRange * pRange);
	void   MsgToDisp_Clear();
	int    MsgToDisp_Add(const char * pMsg);
	virtual int MsgToDisp_Show();
	//
	// Descr: Возвращает операцию текущего чека. То есть один из вариантов enum opXXX
	//
	int    GetCurrentOp() const; // @v12.2.9 
	bool   IsCurrentOp(int op) const; // @v12.2.9 
	bool   IsCurrentOpCorrection() const; // @v12.2.11
	//
	// Descr: Устанавливает операцию текущего чека.
	//    Оооочень осторожно пользоваться - вся эта хрень в процессе разработки из-за необходимости отработать чеки коррекции.
	// ARG(op IN): Одно из значений CPosProcessor::opXXX
	//
	int    SetCurrentOp(int op); // @v12.2.9
	
	struct GrpListItem { // @flat
		GrpListItem();
		enum {
			fFolder = 0x0001,
			fOpened = 0x0002,
			fFirst  = 0x0004,
			fLast   = 0x0008
		};
		PPID   ID;
		PPID   ParentID;
		uint16 Flags;
		uint16 Level; // Номер уровня группы (0..)
	};
	class GroupArray : public TSVector <GrpListItem> {
	public:
		GroupArray();
		GrpListItem * Get(PPID id, uint * pPos) const;

		PPID   TopID;  // Товарная группа, являющаяся родительской для тех групп, которые в текущий момент отображаются в списке выбора группы.
	};
	GroupArray GroupList;

	struct CardState {
		enum {
			fUseDscntIfNQuot  = 0x0001, // Проекция флага SCRDSF_USEDSCNTIFNQUOT из серии карт
			fNoGift           = 0x0002, // Проекция флага SCRDF_NOGIFT из записи карты
			fAmtDiscountGrade = 0x0004, // Для карты применяется скидка с градацией по сумме чека (наследуемой из серии карт)
			fUhtt             = 0x0008, // Выбранная карта синхронизирована с системой Universe-HTT
			fUseMinQuotVal    = 0x0010, // Проекция флага SCRDSF_MINQUOTVAL из серии карт
			fBirthday         = 0x0020  // У владельца карты день рождения
		};
		CardState();
		~CardState();
		CardState & Z();
		PPID   GetID() const { return SCardID; }
		const  char * GetCode() const { return Code; }
		void   SetID(PPID id, const char * pCode);
		double GetDiscount(double ccAmount) const;

		long   Flags;
		SCardSpecialTreatment::IdentifyReplyBlock CSTRB;
		PPID   OwnerID;          // Ид владельца карты
		double Discount;         // Скидка
		double SettledDiscount;  // Установленная скидка (в процентах), в результате вызова CheckPaneDialog::SetupDiscount
		double RestByCrdCard;
		double UsableBonus;      //
		double MaxCreditByCrdCard;
		double AdditionalPayment;  // Доплата наличными
		PPSCardSerRule * P_DisByAmtRule; //
		RetailPriceExtractor::ExtQuotBlock * P_Eqb; //
	private:
		PPID   SCardID;          // ИД дисконтной карты
		char   Code[32];         // Номер карты
	};
	//
	// Descr: Блок параметров ручной скидки на весь чек. Скидка может быть предоставлена как в процентах,
	//   так и в суммовом выражении.
	//   Структура считается неопределенной если Discount <= 0.0
	//   Отрицательная скидка (искусственное увеличение цены) не допускается.
	//   Если установлена дисконтная карта, то ручная скидка применяется ПОСЛЕ начисления скидки по карте.
	//
	struct ManualDiscount {
		ManualDiscount();
		ManualDiscount & Z();
		enum {
			fPct    = 0x0001,
		};
		long   Flags;
		double Discount;
		double SettledAbsolutDiscount;
	};
	//
	// Descr: Блок, обеспечивающий информацию о связанном чеке для операций возврата и корректировки
	//
	struct LinkBlock {
		LinkBlock();
		LinkBlock & Z();

		int    _Op;       // @v12.2.8 CPosProcessor::opXXX
		PPID   _CcID;     // Ид чека, по которому осуществляется возврат или корректировка
		double _CcAmount; //
		double _CcCredit; //
		CcAmountList AmL; // Список оплат чека, по которому осуществляется возврат
		SString FiscalTag; // @v12.2.9 Фискальный признак для чека коррекции (_Op == opCorrection)
	};
	struct Packet : public CCheckItemArray, public PPExtStrContainer { // @v11.8.11 (public PPExtStrContainer)
	public:
		friend int CPosProcessor::SetupAgent(PPID agentID, int asAuthAgent);

		Packet();
		Packet & FASTCALL operator = (const CCheckItemArray & rS);
		Packet & Z();
		void   ClearCur();
		int    ClearGift();
		bool   HasCur() const;
		bool   IsCurValid() const;
		PPID   FASTCALL GetAgentID(int actual = 0) const;
		double GetGoodsQtty(PPID goodsID) const;
		//
		// ARG(isExtCc IN): Если true, то функция применяется к части чека, отправляемой на спаренный кассовый узел.
		//   Некоторые параметры при этом устанавливаются по-иному.
		//
		void   FASTCALL SetupCCheckPacket(CCheckPacket * pPack, const CardState & rCSt, bool isExtCc) const;
		void   SetupInfo(SString & rBuf);
		CCheckItem & GetCur() { return Cur; }
		const  CCheckItem & GetCurC() const { return Cur; }
		double GetRest() const { return Rest; }
		void   SetRest(double rest);
		int    MoveUp(uint itemIdx);
		int    MoveDown(uint itemIdx);
		int    Grouping(uint itemIdx);
		int    SetQueue(uint itemIdx, int8 queue);
		int    InitIteration();
		int    FASTCALL NextIteration(CCheckItem * pItem);

		int    CurCcItemPos; // Текущая позиция чека. 
			// Если (== -1), то нет выбранной позиции и буфер ввода пустой.
			// Если (CurCcItemPos == getCountI()), то в буфере ввода есть данные
			// Если (CurCcItemPos >= 0 && CurCcItemPos < getCountI()), то текущая позиция указывает на одну из акцептированных строк текущего чека.
	private:
		CCheckItem Cur;
		double Rest;   // Остаток товара, выбранного в буфере
		uint   IterIdx;
		PPID   AgentID__;  // ->Article.ID ИД продавца (официанта) Доступ к этому полю - только на чтение. Если надо изменить - SetupAgent()
		PPID   OrgAgentID; // Агент, к которому изначально привязан чек
			// В процессе обработки текущий агент в кассовой панели может иеняться. Данное поле нужно чтобы при этом не менялся оригинальный агент.
	public:
		long   TableCode;        // Номер столика
		uint16 GuestCount;       // Количество гостей за столом
		uint8  Reserve;          // @alignment
		bool   Paperless;        // @v11.3.6 Признак того, что регистрация должна осуществляться без печати бумажного чека
		PPID   OrderCheckID;     // Чек заказа, к которому привязан данный чек
		PPID   OrgUserID;        // Пользователь, создавший оригинальный чек (до первого отложения/восстановления)
		LAssocArray GiftAssoc;   // Список ассоциаций {gift_pos; used_by_gift_pos}
			// Этот список нужен для распределения фиксированной подарочной скидки между
			// строками, по которым этот подарок был предоставлен.
		ExtCcData Eccd;          //
		SaModif CurModifList;    // Список выбранных модификаторов для текущей позиции
		CcAmountList AmL;        // Список оплат по чеку
		CCheckPacket::BuersEAddr_ EAddr; // Электронный адрес покупателя (email or phone)
		// @v11.8.11 CCheckPacket::Prescription Prescr; // @v11.7.12
		LinkBlock Lb_; // @v12.2.9 moved from head class CPosProcessor
	};
	enum {
		fNoEdit             = 0x00000001, // Запрет на редактирование чеков
		fError              = 0x00000002, // В строке статуса выводится сообщение об ошибке. Текст сообщения хранится в буфере ErrMsgBuf
		fRetCheck           = 0x00000004, // Признак ввода чека возврата. Исключает fCorrection.
		fPctDis             = 0x00000008, // Скидка указана в процентах
		fBankingPayment     = 0x00000010, // Чек оплачивается банковской кредитной картой
		fWaitOnSCard        = 0x00000020, // Ожидание ввода дисконтной карты
		fTouchScreen        = 0x00000040, // Используется TouchScreen
		fSelByPrice         = 0x00000080, // Выбор по цене
		fAsSelector         = 0x00000100, // Диалог работает на выбор строки
		fLocPrinters        = 0x00000200, // Используются локальные принтеры
		fRetByCredit        = 0x00000400, // Возврат осуществляется по чеку, часть которого была оплачена корпоративным кредитом (бонусом).
		fCashNodeIsLocked   = 0x00000800, // Кассовый узел заблокирован
		fSleepMode          = 0x00001000, // Панель находится в спящем режиме
		fSuspSleepTimeout   = 0x00002000, // Приостанавливает отсчет таймаута спящего режима
		fPrintSlipDoc       = 0x00004000, // Печать подкладного документа (вместо печати на принтер)
		fBarrier            = 0x00008000, // Флаг блокирует обработку команд. Необходим для избежания возможность "реентранса" (особенно, при работе с сенсорным экраном).
		fOnlyReports        = 0x00010000, //
		fPresent            = 0x00020000, // Ввод товара-подарка
		fSCardBonus         = 0x00040000, // Карта, ассоциированная с чеком, является бонусной
		fSelSerial          = 0x00080000, // Выбирать серийный номер после выбора товара. Проекция флага CASHFX_SELSERIALBYGOODS кассового узла
		fDisableBeep        = 0x00100000, // Запрет на звуковой сигнал при сообщении об ошибке
		fNotUseScale        = 0x00200000, // Не использовать прием с весов
		fForceDivision      = 0x00400000, // Не разрешать проводить строку без номера отдела
		fLockBankPaym       = 0x00800000, // Блокировка безналичной оплаты (например, из-за неработающего банковского терминала)
		fSCardCredit        = 0x01000000, // Чек оплачивается корпоративной кредитной картой
		fUsedRighsByAgent   = 0x04000000, // Применены права доступа по агенту.
		fPrinted            = 0x08000000, // По чеку распечатан счет (called CheckPaneDialog::Print(x, 0))
		fReprinting         = 0x10000000, // В панель загружен незавершенный чек для перепечатки
		fSelModifier        = 0x20000000, // Режим выбора модификатора
		fSCardBonusReal     = 0x40000000, // Карта, ассоциированная с чеком, является бонусной. Практически
			// дублирует флаг fSCardBonus с небольшим нюансом. Если остаток на карте нулевой, то fSCardBonus не выставляется,
			// а fSCardBonusReal - устанавливается. Такое раздвоение необходимо что бы разным образом обрабатывать начисление
			// бонуса и использование бонуса для оплаты.
		fCorrection         = 0x80000000  // @v12.2.8 Признак ввода чека коррекции. Исключает fRetCheck.
	};
	enum {
		uifCloseWOAsk = 0x0001, // Закрывать кассовую панель без подтверждения PPCFM_CLOSECCHKPANE
		uifOnce       = 0x0004, // Панель открывается только для пробития единственного чека.
			// После проведения чека панель закрывается без предупреждения. Если чек не проведен, то
			// при попытке выхода из панели предупреждение запрашивается.
		uifTSGGroupsAsButtons = 0x0008, // Отрисовывать элементы списка групп как кнопки
		uifOneGroupLevel      = 0x0010, // В списке выбора группы отображается только один уровень групп,
			// принадлежащих выбранной группе верхнего уровня. Если флаг не установлен, то выбор иерархический
		uifAutoInput  = 0x0020  // Данные в поле ввода были внесены посредством сканирующего устройства.
			// Например, сканером штрихкодов. Признак устанавливается и снимается функцией GetInput на основе
			// анализа среднего времени между вводом символов. Если ввод осущствлялся методом PASTE, то флаг не устанавливается.
	};

	const  PPID CashNodeID;  // @*CheckPaneDialog::CheckPaneDialog
	PPID   ExtCashNodeID;    // @*CheckPaneDialog::CheckPaneDialog
	PPID   AltRegisterID;    // @*CheckPaneDialog::CheckPaneDialog
	PPID   TouchScreenID;    // @*CheckPaneDialog::CheckPaneDialog
	PPID   ScaleID;          // @*CheckPaneDialog::CheckPaneDialog
	PPID   CnPhnSvcID;       // PPObjCashNode(CashNodeID).PhSvcID
	long   CnFlags;          // @*CheckPaneDialog::CheckPaneDialog (PPObjCashNode(CashNodeID).Flags & (CASHF_SELALLGOODS | CASHF_USEQUOT | CASHF_NOASKPAYMTYPE))
	long   CnExtFlags;       // @*CheckPaneDialog::CheckPaneDialog PPObjCashNode(CashNodeID).ExtFlags
	long   CnSpeciality;     // PPObjCashNode(CashNodeID).Speciality
	PPID   CnLocID;          // PPObjCashNode(CashNodeID).LocID
	PPID   ExtCnLocID;       // PPObjCashNode(ExtCashNodeID).LocID
	long   Flags;            // CheckPaneDialog::fXXX
	long   UiFlags;          // CheckPaneDialog::uifXXX Флаги пользовательского интерфейса
	int    State_p;          // CheckPaneDialog::sXXX
	long   OperRightsFlags;  // CheckPaneDialog::orfXXX
	int    EgaisMode;        // Режим работы с ЕГАИС (0 - нет, 1 - использовать, 2 - тестовый режим, 3 - только сканировать марку).
		// Извлекается из записи синхронного кассового узла (PPSyncCashNode::EgaisMode)
		// Если EgaisMode != 0 и !(Flags & fNoEdit), то в конструкторе создается *P_EgPrc.
	int    ChZnPermissiveMode; // @v11.9.12 Режим работы с разрешительным режимом честный знак.
	PPID   ChZnGuaID;        // @v12.0.12 
	double BonusMaxPart;     // @*CPosProcessor::CPosProcessor()
	long   OrgOperRights;    // Права доступа установленные в конструкторе либо по ключу.
		// Так как агент может переопределять права доступа, то при изменении агента OperRightsFlags
		// должны быть восстановлены из OrgOperRights.
		// Права агента имеют приоритет перед правами пользователя или ключа.
	PPID   CheckID;
	PPID   SuspCheckID;      // Загружен отложенный чек с указанным идентификатором
	PPID   AuthAgentID;      // Агент, который изначально авторизовался в сессии (для поддержки мобильного официанта)
	PPID   AbstractGoodsID;  // Абстрактный товар для проведения строк по свободной цене.
		// Если (CnExtFlags & CASHFX_ABSTRGOODSALLOWED), то равно PPGoodsConfig::DefGoodsID, в противном случае - 0.
	PPObjID OuterOi;         // Внешний объект, к которому привязывается чек.
	LDATETIME LastGrpListUpdTime;     // Время последнего обновления списка групп товаров
	S_GUID SessUUID;
	PPGenCashNode::RoundParam R__;      // Параметры округления //
	PPSyncCashNode::SuspCheckFilt Scf;
	SString CnName;          // Наименование кассового узла
	SString CnSymb;          // Символ кассового узла
	SString Input;
	SString ErrMsgBuf;
	SString TableSelWhatman;
	SString KitchenBellCmd;  // Команда кухонного звонка
	SString KitchenBellPort; // Порты отправки команды кухонного звонка
	SString PhnSvcLocalChannelSymb;
	SString RptPrnPort;      // Порт принтера для печати регулярный отчетов (предчек, например)
	StringSet MsgToDisp;     // Список текстовых сообщений, которые следует отобразить
	Packet P;
	CCheckPacket SelPack;  // Чек, выбранный в качестве образца при возврате или при перепечатке незавершенного чека
	RAssocArray  SelLines; // Строки чека, относящиеся к образцу, выбранному при возврате либо коррекции
	// @v12.2.9 (moved to Packet) LinkBlock Lb_;
	PPObjGoods GObj;
	PPObjSCard ScObj;
	PPObjArticle ArObj;
	PPObjPerson PsnObj;
	PPObjGoodsStruc GSObj;
	PPObjCashNode CnObj;
	CardState CSt;
	ManualDiscount ManDis; // @v11.0.9
	PPCashMachine    * P_CM;
	PPCashMachine    * P_CM_EXT;
	PPCashMachine    * P_CM_ALT;
	GoodsToObjAssoc  * P_GTOA;
	PPObjTSession    * P_TSesObj;
	SArray * P_DivGrpList;
	CCheckPacket * P_ChkPack;
	PPViewCCheck * P_CcView;
	// @v12.2.11 PPEgaisProcessor * P_EgPrc_ToEliminate;
	EgaisMarkAutoSelector * P_EgMas; // @v12.0.12
	LAssocArray SpcTrtScsList; // Список серий карт со специальной трактовкой
};

class CheckPaneDialog : public TDialog, public CPosProcessor {
public:
	friend int CCheckPane(PPID, PPID, const char *, long);
	static int SetLbxItemHight(TDialog *, void * extraPtr); // DialogPreProcFunc

	CheckPaneDialog(PPID cashNodeID, PPID checkID, CCheckPacket * pOuterCcPack, uint ctrFlags/*int isTouchScreen = 0*/);
	~CheckPaneDialog();
	virtual int    AcceptCheck(PPID * pCcID, const CcAmountList * pPl, PPID altPosNodeID, double cash, int mode);
	virtual void   ClearCheck();
	virtual void   OnUpdateList(int goBottom);
	void   SetSCard(const char * pStr);
	void   EnableBeep(int enbl);
	void   SetInput(const char * pStr);
	int    LoadTSession(PPID tsessID);
	int    LoadChkInP(PPID chkinpID, PPID goodsID, double qtty);
private:
	static  int PalmImport(PalmBillPacket *, void * extraPtr);
	DECL_HANDLE_EVENT;
	// @v12.2.6 virtual int  FASTCALL valid(ushort command);
	virtual int  SetupState(int st);
	virtual void SetupInfo(const char * pErrMsg);
	virtual int  Implement_AcceptCheckOnEquipment(const CcAmountList * pPl, AcceptCheckProcessBlock & rB);
	virtual void NotifyGift(PPID giftID, const SaGiftArray::Gift * pGift);
	virtual void ClearRow();
	virtual void SetupRowData(bool doCalcRest);
	virtual void SetPrintedFlag(int set);
	virtual int  MessageError(int errCode, const char * pAddedMsg, long outputMode);
	virtual int  ConfirmMessage(int msgId, const char * pAddedMsg, int defaultResponse);
	virtual int  CDispCommand(int cmd, int iVal, double rv1, double rv2);
	virtual int  MsgToDisp_Show();
	bool   ValidateCommand(TEvent & rEv);
	int    SetDlgResizeParams();
	int    FASTCALL Barrier(int rmv = 0);
	int    RemoveRow();
	enum {
		sgmNormal = 0,
		sgmByPrice,
		sgmModifier,
		sgmRandom,
		sgmInnerGoodsList,
		sgmAbstractSale, //
		sgmAllByName     // Все товары по наименованию (режим применяется в случае,
			// если необходимо отобразить все товары, содержащие строку, и не зависимо от остатка,
			// но опции кассового узла предписывают показывать только то, что есть на остатке).
	};
	void   FASTCALL SelectGoods__(int mode);
	void   AddFromBasket();
	void   AcceptQuantity();
	int    VerifyQuantity(PPID goodsID, double & rQtty, const CCheckItem * pCurItem, bool adjustQtty, bool checkInputBuffer); // @v11.0.3 checkInputBuffer
	void   AcceptSCard(PPID scardID, const SCardSpecialTreatment::IdentifyReplyBlock * pStirb, uint ascf);
	void   AcceptManualDiscount();
	int    LoadCheck(const CCheckPacket *, bool makeRetCheck, bool dontShow);
	int    SetupOrder(PPID ordCheckID);
	void   SetupRetCheck(bool ret);
	void   setupHint();
	bool   GetInput();
	void   ClearInput(int selectOnly);
	int    SelectGuestCount(int tableCode, long * pGuestCount);
	void   ProcessEnter(int selectInput);
	int    PrintCheckCopy();
	int    PrintSlipDocument();
	void   PrintBankingSlip(int afterReceipt, const SString & rSlipBuf);
	//
	// Descr: Флаги функции SelectCheck()
	//
	enum {
		scfSelFormat        = 0x0001, // @v12.2.8
		scfSelSlipDocFormat = 0x0002, // 
		scfThisNodeOnly     = 0x0004, //
		scfAllowReturns     = 0x0008, // Допускается выбор чеков возврата
	};
	struct SelectCheckResult {
		SelectCheckResult() : CcID(0), Op(0)
		{
		}
		PPID   CcID; // Ид чека
		int    Op;   // Выбранная операция с чеком: 0 - undef (по контексту), 1 - возврат, 2 - коррекция //
		SString Format;
	};
	int    SelectCheck(const char * pTitle, long flags, SelectCheckResult & rResult);
	int    SelectBill(PPID * pBillID, const char * pTitle); // @v11.8.7
	int    UpdateGList(int updGoodsList, PPID selGroupID);
	int    PreprocessGoodsSelection(PPID goodsID, PPID locID, PgsBlock & rBlk);
	int    SelectSerial(PPID goodsID, SString & rSerial, double * pPriceBySerial);
	void   ResetListWindows(int listCtrlID);
	int    SuspendCheck();
	int    SelectSuspendedCheck();
	int    SelectTable();
	int    ResetOperRightsByKey();
	int    PrintCashReports();
	int    IsSalCode(const SString & rInput, SString & rCode);
	int    IsCode(const SString & rInput, SString & rPfx, int asterix, SString & rCode) const;
	int    SetupSalByCode(const SString & rInput);
	int    Sleep();
	void   DrawListItem(TDrawItemData *);
	int    TestCheck(CheckPaymMethod paymMethod);
	int    SelectGroup(PPID * pGrpID);
	int    GetLastCheckPacket(PPID nodeID, PPID sessID, CCheckPacket * pPack);
	int    GenerateChecks();
	void   AcceptDivision();
	int    GetDataFromScale(PPID * pGoodsID, double * pWeight);
	int    SetupRowByScale();
	int    AcceptRowDiscount();
	int    PhnSvcConnect();
	int    ProcessPhnSvc(int mode);
	int    InputComplexDinner(SaComplex & rComplex);
	int    EditMemo(const char * pDlvrPhone, const char * pChannel);
	int    EditPrescription();
	void   ViewStoragePlaces(PPID goodsId);
	int    ConfirmPosPaymBank(PosPaymentBlock & rPpl);
	//
	// Descr: Функция пытается найти марку чзн для автоматического списания (без ручного выбора)
	//   На текущий момент функция работает только для товаров, 
	//   имеющих тип чзн GTCHZNPT_DRAFTBEER_AWR (разливное пиво с разрешением автоматического выбора марки).
	// ARG(goodsID IN): Ид продаваемого товара
	// ARG(qtty IN): Количество продаваемого товара (в торговых единицах)
	// ARG(rChZnBuf OUT): Буфер, в который вносится найденная (в случае успеха) марка 
	// Returns:
	//   >0 - функция нашла марку для автоматического списания //
	//   <0 - не удалось найти подходящую марку либо товар не допускает такую операцию
	//    0 - ошибка
	//
	int    ChZnMarkAutoSelect(PPID goodsID, double qtty, SString & rChZnBuf);

	ExtGoodsSelDialog * P_EGSDlg;
	long   AutoInputTolerance; // Мин среднее время (ms) между вводом символом, ниже которого считается, что данные были введены автоматическим средством ввода (напр. сканером штрихкодов)
	long   BarrierViolationCounter; // @debug
	PPID   AltGoodsGrpID;    //
	PPID   SelGoodsGrpID;    //
	PPID   LastCtrlID;       //
	long   CnSleepTimeout;   // @*CheckPaneDialog::CheckPaneDialog() Таймаут бездействия, после которого панель засыпает (clock)
	clock_t IdleClock;       // Время простоя панели в неактивном режиме (clock)
	clock_t PrintCheckClock; // Время окончания печати чека
	long   ClearCDYTimeout;  // @*CheckPaneDialog::CheckPaneDialog() Таймаут очистки дисплея покупателя после печати чека
	PPCustDisp  * P_CDY;
	PPBnkTerminal	 * P_BNKTERM; // @vmiller
	PalmImportWaiter * P_PalmWaiter;
	AsteriskAmiClient * P_PhnSvcClient;
	PPBillImporter * P_UhttImporter;
	SCycleTimer PhnSvcTimer;
	SCycleTimer UhttImportTimer;
	PPID   ActiveListID;   //
	//
	// Параметры перерисовки списка товаров
	//
	enum {
		dummyFirst = 1,
		fontGoodsList,     // Шрифт используемый для отрисовки элементов списка товаров (для TouchScreen)
		brSel,             // Кисть для выбранного товара
		brOdd,             // Кисть для нечетных строк товаров
		brEven,            // Кисть для четных строк товаров
		brGrpSel,          // Кисть для выбранной группы
		brGrp,             // Кисть для обычной группы
		brGrpParent,       // Кисть для группы верхнего уровня //
		brErrorBkg,        // Кисть фона для вывода сообщения об ошибке в строке статуса
		brPresentBkg,      // Кисть фона для вывода сообщения о подарке в строке статуса
		clrFocus,
		clrEven,
		clrOdd,
		clrGrp,
		clrParent,
		penSel,            // Рамка для выбранного элемента
		brTotalGift,       // Кисть для фона итоговой величины, если в чеке есть подарок
		brDiscountGift,    // Кисть для фона скидки, если в чеке есть подарочная скидка
		brOrderBkg         // Кисть для фона информации о чеке, если чек создан по заказу
	};
	uint   GoodsListFontHeight;
	int    GoodsListEntryGap;    //
	SPaintToolBox Ptb;           //
};
//
// Descr: Хранилище для строковых элементов recently-used. Например, для последних открытых файлов.
//   Объект поддерживает максимальное количество элементов maxItems, заданное в констукторе.
//   Ключ для списка определяется фактором ident, который может быть либо целочисленным, либо строковым.
//   Механизм сравнения уже вставленных элементов списка с новым следующий: если задана функция
//   сравнения Cf, то применяеся она, в противном случае - стандартное строковое сравнение, чувствительное к регистру
//   символов (strcmp()).
//
class RecentItemsStorage {
public:
	RecentItemsStorage(int ident, uint maxItems, CompFunc cf);
	RecentItemsStorage(const char * pIdent, uint maxItems, CompFunc cf);
	~RecentItemsStorage();
	int    CheckIn(const char * pText);
	int    GetList(StringSet & rSs);
private:
	int    Ident;
	uint   MaxItems;
	CompFunc Cf;
	SString IdentText;
};
//
// Import/Export Block (PPImpExpParam etc)
//
//
// @vmiller
// Descr: Вспомогательная структура, содержащая параметры для импорта/экспорта данных через dll
//
struct ImpExpParamDllStruct {
	ImpExpParamDllStruct();

	long   BeerGrpID;		 // ИД группы товаров "пиво"
	long   AlcoGrpID;		 // ИД группы товаров "алкоголь"
	long   AlcoLicenseRegID; // ИД регистра производителя с номером "лицензия на алкоголь"
	long   TTNTagID;		 // ИД тега с номером ТТН
	long   ManufTagID;		 // ИД тега импортера/производител
	long   ManufKPPRegTagID; // ИД регистра производителя с номером КПП
	long   RcptTagID;		 // ИД тега для пометки о доставке заказа поставщику
	long   ManufRegionCode;  // Код региона из адреса производителя/импортера
	long   IsManufTagID;	 // Если 1, то персоналия-производитель, 2 - персоналия-импортер
	long   GoodsKindTagID;   // ИД тега лота, определяющего вид товара
	long   ManufINNID;       // ИД тега лота, содержащего ИНН производител
	SString DllPath;
	SString FileName;
	SString Login;
	SString Password;
	SString GoodsKindSymb;	 // По какому параметру искать вид товара: x, y, z, w
	SString XmlPrefix;
	SString OperType;		 // Тип операции импорта/экспорта
	SString GoodsVolSymb;    // По какому параметру смотреть объем продукции: x, y, z, w
};
//
// Descr: Структура соответсвия полей и параметров импорта/экспорта данных
// @defined(PPLIB\RFLDCORR.CPP)
//
class PPImpExpParam {
public:
	static PPImpExpParam * FASTCALL CreateInstance(const char * pIehSymb, long flags);
	static PPImpExpParam * FASTCALL CreateInstance(uint recId, long flags);
	static PPImpExpParam * FASTCALL CreateInstance(const SdRecord & rSdRec, long flags);
	explicit PPImpExpParam(uint recID = 0, long flags = 0);
	virtual ~PPImpExpParam();
	int    Init(int import = 0);
	virtual int Edit();
	virtual int Select();
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	//
	// Descr: Эта функция должна выполнить одну из трех операций над именем конфигурации экспорта:
	//   (op == 1) - [decorate name] Модифицировать имя конфигурации так, чтобы обеспечить
	//      уникальность этого имени среди других конфигураций импорта/экспорта, относящихся к
	//      другим классам
	//   (op == 2) - [undecorate name] Убрать декорирующую часть из имени так, чтобы пользователь
	//      видел то имя конфигурации, которое он задал.
	//   (op == 3) - [check decorated name] Проверить правильность декорированного имени конфигурации
	//   (op == 4) - [check undecorated name] Проверить правильность недекорированного имени конфигурации
	// Returns:
	//   >0 - функция выполнена успешно
	//   0  - ошибка
	//   <0 - функция не выполняла ни каких действий
	//
	virtual int ProcessName(int op, SString & rName) const;
	//
	// Descr: Функция должна сформировать имя файла экспорта на основании значения FileName и
	//   вернуть полное имя файла по ссылке rResult.
	// Note:
	//   Функция принципиально константная и не может ни при каких обстоятельствах
	//   менять внутреннее состояние экземпляра объекта - это связано с особенностями вызова данной функции.
	// Returns:
	//   1 - имя файла используется то же, что и было задано в FileName
	//   100 - имя файла сформировано по шаблону, заданному в FileName
	//   0 - error
	//
	virtual int MakeExportFileName(const void * extraPtr, SString & rResult) const;
	virtual int PreprocessImportFileSpec(StringSet & rList);

	class PtTokenList : public SStrGroup {
	public:
		PtTokenList();
		PtTokenList & Z();
		uint    GetCount() const;
		int     Add(long tokenId, long extID, const char * pText);
		int     Get(uint pos, long * pTokenId, long * pExtID, SString & rText) const;
	private:
		struct InnerEntry {
			long   TokenId;
			long   ExtID;
			uint   StrP;
		};
		TSVector <InnerEntry> L;
	};

	virtual int PreprocessImportFileName(const SString & rFileName, PPImpExpParam::PtTokenList & rResultList);
	int    GetFilesFromSource(const char * pUrl, StringSet & rList, PPLogger * pLogger);
	int    DistributeFile(PPLogger * pLogger);

	enum {
		dfText = 0,
		dfDbf,
		dfXml,
		dfSoap,
		dfExcel
	};
	enum {
		bfDLL    = 0x0001,
		bfDeleteSrcFiles = 0x0002
	};
	uint   RecId;
	long   DataFormat;     // dfXXX
	long   Direction;      // 0 - экспорт, 1 - импорт
	long   EDIDocType;     // Тип докумнта для импорт/экспорта с помощью EDI // @vmiller
	long   BaseFlags;      // PPImpExpParam::bfXXX
	PPID   InetAccID;      // Учетная запись интернет-соединения
	TextDbFile::Param  TdfParam;
	XmlDbFile::Param   XdfParam;
	SoapDbFile::Param  SdfParam;
	ExcelDbFile::Param XlsdfParam;
	SdRecord HdrInrRec;     // Запись, определяющая заголовочный внутренний набор данных.
	SdRecord HdrOtrRec;     // Запись, определяющая заголовочный внешний набор данных.
	SdRecord InrRec;        // Запись, определяющая внутренний набор данных
	SdRecord OtrRec;        // Запись, определяющая внешний (для импорта/экспорта) набор данных
	SString Name;           // Название конфигурации
	SString DataSymb;       // Символ наименования структуры данных
	SString GlobalUserName; // Если конфигурация принадлежит глобальной учетной записи, то здесь задается имя аккаунта.
	SString FileName;       // Имя файла импорта/экспорта
	ImpExpParamDllStruct ImpExpParamDll; // @vmiller
private:
	int    ParseFormula(int hdr, const SString & rPar, const SString & rVal);
};

extern "C" typedef PPImpExpParam * (*FN_IMPEXPHDL_FACTORY)(long flags);

#define IMPEXP_HDL_FACTORY(iehSymb)  IEHF_##iehSymb
#define IMPLEMENT_IMPEXP_HDL_FACTORY(iehSymb, cls) \
	extern "C" __declspec(dllexport) PPImpExpParam * IEHF_##iehSymb(long flags) { return new cls(PPREC_##iehSymb, flags); }
//
// ARG(fileNameId  IN): Идентификатор имени файла, из которого следует получить описание формата
// ARG(sdRecId     IN): Идентификатор записи, в соответствии с которой должен быть получено описание формата
// ARG(pParam     OUT): Описание формата, заполняемое функцией
// ARG(pSectNames OUT): Функция заносит в этот список наименования секций файла, содержащих описания форматов
// ARG(kind        IN): Параметр, определяющий фильтрацию видов описаний
//   0 - и импорт и экспорт
//   1 - только экспорт
//   2 - только импорт
//
int GetImpExpSections(uint fileNameId, uint sdRecId, PPImpExpParam * pParam, StringSet * pSectNames, int kind);
int GetImpExpSections(PPIniFile & rF, uint sdRecId, PPImpExpParam * pParam, StringSet * pSectNames, int kind);
int GetImpExpSections(uint fileName, uint sdRecID, PPImpExpParam * pParam, StrAssocArray * pList, int kind);
int GetImpExpSections(PPIniFile & rF, uint sdRecID, PPImpExpParam * pParam, StrAssocArray * pList, int kind);
//
// Descr: Класс, реализующий универсальный механизм импорта/экспорта данных
// Note: Функции класса считают, что все строковые поля при экспорте
//   поставляются в ANSI кодировке (не OEM)
//
class PPImpExp {
public:
	//
	// Descr: Вспомогательная функция, обеспечивающая разрешение выражения,
	//   представленного наименованием поля структуры rRec.
	//   Используется в контекстах разбора выражений.
	//
	static int ResolveVarName(const char * pSymb, const SdRecord & rRec, double * pVal);

	PPImpExp(const PPImpExpParam *, const void * extraPtr);
	~PPImpExp();
	int    IsCtrError() const;
	int    IsOpened() const;
	int    OpenFileForReading(const char * pFileName);
	int    OpenFileForWriting(const char * pFileName, int truncOnWriting, StringSet * pResultFileList = 0);
	void   CloseFile();
	//int    GetFilesFromSource(const char * pWildcard, PPLogger * pLogger);
	int    DistributeFile(PPLogger * pLogger);
	int    AppendHdrRecord(void * pDataBuf, size_t dataBufLen);
	int    AppendRecord(void * pDataBuf, size_t dataBufLen);
	int    InitDynRec(SdRecord * pDynRec) const;
	int    ReadRecord(void * pInnerBuf, size_t bufLen, SdRecord * pDynRec = 0);
	int    GetNumRecs(long * pNumRecs);
	//
	// Descr: Устанавливает внешний контекст для разрешения формул.
	//   Экземпляр класса PPImpExp не владеет переданным указателем.
	//   То есть, вызывающая функция (класс) должна сама
	//   позаботиться о разрушении объекта, на который ссылается переданный указатель.
	// Note: Передаваемый контекст должен уметь распознавать
	//   переменные, представленные наименованиями полей структуры импорта/экспорта.
	//   Для этого следует использовать вспомогательную статическую функцию PPImpExp::ResolveVarName.
	//
	void   SetExprContext(ExprEvalContext * pCtx);
	int    SetHeaderData(const Sdr_ImpExpHeader * pData);
	const  PPImpExpParam & GetParamConst() const;
	PPImpExpParam & GetParam();
	//
	// Descr: Сохраняет текущее состояние, позволяет считывать в буфер данные о подчиненном элементе.
	//
	int    Push(const PPImpExpParam * pParam);
	//
	// Descr: Восстанавливает текущее состояние.
	//
	int    Pop();
	int    FASTCALL GetFileName(SString & rFileName) const;
	const  SString & GetPreservedOrgFileName() const;
	//
	// Descr: Функция возвращает подготовленные экспортированные данные в буфере rBuf.
	//   Может быть использована только в том случае, если при инициализации
	//   было директивно предопределено требование выгружать данные не в файл, а в буфер памяти.
	// Returns:
	//   >0 - данные успешно скопированы в буфер
	//   <0 - функция не может быть выполнена поскольку экспорт был осуществлен в файл
	//   0  - ошибка
	//
    int    FASTCALL GetExportBuffer(SBuffer & rBuf);
private:
	enum {
		sOpened   = 0x0001, // Файл открыт
		sReadOnly = 0x0002, // Объект работает в режиме "Чтение"
		sCtrError = 0x0004, // Если в контструкторе возникла ошибка, то этот флаг устанавливается //
		sBuffer   = 0x0008  // Обмен осуществляется посредством буфера, а не файла (пока доступно только для экспорта в XML)
	};
	// @vmiller
	struct StateBlock {
		StateBlock();

		int    Busy;
		ulong  RecNo;
		SString FileNameRoot;
		PPImpExpParam Param;
	};
	int    Helper_OpenFile(const char * pFileName, int readOnly, int truncOnWriting, StringSet * pResultFileList);
	int    ResolveFormula(const char * pFormula, const void * pInnerBuf, size_t bufLen, SString & rResult);
	int    GetArgList(SStrScan & rScan, StringSet & rArgList);
	int    ConvertInnerToOuter(int hdr, const void * pInnerBuf, size_t bufLen);
	int    ConvertOuterToInner(void * pInnerBuf, size_t bufLen, SdRecord * pDynRec);
	PPImpExpParam P;
	long   State; // PPImpExp::sXXX
	DbfTable    * P_DbfT;
	TextDbFile  * P_TxtT;
	XmlDbFile   * P_XmlT;
	SoapDbFile  * P_SoapT;
	ExcelDbFile * P_XlsT;
	Sdr_ImpExpHeader * P_HdrData;
	ExprEvalContext * P_ExprContext; // @notowned
	ulong  R_RecNo;
	ulong  W_RecNo;
	ulong  R_SaveRecNo;
	int    ExtractSubChild;
	SString PreserveOrgFileName;
	TSCollection <StateBlock> StateColl; // @vmiller
	TSStack <int> StateStack; // @vmiller
};
//
//
//
class PPDbTableXmlExporter {
public:
	struct BaseParam {
		BaseParam(uint32 sign);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fReplaceIdsBySync = 0x0001
		};
		uint32 Sign;
		long   Flags;
		PPID   RefDbID;
		SString FileName;
	};
	PPDbTableXmlExporter();
	virtual ~PPDbTableXmlExporter();
	virtual DBTable * Init() = 0;
	virtual int  Next() = 0;
	int    Run(const char * pOutFileName);
protected:
	IterCounter Cntr;
};

struct PPDbTableXmlExportParam_TrfrBill : public PPDbTableXmlExporter::BaseParam {
public:
	static int Edit(PPDbTableXmlExportParam_TrfrBill * pData);
	PPDbTableXmlExportParam_TrfrBill();
	int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	DateRange Period;
};

class PPDbTableXmlExporter_Transfer : public PPDbTableXmlExporter {
public:
	PPDbTableXmlExporter_Transfer(const PPDbTableXmlExportParam_TrfrBill & rParam);
private:
	virtual DBTable * Init();
	virtual int  Next();

	PPDbTableXmlExportParam_TrfrBill P;
	Transfer * P_T;
	BExtQuery * P_Q;
};

class PPDbTableXmlExporter_Bill : public PPDbTableXmlExporter {
public:
	PPDbTableXmlExporter_Bill(const PPDbTableXmlExportParam_TrfrBill & rParam);
private:
	virtual DBTable * Init();
	virtual int  Next();

	PPDbTableXmlExportParam_TrfrBill P;
	BillCore * P_T;
	BExtQuery * P_Q;
};
//
// Descr: Общий контекст разрешения формул по записи импорта/экспорта
//
class ImpExpExprEvalContext : public ExprEvalContext {
public:
	ImpExpExprEvalContext(const SdRecord & rRec);
	virtual int Resolve(const char * pSymb, double * pVal);
private:
	const SdRecord & R_Rec;
};
//
// @vmiller
// Класс для импорта/экспорта через dll
//
class ImpExpDll {
public:
	typedef int (* InitExpProc)(void * , const char * , int *);
	typedef int (* SetExpObjProc) (uint , const char * , void *, int *, const char *);
	typedef int (* InitExpIterProc) (uint , uint);
	typedef int (* NextExpIterProc) (uint , uint , void *);
	typedef int (* EnumExpReceiptProc) (void *);
	typedef int (* InitImpProc)(void * , const char * , int *);
	typedef int (* GetImpObjProc) (uint , const char * , void *, int *, const char *);
	typedef int (* InitImpIterProc) (uint , uint);
	typedef int (* NextImpIterProc) (uint , uint , void *);
	typedef int (* ReplyImpObjStatusProc) (uint , uint , void *);
	typedef int (* FinishImpExpProc) ();
	typedef int (* GetErrorMessageProc) (char * , uint);

	ImpExpDll();
	~ImpExpDll();
	int    operator !() const;
	const  int IsInited() { return Inited; }
	// pDllName - полный путь к dll
	// op - операция. 1 - экспорт, 2 - импорт
	int InitLibrary(const char * pDllName, uint op);
	void ReleaseLibrary();

	InitExpProc InitExport;
	SetExpObjProc SetExportObj;
	InitExpIterProc InitExportIter;
	NextExpIterProc NextExportIter;
	EnumExpReceiptProc EnumExpReceipt;
	InitImpProc InitImport;
	GetImpObjProc GetImportObj;
	InitImpIterProc InitImportIter;
	NextImpIterProc NextImportIter;
	ReplyImpObjStatusProc ReplyImportObjStatus;
	FinishImpExpProc FinishImpExp;
	GetErrorMessageProc GetErrorMessage;
private:
	int    OpKind;
	int    Inited;
	SDynLibrary * P_Lib;
};

int InitImpExpParam(uint hdrRecType, uint recType, PPImpExpParam * pParam, const char * pFileName, int forExport, long dataFormat);
int InitImpExpDbfParam(uint recType, PPImpExpParam * pParam, const char * pFileName, int forExport);
//
//
//
class PPWorkbookImpExpParam : public PPImpExpParam {
public:
	explicit PPWorkbookImpExpParam(uint recId = 0, long flags = 0);
};

class PPWorkbookExporter {
public:
	PPWorkbookExporter();
	~PPWorkbookExporter();
	int    Init(const PPWorkbookImpExpParam * pParam);
	int    ExportPacket(const PPWorkbookPacket * pPack);
private:
	PPWorkbookImpExpParam Param;
	PPImpExp * P_IEWorkbook;
	PPObjWorkbook WbObj;
	SString DestFilesPath; // @*PPWorkbookExporter::Init()
};
//
//
//
struct GoodsImportBillIdent {
	GoodsImportBillIdent(PPObjPerson * pPsnObj, PPID defSupplID);
	~GoodsImportBillIdent();
	void   GetFldSet(PPIniFile *, uint sect, DbfTable * pTbl);
	int    Get(DbfRecord * pRec);
	int    Get(Sdr_Goods2 * pRec, PPID supplID);
	PPBillPacket * GetPacket(PPID opID, PPID locID);
	int    FinishPackets();

	PPID   SupplID;
	LDATE  BillDate;
	SString BillCode;
private:
	int    fldn_suppl;
	int    fldn_supplcode;
	int    fldn_billcode;
	int    fldn_billdate;
	//
	SString SupplCodeRegSymb;
	int    CvtCodeToHex;
	PPID   RegTypeID;
	PPID   AccSheetID;
	PPID   DefSupplID;
	//
	SArray * P_CodeToPersonTab;
	PPObjPerson * P_PsnObj; // Not owned by GoodsImportBillIdent
	PPObjArticle * P_ArObj;
	PPBillPacketCollection * P_PackList; // key: Rec.Dt; Rec.Object; Rec.Code
};

class HierArray : public SVector {
public:
	struct Item {
		char   Code[24];
		char   ParentCode[24];
	};
	HierArray();
	const  HierArray::Item & at(uint i) const;
	int    Add(const char * pCode, const char * pParentCode);
	bool   SearchParentOf(const char * pCode, char * pBuf, size_t bufLen) const;
	bool   IsThereChildOf(const char * pParentCode) const;
};

class PPGoodsImpExpParam : public PPImpExpParam {
public:
	enum {
		fSkipZeroQtty     = 0x0001,
		fAnalyzeBarcode   = 0x0002,
		fAnalyzeName      = 0x0004,
		fAnalyzeOnly      = 0x0008,
		fUHTT     = 0x0010,
		fForceSnglBarcode = 0x0020,
		fImportImages     = 0x0040,
		fForceUpdateManuf = 0x0080,
		fForceUpdateBrand = 0x0100  // @v11.6.10
	};
	PPGoodsImpExpParam(uint recId = 0, long flags = 0);
	void   Clear();
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);

	int32   AccSheetID;
	int32   SupplID;
	int32   DefUnitID;
	int32   PhUnitID;
	int32   DefParentID;
	int32   RcptOpID;
	int32   Flags;
	int32   LocID;
	int32   MatrixAction;
	SString SubCode;
};

class PPGoodsExporter {
public:
	PPGoodsExporter();
	~PPGoodsExporter();
	int    Init(const PPGoodsImpExpParam * pParam, StringSet * pResultFileList);
	int    ExportPacket(PPGoodsPacket * pPack, const char * pBarcode, PPID altGrpID = 0); // realy pPack - const
	PPGoodsImpExpParam Param;
	PPImpExp * P_IEGoods;
private:
	char   WeightPrefix[12];
	PPObjGoods * P_GObj;
	PPObjPerson * P_PsnObj;
	PPObjQCert * P_QcObj;
};
//
//
//
class PPQuotImpExpParam : public PPImpExpParam {
public:
	explicit PPQuotImpExpParam(uint recId = 0, long flags = 0);
	PPQuotImpExpParam & Z();
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	int32   QuotCls;    // @v11.4.2 Категория котировок
	int32   QuotKindID;
	int32   CurrID;
	int32   ArID;
	int32   LocID;
	int32   Flags;
};
//
//
//
class PPPriceListImpExpParam : public PPImpExpParam {
public:
	PPPriceListImpExpParam(uint recId = 0, long flags = 0);
};
//
//
//
class PPPhoneListImpExpParam : public PPImpExpParam {
public:
	PPPhoneListImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	SString DefCityPhonePrefix;
};

int EditPhoneListParam(const char * pIniSection);
//
//
//
class PPPersonImpExpParam : public PPImpExpParam {
public:
	explicit PPPersonImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	enum {
		f2GIS      = 0x0001, // Данные извлечены из сервиса 2GIS (импорт реализуется с некоторыми спецификами)
		fCodeToHex = 0x0002  // Код персоналии преобразуется к строке, каждый символ кода преобразуется //
			// в свое беззнаковое шестнадцатиричное представление (два символа). Буквы в этой строке находятся в верхнем регистре.
	};
	PPID   DefKindID;
	PPID   DefCategoryID;
	PPID   DefCityID;
	PPID   SrchRegTypeID;
	long   Flags;
};
//
//
//
class PPSCardImpExpParam : public PPImpExpParam {
public:
	PPSCardImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	SString DefSeriesSymb;
	SString OwnerRegTypeCode;
};
//
//
//
class PPCliBnkImpExpParam : public PPImpExpParam {
public:
	PPCliBnkImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	int    DefPayerByAmtSign; // Если !0, то плательщик определяется по знаку суммы операции.
	SString BnkCode;          // Код банка, с которым происходит взаимодействие.
	SString PaymMethodTransl; // Трансляция вида платежа из Papyrus в client bank
};
//
//
//
class PPLotImpExpParam : public PPImpExpParam {
public:
	PPLotImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	long   Flags;
	PPID   UhttGoodsCodeArID;
};

class PPLotExporter {
public:
	PPLotExporter();
	~PPLotExporter();
	int    Init(const PPLotImpExpParam * pParam);
	int    Export(const LotViewItem * pItem);
private:
	PPLotImpExpParam Param;
	PPObjPerson PsnObj;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	PPUhttClient UhttCli;
	PPImpExp * P_IE;
};
//
//
// 
class PPCCheckImpExpParam : public PPImpExpParam { // @v11.8.4
public:
	PPCCheckImpExpParam(uint recId = 0, long flags = 0);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int PreprocessImportFileSpec(StringSet & rList);

	enum {
		fPrintAsseblyOrders = 0x0001 // При успешном импорте чека печатать заказы на изготовление
	};
	long   Flags;
	long   PredefFormat;      // @persistent PredefinedImpExpFormat
	PPID   PosNodeID;
	uint   CcByUuidSearchMaxDays; // @v11.8.8 Максимальное количество дней назад от текущей даты для поиска чека по UUID. default=30
};

class PPCCheckImporter { // @v11.8.4
public:
	PPCCheckImporter();
	~PPCCheckImporter();
	int    Init(const PPCCheckImpExpParam * pParam, bool nonInteractive);
	int    Run();
	int    Select(PPCCheckImpExpParam * pParam, int isImport, bool nonInteractive);
	int    SerializeParam(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    LoadConfig(int isImport);
private:
	int    Read_Predef_Contract01(xmlParserCtxt * pCtx, const SString & rFileName, CCheckPacket & rPack);
	SString CfgName;
	PPCCheckImpExpParam Param;
	PPObjGoods GObj;
	PPObjCashNode CnObj;
	PPObjCSession CsObj;
	PPLogger Logger;
};
//
// Descr: Базовый класс для реализации механизмов экспорта/импорта в форматах, предопределенных
//   государственными органами России.
//
class DocNalogRu_Base {
public:
	struct FileInfo {
		FileInfo();
		FileInfo & Z();
		bool   ParseFileName(const char * pFileName, bool nonStrict);
		PPID   SenderPersonID;
		PPID   ReceiverPersonID;
		PPID   ProviderPersonID;
		LDATETIME CurDtm; // Текущее время. Так как дебильные форматы NALOG.RU требуют текущие время и дату в самых разных
			// и неожиданных местах в целях избежания противоречивости сформируем один раз это значение для использования везде.
		enum {
			fVatFree             = 0x0001,
			fIndepFormatProvider = 0x0002  // @v11.9.5 Если формат является независимой кастомизацией "по мотивам" nalog.ru, то устанавливается этот флаг
		};
		long   Flags;
		S_GUID Uuid;
		SString FormatPrefix;
		SString SenderIdent;
		SString ReceiverIdent;
		SString ProviderIdent;
		SString ProviderName;
		SString ProviderINN;
		SString FileId;
		SString FileName;
		SString FileFormatVer; // ВерсФорм
		SString ProgVer;       // ВерсПрог
		SString Indep_Format;  // @v11.9.5 fIndepFormatProvider Наименование формата файла (для независимых провайдеров)
		SString Indep_Name;    // @v11.9.5 fIndepFormatProvider Наименование документа (похоже по структуре на имя файла, но почему то отличается) (для независимых провайдеров) 
		SString EdiProviderSymb;  // @v12.0.0 Символ EDI-провайдера. Требутся для того, чтобы видоизменять экспортируемые форматы в соответствии с нюансами, заваемыми провайдером.
			// Допустимые символы  провайдеров перечислены в начале класса PPEdiProcessor.
	};
	struct Address {
		Address();
		int   CountryCode; // @v11.9.5
		int   RuRegionCode;
		SString ZIP;
		SString Destrict; // Район
		SString City;
		SString Street;
		SString House; // Дом
		SString HouseCorp; // Корпус
		SString Apart; // Квартира
		SString FreeFromText; // @v11.9.5 Просто строка адреса в произвольном формате
	};
	struct BankAccount {
		SString Account;
		SString BankName;
		SString BIC;
	};
	struct FIO {
		SString Surname;
		SString Name;
		SString Patronymic;
	};
	struct Participant {
		Participant();
		int   PartyQ; // EDIPARTYQ_XXX
		PPID  PersonID; // ->Person.ID
		PPID  LocID;    // ->Location.ID
		int   JrStatus; // @v12.1.10 PPPRS_XXX
		SString GLN;
		SString OKPO;
		SString INN;
		SString KPP;
		SString Appellation;
		SString Name_;
		SString Surname;
		SString Patronymic;
		SString Phone; // @v12.1.10
		SString EMail; // @v12.1.10
		Address Addr;
		BankAccount BA;
	};
	struct GoodsItem {
		GoodsItem();
		int   RowN;
		SString GoodsName;
		SString SupplCode; // @v11.9.5 Код товара у поставщика
		SString BuyerCode; // @v11.9.5 Код товара у покупателя //
		SString GTIN; // Штрихкод товара (EAN/UPC)
		SString NonEAN_Code; // @v11.5.3 Код товара, не являющийся EAN или UPC-кодом. Пытаемся идентифицировать товар по нему как коду по статье
		SString OKEI;
		SString UOM;
		double Qtty;
		double Price;
		double PriceWoVat;
		double PriceSum;
		double PriceSumWoVat;
		double VatRate;
		StringSet MarkList;
	};
	struct DocumentInfo {
		enum {
			fIndepFormatProvider = 0x0002  // @v11.9.9 Если формат является независимой кастомизацией "по мотивам" nalog.ru, то устанавливается этот флаг
				// note: Значение флага должно совпадать с аналогичным флагом FileInfo::fIndepFormatProvider
		};
		DocumentInfo();
		DocumentInfo(const DocumentInfo & rS);
		DocumentInfo & FASTCALL operator = (const DocumentInfo & rS);
		Participant * GetParticipant(int partQ, bool createIfNExists);
		bool   FASTCALL Copy(const DocumentInfo & rS);

		long   Flags;       // @v11.9.9 @flags
		int    EdiOp;       // @v11.9.5 В случае, если формат используется для EDI, то это - тип EDI-операции 
		SString KND;        // КНД
		SString Function;   // Функция
		LDATE  Dt;          // Дата документа (накладной)
		LDATETIME DueDtm;   // @v11.9.5 Для заказов
		SString Code;       // Номер документа (накладной)
		LDATE  InvcDate;    // Дата счет-фактуры
		SString InvcCode;   // Номер счет-фактуры
		SString Subj;       // PPHSC_RU_NAMEECSUBJCOMP(НаимЭконСубСост)
		SString SubjReason; // PPHSC_RU_REASONECSUBJCOMP(ОснДоверОргСост)
		SString NameOfDoc;  // "НаимДокОпр"
		SString NameOfDoc2; // "ПоФактХЖ"
		TSCollection <Participant> ParticipantList;
		TSCollection <GoodsItem> GoodsItemList;
		//
		SString ConsigneeDivCode; // @v12.0.3 Код подразделения грузополучателя. Приватный код подразделения, передаваемый в виде расширения. Иногда используется для идентификации точки доставки.
		SString ConsigneeDivName; // @v12.0.3 Наименования подразделения грузополучателя. Приватное имя подразделения, передаваемое в виде расширения. Иногда используется для идентификации точки доставки.
	};
	DocNalogRu_Base();
	const  SString & FASTCALL GetToken_Utf8(long tokId);
protected:
	SString & FASTCALL Helper_GetToken(long tokId);
	TokenSymbHashTable TsHt;
};

class DocNalogRu_Reader : public DocNalogRu_Base {
public:
	DocNalogRu_Reader();
	int    ReadSingleXmlFile(const char * pFileName, FileInfo & rHeader, TSCollection <DocumentInfo> & rDocList);
	int    CreateParticipant(const Participant & rP, PPID personKindID, PPID * pPsnID, int use_ta);
private:
	// Читает атрибуты тега <??? Идентиф="key" Значен="val"/>
	int    ReadExtraValue(const xmlNode * pNode, SString & rKey, SString & rVal);
	int    ReadAddress(const xmlNode * pNode, Address & rResult);
	int    ReadFIO(const xmlNode * pNode, FIO & rResult);
	int    ReadParticipant(const xmlNode * pNode, Participant & rResult);
	bool   GetAttr(const xmlNode * pN, long tokId, SString & rText);
};

class DocNalogRu_Generator : public DocNalogRu_Base {
public:
	struct File {
		File(DocNalogRu_Generator & rG, const FileInfo & rHi);
		SXml::WNode N;
	};
	struct Document {
		Document(DocNalogRu_Generator & rG, const DocumentInfo & rInfo);
		SXml::WNode N;
	};
	struct Invoice {
		//
		// ARG(correction IN): Если true, то формирование документа будет в варианте корректирующей счет-фактуры. 
		//   В этой схеме отличаются некоторые теги.
		//
		Invoice(DocNalogRu_Generator & rG, const PPBillPacket & rBp, bool correction = false);
		SXml::WNode N;
		const bool IsCorrection;
	};
	DocNalogRu_Generator();
	~DocNalogRu_Generator();
	//
	// ARG(senderID IN): Ид персоналии-отправителя //
	// ARG(rcvrID IN): Ид персоналии-получателя //
	// ARG(providerID IN): Ид персоналии провайдера обмена данными (не путать с объектом провайдер EDI, который, впрочем, может ссылаться на персоналию-провайдера)
	//
	int    CreateHeaderInfo(const char * pFormatPrefix, PPID senderID, PPID rcvrID, PPID providerID, const char * pBaseFileName, FileInfo & rInfo);
	int    MakeOutFileIdent(FileInfo & rHi);
	int    MakeOutFileName(const char * pFileIdent, SString & rFileName);
	int    StartDocument(const char * pFileName, SCodepage cp);
	int    StartDocument(xmlTextWriter * pOuterWriter, SCodepage cp); // @v11.9.9
	void   EndDocument();
	//
	// ARG(correction IN): Если true, то формирование строк документа будет в варианте корректирующей счет-фактуры. 
	//   В этой схеме отличаются некоторые теги.
	//
	int    WriteInvoiceItems(const PPBillImpExpParam & rParam, const FileInfo & rHi, const PPBillPacket & rBp, bool correction = false);
	int    WriteAddress(const PPLocationPacket & rP, int regionCode, int hdrTag /*PPHSC_RU_ADDRESS||PPHSC_RU_ORGADDR*/);
	//
	// Descr: Специализированная функция, реализующая запись адреса в формате EDI SBIS
	//
	int    WriteAddress_SBIS(const PPLocationPacket & rP, int regionCode, int hdrTag /*PPHSC_RU_ADDRESS||PPHSC_RU_ORGADDR*/);
	// 
	// Descr: Флаги функции WriteOrgInfo
	//
	enum {
		woifAddrLoc_KppOnly = 0x0001 // Адрес addrLocID использовать только для извлечения КПП
	};
	int    WriteOrgInfo(const char * pScopeXmlTag, PPID personID, PPID addrLocID, LDATE actualDate, long flags);
	int    WriteOrgInfo_VatLedger(const char * pScopeXmlTag, PPID personID, PPID addrLocID, LDATE actualDate, long flags);
	//
	// Descr: Записывает тип "УчастникТип"
	//
	int    WriteParticipant(const char * pHeaderTag, PPID personID, PPID dlvrLocID);
	//
	// Descr: Разбивает строку pName на фамилию/имя/отчество и записывает их тегами либо атрибутами
	//   в зависимости от параметра asTags внутри тега с именем, определямемым идентификатором parentTokId.
	//   Если parentTokId == 0, то применяется тег с идентификатором PPHSC_RU_FIO.
	//
	int    WriteFIO(const char * pName, long parentTokId, bool asTags);
	int    WriteDocRequisites(const PPBillPacket & rBp); // @v12.2.12
	int    Underwriter(PPID psnID);
	int    GetAgreementParams(/*PPID arID*/const PPBillPacket & rBillPack, SString & rAgtCode, LDATE & rAgtDate, LDATE & rAgtExpiry);
	const  SString & FASTCALL EncText(const SString & rS);
	const  SString & FASTCALL GetToken_Ansi(long tokId);
	//
	// Descr: Возвращает токен поля с префиксом П0 и последующим номером 10-значным n, набитым слева нулями.
	//
	const  SString & FASTCALL GetToken_Ansi_Pe0(long n);
	//
	// Descr: Возвращает токен поля с префиксом П1 и последующим номером 10-значным n, набитым слева нулями.
	//
	const  SString & FASTCALL GetToken_Ansi_Pe1(long n);
	SVerT  SetupOutputFormatVer(SVerT v); // @v12.2.12
	SVerT  GetOutputFormatVer() const { return OutputFormatVer; } // @v12.2.12
	bool   IsVer503() const { return OutputFormatVer.IsGe(5, 3, 0); } // @v12.2.12
	//
	void   SetDocumentInfo(const DocumentInfo & rS)
	{
		Di.Copy(rS);
	}
//private:
	PPObjGoods GObj;
	PPObjPerson PsnObj;
	PPObjArticle ArObj;
	SXml::WDoc * P_Doc;
	xmlTextWriter * P_X;
private:
	void   WriteExcise(SXml::WNode & rParentNode, double value);
	int    WriteWareInfoAddendum(const PPBillImpExpParam & rParam, const PPBillPacket & rBp, uint itemIdx, 
		const SString & rGoodsCode, const SString & rBarcodeForMarking, bool correction); // @v12.2.12
	//
	// Descr: Извлекает из базы данных идентификатор участника документооборота.
	//   Сложность в том, что этот идентификатор может быть задан либо в виде тега персоналии (PPTAG_PERSON_ENALOGID),
	//   либо (начиная с @v12.0.0) в виде регистра (зарезервированный тип PPREGT_ENALOGID). При этом регистр может быть 
	//   ассоциирован с персоналией-оператором обмена данными.
	//   Алгоритм функции таков:
	//   -- сначала ищет регистр персоналии типа PPREGT_ENALOGID с организацией-эмитентом равной dtoPersonID
	//   -- если не предыдущий пункт неудачный, то ищет регистр того же типа, но с нулевой организацией-эмитентом 
	//   -- если не предыдущий пункт неудачный, то ищет тег PPTAG_PERSON_ENALOGID 
	// Returns:
	//    0 - ошибка
	//   <0 - идентификатор не найден 
	//    1 - идентификатор найден в регистре с точным соответствием по организации-эмитенту
	//    2 - идентификатор найден в регистре, для которого не определен эмитент (dtoPersonID != 0)
	//    3 - идентификатор найден в регистре с явно заданным эмитентом, не совпадающим с dtoPersonID
	//    4 - идентификатор найден в теге
	//
	int    GetIdentifier(PPID psnID, PPID dtoPersonID, SString & rBuf);
	enum {
		fExpChZnMarksGTINSER = 0x0001,
		fExpPlainAddr        = 0x0002 // @v11.5.11 see pp.ini [config] ExpNalogRuPlainAddr
	};
	uint   Flags;
	enum {
		stOuterXmlTextWriter = 0x0001 
	};
	uint   State; // @v11.9.9
	SCodepage Cp; // @v11.9.9
	SVerT  DefOutputFormatVer; // @v12.2.12 Версия формата nalog.ru для формирования документов. Извлекается из
		// параметра pp.ini [config] expnalogrudefver.
	SVerT  OutputFormatVer; // @v12.2.12 Версия формата nalog.ru для формирования документов. Поле введено из-за того, что
		// в 2025 году меняется формат с 5.01 на 5.03 со значительным набором изменений в тегах.
	SString EncBuf;
	DocumentInfo Di; // @v12.3.0 Копия заголовочной информации о документе, передаваемая сюда конструктором Document::Document
};

class DocNalogRu_WriteBillBlock {
public:
	DocNalogRu_WriteBillBlock(const PPBillImpExpParam & rParam, const PPBillPacket & rBp, const char * pHeaderSymb, const SString & rFileName);
	~DocNalogRu_WriteBillBlock();
	const  bool IsValid() const { return !(State & stError); }
	const  SString & FASTCALL GetToken(long tokId);
	const  SString & FASTCALL EncText(const SString & rS);
	int    Do_Invoice(SString & rResultFileName);
	int    Do_Invoice2(SString & rResultFileName);
	int    Do_CorrInvoice(SString & rResultFileName);
	int    Do_UPD(SString & rResultFileName);
	int    Do_DP_REZRUISP(SString & rResultFileName);

	enum {
		stError                 = 0x0001, // В конструкторе возникла ошибка
		stAgreementParamIsValid = 0x0002  // Получение параметров клиентского соглашение (G.GetAgreementParams) завершилось успешно
	};
	uint   State;
	const  PPBillImpExpParam & R_P;
	const  PPBillPacket & R_Bp;

	PPObjAccSheet AcsObj;
	PPOprKind OpRec;
	PPOprKind LinkOpRec;
	PPID   DtoPersonID;  // PPOBJ_PERSON Провайдер обмена данными
	PPID   MainOrgID;    // PPOBJ_PERSON
	PPID   ContragentID; // PPOBJ_PERSON
	SString AgtCode;
	LDATE  AgtDate;
	LDATE  AgtExpiry;
	const  SString & R_NominalFileName;
	SString HeaderSymb;
	DocNalogRu_Generator::FileInfo _Hi;
	DocNalogRu_Generator G;
};
//
//
//
class PPBillImpExpParam : public PPImpExpParam {
public:
	enum {
		fImpRowsFromSameFile  = 0x0001,
		fImpExpRowsOnly       = 0x0002, // Импортировать/экспортировать только файл строк
		//fSignBill = 0x0002
		fRestrictByMatrix     = 0x0004, //
		fExpOneByOne          = 0x0008, // Экспортировать документы по-одному в каждом файле
		fCreateAbsenceGoods   = 0x0010, // Создавать отсутствующие товары (если возможно)
		fDontIdentGoodsByName = 0x0020, // При идентификации товаров
		fChZnMarkAsCDATA      = 0x0040, // @v11.5.0 Для xml-форматов при экспорте марок чезнак обрамлять значения в конструкцию CDATA
		fChZnMarkGTINSER      = 0x0080, // @v11.5.0 Марки чезнак экспортировать в виде GTIN-SERIAL, в противном случае - полную марку
		fUseExtGoodsName      = 0x0100, // @v11.7.12 При экспорте использовать расширенные наименования товаров (если определены)
	};
	
	static int ParseText(const char * pText, const char * pTemplate, PPImpExpParam::PtTokenList & rResultList, SString * pFileTemplate);
	explicit PPBillImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int MakeExportFileName(const void * extraPtr, SString & rResult) const;
	virtual int PreprocessImportFileSpec(StringSet & rList);
	virtual int PreprocessImportFileName(const SString & rFileName, /*StrAssocArray*/PPImpExpParam::PtTokenList & rResultList);

	long   Flags;             // @persistent
	PPID   ImpOpID;           // @persistent
	long   PredefFormat;      // @persistent PredefinedImpExpFormat
	PPID   FixTagID;          // @v11.5.6 @persistent Тег, фиксирующий факт экспорта документа. Если в документе такой тег установлен, то документ снова не экспортируется.
	PPID   DtoPersonID;       // @v11.9.12 Ид персоналии оператора передачи данных. Введен ради использования в EDI. В ini-файле не сохраняется и не читается из него!
	SString Object1SrchCode;  // @persistent
	SString Object2SrchCode;  // @persistent
	SString OuterFormatVer;   // @v11.6.5 @persistent Номер формата внешних данных. Если пусто, то применяется программно предопределенное значение.
	SString EdiProviderSymb;  // @v11.9.12 Символ EDI-провайдера. Требутся для того, чтобы видоизменять экспортируемые форматы в соответствии с нюансами, заваемыми провайдером.
		// Допустимые символы  провайдеров перечислены в начале класса PPEdiProcessor.
};
//
// Экспорт/импорт инвентаризации
//
//
// Импорт инвентаризации
//
class PPInventoryImpExpParam : public PPImpExpParam {
public:
	explicit PPInventoryImpExpParam(uint recId = 0, long flags = 0);
};
//
// Descr: Вспомогательная стурктура, используемая в специализиованных
//   модулях экспорта документов (ЕГАИС, EDI)
//
struct PPBillIterchangeFilt {
	PPBillIterchangeFilt();

	PPID   LocID;
	DateRange Period;
	PPIDArray IdList;
};

class PPBillImpExpBaseProcessBlock {
public:
	enum {
		fUhttImport     = 0x0001,  // Импорт документов из Universe-HTT
		fSignExport     = 0x0002,  // Подписывать исходящие файлы электронной подписью
		fEdiImpExp      = 0x0004,  // Импорт/экспорт документов через EDI
		fCreateCc       = 0x0008,  // При создании документа одновременно создавать чек заказа
		fDisableLogger  = 0x0010,  // Не выводить сообщения в окно журнала
		fEgaisImpExp    = 0x0020,  // Обмен данными с ЕГАИС
		fTestMode       = 0x0040,  //
		fDontRemoveTags = 0x0080,  // Для EDI и ЕГАИС - не снимать теги при получении отрицательных тикетов
		fPaymOrdersExp  = 0x0100,  // Экспорт платежных поручений
		fEgaisVer3      = 0x0200,  // Передача документов в ЕГАИС в 3-й версии (возможность переопределить конфигурацию глобального обмена)
		fFullEdiProcess = 0x0400,  // Полный цикл EDI-обмена данными с контрагентами
		fChZnImpExp     = 0x0800,  // Обмен данными с честным знаком
		fEgaisVer4      = 0x1000,  // @v11.0.12 Передача документов в ЕГАИС в 4-й версии (возможность переопределить конфигурацию глобального обмена)
	};
	struct TransmitParam {
		TransmitParam();
		TransmitParam & Z();

        PPID   InetAccID;
		StrAssocArray AddrList;
		SString Subject;
	};
	struct SearchBlock {
		SearchBlock();

		LDATE  Dt;
		int    SurveyDays; // Количество дней назад от текущей даты для поиска документа
		SString Code;
		SString DlvrLocCode;
	};
	PPBillImpExpBaseProcessBlock();
	PPBillImpExpBaseProcessBlock & Z();
	int    Select(int import);
	int    SerializeParam(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SearchEdiOrder(const SearchBlock & rBlk, BillTbl::Rec * pOrderRec);
	PPID   GetFixTagID(PPObjectTag * pTagRec);
	bool   SkipExportBillBecauseFixTag(PPID billID);
	int    SetFixTagOnExportedBill(const PPIDArray & rBillIdList, int use_ta);
	int    SetFixTagOnImportedBill(PPID billID, int use_ta);

	long   Flags;
	long   DisabledOptions; // @transient
	PPID   OpID;
	PPID   LocID;
	PPID   PosNodeID;
	PPID   GuaID;        // Глобальная учетная запись
	DateRange Period;    // Период за который следует импортировать документы
	PPBillImpExpParam BillParam;
	PPBillImpExpParam BRowParam;
	SString CfgNameBill;
	SString CfgNameBRow;
	TransmitParam Tp;
	PPObjBill * P_BObj;
	PPObjLocation LocObj;
	PPObjPerson PsnObj;
	PPObjQCert  QcObj;
	PPObjArticle ArObj;
	PPObjGoods  GObj;
	PPObjTag TagObj;
};

class PPBillExporter : public PPBillImpExpBaseProcessBlock {
public:
	PPBillExporter();
	~PPBillExporter();
	void   Destroy();
	int    Init(const PPBillImpExpParam * pBillParam, const PPBillImpExpParam * pBRowParam, const PPBillPacket * pFirstPack, StringSet * pResultFileList);
	int    PutPacket(PPBillPacket * pPack, int sessId = 0, ImpExpDll * pImpExpDll = 0);
	int    SignBill(); // @vmiller
	int    CheckBillsWasExported(ImpExpDll * pExpDll); // @vmiller // Получает от dll список успешно экспортированных документов и ставит в них соответствующую пометку
	PPImpExp * GetIEBill() const { return P_IEBill; }
	PPImpExp * GetIEBRow() const { return P_IEBRow; }
private:
	int    BillRecToBill(const PPBillPacket * pPack, Sdr_Bill * pBill);
	int    GetInn(PPID arID, SString & rINN);
	int    GetReg(PPID arID, PPID regTypeID, SString & rRegNum);

	PPImpExp * P_IEBill;
	PPImpExp * P_IEBRow;
	PPObjPersonKind PsnKObj;
};

typedef TSVector <Sdr_BRow> SdrBillRowArray;
typedef TSVector <Sdr_Bill> SdrBillArray;

class PPBillImporter : public PPBillImpExpBaseProcessBlock {
public:
	PPBillImporter();
	~PPBillImporter();
	void   Init();
	int    Init(const PPBillImpExpParam * pBillParam, const PPBillImpExpParam * pBRowParam, PPID opID, PPID locID);
	//
	// Descr: Функция не интерактивно инициализирует импорт с Universe-HTT
	//
	int    InitUhttImport(PPID opID, PPID locID, PPID posNodeID);
	int    LoadConfig(int import);
	int    Run();
	// @vmiller {
	enum {
		statNoSuchDoc = 0,  // Такого документа нет
		statIsSuchDoc = 1 	// Есть такой документ
	};
	// } @vmiller
private:
	int    ResolveINN(const char * pINN, PPID dlvrLocID, const char * pDlvrLocCode,
		const char * pBillId, PPID accSheetID, PPID * pArID, int logErr = 1);
	int	   ResolveGLN(const char * pGLN, /*const char * pLocCode,*/const char * pBillId, PPID accSheetID, PPID * pArId, int logErr = 1); // @vmiller
	int    ResolveUnitPerPack(PPID goodsID, PPID locID, LDATE dt, double * pUpp);
	int    CheckBill(const Sdr_Bill * pBill);
	int    AddBillToList(Sdr_Bill * pBill, long extraBillId);
	int    BillToBillRec(const Sdr_Bill * pBill, PPBillPacket * pPack);
	int    AddBRow(Sdr_BRow & rRow, uint * pRowId);
	const  Sdr_Bill * SearchBillForRow(const SString & rBillIdent, const Sdr_BRow & rRow) const;
	int    SearchNextRowForBill(const Sdr_Bill & rBill, const LongArray * pSeenPosList, uint * pPos) const;
	int    GatherRowsForSameTransferItem(const Sdr_Bill & rBill, uint thisPos, const LongArray & rSeenPosList, LongArray & rResultPosList) const;
	//
	// Descr: Считывает из исходного файла строки документов.
	// ARG(pImpExp IN): Блок параметров импорта
	// ARG(mode    IN): режим считывания
	//   0 - обычный режим
	//   1 - привязка строк к последнему считанному из файла заголовков документу
	//   2 - режим считывания строк без предварителного считываения заголовков документов (вся информация о документах хранится в файле строк)
	//
	int    ReadRows(PPImpExp * pImpExp, int mode/*linkByLastInsBill*/, const PPImpExpParam::PtTokenList * pFnFldList);
	int    ReadSpecXmlData();
	int    Helper_EnsurePersonArticle(PPID psnID, PPID accSheetID, PPID psnKindID, PPID * pArID); // @wota
	//
	// Descr: Вспомогательная функция акцепта импортируемых заказов по предопределенному формату piefCokeOrder
	//
	int    Helper_AcceptCokeData(const SCollection * pRowList, PPID opID, PPID supplArID);
	int    ReadData();
	int    ReadDataDll(const PPEdiProviderPacket * pEp);
	int    Import(int useTa);
	int    RunUhttImport();
	int	   GetDocImpStatus(Sdr_Bill * pBill, Sdr_DllImpObjStatus & rStatus); // @vmiller
	int    AssignFnFieldToRecord(const /*StrAssocArray*/PPImpExpParam::PtTokenList & rFldList, Sdr_Bill * pRecHdr, Sdr_BRow * pRecRow);
	int    ProcessDynField(const SdRecord & rDynRec, uint dynFldN, PPImpExpParam & rIep, ObjTagList & rBillTagList, ObjTagList & rRowTagList);
	int    DoFullEdiProcess();
	int    CreateAbsenceGoods(ResolveGoodsItem & rRgi, int use_ta);
	int    ReadTagItem(const char * pTagSymb, const SdRecord & rDynRec, uint dynFldN, PPID tagsObjType, ObjTagItem * pTagItem);

	PPID   AccSheetID;
	long   LineIdSeq;
	PPLogger Logger;
	SdrBillArray Bills;
	SdrBillRowArray BillsRows;
	CCheckCore * P_Cc;
	BillTransmDeficit * P_Btd;
	StringSet ToRemoveFiles;
	PPLotTagContainer TagC;
	PPLotTagContainer BillTagC; // @v12.2.1 Теги документов, полученные из строк 
};
//
//
//
class ClientBankExportDef {
public:
	//
	// Descr: @constructor
	// ARG(pPeriod IN): Период, которому принадлежат 'кспортируемые платежные поручения.
	//
	ClientBankExportDef(const DateRange * pPeriod);
	~ClientBankExportDef();
	PPImpExpParam & GetParam() const;
	int    ReadDefinition(const char * pIniSection);
	int    CreateOutputFile(StringSet * pResultFileList);
	int    CloseOutputFile();
	int    PutRecord(const PPBillPacket *, PPID debtBillID, PPLogger * pLogger);
	int    GetStat(long * pAcceptedCount, long * pRejectedCount, double * pAmount);
	int    PutHeader();
	int    PutEnd();
private:
	//int    UseImpSection; // (testing purpose) Использовать описание импорта
	void * P_Helper;
};

class ClientBankImportDef {
public:
	static int WriteAssocList(const SVector * pList, int use_ta);
	static int ReadAssocList(SVector * pList);

	ClientBankImportDef();
	~ClientBankImportDef();
	PPImpExpParam & GetParam() const;
	int    ReadDefinition(const char * pIniSection);
	int    ImportAll();
private:
	void * P_Helper;
};
//
// Descr: Общий диалог редактирования параметров импорта/экспорта.
//   Другие диалоги могут наследовать упарвляющие элементы и поведение этого диалога.
//
class ImpExpParamDialog : public TDialog {
	DECL_DIALOG_DATA(PPImpExpParam);
public:
	enum {
		fDisableImport = 0x0001,
		fDisableExport = 0x0002,
		fDisableName   = 0x0004
	};
	explicit ImpExpParamDialog(uint dlgID, long options = 0);
	int    setDTS(const PPImpExpParam *);
	int    getDTS(PPImpExpParam *);
protected:
	DECL_HANDLE_EVENT;
	long   Flags;
	int    EnableExcelImpExp;
};
//
// Descr: Общий диалог редактирования списка параметров импорта/эскпорта.
//  Другие диалоги могут наследовать управляющие элементы и поведение этого диалога.
//
class ImpExpCfgListDialog : public PPListDialog {
public:
	ImpExpCfgListDialog();
	ImpExpCfgListDialog(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pDlg);
	int    SetParams(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pDlg);
private:
	virtual int  setupList();
	virtual int  addItem(long * pPos, long * pID);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	virtual int  EditParam(const char *);

	uint   IniFileID;
	uint   SDRecID;
	StringSet Sections;
	PPImpExpParam * P_Param;
	ImpExpParamDialog * P_ParamDlg;
};
//
//
//
class GoodsImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPGoodsImpExpParam);
public:
	GoodsImpExpDialog();
	int    setDTS(const PPGoodsImpExpParam * pData);
	int    getDTS(PPGoodsImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);
};
//
//
//
class QuotImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPQuotImpExpParam);
public:
	QuotImpExpDialog();
	int    setDTS(const PPQuotImpExpParam * pData);
	int    getDTS(PPQuotImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);

	const PPObjQuotKind::Special QkSpc; // @v11.4.2
	PPObjQuotKind QkObj; // @v11.4.2
};
//
//
//
class PersonImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPPersonImpExpParam);
public:
	PersonImpExpDialog();
	int    setDTS(const PPPersonImpExpParam * pData);
	int    getDTS(PPPersonImpExpParam * pData);
};
//
//
//
class PhoneListImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPPhoneListImpExpParam);
public:
	PhoneListImpExpDialog();
	int    setDTS(const PPPhoneListImpExpParam * pData);
	int    getDTS(PPPhoneListImpExpParam * pData);
};
//
//
//
class SCardImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPSCardImpExpParam);
public:
	SCardImpExpDialog();
	int    setDTS(const PPSCardImpExpParam * pData);
	int    getDTS(PPSCardImpExpParam * pData);
};
//
//
//
class LotImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPLotImpExpParam);
public:
	LotImpExpDialog();
	int    setDTS(const PPLotImpExpParam * pData);
	int    getDTS(PPLotImpExpParam * pData);
};
//
//
//
class BillHdrImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPBillImpExpParam);
public:
	BillHdrImpExpDialog();
	int    setDTS(const PPBillImpExpParam * pData);
	int    getDTS(PPBillImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);
};

class CCheckImpExpDialog : public ImpExpParamDialog {
	DECL_DIALOG_DATA(PPCCheckImpExpParam);
public:
	CCheckImpExpDialog();
	int    setDTS(const PPCCheckImpExpParam * pData);
	int    getDTS(PPCCheckImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);
};
//
//
//
class PPEdiProcessor {
	// Символы провайдеров:
	// KONTUR 
	// KONTUR-T
	// EXITE
	// SBIS
public:
	struct RecadvPacket {
		RecadvPacket();

		//PPBillPacket Bp; // При чтении - RECADV, при отправке DESADV
		PPBillPacket ABp; // Пакет оригинального DESADV
		PPBillPacket RBp; // Собственно, пакет RECADV
		SString DesadvBillCode;
		LDATE   DesadvBillDate;
		int     AllRowsAccepted;
		PPID    WrOffBillID; // Ид документа списания (если Bp - драфт-документ, как и должно быть в большинстве случаев)
		PPID    OrderBillID; // Ид документа заказа, на основании которого был сформирован DESADV, которому соответствует данный RECADV
		RAssocArray DesadvQttyList; // Отгруженные количества, ассоциированные с индексом строки (1..) в документе this->Bp
		RAssocArray RecadvQttyList; // Принятые количества, ассоциированные с индексом строки (1..) в документе this->Bp
		//
		// Заказанные количества, ассоциированные с индексом строки (1..) в документе DESADV.
		// Так как при отправке RECADV однозначно сопоставить строку заказа со строкой DESADV (теоретически) можеть быть сложно,
		// то при возникновении неоднозначностей модуль распределяет такие значения пропорционально.
		//
		RAssocArray OrderedQttyList;
	};
	struct Packet {
		explicit Packet(int docType);
		~Packet();
		//
		// PPEDIOP_ORDER:
		//   P_Data - (PPBillPacket *)
		//   P_ExtData - 0
		// PPEDIOP_ORDERRSP
		//   При отправке:
		//     P_Data - (PPBillPacket *) пакет текущего заказа
		//     P_ExtData - (PPBillPacket *) пакет оригинального заказа (при создании)
		//   При получении:
		//     P_Data - (PPBillPacket *) пакет подтвержденного заказа
		//     P_ExtData - (PPBillPacket *) пакет оригинального заказа (отправленного поставщику)
		//
		void * P_Data;
		void * P_ExtData;
		const  int  DocType;
		long   Flags;
	};
	struct DocumentInfo {
		DocumentInfo();
		enum {
			statusUnkn = 0,
			statusNew  = 1
		};
		int    ID;          // Идентификатор сообщения, инициализируемый дравером конкретного провайдера (не зависимо от провайдера)
		int    EdiOp;       // Тип EDI-операции
		LDATETIME Time;     // Время создания/модификации сообщения
		S_GUID Uuid;        // GUID сообщения
		long   Status;      // DocumentInfo::statusXXX
		long   Flags;       // Флаги
		long   PrvFlags;    // Флаги, специфичные для конкретного провайдера
		SString Code;       // Код сообщения (номер документа)
		SString SenderCode; // Код отправителя
		SString RcvrCode;   // Код получателя
		SString Box;        // Если хранение сообщений дифференцировано по боксам, то здесь может быть имя бокса для сообщения
		SString SId;        // Символьный идентификатор (может быть именем файла)
	};
	class DocumentInfoList : private SStrGroup {
	public:
		DocumentInfoList();
		uint   GetCount() const;
		int    GetByIdx(uint idx, DocumentInfo & rItem) const;
		int    Add(const DocumentInfo & rItem, uint * pIdx);
	private:
		struct Entry {
			int    ID;
			int    EdiOp;
			LDATETIME Dtm;
			S_GUID Uuid;
			long   Status;
			long   Flags;
			long   PrvFlags;
			uint   CodeP;
			uint   SenderCodeP;
			uint   RcvrCodeP;
			uint   BoxP;
			uint   SIdP;
		};
		TSVector <Entry> L;
	};
	class ProviderImplementation {
	public:
		enum {
			ctrfTestMode = 0x0001
		};
		ProviderImplementation(const PPEdiProviderPacket & rEpp, PPID mainOrgID, long flags, PPLogger * pLogger);
		virtual ~ProviderImplementation();
		virtual int    GetDocumentList(const PPBillIterchangeFilt & rP, DocumentInfoList & rList) { return -1; }
		virtual int    ReceiveDocument(const PPEdiProcessor::DocumentInfo * pIdent, TSCollection <PPEdiProcessor::Packet> & rList) { return -1; }
		virtual int    SendDocument(DocumentInfo * pIdent, PPEdiProcessor::Packet & rPack) { return -1; }
		int    GetTempOutputPath(int docType, SString & rBuf);
		int    GetTempInputPath(int docType, SString & rBuf);
		int    GetPersonGLN(PPID psnID, SString & rGLN);
		int    GetArticleGLN(PPID arID, SString & rGLN);
		int    GetMainOrgGLN(SString & rGLN);
		int    GetLocGLN(PPID locID, SString & rGLN);
		int    GetGoodsInfo(PPID goodsID, PPID arID, Goods2Tbl::Rec * pRec, SString & rGtin, SString & rArCode);
		int    ValidateGLN(const SString & rGLN);
		int    GetOriginOrderBill(const PPBillPacket & rBp, BillTbl::Rec * pOrdBillRec);
		int    SearchLinkedBill(const char * pCode, LDATE dt, PPID arID, int ediOp, BillTbl::Rec * pBillRec);
		int    SearchLinkedOrder(const char * pCode, LDATE dt, PPID arID, BillTbl::Rec * pBillRec, PPBillPacket * pPack);
		int    ResolveDlvrLoc(const char * pText, PPBillPacket * pPack);
		int    ResolveContractor(const char * pText, int partyQ, PPBillPacket * pPack);

		PPEdiProviderPacket Epp;
		PPID   MainOrgID;
		long   Flags;
		PPObjBill * P_BObj; // @notowned
		PPObjGoods GObj;
		PPObjPerson PsnObj;
		PPObjArticle ArObj;
		STokenRecognizer TR; // Для распознавания допустимых/недопустимых токенов
		PPAlbatrossConfig ACfg;
		PrcssrAlcReport Arp;
	protected:
		struct DeferredPositionBlock {
			DeferredPositionBlock();
			int    Init(const BillTbl::Rec * pBillRec);
			bool   SetupGoods();

			PPID   GoodsID_ByGTIN;
			PPID   GoodsID_ByArCode;
			SString ArGoodsCode;
			SString GoodsName;
			SString GTIN;
			double OrdQtty;  // заказанное количество
			double AccQtty;  // количество, принятое к исполнению
			double DlvrQtty; // Доставленное количество (DESADV)
			double PriceWithVat;
			double PriceWithoutVat;
			double Vat; // Ставка НДС в процентах
			PPTransferItem Ti;
		};

		struct OwnFormatAddress {
			OwnFormatAddress();
			OwnFormatAddress & Z();

			char   CountryCode[4]; // 2-letter code
			SString AddressText; // foreign address
			SString RegionIsoCode;
			SString District;
			SString City;       // Город
			SString Settlement; // Населенный пункт
			SString Street;
			SString House;
			SString Flat;
			SString ZIP;
		};
		struct OwnFormatContractor {
			OwnFormatContractor();
			OwnFormatContractor & Z();

			SString Name;
			SString GLN;
			SString INN;
			SString KPP;
			//
			OwnFormatAddress Addr;
		};

		const SString & FASTCALL EncXmlText(const char * pS);
		const SString & FASTCALL EncXmlText(const SString & rS);
		int16  FASTCALL StringToRByBill(const SString & rS) const;
		int    GetGTIN(const SString & rS, DeferredPositionBlock & rBlk);
		int    GetArCode(const SString & rS, int partyQ, int whoAmI, PPID billArID, DeferredPositionBlock & rBlk);
		int    ResolveDlvrLoc(const OwnFormatContractor & rC, PPBillPacket * pPack);
		int    ResolveOwnFormatContractor(const OwnFormatContractor & rC, int partyQ, PPBillPacket * pPack);
		SString EncBuf;
		PPLogger * P_Logger; // @notowned
	private:
		int    GetIntermediatePath(const char * pSub, int docType, SString & rBuf);
		int    Helper_GetPersonGLN(PPID psnID, SString & rGLN);
	};

	static int FASTCALL GetEdiMsgTypeByText(const char * pSymb);
	static ProviderImplementation * CreateProviderImplementation(PPID ediPrvID, PPID mainOrgID, long flags, PPLogger * pLogger);
	explicit PPEdiProcessor(ProviderImplementation * pImp, PPLogger * pLogger);
	~PPEdiProcessor();
	int    SendOrders(const PPBillIterchangeFilt & rP, const PPIDArray & rArList);
	int    SendOrderRsp(const PPBillIterchangeFilt & rP, const PPIDArray & rArList);
	int    SendDESADV(int ediOp, const PPBillIterchangeFilt & rP, const PPIDArray & rArList);
	int    SendRECADV(const PPBillIterchangeFilt & rP, const PPIDArray & rArList);
	int    SendDocument(DocumentInfo * pIdent, PPEdiProcessor::Packet & rPack);
	int    ReceiveDocument(const DocumentInfo * pIdent, TSCollection <PPEdiProcessor::Packet> & rList);
	int    GetDocumentList(const PPBillIterchangeFilt & rP, DocumentInfoList & rList);
private:
	int    CheckBillStatusForRecadvSending(const BillTbl::Rec & rBillRec);

	ProviderImplementation * P_Prv; // @notowned
	PPLogger * P_Logger; // @notowned
	PPObjBill * P_BObj;
	PPObjPerson PsnObj;
	PPAlbatrossConfig ACfg;
};
//
//
//
class PPEgaisProcessor : public PrcssrAlcReport, private PPEmbeddedLogger {
public:
	struct Packet {
		explicit Packet(int docType);
		~Packet();
		enum {
			fAcceptedBill = 0x0001, // В пакете содержится импортированный в базу данных документ
			fDoDelete     = 0x0002, // Документ следует удалить с сервера ЕГАИС
			fReturnBill   = 0x0004, // Пакет содержит документ возврата поставщику
			fFaultObj     = 0x0008  // Флаг идентифицирует пакет, являющийся инвалидным.
				// При позднем акцепте этого пакета, наличие флага сигнализирует, что акцептировать такой пакет не следует.
		};
		int    DocType;
		long   Flags;
		uint   SrcReplyPos; // Позиция документа-источника в таблице TSCollection <Reply> (+1)
		PPID   IntrBillID;  // Только для входящих WAYBILL - идентификатор документа внутренней передачи,
			// которому соответствует (PPBillPacket *)P_Data. Необходим для позднего акцепта, поскольку
			// данный идентификатора вычисляется на этапе обработки входящего xml-потока.
		void * P_Data;
	};
	//
	// Descr: Подтверждение от сервера ЕГАИС о получении запроса
	//
	struct Ack {
		Ack();
		PPEgaisProcessor::Ack & Z();

		enum {
			stError = 0x0001
		};
		uint   Ver;        // Версия протокола
		uint8  SignSize;   // Размер подписи
		uint8  Sign[260];  // Подпись
		S_GUID Id;         // Ид присвоенный запросу сервером
		int    Status;
		SString Url;
		SString Message;
	};
	//
	// Descr: Дескриптор ответа на запрос
	//
	struct Reply {
		Reply();
		enum {
			stError    = 0x0001,
			stAccepted = 0x0002,
			stOffline  = 0x0004, // Пакет получен не на прямую от сервера, а из каталога в файловой системе
			stDeleted  = 0x0008  // К пакету была применена операция DeleteDoc
		};
		long   Status;
		S_GUID Id;         // Ид присвоенный запросу сервером (полученный ответом на запрос - см. Ack)
        SString Url;       // Адрес сообщения с ответом
        SString AcceptedFileName; // Имя локального файла, в который получено содержимое ответа
	};
	//
	// Descr: Результат отправки данных
	//
	struct Ticket {
		Ticket();
		PPEgaisProcessor::Ticket & Z();
		struct Result {
			Result();
			PPEgaisProcessor::Ticket::Result & Z();
			enum {
				spcNone = 0,
				spcDup  = 1  // Тикет с ошибкой о том, что накладная уже загеристрирована в ЕГАИС
			};
			int    Type; // 0 - undef, 1 - ticket result, 2 - operation result
			int    Conclusion; // 0 - rejected, 1 - accepted
			int    Special;    // Специальная собственная пометка, идентифицирующая некоторый особенности тикета (определяется Papyrus'ом; это - не от ЕГАИС).
			LDATETIME Time;
			SString OpName; // OperationName
			SString Comment;
		};
        LDATETIME TicketTime;
        S_GUID DocUUID;
        S_GUID TranspUUID;
        int    DocType;
        SString RegIdent;
        Result R;   // Result
        Result OpR; // OperationResult
	};

	struct ConfirmTicket {
		ConfirmTicket();
		PPID   BillID;
		int    Conclusion; // 0 - rejected, 1 - accepted, -1 - undef
		LDATE  Date;
		SString Code;
		SString RegIdent;
		SString Comment;
	};

	struct InformAReg {
		InformAReg();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
        int    ToStr(SString & rBuf);
        int    FromStr(const SString & rBuf);

        long   Qtty;
        LDATE  ManufDate;
        LDATE  TTNDate;
        LDATE  EGAISDate;
        SString TTNCode;
        SString EGAISCode;
	};

	struct InformBItem { // @flat
		InformBItem();
		InformBItem & Z();

		long   P;
		char   OrgRowIdent[64];
		char   Ident[24];
		LDATE  BottlingDate;
	};

	struct InformB {
		InformB();
		InformB & Z();

        SString Id;
        SString WBRegId;      // ИД накладной в системе (присвоенный)
        SString FixNumber;    // Номер фиксации накладной(отгрузки) в ЕГАИС
        LDATE  FixDate;
        SString OuterCode;    // Номер накладной (у отправителя)
        LDATE  OuterDate;     // Дата накладной (у отправителя)
        PPID   ShipperPsnID;
        PPID   ConsigneePsnID;
        PPID   SupplPsnID;
        TSVector <PPEgaisProcessor::InformBItem> Items;
	};

	struct ActInformItem {
		ActInformItem();
		long   P;
		char   AIdent[24];
		TSVector <PPEgaisProcessor::InformBItem> BItems;
	};

    struct ActInform {
        SString ActRegId;
        SString ActNumber;
		TSCollection <PPEgaisProcessor::ActInformItem> Items;
    };
	//
	// Descr: Структура запроса на отмену проведения документа (грузополучатель - отправляет, грузоотправитель - получает и подтверждает)
	//
    struct RepealWb {
    	RepealWb();

        PPID   BillID;
        LDATETIME ReqTime;
        int    Confirm; // Только для подтверждения отмены проведения. 1 - подтверждаем, 0 - отклоняем
        SString ContragentCode;
        SString TTNCode;
        SString ReqNumber;
        SString Memo;
    };
    //
    // Descr: Структура запроса и ответа по штрихкоду (QueryBarcode)
    //
    struct QueryBarcode {
		QueryBarcode();

    	int    RowId;
        int    CodeType; // 103, 203
        SString Rank;
        SString Number;
        SString Result;
    };
	//
	// Descr: Структура ответа на запрос остатков марок по справке Б
	//
	struct ReplyRestBCode {
		ReplyRestBCode();

		LDATETIME RestTime;
		SString Inform2RegId;
		StringSet MarkSet;
	};
    //
    // Descr: Дескриптор сервера УТМ
    //
    struct UtmEntry { // @flat
    	UtmEntry();

    	enum {
    		fDefault = 0x0001 // Если флаг установлен, то это означает, что
				// MainOrgID является текущей главной организацией,
				// FSRARID получен из тега этой персоналии,
				// Url получен из конфигурации глобального обмена
    	};
    	PPID   MainOrgID; // Главная организация, с которой ассоциированы параметры Url и FSRARID.
    	long   Flags;
    	char   Url[128];
    	char   FSRARID[128];
    };
	//
	// Descr: Параметры функции TestEGAIS()
	//
	struct TestParam {
		enum {
			fReceiveDataToTempCatalog  = 0x0001,
			fAcceptDataFromTempCatalog = 0x0002
		};
		PPID   LocID;
		long   Flags;
	};
	//
	// Descr: Параметры запроса к серверу ЕГАИС
	//
	struct QueryParam {
		QueryParam();
		~QueryParam();
		QueryParam(const QueryParam & rS);
		QueryParam & FASTCALL operator = (const QueryParam & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			_afQueryRefA         = 0x0001,
			_afQueryPerson       = 0x0002,
			_afQueryGoods        = 0x0004,
			_afQueryByChargeOn   = 0x0008,
			_afClearInnerEgaisDb = 0x0010
		};
		long   DocType;
		long   DbActualizeFlags;
		long   Flags; // PPEgaisProcessor::stTestSendingMode
		PPID   MainOrgID;
		PPID   LocID;
		SString ParamString;
		SString InfoText; // @transient
		LotFilt * P_LotFilt; // @transient
	};
	//
	// Descr: Типы ТТН
	//
	enum {
		wbtInvcFromMe = 1, // Инвойс от меня к контрагенту
		wbtInvcToMe,       // Инвойс от контрагента ко мне
		wbtRetFromMe,      // Возврат от меня к контрагенту
		wbtRetToMe         // Возврат от контрагента ко мне
	};

	static int  FASTCALL GetDocTypeTag(int docType, SString & rTag);
    static int  FASTCALL RecognizeDocTypeTag(const char * pTag);
	static bool FASTCALL GetWayBillTypeText(int wbType, SString & rBuf);
	static int  FASTCALL RecognizeWayBillTypeText(const char * pText);
	static int  EditInformAReg(InformAReg & rData);
	//
	// Descr: Вызывает диалог для ввода кода акцизной марки.
	//
	static int InputMark(const PrcssrAlcReport::GoodsItem * pAgi, SString & rMark);
	//
	// Descr: Флаги создания экземпляра класса
	//
	enum {
		cfDebugMode         = 0x0001, // Работать в тестовом режиме отправки (не передавать данные в УТМ)
		cfDirectFileLogging = 0x0002, // Сообщения выводить на прямую в файлы журналов (без посредничества PPLogger)
		cfVer3              = 0x0004, // Применять 3-ю версию протокола при отправке документов
		cfUseVerByConfig    = 0x0008, // Версию протокола применять в соответствии с конфигурацией
		cfVer4              = 0x0010, // @v11.0.12 Применять 4-ю версию протокола при отправке документов
	};

	PPEgaisProcessor(long cflags, PPLogger * pOuterLogger, int __reserve);
	~PPEgaisProcessor();
	bool   operator !() const;
	void   SetTestSendingMode(bool set);
	void   SetNonRvmTagMode(bool set);
	bool   GetTestSendingMode() const;
	int    CheckLic() const;
	int    GetUtmList(PPID locID, TSVector <UtmEntry> & rList);
	void   SetUtmEntry(PPID locID, const UtmEntry * pEntry, const DateRange * pPeriod);
	int    GetFSRARID(PPID locID, SString & rBuf, PPID * pMainOrgID);
	int    GetURL(PPID locID, SString & rBuf);
	int    EditQueryParam(PPEgaisProcessor::QueryParam * pData);
	int    ImplementQuery(PPEgaisProcessor::QueryParam & rParam);
	int    InteractiveQuery();

	enum {
		querybyINN = 1,
		querybyCode
	};

    int    QueryClients(PPID locID, int queryby, const char * pQ);
    int    QueryProducts(PPID locID, int queryby, const char * pQ);
    int    QueryRests(PPID locID, const char * /* @unused */);
    int    QueryRestsShop(PPID locID, const char * /* @unused */);
    int    QueryInfA(PPID locID, const char * pInfA);
    int    QueryInfB(PPID locID, const char * pInfB);
    int    Write(Packet & rPack, PPID locID, const char * pFileName);
    int    Write(Packet & rPack, PPID locID, SBuffer & rBuffer);
    int    PutQuery(PPEgaisProcessor::Packet & rPack, PPID locID, const char * pUrlSuffix, PPEgaisProcessor::Ack & rAck);
    int    PutCCheck(const CCheckPacket & rPack, PPID locID, bool horecaAutoWo, PPEgaisProcessor::Ack & rAck);
    PPEgaisProcessor::Packet * GetReply(const PPEgaisProcessor::Reply & rReply);
	int    AcceptDoc(PPEgaisProcessor::Reply & rR, const char * pFileName);
	int    DeleteDoc(PPEgaisProcessor::Reply & rR);
	//
	// Descr: Флаги состояния документа в базе данных
	//
	enum {
		bilstfAccepted          = 0x00000001, // Документ принят из ЕГАИС-сервера
		bilstfWritedOff         = 0x00000002, // Документ списан
		bilstfReadyForAck       = 0x00000004, // Документ готов к отправке подтверждения
		bilstfChargeOn          = 0x00000008, // Документы постановки на баланс начальных остатков
		bilstfExpend            = 0x00000010, // Документы продажи товара
		bilstfIntrExpend        = 0x00000020, // Документы внутренней передачи
		bilstfReturnToSuppl     = 0x00000040, // Документы возврата поставщику
		bilstfLosses            = 0x00000080, // Документы потерь (прочие расходы)
		bilstfRepeal            = 0x00000100, // Документы с запросом на отмену проведения
		bilstfTransferToShop    = 0x00000200, // Документы передачи в торговый зал (Регистр 2)
		bilstfChargeOnShop      = 0x00000400, // Документы постановки на баланс начальных остатков в торговом зале (Регистр 2)
		bilstfTransferFromShop  = 0x00000800, // Документы возврата из торговый зал (Регистр 2) на склад
		bilstfWriteOffShop      = 0x00001000, // Документы списания с баланса торгового зала (Регистр 2)
		bilstfWbRepealConf      = 0x00002000, // Документы, для которых получен и ожидает подтверждения запрос на отмету проведения
		bilstfV1                = 0x00004000, // Специальный флаг, явно указывающий на 1-ю версию формата ЕГАИС
		bilstfV2                = 0x00008000, // Документы 2-й версии ЕГАИС
		bilstfV3                = 0x00010000, // Документы 3-й версии ЕГАИС
		bilstfFixBarcode        = 0x00020000, // Постановка маркированной продукции на баланс
	};
	int    GetAcceptedBillList(const PPBillIterchangeFilt & rP, long flags, PPIDArray & rList);
	int    GetBillListForTransmission(const PPBillIterchangeFilt & rP, long flags, PPIDArray & rList, PPIDArray * pRejectList);
	int    GetBillListForConfirmTicket(/*PPID locID, const DateRange & rPeriod*/const PPBillIterchangeFilt & rP, long flags, PPIDArray & rList);
	int    GetTemporaryFileName(const char * pPath, const char * pSubPath, const char * pPrefix, SString & rFn);
	//
	// Descr: Флаги функции ReadInput()
	//
	enum {
		rifOffline     = 0x0001,
		rifRepairInventoryMark = 0x0002
	};

	int    ReadInput(PPID locID, const DateRange * pPeriod, long flags);
	int    DebugReadInput(PPID locID);
	int    RemoveOutputMessages(PPID locID, bool debugMode);
	int    SendBillActs(const PPBillIterchangeFilt & rP);
	int    SendBillRepeals(const PPBillIterchangeFilt & rP);
	int    SendBills(const PPBillIterchangeFilt & rP);
	int    CreateActChargeOnBill(PPID * pBillID, int ediOp, PPID locID, LDATE restDate, const PPIDArray & rLotList, int use_ta);
	int    CollectRefs();
	LotExtCodeCore * GetLecT(); // @v12.0.11
private:
	struct BillTransmissionPattern {
		long   Flags;
		int    EdiOp;
		const  char * P_UrlSuffix;
	};
	int    Helper_SendBillsByPattern(const PPBillIterchangeFilt & rP, const BillTransmissionPattern & rPattern);
    int    GetReplyList(void * pCtx, PPID locID, int direction /* +1 out, -1 - in */, TSCollection <PPEgaisProcessor::Reply> & rList);
	int    Helper_Read(void * pCtx, const char * pFileName, long flags,
		PPID locID, const DateRange * pPeriod, uint srcReplyPos, TSCollection <PPEgaisProcessor::Packet> * pPackList, PrcssrAlcReport::RefCollection * pRefC);
	int    Helper_Write(Packet & rPack, PPID locID, xmlTextWriter * pX);
	const SString & FASTCALL EncText(const char * pS);
	const SString & FASTCALL EncText(const SString & rS);
	enum {
		wpifPutManufInfo = 0x0001,
		wpifVersion2     = 0x0002  // Данные о товаре записываются в формате 2-й версии протокола ЕГАИС
	};
	int    WriteProductInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, PPID goodsID, PPID lotID, long flags, const ObjTagList * pLotTagList);
	enum {
		woifStrict         = 0x0001,
		woifDontSendWithoutFSRARID = 0x0002,
		woifVersion2       = 0x0004  // Данные о персоналии записываются в формате 2-й версии протокола ЕГАИС
	};
	int    WriteOrgInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, PPID personID, PPID addrLocID, LDATE actualDate, long flags);
	int    WriteOrgInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, const EgaisPersonCore::Item & rRefcItem, long flags);
	int    WriteInformCode(SXml::WDoc & rXmlDoc, const char * pNs, char informKind, SString & rCode, int docType);
	//
	// Descr: Разбирает xml-ответ от сервера УТМ (<A></A>)
	//
	int    ReadAck(const SBuffer * pBuf, PPEgaisProcessor::Ack & rAck);
	int    Read_OrgInfo(xmlNode * pFirstNode, PPID personKindID, int roleFlags, PPPersonPacket * pPack, PrcssrAlcReport::RefCollection * pRefC, SFile * pOutFile);
	int    Read_ProductInfo(xmlNode * pFirstNode, PPGoodsPacket * pPack, PrcssrAlcReport::GoodsItem * pExt, PrcssrAlcReport::RefCollection * pRefC, SFile * pOutFile);
	int    Read_WayBill(xmlNode * pFirstNode, PPID locID, const DateRange * pPeriod, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	int    Read_WayBillAct(xmlNode * pFirstNode, PPID locID, Packet * pPack);
	int    Read_Rests(xmlNode * pFirstNode, PPID locID, const DateRange * pPeriod, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	int    Read_Ticket(xmlNode * pFirstNode, Packet * pPack);
	int    Read_TicketResult(xmlNode * pFirstNode, int ticketType /* 1 or 2 */, PPEgaisProcessor::Ticket::Result & rResult);
	int    Read_TTNIformBReg(xmlNode * pFirstNode, Packet * pPack);
	int    Read_ActInventoryInformBReg(xmlNode * pFirstNode, Packet * pPack);
	int    Read_IformA(xmlNode * pFirstNode, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	SString & FASTCALL PreprocessGoodsName(SString & rName) const;
	int    AssignManufTypeToPersonPacket(PPPersonPacket & rPack, int manufType);
	int    FinishBillProcessingByTicket(const PPEgaisProcessor::Ticket * pT, int use_ta);
	int    Helper_FinishBillProcessingByTicket(int ticketType, const BillTbl::Rec & rRec,
		const SString & rBillText, const PPEgaisProcessor::Ticket * pT, int conclusion, int use_ta);
	int    Helper_FinishConfirmProcessingByTicket(const BillTbl::Rec & rRec, const SString & rBillText,
		const S_GUID & rUuid, int conclusion, int use_ta);
	//
	// Descr: Создает зарезервированную операцию постановки товаров на баланс ЕГАИС
	// ARG(pID    OUT): Идентификатор созданного вида операции
	// ARG(egaisOp IN): PPEDIOP_EGAIS_ACTCHARGEON || PPEDIOP_EGAIS_ACTCHARGEONSHOP
	// ARG(use_ta  IN): @usingtransaction
	//
	int    GetActChargeOnOp(PPID * pID, int egaisOp, int use_ta);
	int    GetDebugPath(PPID locID, SString & rPath);
	int    Helper_ReadFilesOffline(const char * pPath, TSCollection <PPEgaisProcessor::Reply> & rList);
	int    SearchActChargeByActInform(const PPEgaisProcessor::ActInform & rInf, PPID * pBillID);
	int    MakeOutputFileName(const Reply * pReply, const SString & rTempPath, SString & rFileName);
	int    DeleteSrcPacket(const Packet * pPack, TSCollection <PPEgaisProcessor::Reply> & rReplyList);
	int    Helper_SendBills(PPID billID, int ediOp, PPID locID, const char * pUrlSuffix);
	int    Helper_InitNewPack(const int docType, TSCollection <PPEgaisProcessor::Packet> * pPackList, PPEgaisProcessor::Packet ** ppPack);
	int    Helper_FinalizeNewPack(PPEgaisProcessor::Packet ** ppNewPack, uint srcReplyPos, TSCollection <PPEgaisProcessor::Packet> * pPackList);
	int    Helper_CollectRefs(void * pCtx, TSCollection <PPEgaisProcessor::Reply> & rReplyList, RefCollection & rRefC);
	int    Helper_AcceptBillPacket(Packet * pPack, const TSCollection <PPEgaisProcessor::Packet> * pPackList, uint packIdx);
	int    Helper_AcceptTtnRefB(const Packet * pPack, const TSCollection <PPEgaisProcessor::Packet> * pPackList, uint packIdx, LongArray & rSkipPackIdxList);
	int    Helper_AreArticlesEq(PPID ar1ID, PPID ar2ID);
	int    Helper_CreateTransferToShop(const PPBillPacket * pCurrentRestPack);
	int    Helper_CreateWriteOffShop(int v3markMode, const PPBillPacket * pCurrentRestPack, const DateRange * pPeriod);
	int    Helper_CreateWriteOff_ByCCheck(const PPBillPacket * pCurrentRestPack, const DateRange * pPeriod); // @v11.8.2
	int    Helper_ExtractGoodsCodesFromBills(PPID opID, StringSet & rSs);
	void   LogTicketResult(const Ticket * pTicket, const BillTbl::Rec * pBillRec);
	//
	// Descr: Выводит в журнал сообщение об отправке пакета rPack
	//
	int    LogSended(const Packet & rPack);
	int    CheckBillForMainOrgID(const BillTbl::Rec & rRec, const PPOprKind & rOpRec);

	enum {
		stError           = 0x0001, // Во время выполнения какой-то функции произошла критическая ошибка
		stValidLic        = 0x0004, // Присутствует лицензия на использование интерфейса с ЕГАИС
		stTestSendingMode = 0x0008, // Тестовый режим отправки сообщений. Фактически, сообщения в виде файлов копируются в каталог TEMP/EGAIX-XXX/OUT-TEST/
		stDontRemoveTags  = 0x0010, // Опция, припятствующая удалению тегов с документов при получении отрицательных тикетов
		stUseEgaisVer3    = 0x0040, // Документы отправлять в 3-й версии формата
		stUseEgaisVer4    = 0x0080, // @v11.0.12 Документы отправлять в 4-й версии формата
	};
	long   State;
	const  UtmEntry * P_UtmEntry; // @notowned
	SString EncBuf;
	StringSet ExclChrgOnMarks; // Список марок, которые должны быть исключены при постановке лотов на баланс
	PPLocAddrStruc * P_Las;
	LotExtCodeCore * P_LecT;
	PPTextAnalyzerWrapper * P_Taw;
};
//
// Descr: Класс, реализующий функцию автоматического выбор марки егаис для списания в horeca
//
class EgaisMarkAutoSelector { // @v12.0.9 
public:
	struct _MarkEntry {
		_MarkEntry();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v12.2.11

		SString Mark;
		double Rest;
	};

	struct _TerminalEntry {
		_TerminalEntry();
		_TerminalEntry(const _TerminalEntry & rS);
		_TerminalEntry & FASTCALL operator = (const _TerminalEntry & rS);
		bool   FASTCALL Copy(const _TerminalEntry & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v12.2.11
		uint   GetTerminalEntryCount() const;

		PPID   GoodsID;
		PPID   LotID;
		LDATE  LotDate;
		double Qtty;
		TSCollection <_MarkEntry> ML;
	};
	struct Entry {
		Entry();
		Entry(const Entry & rS);
		Entry & FASTCALL operator = (const Entry & rS);
		bool   FASTCALL Copy(const Entry & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v12.2.11
		const _TerminalEntry * SelectMark(uint * pMarkEntryIdx) const;
		uint   GetTerminalEntryCount() const;

		PPID   GsID;     // Идентификатор структуры, из которой сформирован экземпляр this
		//
		// Если this связан с конечным компонентом комплектующей структуры, то Te содержит единственный элемент,
		// если this связан с точкой подстановочной структуры, то Te может содержать более одного элемента.
		//
		TSCollection <_TerminalEntry> Te;
	};
	class DocItem : public TSCollection <Entry> {
	public:
		DocItem();
		DocItem(long itemId, PPID goodsID, double qtty);
		DocItem(const DocItem & rS);
		DocItem & FASTCALL operator = (const DocItem & rS);
		bool   FASTCALL Copy(const DocItem & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v12.2.11
		uint   GetTerminalEntryCount() const;

		long   ItemId;  // Идентификатор для ссылки на исходный документ
		PPID   GoodsID; // Стартовый товар (который был продан)
		double Qtty;    // Количество проданного стартового товара
		double VolumeQtty; // Количество проданного стартового товара в литрах
	};
	class ResultBlock : public TSCollection <DocItem> {
	public:
		ResultBlock();
		ResultBlock(const ResultBlock & rS);
		ResultBlock & FASTCALL operator = (const ResultBlock & rS);
		bool   FASTCALL Copy(const ResultBlock & rS);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx); // @v12.2.11
		uint   GetTerminalEntryCount() const;
		
		int    RetCode; // @v12.2.11 Результат работы функции EgaisMarkAutoSelector::Run. Нужен для серверного запуска фукции.
	};
	EgaisMarkAutoSelector(/*@v12.2.11 PPEgaisProcessor * pEgPrc*/);
	~EgaisMarkAutoSelector();
	
	int    Run(ResultBlock & rResult);
private:
	struct RefBEntry { // @flat
		RefBEntry()
		{
			THISZERO();
		}
		PPID   LocID;
		PPID   StockBillID;
		LDATE  StockBillDt;
		int    StockBillRbb;
		PPID   GoodsID;
		char   RefB[64];
		double Rest;
	};
	static bool SearchRefBEntry(const TSVector <RefBEntry> & rList, const RefBEntry & rKey, uint * pPos);
	static bool SearchRefB(const TSVector <RefBEntry> & rList, const char * pRefB, uint * pPos);
	int    Helper(PPID goodsID, double qtty, DocItem & rResult);
	int    Helper_ProcessLot(PPID goodsStrucID, const ReceiptTbl::Rec & rLotRec, double qtty, Entry ** ppEntry, DocItem & rResult);
	int    GetRecentEgaisStock(TSVector <RefBEntry> & rResultList);

	PPObjGoods GObj;
	// @v12.2.11 (DS.GetTLA().GetEgaisProcessor() used instead) PPEgaisProcessor * P_EgPrc; // @notowned
	TSVector <RefBEntry> RecentEgaisStock;
	bool   IsInitialized;
};
//
// Descr: Класс, реализующий высокоуровневые механизмы обмена с "честным знаком"
//
class PPChZnPrcssr : private PPEmbeddedLogger {
public:
	struct Param {
		Param();
		enum {
			fTestMode = 0x0001
		};
		PPID   GuaID;
		PPID   LocID;
		long   Flags; // @v12.2.0
		DateRange Period;
	};
	struct QueryParam {
		QueryParam();

		enum {
			_afQueryTicket    = 0x0001,
			_afQueryKizInfo   = 0x0002,
			_afSendCc         = 0x0004, // @v11.0.1 Отправка кассовых чеков
			_afQueryDocListIn = 0x0008, // @v11.8.2 Запрос списка входящих документов
		};
		long   DocType;
		long   Flags;
		PPID   GuaID;
		PPID   LocID;
		PPID   ArID;  // Статья, сопоставленная с запросом (всегда, вероятно, поставщик)
		SString ParamString;
		SString InfoText; // @transient
	};
	enum {
		ptUnkn     = GTCHZNPT_UNDEF,
		ptFur      = GTCHZNPT_FUR,     // 00 02
		ptTobacco  = GTCHZNPT_TOBACCO, // 00 05
		ptShoe     = GTCHZNPT_SHOE,    // 15 20
		ptMedicine = GTCHZNPT_MEDICINE //
	};
	static int FASTCALL IsChZnCode(const char * pCode);
	//
	// Descr: Проверяет на равенство два кода честный знак pCode1 и pCode2.
	//   Сопоставление осуществляется без учета специальных символов.
	//
	static bool FASTCALL AreChZnCodesEqual(const char * pCode1, const char * pCode2);
	//
	// Descr: Варианты интерпретации результата функции ParseChZnCode
	// Note: Значение больше нуля трактуется как марка, пригодная к обработке честным знаком
	//
	enum {
		chznciNone      = 0, // Код ни на что не похож. 
		chznciReal      = 1, // Валидный код марки честный знак
		chznciPallet    = 2, // @v12.3.5 (SNTOK_CHZN_PALLET_GTIN) Код паллеты
		chznciSurrogate = -1, // Суррогатный код (не является кодом марки, но из кода можно извлечь полезную информацию: GTIN и, возможно, количество)
		chznciPretend   = 1000 // Разбор кода закончился ошибкой, но тем не менее в нем есть GTIN и серия.
	};
	static constexpr int InterpretChZnCodeResult(int r)
	{
		if(r == 1000)
			return chznciPretend;
		else if(r == SNTOK_CHZN_PALLET_GTIN) // @v12.3.5
			return chznciPallet;
		else if(oneof2(r, SNTOK_CHZN_SURROGATE_GTINCOUNT, SNTOK_CHZN_SURROGATE_GTIN))
			return chznciSurrogate;
		else if(oneof6(r, SNTOK_CHZN_ALTCIGITEM, SNTOK_CHZN_CIGITEM, SNTOK_CHZN_CIGBLOCK, SNTOK_CHZN_SIGN_SGTIN, SNTOK_CHZN_GS1_GTIN, SNTOK_CHZN_SSCC)) // @v11.9.0 SNTOK_CHZN_ALTCIGITEM
			return chznciReal;
		else
			return chznciNone;
	}
	enum {
		pchzncfPretendEverythingIsOk = 0x0001
	};
	static int ParseChZnCode(const char * pCode, GtinStruc & rS, long flags);
	static int ReconstructOriginalChZnCode(const GtinStruc & rS, SString & rBuf);
	static int Encode1162(int productType, const char * pGTIN, const char * pSerial, void * pResultBuf, size_t resultBufSize);
	static int InputMark(SString & rMark, SString * pReconstructedOriginal, const char * pExtraInfoText);
	explicit PPChZnPrcssr(PPLogger * pOuterLogger);
	~PPChZnPrcssr();
	int    EditParam(Param * pParam);
	int    EditQueryParam(PPChZnPrcssr::QueryParam * pData);
	int    InteractiveQuery();
	int    Run(const Param & rP);
	int    TransmitCcList(const Param & rP, const TSCollection <CCheckPacket> & rList);
	static int Test();
	static int InteractiveCheck();

	class PermissiveModeInterface {
	public:
		struct CdnStatus {
			CdnStatus();
			SString CdnAddr; // адрес CDN-площадки
			int    Code; // 0 - ok, !0 - error
			int    AvgTimeMs;
		};
		struct CodeStatus {
			CodeStatus();
			enum {
				fFound      = 0x0001, // Признак наличия кода. Возможные значения: true — «Код найден»; false — «Код не найден»
				fValid      = 0x0002, // Результат проверки валидности структуры КМ. Возможные значения: true — «Структура валидная»; false — «Структура не валидная»
				fVerified   = 0x0004, // Результат проверки крипто-подписи КМ. Возможные значения: true — «Проверка крипто-подписи завершилась успешно»; false — «Проверка крипто-подписи.
				fRealizable = 0x0008, // Признак ввода в оборот. Признак показывает, находится ли КИ в статусе «В обороте». Возможные значения: true – «КИ в статусе «В обороте»»; false – «КИ в статусе, отличном от «В обороте»».
				fUtilised   = 0x0010, // Признак нанесения КИ на упаковку. Возможные значения: true — «КИ нанесён»; false — «КИ не нанесён»
				fIsOwner    = 0x0020, // Признак, определяющий что запрос направлен владельцем кода. true — КМ принадлежит участнику, который направил запрос; false — КМ не принадлежит участнику, который направил запрос.
				fIsBlocked  = 0x0040, // Признак того, что розничная продажа продукции заблокирована по решению ОГВ. true — продажа заблокирована; false — продажа не заблокирована.
				fIsTracking = 0x0080, // Признак контроля прослеживаемости в товарной группе. true — контроль прослеживаемости в товарной группе для данного КМ включен; false — контроль прослеживаемости в товарной группе для данного КМ выключен.
				fSold       = 0x0100, // Признак вывода из оборота товара. true — товар выведен из оборота; false — товар не выведен из оборота.
				fGrayZone   = 0x0200, // Признак принадлежности табачной продукции к «серой зоне». true — принадлежит; false — не принадлежит
			};
			CodeStatus & AssignExceptOrgValues(const CodeStatus & rS);

			uint   OrgRowId; // Идентификатор строки документа (или еще чего нибудь), которому соответствует код. Вызывающая функция сама интерпретирует это значение.
			SString OrgMark; // Текст марки, подаваемый на вход процедуре проверки
			SString Cis; //
			int    ErrorCode; // Код ошибки. 
				// 0 — ошибки отсутствуют; 
				// 1 — ошибка валидации КМ; 
				// 2 — КМ не содержит GTIN; 
				// 3 — КМ не содержит серийный номер; 
				// 4 — КМ содержит недопустимые символы; 
				// 5 — ошибка верификации крипто-подписи КМ (формат крипто-подписи не соответствует типу КМ); 
				// 6 — ошибка верификации крипто-подписи КМ (крипто-подпись не валидная); 
				// 7 — ошибка верификации крипто-подписи КМ (крипто-ключ не валиден); 
				// 8 — КМ не прошел верификацию в стране эмитента; 
				// 9 — Найденные AI в КМ не поддерживаются; 
				// 10 — КМ не найден в ГИС МТ 11 — КМ не найден в трансгране
			int    EliminationState; // Дополнительная информация по КМ. 
				// 1 — товар выведен из оборота по причинам «по образцам» или «дистанционная продажа»; 
				// 2 — товар выведен из оборота по причинам «для собственных нужд» или «для производственных целей» Заполняется для товаров, выведенных из оборота по этим причинам с 08.02.24
			uint   Mrp; // Максимальная розничная цена. В копейках (для табака).
			uint   Smp; // Минимальная из возможных единых минимальных цен. В копейках (для табака).
			uint   PackageQtty;    // 
			uint   InnerUnitCount; // Количество единиц товара в потребительской упаковке / Фактический объём / Фактический вес.
			uint   SoldUnitCount;  // Счётчик проданного и возвращённого товара.
			uint   Flags;
			uint   GroupIds[64];
			LDATETIME ExpiryDtm; // Формат yyyy-MM-dd’T’HH:mm:ss.SSSz
			LDATETIME ProductionDtm; // Формат yyyy-MM-dd’T’HH:mm:ss.SSSz
			double Weight; // Переменный вес продукции (в граммах). Возвращается только для товарной группы «Молочная продукция»
			SString PrVetDocument; // Производственный ветеринарный сопроводительный документ. Возвращается только для товарной группы «Молочная продукция»
			SString Message; // Сообщение об ошибке
			S_GUID ReqId;    // Уникальный идентификатор запроса
			int64  ReqTimestamp; // Дата и время формирования запроса. Параметр возвращает дату и время с точностью до миллисекунд.
			SString PackageType; // Тип упаковки. См. «Справочник "Типы упаковки"»
			SString Parent;      // КИ агрегата.
			SString ProducerInn; // ИНН производителя.
		};

		class CodeStatusCollection : public TSCollection <CodeStatus> {
		public:
			CodeStatusCollection();
			CodeStatusCollection & Z();
			//
			// Descr: Сопоставляет результат проверки, полученный от честного знака с коллекцией this
			//   и, если находит, соответствующий элемент, то присваивает ему поля результата проверки.
			// ARG(rowN IN): Если значение больше или равно нулю, то предполагается, что элемент rEntry
			//   находится в rowN позиции списка результатов. Это может помочь сопоставлению.
			// Returns:
			//   >0 - номер позиции (+1) в коллекции this, с которым успешно сопоставлен результат
			//    0 - не удалось найти соответствие.
			//
			int    SetupResultEntry(int rowN, const CodeStatus & rEntry);
			int    Code; // Result code. 0 - ok
			SString Description; // error message or "ok"
			S_GUID ReqId;
			int64  ReqTimestamp;
		};

		enum {
			queryGetCdnList = 1,
			queryGetCdnStatus,
			queryCheckCodeList
		};
		enum {
			fTest = 0x0001
		};
		PermissiveModeInterface(const char * pToken, uint flags);
		~PermissiveModeInterface();
		int    SelectCdnHost(SString & rResult);
		//
		// Descr: Извлекает из тега PPTAG_GUA_CHZN_PM_HOST глобальной учетной записи guaID имя хоста,
		//   к которому следует обращаться для проверки марок. Если учетная запись guaID не найдена или 
		//   тег не определен, либо в случае, если срок действия тега истек, то заново получает
		//   наиболее приемлемый хост функцией SelectCdnHost и, по возможности, сохраняет его в теге.
		//
		int    FetchCdnHost(PPID guaID, SString & rResult);
		int    CheckCodeList(const char * pHost, const char * pFiscalDriveNumber, CodeStatusCollection & rList);
	private:
		SString & MakeTargetUrl(int query, const char * pAddendum, SString & rResult) const;
		int    QueryCdnList(TSCollection <CdnStatus> & rResultList);
		int    QueryCdnStatus(CdnStatus & rStatus);
		uint   Flags;
		SString Token; // Токен авторизации // Токен нужно получить на каждый ИНН и использовать на всех кассах
		PPGlobalServiceLogTalkingHelper Lth;
	};

	//
	// Descr: Высокоуровневая (терминальная) функция, реализующая полный цикл вызовов для проверки марок в разрешительном режиме.
	//
	static int PmCheck(PPID guaID, const char * pFiscalDriveNumber, PermissiveModeInterface::CodeStatusCollection & rList);
private:
	int    PrepareBillPacketForSending(PPID billID, void * pChZnPacket);
	void * P_Ib; // Блок инициализации
};
//
//
//
enum VetisDocStatus {
	vetisdocstCREATED            = 0,
	vetisdocstCONFIRMED          = 1,
	vetisdocstWITHDRAWN          = 2,
	vetisdocstUTILIZED           = 3,
	vetisdocstFINALIZED          = 4,
	vetisdocstOUTGOING_PREPARING = 8, // Специальный статус, обозначающий строку внутреннего расходного документа, на которую
		// необходимо получить исходящий сертификат
	vetisdocstSTOCK              = 9, // Специальный статус, обозначающий строку остатков, полученных из ВЕТИС
};

class VetisEntityCore {
public:
	enum { // @persistent
		kUndef          = -1,
		kUnkn           =  0,
		kProductItem    =  1,
		kProduct        =  2,
		kSubProduct     =  3,
		kEnterprise     =  4,
		kBusinessEntity =  5,
		kUOM            =  6,
		kCountry        =  7,
		kRegion         =  8,
		kVetDocument    =  9,
		kPackingForm    = 10,
		kStockEntry     = 11
	};
	struct Entity {
		Entity();
		Entity(int kind, const VetisProductItem & rS);
		Entity(int kind, const VetisNamedGenericVersioningEntity & rS);
		explicit Entity(const VetisVetDocument & rS);
		explicit Entity(const VetisStockEntry & rS);
		Entity & Z();
		void   FASTCALL Get(VetisNamedGenericVersioningEntity & rD) const;
		void   SetupVetDocument();

		PPID   ID;
		int    Kind;
		S_GUID Guid;
		S_GUID Uuid;
		long   Flags;
		long   Status;
		long   GuidRef;
		long   UuidRef;
		SString Name;
	};
	//
	// Descr: Специализированная структура для сбора данных о неразрешенных сущностях
	// (как минимум, без имени). Используется для сбора коллекции таких элементов с
	// целью последующего разрешения запросами к серверу Vetis.
	//
	struct UnresolvedEntity {
		PPID   ID;
		int    Kind;
		long   GuidRef;
		long   UuidRef;
	};
	enum {
		txtprpProductItemName = (PPTRPROP_USER+1),
		txtprpTranspVNum      = (PPTRPROP_USER+2), // Номер автомобиля
		txtprpTranspTNum      = (PPTRPROP_USER+3), // Номер прицепа
		txtprpTranspCNum      = (PPTRPROP_USER+4), // Номер контейнера
		txtprpTranspWNum      = (PPTRPROP_USER+5), // Номер вагона
		txtprpTranspSNam      = (PPTRPROP_USER+6), // Наименование коробля
		txtprpTranspFNum      = (PPTRPROP_USER+7), // Номер самолета
		txtprpGoodsCodeList   = (PPTRPROP_USER+8), // Список кодов (в идеале upc/ean) продукции, связанной с документом
	};
	VetisEntityCore();
	static int FASTCALL ValidateEntityKind(int kind);
	static int GetProductItemName(PPID entityID, PPID productItemID, PPID subProductID, PPID productID, SString & rBuf);
	//
	// Descr: Проверяет пару значений expiryFrom и expiryTo (представленные как SUniTime)
	//   на предмет того, не истек ли на текущий день срок годности сертификата.
	//   Функция утилитная, реализована для унификации так как эта процедура применяется в некскольких точках.
	//
	static int FASTCALL CheckExpiryDate(int64 expiryFrom, int64 expiryTo);
	int    SetEntity(Entity & rE, TSVector <UnresolvedEntity> * pUreList, PPID * pID, int use_ta);
	int    DeleteEntity(PPID id, int use_ta);
	int    GetEntity(PPID id, Entity & rE);
	int    GetEntityByGuid(const S_GUID & rGuid, Entity & rE);
	int    GetEntityListByGuid(const S_GUID & rGuid, TSCollection <Entity> & rList);
	int    GetEntityByUuid(const S_GUID & rUuid, Entity & rE);
	//
	// Descr: Флаги функции Put(PPID *, const VetisVetDocument &, long flags, TSVector <UnresolvedEntity> *, int use_ta)
	//
	enum {
		putvdfForceUpdateOuterFields    = 0x0001, // Заменять значения внешних по отношению к ВЕТИС атрибутов
		putvdfEnableClearNativeBillLink = 0x0002  // @v11.1.8 Функция получает возможность обнулить ссылку на собственный документ в БД
	};
	int    Put(PPID * pID, const VetisVetDocument & rItem, long flags, TSVector <UnresolvedEntity> * pUreList, int use_ta);
	int    Put(PPID * pID, const S_GUID & rBusEntGuid, const S_GUID & rEnterpriseGuid, const VetisStockEntry & rItem, TSVector <UnresolvedEntity> * pUreList, int use_ta);
	int    Put(PPID * pID, const VetisEnterprise & rItem, TSVector <UnresolvedEntity> * pUreList, int use_ta);
	int    Put(PPID * pID, const VetisBusinessEntity & rItem, TSVector <UnresolvedEntity> * pUreList, int use_ta);
    int    Put(PPID * pID, int kind, const VetisProductItem & rItem, TSVector <UnresolvedEntity> * pUreList, int use_ta);
	//int    RecToItem(const VetisProductTbl::Rec & rRec, VetisProductItem & rItem);
	int    CollectUnresolvedEntityList(TSVector <UnresolvedEntity> & rList);
	int    Get(PPID id, VetisVetDocument & rItem);
	int    Get(PPID id, VetisEnterprise & rItem);
	int    Get(PPID id, VetisBusinessEntity & rItem);
	int    Get(PPID id, VetisProductItem & rItem);
	//int    Get(PPID id, VetisProduct & rItem);
	//int    Get(PPID id, VetisSubProduct & rItem);
	int    SetOutgoingDocApplicationIdent(PPID id, const S_GUID & rAppId, int use_ta);
	//
	// Descr: Устанавливает у документа с идентификатором id флаг VetisVetDocument::fInSendingQueue
	//
	int    SetOutgoingDocInQueueFlag(PPID id, int use_ta);
	int    SearchPerson(PPID id, VetisPersonTbl::Rec * pRec);
	int    SearchDocument(PPID id, VetisDocumentTbl::Rec * pRec);
	int    MatchPersonInDocument(PPID docEntityID, int side /*0 - from, 1 - to*/, PPID personID, PPID dlvrLocID, int use_ta);
	//
	// Descr: Сопоставляет ветеринарный документ docEntityID с документом billID и (если !0) со строкой документа
	//   {billID; rowN}.
	//   Если параметр fromBill != 0, то считает, что лот {billID; rowN} уже сопоставлен и не модифицирует документ.
	//
	int    MatchDocument(PPID docEntityID, PPID billID, int rowN, int fromBill, int use_ta);
	int    SetupEnterpriseEntry(PPID psnID, PPID locID, VetisEnterprise & rEntry);
	int    MakeCountryList(StrAssocArray & rList, UUIDAssocArray & rGuidList);
	int    MakeRegionList(long countryIdent, StrAssocArray & rList, UUIDAssocArray & rGuidList);
	int    MakeLocalityList(long regionIdent, StrAssocArray & rList, UUIDAssocArray & rGuidList);
	int    MakeProductList(StrAssocArray & rList, UUIDAssocArray & rGuidList);
	int    MakeSubProductList(StrAssocArray & rList, UUIDAssocArray & rGuidList, LAssocArray * pParentProductList);

	VetisEntityTbl ET;
	VetisProductTbl PiT;
	VetisPersonTbl  BT;
	VetisDocumentTbl DT;
	UuidRefCore UrT;
private:
	int    EntityRecToEntity(const VetisEntityTbl::Rec & rRec, Entity & rE);
	int    ResolveEntityByID(PPID entityID, VetisNamedGenericVersioningEntity & rD);
	long   Helper_InitMaxGuidKey(const UUIDAssocArray & rGuidList) const;
	long   Helper_SetGuidToList(const S_GUID & rGuid, long * pMaxGuidKey, UUIDAssocArray & rGuidList) const;

	PPObjPerson PsnObj;
};
//
//
//
class VetisDocumentFilt : public PPBaseFilt {
public:
	VetisDocumentFilt();
	int    FASTCALL GetStatusList(PPIDArray & rList) const;

	uint8  ReserveStart[200]; // @anchor
	enum {
		fkGeneral  = 0,
		fkInterchangeParam = 1
	};
	enum {
		icacnLoadUpdated     = 0x0001,
		icacnLoadAllDocs     = 0x0002,
		icacnLoadStock       = 0x0004,
		icacnPrepareOutgoing = 0x0008,
		icacnSendOutgoing    = 0x0010,
		icacnRefsImport      = 0x0020  // @v11.0.10
	};
	enum {
		refimpfCountry = 0x0001,
		refimpfRegion  = 0x0002,
		refimpfUOM     = 0x0004,
		refimpfEnterprise      = 0x0008,
		refimpfLocation        = 0x0010,
		refimpfProductGroup    = 0x0020,
		refimpfProductSubGroup = 0x0040,
		refimpfProductItem     = 0x0080,
		refimpfPurpose = 0x0100,
	};
	enum {
		fAsSelector      = 0x0001
	};
	int16  Ft_Expiry;   // Селектор по признаку истечения срока годности. (0) ignored, (< 0) off, (> 0) on
	int16  Ft_LotMatch; // Селектор по признаку сопоставления со строкой документа. (0) ignored, (< 0) off, (> 0) on
	PPID   LinkVDocID;  // Ид документа, привязки к которому необходимо отобразить
	S_GUID SelLotUuid;  // Если установлен флаг fAsSelector, то после закрытия окна таблицы в этом поле будет выбранный идентификатор
		// При открытии окна текущая позиция будет установлена на записи с этим идентификатором.
	long   FromPersonID;
	long   FromLocID;
	long   ToPersonID;
	long   ToLocID;
	long   FiltKind;
	long   Flags;
	long   Actions;
	PPID   MainOrgID;
	PPID   LocID__;
	DateRange Period;
	DateRange WayBillPeriod;
	long    VDStatusFlags;
	long    Sel;              // Если установлен флаг fAsSelector, то после закрытия окна таблицы в этом поле будет выбранный идентификатор
	long    RefsImpFlags;     // @v11.0.10 Флаги импорта справочников
	uint8   ReserveEnd[24];   // @anchor @v11.0.10 [28]-->[24]
};

struct VetisDocumentTotal {
	VetisDocumentTotal();

	long   Count;
	long   CtCreated;
	long   CtConfirmed;
	long   CtWithdrawn;
	long   CtUtilized;
	long   CtFinalized;
	long   CtOutgoingPrep;
	long   CtStock;
};

typedef VetisDocumentTbl::Rec VetisDocumentViewItem;

class PPViewVetisDocument : public PPView {
public:
	struct BrwHdr {
		PPID   EntityID;
		long   Flags;
		PPID   LinkBillID;
		int16  LinkBillRow;
		PPID   LinkGoodsID;
		PPID   LinkFromPsnID;
		PPID   LinkFromDlvrLocID;
		PPID   LinkToPsnID;
		PPID   LinkToDlvrLocID;
		LDATE  IssueDate;
		PPID   OrgDocEntityID;
		int64  ExpiryFrom;     // SUniTime
		int64  ExpiryTo;       // SUniTime
	};

	static int FASTCALL EditInterchangeParam(VetisDocumentFilt * pFilt);
	static int FASTCALL RunInterchangeProcess(VetisDocumentFilt * pFilt);

	PPViewVetisDocument();
	~PPViewVetisDocument();
	virtual PPBaseFilt * CreateFilt(const void * extraPtr) const;
	virtual int EditBaseFilt(PPBaseFilt *);
	virtual int Init_(const PPBaseFilt * pBaseFilt);
	int    InitIteration();
	int    NextIteration(VetisDocumentViewItem * pItem);
	int    FASTCALL CheckForFilt(const VetisDocumentViewItem * pItem);
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
	int    CalcTotal(VetisDocumentTotal * pTotal);

	VetisEntityCore EC; // public поскольку внешние модули могут захотеть иметь доступ к этому (дорогому) ресурсу
private:
	static int DynFuncEntityTextFld;
	static int DynFuncBMembTextFld;
	static int DynFuncProductItemTextFld;
	static int DynFuncVetDStatus;
	static int DynFuncVetDForm;
	static int DynFuncVetDType;
	static int DynFuncVetStockByDoc;
	static int DynFuncVetUUID;  //@erik v10.4.11
	static int DynFuncCheckExpiry;
	static int DynFuncCheckLocation; // @v11.5.8

	virtual DBQuery * CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual void PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void ViewTotal();
	int    LoadDocuments();
	int    Helper_ProcessIncoming(const S_GUID & rVetDocUuid, const void * pIfcParam, PPVetisInterface & rIfc, TSVector <VetisEntityCore::UnresolvedEntity> * pUreList);
	int    ProcessIncoming(PPID entityID);
	int    ProcessOutcoming(PPID entityID);
	int    RerequestDocument(PPID id);
	int    ViewWarehouse();
	int    ViewGoods();
	enum {
		otmFrom = 1,
		otmTo,
		otmGoods,
		otmBill,
		otmLot
	};
	int    MatchObject(const VetisDocumentTbl::Rec & rRec, int objToMatch);
	int    ForceResolveObject(const VetisDocumentTbl::Rec & rRec, int objToMatch);

	VetisDocumentFilt Filt;
	PPIDArray FromEntityIdList;
	PPID   FromEnterpriseID;
	PPID   ToEntityID;
	PPID   ToEnterpriseID;
	PPID   LocEntityID; // @v11.5.8
};
//
// PPDesktop and cmd edit
//
int   EditCmdItem(const PPCommandGroup * pDesktop, PPCommand * pData, /*int isDesktopCommand*/PPCommandGroupCategory kind);
int   EditName(SString & rName);
int   EditCommandGroup(PPCommandGroup * pData, /*long initID*/const S_GUID & rInitUuid, PPCommandGroupCategory kind);
//HMENU PPLoadMenu(TVRez * rez, long menuID, int fromRc, int * pNotFound);
HMENU PPLoadCommandMenu(const S_GUID & rUuid, int * pNotFound);
HMENU PPLoadResourceMenu(TVRez * rez, long menuID, int * pNotFound);

int   SelectCommandGroup(S_GUID & rUuid, long * pResourceTemplateId, SString * pName, PPCommandGroupCategory kind, bool asTemplate, const PPCommandGroup * pGrp);

class PPBizScoreWindow : public TWindow {
public:
	static INT_PTR CALLBACK Proc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

	explicit PPBizScoreWindow(HWND hParentWnd);
	~PPBizScoreWindow();
	int    Create();
	void   Destroy();
	int    DoCommand(SPoint2S p);
	void   Move_W();
	void   MoveOnLayout(const FRect & rRect);
	int    LoadData();
private:
	void   Update();
	LDATETIME  Dtm;
	LDATE  ActualDt;
	StrAssocArray  BizScoreList;
	HBRUSH Brush;
	HWND   HParentWnd;
	BizScoreCore Tbl;
};
//
// Descr: Ассоциация, связывающая ввод данных, принятый рабочим столом с исполняемой командой.
//
struct PPDesktopAssocCmd { // @transient
	enum {
		fSpecCode       = 0x0001,
		fSpecCodePrefx  = 0x0002,
		fNonInteractive = 0x0008 // Вызывать команду с минимизацией интерактивности (если возможно)
	};
	enum {
		cbString = 1,     // Просто строка                  // abc AddedStrVal получает значение 'той строки (очищенное от служебных символов и пробелов)
		cbKey,            // Клавиатурный код               // ctrl-f2
		cbSCardCode,      // Номер персональной карты       // @scard
		cbPersonRegister, // Номер персонального регистра   // @reg AddedStrVal является символом типа регистрационного документа.
			// Если AddedStrVal.IsEmpty() и AddedIntVal != 0, то AddedIntVal является идентификатором типа регистрационного документа.
		cbGoodsBarcode    // Штрихкод товара                // @barcode[5..13]
	};
	enum {
		cbfCR    = 0x00000001, // Окончанием ввода должен быть перевод каретки (Enter)
		cbfError = 0x10000000  // Ошибка разбора строки
	};
	struct CodeBlock {
		int    Type;
		long   AddedIntVal;
		long   Flags;
		KeyDownCommand Key;
		IntRange LenRange;
		SString AddedStrVal;
	};

	PPDesktopAssocCmd();
	PPDesktopAssocCmd & Z();
	int    ParseCode(CodeBlock & rBlk) const;

	long   CmdID;
	long   Flags;
	SString Code;
	SString DvcSerial;
	SString CmdParam;
};
//
// Descr: Пул ассоциаций команд рабочего стола с вводимыми данными
//
class PPDesktopAssocCmdPool { // @persistent
public:
	PPDesktopAssocCmdPool();
	~PPDesktopAssocCmdPool();
	void   Init(const S_GUID & rUuid);
	S_GUID GetDesktopUuid() const;
	void   SetDesktopUuid(const S_GUID & rUuid);
	uint   GetCount() const;
	int    GetItem(uint pos, PPDesktopAssocCmd & rCmd) const;
	int    GetByCode(const char * pCode, uint * pPos, PPDesktopAssocCmd * pCmd, SString * pResult = 0) const;
	int    SetItem(uint pos, const PPDesktopAssocCmd * pCmd);
	int    AddItem(const PPDesktopAssocCmd * pCmd);
	int    ReadFromProp(const S_GUID & rDesktopUuid);
	int    WriteToProp(int use_ta);
private:
	struct Item { // @flat
		int32  CmdID;
		int32  Flags;
		uint32 DvcSerialP;
		uint32 CodeP;
		uint32 CmdParamP;
		uint8  Reserve[16];
	};
	int    MakeItem(const PPDesktopAssocCmd & rOuter, Item & rInner);
	int    Pack();

	PPID   DesktopID_Obsolete; // -1 - не определенный стол (0 - общий пул для всех рабочих столов)
	S_GUID DesktopUuid; // @v10.9.3 Начиная с этого релиза DesktopUuid является ведущим идентификатором для
		// распознавания рабочих столов и пользовательских меню.
		// Перманентный 4-байтовый идентификатор получается из ассоциации UuidRefCore
	TSVector <Item> L;
	StringSet P;
};

class PPDesktop : public TWindow {
public:
	static const char * WndClsName;
	//static int   Open(long desktopID, int createIfZero = 0);
	static int   Open(const S_GUID & rDesktopUuid, int createIfZero = 0);
   	static LRESULT CALLBACK DesktopWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static int   RegWindowClass(HINSTANCE hInst);
	static int   EditAssocCmdList(const S_GUID & rDesktopUuid);
	static int   CreateDefault(S_GUID & rNewUuid);
	static int GetDeskName(const S_GUID & rDesktopUuid, SString & rDeskName);
	static int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
	static COLORREF GetDefaultBgColor();
	PPDesktop();
	~PPDesktop();
	int    Init__(const S_GUID & rDesktopUuid);
	int    Destroy(int dontAssignToDb);
	TRect & CalcIconRect(SPoint2S lrp, TRect & rResult) const;
	int    GetIconSize() const { return IconSize; }
	int    GetIconGap() const { return IconGap; }
	void   Paint();
	int    BeginIconMove(SPoint2S p);
	int    MoveIcon(SPoint2S p);
	void   EndIconMove(SPoint2S p);
	void   Update(const TRect * pR, bool drawBackgnd);
	int    EditIconName(long id);
	int    DoCommand(SPoint2S p);
	void   ArrangeIcons();
	void   Layout();
	//
	// Descr: Перечисление внутренних сервисных виджетов
	//
	enum {
		svcviewCommand  = 1, // Иконка вызова команды. CreateServiceView && GetServiceView для этого типа не отрабатывает.
		svcviewBizScore = 2, // Окно бизнес-показателей
		svcviewEvents   = 3  // @construction Окно событий
	};
	int    CreateServiceView(int svcviewId);
	TWindow * GetServiceView(int svcviewId);
	// @v11.0.0 replaced with PPDesktop::GetServiceView(int) PPBizScoreWindow * GetBizScoreWnd();
	// @v11.0.0 replaced with PPDesktop::CreateServiceView(int) int    CreateBizScoreWnd();
	int    Advise();
	void   Unadvise();
protected:
	DECL_HANDLE_EVENT;
private:
	class InputArray : public TSVector <KeyDownCommand> {
	public:
		void   Clear();

		SString DvcSerial;
	};
	struct RawInputBlock {
		RawInputBlock();
		void   ClearInput();
		PPDesktop::InputArray * AddKeyDownCommand(const KeyDownCommand & rK, const char * pDvcSerial);

		uint   RawKeyStatus; // KeyDownCommand::stateXXX
		LTIME  LastRawKeyTime;
		TSCollection <PPDesktop::InputArray> InpList;
		//
		// Далее следуют переменные, используемые как буферы для сокращения времени на распределение памяти
		// при обработке RAWINPUT
		//
		SString DvcNameBuf_;
	};
	ushort Execute();
	void   WMHCreate();
	void   DrawIcon(TCanvas & rC, long cmdID, int isSelected);
	void   DrawIcon(TCanvas & rC, long id, SPoint2S coord, const SString & rText, const SString & rIcon, int isSelected);
	void   AddTooltip(long id, SPoint2S coord, const char * pText);
	int    DrawText(TCanvas & rC, SPoint2S coord, COLORREF color, const char * pText);
	int    ArrangeIcon(PPCommand * pCmd);
	int    ArrangeIcon(SPoint2S * pCoord);
	int    SaveDesktop(PPCommandMngr * pMgr, PPCommandGroup * pDeskList);
	int    WaitCommand();
	int    ProcessRawInput(void * rawInputHandle);
	int    ProcessCommandItem(const PPDesktop::InputArray * pInp, const PPDesktopAssocCmd & rCpItem);
	int    Helper_AcceptInputString(const PPDesktop::InputArray * pInp, const PPDesktopAssocCmd & rCpItem, SString & rBuf);

	int    IconSize; // default=32
	int    IconGap;  // default=8
	long   Selected;
	enum {
		stChanged  = 0x0001, // Рабочий стол был изменен и его нужно сохранить в файле
		stIconMove = 0x0002  // Состояние перемещения иконки
	};
	long   State;
	SImage Logotype;
	SPoint2S MoveIconCoord;
	SPoint2S CoordOffs;
	//
	enum {
		dummyFirst = 1,
        fontText,
        fontDef,
        cursorMain,
        brushTextRect,
        brushSelTextRect,
        brushBkg,
        brushDef,
        penTextRect,
        penSelTextRect,
        penDef,
        colorBkg
	};
	SPaintToolBox Ptb;
	HWND   HwndTT;
	HWND   HBizScoreWnd;
	PPIDArray Cookies;
	PPCommandGroup * P_ActiveDesktop;
	TSCollection <SUsbDevice> UsbList; // @vmiller
	PPDesktopAssocCmdPool PrivateCp;
	PPDesktopAssocCmdPool CommonCp;
	RawInputBlock Rib;
	PPObjSCard * P_ScObj;
	PPObjGoods * P_GObj;
	PPObjPerson * P_PsnObj;
};
//
// DeleteTmpFiles
//
struct DeleteTmpFilesParam {
	DeleteTmpFilesParam();
	enum {
		fRmvTempData     = 0x0001,
		fRmvTempPrns     = 0x0002,
		fRmvInTransm     = 0x0004,
		fRmvOutTransm    = 0x0008,
		fRmvTempCharry   = 0x0010,
		fRmvTempEmail    = 0x0020,
		fRmvBHTDataFiles = 0x0040,
		fRmvTempQrCodes  = 0x0080
	};
	long   Flags;
	int16  InDays;
	int16  OutDays;
};

int PPDeleteTmpFiles(DeleteTmpFilesParam * pDelParam);
int DeleteTmpFilesDlg(DeleteTmpFilesParam * pParam);

struct RcvCharryParam {
	RcvCharryParam();
	int    Edit();

	enum {
		aRcvFromMail   = 1, // Проверить почтовый ящик
		aGetFromInPath = 2, // Не проверять почтовый ящик
		aRcvFromFile   = 3  // Из файла
	};
	PPID   MailAccID;
	int    Action;
	long   Flags;
};
//
//
//
class PPWhatmanWindow : public TWindowBase {
	friend class TWhatmanBrowser;
public:
	//
	// Descr: Открывает окно просмотра файла ватмана pWtmFileName
	//
	static int Launch(const char * pWtmFileName, long options, TWhatmanObject::SelectObjRetBlock * pSelRetBlk);
	//
	// Descr: Открывает окно редактирования файла ватмана pWtmFileName.
	// ARG(pWtmFileName IN): @#{vptr0} Имя файла ватмана для редактирования.
	// ARG(pWtaFileName IN): @#{vptr0} Имя файла панели инструментов.
	// Returns:
	//   >0 - окно успешно создано и запущено
	//   0  - ошибка
	//
	static int Edit(const char * pWtmFileName, const char * pWtaFileName);
	//
	// Descr: Режимы работы окна
	//
	enum {
		modeEdit = 1, // Режим редактирования //
		modeView,     // Режим рабочего отображения //
		modeToolbox   // Режим панели инструментов
	};
	//
	// Descr: Флаги режима работы окна
	//
	enum {
		stfModalSelector = 0x0001 // Окно работает как модальный селектор объекта
	};
	//
	// Descr: Зарезервированные идентификаторы инструментов рисования //
	//
	enum {
		penMain = 1,
		brBackg,
		brGreen,
		fontMain,
		csToolText,
		csToolTextSel,
		paraToolText,
		//
		penObjBorder,
		penObjBorderSel,
		penObjBorderCur,
		penObjRszSq,
		brObjRszSq,
		penObjNonmovBorder,
		penRule,
		brRule,
		penGrid,
		penSubGrid,
		//
		curMove,
		curResizeEW,
		curResizeNS,
		curResizeNESW,
		curResizeNWSE,
		curOdious, // @debug
		penLayoutBorder,
		penContainerCandidateBorder,
		penLayoutEvenBorder, // @v11.2.2 Цвет рамки лейаутов четного уровня
		penLayoutOddBorder, // @v11.2.2 Цвет рамки лейаутов нечетного уровня

		anchorLastTool // Значение для выравнивания идентификаторов инструментов в производных окнах
	};
	explicit PPWhatmanWindow(int mode);
	~PPWhatmanWindow();
	int    AddObject(TWhatmanObject * pObj, const TRect * pBounds);
	int    ArrangeObjects(const LongArray * pObjPosList, TArrangeParam & rParam, SScroller * pScrlr);
	SPaintToolBox & GetToolBox();
	int    EditParam();
	int    AddTool(const char * pObjSymb);
	int    EditTool(uint objIdx);
	int    DeleteTool(uint objIdx);
	//
	// Descr: Опции функции FileSave()
	//
	enum {
		fsfLayoutAsJson = 0x0001 // Сохранить layout в json-формате
	};

	int    FileSave(uint flags, WhatmanObjectLayoutBase * pLayout);
	int    FileOpen();
	int    LoadTools(const char * pFileName);
	void   SetCurrentObject(int objIdx);
	int    EditObject(int objIdx);
protected:
	DECL_HANDLE_EVENT;

	TWhatman W;
	//
	// Descr: Субкласс, управляющий скроллированием в двух измерениях.
	// Note: Находится в состоянии активной разработки.
	//
	class ScrollBlock {
	public:
		ScrollBlock();
		int    SetupWindow(HWND hWnd) const;
		int    MoveToEdge(int side);
		int    Move(int side, int delta);
		int    Set(int x, int y);
		int    GetX() const;
		int    GetY() const;
		void   SetRangeX(const IntRange & rR);
		void   SetRangeY(const IntRange & rR);
		bool   GetUseScrlrX() const;
		bool   GetUseScrlrY() const;
		void   SetUseScrlrX(bool);
		void   SetUseScrlrY(bool);
		SScroller ScrlrX; // @v11.0.3
		SScroller ScrlrY; // @v11.0.3
	private:
		enum {
			fUseScrlrX = 0x0001, // Использовать ScrlrX вместо (Rx, ScX)
			fUseScrlrY = 0x0002  // Использовать ScrlrY вместо (Ry, ScY)
		};
		uint   Flags;
		IntRange Rx;        // Диапазон горизонтального скроллирования //
		IntRange Ry;        // Диапазон вертикального скроллирования   //
		int    ScX;         // Горизонтальная позиция скроллера        //
		int    ScY;         // Вертикальная позиция скроллера          //
	};
	ScrollBlock ScrlB;
private:
	//
	// Descr: Дескриптор местонахождения точки.
	//
	struct Loc {
		enum {
			kNone = 0,       // Точка находится вне ватмана
			kWorkspace,      // Точка находится в рабочей области, но не принадлежит ни одному из объектов
			kObject,         // Точка находится в области объекта
			kObjectInMultSel // Точка находится в области одного из объектов, принадлежащего множеству выбранных
		};
		int    Kind;
		int    ObjIdx;
		int    ObjRszDir;
		SPoint2S Pt;
		const  TWhatmanObject * P_Obj;
	};
	struct ResizeState {
		ResizeState();
		~ResizeState();
		int    operator ! () const;
		void   Reset();
		int    Setup(int mode, const Loc & rLoc, int * pCursorIdent);

		enum {
			kNone = 0,      // Ничего не происходит
			kObjMove,       // Объект перемещается.
			kObjResize,     // Объект изменяет размеры.
			kObjDrag,       // Объекта переносится в рамках операции Drag'n'Drop
			kObjDragTarget, // Перемещение курсора с объектом из чужого источника
			kRectSelection, // Режим выделения прямоугольной области для выбора нескольких объектов
			kMultObjMove    // Перемещение множества выбранных объектов
		};
		enum {
			fDontDrawMovedObj = 0x0001
		};
		int    Kind;      //
		int    ObjIdx;    //
		int    ObjRszDir; // Направление изменения размера объекта (SOW_XXX)
		long   Flags;     // @flags
		SPoint2S StartPt;   // Стартовая точка начала перемещения //
		SPoint2S EndPt;     // Последняя фиксация точки, в которую необходимо осуществить перемещение.
		TWhatmanObject * P_MovedObjCopy;
	};
	struct State_ {
		int    Mode;      // PPWhatmanWindow::modeXXX
		long   Flags;     // PPWhatmanWindow::stfXXX
		int    SelectedObjIdx;
		ResizeState Rsz;
	};
	class ToolObject : public TWhatmanObject {
	public:
		ToolObject(const char * pToolSymb, const TWhatmanToolArray * pTools, const TRect & rBounds);
		virtual TWhatmanObject * Dup() const;
		virtual int Draw(TCanvas2 & rCanv);
		virtual int GetTextLayout(STextLayout & rTlo, int options) const;

		SString ToolSymb; // Символ объекта в контейнере инструментов
		const TWhatmanToolArray * P_Tools; // @notowned
	};
	struct DdotInfoBlock {
		TWindow * P_SrcWin;
		TWhatmanToolArray::Item WtaItem;
	};

	void   Helper_SetCurrentObject(int objIdx, const SPoint2S * pStartResizePt);
	int    Resize(int mode, SPoint2S p);
	int    Locate(SPoint2S p, Loc * pLoc) const;
	int    Rearrange();
	int    LocalMenu(int objIdx);
	int    InvalidateObjScope(const TWhatmanObject * pObj);
	int    InsertDlScopeView(DlContext & rCtx, const DlScope * pParent, const DlScope * pS);
	int    Test_LoadDl600View();
	void   MakeLayoutList(const WhatmanObjectLayoutBase * pItem, uint itemIdx, uint parentIdx, StrAssocArray & rList);
	static int Helper_MakeFrameWindow(TWindowBase * pFrame, const char * pWtmFileName, const char * pWtaFileName);

	State_ St;
	TWhatmanToolArray Tools;
	DdotInfoBlock Dib;
};

struct LayoutEntryDialogBlock : public SUiLayoutParam {
	explicit LayoutEntryDialogBlock(const SUiLayoutParam * pS);
	void   Setup(const SUiLayoutParam * pS);
	int    EditEntry(const TWhatman * pWtm);
	int    EditContainer();

	SString ParentLayoutSymb;
	SString OwnLayoutSymb;
};
//
// @erik {
//
class VkInterface {
public:
	struct InitBlock {
		InitBlock();
		InitBlock & Z();
		PPID   GuaID;
		PPGlobalUserAccPacket GuaPack;
		SString CliIdent;
		SString CliAccsKey;
		SString EndPoint; // URL для запросов
		//
		// (replaced with CliAccsKey) SString Token;
		SString GroupId;
		SString PageId;
		SString TxtMsg;
		SString LinkFilePath;
		long   LinkFileType;
		PPID   OuterWareIdentTagID;
	};
	VkInterface();
	//
	// Descr: Опции функции Setup()
	//
	enum {
		sfInitStoreAttributes = 0x0001 // Инициализировать атрибуты доступа к интернет-магазину VK
	};
	int    Setup(PPID guaID, uint flags);
	void   GetVKAccessToken();
	SString & GetAppIdent(SString & rBuf) const;
	PPID   GetOuterWareIdentTagID() const;

	struct SimpleRef {
		SimpleRef();
		int64  Id;
		SString Name;
	};
	struct WareCategory {
		WareCategory();
		int64  Id;
		SString Name;
		SimpleRef Section;
	};
	struct WarePrice {
		WarePrice();
		int64 Amount; // fixed(2)
		SimpleRef Currency;
		SString Text;
	};
	struct MarketWareItem : public PPObjGoods::ExportToGlbSvcItem {
		MarketWareItem();
		MarketWareItem(const PPObjGoods::ExportToGlbSvcItem & rS);
		int64  OuterId;      // Идентификатор в VK полученный предварительным запросом всех позиций на ресурсе
		int64  OwnerId;      // Сообщество-владелец
		int    Availability;
		int    CurrencyId;
		double CartQtty;
		int64  Date;
		SString Name;
		SString Description;
		SString ImgPath;
		SString ThumbPhoto;
		WareCategory Category;
	};
	struct ErrorResponse {
		ErrorResponse();
		ErrorResponse & Z();
		//
		// Descr: Преобразует объект json в описание ошибки.
		// Returns:
		//   >0 - pJs является объектом json и содержит описание ошибки, которое было успешно разобрано.
		//   <0 - pJs является объектом json, но не содержит описания ошибки
		//    0 - что-то пошло не так (либо pJs не является объектом json либо проблемы с разбором)
		//
		int    FromJsonObj(const SJson * pJs);

		int    Code;
		SString Message;
	};
	struct ImageReplyMeta {
		ImageReplyMeta();
		ImageReplyMeta & Z();

		SPoint2I Size;
		SString Kid;
	};
	struct PostImageReply {
		PostImageReply();
		PostImageReply & Z();

		int64  UserId;
		int64  GroupId;
		int64  AlbumId;
		int64  AppId;
		SString Sha;
		SString Secret;
		SString Hash;
		SString Server;
		SString RequestId;
		SString Photo; // "photo"
		SString CropData; // "crop_data"
		SString CropHash; // "crop_hash"
		ImageReplyMeta Meta;
		ErrorResponse Err;
		//
		SString OriginalReplyText;
	};
	int    PutWareToMarket(const MarketWareItem & rItem, MarketWareItem & rResultItem);
	int    WallPost(const SString & rMessage, const SString & rLinkFilePath, SString & rOutput);
	int    Market_Get(long offs, long maxItems, TSCollection <MarketWareItem> & rList); // get all goods from VK market
	int    Photos_SaveMarketPhoto(const SString & rImage, const SString & rServer,
		const SString & rHash, const SString & rCropData, const SString & rCropHash, SString & rOutput);
	int    Photos_SaveWallPhoto(/*const VkStruct &rVkStruct,*/const SString & rPhoto, const SString & rServer, const SString & rHash, SString & rOutput);
	int    Wall_Post(/*const VkStruct &rVkStruct,*/const SString & rMessage, const SString & rVkPhotoName, SString & rOutput);
	int    PhotoToReq(const SString & rUrlBuf, const SString &rImgPath, PostImageReply & rReply, const char * rDataName);
	int    ParseUploadServer(const SString & rJson, SString & rUploadOut);
	int    Photos_GetMarketUploadServer(/*const VkStruct &rVkStruct,*/const uint mainPhotoFlag, SString & rOutput);
	int    Photos_GetWallUploadServer(/*const VkStruct &rVkStruct,*/SString & rOutput);
	//int    ParceGoodsItemList(const SString & rJsonStr, LongArray & rList) const;
	int    PublishImage(int vkContentCategory, const char * pImgPat, int64 * pResultPhotoId); // @v12.2.6 @construction
	int    SaveProductPhoto(const PostImageReply & rPIR, int64 * pPhotoId);
	// 
	// Descr: Категории контента для загрузки
	//
	enum {
		ccatUndef = 0,
		ccatMarketProductPhoto = 1, // Загрузка фотографии для товара (market.getProductPhotoUploadServer)
		ccatPhotos             = 2, // Загрузка фотографий в альбом (photos.getUploadServer)
		ccatPhotosWall         = 3, // Загрузка фотографии на стену (photos.getWallUploadServer)
		ccatPhotosOwner        = 4, // Загрузка главной фотографии пользователя или сообщества (photos.getOwnerPhotoUploadServer)
		ccatPhotosMessages     = 5, // Загрузка фотографии в личное сообщение (photos.getMessagesUploadServer)
		ccatPhotosChat         = 6, // Загрузка главной фотографии для чата (photos.getChatUploadServer)
		ccatPhotosMarketAlbum  = 7, // Загрузка фотографии для подборки товаров (photos.getMarketAlbumUploadServer)
	};

	bool   GetUploadServerUrl(int vkContentCategory, SString & rBuf); // @v12.2.6

	enum {
		usrScopeNotify   = 0x00000001,
		usrScopeFriends  = 0x00000002,
		usrScopePhotos   = 0x00000004,
		usrScopeAudio    = 0x00000008,
		usrScopeVideo    = 0x00000010,
		usrScopeNONE1    = 0x00000020,
		usrScopeStories  = 0x00000040,
		usrScopePages    = 0x00000080,
		usrScopeAddLink  = 0x00000100,    // ХЗ что это
		usrScopeNONE2    = 0x00000200,
		usrScopeStatus   = 0x00000400,
		usrScopeNotes    = 0x00000800,
		usrScopeMessages = 0x00001000,
		usrScopeWall     = 0x00002000,
		usrScopeNONE3    = 0x00004000,
		usrScopeAds      = 0x00008000,
		usrScopeOffline  = 0x00010000,
		usrScopeDocs     = 0x00020000,
		usrScopeGroups   = 0x00040000,
		usrScopeNotification = 0x00080000,
		usrScopeStats    = 0x00100000,
		usrScopeNONE4    = 0x00200000,
		usrScopeEmail    = 0x00400000,
		usrScopeMarket   = 0x00800000
	};

	enum {
		commScopeStories   = 0x00000001,
		commScopePhotos    = 0x00000004,
		commScopeAppWidget = 0x00000040,
		commScopeMessages  = 0x00001000,
		commScopeDocs      = 0x00020000,
		commScopeManage    = 0x00040000,
	};

	const ErrorResponse & GetLastResponseError() const;
	//
	// @v12.2.6
	// Descr: Процедура для отработки различных техник и сценариев.
	//
	static int Test();
private:
	int    GetRequest(const SString & rUrl, SString & rOutput, int mflags);
	int    ReadError_(const SJson * pJs, ErrorResponse & rErr) const;
	int    ParseSimpleRef(const SJson * pJs, SimpleRef & rItem) const;
	int    ParseWareItem(const SJson * pJs, MarketWareItem & rItem) const;
	int    ParseWareCategory(const SJson * pJs, WareCategory & rItem) const;
	int    ParseWarePrice(const SJson * pJs, WarePrice & rItem) const;
	SString & AppendParamProtoVer(SString & rBuf) const;
	InitBlock Ib;
	SString AppIdent;
	const SVerT ProtoVer;
	PPGlobalServiceLogTalkingHelper Lth;
	ErrorResponse LastErrResp;
	uint64 LastRequestClk; // Момент последнего запроса к серверу VK
};
// } @erik
//
//
class UdsGameInterface {
public:
	struct InitBlock {
		InitBlock();
		InitBlock & Z();
		PPID   GuaID;
		PPID   OuterWareIdentTagID;
		PPGlobalUserAccPacket GuaPack;
		SString CliIdent;
		SString CliAccsKey;
		SString EndPoint; // URL для запросов
	};
	struct Error {
		Error();
		Error & Z();
		int    Code; // -1 error but numeric code is undefined
		SString ErrCode; // text code
		SString Message; // text message
	};
	struct MembershipTier {
		struct Conditions {
			Conditions();
			double TotalCashSpent;
			double EffInvitedCount;
		};
		MembershipTier();
		S_GUID Uid;
		SString Name;
		double Rate;
		Conditions C;
	};
	struct Settings {
		enum {
			fPurchaseByPhone = 0x0001,
			fWriteInvoice    = 0x0002,
			fBurnPointsOnPurchase  = 0x0004,
			fBurnPointsOnPricelist = 0x0008
		};
		Settings();
		int64  ID;
		uint   Flags;
		double MaxScoresDiscount;
		double CashierAward;
		double ReferralReward;
		double ReceiptLimit;
		double DeferPointsForDays;
		SString Name;
		SString PromoCode;
		SString Currency;
		SString BaseDiscountPolicy;
		SString Slug;
		MembershipTier BaseMt;
		TSCollection <MembershipTier> MtList;
	};
	struct Participant {
		Participant();
		int64 ID;
		int64 InviterID;
		double PointCount;
		double DiscountRate;
		double CashbackRate;
		LDATE DOB;
		LDATETIME DtmCreated;
		LDATETIME DtmLastTransaction;
		MembershipTier Mt;
	};
	struct Customer {
		Customer();
		int    Gender; // GENDER_XXX
		LDATE  DOB;
		S_GUID Uid;
		SString Avatar;
		SString DisplayName;
		SString Phone;
		Participant P;
	};
	struct Purchase {
		double MaxPoints;
		double Total;
		double SkipLoyaltyTotal;
		double DiscountAmount;
		double DiscountPercent;
		double Points;
		double PointsPercent;
		double NetDiscount;
		double NetDiscountPercent;
		double Cash;
		double CashBack;
	};
	struct Ref {
		Ref();
		int64  ID;
		SString Name;
	};

	enum {
		tactUndef = 0,
		tactPurchase = 1,
	};
	enum {
		tstUndef = 0,
		tstNormal,   // NORMAL
		tstCanceled, // CANCELED
		tstReversal  // REVERSAL
	};
	struct Transaction {
		Transaction();
		int64  ID;
		LDATETIME Dtm;
		int    Action; // tactXXX
		int    State;  // tstXXX
		SString Code;       // При создании транзакции: код, сканируемый с телефона
		SString BillNumber; // При создании транзакции: номер чека или документа
		Customer Cust;
		Ref    Cashier;
		Ref    Branch;
		double Points;
		double Cash;
		double Total;
		double SkipLoyaltyTotal; // При создании транзакции: A part of the bill amount for which cashback is not credited and to which the discount does not apply (in currency units).
	};
	struct FindCustomerParam {
		FindCustomerParam();
		enum {
			fExchangeCode = 0x0001 // Exchange existing payment promo code (if present in query) to a new long-term one. Old promo code will be deactivated.
		};
		S_GUID Uid;    // Customer UID
		double Total;  // Total bill amount (in currency units).
		double SkipLoyaltyTotal; // A part of the bill amount for which cashback is not credited and to which the discount does not apply (in currency units).
		long   Flags;
		SString Code;  // Payment code
		SString Phone; // Phone number in E164 format, for example, +79876543210.
	};
	UdsGameInterface();
	~UdsGameInterface();
	int    Setup(PPID guaID);
	PPID   GetOuterWareIdentTagID() const;
	//
	// Descr: Возвращает !0 если последний метод обращения к серверу завершился ошибкой.
	//   По ссылке rErr возвращает состояние последней ошибки.
	//
	int    IsError(Error & rErr) const;
	int    GetSettings(Settings & rResult);        // GET https://api.uds.app/partner/v2/settings
	int    GetTransactionList(); // GET  https://api.uds.app/partner/v2/operations
	int    GetTransactionInformation(); // GET  https://api.uds.app/partner/v2/operations
	int    GetTransactionInformation2(); // POST https://api.uds.app/partner/v2/operations/calc
	int    CreateTransaction(const Transaction & rT, Transaction & pReplyT);  // POST https://api.uds.app/partner/v2/operations
	int    RefundTransaction();  // POST https://api.uds.app/partner/v2/operations/<id>/refund
	int    RewardingUsersWithPoints(); // POST https://api.uds.app/partner/v2/operations/reward
	int    GetCustomerList(TSCollection <Customer> & rResult); // GET https://api.uds.app/partner/v2/customers
	int    FindCustomer(const FindCustomerParam & rP, Customer & rC, SString & rCode, Purchase & rPurchase);  // GET https://api.uds.app/partner/v2/customers/find
	int    GetCustomerInformation(int64 id, Customer & rC); // GET https://api.uds.app/partner/v2/customers/<id>

	struct GoodsItem {
		GoodsItem();
		GoodsItem & Z();
		enum {
			typUndef = 0,
			typCategory = 1,
			typItem = 2,
			typVaryingItem = 3
		};
		enum {
			fHidden  = 0x0001,
			fBlocked = 0x0002
		};
		int    Type;
		uint   Flags;
		int64  OuterId;  // Идентификатор в UDS
		int64  ParentId; // Идентификатор родительской категории в UDS
		LDATETIME DtmCreated;
		double Price;
		SString Ident;  // Собственный идентификатор
		SString Name;
		SString Sku;
		SString Description;
	};

	int    CreatePriceItem(const GoodsItem & rItem, GoodsItem & rRetItem);  // POST https://api.uds.app/partner/v2/goods
	int    UpdatePriceItem(const GoodsItem & rItem, GoodsItem & rRetItem);  // PUT https://api.uds.app/partner/v2/goods/<id>
	int    DeletePriceItem(int64 outerId);  // DELETE -s https://api.uds.app/partner/v2/goods/<id>
	struct GoodsItemFilt {
		GoodsItemFilt();
		int64   ParentId;
		uint    Count;  // max=50, default=10
		uint    Offset; // max=10000, default=9
	};
	int    GetPriceItemList(const GoodsItemFilt & rFilt, TSCollection <GoodsItem> & rList, uint * pFetchedCount, uint * pTotalCount); // GET -s https://api.uds.app/partner/v2/goods
	int    GetPriceItemInformation(int64 outerId, GoodsItem & rItem); // GET -s https://api.uds.app/partner/v2/goods/<id>
	//
	// Descr: Утилитная функция для поиска внешнего идентификатора в коллекции rList, полученной от сервера ранее.
	// Returns:
	//   >0 - индекс найденной позиции в rList [1..]
	//   0  - идентификатор не найден
	//
	static uint SearchOuterIdentInCollection(const TSCollection <UdsGameInterface::GoodsItem> & rList, const char * pIdent);
private:
	void   PrepareHtmlFields(StrStrAssocArray & rHdrFlds);
	int    ReadError(const SJson * pJs, Error & rErr) const;
	int    ReadMembershipTier(const SJson * pJs, MembershipTier & rT) const;
	int    ReadCustomer(const SJson * pJs, Customer & rC) const;
	int    ReadParticipant(const SJson * pJs, Participant & rP) const;
	int    ReadPurchase(const SJson * pJs, Purchase & rP) const;
	int    ReadPriceItem(const SJson * pJs, GoodsItem & rI) const;
	InitBlock Ib;
	Error LastErr;
	PPGlobalServiceLogTalkingHelper Lth;
};
//
//
//
class PPGlobalServiceHighLevelImplementations {
public:
	//int    PPSetup_GlobalService_UDS();
	static int Setup_VK();
	static int Setup_UDS();
	static int Setup_Wildberries(); // @v12.2.0
	static int ExportGoods_VK(const PPObjGoods::ExportToGlbSvcParam & rParam, const TSVector <PPObjGoods::ExportToGlbSvcItem> & rSrcList, PPLogger * pLogger);
	static int ExportGoods_UDS(const PPObjGoods::ExportToGlbSvcParam & rParam, const TSVector <PPObjGoods::ExportToGlbSvcItem> & rSrcList, PPLogger * pLogger);
};
//
// Standalone functions and supported structures
//
DECL_CMPFUNC(PPObjID);
DECL_CMPFUNC(PPQuot);
DECL_CMPFUNC(PPLBItem);
DECL_CMPFUNC(PPTLBItem);
DECL_CMPFUNC(Acct);
DECL_CMPFUNC(DraftRcptItem);
DECL_CMPFUNC(ReceiptTbl_DtOprNo);
DECL_CMPFUNC(BscCls); // @v12.3.7 классы бизнес-показателей по рангу
//
// Descr: Инициализирует глобальный объект, управляющий строковыми ресурсами.
//
bool   PPInitStrings(const char * pFileName = 0);
//
// Descr: Разрушает глобальный объект, управляющий строковыми ресурсами.
//
void   PPReleaseStrings();
//
// Descr: Загружает строку, принадлежащую группе group с идентификатором code в буфер s.
// Returns:
//   !0 - строка успешно загружена
//   0  - ошибка (PPSetErrorSLib())
//
int    STDCALL PPLoadString(int group, int code, SString & s); // @cs
SString & STDCALL PPLoadStringS(int group, int code, SString & s); // @cs
//
// Descr: То же, что и PPLoadString но строка извлекается в utf8-кодировке (это - оригинальная кодировка хранения строк)
//
int    STDCALL  PPLoadStringUtf8(int group, int code, SString & s); // @cs
int    FASTCALL PPLoadString(const char * pSignature, SString & s);
int    FASTCALL PPLoadStringUtf8(const char * pSignature, SString & s); // @v11.7.6
SString & FASTCALL PPLoadStringS(const char * pSignature, SString & s);
SString & FASTCALL PPLoadStringUtf8S(const char * pSignature, SString & s); // @v11.7.6
int    FASTCALL PPLoadStringDescription(const char * pSignature, SString & rBuf);
//
// Descr: Возвращает хэш-таблицу символов, ассоциированную с группой group
//   из внутреннего глобального хранилища.
// Note: Ни в коем случае не пытайтесь менять состояние объекта, на который
//   ссылается возвращаемый указатель. Если необходимы nonconst-действия, то сделайте
//   копию этого объекта и с ней работайте.
//
const  SymbHashTable * FASTCALL PPGetStringHash(int group);
//
// Descr: Если строка rS содержи макросы вида @{abc}, то
//   функция разрешает эти макросы извлекая строки с сигнатурами @abc
//   из строкового хранилища.
//
int    FASTCALL PPExpandString(SString & rS, int ctransf);
//
// Descr: Загружает строку категории PPSTR_TEXT с идентификатором code (PPTXT_XXX) в буфер rS.
// Note: Буфер rS предварительно очищается функцией.
//
int    FASTCALL PPLoadText(int code, SString & rS);
int    FASTCALL PPLoadTextUtf8(int code, SString & rS);
//
// Descr: Загружает строку категории PPSTR_TEXT с идентификатором code (PPTXT_XXX) в буфер rS.
// Note: Буфер rS предварительно очищается функцией.
// Returns: rS
//
SString & FASTCALL PPLoadTextS(int code, SString & rS);
SString & FASTCALL PPLoadTextUtf8S(int code, SString & rS);
//
// Descr: Загружает строку с ошибкой в буфер s
//
int    STDCALL PPLoadError(int code, SString & s, const char * pAddInfo);
//
// Descr: Загружает строку категории PPSTR_TEXT в буфер s и перекодирует ее функцией s.Transf(CTRANSF_INNER_TO_OUTER)
//
int    FASTCALL PPLoadTextWin(int code, SString & s);
int    PPGetSubStr(const char * pStr, int idx, SString &);
int    PPGetSubStr(const char * pStr, int idx /* 0.. */, char * pBuf, size_t bufLen);
	// @>>PPGetSubStr(const char *, int, SString &)
int    PPGetSubStr(uint strID, int idx, SString &);
int    PPGetSubStr(uint strID, int idx /* 0.. */, char * buf, size_t buflen);
int    PPCmpSubStr(const char * pStr, int idx /* 0.. */, const char * pTestStr, int ignoreCase);
int    PPSearchSubStr(const char * pStr, int * pIdx, const char * pTestStr, int ignoreCase);
char * numbertotext(double nmb, long fmt, char * pBuf);
char * PPGetWord(uint wordId /* PPWORD_XXX */, int ansiCoding, char * pBuf, size_t bufLen); // @obsolete
SString & PPGetWord(uint wordId /* PPWORD_XXX */, int ansiCoding, SString & rBuf);
//
// Descr: Извлекает подстроку из строки вида "1,str1;2,str2;3,str3;.." по номеру
//   предшествующему собственно подстроке (subId)
// Returns:
//   1 - подстрока обнаружена и присвоена буферу rBuf
//   0 - подстрока не обнаружена либо не удалось загрузить всю строку по идентификатору strId.
//
int    PPGetSubStrById(int strId, int subId, SString & rBuf);
//
// Функция ideqvalstr прописывает в буфер pBuf текст "ID=id"
//
SString & FASTCALL ideqvalstr(long id, SString & rBuf);
char * STDCALL ideqvalstr(long id, char * pBuf, size_t bufLen); // @obsolete
//
// Descr: Специализированная функция, используемая в стереотипных методах семейства PPObject GetPacket()
//   для диагностики вызова с нулевым идентификатором.
//
int    FASTCALL PPCheckGetObjPacketID(PPID objType, PPID id);
//
// Database chain functions
//
// Descr: Setup database chain
// ARG(pPassword IN): password for removing chain. If pPassword == 0, then
//   removing impossible.
//
int    PPChainDatabase(const char * pPassword);
//
// Descr: Remove database chain
//
int    PPUnchainDatabase(const char * pPassword);
//
// Descr: Check chain integrity.
// Returns:
//   >0 - ok
//   <0 - chain not installed
//   0  - chain integrity error
//
int    PPCheckDatabaseChain();
//
// Некоторые файловые расширения используемые в системе
//
// @v11.8.4 #define PPSEXT     ".PPS" // Файлы передачи данных между разделами БД
// @v11.8.4 #define CHARRYEXT  ".CHY" // Файлы charry
//
// Path and file fuctions
//
int    FASTCALL PPGetPath(PPID pathID, SString & rBuf);
SString & FASTCALL PPGetFileName(uint fnameID, SString & rBuf);
int    STDCALL PPGetFilePath(PPID pathID, const char * pFileName, SString & rBuf);
SString & STDCALL PPGetFilePathS(PPID pathID, const char * pFileName, SString & rBuf);
int    STDCALL PPGetFilePath(PPID pathID, uint fnameID, SString & rBuf);
//
// Descr: То же, что и PPGetFilePath но возвращает ссылку на буфер rBuf с целью
//   непосредственной подстановки результата в функцию-консьюмер.
//
SString & STDCALL PPGetFilePathS(PPID pathID, uint fnameID, SString & rBuf);
//
// Descr: Формирует уникальное имя временного файла в каталоге PPPATH_TEMP.
//
SString & STDCALL PPMakeTempFileName(const char * pPrefix, const char * pExt, long * pStart, SString & rBuf);
	// @>>MakeTempFileName
//
// Descr: Удаляет файлы, пути к которым перечислены в массиве pFileList
//
int    PPRemoveFiles(const /*PPFileNameArray*/SFileEntryPool * pFileList, uint * pSuccCount, uint * pErrCount);
int    PPRemoveFilesByExt(const char * pSrc, const char * pExt, uint * pSuccCount, uint * pErrCount);
int    GetFilesFromMailServer2(PPID mailAccID, const char * pDestPath, long filtFlags, int clean, int deleMsg);
//
// Передает выборку файлов по адресу pDestAddr, используя учетную запись mailAccID
// и тему сообщения pSubj.
//
int    PutFilesToEmail(const /*PPFileNameArray*/SFileEntryPool *, PPID mailAccID, const char * pDestAddr, const char * pSubj, long trnsmFlags);
int    PutFilesToEmail2(const StringSet * pFileList, PPID mailAccID, const char * pDestAddr, const char * pSubj, long trnsmFlags);
int    PPSendEmail(const PPInternetAccount & rAcc, const SMailMessage & rMsg, MailCallbackProc cbProc, const IterCounter & rMsgCounter);
//
// Descr: Флаги функции PPBackupOperationFile()
//
enum {
	bofCompress = 0x0001 // Файлы вносить в общий сжатый архив (иначе - в подкаталог)
};
int    PPBackupOperationFile(const char * pFileName, const char * pFolderName, long flags);
//
// Descr: Загружает из ресурсов структуру SdRecord.
//   Тип ресурса - PP_RCDECLRECORD, идентификатор - rezID.
// ARG(rezID      IN): Идентификатор ресурса описания записи
// ARG(pRec      OUT): Указатель на структуру записи, которая буде заполнена из описания ресурса.
// ARG(headerOnly IN): Если !0, то загружаются только идентификатор и наименование ресурса.
//   Описания полей не загружаются.
// Returns:
//   >0 - структура успешно загружена
//   0  - ошибка
//
int    STDCALL LoadSdRecord(uint rezID, SdRecord * pRec, int headerOnly = 0); // @defined(PPUTIL.CPP)
//
// Следующие функции возвращают таблицу аналитических статей,
// ассоциированную соответственно с поставщиками, покупателями и агентами.
//
PPID   GetSupplAccSheet();
//
// Descr: Возвращает идентификатор таблицы аналитических статей, представляющих покупателей.
//
PPID   GetSellAccSheet();
//
// Descr: Возвращает идентификатор вида персоналий, представляющего покупателей.
//   Значение определяется как группа объектов, связанных с аналитическими статьями
//   таблицы GetSellAccSheet() если с этой таблицей связаны персоналии.
//
PPID   GetSellPersonKind();
PPID   GetAgentAccSheet();
//
// Descr: Если статья articleID соотносится с поставщиком, освобожденным от НДС,
//   то функция IsSupplVATFree возвращает (>0).
//
int    FASTCALL IsSupplVATFree(PPID articleID); // @>>ArticleCache::IsSupplVatFree
bool   FASTCALL IsLotVATFree(const ReceiptTbl::Rec & rLotRec);
//
// Descr: GetSupplText если suppl != 0 возвращает строку вида "Поставщик: XXX" и
//   код возврата > 0. В противном случае - пустую строку и код < 0.
//   Используется при печати отчетов.
//
int    GetSupplText(PPID suppl, SString & rBuf);
int    FASTCALL GetCommConfig(PPCommConfig *);
int    FASTCALL SetCommConfig(const  PPCommConfig *, int use_ta);
//
// Descr: вычисляет значение, на которое необходимо умножить сумму,
//   облагаемую налогом с продаж или НДС, (сумма включает значение налога)
//   чтобы получить величину налога к уплате.
// ARG(rate IN): задает номинальную ставку налога в %.
//
double FASTCALL SalesTaxMult(double rate);
//
// Descr: вычисляет номинальную ставку НДС (%) по значениям облагаемой
//   базы (base) и суммы НДС к уплате (vat_sum). Полезна для расчета средней ставки НДС.
//
double FASTCALL CalcVATRate(double base, double vat_sum);
//
// Descr: Инициализирует rCntr количеством записей в таблице pTbl.
// Returns:
//   <0 - функция выполнена успешно
//    0 - error
//
int    FASTCALL PPInitIterCounter(IterCounter & rCntr, DBTable * pTbl);
//
// Descr: Копирует почту на носитель или отправляет по электронной почте
//
int    PutTransmitFiles(PPID, long trnsmFlags);
//
// Descr: Забирает почту с внешнего носителя или из электронной почты
//
int    GetTransmitFiles(ObjReceiveParam *);
//
// Descr: возвращает объект, соответствующий идентификатору obj.
//   Так как последствия отсутствия среди зарегестрированных,
//   требуемого объекта предсказать очень трудно, то такая ситуация //
//   обрабатывается макросом assert. Прочие сбои влекут за собой
//   возврат нуля и установку PPErrCode.
//
PPObject * FASTCALL GetPPObject(PPID obj, void * extraPtr);
//
// Descr: Флаги функции PPGetObjTypeList
//
enum {
	gotlfExcludeDyn      = 0x0001, // Не включать в список динамические типы объектов
	gotlfExcludeObsolete = 0x0002, // Не включать в список устаревшие типы объектов
	gotlfExcludeObjBill  = 0x0004  // Не включать в список PPOBJ_BILL
};

int    FASTCALL PPGetObjTypeList(PPIDArray * pList, long flags);
int    STDCALL  SendObjMessage(int msg, PPID destObj, PPID obj, PPID id, void * msgExtraPtr, ObjCollection * pDestObjColl);
int    STDCALL  SendObjMessage(int msg, PPID destObj, PPID obj, PPID id);
//
// Descr: Функция возвращает идентификаторы PPView и PPFilt, соответствующие типу объекта objType.
// Returns:
//   >0 найдено соответствие objType-->{viewId; filtId}
//    0 соответствие для типа объекта objType не найдено
//
int    PPGetObjViewFiltMapping_Obj(PPID objType, int * pViewId, int * pFiltId);
int    PPGetObjViewFiltMapping_View(int viewId, PPID * pObjType, int * pFiltId);
int    PPGetObjViewFiltMapping_Filt(int filtId, PPID * pObjType, int * pViewId);
int    PPGetConfigList(StrAssocArray *);
int    PPLicUpdate();
int    PPLicRegister();
int    PPGetLicData(PPLicData * pData);
int    PPUpdateLic(const char * pSrcFile, const char * pRegName, const char * pRegNum);
int    PPUpdateLic(const char * pSrcFile);
//
// Descr: посылает сообщение msg всем объектам за исключением объекта srcObjType
//   от объекта {srcObjType, srcObjID} с дополнительным параметром msgExtra.
//   Если один из объектов-получателей вернул в ответ на сообщение DBRPL_ERROR,
//   то исполнение функции прерывается с возвратом значения 0.
// Returns:
//   !0 - все объекты, которым было послано сообщение, отреагировали на сообщение без ошибок
//   0  - по крайней мере один из объектов в ответ на сообщение вернул код DBRPL_ERROR
//
int    STDCALL  BroadcastObjMessage(int msg, PPID srcObjType, PPID srcObjID, void * msgExtraPtr);
//
// Descr: возвращает запись PPOprKind, соответствующую идентификатору вида операции opID.
//   Возвращаемая запись извлекается из кэша, поэтому, не все поля в ней заполнены так,
//   как в базе данных (Name не определено). Параметр pData может быть равен нулю. В случае ошибки
//   возвращает 0.
//
int    FASTCALL GetOpData(PPID opID, PPOprKind * pData);
//
// Descr: Через кэш извлекает запись вида операции по символу pSymb.
//
int    FASTCALL GetOpBySymb(const char * pSymb, PPOprKind * pData);
int    STDCALL  GetOpName(PPID opID, char * buf, size_t buflen); // @obsolete use GetOpName(PPID opID, SString &)
int    FASTCALL GetOpName(PPID opID, SString &);
//
// Descr: проверяет флаги операции opID по следующему алгоритму:
//   if (GetOpData(oprKind) == 0) return 0;
//   if (andF && (Flags & andF) != andF) return 0;
//   if (notF && (Flags & notF) == notF) return 0;
//   In another cases return 1;
//
int    STDCALL  CheckOpFlags(PPID opID, long andF, long notF = 0);
int    FASTCALL CheckOpPrnFlags(PPID opID, long andF);
PPID   FASTCALL GetOpType(PPID opID, PPOprKind * = 0);
int    FASTCALL GetOpSubType(PPID opID);
int    FASTCALL GetOpList(PPID opTypeID, PPIDArray * pList);
//
// Descr: возвращает (>0) если операция op принадлежит типу
//   PPOPT_GENERIC, (<0) если op == 0 и (0) в противном случае.
//
int    FASTCALL IsGenericOp(PPID opID);
//
// Descr: возвращает параметром pList список операций,
//   обобщаемых операцией opID. Если opID == 0 или opID не является обобщенной
//   операцией, то возвращается (<0). Если возникла ошибка, то возвращается 0.
//
int    FASTCALL GetGenericOpList(PPID opID, ObjRestrictArray * pList);
//
// Descr: Редуцированный вариант предыдущей функции. Возвращает только список операций без флагов.
//
int    FASTCALL GetGenericOpList(PPID opID, PPIDArray * pList);
bool   FASTCALL IsOpBelongTo(PPID testOpID, PPID anotherOpID);
int    STDCALL  GetOpCommonAccSheet(PPID opID, PPID * pAccSheetID, PPID * pAccSheet2ID);
//
// Descr: Утилитная функция. Определяет, является ли операция возвратом либо
//   оплатой. Эта проверка используется весьма часто.
// Returns:
//   0 - вид операции не является ни оплатой, ни возвратом
//  !0 - тип операции, к которому относится операция opID (PPOPT_PAYMENT || PPOPT_GOODSRETURN || PPOPT_CHARGE).
//
PPID   FASTCALL IsOpPaymOrRetn(PPID opID);
//
// Descr: Определяет, является ли операция оплатой.
//   Отличается от IsOpPaymOrRetn только тем, что для операции возврата возвращает 0.
//
bool   FASTCALL IsOpPaym(PPID opID);
//
// Descr: Если операция товарная и оценивается в ценах реализации, то функция IsSellingOperation
//   возвращает (> 0), если товарная и оценивается в ценах поступления, то 0, для нетоварных операций
//   возвращает (< 0).
//
int    FASTCALL IsSellingOp(PPID);
//
// Descr: по спецификации идентична IsSellingOp. Существенная разница в том, что IsSellingOp извлекает ответ
//   из состояния флажка OPKF_SELLING структуры PPOprKind, а _IsSellingOp дает ответ полагаясь на
//   подразумеваемые свойства зарезервированных видов и типов операций. Функция _IsSellingOp необходима
//   лишь в редких случаях. Например для оценки корректности установки вышеозначенного флажка в диалоге пользователем.
//
int    FASTCALL _IsSellingOp(PPID);
int    FASTCALL IsExpendOp(PPID);
//
#define INTREXPND 1
#define INTRRCPT  2
//
// Descr: определяет является ли операция межскладской передачей. Если возвращаемое значение равно 0,
//   то ответ отрицательный. Если 1 - то межскладской расход, 2 - межскладской приход.
//   Признаком межскладской операции является условие: (Op(o).AccSheet == LConfig.LocSheet) &&
//     (Op(o)::Type == PPOPT_GOODSEXPEND || Op(o)::Type == PPOPT_GOODSRECEIPT).
//
int    FASTCALL IsIntrOp(PPID opID);
bool   FASTCALL IsIntrExpndOp(PPID opID); // {IsIntrOp(opID) == INTREXPND}
bool   FASTCALL IsDraftOp(PPID opID);
bool   FASTCALL IsGoodsDetailOp(PPID opID);
int    STDCALL  EnumOperations(PPID oprType, PPID * pID, PPOprKind * pRec = 0);
PPID   GetCashOp();
PPID   GetCashRetOp();
PPID   GetReceiptOp();
//
// Descr: возвращает ИД операции, если она единственная принадлежит
//   заданному типу oprType. Если существует более одной такой операции,
//   то возвращается <0. Если вообще нет таких операций, то возвращается 0.
//
PPID   FASTCALL GetSingleOp(PPID oprType);
//
// Descr: Возвращает список зачетных операций
//
int    FASTCALL GetReckonOpList(PPIDArray *);
//
// Descr: функция очень полезна для реализации ComboBox'ов.
//   Фактически возвращает (PPObjListWindow*), однако полагаться //
//   на это не следует. Эта функция создает объект класса PPObject
//   и передает его объекту PPObjListWindow, который разрушаясь удалит и созданный PPObject.
//
ListWindow * STDCALL GetPPObjList(PPID obj, uint flags, void * extraPtr);
//
// Descr: Высокоуровневая функция настройки ComboBox'а. Полагается на то,
//   что ComboBox и его строка подстроены под заданный obj.
// Returns: Если параметр pCombo == 0, то возвращает (<0) ничего не делая.
//   Если все OK, то возвращает (>0). Иначе - 0.
//
int    STDCALL SetupPPObjCombo(ComboBox * pCombo, PPID objType, PPID initID, uint flags, void * extraPtr);
int    STDCALL SetupPPObjCombo(TDialog * pDlg, uint ctlId, PPID objType, PPID initID, uint flags, void * extraPtr);
int    STDCALL SetupPPObjCombo(TDialog * pDlg, uint ctlId, PPID objType, PPID initID, uint flags);
int    STDCALL SetupObjListCombo(TDialog *, uint, PPID, const PPIDArray * pInclList = 0);
//
// Descr: Специализированные флаги функции SetupArCombo
//
enum {
	sacfDisableIfZeroSheet   = 0x0001, // Заблокировать комбо-бокс если таблица статей не определена
	sacfNonEmptyExchageParam = 0x0002, // Показывать только статьи с не пустой конфигурацией обмена в соглашении
	sacfNonGeneric           = 0x0004  // Исключить выбор группирующих статей
};

int    STDCALL SetupArCombo(TDialog * dlg, uint ctlID, PPID id, uint flags, PPID accSheetID, long /*disableIfZeroSheet*/sacf /*= 0*/);
	// @>>SetupPPObjCombo
int    SetupAmtTypeCombo(TDialog *, uint ctl, PPID id, uint flags, long options, PPIDArray * pInclList);
int    SetupCurrencyCombo(TDialog *, uint ctl, PPID id, uint /*flags*/, int asSymb, PPIDArray * pInclList);
int    SelectCurRate(PPID curID, PPID rateTypeID, double * pRate);
int    STDCALL SearchObject(PPID obj, PPID id, void * = 0);
int    EditPPObj(PPID objType, PPID objID);
//
// Descr: Возвращает наименование типа объекта (напр. "Документы", "Товары")
//
SString & FASTCALL GetObjectTitle(PPID objType, SString & rBuf);
//
// Descr: Возвращает тип объекта, соответствующего символу pSymb.
//   Если символ предполагает уточненяющее значение, то оно возвращается по
//   указателю pExtra.
//   Например, для символа "CITY" функция возвращает PPOBJ_WORLD и
//   по указателю pExtra присваивает WORLDOBJ_CITY.
//
PPID   FASTCALL GetObjectTypeBySymb(const char * pSymb, long * pExtra);
// @v12.0.1 int    STDCALL  GetObjectName(PPID objType, PPID objID, char * pBuf, size_t bufLen);
int    STDCALL  GetObjectName(PPID objType, PPID objID, SString & rBuf);
int    STDCALL  CatObjectName(PPID objType, PPID objID, SString & rBuf); // @v12.0.1 Вместо GetObjectName(PPID objType, PPID objID, SString & rBuf, int cat);
SString & GetExtObjectName(const ObjIdListFilt & rObjList, PPID obj, size_t maxItems, SString & rBuf);
int    FASTCALL ShowObjects(PPID objType, void * extraPtr);
	// @>>GetPPObject(objType, extra)->Browse(extra)
//
// Supplement procedure. Call simple list viewer with buttons.
// (Implemented in OBJREF.CPP)
//
int    SimpleObjView(PPObject * ppobj, void * extraPtr);
int    PPSelectObject(PPID objType, PPID *, uint titleID, void * extraPtr);
int    RefObjView(PPObject * pObj, long charryID, void * extraPtr);
int    PPGenerateKeywordSequence(const char * pContext, SString & rResult, void * pStat);
//
// Descr: Функция ожидающая создание файла pPath или его удаления в зависимости от параметра whileExists
// Параметр notifyTimeout отвечает за ожидание функцией DirChangeNotification::Wait события создания или удаления файла
//
int    WaitForExists(const char * pPath, int whileExists, int notifyTimeout = 5000);
int    WaitNewFile(const char * pDir, SString & rFile, int notifyTimeout = 5000);
//
// Онлайновый обмен с терминалом сбора данных
//
int    StyloBHTExch(TcpSocket *);
//
// Онлайновый обмен с терминалом сбора данных (программа StyloBhtII)
//
int    StyloBhtIIExchange(const char * pDbSymb, const char * pName, const char * pPassword, TcpSocket * pSo);
//
// Функции тестирования //
//
//
// Descr: Вызывается до вызова процедуры авторизации в базе данных
//
int    TestNoLogin(); // @<<WinMain
//
// Descr: Вызывается после авторизации в базе данных
//
int    TestLogin(); // @<<PPApp::login
//
// Descr: Генерация товарных документов
//
int    GenerateGoodsBills();
//
// Descr: Генерация платежей для формирования тестовых данных клиент/банк
//
int    GenerateCliBnkImpData();
//
// Descr: Функция, создающая и открывающая DBF-таблицу по образцу,
//   заданному в ресурсе rezID (PP_RCDATA).
//
DbfTable * FASTCALL CreateDbfTable(uint rezID, const char * fName, int forceReplace);
DbfTable * FASTCALL PPOpenDbfTable(const char * pPath);
//
// Descr: Функция форматирования количества товара. Кроме общих флагов
//   форматирования параметр fmt может включать флаги QTTYF_XXX (ppdefs.h)
//   Параметр upp (UnitsPerPack) передает емкость упаковки.
//   Если noabs != 0, то у значения qtty не будет отбрасываться знак минус.
//
char    * FASTCALL QttyToStr(double qtty, double pack, long fmt, char * buf, int noabs = 0);
SString & MoneyToStr(double nmb, long fmt, SString &);
SString & DateToStr(LDATE dt, SString & rBuf);
SString & GetCurSymbText(PPID curID, SString & rBuf);
SString & VatRateStr(double rate, SString & rBuf);
int    GetReportIDByName(const char * pRptName, uint * pRptID);
int    FASTCALL StatusWinChange(int onLogon = 0, long timer = -1);
SDateRange FASTCALL DateRangeToOleDateRange(DateRange period);
DateRange  FASTCALL OleDateRangeToDateRange(const SDateRange & rRnd);
SIterCounter FASTCALL GetPPViewIterCounter(const void * ppviewPtr, int * pAppError);
IUnknown * FASTCALL GetPPObjIStrAssocList(SCoClass * pCls, PPObject * pObj, void * extraPtr);
//
// Descr: Опции функций PPOpenFile
//
enum {
	ofilfNExist = 0x0001 // Можно выбирать отсутствующие файлы
};

int    PPOpenFile(SString & rPath, const StringSet & rPatterns, long flags, HWND owner);
int    PPOpenFile(uint strID, SString & rPath, long flags, HWND owner);
int    PPOpenDir(SString & rPath, const char * pTitle, HWND owner);
//
// 
//
//typedef int (*InitializeDialogFunc)(TDialog * pThis, const void * pIdent, void * extraPtr); // @v12.3.6
// Descr: Функция инициализации диалога средствами DL600. Указатель на эту функцию передается //
//   модулю SLIB методом SlSession::SetExtraProcBlock() дабы класс TDialog мог воспользоваться техникой
//   описания диалогом DL600.
//
int PPInitializeDialogFunc(TDialog * pThis, const void * pIdent, void * extraPtr); // @v12.3.6 @construction
//
//
//
struct SelPersonIdent {
	PPID   KindID;
	PPID   PersonID;
};

int    SelectPerson(SelPersonIdent *);
int    STDCALL  EditObjTagItem(PPID objType, PPID objID, ObjTagItem * item, const PPIDArray * pAllowedTags);
int    FASTCALL EditTagFilt(PPID objType, TagFilt *);
int    SelectObjTag(PPID * pTagID, const PPIDArray * pAllowedTags, ObjTagFilt * pFilt);
int    EditObjTagValList(ObjTagList * pTags, const PPIDArray * allowedTags);
int    EditObjTagValList(PPID objType, PPID objID, const PPIDArray * allowedTags);
//
// Descr: Вызывает диалог редактирования значений тегов для изменения по выборке объектов.
//
int    EditObjTagValUpdateList(ObjTagList * pList, const PPIDArray * pAllowedTags, int * pUpdateMode);
int    SelectPrinterFromWinPool(SString & rPrinter);
//
//
//
struct SelBasketParam : public PPBasketCombine {
	enum {
		fUseGoodsRestAsQtty     = 0x0001,  // Количество товара в корзине выбирать из остатков товара
		fNotSelPrice            = 0x0002,  // Запрет выбора цены
		fFillUpToMinStock       = 0x0004,  // Пополнить до минимального остатка
		fEnableFillUpToMinStock = 0x0008   // Если этот флаг не установлен, то опция fFillUpToMinStock будет недоступна
	};
	SelBasketParam();
	int    StoreInReg(const char * pName) const;
	int    RestoreFromReg(const char * pName);
	long   SelPrice;     // IN/OUT Выбор вида цены, которая должна загружаться в корзину
		// { 1 - цена поступления, 2 - номинальная цена реализации, 3 - чистая цена реализации (Price-Discount)}
	long   SelReplace;   // IN/OUT Способ обработки непустой корзины
		// {1 - очистить корзину, 2 - заменить существующие товары, 3 - сложить количества для существующих товаров}
	int16  Flags;        //
	int16  Reserve;      // @alignment
};
//
// Descr: вызывает диалог выбора корзины, которую необходимо заполнить из внешнего источника
//   (строки товарного документа, товарный отчет по операции и т.д.).
// ARG(pParam    IN/OUT): Структура параметров (см. комментарии к SelBasketParam
// ARG(pCallerSymb   IN):
// ARG(useGbPriceDlg IN): Использовать диалог, предлагающий выбрать одну номинальную цену и
//   три дополнительные цены (используется при выгрузке прайс-листа в корзину)
// Returns:
//   >0 - Пользователь выбрал корзину, подтвердил выбор и функция завершилась успешно.
//   <0 - Пользователь отказался от выбора корзины
//    0 - Ошибка
//
int    GetBasketByDialog(SelBasketParam * pParam, const char * pCallerSymb, uint dlgID = 0);
int    PPCalculator(void * hParentWnd, const char * pInitData);
TView * ValidView(TView *);
int    FASTCALL InsertView(TBaseBrowserWindow * v);
ushort FASTCALL ExecView(TWindow *);
ushort FASTCALL ExecViewAndDestroy(TWindow * pView);
ushort STDCALL  CheckExecAndDestroyDialog(TDialog * pDlg, int genErrMsg, int toCascade);
ushort FASTCALL ExecView(TBaseBrowserWindow * v);
bool   FASTCALL GetModelessStatus(bool outerModeless = true);
void   FASTCALL DisableOKButton(TDialog *);
int    STDCALL  SetupPhoneButton(TDialog * pDlg, uint inputCtlId, uint btnCmd);
int    STDCALL SetupGeoLocButton(TDialog * pDlg, uint inputCtlId, uint btnCmd); // @v11.6.2 @construction
int    FASTCALL PPWait(int begin);
void   PPWaitStart(); // @v11.0.3 PPWait(1)
void   PPWaitStop(); // @v11.0.3 PPWait(0)
void   FASTCALL PPWaitMsg(const char *);
void   STDCALL  PPWaitMsg(int msgGrpID, int msgID, const char * = 0);
void   FASTCALL PPWaitLong(long);
void   FASTCALL PPWaitPercent(ulong p, const char * pMsg = 0);
void   STDCALL  PPWaitPercent(long  p, long  t, const char * pMsg = 0);
void   STDCALL  PPWaitPercent(ulong p, ulong t, const char * pMsg = 0);
void   STDCALL  PPWaitPercent(uint  p, uint  t, const char * pMsg = 0);
void   STDCALL  PPWaitPercent(int64 p, int64 t, const char * pMsg = 0);
void   FASTCALL PPWaitPercent(const IterCounter & rCntr, const char * pMsg);
void   FASTCALL PPWaitPercent(const IterCounter & rCntr);
void   FASTCALL PPWaitDate(LDATE);
//
// Descr: проверяет очередь клавиатуры на Escape.
//   Если Esc нажата, то выдается запрос на подтверждение. В случае
//   положительного ответа пользователя возвращается (0). В случае
//   отрицательного - (-1). Если Esc не была нажата - (1).
//
int    PPCheckUserBreak();
int    SetupComboByBuddyList(TDialog * pDlg, uint ctlCombo, const ObjIdListFilt & rList);
int    STDCALL BarcodeInputDialog(int initChar, SString & rBuf);
//
// Descr: Устанавливает список баз данных в комбо-бокс ctl диалога dlg.
// ARG(dlg IN): указатель на диалог, в котором находится комбо-бок
// ARG(ctl IN): идентификатор комбо-бокса
// ARG(pDbes IN): контейнер, содержащий список дескрипторов баз данных
// ARG(pDbeIdxList IN): опциональный массив индексов (позиций) дескрипторов баз данных из контейнера pDbes подлежащих выбору.
//   Значения индексов в этом массиве начинаются с единицы. То есть, индекс 1 соответствует 0-му элементу pDbes.
//
int    STDCALL SetupDBEntryComboBox(TDialog * dlg, uint ctl, const PPDbEntrySet2 * pDbes, const LongArray * pDbesIdxList);
int    STDCALL SetupDBTableComboBox(TDialog * dlg, uint ctl, PPDbEntrySet2 * pDbes, long dbID, BTBLID tblID);
int    EditAccTurnTemplate(PPObjAccTurn*, PPAccTurnTempl *);
//
// @obsolete {
// Параметр options принимает значение:
//   0 - при добавлении.
//   1 - при редактировании
//   2 - редактирование с форсированным признаком modified.
//       В случае редактирования некоторые поля блокируются.
//   3 - не выводить сообщение о том что документ был модифицирован
// }
//
int    EditGoodsBill(PPBillPacket * pPack, long egbFlags);
int    GetScaleData(PPID scaleID, TIDlgInitData * pData = 0);
int    GetDefScaleData(TIDlgInitData * pData = 0);
int    EditTransferItem(PPBillPacket & rPack, int itemNo, TIDlgInitData *, const PPTransferItem * pOrder = 0, int sign = 0);
//
// Descr: Вызывает диалог редактирования списка штатных сумм
// ARG(pData IN/OUT): @#{vptr} Список сумм, который необходимо редактировать
// ARG(pTitle    IN): @#{vptr0} Опциональный заголовок диалога
// ARG(enableMod IN): Если этот параметр равен 0, то функция не допускает каких-либо изменений списка сумм
// Returns:
//   >0 - список был редактирован и пользователь нажал ОК
//   <0 - пользователь отменил (возможно) сделанные изменения //
//   0  - ошибка
//
int    EditStaffAmtList(StaffAmtList * pData, const char * pTitle, int enableMod);
int    EditStaffAmtEntry(long idx, StaffAmtList * pAmtList);
//
// Параметры функции SelectOprKind - список типов операций (PPID),
// заканчивающийся нулем. Если linkOprKind != 0, то выбираются только
// те виды операция, для которых вид связанной операции равен linkOprKind
//
PPID   CDECL   SelectOprKind(uint opklFlags /* OPKLF_XXX */, PPID linkOprKind, ...);
PPID   SelectOpKind(PPID linkOpID, const PPIDArray * pOpTypesList, uint opklFlags /* OPKLF_XXX */);
int    STDCALL SetupOprKindCombo(TDialog *, uint ctlID, PPID id, uint flags, const PPIDArray *, uint opklFlags);
int    BillPrelude(const PPIDArray * pOpList, uint opklFlags, PPID linkOpID, PPID * pOpID, PPID * pLocID);
int    STDCALL SetupLocationCombo(TDialog *, uint, PPID, uint flags, PPID locType, PPID owner);
int    STDCALL SetupLocationCombo(TDialog * dlg, uint ctl, PPID id, uint flags, const LocationFilt * pFilt);
int    STDCALL SetupObjTagCombo(TDialog *, uint, PPID, uint flags, ObjTagFilt * pFilt);
int    SetupStaffListCombo(TDialog *, uint, PPID, uint flags, PPID orgID, PPID divID);
int    SetupSubstGoodsCombo(TDialog * dlg, uint ctlID, long initID);
int    SetupSubstBillCombo(TDialog * pDlg, uint ctlID, SubstGrpBill sgb);
int    STDCALL SetupPersonCombo(TDialog *, uint ctlID, PPID id, uint flags, PPID personKindID, int disableIfZeroPersonKind);
int    MessagePersonBirthDay(TDialog * pDlg, PPID psnID);
int    STDCALL SetupSubstPersonCombo(TDialog * pDlg, uint ctlID, SubstGrpPerson sgp);
int    SetupSubstDateCombo(TDialog * dlg, uint ctlID, long initID);
int    SetupSubstSCardCombo(TDialog * pDlg, uint ctlID, SubstGrpSCard sgc);
int    EditCfgOptionsDialog(PPConfig *, long, EmbedDialog * = 0);
int    EditSecurDialog(PPID obj, PPID * id, void * extraPtr);
int    STDCALL ViewLots(const LotFilt *, int asOrders, int modeless);
int    STDCALL ViewLots(PPID goods, PPID loc, PPID suppl, PPID qcert, int modeless);
int    BillExtraDialog(const PPBillPacket * pPack, PPBillExt * pExt, ObjTagList * pTagList, int isFilt);
int    BillFilterDialog(uint rezID, BillFilt *, const char * addText = 0);
int    BillFilterDialog(uint rezID, BillFilt *, TDialog ** d, const char * addText = 0);
int    ViewStatus();
int    ViewPredictSales(PredictSalesFilt *);
void   STDCALL SetPeriodInput(TDialog *, uint fldID, const DateRange & rPeriod);
int    STDCALL GetPeriodInput(TDialog *, uint fldID, DateRange *);
int    STDCALL GetPeriodInput(TDialog * dlg, uint fldID, DateRange * pPeriod, long strtoperiodFlags);
void   STDCALL SetTimeRangeInput(TDialog *, uint ctl, long fmt, const TimeRange * pTimePeriod);
void   STDCALL SetTimeRangeInput(TDialog *, uint ctl, long fmt, const LTIME * pLow, const LTIME * pUpp);
int    STDCALL GetTimeRangeInput(TDialog *, uint ctl, long fmt, TimeRange * pTimePeriod);
int    STDCALL GetTimeRangeInput(TDialog *, uint ctl, long fmt, LTIME * pLow, LTIME * pUpp);
SString & FASTCALL PPFormatPeriod(const DateRange * pPeriod, SString & rBuf);
SString & FASTCALL PPFormatPeriod(const LDATETIME & rBeg, const LDATETIME & rEnd, SString & rBuf);
int    FASTCALL SetRealRangeInput(TDialog *, uint ctl, double lo, double up, int prc = 0);
int    FASTCALL SetRealRangeInput(TDialog *, uint ctl, const RealRange *, int prc = 0);
int    FASTCALL GetRealRangeInput(TDialog *, uint ctl, double * pLow, double * pUpp);
int    FASTCALL GetRealRangeInput(TDialog *, uint ctl, RealRange *);
int    FASTCALL SetIntRangeInput(TDialog *, uint ctl, const IntRange *);
int    FASTCALL GetIntRangeInput(TDialog *, uint ctl, IntRange *);
int    FASTCALL PPSetupCtrlMenu(TDialog * pDlg, uint ctl, uint ctlButton, uint ctrlMenuID);
int    PPExecuteContextMenu(TView * pView, uint menuID);
int    ViewGoodsTurnover(long);
int    PrintDialog(SPrinter *);
int    FastEditRightsDialog();
int    ActiveUsersListDialog();
int    FastEditSumByDivDialog();
int    FastViewDivBySumDialog();
//
enum {
	selSymbAmount    = 0x0001, // Выбирать типы сумм
	selSymbFormula   = 0x0002, // Выбирать формулы
	selSymbStaffCal  = 0x0004, // Выбирать штатные календари
	selSymbSalPeriod = 0x0008  // Выбирать периоды начисления зарплаты //
};
//
int    STDCALL SelectAmountSymb(PPID * pID, long options, int * pKind, SString & rSymbBuf);
int    STDCALL PrintCashOrderByGoodsBill(PPBillPacket * pPack, int prnflags = 0);
int    STDCALL PrepareBillMultiPrint(PPBillPacket * pFirstPack, SVector ** ppAry, long * pOutPrnFlags);
int    STDCALL MultiPrintGoodsBill(PPBillPacket * pPack, const SVector * pAry, long outPrnFlags);
int    STDCALL PrintGoodsBill(PPBillPacket * pPack);
//
// Descr: печатает расходный или приходный кассовый ордер.
//   Если pay_rcv != 0, то печатается расходный ордер (pay), в противном
//   случае - приходный.
//
int    STDCALL PrintCashOrder(PPBillPacket *, int pay_rcv, int prnflags = 0);
int    STDCALL ViewGoodsBills(BillFilt *, bool modeless);
int    STDCALL BrowseBills(BrowseBillsType);
int    STDCALL ViewBillsByPool(PPID poolType, PPID poolOwnerID);
int    STDCALL ViewOpersByLot(PPID id, int withZeroLotID);
int    STDCALL ViewCashBills(PPID cashNode);
int    STDCALL ViewGoodsMov(int modeless);
//
// Descr: Вызывает диалог расчета формул по товару goodsID.
//   Расчет формул по товару возможен тогда, когда товар принадлежит
//   классу, для которого определена по крайней мере одна формула.
//   Диалог содержит комбо-бокс выбора формулы, три поля для ввода аргументов
//   и одно поле рещультата.
//   Вызывающая функция может задать один из аргументов, передав его номер [1..3]
//   через параметр argIdx и значение через параметр arg.
//   По указателю pVal будет присвоен результат последнего расчета.
// Returns:
//   >0 - последняя попытка расчета была реализована.
//   <0 - не было реализована последняя попытка расчета либо товар goodsID не принадлежит
//        классу, для которого определены формулы.
//   0  - ошибка
//
int    PPGoodsCalculator(PPID goodsID, PPID tsesID, int argIdx, double arg, double * pVal);
//
//
//
struct CalcPriceParam { // @{calcprice}
	CalcPriceParam();
	int    Save() const; // VarPercent, RoundPrec, RoundDir, fRoundVat, fVatAboveAddition
	int    Restore();
	//
	// Descr: Осуществляет расчет цены на основе входящей цены inPrice.
	//   Не инициализирует переменную Price, но вместо этого возвращает рассчитанное
	//   значение (для сохранения спецификации const).
	//
	double Calc(double inPrice, double * pVatRate, double * pVatSum, double * pExcise) const;

	enum {
		fCostWoVat        = 0x0001, // IN     Цена поступления на входе задана без НДС
		fExclTaxes        = 0x0002, // IN/OUT Исключить налоги из цены
		fRoundVat         = 0x0004, // IN/OUT Округлять до значения, кратного ставке НДС
		fVatAboveAddition = 0x0008  // IN/OUT НДС начислять на наценку
	};
	PPID   GoodsID;    // IN
	PPID   QuotKindID; // IN/OUT
	PPID   InTaxGrpID; // IN Налоговая группа на приход (если 0, то принимается равной налоговой группе на товар)
	LDATE  Dt;         // IN
	double Cost;       // IN
	double Price;      // OUT
	double VaPercent;  // IN/OUT
	double RoundPrec;  // IN/OUT
	int16  RoundDir;   // IN/OUT (-1) - round down, (+1) - round up, (0) - to nearest
	int16  Reserve;    // @alignment
	long   Flags;      // IN/OUT CalcPriceParam::fXXX
};
//
// Descr: Новый вариант виджета для выбора даты и периода и времени
//
class SCalendarPicker : public TWindowBase {
public:
	/* @v12.3.7 (replaced with SUiCtrlSupplement::DataBlock) struct DataBlock {
		DataBlock();
		LDATETIME Dtm;
		DateRange Period;
	};*/
private:
	DECL_DIALOG_DATA(SUiCtrlSupplement::DataBlock);
public:
	/* @v12.3.7 (replaced with SUiCtrlSupplement::kXXX) enum {
		kDate     = 1,
		kPeriod   = 2,
		kTime     = 3,
		kDateTime = 4
	}; */
	// @v12.3.7 static int Exec(const int kind/*SUiCtrlSupplement::kXXX*/, SUiCtrlSupplement::DataBlock & rData);
	static int Exec(const int kind/*SUiCtrlSupplement::kXXX*/, TDialog * pParentDlg, uint inputCtlId, SUiCtrlSupplement::DataBlock * pData);
	explicit SCalendarPicker(int kind);
	~SCalendarPicker();
	DECL_DIALOG_SETDTS();
	DECL_DIALOG_GETDTS();
private:
	enum {
		loiYear,
		loiYearArrow,
		loiMonth,
		loiWeekday,
		loiDay,
		//loiHour,        //
		//loiMinute,      //
		loiFrame_Main,
		loiFrame_Years,
		loiFrame_Monthes,
		loiFrame_Days,
		loiFrame_Buttons, // 0 - frame, 1 - now, 2 - ok, 3 - cancel, 4 - left-opened-period, 5 - right-opened-period, 6 - reset period
		loiFrame_PeriodTypeButtons, // 0 - frame, PRD_DAY, PRD_WEEK, PRD_MONTH, PRD_QUARD, PRD_ANNUAL
		loiFrame_Hours,  // 0 - frame
		loiFrame_Minuts, // 0 - frame
	};
	struct LayoutExtra {
		LayoutExtra(int ident, uint value);
		int   Ident; // loiXXX
		uint  Value; // Для месяцев - месяц, для дней - день, для дней недели - день недели,
			// для loiYearArrow: SIDE_LEFT - left, SIDE_RIGHT - right
			// Для лет - (year - StartLoYear)
	};
	DECL_HANDLE_EVENT;
	static const char * GetWindowTitle(int kind);
	static const SVector & GetLayoutExtraVector();
	const LayoutExtra * GetLayoutExtra(int ident, uint val) const;
	void   CreateFont_();
	void   CreateLayout(LDATE selectedDate);
	void   DrawLayout(TCanvas2 & rCanv, const SUiLayout * pLo);
	SUiLayout * Helper_FindLayout(SUiLayout * pItem, int extraIdent, uint extraValue);
	SUiLayout * FindLayout(int extraIdent, uint extraValue);
	LDATE  AdjustLeftDate(int prdType, LDATE d) const;
	LDATE  AdjustRightDate(int prdType, LDATE d) const;
	void   UpdateSelectedPeriod(const DateRange * pNewPeriod);
	void   SetupStartLoYear();
	LDATE  ISD() const; // Inner selected date. Если Data.Dtm.d не валидно, то ISD возвращает текущую системную дату

	const  int Kind; // SUiCtrlSupplement::kDateCalendar || SUiCtrlSupplement::kDateRangeCalendar || SUiCtrlSupplement::kTime
	const  SUiLayout * P_LoFocused;
	const  SVector LoExtraList;
	int    FontId;
	int    CStyleId;
	int    CStyleFocusId;
	uint   StartLoYear;  // Стартовый год в блоке выбора года.
	long   PeriodTerm;   // PRD_XXX Kind==kPeriod
	long   PeriodPredef; // Предопределенный период (сегодня, вчера, последняя неделя и т.д.)
};
//
// Descr: Класс, управляющий процессом сборки дистрибутива Papyrus 
// 
class PrcssrBuild {
public:
	struct BuildVer {
		BuildVer();
		int    Major; // MajorVer
		int    Minor; // MinorVer
		int    Revision; // Revision
		int    Asm; // AssemblyVer
	};
	struct Param {
		enum {
			fBuildClient       = 0x0001,
			fBuildServer       = 0x0002,
			fBuildMtdll        = 0x0004,
			fBuildDrv          = 0x0008,
			fBuildSoap         = 0x0010,
			fBuildDistrib      = 0x0020,
			fCopyToUhtt        = 0x0040,
			fOpenSource        = 0x0080, // OpenSource-вариант сборки
			fSupplementalBuild = 0x0100  // дополнительная сборка XP-совместимых исполняемых файлов
		};
		Param();
		Param(const Param & rS);
		Param & FASTCALL operator = (const Param & rS);
		Param & FASTCALL Copy(const Param & rS);
		SString & GetVerLabel(SString & rBuf) const;

		BuildVer Ver;            // Собираемая версия //
		long   Flags;
		uint   ConfigEntryIdx;   // Индекс выбранной конфигурации сборки. 0 - undef
		uint   XpConfigEntryIdx; // Индекс дополнительной конфигурации сборки для Windows-XP. 0 - undef
		SString VerSuffix;       // Опциональный суффикс версии дистрибутива (например, PRE)
		struct ConfigEntry {
			ConfigEntry();
			SString Name;            // Наименование элемента конфигурации сборки
			int    PrefMsvsVerMajor; // PPINIPARAM_PREFMSVSVER
			SString RootPath;        // PPINIPARAM_BUILDROOT     Корневой каталог проекта
			SString SrcPath;         // PPINIPARAM_BUILDSRC      Каталог исходных кодов
			SString SlnPath;         // PPINIPARAM_BUILDSOLUTION Каталог, содержащий файлы проектов
			SString TargetRootPath;  // PPINIPARAM_BUILDTARGET   Корневой каталог, в котором должна собираться версия (C:\PPY)
			SString NsisPath;        // PPINIPARAM_BUILDNSIS     Путь к исполняемому файлу NSIS (сборщик дистрибутива)
			SString DistribPath;     // PPINIPARAM_BUILDDISTRIB  Корневой каталог, хранящий дистрибутивы
		};
		TSCollection <ConfigEntry> ConfigList;
	};

	static int FindMsvs(int prefMajor, StrAssocArray & rList, SString * pPrefPath);
	static int FindMsvs2(int prefMajor, StrAssocArray & rList, SString * pPrefPath);
	int	   InitParam(Param *);
	int	   EditParam(Param *);
	int	   Init(const Param *);
	int	   Run();
	int    Build();
	int    BuildLocalDl600(const char * pPath);
	Param::ConfigEntry * SetupParamByEntryIdx(Param * pParam, int supplementalConfig);
private:
	static int CopyProgressProc(const SDataMoveProgressInfo * scfd); // SDataMoveProgressProc
	int	   UploadFileToUhtt(const char * pFileName, const char * pKey, const char * pVerLabel, const char * pMemo);
	int	   InitConfigEntry(PPIniFile & rIniFile, const char * pSection, Param::ConfigEntry * pEntry);
	int    Helper_Compile(const Param::ConfigEntry * pCfgEntry, int supplementalConfig, PPLogger & rLogger);

	Param  P;
};
//
// Descr: Функции обслуживания исходных кодов системы.
//
class PrcssrSourceCodeMaintainingFilt : public PPBaseFilt {
public:
	PrcssrSourceCodeMaintainingFilt();
	PrcssrSourceCodeMaintainingFilt & FASTCALL operator = (const PrcssrSourceCodeMaintainingFilt & rS);

    uint8  ReserveStart[128]; // @anchor
	enum {
		fParseWinRcForNativeText           = 0x0001,
		fFindSourceCodeWithNotUtf8Encoding = 0x0002,
		fVerifySourceCodeByPatterns        = 0x0004 // @v12.3.2 
	};
	long   Flags;
	long   Reserve;          // @anchor	
};

class PrcssrSourceCodeMaintaining {
public:
	PrcssrSourceCodeMaintaining();
	int	   Init(const PPBaseFilt * pBaseFilt);
	int    InitParam(PPBaseFilt * pBaseFilt);
	int    EditParam(PPBaseFilt * pBaseFilt);
	int	   Run();
private:
	struct NoticedFileEntry {
		NoticedFileEntry() : LineNo(0)
		{
		}
		uint   LineNo; // 0 - undefined
		SString FileName;
	};
	int    ParseWinRcForNativeText(PPLogger * pLogger);
	int    FindSourceCodeWithNotUtf8Encoding(PPLogger * pLogger);
	int    VerifyByPatterns(PPLogger * pLogger);

	PrcssrSourceCodeMaintainingFilt P;
	SString BuildRootPath;
	SString SrcPath;
};
//
// Descr: Класс, управляющий инфраструктурой тестирования сложных объектов в базе данных.
//   Как обычно, этим классом я пытаюсь обобщить все ошметки тестирования оъектов в базе данных,
//   которые были сделаны до сих пор.
// 
// Далее общие замечания по тестированию (будут расширяться).
// Символы тегов, идентифицирующих тестовые объекты в базе данных:
//   pptest-bill
//   pptest-goods
//   pptest-person
//   pptest-location
//   pptest-posnode
//   pptest-ccheck
//   pptest-prc
//   pptest-tsess
//   pptest-computer
//   pptest-lot
//   pptest-gua
//   Все теги, идентифицирующие тестовые объекты, строковые. В значениях тегов будут указываться специальные
//   символы и мнемоники, обозначающие назначение тестового объекта.
//   У объекта PPObjGoodsTax тегов нет, потому для них будем использовать специальные символы
//
class PPTestDbInfrastructure { // @v12.2.4 @construction
public:
	PPTestDbInfrastructure();
	~PPTestDbInfrastructure();
	int    SetupDatabaseObjects();
	
	int    _Case_TaxEvaluation(); // Это будет первой задачей для нашего амбициозного субпроекта PPTestDbInfrastructure :)
private:
};
//
// @v12.2.5 
// Descr: Специальный модуль, реализующий шлюз между древней-предревней системой управления розничным магазином Кристалл и 
//   кассовым модулем Set-Retail.
//
class Cristal2SetRetailGateway {
public:
	struct CmdParam {
		CmdParam();
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			actReadCristalSrcData   = 0x0001, 
			actWriteCristalDestData = 0x0002
		};
		uint32 Version;
		int32  Actions;
		uint32 Flags;
		uint8  Reserve[64];
	};
	enum {
		eefMinus = 0x0001 // Ведущее поле записи содержит '-' (а не '+')
	};
	//
	// Descr: Элемент данных, импортируемый из системы Кристалл.
	//   Здесь будут товары, группы товаров, дисконтные карты и, вероятно, еще что-то.
	//
	struct ErpGoodsEntry { // @flat
		ErpGoodsEntry();

		long   ID;
		uint   Flags;
		long   GoodsGroupID;
		double Price;
		double VatRate;
		double AlcVolume;
		double AlcProof;
		char   GoodsNameS[128]; // Короткое наименование товара
		char   GoodsNameF[128]; // Полное наименование товара (из 2 частей)
		char   Barcode[32];
		char   UomName[48];
		char   GoodsGroupName[128];
		char   MarkingSymb[32]; // Тут хранится символ типа товара chzn, а для крепкого алкоголя - какие-то непонятные числовые коды.
	};
	struct ErpWeightedGoodsEntry {
		ErpWeightedGoodsEntry();
		long   ID;	
		uint   Flags;
		long   PLU;
		double Price; // Цена за 1кг
		char   GoodsNameF[128]; // Полное наименование товара (из 2 частей)
	};
	struct ErpSCardEntry {
		ErpSCardEntry();

		uint   Flags;
		double PctDis;
		char   CodeRangeStart[32];
		char   CodeRangeEnd[32];
	};
	class CristalImportBlock {
	public:
		TSVector <ErpGoodsEntry> List1;
		TSVector <ErpWeightedGoodsEntry> List2; 
		TSVector <ErpSCardEntry> List3;
	};
	Cristal2SetRetailGateway();
	~Cristal2SetRetailGateway();
	int    EditCmdParam(CmdParam & rData);
	int    Process(const CmdParam & Param);
	//
	int    Helper_CristalImportDir(const char * pPathUtf8, Cristal2SetRetailGateway::CristalImportBlock & rIb, const char * pLogFilePath);
	//
	// Descr: Импортирует текстовый файл, подготовленный системой Кристалл.
	//   Файлы в кодировке cp866, разделители полей '|'.
	//
	int    CristalImport(const char * pPathUtf8, Cristal2SetRetailGateway::CristalImportBlock & rIb);
};
//
// Descr: Возвращает минимальный множитель, цены кратные которому
//   дают расчет суммы НДС без остатка.
//   Множитель возвращается долях денежной единицы, определяемых параметром prec
// ARG(rate IN): ставка НДС (в долях от единицы, например - 0.20 (20%))
// ARG(prec IN): @{0..6} точность представления результата. 0 - до целых значений,
//   3 - с точностью 0.001 и т.д.
//
ulong  GetMinVatDivisor(double rate, uint prec);
int    PPCalcExpression(const char *, double * pResult, const PPCalcFuncList *);
int    PPCalcExpression(const char *, double * pResult, PPBillPacket *, PPID curID, uint advItemIdx);
int    PPCalcExpression(const char *, double * pResult, GdsClsCalcExprContext * pCtx);
int    CalcPrice(CalcPriceParam *);
int    CalcDiff(double amount, double * pDiff);
int    CalcTaxPrice(PPID goodsID, PPID opID, LDATE, double price, int = 0);
int    CloseCashDay();
int    STDCALL SelectorDialog(uint dlgID, uint ctlID, uint * pVal /* IN,OUT */, const char * pTitle = 0);
//
// Descr: функция для выбора элемента из списка
//
class ListBoxSelDialog : public PPListDialog {
public:
	static int STDCALL Run(PPID objID, PPID * pID, void * extraPtr);
	static int STDCALL Run(StrAssocArray * pAry, uint titleStrId, PPID * pID/*, uint flags*/);
	static int STDCALL Run(StrAssocArray * pAry, const char * pTitle, PPID * pID/*, uint flags*/);
	static int STDCALL Run(StrAssocArray * pAry, const char * pTitle, PPIDArray * pIdList/*, uint flags*/); // @v11.4.3 @construction
	static int STDCALL Run(uint dlgID, StrAssocArray * pAry, PPID * pID/*, uint flags*/);
private:
	explicit ListBoxSelDialog(ListBoxDef * pDef, uint dlgID, uint flags/*PPListDialog::fXXX*/);
	int    setDTS(PPID id);
	int    getDTS(PPID * pID);
	virtual int  setupList();
	virtual int  editItem(long pos, long id);
	ListBoxDef * P_Def;
};

int    ComboBoxSelDialog2(const StrAssocArray & rAry, uint subTitleStrId, uint labelStrId, long * pSelectedId, uint flags);
int    AdvComboBoxSelDialog(const StrAssocArray & rAry, SString & rTitle, SString & rLabel, PPID * pID, SString * pName, uint flags);
//
#define INIREPF_FORCELANDSCAPE 0x0001L
#define INIREPF_NOSHOWDIALOG   0x0002L
//
int    CorrectAccTurnRest();
int    CorrectCurRest();
int    RecalcBillTurns(int checkAmounts);
int    RemoveEmptyAcctRels();
int    STDCALL EditSysjFilt2(SysJournalFilt * pFilt);
#define OBJTRNSMDLGF_SEARCHDTTM 0x00000001
int    STDCALL ObjTransmDialog(uint dlgID, ObjTransmitParam *, long dlgFlags = 0);
int    STDCALL ObjTransmDialogExt(uint dlgID, int viewId, ObjTransmitParam * pParam, PPBaseFilt * pFilt, long dlgFlags = 0);
//
// Descr: Проверяет корректность создания и загрузки диалога.
//   С этой функцией вышел легкий прокол. Фактически ей должен
//   передаваться параметр типа (TDialog **), однако уродский C++ не
//   позволяет использовать неявное преобразование к этому типу от
//   указателя на класс, порожденного от TDialog. Необходимо быть
//   внимательным с этой функцией, примерный вызов следующий:
// Sample:
//   DerivedDialog * dlg = new DerivedDialog; // DerivedDialog порожден от класса TDialog.
//   THROW(CheckDialogPtr(&dlg));
// ARG(ppDlg IN/OUT): указатель на указатель созданного диалога. (TDialog **)
//   Если функция идентифицировала ошибку в диалоге, то диалог *ppDlg будет
//   ею же и разрушен. В результате *ppDlg получит 0.
// ARG(genErrMsg IN): если этот параметр !0, то функция выведет на экран сообщение
//   об ошибке.
// Returns:
//   !0 - диалог *ppDlg корректен
//   0  - диалог *ppDlg не корректен
//
int    FASTCALL CheckDialogPtr(void * ppDlg/*, int genErrMsg = 0*/);
int    FASTCALL CheckDialogPtrErr(void * ppDlg);
//
// Descr: Вызывает функцию сообщения об ошибке PPError(err, 0) и делает активным элемент диалога ctlID.
// Returns:
//   0 - всегда. Для того, чтобы можно было быстро инициализировать значение, возвращаемое вызывающей функцией.
//
int    STDCALL PPErrorByDialog(TDialog * dlg, uint ctlID, int err);
//
// Descr: То же, что и PPErrorByDialog(TDialog * dlg, uint ctlID, int err), но
//   аргумент err = -1. Отдельная функция сделана ради уменьшения размера кода (чаще вызывается именно так).
// Return:
//   0 - всегда. Для того, чтобы можно было быстро инициализировать значение, возвращаемое вызывающей функцией.
//
int    STDCALL PPErrorByDialog(TDialog * dlg, uint ctlID);
uint   STDCALL GetComboBoxLinkID(TDialog *, uint comboBoxCtlID);
int    STDCALL SetComboBoxLinkText(TDialog *, uint comboBoxCtlID, const char * pText);
//
// Descr: Блок параметров функции InputStringDialog()
//
struct PPInputStringDialogParam {
	explicit PPInputStringDialogParam(const char * pTitle = 0, const char * pInputTitle = 0);
	~PPInputStringDialogParam();

	enum {
		fDisableSelection = 0x0001, // Не реализуется полное выделение строки ввода
		fInputMemo        = 0x0002  // Подставляется диалог DLG_MEMO
	};
	long   Flags;
	SString Title;      // Текст заголовка диалога
	SString InputTitle; // Текст заголовка строки ввода
	WordSel_ExtraBlock * P_Wse; // @owned
};
//
// Descr: Вызывает простой диалог, содержащий строку ввода, ограниченную 64 байтами.
// ARG(pParam           IN): @#{vptr0} Блок параметров диалога
// ARG(rBuf         IN/OUT): Строка, передаваемая в поле ввода. Если пользователь ввел какую-либо
//   строку и подтвердил ввод, нажав ОК, то в этом буфере вернется то, что он ввел.
// Returns:
//   >0 - пользователь подтвердил ввод строки
//   <0 - пользователь отказался от ввода
//   0  - ошибка
//
int    FASTCALL InputStringDialog(PPInputStringDialogParam * pParam, SString & rBuf);
int    InputDateDialog(const char * pTitle, const char * pInputTitle, LDATE * pDate);
int    DateRangeDialog(const char * pTitle, const char * pInputTitle, DateRange & rPeriod);

struct DateAddDialogParam {
	DateAddDialogParam();
	int    Recalc();

	LDATE  BaseDate;
	long   Period;
	long   PeriodCount;
	LDATE  ResultDate;
};

int    DateAddDialog(DateAddDialogParam * pData);
int    InputQttyDialog(const char * pTitle, const char * pInputTitle, double *);
int    InputNumberDialog(const char * pTitle, const char * pInpTitle, double & rValue);
int    BigTextDialog(uint maxLen, const char * pWindowTitle, const char * pSubTitle, SString & rText);
//
// Descr: Устанавливает в строке комбо-бокса текст 'Список'
//
int    STDCALL SetComboBoxListText(TDialog *, uint comboBoxCtlID);
int    STDCALL SetupStringCombo(TDialog *, uint ctlID, int strID, long initID);
int    STDCALL SetupStringCombo(TDialog *, uint ctlID, const char * pStrSignature, long initID);
int    STDCALL SetupStringComboWithAddendum(TDialog * dlg, uint ctlID, const char * pStrSignature, const StrAssocArray * pAddendumList, long initID);
// id = <string offset> + 1
int    SetupStringComboDevice(TDialog *, uint ctlID, uint dvcClass, long initID, uint /*flags*/); //@vmiller
int    GetDeviceTypeName(uint dvcClass, PPID deviceTypeID, SString & rBuf);
int    GetStrFromDrvIni(PPIniFile & rIniFile, int iniSectID, long devTypeId, int numOfOldDev, SString & str); // @vmiller
int    STDCALL SetupStrAssocCombo(TWindow * dlg, uint ctlID, const StrAssocArray & rList, long initID, uint flags, size_t offs = 0, int ownerDrawListBox = 0);
int    STDCALL SetupSCollectionComboBox(TDialog * dlg, uint ctl, SCollection * pSC, long initID);
int    STDCALL ViewSysJournal(const SysJournalFilt *, int modeless);
int    STDCALL ViewSysJournal(PPID objType, PPID objID, int modeless);
int    ChangeBillFlagsDialog(long * pSetFlags, long * pResetFlags, PPID * pStatusID);
int    EditRightsDialog(PPRights &);
int    GenericObjRightsDialog(PPID obj, ObjRights *, EmbedDialog * = 0);
//
// Descr: выдает на экран диалог с запросом ввода пароля и подтверждения.
//   Если параметр dlgID == 0, то используется стандартный диалог (DLG_PASSWORD).
//   В противном случае будет использоваться указанный диалог. В нем должны
//   присутствовать поля ввода CTL_PASSWORD_FIRST и CTL_PASSWORD_SECOND.
//
int    PasswordDialog(uint dlgID, char * pBuf, size_t bufSize, size_t minLen, int withoutEncrypt = 0);
int    UpdatePassword();
int    UnifyGoodsPrice();
//int    SelectLot__(PPID loc, PPID goods, PPID exclude, PPID * pLotID, ReceiptTbl::Rec *);
int    EditMainConfig();
int    EditCommConfig(); // COMMCFG.CPP
int    EditCurrConfig(); // COMMCFG.CPP
int    EditQCertDialog(QualityCertTbl::Rec * aRec, int viewOnly);
int    ViewQCertDialog(PPID);
int    ExecCSPanel(const CashNodePaneFilt *);
int    SelectCSession(PPID cashNodeID, PPID extCashNodeID, CSessInfo * pInfo);
int    AsyncCashnPrepDialog(AsyncPosPrepParam * pParam);
int    FASTCALL ListToListDialog(ListToListData *);
int    UISettingsDialog();
int    GoodsFilterDialog(GoodsFilt *);
int    GoodsFilterAdvDialog(GoodsFilt *, int disableLocSel);
int    CreateBizScGlblUserAcct();
//
// Descr: Возвращает прогноз продаж товара goodsID по набору складов pLocList на период pPeriod.
//
int    GetEstimatedSales(const ObjIdListFilt * pLocList, PPID goodsID, const DateRange * pPeriod, double * pQtty);
//
// Descr: Флаги опций просмотра ассоциаций товар-объект
//
enum {
	goafModal  = 0x0001, // Модальное окно
	goafFreeExtraAsPtr = 0x0002  // extraParam является указателем, который следует разрушить
		// при разрушении броузера.
};
//
// Descr: Вызывает броузер для просмотра ассоциаций товар-объект.
// ARG(objType    IN): Тип объектов, с которыми ассоциированы товары
// ARG(objID      IN): ИД объекта, которым необходимо ограничить просмотр ассоциаций
// ARG(asscType   IN): Тип ассоциации
// ARG(extraParam IN): Дополнительный параметр для выбора объекта
// ARG(options    IN): Опции (goafXXX)
//
int    ViewGoodsToObjAssoc(PPID objType, PPID objID, PPID asscType, void * extraPtr, long options = 0);
	// @uses(PPViewGoodsToObjAssoc)
int    ViewGoodsToLocAssoc(PPID locID, PPID asscType, const LocationFilt * pLocFilt, long options = 0);
int    ViewGoodsToObjAssoc(long extraParam);
int    FASTCALL SetupStrListBox(TView *);
int    FASTCALL SetupStrListBox(TDialog *, uint ctl);
int    SetupTreeListBox(TDialog * dlg, uint ctl, StrAssocArray * pData, uint fl, uint lbfl);
int    EditDefaultPrinterCfg();
int    AmountListDialog(AmtList *, PPIDArray * pRestrictList, LDATE cRateDate, const char * pTitle, uint options);
//
// Descr: Флаги функции CCheckPane()
//
enum {
	cchkpanfOnce = 0x0001 // Закрыть панель после проведения первого чека
};

int    CCheckPane(PPID cashNodeID, PPID checkID, const char * pInitLine = 0, long flags = 0);
int    ViewCashNodes();
int    ViewPerson(const PersonFilt *);
int    EditELinks(const char * pInfo, PPELinkArray * pList);
int    EditMainOrg();
int    ViewShipmAnalyze(ShipmAnalyzeFilt *);
int    ViewGoodsRest(const GoodsRestFilt *, int);
int    GoodsRestTest();
int    ViewAccAnlz(const AccAnlzFilt *, AccAnlzKind);
int    EditPriceListConfig();
int    ViewGoodsTaxAnalyze(const GoodsTaxAnalyzeFilt *);
int    ViewGoodsOpAnalyze(const GoodsOpAnalyzeFilt *);
int    ViewArticle(const ArticleFilt *);
int    ViewOpGrouping(const OpGroupingFilt *);
int    ViewCCheck(const CCheckFilt *, int execFlags);
int    ViewTrfrAnlz(const TrfrAnlzFilt *);
int    ViewSCard(const SCardFilt *, int _modeless);
int    ViewAddressBook();
int    SelectAddressFromBook(PPID * pSelPersonID, SString & rAddr);
int    ViewBillDetails(PPBillPacket * pPack, long options, PPObjBill *);
int    ViewMrpTab(const MrpTabFilt *);
int    ViewDLSDetail(const DLSDetailFilt & rFilt);
// @todo Member of PPObjOpCounter
int    EditCounter(PPOpCounterPacket * pPack, uint resID, PPID * pOpcID = 0); // AHTOXA
//
//
//
#define ISHIST_LEFTBILL  1
#define ISHIST_RIGHTBILL 2
#define ISHIST_BOTHBILL  3
#define ISHIST_NOTHING   4
int    ViewGoodsBillCmp(PPID lhBillID, const PPIDArray & rRhBillList, int _modeless, int whatBillIsHistory = ISHIST_NOTHING, const LDATETIME * pLhEvDtm = 0, const LDATETIME * pRhEvDtm = 0);
int    ViewPrjTask(const PrjTaskFilt *);
int    ViewPrjTask_ByStatus(); // Вызывается по двойному щелчку мыши в окне статуса (показать все непросмотренные задачи)
int    ViewPrjTask_ByReminder(); //  Вызывается по двойному щелчку мыши в окне статуса (показать все невыполненные задачи за определенный период)
int    ViewQuot(const QuotFilt *);
int    ViewTech(const TechFilt *);
int    ViewTSession(const TSessionFilt *);
int    ViewManufPlan(const TSessionFilt *);
int    ViewTSessLine(const TSessLineFilt *);
int    AnalyzeObjSyncCmp(int _modeless);
int    ViewObjSyncTab(PPObjID oid);
int    ViewJobPool();                         // @defined(ppjob.cpp)
int    ViewLogs();
int    DatabaseCutting();
//
// Descr: Функция возвращает указатель на строку сигнатуры кнопки, управляющей отображением календаря.
//   Сигнатура необходима для идентификации типа кнопки посредством вызова TView::GetWindowProp(hWnd, GWLP_USERDATA)
//   Если указатель на пользовательские данные не нулевой и в начале содержится строка сигнатуры, возвращаемая
//   GetCalCtrlSignature, то кнопка относится к искомому типу.
//
const  char * GetCalCtrlSignature(int type);
void   ShowCalCtrl(int buttCtlID, TDialog * pDlg, int show);
int    Import(PPID objType, long extraParam = 0);
int    ImportBanks();
int    ImportSpecSeries();
int    ImportKLADR();
int    ImportInventory();
int    ImportSR25(); // @vmiller
int    ImportCompGS(); // @vmiller
int    ImportPhoneList();
int    ImportWorkbook();
int    ImportSCard();
int    ImportSwProgram(); // @v12.0.4
//int    ImportPosRefs(TSCollection <PPPosProtocol::QueryProcessBlock> * pQpBlkList);
int    SetDatabaseChain();
int    DBMaintenance(PPDbEntrySet2 *, int autoMode);
int    ViewFiltPool(); // @paul pentaho @defined(v_filtp.cpp)

struct DBMaintainParam {
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long) const;
	enum {
		tblDLS  = 0x00000001,
		tblMRP  = 0x00000002,
		tblSJ   = 0x00000004,
		tblXBill        = 0x00000008,
		tblRsrvSj       = 0x00000010,  // Восстанавливать в системном журнале записи из резервной таблицы
		tblXBillRecover = 0x00000020,  // Удалять висящие записи строк, идентификатор которых больше последнего идентификатора документа
		tblTempAltGGrp  = 0x00000040,  // Удалять временные альтернативные группы
		tblMoveObsolete = 0x00000080   // Переместить устаревшие файлы данных
	};

	int16 DLSDays;
	int16 MRPDays;
	int16 SJDays;
	int16 XBillDays;
	long  Tables;
};

int    DBMaintainDialog(DBMaintainParam *);
int    DoDBMaintain(const DBMaintainParam * pParam);
int    ReadDBMaintainCfg(DBMaintainParam *);
int    EditDBMaintainCfg();
int    EditJobBackupParam(SString & rDBSymb, PPBackupScen * pScen);
int    DeleteTmpFiles();
int    FillPredictSales();
int    TestPredictSales();
int    TestReconnect();
int    FASTCALL PPOpenBrowser(BrowserWindow *, int modeless);
void   FASTCALL PPCloseBrowser(TBaseBrowserWindow *);
BrowserWindow * PPFindLastBrowser();
STimeChunkBrowser * PPFindLastTimeChunkBrowser();
PPPaintCloth * PPFindLastPaintCloth();
int    InitSTimeChunkBrowserParam(const char * Symbol, STimeChunkBrowser::Param * pParam);
//
// Descr: Варианты обработки товарного дефицита
//
enum PUGP {
	pugpFull      = 1,
	pugpZero      = 2,
	pugpNoBalance = 3
};

int    ProcessUnsuffisientGoods(PPID goodsID, PUGP param);
int    ProcessUnsuffisientList(uint dlgID, PUGL * pList);
int    SelectGoods(PPID & rGoodsID);
int    EditObjMemos(PPID objTypeID, PPID prop, PPID objID);
int    PutObjMemos(PPID objTypeID, PPID prop, PPID objID, const SString & rMemos, int useTa);
void   SetupTimePicker(TDialog * pDlg, uint editCtlID, int buttCtlID);
int    SynchronizeObjects(PPID dest);
int    CorrectLotsCloseTags();
int    CorrectLotSuppl();
int    CorrectZeroQCertRefs();
int    CorrectZeroDebtDimRefs();
int    CorrectAccturn();       // PPACC\C_ATURN.CPP
int    EditQuotVal(PPQuot * pQ, int quotCls);
int    EditQuotUpdDialog(QuotUpdFilt * pFilt);
int    ViewQuotValueInfo(const PPQuot & rQuot);
int    UpdateQuots(const QuotUpdFilt *);
int    EditQuotRollbackDialog(LDATETIME *pDateTime); // @erik v10.5.8
int    RollbackQuots(const LDATETIME * pDateTime); // @erik v10.5.8
int    MakeCRptDataFiles(int verifyAll = 0);    // PPLIB\PPTVUTIL.CPP
SString & GetCrr32ProxiPipeName(SString & rBuf); // @v11.9.5
int    RecoverAbsenceLots();   // PPBILL\C_TRFR.CPP
int    RecoverAbsenceGoods();  // PPBILL\C_TRFR.CPP
int    RecoverAbsenceBills();  // Восстановление потерянных заголовков документов
int    RecoverAbsenceAccounts(); // Восстановление отсутствующих счетов
int    RecoverGoodsGroups(const GoodsGroupRecoverParam * pParam);
	// @<<cmCorrectGoodsGroups
	// @>>PPObjGoodsGroup::Recover
int    RecoverGoodsGroupsNIA();
int    RecoverTransfer();
//
// Descr: Удаление "плохих" зачетов
//
int    RemoveBadReckons();
int    CurReval();
int    RestoreBalance();
int    SaveBalance();
int    MakeDatabase();
// @unused int    UpdateLicense();
// @unused int    Registration();
//
// Descr: Интерактивная функция, вызывающая диалог добавления товара goodsID
//   в товарную корзину. Корзина может быть выбрана прямо в этом диалоге.
//   Если goodsID == 0, то функция ничего не делает.
//   Параметр defLocID определяет, с какого склада брать текущие данные по товару
//   (цену, срок годности, емкость упаковки и т.д.)
//
int    AddGoodsToBasket(PPID goodsID, PPID defLocID, double qtty = 0.0, double price = 0.0);
int    RevalAssets();
int    WriteOffDrafts(const PPIDArray * pCSessList);
int    ProcessDL200();
int    ProcessGoodsSaldo();
//
// Descr: Редактирование списка выходных для прогнозирования //
//
int    EditHolidays();
int    ViewGoodsInfo(const InfoKioskPaneFilt * pFilt);
int    STDCALL ViewSCardInfo(PPID * pSCardID, PPID posNodeID, int asSelector);
//
// Descr: Отображает список товарных позиций, соответсвующих забракованной серии pSerial
//
int    ViewSpoilList(SpecSeriesCore * pTbl, const char * pSerial, int useText);
int    SendCharryObject(PPID strucID, const PPIDArray & rObjIdList);
int    SendCharryFiles();
int    ReceiveCharryObjects(const RcvCharryParam * pParam);
//
// Descr: Вызывает функцию обслуживания задач объекта PPObjPrjTask.
//   Перед вызовом требует подтверждения пользователем
// Returns:
//   >0 - Функция успешно выполнена
//   <0 - Функция отклонена пользователем
//   0  - Ошибка
//
int    MaintainPrjTask();      // @>>PPObjPrjTask::Maintain
int    ExecPrcPane(PPID prcID);
//
// Поддержка импорта-экспорта в клиент-банк
//
int    SetupCliBnkFormats();
int    SetupCliBnkAssoc();
int    CliBnkImport();
int    CliBnkSelectCfgDialog(int direction /*1 - export, 2 - import*/, SString & rSection);
int    ConvertRbcBnk(const char * pPath);
//
// Descr: Вызывает диалог конфигурирования импорта специальных серий
//
int    EditSpecSeriesFormatDescription();
//
// Descr: Вызывает диалог просмотра картинки и информации ей сопутствующей
//
int    ViewImageInfo(const char * pImagePath, const char * pInfo, const char * pWarn);
int    EditImpExpParams(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pParamDlg);
int    EditBillImpExpParams(int editBill);
int    EditInventoryImpExpParams();
int    EditGoodsImpExpParams(const char * pIniSection);
int    EditGoodsImpExpParams();
int    EditImpExpConfigs();
int    ImportBills(PPBillImpExpParam * pBillParam, PPBillImpExpParam * pBRowParam, PPID opID, PPID locID);
int    ImportCChecks(PPCCheckImpExpParam * pParam);
int    ImportEmailAccts();
int    ExportEmailAccts(const PPIDArray * pMailAcctsList);
// @v12.0.5 @unused int    SupplGoodsImport();
// @v12.0.5 @unused int    EditSupplExpFilt(SupplExpFilt * pFilt, int selOnlySuppl);
int    DoSupplInterchange(SupplInterchangeFilt * pFilt);
int    DoMarketplaceInterchange();
int    DoAptekaRuInterchange(); // @v12.2.1
int    DoSourceCodeMaintaining(const PrcssrSourceCodeMaintainingFilt * pFilt); // @v12.2.10
int    GatherClientActivityStatistics(); // @v12.2.2 @construction
int    EditPriceListImpExpParams();
int    EditDebtLimList(PPClientAgreement & rCliAgt);
int    EditCheckInPersonItem(const PPCheckInPersonConfig * pCfg, PPCheckInPersonItem * pData);
int    EditCheckInPersonList(const PPCheckInPersonConfig * pCfg, PPCheckInPersonArray * pData);
void   PPViewTextBrowser(const char * pFileName, const char * pTitle, const char * pLexerSymb, int toolbarId = -1);

class EditTextFileParam : public PPBaseFilt {
public:
	EditTextFileParam();
	uint8  ReserveStart[32]; // @anchor
	long   Flags;
	uint8  ReserveEnd[32];   // @reserve
	SString FileName;
};

int    PPEditTextFile(const EditTextFileParam * pParam);
int    DoDbDump(PPDbEntrySet2 * pDbes);
int    VerifyPhoneNumberBySms(const char * pNumber, const char * pAddendum, uint * pCheckCode, int checkCodeInputOnly);

struct ResolveGoodsItem {
	explicit ResolveGoodsItem(PPID goodsID = 0);

	PPID   GoodsID;
	PPID   ResolvedGoodsID;
	PPID   ArID;              // Статья, с которой связан код ArCode
	double VatRate;           // Ставка НДС (в процентах)
	char   GoodsName[128];
	char   Barcode[252];      // @v11.4.5 (24)-->(252) Увеличили поле для акцепта списка кодов
	char   ArCode[24];        // Код, ассоциированный со статьей ArID
	char   ManufName[128];    // Наименование производителя
	char   GroupName[128];    // Наименование товарной группы
	char   BrandName[128];    // Наименование бренда
	double Quantity;
};

class ResolveGoodsItemList : public TSArray <ResolveGoodsItem> {
public:
	ResolveGoodsItemList();
	ResolveGoodsItemList(const ResolveGoodsItemList & s);
	ResolveGoodsItemList & FASTCALL operator = (const ResolveGoodsItemList & s);
	ResolveGoodsItemList & FASTCALL operator = (const PPIDArray & s);
};
//
// Descr: Разрешает с помощью диалога неизвестные системе товары
//
#define RESOLVEGF_RESOLVEALLGOODS 0x0001 // Выдавать ошибку, если не все товары были разрешены
#define RESOLVEGF_SHOWBARCODE     0x0002 // Показывать вместе с именем товара штрихкод
#define RESOLVEGF_SHOWQTTY        0x0004 // Показывать вместе с именем товара количество
#define RESOLVEGF_MAXLIKEGOODS    0x0008 // Выдавать список товаров для подстановки по нечеткому поиску
#define RESOLVEGF_SHOWRESOLVED    0x0010 // Показывать товары для которых подстановка уже выполнена
#define RESOLVEGF_SHOWEXTDLG      0x0020 // Отображать диалог DLG_SUBSTGL

int ResolveGoodsDlg(ResolveGoodsItemList * pData, int flags);
//
// @v11.9.5 @construction Структуры и функции для работы 32-битного proxi-сервера CristalReports
//

//
// Конвертация сертификатов качества в теги лотов (для Лэнда).
//
// @v12.2.2 int ConvertLandQCertToLotTag();
//int Convert329();
//int Convert3512();  // Перенесено в Convert4405
int Convert372();
//int Convert380();   // Перенесено в Convert4405
int Convert31102();
int Convert31110();
int Convert400();
int Convert4108();
// @v6.2.2 int Convert4208();
int Convert4405();
int Convert4515();
int Convert4707();
int Convert4802();
int Convert4805();
int Convert4911();
// [Перенесено в Convert6202()] int Convert5006();    // VADIM
int Convert5009();
int Convert5200();
int Convert5207();
int Convert5501();
// [Перенесено в Convert6202()] int Convert5506();    // @v5.5.6 VADIM
// [Перенесено в Convert6202()] int Convert5512();    // @v5.5.12 Добавился индекс к таблице World
int Convert5608();    // ObjSync Значительное изменение
int Convert5810();    // Reference-->Reference2; CGoodsLine
int Convert6202();    // (SpecSeries значительное изменение) +
int Convert6303();
int Convert6407();
int Convert6611();
// [Перенесено в Convert7601()] int Convert6708();    // @v6.7.8
// @v12.2.6 int Convert7311();
int ConvertQuot720();
int Convert7305();
// @v11.1.12 moved to PPCvtTech11112 int Convert7506();
int Convert7601();
// @v9.4.0 int Convert7702();
int Convert7708();
int Convert7712();
int Convert7907();
// @v8.3.6 int Convert8203();
// @v12.0.0 int Convert8306();
int Convert8800();
int ConvertWorkbook813();
int Convert8910();
// @v9.0.4 int Convert9003();
int Convert9004(); // @v9.0.4
int Convert9108(); // @v9.1.8
int Convert9214(); // @v9.2.14
int Convert9400(); // @v9.4.0
int Convert9811(); // @v9.8.11
int ConvertSCardSeries9809(); // @v9.8.9 (objscard.cpp)
// @10.2.9 int Convert10012(); // @v10.0.12
int Convert10209(); // @10.2.9
int Convert10507(); // @v10.5.7 Scale
int Convert10702(); // @v10.7.2 projects and todo
int Convert10703(); // @erik @v10.7.2 desktops
int Convert10903(); // @v10.9.3
int Convert10905(); // @v10.9.5 EgaisRefA
int Convert11004(); // @v11.0.4 TSessLine
int Convert11112(); // @v11.1.12 Bill
int Convert11200(); // @v11.2.0 Соглашения с клиентами
int Convert12000(); // @v12.0.0 Регистры (увеличились длины серии и номера регистра)
int Convert12005(); // @v12.0.5 SCardOp (добавлены поля CtAmount & CtRest для количественного учета)
int Convert12207(); // @v12.2.7 VATBook (добавлены дополнительные поля для новых ставок НДС, увеличены длины номеров документов, перестроен порядок полей)
int DoChargeSalary();
int DoDebtRate();
int DoBizScore(PPID bzsID);
int DoProcessObjText(const PrcssrObjTextFilt * pFilt);
int DoProcessOsm(PrcssrOsmFilt * pFilt);
int DoProcessSartre(PrcssrSartreFilt * pFilt);
int DoConstructionTest();

template <typename Dlg, typename D> int PPDialogProcBodyID(uint dlgID, D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg(dlgID);
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

template <typename Dlg, typename D> int PPDialogProcBody(D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg;
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

template <typename Dlg, typename D> int PPDialogProcBody(uint dlgId, D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg(dlgId);
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

#define DIALOG_PROC_BODY(dlg_class, data_param)          \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class;                         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODYERR(dlg_class, data_param)        \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class;                         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P1(dlg_class, param1, data_param) \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1);                 \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P2(dlg_class, param1, param2, data_param) \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1, param2);         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P1ERR(dlg_class, param1, data_param) \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1);                 \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P2ERR(dlg_class, param1, param2, data_param) \
int    ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1, param2);         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;
//
//
//
#endif // } __PP_H
