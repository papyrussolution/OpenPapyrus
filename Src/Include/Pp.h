// PP.H
// Copyright (c) A.Sobolev 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
// @codepage UTF-8
//
// Спасибо за проделанную работу:
//   Насонову Вадиму (VADIM), Стародубу Антону (AHTOXA), Казакову Михаилу (Muxa), Миллер Владиславе (vmiller),
//   Осолоткину Алексею [rip], Антонову Валерию, Симанову Александру [rip], Курилову Андрею (Andrew)
//
//  Соглашение об обозначениях:
//
//  @v9.99.99 - номер версии, в которой добавлена или изменена строка. Набор строк, измененных в
//  в этой версии обрамляется так:
//  // @v9.99.99 {
//  ...
//  // } @v9.99.99
//
//  @<<FunctionName - имя функции, которая вызывает ту функцию, которая помечена этим обозначением
//	  Обычно это обозначение следует строкой ниже объявления функции, к которой относится //
//
//  @>>FunctionName - имя функции, которую вызывает та функция, которая помечена этим обозначением
//	  Обычно это обозначение следует строкой ниже объявления функции, к которой относится //
//
//  @attention - комментарии, учет которых крайне важен для корректного функционирования системы
//
//  @global - глобальные переменные. Критичны для многопоточного испольнения. Если за этим обозначением
//    следует @threadsafe, то в программном коде приняты меры для того, чтобы эта переменная //
//    была безопасна для многопоточного испольнения.
//
// @transient - этим признаком помечаются флаги, поля структур, сами структуры, которые не сохраняются //
//    в базе данных или в каких-либо файлах. Признак контекстно-зависимый: используется тогда, когда
//    в контексте какого-либо сожержания необходимо подчеркнуть, что некоторый объект не будет
//    сохраняться в базе данных или файле передачи данных.
// @flat - помечаются стрктуры, которые обязательно должны быть "плоскими". То есть не иметь в своем
//    составе указателей, и сложных объектов.
// @persistent - этим признаком помечаются структуры, которые сохраняются в базе данных или
//    в каком-либо файле. Признак контекстно-зависимый.
// @used FunctionName | ClassName - имя функции или класса, использующего переменную или класс,
//    которые помечены этим признаком
// @cstr - помечаются строки кода, использующие строковые константы, которые должны находится в ресурсах
//
// @# - Строгое утверждение, которое должно выполняться //
//      далее могут следовать следующие формальные обозначения:
//        vptr      - допустимый указатель
//        vptr0     - допустимый указатель или нулевой указатель.
//        !0        - не ноль
//        val1^val2 - значения val1 и val2 являются взаимоисключающими
//        low..upp  - диапазон допустимых значений (включая границы)
//
// @nointeract - признак, означающий, что функция или класс никак не взаимодействуют
//      с пользователем. В том числе не выдают никаких сообщений или предупреждений
//      Этот признак следует учитывать, принимая решение о том, следует ли после ошибочного
//      завершения функции вызывать PPError().
//      Если этот признак определен для класса, то ни один из методов класса не является //
//      интерактивным.
// @dbd_exchange - помечаются позиции, ввод в действие которых отложен из-за невозможности
//      изменить формат обмена данными между разделами
// @ta - транзактивная функция. Внутри функции безусловно вызывается транзакция обработки данных.
//      Этот признак следует выставлять для того, чтобы вызывающая функция не пыталась
//      вызывать такую функцию внутри транзакции.
// @wota - транзактивная функция. Внутри функции не вызывается транзакция обработки данных, но
//      функция должан обрамляться транзакцией посколько в ней используются методы изменения базы данных.
//      Такая особенность может применяться только для локально используемых helper-функций.
// @*  - обозначает функцию или класс, инициализирующие поле. Например:
//     struct Foo {
//        int Setup();
//        double M; // @*Foo::Setup
//     };
// @cs   - функция вызывает локальную критическую секцию
// @temp - временный участок кода. После этого обозначения может следовать период действия //
//     Example:
//     // @temp(..31/12/2005) {
//     ... // Этот участок кода после 31/12/2005 должен быть удален
//     // } @temp
// @recursion - функция вызывается рекурсивно
// @memleak   - не устраненный источник утечки памяти
// @internal  - поле или флаг используется только для внутренний потребностей.
//    !Запрещена публикация этого поля (флага) во внешних описаниях и интерфейсах!
// @anchor    - поле структуры, к положению и (или) размеру которого в исходном коде
//    существует привязка. Следует быть крайне аккуратным при изменении типа и положения этого поля.
// @temptest  - помечаются участки кода, которые оставляются на некоторое время для автоматического
//    тестирования. Следует освобождать от проверки спустя не менее трех месяцев с момента установки //
// @stypeset  - помечаются участки кода, где не полностью учтен набор типов данных STYPE
// @sfu-r     - временная пометка для вызовов updateRec и updateRecBuf означающая, что
//              предварительный вызов search приведен к searchForUpdate
// @speedcritical - пометка, означающая, что код введен ради ускорения критичной по времени исполнения функции
// @allocreuse    - помечаются члены классов, используемые как временные буферы
//                  для предотвращения повторного распределения памяти с целью ускорения испольнения функций.
//
// @todo Повторная загрузка на асинхронный узел всех объектов, начиная с заданной записи журнала загрузки
// @todo В примитивы бизнес-показателей добавить фильтрацию по группам
// @todo Конвертация CpTransf с целью уменьшения размера структуры
// @todo Перенос Account в Reference2
// @todo Перенос BankAccount в одну из общих таблиц (пока не совсем ясно куда и как)
// @todo Добавить в стуктуры оплаты по чеку валюту
//
//
#ifndef __PP_H // {
#define __PP_H

#include <slib.h>
#include <db.h>
#include <ppdbs.h>
#include <ppdefs.h>
#include <report.h>
#include <snet.h>
#include <stylopalm.h>
#include <stylobhtII.h>
#include <ppedi.h>
#include <wininet.h>
#include <..\Rsrc\STR\ppstr2.h> // @v9.0.3 перенесено из конца файла сюда
#ifdef _MSC_VER
	#pragma intrinsic (fabs)
#else
	#pragma intrinsic fabs
#endif

// @v9.4.5 #define USE_OBJSYNC2 // @obsolete @v5.8.2
// @v9.4.5 #define USE_REF2     // @v5.8.2

#define DECL_REF_REC(rec)     typedef rec##2 rec
#define ReferenceTbl          Reference2Tbl
#define REF_TEST_RECSIZE(rec) assert(sizeof(rec##_) == sizeof(Reference_Tbl::Rec) && sizeof(rec##2) == sizeof(Reference2Tbl::Rec));

class  PPThread;
class  PPObjBill;
class  PPObjWorld;
class  PPObjWorkbook;
class  PPObjTSession;
class  PPObjSCard;
class  PPObjCashNode;
class  PPObjGoods;
class  PPObjBrand;
class  PPObjPerson;
class  PPObjLocation;
class  PPObjArticle;
class  PPObjProcessor;
class  PPObjQCert;
class  PPObjCSession;
class  PPObjAccTurn;
class  PPObjPrjTask;
class  SysJournal;
class  ObjSyncCore;
class  BillFilt;
class  PPBillPacket;
class  CCheckPacket;
class  DbfTable;
struct PathData;
class  PPGoodsPacket;
struct PPRegistrInfo;
class  PPPersonPacket;
class  PPLocationPacket;
class  BillCore;
class  Transfer;
class  PPDbEntrySet2;
class  TView;
class  BrowserWindow;
struct AsyncCashGoodsInfo;
class  TDialog;
class  ComboBox;
class  ListWindow;
class  ListBoxDef;
class  AccTurnDialog;
class  TVRez;
class  BrowserWindow;
class  AccAnlzFilt;
class  BhtProtocol;
class  CipherProtocol;
class  BhtRecord;
class  GoodsListDialog;
class  PPBasketPacket;
class  EmbedDialog;
class  MrpTabPacket;
class  HierArray;
class  PPELinkArray;
class  PPGoodsStruc;
class  GRI;
class  GoodsReplacementArray;
struct TIDlgInitData;
struct PPGdsClsPacket;
struct ObjTransmContext;
class  PPCommandGroup;
class  DlContext;
struct TaxAmountIDs;
class  ObjCollection;
class  PPBasketCombine;
class  PPServerSession;
class  UhttSCardOpFilt;
class  UhttStatus;
class  UhttBrandPacket;
class  UhttGoodsPacket;
class  UhttSpecSeriesPacket;
class  UhttSCardPacket;
class  UhttCheckPacket;
class  UhttLocationPacket;
class  UhttBillPacket;
class  UhttBillFilter;
class  UhttQuotPacket;
class  UhttQuotFilter;
class  UhttPersonPacket;
class  UhttWorkbookItemPacket;
class  UhttGoodsRestListItem;
class  UhttDCFileVersionInfo;
class  UhttSmsPacket; // @vmiller
class  UhttStyloDevicePacket;
class  UhttProcessorPacket;
class  UhttTSessionPacket;
class  PersonRelFilt;
struct SBrowserDataProcBlock;
class  CCheckFilt;
struct PrjTaskFilt;
struct RegisterFilt;
class  SStatFilt;
class  GoodsFilt;
struct SysJournalFilt;
class  FreightFilt;
struct BudgetFilt;
class  SpecSeriesFilt;
struct SCardFilt;
struct CurRateFilt;
struct ClsdGoodsFilt;
struct TSessionFilt;
struct ProcessorFilt;
struct OpGroupingFilt;
struct MrpTabFilt;
class  PPView;
class  PPViewBrowser;
class  PPViewDebtTrnovr;
class  PPViewGoodsRest;
class  PPViewTrfrAnlz;
class  PPViewSStat;
class  PPViewPrjTask;
class  PPTransferItem;
class  TSessionPacket;
struct PPBillConfig;
class  CheckOpJrnl;
struct CCheckViewItem;
class  PPAlbatrosConfig;
struct PPSCardSeries2;
class  GtaJournalCore;
struct PPSCardSerPacket;
class  ObjTagItem;
class  ObjTagList;
class  LocTransfCore;
class  PrcssrAlcReport;
class  BillTransmDeficit;
struct PPQuot;
class  GoodsToObjAssoc;
class  PPSoapClientSession;
struct PPAccount;
class  CPosProcessor;
class  PPPaintCloth;
class  SaComplex;
class  BVATAccmArray;
struct BarcodeLabelParam;
struct BarcodeLabelEntry;
struct RetailGoodsInfo;
class  PPCommandItem;
class  PPCommand;
class  PPCommandHandler;
class  PPDesktop;
struct BillGoodsBrwItem;
class  BillGoodsBrwItemArray;
class  LocValList;
struct LocValEntry;
class  __HolidayArray;
class  DL2_Resolver;
class  DL2_Entry;
class  DL2_Group;
class  DL2_Data;
class  CMrpTab;
struct TagrCacheItem;
struct GoaAddingBlock;
struct GoaCacheItem;
struct ProfileEntry;
class  LogListWindow;
class  LogListWindowSCI;
struct PPCheckInPersonConfig;
class  PPCheckInPersonArray;
struct _PPRights;
struct PPSupplExchangeCfg;
class  EAddrCore;
struct ArticleDlgData;
class  ArticleCache;
class  PPComplBlock;
class  PPSCardPacket;
class  SCardTransmitPacket;
class  PPWorkbookExporter;
class  PPEgaisProcessor;
struct AddrItemDescr;
class  GoodsRestFilt;
class  SmsProtocolBuf;
class  SrGeoNodeTbl;
class  PPTextAnalyzerWrapper;

typedef long PPID;
typedef LongArray PPIDArray;
//
// Descr: Габаритные размеры (mm).
//
struct PPDimention {
	// @noconstructor @novtbl
	PPDimention & Reset();
	int    operator !() const;
	int    FASTCALL IsEqual(const PPDimention & rS) const;
	int    FASTCALL operator == (const PPDimention & rS) const;
	int    FASTCALL operator != (const PPDimention & rS) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Возвращает объем в куб.метрах
	//
	double SLAPI CalcVolumeM() const;
	//
	// Descr: Возвращает объем в куб.миллиметрах
	//
	double SLAPI CalcVolumeMM() const;
	//
	// Descr: Устанавливает общий объем в куб.метрах.
	//   При этом ширина и высота устанавливаются равными 100мм, а длина в R0i(volume * fpow10i(5))
	// Returns:
	//   1
	//
	int    SLAPI SetVolumeM(double volume);

	long   Length;
	long   Width;
	long   Height;
};
//
//
int    SLAPI CreateSerial(PPRegistrInfo *);
int    SLAPI SetRegistrInfo(const PPRegistrInfo *, const char *);
//
//
//
#define MAX_LINKED_FILES 32

class ObjLinkFiles {
public:
	//
	// Descr: Флаги состояния объекта
	//
	enum {
		stTransmissionNotSupported = 0x0001, // При восстановлении объекта из буфера выяснилось, что
			// сторона, упаковавшая его в буфер, не поддерживает сериализацию.
		stIgnoreCheckStorageDir    = 0x0002  // @v9.4.12
	};

	SLAPI  ObjLinkFiles();
	SLAPI  ObjLinkFiles(PPID objType);
	SLAPI  ObjLinkFiles(const ObjLinkFiles & rS);
	void   SLAPI SetMode_IgnoreCheckStorageDir(int set);
	int    FASTCALL Copy(const ObjLinkFiles & rS);
	ObjLinkFiles & FASTCALL operator = (const ObjLinkFiles & rSrc);
	void   SLAPI Init(PPID objType, const char * pDir);
	void   FASTCALL Init(PPID objType);
	int    SLAPI Load(PPID objID, const char * pAddedSubstr);
	int    SLAPI Save(PPID objID, const char * pAddedSubstr);
	int    SLAPI SaveSingle(PPID objID, const char * pAddedSubstr, uint idx, SString * pResultName);
	//int    SLAPI IsChanged(PPID id, const char * pAddedSubstr) const;
	int    SLAPI Load(PPID objID, PPID addedID);
	int    SLAPI Save(PPID objID, PPID addedID);
	int    SLAPI IsChanged(PPID id, PPID addedID) const;
	uint   SLAPI GetCount() const;
	int    SLAPI At(uint i, SString & rPath) const;
	int    SLAPI Remove(uint i);
	int    SLAPI CheckFile(uint pos, const char * pPath);
	int    SLAPI Replace(uint i, const char * pPath);
	void   SLAPI Clear();
	//
	// Descr: Высокоуровневая функция устанавливающая (возможно, замещая существующий) файл по индексу 0.
	//
	int    SLAPI SetupZeroPositionFile(PPID objType, PPID objID, const char * pPath);
	//
	// Descr: Высокоуровневая функция извлекающая файл по индексу 0
	//
	int    SLAPI GetZeroPositionFile(PPID objType, PPID objID, SString & rPath);

	long   SLAPI GetState() const;
	//
	// Descr: Процедура сериализации прикрепленных файлов.
	// ARG(dir   IN): Направление сериализации. >0 - объект-->буфер, <0 - буфер-->объект
	// ARG(transmissionNotSupported IN): Индикатор, сигнализирующий о том, что сериализация прикрепленных
	//   файлов не поддерживается для данного объекта. Имеет значение только при dir > 0.
	//   Если transmissionNotSupported != 0, то в буфер записывается специальное значение,
	//   при считывании которого десериализация (dir<0) может специальным образом это обработать.
	// ARG(rBuf  INOUT): Буфер, в который (dir>0) или из которого (dir<0) сериализуется объект this
	// ARG(pSCtx INOUT): Контекст сериализации
	//
	int    SLAPI Serialize(int dir, int transmissionNotSupported, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Служебная структура, используемая для кодирования/декодирования хранимых имен файлов
	//
	struct Fns {
		Fns();
		void   Reset();

		long   ObjType;
		long   ObjID;
		// @v9.3.9 long   AddedID;
		SString AddedStr; // @v9.3.9
		long   Cntr;
		char   Ext[32];
	};
	static int SLAPI SplitInnerFileName(const char * pFileName, Fns * pS) /*const*/;
private:
	int    SLAPI MakeFilePath(PPID objID, /*PPID addedID*/const char * pAddedStr, SString & rPath);
	int    SLAPI MakeExistsFilePath(uint i, PPID objID, /*PPID addedID*/const char * pAddedStr, SString & rPath);
	int    SLAPI GetFreeNum(uint * pNum) const;
	int    SLAPI GetNum(const char * pPath, uint * pNum);
	int    SLAPI Helper_ClearBeforeSaving(PPID objID, const char * pAddedStr);
	int    SLAPI Helper_Save(PPID objID, const char * pAddedStr, uint idx, SString * pResultFileName);

	PPID   ObjType;
	PPID   ObjID;
	ulong  FilesNums;
	ulong  InitFilesNums; // номера файлов присоединенных к объекту, не изменяется после загрузки
	long   State;         // @v8.2.3 Флаги состояния объекта
	SString StoreDir;
	SStrCollection Files;
};
//
//
//
class PapyrusPrivateBlock {
public:
	SLAPI  PapyrusPrivateBlock();
	SLAPI ~PapyrusPrivateBlock();
	void   SLAPI Clear();
	int    SLAPI ReadFromIni(SIniFile & rIniFile);
	int    SLAPI WriteToSrc(const char * pFileName);
	int    SLAPI RestoreBuffer(const void * pSrcData, size_t srcDataSize);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		fDemo       = 0x0001,
		fOpenSource = 0x0002
	};
	struct Header {
		char   Signature[32];  // Заголовочная сигнатура структуры
		uint32 RawBufferSize;  // Полный размер "сырого" сериализованного буфера
	} H;
	uint32 StructVer;      // Версия структуры данных. [1..]
	int32  StartDevYear;   // Год начала разработки
	int32  LastDevYear;    // Последний год разработки
	SVerT  Ver;            // Номер версии продукта
	SVerT  MinVer;         // Минимальная версия базы данных, с которой может работать данная версия системы
	int32  AssemblyN;      // Номер сборки
	// @v9.4.8 int32  Demo;           // Если !0, то демо-версия
	int32  Flags;          // @v9.4.8
    SString ProductName;   // Наименование продукта
    SString Team;          // Команда разработчиков
	SString Secret;        // Секретный текст
	SString DefPassword;   // Пароль для шифрования/расшифрования по умолчанию
	SString MsftTranslAcc; // Аккаунт доступа к службе Microsoft Translate
	SString UhttAcc;       // Default-аккаунт доступа к службам Universe-HTT
};
//
// Descr: Блок информации о версии системы.
//   Данные хранятся в зашифрованном виде.
//
class PPVersionInfo {
public:
	SLAPI  PPVersionInfo(const char * pOuterFileName = 0);
	SLAPI  PPVersionInfo(const PPVersionInfo & s);
	SLAPI ~PPVersionInfo();
	PPVersionInfo & FASTCALL operator = (const PPVersionInfo &);
	int    SLAPI GetProductName(SString & rBuf);
	int    SLAPI GetTeam(char *, size_t);
	int    SLAPI GetDevYears(uint * pStart, uint * pLast);
	int    SLAPI GetVersion(uint * pMajor, uint * pMinor, uint * pRevision, char * pDemo = 0, int minVersion = 0);
	SVerT  SLAPI GetVersion(int minVersion = 0);
	int    SLAPI GetSecret(char * pBuf, size_t bufSize);
	int    SLAPI GetVersionText(char *, size_t);
	int    SLAPI GetCopyrightText(SString & rBuf);
	int    SLAPI GetDefaultEncrKey(SString & rBuf);
	int    SLAPI GetMsftTranslAcc(SString & rBuf);
	long   SLAPI GetFlags();
	// @v9.3.3 int    SLAPI GetMaxUserNumber(int *);
	// @v9.3.3 int    SLAPI GetRegistrInfo(PPRegistrInfo *, const char *);
	// @v9.3.3 int    SLAPI UpdateLicense(const PPRegistrInfo *, const char * , const char *);
private:
	int    SLAPI Decrypt();
	void   SLAPI Clear();

	void * P_Info_Pre9303;
	PapyrusPrivateBlock * P_Info_;
	char * P_OuterFileName;
};
//
// Descr: Блок данных о лицензиях, которыми владеет пользователь программы.
//
struct PPLicData {
	SLAPI  PPLicData();

	enum {
		effJobServer  = 0x0001,
		effDebtorStat = 0x0002,
		effRemove     = 0x8000, // Если флаг установлен, то транспортный
			// файл накладывает флаги на существующий файл операцией "&~"
			// В противном случае - операцией "|"
		effEgais      = 0x0004  // @v8.8.2 Лицензия на использование интерфейча с ЕГАИС
	};
	char   RegName[48];
	char   RegNumber[32];
	int32  LicCount;
	LDATE  LastUpdate;
	int16  Transport;
	int16  Version;         // 0..
	char   Reserve2[24];
	uint32 ExtFunc;         // @v6.0.1 Битовые флаги доступности дополнительных функций
	int32  FreeLicCount;    //
	uint32 DbDivArray[8];   // Битовый массив доступных разделов БД
	uint32 SrvJobArray[16]; // Битовый массив доступных задач сервера
};

int SLAPI PPLicUpdate();
int SLAPI PPLicRegister();
int SLAPI PPGetLicData(PPLicData * pData);
int SLAPI PPUpdateLic(const char * pSrcFile, const char * pRegName, const char * pRegNum);
int SLAPI PPUpdateLic(const char * pSrcFile);
//
// Descr: Класс, управляющий получение списка файлов по шаблону
//
class PPFileNameArray : public TSArray <SDirEntry> {
public:
	SLAPI  PPFileNameArray();
	int    SLAPI Scan(const char * pPath, const char * pWildcard);
	int    SLAPI Enum(uint * pIdx, SDirEntry * pEntry, SString * pFullPath) const;
	const  SString & SLAPI GetPath() const;
//private:
	SString Path; //
};
//
// Descr: Список идентификаторов. Практически полностью повторяет
//   функционал LongArray (PPIDArray) за исключением того, что может быть
//   неопределенным (!ObjIdListFilt::IsExists()).
//   Используется для фильтрации по списку идентификаторов объектов.
//   Неопределенный экземпляр не накладывает ограничений фильтрации.
//
class ObjIdListFilt { // @size=sizeof(PPIDArray *) Передается в качестве аргументов по значению
public:
	SLAPI  ObjIdListFilt();
	SLAPI  ObjIdListFilt(const ObjIdListFilt &);
	SLAPI ~ObjIdListFilt();
	ObjIdListFilt & FASTCALL operator = (const ObjIdListFilt &);
	//
	// Descr: Устанавливает единственное значение списка, равное value
	//   Если до присвоения список был не пуст, то он очищается.
	//   Если value == 0, то список просто очищается.
	//
	ObjIdListFilt & FASTCALL operator = (long value);
	int    SLAPI operator ! () const
	{
		return (P_List == 0);
	}
	int    SLAPI IsExists() const
	{
		return BIN(P_List);
	}
	int    FASTCALL IsEqual(const ObjIdListFilt &) const;
	int    SLAPI IsEmpty() const;
	int    FASTCALL CheckID(PPID) const;
	const  PPIDArray & SLAPI Get() const
	{
		return *P_List;
	}
	PPIDArray * SLAPI GetP() const
	{
		return P_List;
	}
	int    FASTCALL Get(PPIDArray & rResult) const;
	//
	// Descr: Распределяет память для массива P_List.
	//   Если P_List != 0, то ничего не делает.
	//   Вызов этой функции может понадобиться для того, чтобы
	//   функция IsExists возвращала !0.
	// Returns:
	//   !0 - либо P_List не был равен нулю, либо удалось его создать
	//   0  - не удалось распределить память для массива P_List (PPErrCode = PPERR_NOMEM)
	//
	ObjIdListFilt & SLAPI InitEmpty();
	ObjIdListFilt & FASTCALL Set(const PPIDArray *);
	int    SLAPI Add(PPID, int ignoreZero = 1);
	//
	// Descr: Добавляет в список элементы из массива pList.
	// Attention: В отличии от метода ObjIdListFilt::Add(PPID, int)
	//   эта функция не игноирует нулевые значения.
	//
	int    SLAPI Add(const PPIDArray * pList);
	int    SLAPI Update(uint pos, PPID newId, int ignoreZero = 1);
	int    SLAPI Remove(PPID, int bsearch = 0);
	PPID   SLAPI GetSingle() const;
	PPID   SLAPI Get(uint pos) const;
	uint   SLAPI IncPointer(); // @>>P_List->incPointer
	//
	// Descr: Очищает список и вставляет в него единственный элемент id.
	//   Если id == 0, то список остается пустым.
	//
	int    SLAPI SetSingle(PPID id);
	uint   SLAPI GetCount() const;
	int    SLAPI Sort();
	int    SLAPI Search(PPID id, uint * pPos, int bsearch = 0) const;
	int    SLAPI FreeAll();
	int    SLAPI CopyTo(PPIDArray * pAry) const;
	int    SLAPI Intersect(const ObjIdListFilt * pList, int binary = 0); // -> LongArray::intersect

	int    SLAPI Write(SBuffer & rBuf) const;
	int    SLAPI Read(SBuffer & rBuf);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	PPIDArray * P_List;
};
//
//
//
struct PPCycleFilt { // @size=4
	void   SLAPI Init();
	int    FASTCALL operator == (const PPCycleFilt s) const;
	int    SLAPI operator !() const;
	int16  Cycle;
	int16  NumCycles;
};

class PPCycleArray : public TSArray <DateRange> {
public:
	SLAPI  PPCycleArray();
	SLAPI  PPCycleArray(LDATE, LDATE, int cycle, int numCycles);
	int    SLAPI init(LDATE beg, LDATE end, int cycle, int numCycles);
	int    SLAPI init(const DateRange *, int cycle, int numCycles);
	int    SLAPI init(const DateRange *, PPCycleFilt cycl);
	int    SLAPI init2(DateRange * pPeriod, PPCycleFilt * pCycl);
	int    SLAPI concat(const PPCycleArray *);
	int    SLAPI getCycleParams(DateRange *, PPCycleFilt * pCycl) const;
	int    SLAPI getPeriod(uint pos, DateRange *) const;
	int    SLAPI searchDate(LDATE, uint *) const;
	int    SLAPI searchPeriodByDate(LDATE, DateRange *) const;
	int    SLAPI formatCycle(LDATE, char *, size_t) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	DateRange Period;
	int    Cycle;
	int    NumCycles;
};

class DateIter {
public:
	SLAPI  DateIter(long start = 0, long finish = 0);
	SLAPI  DateIter(const DateRange *);
	void   SLAPI Init(long start = 0, long finish = 0);
	void   SLAPI Init(const DateRange *);
	int    FASTCALL Advance(LDATE d, long o);
	int    SLAPI IsEnd() const;
	//
	// Descr: Сравнивает объект this с объектом rS.
	//   Сравнение осуществляется по паре {dt, oprno}
	// Returns:
	//   >0 - this > rS
	//   <0 - this < rS
	//    0 - this == rS
	//
	int    FASTCALL Cmp(const DateIter & rS) const
	{
        int    si = 0;
        CMPCASCADE2(si, this, &rS, dt, oprno);
        return si;
	}

	LDATE  end;
	LDATE  dt;
	long   oprno;
};

class IterCounter {
public:
	SLAPI  IterCounter() { Init(); }
	operator ulong() const { return Count; }
	void   FASTCALL Init(ulong total = 0L) { Total = total; Count = 0L; }
	int    FASTCALL Init(DBTable *);
	void   FASTCALL SetTotal(ulong total)  { Total = total; }
	IterCounter & SLAPI Increment() { Count++; return *this; }
	IterCounter & FASTCALL Add(long a) { Count += a; return *this; }
	ulong  SLAPI GetTotal() const { return Total; }
private:
	ulong  Count;
	ulong  Total;
};
//
// Descr: Специализированный массив, хранящий пары {id, binary data}. Причем
//   значение ключа автоматически назначается экземпляром массива при обращении
//   к функции SurKeyArray::Add.
//
class SurKeyArray : public SArray {
public:
	SurKeyArray();
	int    Add(long * pID, const void * pData, size_t dataLen);
	int    Remove(long id);
	const void * Get(long id, size_t * pDataLen) const;
private:
	virtual void FASTCALL freeItem(void * pItem);
	long   LastId;
};
//
//
//
struct PPCalcFuncEntry {
	SLAPI  PPCalcFuncEntry();
	SLAPI ~PPCalcFuncEntry();
	uint   FuncID;
	SString Name;
	SString Description;
	uint   RetType;
	uint   ParamCount;
	uint * P_ParamTypeList;
};

class PPCalcFuncList : public TSCollection <PPCalcFuncEntry> {
public:
	SLAPI  PPCalcFuncList();
	int    SLAPI Load();
	void   SLAPI Release();
	int    SLAPI ReadParams(uint16 funcID, const char *, size_t *, StringSet *) const;
	int    SLAPI CalcFunc(uint16 funcID, const StringSet * pParams, char * pRes, size_t resBufLen) const;
	const  PPCalcFuncEntry * FASTCALL SearchFunc(uint16 funcID) const;
	uint16 FASTCALL SearchFuncByName(const char * pName) const;
};
//
// Descr: Класс, позволяющий организовать централизованное создание и уничтожение запросов
//   BExtQuery с сокрытием деталей создания этих запросов.
//
class PPTblEnumList {
public:
	SLAPI  PPTblEnumList();
	SLAPI ~PPTblEnumList();
	int    SLAPI RegisterIterHandler(BExtQuery * pQ, long * pHandle);
	int    SLAPI DestroyIterHandler(long handle);
	int    FASTCALL NextIter(long handle);
private:
	TSArray <void *> Tab;
};
//
//
//
template <class T> class PPTblEnum : public SEnumImp {
public:
	PPTblEnum(T * pT, long h)
	{
		P_T = pT;
		H = h;
	}
	virtual ~PPTblEnum()
	{
		CALLPTRMEMB(P_T, EnumList.DestroyIterHandler(H));
	}
	virtual int Next(void * pRec)
	{
		return (P_T && P_T->EnumList.NextIter(H) > 0) ? (P_T->copyBufTo(pRec), 1) : 0;
	}
protected:
	T * P_T;
	long   H;
};
//
// Descr: Базовый класс контекстов разрешения переменных в формулах.
//
#define EXRP_EVAL_FIRST_FUNC 1000

class ExprEvalContext {
public:
	friend class PPExprParser;

	SLAPI  ExprEvalContext();
	virtual SLAPI ~ExprEvalContext();
	int    SLAPI SelfScanArgList() const;
	int    SLAPI SetInnerContext(ExprEvalContext * pInner);
	virtual int SLAPI Resolve(const char * pSymb, double * pVal) = 0;
	//
	// Descr: Определяет, является ли строка pSymb функцией.
	//   Если "да", то должна вернуть !0, по указателю pFuncId
	//   присвоить идентификатор функции.
	//
	virtual int SLAPI IsFunc(const char * pSymb, int * pFuncId);

	struct FC {
		void   Init();
		RealArray ArgList;    // Список числовых представлений аргументов
		SString StrArg;       // Список аргументов одной строкой
		TYPEID RetType;
		double RetReal;
		SString RetStr;
	};
	virtual int SLAPI ResolveFunc(int funcId, FC & rFc);
protected:
	enum {
		fSelfScanArgList = 0x0001 // Контекст самостоятельно сканирует аргументы функции.
	};
	long   ImplementFlags;
	ExprEvalContext * P_Next; // @v9.3.3 Внутренний контекст, используемый, если не удается разрешить формулу (переменную) с помощью данного контекста
};
//
// Descr: Реализует разрешение формулы. Использует ExprEvelContext для разрешения переменных
//   и функций. Формулы обрабатывают только значения с плавающей точкой.
//   Доступ к сервису этого класса осуществляется только через статический метод
//   PPExprParser::CalcExpression
//
class PPExprParser {
public:
	static int SLAPI CalcExpression(const char * pFormula, double * pResult, const PPCalcFuncList * pFuncList, ExprEvalContext * pCtx);
private:
	enum {
		tokNumber = 257,
		tokName = 258,
		tokFunc = 259,
		tokLe,          // <=
		tokGe,          // >=
		tokNe           // !=
	};
	enum {
		funcAbs   = 1, // abs(x)
		funcSqrt,      // sqrt(x)
		funcSin,       // sin(x)
		funcCos,       // cos(x)
		funcTan,       // tan(x)
		funcSieve,     // sieve[1.; 20000. ? 2.5; 40000 ? 4](x)
		funcRound,     // round(x, prec) округление до ближайшего
		funcOid,       // oid(objtypesymb, objsymb) oid(GoodsType, tare)
		funcPow,       // pow(x, p)
		funcQuest,     // ?(condition, true_val, false_val)
		funcMin,       // min(...) любое количество аргументов
		funcMinZ,      // minz(...) любое количество аргументов
		funcMax,       // max(...) любое количество аргументов
		funcEq,        // eq(a, b)
		funcNEq,       // neq(a, b)
		funcRoundUp,   // roundup(x, prec) округление до верхней границы
		funcRoundDown  // rounddown(x, prec) округление до нижней границы
	};
	SLAPI  PPExprParser(const char *, const PPCalcFuncList *, ExprEvalContext *);
	SLAPI ~PPExprParser();
	int    FASTCALL CalcExpr(double *);
	int    FASTCALL GetFactor(double *);
	int    FASTCALL GetTerm(double *);
	void   SLAPI Skip();
	int    SLAPI GetToken();
	int    SLAPI Next();
	int    SLAPI GetSieve();
	int    SLAPI ReadArgString(SString & rBuf, size_t * pOffs) const;

	int    SLAPI ResolveContextName(const char * pSymb, double * pResult);

	struct State {
		State();
		State & FASTCALL operator = (const State & rS);

		PPID   OidObjType;    // for oid()
		PPID   OidObjTypeExt; // for oid()
	};

	int    Token;
	double Number;
	SString Name;
	int    Func;
	int    Cur;
	char * P_S;
	size_t Pos;
	State  St;
	SHistogram Sieve;
	RAssocArray SieveVal;

	const PPCalcFuncList * P_CFL;
	ExprEvalContext * P_Ctx;
};
//
//
//
struct GdsClsCalcExprContext {
	SLAPI  GdsClsCalcExprContext(PPGdsClsPacket * pGcPack, PPGoodsPacket * pGPack);
	//
	// Descr: Конструктор, используемый для расчетов формул в структуре товара
	//
	SLAPI  GdsClsCalcExprContext(const PPGoodsStruc * pGs, PPID sessID = 0);
	SLAPI  GdsClsCalcExprContext(const PPGoodsStruc * pGs, const PPBillPacket * pBillPack);
	//
	// Descr: Конструктор, используемый для расчетов технологий перенастройки, в
	//   которых участвуют два товара: тот который будет производиться (goodsID) и тот,
	//   который производился непосредственно до этого (prevGoodsID).
	//
	SLAPI  GdsClsCalcExprContext(PPID goodsID, PPID prevGoodsID);
	SLAPI  GdsClsCalcExprContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack);

	PPGdsClsPacket * P_GcPack;
	PPGoodsPacket  * P_GPack;
	const  PPGoodsStruc * P_GsPack;
	const  PPBillPacket * P_BillPack;
	const  PPTransferItem * P_Ti;
	PPID   TSessID;
	double Par1;
	double Par2;
	double Par3;
	PPID   GoodsID;
	PPID   PrevGoodsID;
};

int    SLAPI PPCalcExpression(const char *, double * pResult, const PPCalcFuncList *);
int    SLAPI PPCalcExpression(const char *, double * pResult, PPBillPacket *, PPID curID, uint advItemIdx);
int    SLAPI PPCalcExpression(const char *, double * pResult, GdsClsCalcExprContext * pCtx);
//
//	Структура результирующей кросс-таблицы следующая:
//		autolong CTID;
//		Поля, заданные в списке IdxFldList, копируемые из исходной таблицы;
//		Поля, заданные в списке InhFldList, копируемые из исходной таблицы;
//		Поля, заданные в списке FixFldList
//		Список кросс-таб-полей (по AggrFldList.GetCount() на каждое табулируемое значение)
//			Наименования имеют следующую форму: CTFxxyy, где xx - номер табулированного значения,
//			yy - номер поля в списке AggrFldList;
//		AggrFldList.GetCount() итоговых поля //
//			Наименования имеют следующую форму: CTFTyy, где yy - номер поля в списке AggrFldList;
//
class Crosstab {
public:
	enum AggrFunc {
		afSum = 1,
		afCount,
		afAvg,     // not supported
		afMin,
		afMax
	};
	SLAPI  Crosstab();
	SLAPI ~Crosstab();
	int    SLAPI SetTable(DBTable * pTbl, const DBField & crssFld);
	int    SLAPI AddIdxField(const DBField &);
	int    SLAPI AddAggrField(const DBField &, AggrFunc af = afSum, const char * pColName = 0, long format = 0, long options = 0);
	int    SLAPI AddFixField(const char * pName, TYPEID type);
	int    SLAPI AddInheritedFixField(const DBField &);
	int    SLAPI AddTotalRow(const DBFieldList & rAggrFldList, size_t extSize, const char * pTitle);
	int    SLAPI AddTotalColumn(const DBField & rAggrFld, size_t extSize, const char * pTitle);
	int    SLAPIV SetSortIdx(const char * pFldName, ...);
	int    SLAPI Create(int use_ta);
	uint   SLAPI GetAggrCount() const;
	uint   SLAPI GetTotalRowsCount() const;
	uint   SLAPI GetTotalColsCount() const;
	virtual DBQuery * SLAPI CreateBrowserQuery();
	virtual BrowserWindow * SLAPI CreateBrowser(uint brwId, int dataOwner);
	virtual int  SLAPI GetTabTitle(const void * pVal, TYPEID typ, SString & rBuf) const;
		// @<<Crosstab::SetupBrowserCtColumns
	int    SLAPI SetupBrowserCtColumns(BrowserWindow * pBrw) const;
		// @<<Crosstab::CreateBrowser
	DBTable * SLAPI GetResultTable();
	const  DBFieldList & SLAPI GetTabFieldList() const;
	int    SLAPI GetIdxFields(PPID id, DBFieldList * pFldList);
	int    SLAPI GetTab(uint tabIdx, void * pTabVal);
	int    SLAPI SetFixFieldValByCTID(long ctID, uint fldPos, void * pBuf);
	int    SLAPI GetFixFieldValByCTID(long ctID, uint fldPos, void * pBuf, size_t bufSize);
	//
	// Descr: Извлекает индексное поле с номером idxFldN из строки буфера записи pDataBuf.
	//   Если pDataBuf == 0, то данные извлекаются из буфера текущей записи таблицы P_RTbl.
	//
	int    SLAPI GetIdxFieldVal(uint idxFldN, const void * pDataBuf, void * pBuf, size_t bufSize);
	//
	// Descr: Извлекает агрегатное поле с номером aggrFldN из строки буфера записи pDataBuf.
	//   Если pDataBuf == 0, то данные извлекаются из буфера текущей записи таблицы P_RTbl.
	//
	int    SLAPI GetAggrFieldVal(uint tabIdx, uint aggrFldN, const void * pDataBuf, void * pBuf, size_t bufSize);

	int    SLAPI Write(SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI Read(DBTable * pTbl, SBuffer & rBuf, SSerializeContext * pCtx);
protected:
	struct CalcSummaryBlock {
		CalcSummaryBlock(int dir);
		int    Dir;          // 0 - total row, 1 - total column
		uint   TotalItemPos; // @#[0..TotalLinesCount]
		uint   CtValPos;     // Номер кросстабулированной колонки
		uint   AggrPos;      // Номер кросстабилированной субколоки
		int    AggrFunc;     // (Crosstab::AggrFunc) Агрегирующая функция, используемая для расчета итоговых столбцев.
			// Это значение применяется только базовой реализацией метода CalcSummary
		void * P_ExtData;    // Указатель на область дополнительных данных, используемый функцией CalcSummary
		double CellVal;      // Значение в ячейке, для которой осуществляется суммирование
		double Result;       // Результат. При входе в функцию CalcSummary это поле содержит
			// значение, рассчитанное предыдущими итерациями.
			// Функция CalcSummary должна после вычисления присвоить этому полю новое
			// значение результата.
	};
	virtual int SLAPI SetupFixFields(int initialCall);
	virtual int SLAPI CalcSummary(int action, CalcSummaryBlock & rBlk);
	int    SLAPI Helper_SetupBrowserCtColumn(BrowserWindow * pBrw, uint ctValPos, SString & rTitle) const;
		// @<<Crosstab::SetupBrowserCtColumns
	uint   SLAPI GetFixFieldOffs() const;
	uint   SLAPI GetTabFldPos(uint ctValPos, uint aggrFldPos) const;
private:
	enum {
		fHasSortIdx      = 0x0004, // Внутреннее значение, указывающее на то, что таблица содержит
			// сортирующий индекс
		fHasExtSortField = 0x0008  // Таблица содержит дополнительное сортирующее поле
			// для смещения итоговых строк в нижнюю часть области просмотра.
			// Если это поле существует, то она расположено 2-м по счету сразу после
			// поля идентификатора
	};

	int    SLAPI CreateTable();
	int    SLAPI FillTable();
	int    SLAPI DestroyTable();
	int    SLAPI GetCrossValues(DBTable * pTbl, const DBField & crssFld, STypArray ** ppList);
	int    SLAPI SetAggrValues(uint ctValPos);
	int    SLAPI SetAggrSummaryValues();
	int    SLAPI SetAggrSummaryRow();
	int    SLAPI SetSummaryRows();

	int    SLAPI WriteDbFieldList(DBFieldList & rList, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI ReadDbFieldList(DBTable * pTbl, DBFieldList & rList, SBuffer & rBuf, SSerializeContext * pCtx);

	long   Flags;              // @viewstate
	DBTable * P_Tbl;           // Исходная таблица для построения кросс-таба
	DBTable * P_RTbl;          // @viewstate Кросстабулированная таблица
	DBField     CrssFld;       // @viewstate Поле, по которому разворачивается таблица P_Tbl
	DBFieldList IdxFldList;    // @viewstate Список полей, образующих индекс
	BNFieldList FixFldList;    // @viewstate Список фиксированных полей, заполняемых вызовом виртуальной функции SetupFixFields
	DBFieldList InhFldList;    // @viewstate Список полей, унаследованных из исходой таблицы
	DBFieldList CrssFldList;   // @viewstate Список результирующих кросс-таб полей
	DBFieldList AggrFldList;   // @viewstate Список агрегируемых полей
	IntArray    AggrFuncList;  // @viewstate Список агрегатных функций, ассоциированный со списком AggrFldList
	SStrCollection AggrFldColNames; // @viewstate Наименования столбцов агрегируемых полей
	LAssocArray   AggrFldFormats; // @viewstate Формат и опции колонки

	STypArray * P_CtValList;   // @viewstate
	StringSet SortIdxList;     // @viewstate

	struct Summary {
		Summary(size_t extSize, uint aggrFldCount);
		size_t GetEntrySize() const;
		uint   GetCount() const;
		int    IsAggrField(uint lineNo, uint aggrPos) const;
		int    AddLine(uint32 aggrFldPosMask, const char * pTitle);
		int    GetTitle(uint lineN, SString & rBuf) const;
		double GetValue(uint lineNo, uint ctValPos, uint aggrPos);
		int    SetValue(uint lineNo, uint ctValPos, uint aggrPos, double val);
		void * GetExtPtr(uint lineNo, uint ctValPos);
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	private:
		uint   AggrFldCount;
		size_t ExtSize;
		struct Item {
			Item(uint32 aggrFldPosMask, const char * pTitle, uint entrySize);
			uint32 AggrFldPosMask;
			SString Title;
			SArray List;
		};
		TSCollection <Item> Data;
	};
	Summary * P_TotalRows; // @viewstate
	Summary * P_TotalCols; // @viewstate
};
//
//
//
class PPDbqFuncPool {
public:
	static int IdEmpty;             //
	static int IdBillDebt;          //
	static int IdCQtty;             //
	static int IdTrfrPrice;         // (fldOpID, fldCost, fldPrice, fldDiscount)

	static int IdObjNameBillStatus; // (fldBillStatusID)
	static int IdObjNameOprKind;    // (fldOpID)
	static int IdObjNameLoc;        // (fldLocID)
	static int IdObjNameAr;         // (fldArID)
	static int IdObjNameArByAcc;    // (fldArID, fldAccID) Если у пользователя нет прав на доступ к счету fldAccID,
		// то выдается пустое имя статьи fldArID //
	static int IdObjNameUser;       // (fldUserID)
	static int IdObjNameGlobalUser; // (fldGlobalUserID)
	static int IdObjNameUnit;       // (fldUnitID)
	static int IdObjNameTech;       // (fldTechID)
	static int IdObjNameGoodsByTech; // (fldTechID)
	static int IdObjNamePrc;        // (fldPrcID)
	static int IdObjNameGoods;      // (fldGoodsID)
	static int IdObjNamePerson;     //
	static int IdObjNameSalCharge;  // (fldSalChargeID)
	static int IdObjNameStaff;      // (fldStaffID)
	static int IdObjNameStaffCal;   // (fldStaffCalID)
	static int IdObjNamePersonPost; // (fldPersonPostID)
	static int IdObjStaffOrg;       // (fldStaffListID) // @v9.0.3
	static int IdObjStaffDiv;       // (fldStaffListID) // @v9.0.3
	static int IdObjSymbCurrency;   // (fldCurrencyID)
	static int IdObjNameAccSheet;   // (fldAcsID)
	static int IdObjNameQuotKind;   // (fldQkID)
	static int IdObjNameCashNode;   // (fldCashNodeID)
	static int IdObjNameScale;      // (fldScaleID)
	static int IdObjNamePsnOpKind;  // (fldScaleID)
	static int IdObjNameBizScore;   // (fldBizScoreID)
	static int IdObjNameAcctRel;    // (fldAcctRelID)
	static int IdObjNameBrand;      // (fldBrandID)
	static int IdObjNameWorld;      // (fldWorldID)
	static int IdObjNamePersonStatus; //
	static int IdObjNamePersonCat;  //
	static int IdObjNameAmountType; //
	static int IdObjNamePsnKind;    //
	static int IdObjCodeBillCmplx;  // (fldBillID) Формирует строку, состоящую из даты и номера документа
	static int IdObjCodeBill;       // (fldBillID) Формирует строку, состоящую из номера документа
	static int IdObjMemoBill;       // (fldBillID) Формирует строку примечания к документу
	static int IdObjNameSCardSer;   // (fldSCardSeriesID)
	static int IdObjNameDebtDim;    //
	static int IdObjCodeSCard;      // (fldSCardID)
	static int IdSCardOwnerName;    // (fldSCardID)
	static int IdUsrPersonName;     // (fldUsrID)
	static int IdLocOwnerName;      // @v9.1.5  (fldLocID) Формирует строку с именем персоналии-владельца локации
	static int IdUfpFuncName;       // @v8.1.1  (fldFuncId)
	static int IdVersionText;       // @v8.1.1  (fldLong)
	static int IdUfpFuncId;         // @v8.1.1  (fldLong)

	static int IdDateTime;          // (fldDate, fldTime)
	static int IdDurationToTime;    // (fldLong)
	static int IdInventDiffQtty;    // (fldFlags, fldDiffQtty)
	static int IdTSesLnPhQtty;      // (fldGoodsID, fldFlags, fldQtty, fldWtQtty)
	static int IdTSesLnFlags;       // (fldFlags)
	static int IdPercent;           // (fldDividend, fldDivisor) =(100 * div / divisor)
	static int IdPercentIncDiv;     // (fldDividend, fldDivisor) =(100 * div / (divisor+div))
	static int IdWorldIsMemb;       // (fldCity, WorldItemFilt)
	static int IdTaCost;            // Цена поступления в анализе товарных операций
	static int IdTaPrice;           // Цена реализации в анализе товарных операций
	static int IdCommSyncId;        // Общий идентификатор синхронизации объектов {int16; int32}
	static int IdObjTitle;          // (objType)  Наименование типа объекта данных
	static int IdGoodsStockDim;     // (fldGoods) Строка габаритов товара "width x length x height"
	static int IdGoodsStockBrutto;  // (fldGoods) Строка массы брутто товара
	static int IdGoodsStockMin;     // (fldGoods) Строка массы минимального остатка товара
	static int IdGoodsStockPackage; // (fldGoods) Строка емкости упаковки поставки товара
	static int IdGoodsSingleBarcode; // (fldGoods) Штрихкод товара
	static int IdReportTypeName;    // (fldReportTypeID) Строка типа отчета (стандартный или локальный)
	static int IdLogFileName;		// Имя файла журнала
	static int IdSysJActionName;    // Строка наименования системного события //
	static int IdGtaJActionName;    // Строка наименования тарифицируемого события глобальной учетной записи
	static int IdCounter;           // Счетчик. ((long)(long *)) В качестве параметра должен
		// передаваться указатель на статическую переменную long.
	static int IdPropSubStr;        // (ObjType, ObjID, PropID, Sub)
		// Подстрока, извлекаемая из строки переменной длины,
		// привязанной к объекту {ObjType, ObjID} с идентификатором PropID.
		// Индекс подстроки задается значением Sub.
	static int IdCheckUserID;       // (userID, filtUserID) Проверка на соответствие пользователя userID критерию filtUserID
	static int IdCheckWmsLocID;     // (locID, filtLocID) Проверка на принадлежность локации locID критерию filtLocID.
		// locID принадлежит filtLocID если PPObjLocation::IsMemberOfGroup(locID, filtLocID).
	static int IdTransportTypeName; // (fldTransportTypeID) Строка типа транспортного средства (Автомобиль или судно)
	static int IdLotCloseDate;      //
	static int IdFormatCycle;       // (fldDate, CycleList) Форматирует временной цикл (@>>PPCycleArray::formatCycle)
	static int IdYesWordByFlag;     // (flags, flag) Если flag присутствует в flags, то возвращаем "Да", иначе пустую строку
	static int IdBudgetPlanOrFact;  // (amount, kind, is_fact) Если kind != is_fact, то 0 иначе amount
	static int IdChkOpJActionName;  // (action_id - 0..)
	static int IdAddrCityName;      // (locID)
	static int IdAddrExField;       // (locID, locExFld)
	static int IdCheckCsPosNode;    // (csessID, posNodeID)
	static int IdCheckCsPosNodeList; // (csessID, (const LongArray *))
	static int IdStrExistSubStr;	// @vmiller (fldName, const char *) Определяет, содержит ли строковое поле заданную подстроку
	static int IdAddedCreditLimit;  // @v8.2.4 (limit, limit_term, added_limit_term)
	static int IdBillFrghtIssueDt;  // @v8.2.9 (billID)
	static int IdBillFrghtArrvlDt;  // @v8.2.9 (billID)
	static int IdBillFrghtDlvrAddr; // @v8.7.9 (billID)
	static int IdGetAgrmntSymbol;   // @vmiller
	static int IdBillAgentName;     // @v8.3.6 (billID) Наименование агента по документу (извлекается из записи расширения документа)
	static int IdRegisterText;      // @v8.4.4 (registerID) Текст описания регистрационного документа
	static int IdObjTagText;        // @v8.4.11 (tagid, objid) Текстовое представление тега объекта
	static int IdDateRange;         // @v8.6.4  (low, upp) Текстовое представление периода
	static int IdOidText;           // @v8.6.11 (objType, objID) Текстовое представление полного OID
	static int IdDateBase;          // @v8.6.11 (dateValue, baseDate) Текстовое представление даты, сжатой в виде количества дней, прошедших с baseDate
	static int IdBillFrghtStrgLoc;  // @v8.8.6 (billID)
	static int IdSCardExtString;    // @v9.6.1 (scardID, fldId)

	static int SLAPI Register();
	static int SLAPI InitObjNameFunc(DBE & rDbe, int funcId, DBField & rFld);
	static int SLAPI InitLongFunc(DBE & rDbe, int funcId, DBField & rFld);
	static int SLAPI InitFunc2Arg(DBE & rDbe, int funcId, DBItem & rA1, DBItem & rA2);
	//
	// ARG(incDiv) Если !0, то результат равен (100 * div / (divisor+div))
	//   В противном случае (100 * div / divisor)
	//
	static int SLAPI InitPctFunc(DBE & rDbe, DBField & rFld1, DBField & rFld2, int incDiv = 0);
	//static PPID FASTCALL helper_dbq_name(const DBConst * params, char * pNameBuf);
	static PPID FASTCALL helper_dbq_name(const DBConst * params, char * pNameBuf);
};
//
//
//
#define MONEYTOLDBL(m)         dectobin((m),sizeof(m),2)
#define LDBLTOMONEY(ldbl,m)    dectodec((ldbl),(m),sizeof(m),2)
#define MONEYTOMONEY(s,d)      dectodec(dectobin((s),sizeof(s),2),(d),sizeof(d),2)
#define CONFIRM(m)             (PPMessage(mfConf|mfYes|mfNo,m)==cmYes)
#define CONFIRM_S(m,s)         (PPMessage(mfConf|mfYes|mfNo,m,s)==cmYes)
#define CONFIRMCRIT(m)         (PPMessage(mfCritWarn,m)==cmYes)
// @v9.6.3 @useless #define CHKACCS(l)             ((l)>=LConfig.AccessLevel)
#define THROW_PP(expr,val)     {if(!(expr)){PPSetError(val);goto __scatch;}}
#define THROW_PP_S(expr,val,s) {if(!(expr)){PPSetError(val,s); goto __scatch;}}
#define THROW_SL(expr)         {if(!(expr)){PPSetErrorSLib();goto __scatch;}}
#define THROW_MEM(expr)        {if(!(expr)){PPSetErrorNoMem();goto __scatch;}}
#define THROW_INVARG(expr)     {if(!(expr)){PPSetErrorInvParam();goto __scatch;}}
#define THROW_DB(expr)         {if(!(expr)){PPSetErrorDB();goto __scatch;}}
#define THROW_LXML(expr, ctx)  {if(!(expr)){PPSetLibXmlError(ctx);goto __scatch;}}
#define CALLEXCEPT_PP(val)     {PPSetError(val);goto __scatch;}
#define CALLEXCEPT_PP_S(val,s) {PPSetError(val,s); goto __scatch;}
#define CATCHZOKPPERR \
	goto __sendcatch;__scatch:\
	ok = PPErrorZ();\
	__sendcatch:;

#define BR2(v) R2(v) // Используется для округления сумм документов
#define TR5(v) R5(v) // Используется для округления цен в Transfer

long SLAPI CheckXORFlags(long v, long f1, long f2);
long SLAPI SetXORFlags(long v, long f1, long f2, long f);

// @v8.0.3 long SLAPI PPStartProfile();
// @v8.0.3 long SLAPI PPEndProfile();
// @v8.0.3 long SLAPI PPGetProfile();
//
// Функции и макросы для профилирования кодов
//
#define USRPROFF_FINISHED 0x00000001L

struct PPUserProfileFileItem {
	S_GUID DbID;
	char   DbSymb[32];
	LDATETIME CrtDtm;
	int64  StartOffs;
	int64  FinishOffs;
};

struct PPUserProfileFile { // @Property
	PPID   ObjType;
	PPID   ObjID;
	PPID   PropID;
	long   Count;
	// PPUserProfileLogOffsItem[Count]
};

struct PPUserProfileFuncEntry {
	static uint16 FromLoggedFuncId(long logFuncId, uint16 * pFuncVer)
	{
		ASSIGN_PTR(pFuncVer, (uint16)(logFuncId%1000));
		return (uint16)(logFuncId/1000);
	}
	long   GetLoggedFuncId() const
	{
		return (((long)FuncId)*1000)+((long)FuncVer);
	}
	enum {
		fFinishOnly = 0x0001, // Для функции не формируется стартовая запись (предполагается гарантированное завершение)
		fAccumulate = 0x0002  // Для функции результаты профилирования накапливаются в аккумуляторе
			// и сбрасываются в журнал время от времени.
	};
	uint16 FuncId;      // @anchor
	uint16 FuncVer;
	uint16 FactorCount;
	uint16 Flags;
	uint32 AccumLimit;
};

class Profile : public SArray {
public:
	SLAPI  Profile(int singleThreaded = 0);
	SLAPI ~Profile();
	int    SLAPI Output(uint fileId, const char * pDescription);
	int    SLAPI Start(const char * pFileName, long lineNum, const char * pAddedInfo = 0); // @cs
	int    SLAPI Finish(const char * pFileName, long lineNum); // @cs
	int    SLAPI Start(uint logFileId, const char * pName, const char * pAddedInfo = 0);  // @cs
	int    SLAPI Finish(uint logFileId, const char * pName, const char * pAddedInfo = 0); // @cs
	uint64 SLAPI GetAbsTimeMicroseconds(); // @cs

	int    SLAPI InitUserProfile(const char * pUserName);
	int    SLAPI SetUserProfileFactor(uint handle, uint factorN, double value);
	double SLAPI GetUserProfileFactor(uint handle, uint factorN) const;
	//
	// Descr: Возвращает идентификатор функции профилирования, с которой ассоциирован хандлер handle.
	//
	int    FASTCALL GetUserProfileFuncID(uint handle) const;
	uint   FASTCALL StartUserProfileFunc(int funcId);
	int    FASTCALL FinishUserProfileFunc(uint handle);
	int    SLAPI FlashUserProfileAccumEntries();

	enum {
		fkSession = 1,
		fkStart,
		fkFinish
	};

	SString & GetUserProfileFileName(int fk, SString & rBuf);
private:
	virtual void FASTCALL freeItem(void *);
	ProfileEntry & FASTCALL at(uint) const;
	void * FASTCALL Search(const char * pFileName, long lineNum) const;
	int    SLAPI Insert(ProfileEntry *, uint * p);
	int    SLAPI AddEntry(const char * pFileName, long lineNum, int iterOp, const char * pAddedInfo = 0);
	uint64 SLAPI Helper_GetAbsTimeMicroseconds();
	int    SLAPI Helper_Start(const char * pFileName, long lineNum, const char * pAddedInfo);
	int    SLAPI Helper_Finish(const char * pFileName, long lineNum);

	const  int SingleThreaded;
	int64  StartClock; // время в промежутках по 100 нс начиная с полуночи 01/01/1601 GMT
	int64  EndClock;   // время в промежутках по 100 нс начиная с полуночи 01/01/1601 GMT
	uint64 ClockFrequency; // result of QueryPerformanceFrequency()
	//
	// Descr: Специализированный блок переменных, используемых только функцией Helper_GetAbsTimeMicroseconds
	//
	struct GetTimeBlock {
		uint64 StartHrc;       // start of QueryPerformanceCounter()
		uint64 PrevHrc;        //
		uint32 StartTick;      // start of GetTickCount()
	};
	//
	// Descr: Блок, хранящий постоянные для потока данные, ради 'кономии времени на вывод в журналы.
	//
	struct UserProfileStaticBlock {
		S_GUID SessUuid;
		S_GUID DbUuid;
		SString DbSymb;
		SString LogFileName_Start;
		SString LogFileName_Finish;
		SString LogItemPrefix;
	};
	//
	//
	//
	struct UserProfileEntry {
		PPUserProfileFuncEntry Fe;
		int64  Seq;
		uint64 StartClock;
		LDATETIME StartDtm;
		uint64 AccumClock;
		uint64 Accum;
		double Factors[8];
	};

	UserProfileStaticBlock UPSB;
	TSStack <UserProfileEntry> UserProfileStack;
	TSArray <UserProfileEntry> UserProfileAccum;
	//
	//
	//
	struct FunctionStartDtm {
		uint      FuncId;
		uint64    StartClock;
		LDATETIME StartDtm;
	};
	GetTimeBlock Gtb;
	SMtLock Lck;
};

class PPUserFuncProfiler {
public:
	static int SLAPI Init();
	//
	// Descr: Возвращает имя файла начала или окончания профилировани
	//
	static SString & SLAPI GetFileName_(int fk /* Profile::fkXXX */, SString & rBuf);
	//
	// Descr: Конструктор. Если funcId != 0, то сразу запускает процесс профилирования функции.
	//   В противном случае должен быть вызван метод Begin() для запуска профилирования.
	//
	SLAPI  PPUserFuncProfiler(int funcId);
	//
	// Descr: Деструктор. Если процесс профилирования был запущен, но не был остановлен методом
	//   Commit(), то останавливает профилирование функции.
	//
	SLAPI ~PPUserFuncProfiler();
	int    SLAPI operator !() const;
	int    SLAPI FlashAccumEntries();
	//
	// Descr: Запускает процесс профилирования Функции funcId если он до этого не был запущен.
	//
	int    FASTCALL Begin(int funcId);
	//
	// Descr: Завершает процесс профилирования установленной до этого функции.
	//
	int    SLAPI Commit();
	int    SLAPI CommitAndRestart();
	int    SLAPI SetFactor(uint factorN, double value);
	double SLAPI GetFactor(uint factorN) const;
private:
	uint   H;
};

// @v8.0.3 extern Profile * P_Profiler; // @global

#if SL_PROFILE && !defined(DL600C) // {
	// @v8.0.3 #define PROFILE_INIT // @v8.0.3 delete P_Profiler; P_Profiler = new Profile;
	#define PROFILE(line) \
		{DS.GProfileStart(__FILE__, __LINE__); \
		line;             \
		DS.GProfileFinish(__FILE__, __LINE__);}
	#define PROFILE_S(line,s) \
		{DS.GProfileStart(__FILE__, __LINE__, s); \
		line;             \
		DS.GProfileFinish(__FILE__, __LINE__);}
	#define PROFILE_START        {long ln_num = __LINE__; DS.GProfileStart(__FILE__, ln_num);
	#define PROFILE_START_S(s)   {long ln_num = __LINE__; DS.GProfileStart(__FILE__, ln_num, s);
	#define PROFILE_END          DS.GProfileFinish(__FILE__, ln_num); }
	// @v8.0.3 #define PROFILE_REPORT(description) P_Profiler->Output(0, description)
#else
	// @v8.0.3 #define PROFILE_INIT
	#define PROFILE(line) line
	#define PROFILE_S(line,s) line
	#define PROFILE_START
	#define PROFILE_START_S(s)
	#define PROFILE_END
	#define PROFILE_END_THR
	// @v8.0.3 #define PROFILE_REPORT(description)
#endif // } SL_PROFILE

//
// @ModuleDecl(PPSync)
// Модуль блокировки объектов данных
//

//
// Descr: Заголовок файла блокировок
//
struct PPSyncHeader {      // @persistent @size=62 (+4 Lock Prefix Size)
	long   Magic;          // unique identifier
	long   RecsCount;      // number of records
	int16  Ver;            // Since v4.6.15 Ver=1
	char   Reserved[52];   // @reserve
};

#define PPSYNC_SEMAPHORE  1
#define PPSYNC_MUTEX      2
#define PPSYNC_DBLOCK     3
//
// Descr: Запись файла блокировок
//
struct PPSyncItem {        // @persistent @size=66 (+4 Lock Prefix Size)
	long   ID;             // record id
	long   Type;           // record type (1-Semaphore, 2-Mutex, 3-DbLock, 0-Logout) PPSYNC_XXX
	long   UserID;         // user unique identifier
	char   Name[32];       // user name
	long   ObjType;        // type of semaphore object
	long   ObjID;          // semaphore object identifier.
		// Для типа записи PPSYNC_DBLOCK (пользовательская сессия) значение этого
		// поля может быть 0 или 1. 1 означает, что вход совершен серверной сессией.
	long   Counter;        // semaphore/mutex counter
	MACAddr MchnID;        //
	ulong  TerminalSessID; //
};

typedef TSArray <PPSyncItem> PPSyncArray;
//
// Descr: Класс, управляющий блокировками объектов данных
//
class PPSync {
public:
	SLAPI  PPSync();
	SLAPI ~PPSync();
	int    SLAPI Init(const char * pDataPath);
	//
	// Descr: Closes file. If database don't locked, then removes sync file.
	// Returns:
	//   1 - Файл был открыт. Функция его успешно закрыла, но не удалила, по-скольку он заблокирован.
	//   2 - Файл был открыт. Функция его успешно закрыла, и удалила.
	//  -1 - Файл не был открыт.
	//
	int    SLAPI Release();
	int    SLAPI LoginUser(long userID, const char * pUserName, long * pSessID, const MACAddr * pMachineID, ulong terminalSessID);
	int    SLAPI LogoutUser(long sessID);
	//
	// Checks is sombody works with database.
	// Returns 1 if database is locked, 0 - otherwise.
	//
	int    SLAPI IsDBInUse();
	int    SLAPI GetItemsList(long recType, PPSyncArray *);
	int    SLAPI GetItem(PPID id, PPSyncItem * pItem);
	int    SLAPI LockDB();
	int    SLAPI UnlockDB();
	//
	// Checks is login to database is forbidden.
	// Returns 1 if database is locked, 0 - otherwise.
	//
	int    SLAPI IsDBLocked();
	int    SLAPI CreateMutex(long sessionid, long objtype, long objid, long * pMutexID, PPSyncItem *);
	int    SLAPI ReleaseMutex(long objtype, long objid);
	int    SLAPI ReleaseMutex(long mutexid);
	int    SLAPI ClearMutex(long mutexID);
	int    SLAPI IsMyLock(long sessID, long objtype, long objid);
	int    SLAPI GetLockingText(PPID mutexID, int resolveHostName, SString & rBuf);
private:
	int    Handle;
	int    NoSHARE; // if !0 then share.exe not loaded (DOS)
	SString DataPath;

	SString & SLAPI GetFileName(SString & rBuf) const;
	int    SLAPI CreateEmptyFile();
	int    SLAPI ImplementGetBlock(ulong offs, void * pBuf, int * pIsLocked);
	long   SLAPI AddRecord(long type, long appID, const char * pName, long, long, ulong * pOffs, const MACAddr * pMachineID, ulong terminalSessID);
	int    SLAPI Lock(ulong offs, int checkOnly);
	int    SLAPI Unlock(ulong offs);
	int    FASTCALL IsLocked(ulong offs);
	int    SLAPI ReleaseItem(ulong offs);
	int    SLAPI GetInitPosition(ulong * pOffs, long * pNumItems);
	int    SLAPI GetHeader(ulong offs, PPSyncHeader *, int * pIsLocked);
	int    SLAPI GetItem(ulong offs, PPSyncItem *, int * pIsLocked);
	int    FASTCALL AdvanceOffset(ulong * pOffs) const;
	int    SLAPI GetOffsetByID(long id, ulong * pOffs);
	int    SLAPI GetFreeEntry(ulong * pOffs, long * pId);
	int    SLAPI SearchMutexByObj(long objtype, long objid, PPSyncItem * pItem, ulong * pOffs);
	int    SLAPI ReleaseSessionMutex(long sessID);
	int    FASTCALL CheckOffset(ulong offs) const;
};
//
// Backing up
//
struct PPBackupScen {
	SLAPI  PPBackupScen();
	int    SLAPI ToStr(SString & rBuf) const;
	long   ID;
	char   Name[64];
	char   DBName[64];
	char   BackupPath[MAXPATH];
	long   Period;     // Backup period (days)
	long   Flags;      // Reserved
	long   numCopies;  // Max number of copies
};

//void TestMonitor();

class PPBackup : public DBBackup {
public:
	static PPBackup * SLAPI CreateInstance(PPDbEntrySet2 *);

	SLAPI  PPBackup(const char * pDbName, DbProvider * pDb);
	SLAPI ~PPBackup();
	int    SLAPI IsValid() const;
	int    SLAPI EnumScen(long *, PPBackupScen *);
	int    SLAPI GetScen(long, PPBackupScen *);
	int    SLAPI GetLastScenCopy(PPBackupScen *, BCopyData *);
	//
	// Descr: пытается заблокировать БД для входа. Если ей это удалось сделать,
	//   то возвращается (>0) в противном случае функция выдает на экран запрос
	//   на ожидание возможности заблокировать БД. Если пользователь отвечает
	//   отрицательно или прерывает ожидание, то возвращается (<0). В случае ошибки возвращается 0.
	//
	int    SLAPI LockDatabase();
	int    SLAPI UnlockDatabase();
private:
	int    SLAPI GetScenList(SArray *);
	int    SLAPI GetDefaultScen(PPBackupScen *);
	int    SLAPI GetDefaultBackupPath(char *) const;
	virtual int SLAPI CBP_CopyProcess(const char * pSrcFile, const char * pDestFile,
		int64 totalSize, int64 fileSize, int64 totalBytesReady, int64 fileBytesReady);

	enum {
		stValid      = 0x0001,
		stDbIsLocked = 0x0002
	};
	long   State;
	char   DBName[64];
	SArray * P_ScenList;
	PPSync * P_Sync;
};
//
// PPMsgLog
//
#define LF_BUFFSIZE  4096
#define LF_MAXMSG    1000
#define LF_DONTWRITE 0x00010000l
#define LF_SHOW      0x00020000l
#define LF_MODAL     0x00040000l

struct PPLogIdx {
	long   flags;
	long   address;
};
//
// PPMsgLog::SaveLogFile options
//
#define SAVELOGF_OVERWRITE  0x0001L
#define SAVELOGF_APPEND     0x0002L

#define LOGLIST_MAXSTRLEN   256

struct MsgLogItem {
	char   LogListStr[LOGLIST_MAXSTRLEN];
};

class PPMsgLog {
public:
	//
	// Descr: Удаляет все файлы, сформированные логгером и не удаленные из-за
	//   аварийного прерывания сеанса.
	//
	static int SLAPI RemoveTempFiles();

	SLAPI  PPMsgLog();
	virtual SLAPI ~PPMsgLog();
	long   SLAPI GetCount() const;
	long   SLAPI GetCurMsg() const;
	long   SLAPI GetVisCount() const;
	// -1 - error code
	// 0 - no action
	long   SLAPI PutMessage(const char * pBody, long flags = 0, const void * head = 0, size_t hsize = 0);
	long   SLAPI Init();
	void   SLAPI DeleteVisibleMessage(long row);
	int    SLAPI SaveLogFile(const char *, long flags);
	int    SLAPI Print();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(MsgLogItem *);
	virtual int SLAPI ShowLogWnd(const char * pTitle = 0);
	//
	// If nmsg>0 - search message with No=nmsg
	// If nmsg=0 - search next message
	// Return 0 - end of search
	// > 0 - message number
	//
	long   SLAPI EnumMessages(long nmsg, void* buff, int16 bsize, int16 *retsize, int16 *hsize);
	long   SLAPI GetVisibleMessage(long nrow);
	void * SLAPI GetRow(long r);
protected:
	virtual  long  SLAPI ImplPutMsg(const char * pText, long flags);
	void   SLAPI Destroy();
	PPLogIdx SLAPI GetLogIdx(long);
	void   SLAPI SetLogIdx(long, PPLogIdx *);

	long   CurMsg;
	char   TmpText[LF_BUFFSIZE];
	long   Valid;
	long   AllCount;
	SString FileName;
	SString InFileName;
	int    Stream;
	int    InStream;
	SArray * P_Index;
	int    NextStrOffset;
};

class PPLogger {
public:
	enum {
		fDisableOutput = 0x0001
	};
	SLAPI  PPLogger(long flags = 0);
	SLAPI ~PPLogger();
	int    SLAPI Log(const char * pMsg);
	int    SLAPI LogMsgCode(uint msgOptions, uint msgId, const char * pAddedInfo);
		// @>>PPGetMessage(msgOptions, msgId, pAddedInfo, ...)
	int    SLAPI LogSubString(uint strID, int idx);
	int    SLAPI LogString(uint strId, const char * pAddedInfo);
	int    SLAPI LogAcceptMsg(PPID objType, PPID objID, int upd);
		// @>>PPObject::GetAcceptMsg
	int    SLAPI LogLastError();
	int    SLAPI Save(const char * pFileName, long options); // @>>PPMsgLog::SaveLogFile
	int    SLAPI Save(uint fileId, long options); // @>>PPMsgLog::SaveLogFile
	void   SLAPI Clear();
private:
	long   Flags;
	PPMsgLog * P_Log;
};
//
// Descr: Опции функция вывода в журнал
//
#define LOGMSGF_TIME        0x0001L // Выводить текущее время //
#define LOGMSGF_USER        0x0002L // Выводить имя активного пользователя //
#define LOGMSGF_LASTERR     0x0004L // Выводить текст сообщения о последней ошибке @#{pStr == 0}
#define LOGMSGF_DBINFO      0x0008L // Выводить символ базы данных
#define LOGMSGF_COMP        0x0010L // Выводить имя компьютера
#define LOGMSGF_UNLIMITSIZE 0x0020L // Размер файла не лимитирован
#define LOGMSGF_THREADINFO  0x0040L // Сообщение заносится в информационный буфер потока (для отображения в мониторах)
#define LOGMSGF_THREADID    0x0080L // Выводить идент потока
#define LOGMSGF_DIRECTOUTP  0x0100L // @v9.2.0 Сообщение выводится без посредничества специального потока, управляющего выводом в журналы
#define LOGMSGF_NODUPFORJOB 0x0200L // @v9.2.11 Сообщение не следует дублировать в спец журнале для рассылки результатов выполнения задач

int SLAPI PPLogMessage(const char * pFileName, const char * pStr, long options);
int SLAPI PPLogMessage(uint fileNameId, const char * pMsg, long options);
int SLAPI PPLogMessageList(uint fileNameId, const SStrCollection & rList, long options);
int SLAPI PPLogMessage(uint fileId, uint strGroup, uint strId, long options);
//
//
//
struct PPObjID {
	PPObjID Set(PPID objType, PPID objID);
	int    SLAPI IsEqual(PPID objType, PPID objID) const;
	int    FASTCALL operator == (PPObjID s) const;
	int    FASTCALL operator != (PPObjID s) const;
	operator double() const;
	PPObjID & FASTCALL operator = (double);
	//
	// GOODS(1204)
	//
	int    SLAPI ToStr(int format, SString & rBuf) const;
	int    FASTCALL FromStr(const char * pStr);

	PPID   Obj;
	PPID   Id;
};

DECL_CMPFUNC(PPObjID);

class PPObjIDArray : public TSArray <PPObjID> {
public:
	friend class PPObjectTransmit;
	SLAPI  PPObjIDArray();
	int    SLAPI Search(PPObjID key, uint * pPos) const;
	int    SLAPI Add(PPID objType, PPID objID);
	int    SLAPI Add(PPID objType, const PPIDArray & rList);
	int    SLAPI Add_NotPreprocess(PPID objType, PPID objID);
	int    FASTCALL Is_NotPreprocess_Pos(uint pos) const;
	int    SLAPI ProcessRef(PPID objType, PPID * pObjID);
private:
	int    DoReplace; // @transient
	LongArray DontPreprocPosList; // @transient Список позиций, которые не должны обрабатываться //
		// функцией PPObjectTransmit::RestoreObj() при приеме данных из другого раздела.
};
//
// ObjRestrictArray
//
// Descr: Список, позволяющий хранить список ссылок на объекты
//   с дополнительными флагами. Тип объектов определяется неявно
//   использующим контекстом.
//   Используется в правах доступа, обобщенных объектах и др.
// @todo DATE:12/06/2004 Объединить с LAssocArray
//
struct ObjRestrictItem {
	PPID   ObjID;
	long   Flags;
};

class ObjRestrictArray : public TSArray <ObjRestrictItem> {
public:
	SLAPI  ObjRestrictArray();
	SLAPI  ObjRestrictArray(const ObjRestrictArray &);
	ObjRestrictArray & FASTCALL operator = (const ObjRestrictArray &);

	enum {
		moEmptyListIsFull = 0x0001 // Пустой список дает все доступные права
	};

	int    SLAPI Merge(const ObjRestrictArray * pS, long options);
	int    SLAPI Add(PPID objID, long flags, uint * pPos);
	//
	// Returns:
	//   0  - В списке уже есть элемент с идентификатором id
	//   !0 - В списке нет элемента с идентификатором id.
	//
	int    SLAPI CheckUniqueID(PPID id) const;
	int    SLAPI UpdateItemByID(PPID id, long flags);
	int    SLAPI RemoveItemByID(PPID id);
	int    SLAPI SearchItemByID(PPID id, uint * pPos) const;
	int    SLAPI CheckFlag(PPID id, long flag) const;
private:
	int    SLAPI Helper_MergeItems(const ObjRestrictArray * pS);
};
//
// Общие флаги доступа (первые восемь бит зарезервированы как общие)
//
#define PPR_READ        0x0001
#define PPR_INS         0x0002
#define PPR_MOD         0x0004
#define PPR_DEL         0x0008
#define PPR_ADM         0x0010
//
// Последние два операционных бита зарезервированы
//
#define PPORF_INHERITED 0x4000 // Структура унаследована от вышестоящего объекта
#define PPORF_DEFAULT   0x8000 // Права установлены по умолчанию (не из БД)
//
// @v1.9.7
// Variable length struct
//
class ObjRights { // @persistent
public:
	static ObjRights * SLAPI Create(PPID objType, size_t totalSize);
	static void FASTCALL Destroy(ObjRights * pObj);
	//void * SLAPI operator new(size_t sz, size_t extra = 0);
	//void   SLAPI operator delete(void *, size_t extra);
	ObjRights(PPID objType = 0);

	PPID   ObjType;
	uint16 Size;
	uint16 Flags;
	long   OprFlags; // @v8.5.5 ushort->long
	// ... [Size - sizeof(ObjRights)];
};

struct PPAccessRestriction { // @transient (translated for storage to PPRights)
public:
	enum {
		pparR = 1,
		pparW
	};
	enum {
		cfStrictOnlyGoodsGrp      = 0x0001,  // Строгое ограничение на товарную группу OnlyGoodsGrpID
		cfDesktopCr               = PPR_INS, // (0x0002) Возможнось создавать рабочие столы
		cfDesktopMod              = PPR_MOD, // (0x0004) Возможность изменять рабочие столы
		//
		// -- Если (CFlags & (cfOwnBillRestr|cfOwnBillRestr2)) == cfOwnBillRestr
		//    то доступ ограничен только теми документами, которые пользователь сам создал
		// -- Если (CFlags & (cfOwnBillRestr|cfOwnBillRestr2)) == cfOwnBillRestr2
		//    то доступ ограничен только теми документами, которые созданы либо
		//    самим пользователем, либо пользователями, входящими в ту же группу, что
		//    и данный пользователь.
		//
		cfOwnBillRestr            = 0x0008,
		cfOwnBillRestr2           = 0x0010,
		cfApplyBillPeriodsToCSess = 0x0020  // @v9.2.11 Применять периоды доступа к документам и к кассовым сессиям
	};
	SLAPI  PPAccessRestriction();
	int    SLAPI GetRBillPeriod(DateRange *) const;
	int    SLAPI GetWBillPeriod(DateRange *) const;
	int    SLAPI SetBillPeriod(const DateRange * pPeriod, int setROrW);
	int    SLAPI GetPeriodInputExt(TDialog * pDlg, uint ctrlID, int setROrW);
	int    SLAPI SetPeriodInputExt(TDialog * pDlg, uint ctrlID, int getROrW) const;
	int    SLAPI GetOwnBillRestrict() const;
	void   SLAPI SetSaveMode(int saveData);

	LTIME  TimeBeg;       // Допустимое начало рабочей сессии (0..23:59:59)
	LTIME  TimeEnd;       // Допустимый конец рабочей сессии
	ushort WeekDays;      // Допустимые дни работы (биты: 0 - вскр, 1 - пнд ...)
	short  PwMinLen;      // Минимальная длина пароля //
	short  PwPeriod;      // Продолжительность действия пароля (дней)
	short  AccessLevel;   // Уровень доступа
	long   CFlags;        // Общие флаги прав (PPAccessRestriction::cfXXX)
	PPID   OnlyGoodsGrpID; //
private:
	//
	// В следующих четырех полях, если LDATE::year() == 0x8000 и LoWord(LDATE::v) & 0x8000 != 0, то
	// LoWord(LDATE::v) & 0x7fff представляет собой знаковое смещение относительно текущей системной даты.
	//
	//LDATE  LowRBillDate;  // Дата, до которой R-доступ к документам запрещен
	//LDATE  UppRBillDate;  // Дата, после которой R-доступ к документам запрещен
	//LDATE  LowWBillDate;  // Дата, до которой W-доступ к документам запрещен
	//LDATE  UppWBillDate;  // Дата, после которой W-доступ к документам запрещен
	DateRange RBillPeriod;
	DateRange WBillPeriod;
	int    ShowInnerDates; // В GetR(W)BillPeriod подставлять даты так, как они хранятся //
};

class PPRights {
public:
	static ushort SLAPI GetDefaultFlags();
	static long   SLAPI GetDefaultOprFlags();

	SLAPI  PPRights();
	SLAPI ~PPRights();
	PPRights & FASTCALL operator = (const PPRights &);
	size_t SLAPI Size() const;
	void   SLAPI Empty();
	int    SLAPI IsEmpty() const;
	int    SLAPI IsInherited() const;

	int    SLAPI Merge(const PPRights & rS, long flags);

	int    SLAPI Put(PPID securType, PPID securID);
	int    SLAPI Get(PPID securType, PPID securID, int ignoreCheckSum = 0);
	int    SLAPI Remove(PPID securType, PPID securID);
	//
	// Descr: Возвращает указатель на дескриптор прав доступа по объекту objType.
	//   ! Возвращенный указатель должен быть освобожден вызывающей функцией !
	//   (delete p_rights)
	// ARG(objType    IN): Тип объекта, для которого необходимо получить дескриптор прав
	// ARG(useDefault IN): Если !0 и собственной записи прав доступа для типа объектов objType
	//   нет, то функция создаст дескриптор по умолчанию.
	//
	ObjRights * SLAPI GetObjRights(PPID objType, int useDefault = 0) const;
	const ObjRights * SLAPI GetConstObjRights(PPID objType, ObjRights * pDef = 0) const;
	//
	// Descr: устанавливает новые права доступа к объекту objType.
	//   Если rt == 0, то права доступа для этого объекта удаляются.
	//   Если replace == 0 и в структуре уже имеются права для заданного
	//   объекта, то они не заменяются на новые.
	//
	int    SLAPI SetObjRights(PPID objType, const ObjRights * rt, int replace = 1);
	PPAccessRestriction & SLAPI GetAccessRestriction(PPAccessRestriction & rAcsr) const;
	int    SLAPI SetAccessRestriction(PPAccessRestriction *);
	//
	// Descr: Проверяет доступность даты dt для работы с документом.
	//   Если forRead == 0, то проверяется возможность записи, в противном
	//   случае проверяется возможность чтения.
	// Returns:
	//   !0 - дата dt доступна (если forRead, то на чтение).
	//   0  - дата dt не доступна.
	//
	int    SLAPI CheckBillDate(LDATE dt, int forRead = 0) const;
	int    SLAPI AdjustBillPeriod(DateRange & rPeriod, int checkOnly) const;
	int    SLAPI AdjustCSessPeriod(DateRange & rPeriod, int checkOnly) const;
	int    SLAPI IsOpRights() const;
	int    SLAPI IsLocRights() const;
	int    SLAPI ExtentOpRights();
	int    SLAPI MaskOpRightsByOps(PPIDArray * pOpList, PPIDArray * pResultOpList) const;
	int    SLAPI MaskOpRightsByTypes(PPIDArray * pOpTypeList, PPIDArray * pResultOpList) const;
	int    SLAPI CheckOpID(PPID, long) const;
	int    SLAPI CheckLocID(PPID, long) const;
	int    SLAPI CheckPosNodeID(PPID id, long flags) const;
	int    SLAPI CheckQuotKindID(PPID id, long flags) const;
	int    SLAPI CheckAccID(PPID, long) const;
	int    SLAPI CheckDesktopID(long deskID, long rt) const;

	ObjRestrictArray * P_OpList;   // Доступные операции
	ObjRestrictArray * P_LocList;  // Доступные склады
	ObjRestrictArray * P_CfgList;  // Список доступных конфигураций
	ObjRestrictArray * P_AccList;  // Список доступный счетов. Элемент с ид = 0 - для счетов отсутствующих в списке
	ObjRestrictArray * P_PosList;  // @v8.9.1 Список доступных кассовых узлов
	ObjRestrictArray * P_QkList;   // @v8.9.1 Список доступных видов котировок
private:
	ulong  SLAPI CheckSum();
	int    SLAPI Resize(uint);
	int    SLAPI ReadRights(PPID securType, PPID securID, int ignoreCheckSum);

	_PPRights * P_Rt;
};

int    SLAPI ParseBound(const char * pBuf, long * pVal);
//
// Descr: Класс, управляющий ini-файлами
//
class PPIniFile : public SIniFile {
public:
	static int   FASTCALL GetSectSymb(int idx, SString & rBuf);
	static int   FASTCALL GetParamSymb(int idx, SString & rBuf);

	SLAPI  PPIniFile(const char * pFileName = 0, int fcreate = 0, int winCoding = 0, int useIniBuf = 0);
	int    SLAPI GetEntryList(uint sectId, StringSet * pEntries, int storeAllString = 0);
	int    SLAPI Get(uint sectId, uint paramId, SString & rBuf);
	int    SLAPI Get(uint sectId, const char * pParamName, SString & rBuf);
	int    SLAPI Get(const char * pSectName, uint paramId, SString & rBuf);
	int    SLAPI GetInt(uint sectId, uint paramId, int *);
	int    SLAPI GetInt(const char * pSectName, uint paramId, int *);
	int    SLAPI Append(uint sectId, uint paramId, const char * pVal, int overwrite);
	int    SLAPI IsWinCoding();
	int    SLAPI Backup(uint maxCopies = 5);
	int    SLAPI UpdateFromFile(const char * pSrcFileName);
private:
	int    SLAPI ParamIdToStrings(uint sectId, uint paramId, SString * pSectName, SString * pParam);
};

class PPRegKeys {
public:
	static const char * PrefSettings;          // @defined(ppappo.cpp) "Software\\Papyrus\\Pref"
	static const char * PrefBasketSelSettings; // @defined(ppappo.cpp) "Software\\Papyrus\\Pref\\BasketSel"
	static const char * SysSettings;           // @defined(ppappo.cpp) "Software\\Papyrus\\System"
	static const char * Sessions;              // @defined(ppappo.cpp) "Software\\Papyrus\\Sessions"
};
//
//
//
class PPConfigDatabase {
public:
	enum {
		tExport = 1,
		tImport,
		tMenu,
		tDesktop,
		tJob
	};
	//
	// Descr: Заголовочная структура объекта конфигурации, хранящегося в базе данных.
	//   Уникальными комбинациями структуры являются {ID} и {Type, Name, DbSymb, OwnerSymb}
	//
	struct CObjHeader {
		CObjHeader();
		int    Cmp(const CObjHeader & rS, long flags) const;

		int32  ID;         //
		int32  Ver;        //
		int32  Type;       //
		int32  Flags;      //
		SString Name;      // Наименование конфигурации
		SString SubSymb;   // Уточняющая строка.
			// tExport:  символ внутренней структуры данных
			// tImport:  символ внутренней структуры данных
			// tMenu:    none
			// tDesktop: none
			// tJob:     символ команды
		SString DbSymb;    // Символ базы данных, к которой относится конфигурация (может быть пустым)
		SString OwnerSymb; // Символ владельца конфигурации. Конкретный смысл зависит от типа записи (может быть пустым)
	};
	struct CItemHeader {
		int32  ID;
		int32  ObjID;
		SString Name;
	};

	SLAPI  PPConfigDatabase(const char * pDbDir);
	SLAPI ~PPConfigDatabase();
	int    SLAPI Open(const char * pDbPath);
	int    SLAPI Close();
	int    SLAPI GetObjList(int type, const char * pSubSymb, const char * pDbSymb, const char * pOwner, StrAssocArray & rList);
	int    SLAPI GetObj(int32 id, CObjHeader * pHdr, SBuffer * pData);
	int    SLAPI GetObj(CObjHeader & rHdr, int32 * pID, SBuffer * pData);
	int    SLAPI PutObj(int32 * pID, CObjHeader & rHdr, SBuffer & rData, int use_ta);
	int    SLAPI DeleteObj(int32 id, int use_ta);
private:
	class CObjTbl : public BDbTable {
	public:
		SLAPI  CObjTbl(BDbDatabase * pDb);
		SLAPI ~CObjTbl();
		int    SLAPI SerializeKeyBuf(int dir, CObjHeader * pKey, SBuffer & rBuf);

		long   SeqID;
	private:
		virtual int Implement_Cmp(const BDbTable::Buffer * pKey1, const BDbTable::Buffer * pKey2);
	};
	class CObjTailTbl : public BDbTable {
	public:
		SLAPI  CObjTailTbl(BDbDatabase * pDb);
		SLAPI ~CObjTailTbl();
	};
	BDbDatabase * P_Db;
	CObjTbl * P_OT;
	CObjTailTbl * P_OtT;
};
//
// @vmiller
// Descr: Вспомогательная структура, содержащая параметры для импорта/экспорта данных через dll
//
struct ImpExpParamDllStruct {
	ImpExpParamDllStruct();

	long   BeerGrpID;		   // ИД группы товаров "пиво"
	long   AlcoGrpID;		   // ИД группы товаров "алкоголь"
	long   AlcoLicenseRegID;  // ИД регистра производителя с номером "лицензия на алкоголь"
	long   TTNTagID;		   // ИД тега с номером ТТН
	long   ManufTagID;		   // ИД тега импортера/производител
	long   ManufKPPRegTagID;  // ИД регистра производителя с номером КПП
	long   RcptTagID;		   // ИД тега для пометки о доставке заказа поставщику
	long   ManufRegionCode;   // Код региона из адреса производителя/импортера
	long   IsManufTagID;	   // Если 1, то персоналия-производитель, 2 - персоналия-импортер
	long   GoodsKindTagID;    // ИД тега лота, определяющего вид товара
	long   ManufINNID;        // ИД тега лота, содержащего ИНН производител
	SString DllPath;
	SString FileName;
	SString Login;
	SString Password;
	SString GoodsKindSymb;	   // По какому параметру искать вид товара: x, y, z, w
	SString XmlPrefix;
	SString OperType;		   // Тип операции импорта/экспорта
	SString GoodsVolSymb;      // По какому параметру смотреть объем продукции: x, y, z, w
};
//
// Descr: Структура соответсвия полей и параметров импорта/экспорта данных
// @defined(PPLIB\RFLDCORR.CPP)
//
class PPImpExpParam {
public:
	static PPImpExpParam * FASTCALL CreateInstance(const char * pIehSymb, long flags);
	static PPImpExpParam * FASTCALL CreateInstance(uint recId, long flags);

	PPImpExpParam(uint recID = 0, long flags = 0);
	virtual ~PPImpExpParam();
	int    SLAPI Init(int import = 0); // @v7.6.0 (int import = 0)
	virtual int Edit();
	virtual int Select();
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	//
	// Descr: Эта функция должна выполнить одну из трех операций над именем конфигурации экспорта:
	//   (op == 1) - [decorate name] Модифицировать имя конфигурации так, чтобы обеспечить
	//      уникальность этого имени среди других конфигураций импорта/экспорта, относящихся к
	//      другим классам
	//   (op == 2) - [undecorate name] Убрать декорирующую часть из имени так, чтобы пользователь
	//      видел то имя конфигурации, которое он задал.
	//   (op == 3) - [check decorated name] Проверить правильность декорированного имени конфигурации
	//   (op == 4) - [check undecorated name] Проверить правильность недекорированного имени конфигурации
	// Returns:
	//   >0 - функция выполнена успешно
	//   0  - ошибка
	//   <0 - функция не выполняла ни каких действий
	//
	virtual int ProcessName(int op, SString & rName) const;
	//
	// Descr: Функция должна сформировать имя файла экспорта на основании значения FileName и
	//   вернуть полное имя файла по ссылке rResult.
	// Note:
	//   Функция принципиально константная и не может ни при каких обстоятельствах
	//   менять внутреннее состояние экземпляра объекта - это связано с особенностями вызова данной функции.
	// Returns:
	//   1 - имя файла используется то же, что и было задано в FileName
	//   100 - имя файла сформировано по шаблону, заданному в FileName
	//   0 - ошибка
	//
	virtual int MakeExportFileName(const void * extraPtr, SString & rResult) const;
	virtual int PreprocessImportFileSpec(const SString & rFileSpec, PPFileNameArray & rList);
	virtual int PreprocessImportFileName(const SString & rFileName, StrAssocArray & rResultList);

	int    GetFilesFromSource(const char * pWildcard, PPLogger * pLogger);
	int    DistributeFile(PPLogger * pLogger);

	enum {
		dfText = 0,
		dfDbf,
		dfXml,
		dfSoap,
		dfExcel
	};
	enum {
		bfDLL            = 0x0001,
		bfDeleteSrcFiles = 0x0002
	};
	uint   RecId;
	long   DataFormat;      // dfXXX
	long   Direction;       // 0 - экспорт, 1 - импорт
	// @v8.4.6 long   ImpExpByDll;		// 0 - по-старому, 1 - через dll // @vmiller
	long   EDIDocType;      // Тип докумнта для импорт/экспорта с помощью EDI // @vmiller
	long   BaseFlags;       // @v8.4.6 PPImpExpParam::bfXXX
	PPID   FtpAccID;        // @v8.6.1 Учетная запись FTP-сервера
	TextDbFile::Param  TdfParam;
	XmlDbFile::Param   XdfParam;
	SoapDbFile::Param  SdfParam;
	ExcelDbFile::Param XlsdfParam;
	SdRecord HdrInrRec;     // Запись, определяющая заголовочный внутренний набор данных.
	SdRecord HdrOtrRec;     // Запись, определяющая заголовочный внешний набор данных.
	SdRecord InrRec;        // Запись, определяющая внутренний набор данных
	SdRecord OtrRec;        // Запись, определяющая внешний (для импорта/экспорта) набор данных
	SString Name;           // Название конфигурации
	SString DataSymb;       // Символ наименования структуры данных
	SString GlobalUserName; // Если конфигурация принадлежит глобальной учетной записи, то здесь задается имя аккаунта.
	SString FileName;       // Имя файла импорта/экспорта
	ImpExpParamDllStruct ImpExpParamDll; // @vmiller
private:
	int    ParseFormula(int hdr, SString & rPar, SString & rVal);
};

extern "C" typedef PPImpExpParam * (*FN_IMPEXPHDL_FACTORY)(long flags);

#define IMPEXP_HDL_FACTORY(iehSymb)  IEHF_##iehSymb
#define IMPLEMENT_IMPEXP_HDL_FACTORY(iehSymb, cls) \
	extern "C" __declspec(dllexport) PPImpExpParam * IEHF_##iehSymb(long flags) { return new cls(PPREC_##iehSymb, flags); }
//
// ARG(fileNameId  IN): Идентификатор имени файла, из которого следует получить описание формата
// ARG(sdRecId     IN): Идентификатор записи, в соответствии с которой должен быть получено описание формата
// ARG(pParam     OUT): Описание формата, заполняемое функцией
// ARG(pSectNames OUT): Функция заносит в этот список наименования секций файла, содержащих описания форматов
// ARG(kind        IN): Параметр, определяющий фильтрацию видов описаний
//   0 - и импорт и экспорт
//   1 - только экспорт
//   2 - только импорт
//
int SLAPI GetImpExpSections(uint fileNameId, uint sdRecId, PPImpExpParam * pParam, StringSet * pSectNames, int kind);
int SLAPI GetImpExpSections(uint fileName, uint sdRecID, PPImpExpParam * pParam, StrAssocArray * pList, int kind);
//
// Descr: Класс, реализующий универсальный механизм импорта/экспорта данных
// Note: Функции класса считают, что все строковые поля при экспорте
//   поставляются в ANSI кодировке (не OEM)
//
class PPImpExp {
public:
	//
	// Descr: Вспомогательная функция, обеспечивающая разрешение выражения,
	//   представленного наименованием поля структуры rRec.
	//   Используется в контекстах разбора выражений.
	//
	static int ResolveVarName(const char * pSymb, const SdRecord & rRec, double * pVal);

	PPImpExp(const PPImpExpParam *, const void * extraPtr);
	~PPImpExp();
	int    IsCtrError() const;
	int    IsOpened() const;
	int    OpenFileForReading(const char * pFileName);
	int    OpenFileForWriting(const char * pFileName, int truncOnWriting, StringSet * pResultFileList = 0);
	int    CloseFile();
	int    GetFilesFromSource(const char * pWildcard, PPLogger * pLogger);
	int    DistributeFile(PPLogger * pLogger);
	int    AppendHdrRecord(void * pDataBuf, size_t dataBufLen);
	int    AppendRecord(void * pDataBuf, size_t dataBufLen);
	int    InitDynRec(SdRecord * pDynRec) const;
	int    ReadRecord(void * pInnerBuf, size_t bufLen, SdRecord * pDynRec = 0);
	int    GetNumRecs(long * pNumRecs);
	//
	// Descr: Устанавливает внешний контекст для разрешения формул.
	//   Экземпляр класса PPImpExp не владеет переданным указателем.
	//   То есть, вызывающая функция (класс) должна сама
	//   позаботиться о разрушении объекта, на который ссылается переданный указатель.
	// Note: Передаваемый контекст должен уметь распознавать
	//   переменные, представленные наименованиями полей структуры импорта/экспорта.
	//   Для этого следует использовать вспомогательную статическую функцию PPImpExp::ResolveVarName.
	//
	void   SetExprContext(ExprEvalContext * pCtx);
	int    SetHeaderData(const Sdr_ImpExpHeader * pData);
	const  PPImpExpParam & GetParam() const;
	//
	// Descr: Сохраняет текущее состояние, позволяет считывать в буфер данные о подчиненном элементе.
	//
	int    SLAPI Push(PPImpExpParam * pParam);
	//
	// Descr: Восстанавливает текущее состояние.
	//
	int    SLAPI Pop();
	int    FASTCALL GetFileName(SString & rFileName) const;
	const  SString & SLAPI GetPreservedOrgFileName() const;
	//
	// Descr: Функция возвращает подготовленные экспортированные данные в буфере rBuf.
	//   Может быть использована только в том случае, если при инициализации
	//   было директивно предопределено требование выгружать данные не в файл, а в буфер памяти.
	// Returns:
	//   >0 - данные успешно скопированы в буфер
	//   <0 - функция не может быть выполнена поскольку экспорт был осуществлен в файл
	//   0  - ошибка
	//
    int    FASTCALL GetExportBuffer(SBuffer & rBuf);
private:
	enum {
		sOpened   = 0x0001, // Файл открыт
		sReadOnly = 0x0002, // Объект работает в режиме "Чтение"
		sCtrError = 0x0004, // Если в контструкторе возникла ошибка, то этот флаг устанавливается //
		sBuffer   = 0x0008  // @v8.6.8 Обмен осуществляется посредством буфера, а не файла (пока доступно только для экспорта в XML)
	};
	// @vmiller
	struct StateBlock {
		StateBlock();

		int    Busy;
		ulong  RecNo;
		SString FileNameRoot;
		PPImpExpParam Param;
	};
	int    Helper_OpenFile(const char * pFileName, int readOnly, int truncOnWriting, StringSet * pResultFileList);
	int    ResolveFormula(const char * pFormula, const void * pInnerBuf, size_t bufLen, SString & rResult);
	int    GetArgList(SStrScan & rScan, StringSet & rArgList);
	int    ConvertInnerToOuter(int hdr, const void * pInnerBuf, size_t bufLen);
	int    ConvertOuterToInner(void * pInnerBuf, size_t bufLen, SdRecord * pDynRec);
	PPImpExpParam P;
	long   State; // PPImpExp::sXXX
	DbfTable    * P_DbfT;
	TextDbFile  * P_TxtT;
	XmlDbFile   * P_XmlT;
	SoapDbFile  * P_SoapT;
	ExcelDbFile * P_XlsT;
	Sdr_ImpExpHeader * P_HdrData;    // @v7.4.6
	ExprEvalContext * P_ExprContext; // @notowned
	ulong  R_RecNo;
	ulong  W_RecNo;
	ulong  R_SaveRecNo;
	int    ExtractSubChild;
	SString PreserveOrgFileName; // @v9.3.10
	// @v9.3.10 PPImpExpParam SaveParam;
	TSCollection <StateBlock> StateColl; // @vmiller
	TSStack <int> StateStack; // @vmiller
};
//
//
//
class PPDbTableXmlExporter {
public:
	struct BaseParam {
        SLAPI  BaseParam(uint32 sign);
        int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fReplaceIdsBySync = 0x0001
		};
        uint32 Sign;
        long   Flags;
        PPID   RefDbID;
		SString FileName;
	};
    SLAPI  PPDbTableXmlExporter();
    virtual SLAPI ~PPDbTableXmlExporter();
    virtual DBTable * Init() = 0;
    virtual int  Next() = 0;
    int    SLAPI Run(const char * pOutFileName);
protected:
	IterCounter Cntr;
};

struct PPDbTableXmlExportParam_TrfrBill : public PPDbTableXmlExporter::BaseParam {
public:
	static int SLAPI SLAPI Edit(PPDbTableXmlExportParam_TrfrBill * pData);
	SLAPI  PPDbTableXmlExportParam_TrfrBill();
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	DateRange Period;
};

class PPDbTableXmlExporter_Transfer : public PPDbTableXmlExporter {
public:
	SLAPI  PPDbTableXmlExporter_Transfer(const PPDbTableXmlExportParam_TrfrBill & rParam);
private:
    virtual DBTable * Init();
    virtual int  Next();

	PPDbTableXmlExportParam_TrfrBill P;
    Transfer * P_T;
    BExtQuery * P_Q;
};

class PPDbTableXmlExporter_Bill : public PPDbTableXmlExporter {
public:
	SLAPI  PPDbTableXmlExporter_Bill(const PPDbTableXmlExportParam_TrfrBill & rParam);
private:
    virtual DBTable * Init();
    virtual int  Next();

	PPDbTableXmlExportParam_TrfrBill P;
    BillCore * P_T;
    BExtQuery * P_Q;
};
//
// Descr: Общий контекст разрешения формул по записи импорта/экспорта
//
class ImpExpExprEvalContext : public ExprEvalContext {
public:
	SLAPI ImpExpExprEvalContext(const SdRecord & rRec);
	virtual int SLAPI Resolve(const char * pSymb, double * pVal);
private:
	const SdRecord & R_Rec;
};
//
// @vmiller
// Класс для импорта/экспорта через dll
//
class ImpExpDll {
public:
	typedef int (* InitExpProc)(void * , const char * , int *);
	typedef int (* SetExpObjProc) (uint , const char * , void *, int *, const char *);
	typedef int (* InitExpIterProc) (uint , uint);
	typedef int (* NextExpIterProc) (uint , uint , void *);
	typedef int (* EnumExpReceiptProc) (void *);
	typedef int (* InitImpProc)(void * , const char * , int *);
	typedef int (* GetImpObjProc) (uint , const char * , void *, int *, const char *);
	typedef int (* InitImpIterProc) (uint , uint);
	typedef int (* NextImpIterProc) (uint , uint , void *);
	typedef int (* ReplyImpObjStatusProc) (uint , uint , void *);
	typedef int (* FinishImpExpProc) ();
	typedef int (* GetErrorMessageProc) (char * , uint);

	int operator !() const
	{
		if(OpKind == 1)
			return !(InitExport && SetExportObj && InitExportIter && NextExportIter && EnumExpReceipt &&
					FinishImpExp && GetErrorMessage);
		else
			return !(InitImport && GetImportObj && InitImportIter && NextImportIter && ReplyImportObjStatus &&
					FinishImpExp && GetErrorMessage);
	}

	ImpExpDll();
	~ImpExpDll();
	const int IsInited()
	{
		return Inited;
	}
	// pDllName - полный путь к dll
	// op - операция. 1 - экспорт, 2 - импорт
	int InitLibrary(const char * pDllName, uint op);
	void ReleaseLibrary();

	InitExpProc InitExport;
	SetExpObjProc SetExportObj;
	InitExpIterProc InitExportIter;
	NextExpIterProc NextExportIter;
	EnumExpReceiptProc EnumExpReceipt;
	InitImpProc InitImport;
	GetImpObjProc GetImportObj;
	InitImpIterProc InitImportIter;
	NextImpIterProc NextImportIter;
	ReplyImpObjStatusProc ReplyImportObjStatus;
	FinishImpExpProc FinishImpExp;
	GetErrorMessageProc GetErrorMessage;
private:
	int OpKind;
	int Inited;
	SDynLibrary * P_Lib;
};

int InitImpExpParam(uint hdrRecType, uint recType, PPImpExpParam * pParam, const char * pFileName, int forExport, long dataFormat);
int InitImpExpDbfParam(uint recType, PPImpExpParam * pParam, const char * pFileName, int forExport);
//
// Параметры подстановки объектов для получения агрегированных отчетов
// Строки соответствующие SubstGrpGoods: PPTXT_SUBSTGOODSLIST
//
enum SubstGrpGoods { // @persistent
	sggNone = 0,           //
	sggGeneric,            // PPObjGoods      Обобщенный товар
	sggGroup,              // PPObjGoodsGroup Обыкновенная товарная группа
	sggManuf,              // PPObjPerson     Производитель
	sggDimX,               // Размерность X
	sggDimY,               // Размерность Y
	sggDimZ,               // Размерность Z
	sggClsKind,            // Классификатор Kind
	sggClsGrade,           // Классификатор Grade
	sggClsAddObj,          // Классификатор AddObj
	sggClsKind_Grade,      // Классификаторы Kind-Grade
	sggSuppl,              // PPObjArticle  Поставщик
	sggBrand,              // PPObjBrand    Торговая марка
	sggClsKind_Grade_AddObj, // Классификаторы Kind-Grade-AddObj
	sggClsKind_AddObj_Grade, // Классификаторы Kind-AddObj-Grade
	sggSupplAgent,         // PPObjArticle  Агент поставщика
	sggLocation,           // PPObjLocation Склад
	sggBrandOwner,         // PPOBJ_PERSON(PPPRK_MANUF)
	sggVatRate,            // @v8.3.3 Ставка НДС в ценах реализации
	sggCVatRate,           // @v8.3.3 Ставка НДС в ценах поступления
	sggAlcoCategory,       // @v8.4.4 Категория алкогольной продукции по классификации РосАлкогольРегулирования
		// Доступно только в случае, если правильно определенаконфигруация алкогольной декларации
	sggDimW,               // @v8.6.1 Размерность W
	sggLocAssoc,           // @v8.6.1 Ассоциированное с товаром место хранения //
	sggType,               // @v9.6.0 Тип товара
	sggGroupSecondLvl = 100,   // PPObjGoodsGroup Группа уровня 2 и далее идут группы уровня 2 и т.д.
	sggTagBias        = 100000 // @v7.5.4 Смещение для группировки по тегам товаров.
};
//
// Строки соответствующие SubstGrpDate: PPTXT_SUBSTDATELIST
//
enum SubstGrpDate {
	sgdNone = 0,
	sgdWeek,
	sgdMonth,
	sgdQuart,
	sgdYear,
	sgdHour,    // для совместимости добавлены последними
	sgdWeekDay  // если нужно использовать эти 2 параметра, то в ComboBox должна грузиться строка PPTXT_SUBSTDATELISTEXT
};
//
// Строки соответствующие SubstGrpPerson: PPTXT_SUBSTPERSONLIST
//
enum SubstGrpPerson {
	sgpNone = 0,
	sgpCity,           // Город
	sgpRegion,         // Регион
	sgpCountry,        // Государство
	sgpCategory,       // Категория персоналии
	//
	// За подстановку вместо персоналии агента по документу и транспортного брокера функция PPObjPerson::Subst не
	// отвечает. О правильности такой подстановки должен позаботиться класс, отвечающий
	// за перебор объектов, в которых необходимо осуществить подстановку.
	//
	sgpBillAgent,      // Агент по документу
	sgpVesselAgent,    // Транспортный брокер
	sgpAccSheet,       // Таблица статей аналитического учета
	sgpFirstRelation = 10000,
		// 10001 начиная с этого значения, типы отношений персоналий
		// Строки соотвествующие типам отношений не указаны в PPTXT_SUBSTPERSONLIST
		// и заносятся в строки для combobox'а динамически
	sgpArticleMask   = 0x8000000 // Маска, индицирующая то, что идентификатор для подстановки
		// является статьей, а не персоналией.
};

#define IS_SGG_CLSSUBST(x) ((x)==sggDimX||(x)==sggDimY||(x)==sggDimZ||(x)==sggDimW||\
	(x)==sggClsKind||(x)==sggClsGrade||(x)==sggClsAddObj||(x)==sggClsKind_Grade||\
	(x)==sggClsKind_Grade_AddObj||(x)==sggClsKind_AddObj_Grade)
//
// Строки соответствующие SubstGrpSCard: PPTXT_SUBSTSCARDLIST
//
enum SubstGrpSCard {
	sgcNone = 0,
	sgcSeries,
	sgcOwner
};
//
// Descr: Варианты подстановки атрибута документа
//
struct SubstGrpBill { // @size=8
	SubstGrpBill();
	void   Reset();
	int    operator !() const;

	enum _S {
		sgbNone = 0,
		sgbOp,
		sgbDate,
		sgbLocation,
		sgbObject,
		sgbObject2,
		sgbStatus,
		sgbAgent,
		sgbPayer,
		sgbDebtDim,    // @v7.0.1
		sgbStorageLoc, // @v8.8.6 Место хранения, ассоциированное с фрахтом документа
		sgbDlvrLoc     // @v9.1.5 Адрес доставки
	} S;
	union {
		SubstGrpDate   Sgd;
		SubstGrpPerson Sgp;
	} S2;
};

class BillSubstList {
public:
	struct Item {
		PPID   BillID;
	};
	SLAPI  BillSubstList();
	int    SLAPI AddItem(const BillSubstList::Item * pItem, PPID * pID);
	int    SLAPI GetItem(PPID id, BillSubstList::Item * pItem) const;
private:
	SArray List;
	LAssocArray * P_AsscList;
};
//
// Descr: Внешнее представление 'лемента списка PPViewDisplayExtList
//   Схема нумерации идентификаторов данных:
//     1..1000 - зарезервировано за существующими полями (определенными в броузерах ppbrow.rc2)
//     1001..100000 - доступный для использования диапазон
//     100001.. - специальный диапазон для динамически заданных полей с использованием специальных комбинаций (например, тип т'га)
//
struct PPViewDisplayExtItem {
	int    DataId;   // Идентификатор данных для отображения.
	int    Position; // Позиция в таблице. 0 - на усмотрение отображающего класса, -1 - последней колонкой, >0 - явно заданное значение.
	SString Title;   // Заголовок колонки. Если строка пустая, то - на усмотрение отображающего класса.
};
//
// Descr: Класс PPViewDisplayExtList представляющий список (дополнительных) полей для отображения в
//   в таблицах объектов PPView. "кземпляр класса следует хранить в фильтре.
//
class PPViewDisplayExtList : private SStrGroup {
public:
	SLAPI  PPViewDisplayExtList();
	PPViewDisplayExtList & Clear();
	int    FASTCALL IsEqual(const PPViewDisplayExtList & rS) const;
	int    SLAPI SetItem(int dataId, int position, const char * pTitle);
	int    SLAPI GetItemByPos(uint pos, PPViewDisplayExtItem * pItem) const;
	int    SLAPI GetItemByDataId(int dataId, PPViewDisplayExtItem * pItem) const;
	int    SLAPI RemoveItem(int dataId);
	int    SLAPI Pack();
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);
private:
	int    SLAPI SearchItem(int dataId, uint * pPos) const;

	struct InnerItem { // @persistent
		int32  DataId;
		int32  Position;
		uint   TitleP;
		uint8  Reserve[16];
	};
	TSArray <InnerItem> L;
};
//
// Descr: Базовый класс для определения фильтров
//
class PPBaseFilt { // @persistent
public:
	static const char * P_TextSignature; // "#TFD";
	//
	// Флаги "врожденных" особенностей фильтра (Capability)
	//
	enum {
		cFlat = 0x0001 // Фильтр является "плоским" (то есть не содержит указателей и прочих отростков)
	};
	DECL_INVARIANT_C();
	SLAPI  PPBaseFilt(long signature, long capability, int32 ver);
	virtual SLAPI ~PPBaseFilt();
	virtual int SLAPI Init(int fullyDestroy, long extraData);
	virtual int SLAPI Write(SBuffer &, long) const;
	virtual int SLAPI Read(SBuffer &, long);
	virtual int SLAPI Copy(const PPBaseFilt *, int);
	//
	// Descr: Эта функция должна сравнить фильтры и, если они эквивалентны,
	//   вернуть значение >0.
	//
	virtual int SLAPI IsEqual(const PPBaseFilt *, int) const;
	virtual int SLAPI IsEmpty() const;
	//
	// Descr: описание внутреннего состояния фильтра
	//
	virtual int Describe(long flags, SString & rBuf) const;
	//
	// Descr: Проверяет соответствие между фильтром this и pS по сигнатуре.
	//   Метод используется для идентификации "подлога". То есть, выявлени
	//   факта передачи под видом PPBaseFilt не того типа фильтра,
	//   который ожидает некоторая функция.
	//
	int    FASTCALL IsA(const PPBaseFilt * pS) const;
	long   SLAPI GetSignature() const;
	int32  SLAPI GetVer() const;
	PPBaseFilt & FASTCALL operator = (const PPBaseFilt &);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
protected:
	//
	// Descr: Служебная функция, создающая копию фильтра pSrcFilt по указателю **ppDestFilt.
	//   Тип фильтра определяется аргументом filtId.
	//   Если pSrcFilt == 0, то *ppDestFilt разрушается (если не нулевой) и обнуляется.
	//
	static int SLAPI CopyBaseFiltPtr(int filtId, const PPBaseFilt * pSrcFilt, PPBaseFilt ** ppDestFilt); // @v8.4.1

	static const int RpvInvSignValue = 0xECA5B7F9;
	//
	// Descr: Если функция PPBaseFilt::Read встретила несоответствие считываемой версии
	//   фильтра текущей, и считываемая версия меньше текущей, то вызывает метод ReadPreviosVer()
	//   с номером считанной версии в качестве параметра.
	//
	//   Специальный случай: если параметр ver == PPBaseFilt::RpvInvSignValue (0xECA5B7F9) то это значит, что считанная в начале
	//   буфера 4-байтовая сигнатура не равна this->Signature.
	//   На момент ввода этого случая (@v9.2.1) функция Read не проверяла данное условие, по этому,
	//   если в ответ на такой параметр функция вернет <0 то считывание продолжится.
	//   Если порожденный класс каким-то специальным способом обрабатывает эту ситуацию, то
	//   он должен вернуть >0 (ok) или 0 (error).
	// Note: К моменту вызова ReadPreviosVer() смещение на чтение из буфера rBuf
	//   возвращется на исходную позицию, где оно находилось до вызова PPBaseFilt::Read
	// Returns:
	//   >0 - фильтр с заданной версией успешно считан.
	//   <0 - функция не поддерживается или нет возможности считать фильтр с заданным номером версии.
	//   0  - ошибка
	//
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
	//
	// Descr: Реализует извлечение параметров фильтрации из текстового описания.
	//   Функция вызывается из PPBaseFilt::Read при обнаружении специального префикса.
	// Returns:
	//   >0 - фильтр успешно считан
	//   <0 - функция считывания текстового описания не поддерживается //
	//   0  - ошибка
	//
	virtual int SLAPI ReadText(const char * pText, long); // @<<PPBaseFilt::Read
	//
	// Descr: Устанавилвает "плоский" участок фильтра. Такой участок фильтра базовый класс
	//   обрабатывает самостоятельно. Это касается методов Init, Write, Read, Copy, IsEqual.
	//
	void   SLAPI SetFlatChunk(size_t offs, size_t len);
	int    FASTCALL SetBranchSString(size_t offs);
	int    FASTCALL SetBranchSArray(size_t offs);
	int    FASTCALL SetBranchObjIdListFilt(size_t offs);
	int    FASTCALL SetBranchStrAssocArray(size_t offs);
	int    SLAPI SetBranchBaseFiltPtr(int filtID, size_t offs);
	int    FASTCALL SetBranchDisplayExtList(size_t offs); // @v8.2.9
	//
	// Вспомогательные методы для функции Describe
	//
	int    SLAPI PutObjMembToBuf(PPID objType, PPID objID, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutObjMembListToBuf(PPID objType, const ObjIdListFilt * pList, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutFlagsMembToBuf(StrAssocArray * pFlagList, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(LDATE, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(const DateRange *, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(const RealRange *, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(const char *, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(double, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutMembToBuf(long, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutSggMembToBuf(SubstGrpGoods,  const char * pMembName, SString & rBuf) const;
	int    SLAPI PutSgpMembToBuf(SubstGrpPerson, const char * pMembName, SString & rBuf) const;
	int    SLAPI PutSgdMembToBuf(SubstGrpDate,   const char * pMembName, SString & rBuf) const;
private:
	int    SLAPI CheckBranchOffs(size_t offs);
	void   SLAPI Destroy();
	int    SLAPI AddBranch(uint type, size_t offs, int32 extraId);

	long   Signature;
	long   Capability;
	int32  Ver;
	uint16 FlatOffs; // @transient Смещение плоского участка фильтра
	uint16 FlatSize; // @transient Длина плоского участка фильтра
	//
	// Описание ветвления структуры
	//
	struct Branch {
		enum {
			tSString = 1,
			tSArray,
			tObjIdListFilt,
			tBaseFiltPtr,
			tStrAssocArray,
			tDisplayExtList
		};
		uint16 Type;
		uint16 Offs;
		int32  ExtraId; // For tBaseFiltPtr - FiltID
	};
	SArray BranchList; // @transient Список ветвлений структуры фильтра
};
//
//
//
class TagFilt : public PPBaseFilt {
public:
	enum {
		fNotTagsInList = 0x0001,
		fColors        = 0x0002  // Фильтр используется для определения цветового выделения объектов, удовлетворяющих ограничениям
	};

	static int FASTCALL SetRestriction(const char * pRestrictionString, SString & rItemBuf);
	static int FASTCALL SetColor(const SColor * pClr, SString & rItemBuf);
	static int FASTCALL GetRestriction(const char * pItemString, SString & rRestrictionBuf);
	static int FASTCALL GetColor(const char * pItemString, SColor & rClr);
	static int FASTCALL SetRestrictionIdList(SString & rRestrictionBuf, const PPIDArray & rList);
	static int FASTCALL GetRestrictionIdList(const SString & rRestrictionBuf, PPIDArray * pList);

	SLAPI  TagFilt();
	virtual int SLAPI IsEmpty() const;
	TagFilt & FASTCALL operator = (const TagFilt & rS);
	int    FASTCALL Check(const ObjTagList * pList) const;
	int    SLAPI CheckTagItemForRestrict(const ObjTagItem * pItem, const SString & rRestrict) const;
	int    SLAPI SelectIndicator(PPID objID, SColor & rClr) const;

	char   ReserveStart[32];    // @anchor
	long   Flags;               // @flags
	StrAssocArray TagsRestrict; // @anchor
private:
	static int SLAPI ParseString(const char * pItemString, SString & rRestrictionBuf, SString & rColorBuf);
	static int SLAPI MergeString(const char * pRestrictionString, const char * pColorString, SString & rItemBuf);
	int   SLAPI Helper_CheckTagItemForRestrict_EnumID(const ObjTagItem * pItem, long restrictVal) const;
};
//
//
//
extern "C" typedef PPBaseFilt * (*FN_PPFILT_FACTORY)();

#define PPFILT_FACTORY(filtSymb)  BFF_##filtSymb
#define IMPLEMENT_PPFILT_FACTORY(filtSymb) \
	extern "C" __declspec(dllexport) PPBaseFilt * BFF_##filtSymb() { return new filtSymb##Filt(); }
//
// @ModuleDecl(PPConfig)
//

//
// Некоторые флаги установлены жестко, независимо от внешней настройки
// Такие установки делаются функцией PPSession::FetchConfig
//
#define CFGFLG_CHECKTURNREST           0x00000001L // Проверять остатки при бух. проводках
#define CFGFLG_DISCOUNTBYSUM           0x00000002L // Ввод скидки неявный через сумму
#define CFGFLG_UNITEINTRTRFR           0x00000008L // Объединять проводки по межскладской передаче товаров
#define CFGFLG_CHECKBILLACCS           0x00000010L // Проверять доступ к документам
#define CFGFLG_CHECKACCTACCS           0x00000020L // Проверять доступ к счетам
#define CFGFLG_FORCEMANUF              0x00000040L // При вводе товара необходимо ввести производителя //
#define CFGFLG_UNIQUELOT               0x00000080L // В одном пакете не может быть двух строк из одного лота
#define CFGFLG_SELGOODSBYPRICE         0x00000100L // Выбор товара при реализации по цене
#define CFGFLG_USEPACKAGE              0x00000200L // Использовать поля упаковки в диалогах PPTransferItem
	// Следующие два флага определяют направление округления //
	// Если оба этих флага установлены или сброшены, то до ближайшего
#define CFGFLG_ROUNDUP                 0x00000400L
#define CFGFLG_ROUNDDOWN               0x00000800L
#define CFGFLG_FREEPRICE               0x00002000L // Определяет, что цена реализации товаров является //
	// свободной. То есть при операциях с поставщиком и межскладских передачах
	// цена реализации не отражается в бухгалтерских проводках.
// @v8.6.6 @obsolete #define CFGFLG_NEJPBILL                0x00004000L // Не прогонять бумагу после печати накладной.
#define CFGFLG_ALLOWOVERPAY            0x00010000L // Допускается переплата по документам
#define CFGFLG_ENABLEFIXDIS            0x00020000L // Разрешать фиксацию скидки
#define CFGFLG_STAFFMGMT               0x00040000L // Управление кадрами
#define CFGFLG_TURNINVOICE             0x00080000L // Развернуть счет-фактуру
#define CFGFLG_MULTICURACCT            0x00100000L // Допускаются многовалютные счета (Global)
#define CFGFLG_AUTOQUOT                0x00200000L // Автоматически устанавливать котировку при продаже товара
#define CFGFLG_SHOWPHQTTY              0x00400000L // Показывать физические единицы в товарных документах
#define CFGFLG_CONFGBROWRMV            0x00800000L // Подтверждать удаление товарной строки документа
#define CFGFLG_SEC_CASESENSPASSW       0x01000000L // Пароль, чувствительный к регистру символов
#define CFGFLG_SEC_DSBLMULTLOGIN       0x02000000L // Запрет на вход в систему с одним именем с разных машин
#define CFGFLG_USEGOODSMATRIX          0x04000000L // Товарная матрица ограничивает выбор товаров в
	// списках и использование в документах. Эта опция занесена в общую конфигурацию для того, чтобы можно было
	// раздельно назначать ее разным пользователям (группам).
#define CFGFLG_SEC_DSBLNSYSDATE        0x08000000L // Запрет на вход с операционной датой, отличной от системной
#define CFGFLG_DONTPROCESSDATAONJOBSRV 0x10000000L // Не обрабатывать данные на Job сервере
#define CFGFLG_FEFO                    0x20000000L // @v8.6.6 Модификация метода подбора партий по наиболее близкому сроку истечения годности лота

#define CFGST_INITIATE           0x00000001L // Структура инициализирована
#define CFGST_INHERITED          0x00000002L // Структура унаследована от предыдущего уровня //
#define CFGST_MASTER             0x00000004L // Признак пользователя "Master"
#define CFGST_WAREHOUSE          0x00000008L // Текущая позиция - складская //
#define CFGST_PWEXPIRED          0x00000010L // Срок действия пароля истек
#define CFGST_EMPTYBASE          0x00000020L // Вероятно база данных пуста
#define CFGST_DEMOMODE           0x00000040L // Демо режим работы системы
#define CFGST_TRANSGLED          0x00000080L // Аварийный флаг, предназначен для передачи информации по лотам с товарами
#define CFGST_STOP               0x00000100L // Флаг останова текущего потока
#define CFGST_TRANSQUOT          0x00000200L // Флаг, предписывающий функции PPObjGoods::Read()
	// выставлять флаг GF_TRANSQUOT в извлеченном из БД пакете для переноса только котировок по товару
	// без изменения самого товара в разделе-приемнике.
	// Флаг CFGST_TRANSQUOT выставляется функцией PPViewQuot::Transmit() эта же функция снимает
	// убирает этот флаг после передачи товаров.
	// Возможно возникновение проблем при рекурсивном извлечении товаров или групп товаров от которых
	// зависит изначально извлекаемый товар (эти пакеты также получат указанный флаг).
//
// Опции и параметры конфигурации по умолчанию
//
#define DEFCFG_FLAGS             (CFGFLG_CHECKTURNREST|CFGFLG_UNITEINTRTRFR)
#define DEFCFG_RLZORD            RLZORD_FIFO
#define DEFCFG_ACCESS            0
#define DEFCFG_USERID            PPUSR_MASTER // Если в БД нет ни одного пользовател
#define DEFCFG_MENU              MENU_DEFAULT
#define DEFCFG_LOCATION          0
#define DEFCFG_LOCSHEET          0
#define DEFCFG_CURRENCY          0

struct PPConfig {          // @persistent @store(PropertyTbl) size=92
	SLAPI  PPConfig();

	long   Tag;            //  4  0 || PPOBJ_CONFIG || PPOBJ_USRGRP || PPOBJ_USR
	long   ObjID;          //  8  Идентификатор объекта к которому относится конфигурация //
	long   PropID;         // 12  Const=PPPROP_CFG
	PPID   DefBillCashID;  // 16  Кассовый узел, используемый для печати чеков по документам
	LDATE  InitDate;       // 20  Дата первого баланса после инсталляции
	LDATE  OperDate;       // 24  Операционная дата
	short  AccessLevel;    // 26  Из прав доступа (в БД - 0)
	long   BaseCurID;      // 30  Базовая валюта (PPOBJ_CONFIG only)
	short  RealizeOrder;   // 32  Порядок использования лотов при расходе товара
	short  Menu;           // 34  Номер меню, используемого этой конфигурацией
	PPID   User;           // 38
	PPID   LocAccSheetID;  // 42  Таблица аналитических статей, содержащая активную позицию
	PPID   Location;       // 46  Активная позиция //
	long   Flags;          // 50  Флаги CFGFLG_XXX
	long   State;          // 54  Текущее состояние (Только для текущего сеанса) CFGST_XXX
	short  BillAccess;     // 56  Уровень доступа к документу, устанавливаемый по умолчанию
	PPID   Cash;           // 60  Текущий кассовый узел (!0 только при вводе кассы)
	double RoundPrec;      // 68  Точность округления //
	PPID   MainOrg;        // 72  Главная организация по умолчанию
	long   SessionID;      // 76  Идентификатор сессии исполнения //
	PPID   DBDiv;          // 80  ИД раздела базы данных (PPOBJ_CONFIG only)
	long   BaseRateTypeID; // 84  Базовый тип валютного курса (PPOBJ_CONFIG only)
	long   DesktopID;      // 88  Идентификатор рабочего стола, испольуемого пользователем (группой)
	long   MenuID;         // 92  Идентификатор меню, испольуемого пользователем (группой)
};
//
// Descr: Частная конфигурация, привязанная к конкретному пользователю.
//   В этой структуре держатся поля, которые должны относится строго к пользователю
//   без возможности наследования из родительской конфигурации.
//
struct PPConfigPrivate {   // @persistent @store(PropertyTbl)
	long   Tag;            // Const=PPOBJ_USR
	long   ObjID;          // ->Ref(PPOBJ_USR)
	long   PropID;         // Const=PPPRP_CFGPRIVATE
	char   Reserve[60];    // @reserve
	long   DesktopID;      // Идентификатор рабочего стола, испольуемого пользователем
	long   Reserve2[2];    // @reserve
	char   Tail[1024];     //
};

#define PATHF_EMPTY              0x0001 // Может возвращаться функцией Path::GetPath
#define PATHF_INHERITED          0x4000 // Путь наследуется от предыдущего уровня //

class PPPaths {
public:
	SLAPI  PPPaths();
	SLAPI ~PPPaths();
	PPPaths & FASTCALL operator = (const PPPaths &);
	int    SLAPI IsEmpty() const;
	void   SLAPI Empty();
	int    SLAPI Get(PPID securType, PPID securID);
	int    SLAPI Put(PPID securType, PPID securID);
	int    SLAPI Remove(PPID securType, PPID securID);
	// @v9.4.8 int    SLAPI GetPath(PPID pathID, short * pFlags, char * pBuf, size_t bufSize) const;
	int    SLAPI GetPath(PPID pathID, short * pFlags, SString & rBuf) const;
	int    SLAPI SetPath(PPID pathID, const char * buf, short flags = 0, int replace = 1);
	int    SLAPI Get(PPID obj, PPID id, PPID pathID, SString & rBuf);
	// @v9.4.8 int    SLAPI Get(PPID obj, PPID id, PPID p, char * pBuf, size_t bufLen); // @obsolete
private:
	size_t SLAPI Size() const;
	int    SLAPI Resize(size_t);
	PathData * P;
};

class PPDriveMapping : public StringSet {
public:
	PPDriveMapping();
	int    Load(PPIniFile * pIniFile);
	int    Get(int drive, SString & rMapping) const;
	int    ConvertPathToUnc(SString & rPath) const;
};

struct PPPrinterCfg { // @persistent @store(PropertyTbl)
	enum {
		fUseDuplexPrinting = 0x0001 // Использовать дуплексную печать (Win32).
			// Этот флаг хранится в реестре win32 по адресу
			// HKEY_CURRENT_USER\\Software\\Papyrus\\System
			// Parameter UseDuplexPrinting=(1|0)
	};
	long   Tag;           // 0 || PPOBJ_CONFIG || PPOBJ_USRGRP || PPOBJ_USR
	long   ObjID;         //
	long   PropID;        // Const=PPPRP_PRINTER
	long   PrnCmdSet;     // ИД набора команд принтера
	short  LeftMargin;    // [0..127]
	int16  Flags;
	char   Port[64];
};

int SLAPI PPGetPrinterCfg(PPID obj, PPID id, PPPrinterCfg *);
int SLAPI PPSetPrinterCfg(PPID obj, PPID id, PPPrinterCfg *);
//
//
//
class UuidRefCore : public UuidRefTbl {
public:
	SLAPI  UuidRefCore();
	SLAPI ~UuidRefCore();
	int    SLAPI Search(long id, S_GUID & rUuid);
	int    SLAPI SearchUuid(const S_GUID & rUuid, int useCache, long * pID);
	//
	// Descr: Опции функции GetUuid
	//
	enum {
		sgoOptimistic = 0x0001, // Предварительно предполагается, что rGuid в таблице отсутствует
		sgoHash       = 0x0002  // Использовать хэш для поиска GUID
	};

	int    SLAPI GetUuid(const S_GUID & rUuid, long * pID, int options, int use_ta);
	int    SLAPI RemoveUuid(S_GUID & rUuid, int use_ta);
	int    SLAPI Remove(long id, int use_ta);
	int    SLAPI PutChunk(TSArray <S_GUID> & rChunk, uint maxCount, int use_ta);
private:
	//static int FASTCALL TextToUuid(const char * pText, S_GUID & rUuid);
	//static int FASTCALL UuidToText(const S_GUID & rUuid, SString & rText);
	int    SLAPI InitCache();

	GuidHashTable * P_Hash;
};
//
// Descr: Зарезервированные значения текстовых свойств объектов
// @persistent
//
#define PPTRPROP_DEFAULT   0
#define PPTRPROP_NAME      1 // Если у объекта есть и короткое и длинное наименования, то короткое заносится в PPTRPROP_NAME, а длинное - в PPTRPROP_LONGNAME
#define PPTRPROP_SYMB      2
#define PPTRPROP_LONGNAME  3
#define PPTRPROP_MEMO      4
#define PPTRPROP_COMBINE   5 // Комбинированная строка, содержащая набор текстовых свойств

#define PPTRPROP_USER    100 // Стартовое значение, с которого можно использовать пользовательские идентификаторы текстовых свойств

class TextRefIdent {
public:
	TextRefIdent();
	TextRefIdent(PPID objType, PPID objID, int16 prop);
	int operator !() const;

	PPObjID O; // Идентификатор объекта
	int16   P; // Идентификатор свойства
	int16   L; // Идентификатор языка (slangXXX; 0 - default)
};

class TextRefEnumItem : public TextRefIdent {
public:
	SString	S; // Строка UTF8
};

class TextRefCore : public TextRefTbl {
public:
	SLAPI  TextRefCore();
	int    SLAPI Search(const TextRefIdent & rI, SStringU & rBuf);
	int    SLAPI SearchSelfRef(long id, SStringU & rBuf);
	int    SLAPI SearchText(const TextRefIdent & rI, const wchar_t * pText, TextRefIdent * pResult);
	int    SLAPI SearchSelfRefText(const wchar_t * pText, PPID * pID);
	//
	// Descr: Находит SelfRefText через кэш.
	// Note: Параметр pText должен быть представлен в ANSI кодировке
	//
	int    SLAPI FetchSelfRefText(const char * pText, PPID * pID);
	int    SLAPI GetSelfRefText(const wchar_t * pText, PPID * pID, int use_ta);
	int    SLAPI SetText(const TextRefIdent & rI, const wchar_t * pText, int use_ta);
	int    SLAPI SearchTextByPrefix(const TextRefIdent & rI, const wchar_t * pPrefix, TSArray <TextRefIdent> * pList);
	int    SLAPI SearchSelfRefTextByPrefix(const wchar_t * pPrefix, TSArray <TextRefIdent> * pList);
private:
	int    SLAPI GetLastObjId(PPID objType, int prop, PPID * pID);
};

class UnxTextRefCore : public UnxTextRefTbl {
public:
	SLAPI  UnxTextRefCore();
	int    SLAPI Search(const TextRefIdent & rI, SStringU & rBuf);
	int    SLAPI SetText(const TextRefIdent & rI, const wchar_t * pText, int use_ta);
	//
	// Descr: Возвращает текст в кодировке utf-8
	//
	int    SLAPI GetText(const TextRefIdent & rI, SString & rBuf);
	//
	// Descr: Сохраняет текст, заданный в кодировке utf-8
	//
	int    SLAPI SetText(const TextRefIdent & rI, const char * pText, int use_ta);
	//
	SEnumImp * SLAPI Enum(PPID objType, int prop);
	int    SLAPI InitEnum(PPID objType, int prop, long * pHandle);
	int    SLAPI NextEnum(long enumHandle, TextRefEnumItem * pRec);
private:
	// @construction {
	class _Enum : public SEnumImp {
	public:
		_Enum(UnxTextRefCore * pT, long h);
		virtual ~_Enum();
		virtual int Next(void * pRec);
	protected:
		UnxTextRefCore * P_T;
		long   H;
	};
	// } @construction
	int    FASTCALL PostprocessRead(SStringU & rBuf);

	PPTblEnumList EnumList;
};
//
//
//
class ObjAssoc : public ObjAssocTbl {
public:
	friend class PPTblEnum <ObjAssoc>;

	SLAPI  ObjAssoc();
	int    SLAPI Add(PPID * pID, ObjAssocTbl::Rec * b, int use_ta);
	//
	// Descr: если pList != 0, добавляет в таблицу записи со следующими полями:
	//   {AsscType=asscTyp, PrmrObjID=pList[i].Key, ScndObjID=pList[i].Val, InnerNum=1 }
	//   Если preRemove != 0, то предварительно удаляет все записи, соответствующие
	//   типу ассоциации asscTyp.
	//   Если pList == 0 && preRemove, то записи удаляются все равно
	// ARG(asscTyp   IN): @#{!0}    тип ассоциации. Если 0, то функция возвращает ошибку (PPErrCode=PPERR_INVPARAM)
	// ARG(pList     IN): @#{vptr0} список ассоциаций, который следует добавить в таблицу.
	// ARG(preRemove IN): если !0, то прежде всего функция удалит все записи,
	//   имеющие тип ассоциации asscTyp
	// ARG(use_ta    IN): если !0, то операция осуществляется в транзакции
	// Returns:
	//   >0 - операция успешно выполнена
	//   0  - ошибка
	//
	int    SLAPI AddArray(PPID asscTyp, const LAssocArray * pList, int preRemove, int use_ta);
	//
	// Descr: добавляет в таблицу список записей pList по типу ассоциации asscTyp и с первичным
	//   идентификатором prmrID.
	//   Перед выполнением функции проверяются следующие условия:
	//     asscTyp != 0; prmrID != 0; pList == 0 || pList->getItemSize() == sizeof(ObjAssocTbl::Rec).
	//     Если эти условия не выполняются, то возвращается 0 с кодом ошибки PPERR_INVPARAM.
	//   Если параметр preRemove != 0, то предварительно удаляются все записи с типом ассоциации
	//   asscTyp и первичным идентификатором prmrID.
	//   При вставке записей из массива pList в каждой записи устанавливаются следующие атрибуты:
	//     AsscType = asscTyp; PrmrObjID = prmrID; если InnerNum == 0, то устанавливается равным
	//     позиции элемента в массиве pList с базой 1 (1..).
	// Returns:
	//   >0 - операция успешно выполнена
	//   0  - ошибка
	//
	int    SLAPI AddArray(PPID asscTyp, PPID prmrID, const SArray * pList, int preRemove, int use_ta);
	int    SLAPI Update(PPID asscID, ObjAssocTbl::Rec * pRec, int use_ta);
	int    SLAPI Remove(PPID asscID, int use_ta);
	//
	// Descr: удаляет кортеж записей, соответствующий условию:
	//   (!asscType || (asscTyp == AssType && (!prmr || prmr == PrmrObjID) &&
	//   (!scnd || scnd == ScndObjID)))
	//
	int    SLAPI Remove(PPID asscTyp, PPID prmrID, PPID scnd, int use_ta);
	int    SLAPI Search(PPID, ObjAssocTbl::Rec * = 0);
	int    SLAPI Search(PPID asscTyp, PPID prmrID, PPID scnd, ObjAssocTbl::Rec * = 0);
	int    SLAPI SearchNum(PPID asscTyp, PPID prmrID, long num, ObjAssocTbl::Rec * = 0);
	int    SLAPI SearchFreeNum(PPID asscTyp, PPID prmrID, long * num, ObjAssocTbl::Rec * = 0);
	int    SLAPI EnumByPrmr(PPID asscTyp, PPID prmrID, PPID * scnd, ObjAssocTbl::Rec * = 0);
	SEnumImp * SLAPI Enum(PPID asscType, PPID keyID, int byScnd);
	int    SLAPI GetList(PPID asscTyp, LAssocArray *);
	int    SLAPI GetListByPrmr(PPID asscTyp, PPID prmrID, PPIDArray * pList);
	int    SLAPI GetItemsListByPrmr(PPID asscType, PPID prmrID, SArray * pList);
	int    SLAPI Count(PPID asscTyp, PPID prmrID, long * pCount);
	int    SLAPI _SearchNum(PPID asscTyp, PPID prmrID, long num, int spMode, ObjAssocTbl::Rec *);
private:
	int    SLAPI GetByPrmr_Helper(PPID asscTyp, PPID prmrID, PPIDArray * pList, long * pCount, SArray * pItemsList);

	PPTblEnumList EnumList;
};
//
//
//
typedef int (*PPCheckInPersonTurnProc)(const PPCheckInPersonConfig * pCfg, PPCheckInPersonArray * pList, uint itemPos, void * pExtPtr);
//
// Descr: Транзиентная (пока) конфигурация регистрации персоналий
//
struct PPCheckInPersonConfig {
	SLAPI  PPCheckInPersonConfig();
	SLAPI  PPCheckInPersonConfig(PPObjTSession & rTSesObj, const TSessionPacket & rTSessPack);
	int    SLAPI operator !() const;

	enum {
		fInitPrc  = 0x0001, // При инициализации был идентифицирован процессор
		fInitTech = 0x0002, // При инициализации была идентифицирована технология
		fError    = 0x0004  // При инициализации экземпляра произошла ошибка
	};
	long   Flags;
	PPID   PersonKindID; // Вид персоналий, которые могут быть загеристрированы
	int    Capacity;     // Максимальное количество персоналий в регистрационном списке. 0 - unlimited
	PPID   GoodsID;      // Товар, который применяется для определения цены регистрации и для проведения кассового чека.
	PPID   LocID;        // Локация для определения цены товара GoodsID
	PPCheckInPersonTurnProc TurnProc; // Процедура для сохранения списка персональных регистраций.
		// Необходимость в процедуре (на текущий момент) обусловлена механизмом проведения чека для регистрации:
		// чек должен быть проведен только по объекту, который имеет свою копию в базе данных.
	void * P_TurnProcExt;
};
//
// Descr: Структура членства персоналии в агрегации "Регистрация персоналий".
//
class PPCheckInPersonItem { // @persistent(DBX) @flat
public:
	friend class PPCheckInPersonMngr;
	friend class PPCheckInPersonArray;

	DECL_INVARIANT_C();

	enum {
		statusUnkn = 0,
		statusRegistered = 1,
		statusCheckedIn,
		statusCanceled
	};
	enum {
		kUnkn = 0,
		kTSession
	};
	enum {
		fCheckedIn = 0x0001, // Подтвержденная регистрация (CheckIn)
		fCanceled  = 0x0002, // Явно отмененная регистрация //
		fAnonym    = 0x0004  // Запись с анонимной персоналией. Если флаг установлен, то поле PersonID
			// получает специальное значение.
	};
	SLAPI  PPCheckInPersonItem();
	int    SLAPI GetStatus() const;
	int    SLAPI SetStatus(int status);
	int    FASTCALL SetPerson(PPID personID);
	PPID   SLAPI GetPerson() const;
	int    SLAPI GetPersonName(SString & rBuf) const;
	int    SLAPI SetAnonym();
	int    SLAPI IsAnonym() const;
	//
	// Descr: Опции функции PPCheckInPersonItem::IsEqual
	//
	enum {
		eqoNoID    = 0x0001, // Сравнивать без учета ID
		eqoNoNum   = 0x0002, // Сравнивать без учета Num
		eqoKeyOnly = 0x0004  // Сравнивает комбинации {Kind, PrmrID, PersonID}
			// Если запись оба объекта анонимные, то PersonID не сравниваются.
			// Если одна запись анонимная, а другая - нет, то записи разные.
	};
	int    FASTCALL IsEqual(const PPCheckInPersonItem & rS, long options) const;
	int    FASTCALL operator == (const PPCheckInPersonItem & rS) const;
	int    SLAPI Count(uint * pRegCount, uint * pCiCount, uint * pCanceledCount) const;
	int    SLAPI CalcAmount(const PPCheckInPersonConfig * pCfg, double * pPrice, double * pAmount) const;
	PPCheckInPersonItem & SLAPI Clear();
	int    SLAPI CalcPinCode(SString & rCode) const;

	enum {
		opfVerifyPinCode = 0x0001
	};

	int    SLAPI Cancel(long flags, const char * pPinCode);
	int    SLAPI CheckIn(long flags, const char * pPinCode);

	PPID   ID;             // Идентификатор ассоциации. В пределах одного раздела БД строка идентифицируется этим полем.
	int32  Kind;           // Вид ассоциации.
	PPID   PrmrID;         // Идентификатор первичного объекта, для которого фиксируется регистрация (например, PPObjTSession)
private:
	PPID   PersonID;       // ->Person.ID
public:
	long   Num;            // Номер записи в однородном списке относительно заданного первичного объекта
	uint16 RegCount;       // Количество персоналий, включенное в данную регистрацию. Как правило =1,
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	uint16 CiCount;        // Количество персоналий, включенное в данную регистрацию со статусом CheckedIn. Как правило =(0|1),
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	long   Flags;          // @flags
	LDATETIME RegDtm;      // Время регистрации //
	LDATETIME CiDtm;       // Время подтверждения регистрации (CheckID)
	double Amount;         // Сумма, уплаченная или которая должна быть уплачена за регистрацию (подтверждение)
	PPID   CCheckID;       // Кассовый чек, которым оплачено подтверждение регистрации
	PPID   SCardID;        // Карта, с которой ассоциирована зерегистрированная персоналия //
	uint   MemoPos;        // @internal
	char   PlaceCode[8];   // @v8.6.5 Номер места (для регистрации, ассоциированной с посадочным местом)
	PPID   BillID;         // @v8.7.8 ИД документа, который связан с данной регистрацией
	uint8  Reserve[8];     // @v8.6.5 [20]-->[12]
};
//
// Descr: Список членства персоналий в агрегации "Регистрация персоналий"
//
class PPCheckInPersonArray : private TSArray <PPCheckInPersonItem> { // @persistent(DBX)
public:
	friend class PPCheckInPersonMngr;

	DECL_INVARIANT_C();

	SLAPI  PPCheckInPersonArray();
	PPCheckInPersonArray & SLAPI Init(int kind = 0, PPID prmrID = 0);
	PPCheckInPersonArray & SLAPI Clear();
	PPCheckInPersonArray & FASTCALL Copy(const PPCheckInPersonArray & rS);
	PPCheckInPersonArray & FASTCALL operator = (const PPCheckInPersonArray & rS);
	void   FASTCALL InitItem(PPCheckInPersonItem & rItem) const;
	int    SLAPI SearchByID(PPID id, uint * pPos) const;
	int    SLAPI SearchByNum(long num, uint * pPos) const;
	int    SLAPI SearchItem(const PPCheckInPersonItem & rItem, uint * pPos) const;
	uint   SLAPI GetCount() const;
	int    SLAPI AddItem(const PPCheckInPersonItem & rItem, const PPCheckInPersonConfig * pCipCfg, uint * pPos);
	int    SLAPI UpdateItem(uint pos, const PPCheckInPersonItem & rItem, const PPCheckInPersonConfig * pCipCfg);
	int    FASTCALL RemoveItem(uint pos);

	void   SLAPI Normalize(int kind, PPID prmrID);
	//
	// Descr: Вспомогательная функция, реализующая разрешение ссылок при синхронизации
	//   объекта, который содержит 'кземпляр this.
	//
	int    SLAPI ProcessObjRefs(PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);

	void   SLAPI InitIteration();
	int    FASTCALL NextIteration(PPCheckInPersonItem & rItem);

	int    SLAPI Count(uint * pRegCount, uint * pCiCount, uint * pCanceledCount) const;
	const  PPCheckInPersonItem & Get(uint pos) const;
	int    SLAPI CalcAmount(const PPCheckInPersonConfig * pCfg, double * pAmount) const;
	int    SLAPI SetMemo(uint rowPos, const char * pMemo);
	int    SLAPI GetMemo(uint rowPos, SString & rMemo) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	SVerT Ver;    // Версия системы, создавшая структуру. Необходимо для сериализации.
	int32  Kind;
	PPID   PrmrID;
	long   LastAnonymN;     // @v7.9.1 Последнее значение, использованное для нумерации анонимных записей
	StringSet MemoPool;     // @v7.8.10
};
//
// Descr: Класс, управляющий хранением и извлечением агрегации "Регистрация персоналий"
//
class PPCheckInPersonMngr {
public:
	SLAPI  PPCheckInPersonMngr();
	int    SLAPI Search(PPID id, PPCheckInPersonItem * pItem);
	int    SLAPI Search(/*int kind, PPID prmrID, PPID personID*/const PPCheckInPersonItem & rKeyItem, PPCheckInPersonItem * pItem);
	int    SLAPI Put(PPCheckInPersonItem & rItem, int use_ta);
	int    SLAPI Put(PPCheckInPersonArray & rList, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI Remove(int kind, PPID prmrID, int use_ta);
	int    SLAPI GetList(int kind, PPID prmrID, PPCheckInPersonArray & rList);
private:
	static PPID FASTCALL GetAssocType(int kind);
	static int  FASTCALL GetKind(PPID asscType);
	static int  FASTCALL ItemToStorage(const PPCheckInPersonItem & rItem, ObjAssocTbl::Rec & rRec);
	static int  FASTCALL StorageToItem(const ObjAssocTbl::Rec & rRec, PPCheckInPersonItem & rItem);
};
//
// @ModuleDecl(ObjTagCore)
// Теги объектов
//
// Типы данных для тегов
//
#define OTTYP_GROUP         0  // Группа тегов
#define OTTYP_BOOL          1  // Логическое значение
#define OTTYP_STRING        2  // Строка
#define OTTYP_NUMBER        3  // double
#define OTTYP_ENUM          4  // Перечисление (PPObjectTag::TagEnumID)
#define OTTYP_INT           5  // long
#define OTTYP_OBJLINK       6  // Ссылка на объект (PPObjectTag::TagEnumID)
#define OTTYP_DATE          7  // LDATE
#define OTTYP_GUID          8  // GUID
#define OTTYP_IMAGE         9  // Строка, содержащая путь к файлу с изображением
#define OTTYP_TIMESTAMP    10  // @v7.5.0 Временная метка.
#define OTTYP_LAST         10  // Последнее допустимое значение типа тега
//
// Флаги тегов
//
// @v8.0.1 флаг больше не используется - т'ги не могут быть дублируемыми #define OTF_DUP         0x0001 // Объекту может соответствовать несколько таких тегов с различающимися значениями
#define OTF_NOZERO           0x0002 // Тег с нулевым значение удаляется //
#define OTF_NMBRULE          0x0004 // Для тега с числовым значением определено правило
#define OTF_WARNZERO         0x0008 // Нулевое или отрицательное значение тега является поводом для предупреждения //
	// оператора (в документах, персональных операциях и т.д.)
#define OTF_INHERITABLE      0x0010 // @v7.4.5 Наследуемый tag. Интерпретация флага зависит от типа объектов,
	// к которому относится tag.
#define OTF_NOTICEINCASHPANE 0x0020 // Извещение в кассовой панели
#define OTF_HIERENUM         0x0040 // @v8.2.5 Иерерхическое перечисление

struct PPObjectTag2 {   // @persistent @store(Reference2Tbl+)
	PPID   Tag;         // Const=PPOBJ_TAG
	PPID   ID;          // @id
	char   Name[48];    // @name @!refname
	char   Symb[20];    // Символ для использования в формулах

	char   Reserve[48]; // @reserve
	PPID   LinkObjGrp;  // Дополнительный параметр для ссылочного объекта
	PPID   TagEnumID;   // Тип ссылочного объекта
	long   TagDataType; // OTTYP_XXX
	long   Flags;       // OTF_XXX

	PPID   ObjTypeID;   // Тип объекта, для которого определен тег
	PPID   TagGroupID;  // Группа, к которой относится тег
};

DECL_REF_REC(PPObjectTag);

class PPTagEnumList : public StrAssocArray {
public:
	SLAPI  PPTagEnumList(PPID enumID = 0);
	PPTagEnumList & FASTCALL operator = (const PPTagEnumList & s);
	int    FASTCALL Copy(const PPTagEnumList &);
	int    SLAPI PutItem(PPID * pID, const char * pName, PPID parentID);
	void   SLAPI SetEnumID(PPID enumID);
	PPID   SLAPI GetEnumID() const;
	void   SLAPI SetFlags(long flags);
	long   SLAPI GetFlags() const;
	//
	// Descr: Считывает из базы данных все элементы перечисления объекта enumID
	//
	int    SLAPI Read(PPID enumID);
	int    SLAPI Write(int use_ta);
private:
	PPID   EnumID;
	long   Flags;  // @v8.2.5
};
//
// Descr: Пакет объекта PPOBJ_TAG.
//   При обмене данными с другими разделами передается и принимается только
//   поле Rec (EnumList синхронизируется посредством Rec.TagEnumID, Rule не используется).
//
class PPObjTagPacket {
public:
	SLAPI  PPObjTagPacket();
	int    SLAPI Init();
	PPObjTagPacket & FASTCALL operator = (PPObjTagPacket &);

	PPObjectTag   Rec;
	//PPTagEnumList EnumList;
	SString Rule;
};
//
// Значение тега
//
class ObjTagItem {         // @persistent(DBX)
public:
	static SString & FASTCALL GetTypeString(int tagType, PPID enumId, SString & rBuf);

	SLAPI  ObjTagItem();
	SLAPI  ObjTagItem(const ObjTagItem & rS);
	SLAPI ~ObjTagItem();
	int    FASTCALL Init(PPID tagID);
	int    SLAPI SetInt(PPID tagID, long);
	int    SLAPI SetReal(PPID tagID, double);
	int    SLAPI SetStr(PPID tagID, const char *);
	int    SLAPI SetDate(PPID tagID, LDATE dt);
	int    SLAPI SetGuid(PPID tagID, const S_GUID *);
	int    SLAPI SetTimestamp(PPID tagID, LDATETIME dtm);
	int    SLAPI AddKeyword(PPID tagID, const char * pKeyword);

	int    FASTCALL GetInt(long *) const;
	int    FASTCALL GetReal(double *) const;
	int    FASTCALL GetStr(SString &) const;
	int    FASTCALL GetDate(LDATE *) const;
	int    FASTCALL GetGuid(S_GUID *) const;
	int    FASTCALL GetTimestamp(LDATETIME *) const;
	int    SLAPI    GetEnumData(long * pID, long * pParentID, SString * pTxt, SString * pSymb) const;

	int    SLAPI AddReal(double rVal);
	int    FASTCALL Copy(const ObjTagItem &);
	void   SLAPI Destroy();
	int    FASTCALL Get_(const ObjTagTbl::Rec & rRec);
	int    SLAPI Put(PPID objType, PPID objID, long tagByObj, ObjTagTbl::Rec *) const;
	int    FASTCALL Cmp(const ObjTagItem &) const;
	int    SLAPI IsZeroVal() const;
	int    SLAPI IsWarnVal() const;
	ObjTagItem & FASTCALL operator = (const ObjTagItem &);
	int    FASTCALL operator == (const ObjTagItem & a) const;
	int    FASTCALL operator != (const ObjTagItem & a) const;
	int    SLAPI Write__(SBuffer & rBuf) const; // @todo(eliminate)
	int    SLAPI Read__(SBuffer & rBuf);        // @todo(eliminate)
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	PPID   TagID;          // ->Ref(PPOBJ_TAG)
	long   TagDataType;    // OTTYP_XXX
	PPID   TagEnumID;      //
	union {
		long   IntVal;     //
		double RealVal;    //
		char * PStr;       //
		LDATE  DtVal;      //
		LDATETIME DtmVal;  // @v7.5.0
	} Val;
};
//
// Список значений тегов
//
class ObjTagList : SArray {
public:
	SLAPI  ObjTagList();
	SLAPI  ObjTagList(const ObjTagList & s);
	SLAPI ~ObjTagList();
	ObjTagList & FASTCALL operator = (const ObjTagList & s);
	uint   SLAPI GetCount() const;
	int    FASTCALL IsEqual(const ObjTagList & rS) const;
	//
	// Descr: Возвращает указатель на тег с идентификатором типа tagID.
	//   Если список не содержит такого тега, то, при forceEmpty != 0
	//   в список добавляется пустой тег с типом tagID и возвращается указатель
	//   на него, в противном случае возвращается 0.
	//
	const  ObjTagItem * FASTCALL GetItem(PPID tagID) const;
	int   SLAPI GetItemStr(PPID tagID, SString & rBuf) const;
	const  ObjTagItem * FASTCALL GetItem_ForceEmpty(PPID tagID);
	const  ObjTagItem * FASTCALL GetItemByPos(uint) const;
	const  ObjTagItem * FASTCALL EnumItems(uint * pos) const;
	//
	// Descr: Список получает собственную копию элемента ObjTagItem.
	//   По-этому, объект, переданный функции параметром pItem
	//   может (и, вероятно, должен) быть разрушен вызывающей функцией.
	//
	int    SLAPI PutItem(PPID tagID, const ObjTagItem * pItem);

	enum {
		pinzfInheritableOnly = 0x0001,
		pinzfUnmirroredOnly  = 0x0002
	};

	int    SLAPI PutItemNZ(const ObjTagItem * pItem, long flags);
	int    SLAPI PutItemStr(PPID tagID, const char * pStr);
	//
	// Descr: Вставляет в список тег со значением равным строке pStr
	//   но только в том случае, если !isempty(pStr).
	// Returns:
	//   >0 - тег успешно вставлен в список
	//   <0 - строка pStr пустая: ничего не произошло
	//   0  - ошибка
	//
	int    SLAPI PutItemStrNE(PPID tagID, const char * pStr);
	int    FASTCALL Copy(const ObjTagList & src);
	//
	// Descr: Опции функции ObjTagList::Merge().
	//
	enum {
		mumAdd       = 0x0001, // Добавлять не существующие теги из rSrc в this
		mumUpdate    = 0x0002, // Изменять теги из rSrc в this (если для типа тега не установлен признак OTF_DUP)
		mumRemove    = 0x0004, // Удалить в списке this теги с типами, перечисленными в rSrc. Эта опция отменяет остальные флаги.
		mumIgnoreDup = 0x0008  // Если в rSrc встретился тег с типом, который уже есть в this, то тег в this
			// будет изменен, даже если для типа тега установлен признак OTF_DUP.
	};
	//
	// Descr: Объединяет список тегов this со списком rSrc.
	//
	int    SLAPI Merge(const ObjTagList & rSrc, int updateMode);
	void   SLAPI Destroy();

	int    SLAPI Write__(SBuffer & rBuf) const; // @todo(eliminate)
	int    SLAPI Read__(SBuffer & rBuf);        // @todo(eliminate)
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI ProcessObjRefs(PPObjIDArray * ary, int replace);

	PPID   ObjType;
	PPID   ObjID;
protected:
	virtual void FASTCALL freeItem(void *);
};
//
//
//
class ObjTagCore : public ObjTagTbl {
public:
	SLAPI  ObjTagCore();
	//
	// Descr: Специальный конструктор, используемый для открытия таблицы, отличной от той,
	//   что находится в текущей базе данных.
	//
	SLAPI  ObjTagCore(const char * pFileName);
	int    SLAPI GetList(PPID objType, PPID objID, ObjTagList * pList);
	int    SLAPI PutList(PPID objType, PPID objID, const ObjTagList * pList, int use_ta);
	//
	// Descr: Вносит в базу данных список тегов pList игнорируя теги с идентификаторами, перечисленными
	//   в pExclList. Если pExclList == 0 или пусто, то работает так же, как и PutList()
	//
	int    SLAPI PutListExcl(PPID objType, PPID objID, const ObjTagList * pList, PPIDArray * pExclList, int use_ta);
	int    SLAPI GetTagRec(PPID objType, PPID objID, PPID tagID, ObjTagTbl::Rec * pRec);
	int    SLAPI GetTag(PPID objType, PPID objID, PPID tagID, ObjTagItem * pItem);
	//
	// Descr: Высокоуровневая функция, получающая тег и извлекающая из него
	//   строковое значение.
	// Returns:
	//   >0 - тег извлечен и содержит не пустое строковое значение
	//   <0 - тег не найден, либо не может быть преобразован к строке
	//   0  - ошибка
	//
	int    SLAPI GetTagStr(PPID objType, PPID objID, PPID tagID, SString & rBuf);
	int    SLAPI EnumTags(PPID objType, PPID objID, PPID * pTagID, long * pTagByObj, ObjTagItem *);
	int    SLAPI EnumTags(PPID objType, PPID objID, PPID tagID, long * tagByObj, ObjTagItem *);
	//
	// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
	//   тип тега равен tagID, строковое содержимое тега равно pStr (нечувствительное к регистру сравнение).
	// Returns:
	//   >0 - Найден хоть один тег, то возвращается //
	//   <0 - Не найдено ни одного соответствия //
	//   0  - Ошибка
	//
	int    SLAPI SearchObjectsByStr(PPID objType, PPID tagID, const char * pStr, PPIDArray *);
	//
	// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
	//   тип тега равен tagID, тип значения тега - строка, строковое содержимое тега В ТОЧНОСТИ равно pStr (нечувствительное к регистру сравнение).
	// Returns:
	//   >0 - Найден хоть один тег, то возвращается //
	//   <0 - Не найдено ни одного соответствия //
	//   0  - Ошибка
	//
	int    SLAPI SearchObjectsByStrExactly(PPID objType, PPID tagID, const char * pStr, PPIDArray *);
	int    SLAPI GetObjTextList(PPID objType, PPID tagID, StrAssocArray & rList);
	//
	// Descr: Формирует список идентификаторов объектов, для которых существуют теги типа tagID.
	// Note: Список rList предварительно не очищается.
	//
	int    SLAPI GetObjectList(PPID objType, PPID tagID, UintHashTable & rList);
	//
	// Descr: Ищет запись, соответсвующую типу объект objType и тегу tagID со строковой величиной, равной
	//   pStr. Если находит, то возвращает идентификатор этого объекта. В противном случае создает
	//   такую запись с новым значением идентификатора объекта и возвращает этот ид.
	// Note:
	//   Если длина строки pStr превышает размер (ObjTagTbl::Rec::StrVal-1), то функция возвращает 0
	//   и инициализирует код ошибки PPERR_EXCSTRLEN
	// Returns:
	//   1 - запись найдена
	//   2 - запись не найдена и успешно создана
	//  -1 - строка pStr - пустая //
	//   0 - ошибка
	//
	// @obsolete since @v9.0.11 int    SLAPI CreateUniqueStr(PPID objType, PPID tagID, PPID * pObjID, const char * pStr, int use_ta);
	int    SLAPI PutTag(PPID objType, PPID objID, const ObjTagItem *, int use_ta);
	int    SLAPI RemoveTag(PPID objType, PPID objID, PPID tagID /* if 0 then remove all */, int use_ta);
	int    SLAPI SearchAnyRefToTagID(PPID tagID, PPObjID *);
protected:
	int    SLAPI PutTagToRec(PPID objType, PPID objID, long tagByObj, const ObjTagItem *);
	int    SLAPI GetNewTagByObjCounter(PPID objType, PPID objID, PPID tagID, long * tagByObj);
};
// @EndModuleDecl(ObjTagCore)
//
//
enum {
	objlWithHeader = 0x0001, // Элемент массива стостоит из 4-х байтового идентификатора и наименования //
	objlSortByText = 0x0002  // Сортировать элементы списка по наименованию
};

typedef int (SLAPI * ObjFilterProc)(void *, void * extraPtr);
//
//
//
#define USRF_INHCFG     0x00000001L // Наследует конфигурацию
#define USRF_INHRIGHTS  0x00000002L // Наследует права
//
// Флаги операционных категорий исключений прав доступа
//
#define PPEXCLRT_OBJDBDIVACCEPT      0x0001
#define PPEXCLRT_CSESSWROFF          0x0002
#define PPEXCLRT_CSESSWROFFROLLBACK  0x0004
#define PPEXCLRT_INVWROFF            0x0008
#define PPEXCLRT_INVWROFFROLLBACK    0x0010
#define PPEXCLRT_DRAFTWROFF          0x0020 // @v8.6.4
#define PPEXCLRT_DRAFTWROFFROLLBACK  0x0040 // @v8.6.4

struct PPSecur2 {          // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const={PPOBJ_USR | PPOBJ_USRGRP}
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // @unused
	char   Password[40];   // (USER only) Пароль (зашифрован и свернут в строку кодировкой MIME64)
	char   Reserve[4];     // @reserve
	PPID   UerID;          // @v8.6.0 Исключение прав доступа для PPOBJ_USR
	long   UerFlags;       // Флаги исключений прав доступа для PPOBJ_USREXCLRIGHTS
	uint32 Crc;            // Контрольная сумма для гарантии того, что запись не была создана либо
		// изменена вне сервисов системы.
	LDATE  PwUpdate;       // (USER only) Дата последнего изменения пароля //
	long   Flags;          // (USER only) Флаги (USRF_XXX)
	long   ParentID;       // Родительский объект (группа | конфигурация)
	PPID   PersonID;       // (USER only) Связанная персоналия //
};

DECL_REF_REC(PPSecur);

struct PPSecurPacket {
	SLAPI  PPSecurPacket(PPID = 0, PPID = 0);
	PPSecurPacket & FASTCALL operator = (const PPSecurPacket &);
	PPSecur  Secur;
	PPConfig Config;
	PPPaths  Paths;
	PPRights Rights;
};

struct PropPPIDArray {
	PPID   ObjType;
	PPID   ObjID;
	PPID   PropID;
	long   Count;
	// long Items[];
};
//
// Descr: Макрос для представления размера фиксированной части (без "хвоста" переменной длины)
//   записи таблицы PropertyTbl
//
//#define PROPRECFIXSIZE sizeof(PropertyTbl::Rec)
#define PROPRECFIXSIZE        offsetof(PropertyTbl::Rec, VT)
#define PCFGEXSTR_DESKTOPNAME 1
//
//
//
class Reference : public ReferenceTbl {
public:
	friend class PPTblEnum <Reference>;

	enum {
		crymDefault = 0,
		crymRef2
	};
	static int SLAPI Encrypt(int cryptMethod, const char * pText, char * pBuf, size_t bufLen);
	static int SLAPI Decrypt(int cryptMethod, const char * pBuf, size_t bufLen, SString & rText);
	static int SLAPI GetPassword(const PPSecur * pSecur, char * pBuf, size_t bufLen);
	static int SLAPI VerifySecur(PPSecur2 * pSecur, int set);
	static int SLAPI GetExField(const PPConfigPrivate * pRec, int fldId, SString & rBuf);
	static int SLAPI SetExField(PPConfigPrivate * pRec, int fldId, const char * pBuf);

	SLAPI  Reference();
	SLAPI ~Reference();
	int    SLAPI AddItem(PPID obj, PPID * pID, const void * b, int use_ta);
	int    SLAPI UpdateItem(PPID obj, PPID id, const void *, int logAction /*=1*/, int use_ta);
	int    SLAPI GetItem(PPID obj, PPID id, void * = 0);
	//
	enum {
		eoIdName = 0x0001, // Инициализировать запрос на поля ObjID и ObjName
		eoIdSymb = 0x0002  // Инициализировать запрос на поля ObjID и Symb
		// Если указаны и eoIdName и eoIdSymb, то запрос результат содержит {ObjID, ObjName, Symb}
	};
	int    SLAPI InitEnum(PPID objType, int options, long * pHandle);
	//
	// Descr: Инициализирует перечисление записей по одному из дополнительных индексированных
	//   значений, соответствующих ReferenceTbl::Rec::Val1 или ReferenceTbl::Rec::Val2.
	// ARG(objType  IN): тип объекта для перечисления //
	// ARG(valN     IN): @#{1,2} номер поля по которому следует перечислять значения. Это может быть
	//   либо 1 (Val1), либо 2 (Val2)
	// ARG(val      IN): Значение дополнительного поля по которому следует перечислять записи
	// ARG(pHandle OUT): Манипулятор перечисления, который используется в функции Reference::NextEnum.
	//   После завершения работы с перечислением его следует разрушить вызовом Reference::DestroyIter.
	// Returns:
	//   >0 - перечисление успешно инициализировано.
	//   0  - ошибка
	//
	int    SLAPI InitEnumByIdxVal(PPID objType, int valN, long val, long * pHandle);
	int    SLAPI NextEnum(long enumHandle, void * pRec);
	int    SLAPI DestroyIter(long enumHandle);
	//
	SEnumImp * SLAPI Enum(PPID objType, int options);
	SEnumImp * SLAPI EnumByIdxVal(PPID objType, int valN, long val);
	//
	int    SLAPI EnumItems(PPID obj, PPID * pID, void * = 0);
	//
	// Descr: Загружает в массив pList все элементы справочника типа objType.
	//   Массив pList должен иметь размер элемента равный sizeof(ReferenceTbl::Rec).
	// Returns:
	//   0  - ошибка
	//   <0 - нет ни одного элемента
	//   >0 - в массив pList загружено 1 или более элементов
	//
	int    SLAPI LoadItems(PPID objType, SArray * pList);
	int    SLAPI SearchName(PPID obj, PPID * pID, const char * pName, void * pRec = 0);
	int    SLAPI SearchSymb(PPID, PPID *, const char * pSymb, size_t offs);
	int    SLAPI CheckUniqueSymb(PPID objType, PPID objID, const char * pSymb, size_t offs);
	//
	// Если (*pID == 0) GetFreeID присваивает ему первый доступный
	// пользовательский идентификатор. Иначе, GetFreeID проверяет
	// не занят ли переданный идентификатор. Если занят - возвращает -1.
	// Если не занят и нет ошибок, возвращает (>0).
	//
	int    SLAPI GetFreeID(PPID obj, PPID * pID);
	int    SLAPI RemoveItem(PPID obj, PPID id, int use_ta = 1);
	int    SLAPI AllocDynamicObj(PPID * pDynObjType, const char * pName, long flags, int use_ta);
	int    SLAPI FreeDynamicObj(PPID dynObjType, int use_ta);
	//
	// Descr: ищет заданную запись свойств и, если не находит, то
	//   добавляет ее, если находит, то обновляет. Если параметр b == 0 и
	//   запись существует, то она удаляется.
	//
	int    SLAPI PutProp(PPID obj, PPID id, PPID prop, const void * b, size_t sz = 0, int use_ta = 0);
	int    SLAPI PutPropVlrString(PPID obj, PPID id, PPID prop, const char *, int use_ta = 0);
	int    SLAPI GetPropVlrString(PPID obj, PPID id, PPID prop, SString & rBuf);
	int    SLAPI PutPropSBuffer(PPID obj, PPID id, PPID prop, const SBuffer & rBuf, int use_ta);
	int    SLAPI GetPropSBuffer(PPID obj, PPID id, PPID prop, SBuffer & rBuf);
	int    FASTCALL GetPropSBuffer_Current(SBuffer & rBuf);
	//
	// Если в функции RemoveProp параметр prop == 0, то удаляются все
	// свойства объекта { obj, id }. В противном случае удаляются только
	// свойства с ИД == prop.
	//
	int    SLAPI RemoveProp(PPID, PPID, PPID, int use_ta);
	int    SLAPI GetProp(PPID, PPID, PPID, void * = 0, size_t sz = 0);
	int    SLAPI GetPropActualSize(PPID objType, PPID objID, PPID prop, size_t * pActualSize);
	int    SLAPI EnumProps(PPID objType, PPID objID, PPID * pProp, void * pData = 0, uint sz = 0);
	int    SLAPI GetConfig(PPID, PPID, PPID cfgID, void * = 0, uint sz = 0);
	int    SLAPI SetConfig(PPID, PPID, PPID cfgID, void *, uint sz = 0);
	int    SLAPI LoadSecur(PPID, PPID, PPSecurPacket *);
	int    SLAPI EditSecur(PPID, PPID, PPSecurPacket *, int isNew);
	int    SLAPI RemoveSecur(PPID obj, PPID id, int use_ta);
	int    SLAPI GetPropArrayFromRecBuf(SArray * pAry);
	int    SLAPI GetPropArray(PPID obj, PPID id, PPID prop, SArray *);
	int    SLAPI PutPropArray(PPID obj, PPID id, PPID prop, const SArray *, int use_ta);

	static int SLAPI Helper_Encrypt_(int cryptMethod, const char * pEncPw, const char * pText, char * pBuf, size_t bufLen);
	static int SLAPI Helper_Decrypt_(int cryptMethod, const char * pEncPw, const char * pBuf, size_t bufLen, SString & rText);
	//
	static int SLAPI Helper_EncodeOtherPw(const char * pEncPw, const char * pPw, size_t pwBufSize, SString & rResult);
	static int SLAPI Helper_DecodeOtherPw(const char * pEncPw, const char * pPw, size_t pwBufSize, SString & rResult);
protected:
	int    SLAPI _GetFreeID(PPID obj, PPID * id, PPID firstID);
	int    SLAPI _Search(PPID obj, PPID id, int spMode, void *);
	int    SLAPI _SearchProp(PPID obj, PPID id, PPID prop, int spMode, void * pBuf, size_t sz = 0);
private:
	int    SLAPI PreparePropBuf(PPID obj, PPID id, PPID prop, const void * b, uint s);
	int    SLAPI ReadPropBuf(void * b, size_t s, size_t * pActualSize);

	PPTblEnumList EnumList;
public:
	PropertyTbl Prop;
	ObjAssoc    Assc;
	ObjTagCore  Ot;
	UnxTextRefCore UtrC;
	TextRefCore TrT;
};
//
// Система внутренних штрихкодов (PPOBJ_BCODESTRUC)
//
struct PPBarcodeStruc2 {   // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_BCODESTRUC
	long   ID;             // @id
	char   Name[48];       // @name
	char   Templ[20];      // Шаблон
	char   Reserve[60];    // @reserve
	long   Flags;          // Флаги
	long   Reserve1;       // @reserve
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPBarcodeStruc);
//
// @ModuleDecl(QuotationCore)
//
struct QuotFilt : public PPBaseFilt {
	SLAPI  QuotFilt();
	int    IsSeries() const
	{
		return BIN(Flags & fSeries && GoodsID && QuotKindID);
	}

	enum {
		fAllQuotKinds        = 0x0001, // Все котировки (актуально,
			//	если QuotKindID == 0. Если QuotKindID == 0 && !(Flags & fAllQuotKinds),
			//	тогда рассматривается только базовая котировка
		fAllLocations        = 0x0002, // Показывать только котировки, определенные для всех складов
		fOnlyAbsence         = 0x0004, // Только товары, для которых котировка, соответствующая фильтру отсутствует
		fActualOnly          = 0x0080, // (quot2) Только актуальные значения (для quot и так все значения актуальные).
		fCrosstab            = 0x0100, // Кросстаб
		fAbsence             = 0x0400, // Показывать товары, для которых котировка, соответствующая фильтру отсутствует
		fSeries              = 0x0800, // @v7.1.11 Показывать временной ряд значений.
			// Данный флаг имеет несколько требований непротиворечивости:
			// -- должен быть определен товар GoodsID
			// -- комбинация факторов {QuotKindID, LocID, ArticleID} считается определенной
			// -- QTaID игнорируется //
			//
		fListOnly            = 0x1000, // @v7.1.12 Функция PPViewQuot::Init_ создает только внутренний список
			// значений котировок (PPQuotItemArray)
		fZeroArOnly          = 0x2000, // @v7.1.12 Отбирать котировки только с нулевой статьей
			// (применяется для разрешения неоднозначности по критерию ArID == 0).
		fByGroupOnly         = 0x4000, // @v8.6.6 Показывать только котировки привязанные к товарным группам
		fByGoodsOnly         = 0x8000  // @v8.6.6 Показывать только котировки привязанные к товарам
			// @# fByGroupOnly^fByGoodsOnly
	};
	int32  InitOrder;        // @anchor @v8.1.1 Порядок сортировки
	int32  QkCls;            // Класс вида котировки
	DateRange Period;        // (quot2) Период значений
	LDATE  EffDate;          // @v7.3.5 (quot2) Дата, для которой должны быть действительны отображаемые котировки
	PPID   QTaID;            // (quot2) ИД транзакции изменения котировки
	PPID   SellerID;         // ->Article.ID Продавец
	PPID   SellerLocWorldID; // ->World.ID Ид элемента World, которому должна принадлежать локация LocID
	PPID   BrandID;          //
	PPID   LocID;            //
	PPID   QuotKindID;       //
	PPID   CurID;            //
	PPID   ArID;             //
	PPID   GoodsGrpID;       // if !0, тогда это поле ограничивает перебор товаров только указанной группой
	PPID   GoodsID;          // if !0, то строки развернуты либо по складам,
		// либо по клиентам, либо по видам котировок
	RealRange Val;           // Диапазон значений котировки (0..0 - игнорируется)
	long   Flags;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
	ObjIdListFilt LocList;   // Список складов
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};
//
//
//
inline LDATE QIDATE(LDATE d) { return d; } // Служебная конструкция для идентификации конструкторов QuotIdent, в которых использована дата

class QuotIdent { // @transient
public:
	SLAPI  QuotIdent(PPID locID = 0, PPID quotKindID = 0, PPID curID = 0, PPID arID = 0);
	SLAPI  QuotIdent(LDATE dt, PPID locID = 0, PPID quotKindID = 0, PPID curID = 0, PPID arID = 0);
	SLAPI  QuotIdent(const QuotIdent & rS);
	SLAPI  QuotIdent(const PPQuot & rS);
	void   SLAPI SetBase(double);
	double SLAPI GetPrevBase() const;
	void   FASTCALL SetIdentPeriod(const DateRange * pPeriod);
	void   FASTCALL SetIdentQtty(const long * pQtty);
	enum {
		fUsePeriod  = 0x0001,
		fUseQtty    = 0x0002
	};
	long   Flags;          // @v7.3.5
	PPID   LocID;
	PPID   QuotKindID;
	PPID   CurID;
	PPID   ArID;
	LDATE  Dt;             // @v7.3.5 Дата, для которой проверяется период действия котировки.
		// Если !Dt, то предполагается, что Dt == getcurdate_().
	DateRange Period;      // @v7.3.5 Если (Flags & fUsePeriod), то функции извлечения котировки
		// ищут котировку, у которой период точно соответствует this->Period
	double Qtty_;          // Используется для нахождения значения котировки, ограниченного количеством.
		// Если Qtty == 0.0 то значения с ограничением по количеству не считаются.
private:
	double PrevBase;
};
//
// Descr: Структура товарной котировки.
// Note: Замечание по передаче при синхронизации: эта структура синхронизируется по полям
//   функцией PPObjGoods::SerializePacket. То есть, добавлять новые поля в эту структуру можно,
//   однако менять типы существующий полей не допустимо.
//
struct PPQuot { // @persistent(DBX see Note above)
	//
	// Descr: Реализация форматирования значения котировки.
	//
	static SString & PutValToStr(double val, long flags, SString & rBuf);
	//
	// Descr: Расширенный вариант форматирования значения котировки, включающий так же
	//   период действия и минимальное количество.
	//
	static SString & PutValToStr(double val, long flags, const DateRange & rPeriod, double minQtty, SString & rBuf);

	enum {
		fPctOnCost     = 0x0001, // Наценка в процентах к цене поступления (Cost)  'C' //
		fPctOnPrice    = 0x0002, // Наценка в процентах к цене реализации  (Price) 'P' //
		fPctOnAddition = 0x0004, // Наценка в процентах к наценке (Price-Cost)     'D' //
		fPctDisabled   = 0x0008, // Заблокированная котировка                      'X' //
		fPctOnBase     = 0x0010, // Наценка в процентах к базовой котировке        'Q' //
		fWithoutTaxes  = 0x0020, // @construction Цена указана без налогов 'F' //
		fZero          = 0x0040, // Явно заданное нулевое значение.
		fActual        = 0x0080, // @transient @v7.1.12 Специализированный флаг -
			// используется для индикации признака актуальной котировки во временных структурах.
			// В базе данных не сохраняется.
		fDbUpd         = 0x0100, // @transient @v7.2.1 Устанавливается функциями изменения списка котировок
			// в тех элемента PPQuotArray, которые были реально изменены в БД.
		fDbMask        = (fPctOnCost|fPctOnPrice|fPctOnAddition|fPctDisabled|fPctOnBase|fWithoutTaxes|fZero)
	};
	//
	// Descr: Классы котировок
	//
	enum {
		clsGeneral = 0,   // Обычные котировки
		clsMtx,           // Товарная матрица и ограничение товарной матрицы
		clsMtxRestr,      // Ограничения товарной матрицы
		clsSupplDeal,     // Контрактные цены и допуски контрактных цен
		clsPredictCoeff   // Поправочные коэффициенты прогноза продаж
	};
	//
	// Descr: Определяет, принадлежит ли склад locID котировки множеству ограничивающих
	//   складов rLocList.
	//   Здесь правила следующие:
	//   1. Если rLocList.getCount() == 0, то locID является допустимым
	//   2. Если locID - член списка rLocList, то является допустимым
	//   3. Если locID является группирующим складом и один из членов rLocList - дочерний
	//      элемент этой группы (по всей иерархии), то locID является допустимым
	// Returns:
	//   >0 - locID является приемлемым складом при ограничении rLocList
	//   0  - locID не  вляется приемлемым складом при ограничении rLocList
	//
	static int FASTCALL IsQuotAcceptableForLoc(PPID locID, const PPIDArray & rLocList);

	SLAPI  PPQuot(PPID goodsID = 0);
	SLAPI  PPQuot(const QuotationTbl::Rec &);
	PPQuot & FASTCALL operator = (const QuotationTbl::Rec &);
	QuotIdent & FASTCALL MakeIdent(QuotIdent & rQi) const;
	void   Clear()
	{
		THISZERO();
	}
	enum {
		cmpFull  = 0x0000,
		cmpNoID  = 0x0001, // Не брать в рассмотрение ИД котировки
		cmpNoVal = 0x0002  // @v7.0.6 Не брать в рассмотрение значение котировки
	};
	int    SLAPI IsEqual(const PPQuot & rS, long cmpFlags = 0) const;
	int    SLAPI IsRelative() const;
	int    SLAPI IsEmpty() const;
	double SLAPI CalcPrice(double cost, double price) const;
	void   FASTCALL GetFromRec(const QuotationTbl::Rec &);
	int    FASTCALL GetValFromStr(const char * pStr);
	SString & FASTCALL PutValToStr(SString & rBuf) const;
	int    FASTCALL CheckForVal(const RealRange * pRange) const;
	int    FASTCALL CheckForFilt(const QuotFilt * pFilt, const PPIDArray * pKindList) const;

	PPID   ID;
	PPID   ArID;
	PPID   GoodsID;
	PPID   LocID;
	PPID   Kind;
	PPID   CurID;
	long   Flags;
	long   MinQtty;
	DateRange Period;  // @v7.3.5 Период действия котировки
	double Quot;

	PPID   SellerArID; // @transient (special for UHTT) ИД статьи-поставщика
	PPID   RelID;  // @transient
	PPID   QTaID;  // @transient
	LDATETIME Dtm; //
};

DECL_CMPFUNC(PPQuot);

class PPQuotArray : public TSArray <PPQuot> {
public:
	SLAPI  PPQuotArray(PPID goodsID = 0);
	SLAPI  PPQuotArray(const PPQuotArray & s);
	PPQuotArray & FASTCALL operator = (const PPQuotArray &);
	//
	// Descr: Устанавливает значение котировки в соответствии с идентифицирующим блоком rQi.
	// Returns:
	//   >0 - номер позиции, в которой было изменено значение либо номер позиции, по которой новое
	//    значение было добавлено. Нумерация начинается с 1. То есть, чтобы получить измененное (вставленное)
	//    значение необходимо вызвать PPQuotArray::at(PPQuotArray::SetQuot()-1) (естественно, необходимо проверить результат на условие >0)
	//   0 - ошибка.
	//
	int    SLAPI SetQuot(const QuotIdent & rQi, double val, long flags, long minQtty, const DateRange * pPeriod); // minQtty - @v5.5.2 VADIM; minQtty < 0 - don`t update
	int    FASTCALL SearchQi(const QuotIdent & rQi, uint * pPos) const;
	//
	// Descr: Возвращает список позиций значений котировок, удовлетворяющих условиям rQi
	// Returns:
	//   >0 - найдено по крайней мере одно значение
	//   <0 - не найдено ни одного значения, удовлетворяющего условиям rQi
	//
	int    FASTCALL SearchQiList(const QuotIdent & rQi, LongArray & rPosList) const;
	//
	// Descr: ищет в массиве котировку, соответствующую идентификатору pIdent.
	//   -- Если такая котировка найдена, то она присваивается по указателю pQuot и функция //
	//   возвращает значение больше нуля (> 0).
	//   -- Если котировка не найдена, то объект по указателю pQuot заполняется //
	//   в соответствии с идентификатором pIdent (pQuot->Quot = 0, pQuot->Flags = 0)
	//   и функция возвращает ноль (0).
	// Precondition:
	//   -- pIdent hasn't to be 0
	//   -- pQuot can be 0.
	//
	int    SLAPI GetQuot(const QuotIdent & rIdent, PPQuot * pQuot) const; // @>>PPQuotArray::Search
	int    SLAPI SearchNearest(const QuotIdent & rIdent, uint * pPos) const;
	//
	// Descr: Ищет наиболее подходящую для заданного идентификатора pIdent котировку
	//   и возвращает рассчитанное на ее основе значение и по заданным цене поступления (cost)
	//   и цене реализации (price) по указателю pResult.
	// ARG(rIdent  IN)  - ссылка на экземпляр структуры QuotIdent, идентифицирующей условия использования котировки
	//   идентифицирующей условия использования котировки
	// ARG(cost    IN)  - цена поступления, на основе которой будет рассчитано значение котировки,
	//   если найденная котировка окажется относительной (привязанной либо к цене поступления, либо к наценке)//
	// ARG(price   IN)  - цена реализации, на основе которой будет рассчитано значение котировки,
	//   если найденная котировка окажется относительной (привязанной либо к цене реализации, либо к наценке)
	// ARG(pResult OUT) - указатель, по которому функция вернет рассчитанное значение найденной котировки.
	// Returns:
	//   0  - ошибка
	//   1  - найдена подходящая котировка
	//   2  - найдена подходящая котировка, но ее значение "Заблокирована"
	//   -1 - подходящая котировка не найдена (*pResult = 0)
	//
	int    SLAPI GetResult(const QuotIdent & rIdent, double cost, double price, double * pResult) const;
		// @>>PPQuotArray::SearchNearest
	void   SLAPI Sort();
	//
	// Descr: проверяет является-ли котировка извлекаемая с помощью pIdent заблокированной
	//   по следующему правилу:
	//   -- Если эта котировка заблокированная или имеется заблокированная котировка с более высоким приоритетом
	//   Рассматриваются только котировки, вид которых принадлежит множеству pQKList. Если pQKList нулевой, то
	//   рассматриваются все котировки.
	//   Если в данном массиве не найдена котировка по pIdent и pParentQuots не нуль, то проверяем данную котировку
	//   на предмет блокировки в этом массиве (pParentQuots - котировки на группу, к которой принадлежит данный товар).
	//
	int    SLAPI IsDisabled(const QuotIdent & rIdent, const PPIDArray * pQKList = 0, PPQuotArray * pParentQuots = 0);
	//
	// Descr: удаляет из массива те котировки, которые ссылаются на несуществующие
	//   склады. Вызывается при передаче пакета в другой раздел функцией PPObjGoods::Read().
	//
	int    SLAPI RemoveHangedLocations(); // @<<PPObjGoods::Read
	//
	// Descr: Устанавливает список складов, по которым котировки, находящиеся в базе данных,
	//   но не принадлежащие this могут быть удалены. Если pList == 0 или pList->getCount() == 0,
	//   то функция CanUpdateQuot будет считать, что все котировки по товару GoodsID, не принадлежащие
	//   this могут быть удалены из базы данных.
	//
	int    SLAPI SetManagedLocList(const PPIDArray * pList);
	//
	// Descr: Определяет можно ли удалить из базы данных котировку rQuot.
	//   Эта функция вызывается в QuotationCore::SetCurrList для котировок,
	//   находящихся в базе данных, но не принадлежащих this.
	//
	int    FASTCALL CanUpdateQuot(const PPQuot & rQuot) const; // @<<QuotationCore::SetCurrList
	//
	// Descr: Корректирует проблему, появившуюся в релизе 7.2.1 и исправленную в 7.8.3.
	//   Суть проблемы в том, что в базу данных попадало несколько значений с идентичными факторами
	//   и, соответственно, атрибутом Actual == 1.
	//   Проблема сказывается только на котировках первого поколения (QuotationTbl).
	//
	int    SLAPI Correct721(PPLogger * pLogger);
	int    SLAPI DebugLog() const;

	PPID   GoodsID;
private:
	PPIDArray ManagedLocList; // @transient Список складов, по которым можно удалять
		// котировки из базы данных, если они не принадлежат множеству this.
};
//
// Descr: Специализированная структура для обмена значениями котировок с внешними приложениями.
//
struct PPQuotItem_ { // @persistent
	PPQuotItem_();
	PPQuotItem_(const PPQuot & rS);

	int32  GoodsID;
	int32  KindID;
	int32  LocID;
	int32  ArID;
	int32  CurID;
	int32  MinQtty;   // @v7.3.5
	DateRange Period; // @v7.3.5
	LDATETIME Dtm;
	int32  Flags;
	double Val;
};

class PPQuotItemArray : public TSArray <PPQuotItem_> {
public:
	PPQuotItemArray();
	int    FASTCALL Add(const PPQuotItem_ & rItem);
	int    FASTCALL Add(const PPQuot & rQ);
	//
	// Descr: Флаги функции PPQuotItemArray::Replace
	//
	enum {
		rfGt = 0x0001, // Заменять значение, если время установки нового значение превышает существующее
		rfLt = 0x0002  // Заменять значение, если время установки нового значения меньше существующего
	};
	int    SLAPI Set(const PPQuot & rQ, long flags);
	void   SLAPI Sort();
};

class QuotationCore : public QuotationTbl {
public:
	SLAPI  QuotationCore();
	int    SLAPI Search(PPID id, void * = 0);
	//
	// Descr: Изменяет одну котировку.
	// ARG(pID IN/OUT): Идентификатор котировки (если необходимо изменить существующую).
	// ARG(pQuot   IN): Параметры котировки
	// ARG(logSj   IN): записывать в системный журнал событие (PPACN_GOODSQUOTUPD, PPACN_GOODSMTXUPD).
	//   Если ничего не изменилось, то и событие не записывается, даже если logSj != 0.
	// ARG(use_ta  IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   <0 - котировка не была изменена, поскольку pQuot не отличается от записи с идентификатором *pID
	//   >0 - котировка была изменена (добавлена/удалена).
	// 1000 - котировка была изменена (добавлена/удалена). При этом, котировка относится к товарной матрице.
	// 2000 - котировка была изменена (добавлена/удалена). При этом, котировка является ограничением по товарной матрице.
	//    0 - ошибка
	//
	int    SLAPI SetCurr(PPID * pID, const PPQuot * pQuot, int logSj, int use_ta);
	int    SLAPI SetCurrList(PPQuotArray & rQuotList, const PPQuotArray * pTemplate, int noRmv, int use_ta);
	int    SLAPI GetCurrList(PPID goodsID, PPID quotKindID, PPID loc, PPQuotArray &);
	int    SLAPI GetCurr(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache = 0);
	int    SLAPI GetNearest(PPID goodsID, const QuotIdent & pIdent, PPQuot * pQuot, int useCache);
	int    SLAPI GetMatrix(PPID mtxQkID, PPID locID, PPIDArray * pList);
	int    SLAPI GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    SLAPI BelongToMatrix(PPID goodsID, PPID locID);
	//
	// Descr: Кэшированное извлечение списка котировок для товара goodsID.
	// Returns:
	//   >0 - список котировок успешно извлечен (это не означает, что список не пустой).
	//   <0 - кэш котировок не существует (практически это невозможно).
	//   0  - ошибка при извлечении списка.
	//
	int    SLAPI FetchList(PPID goodsID, PPQuotArray & rList);
	//
	// Descr: Кэшированное извлечение матрицы товаров по складу locID.
	//
	int    SLAPI GetMatrix(PPID locID, PPIDArray * pResult);
	//
	// Descr: Объявляет котировки по товару goodsID в кэше недействительными
	//
	int    SLAPI DirtyGoodsID(PPID goodsID);
	//
	// Descr: Очищает кэш котировок
	//
	int    SLAPI ClearCache();
	//
	// Descr: Объявляет матрицы товаров по списку складов pMtxLocList в кэше недействительными.
	//   Если pMtxLocList == 0 || pMtxLocList->getCount() == 0, то объявляет недействительными
	//   все товарные матрицы.
	//
	int    SLAPI DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList, int deferred);
	//
	// Descr: Заменяет все ссылки на статью replacedID ссылками на newID
	//
	int    SLAPI ReplaceArticleRefs(PPID replacedID, PPID newID, int use_ta);
	int    SLAPI GetMatrixListByLoc(PPID mtxQkID, PPID locID, PPIDArray & rList, PPIDArray & rNegList);
		// @<<QuotationCore::GetMatrix
};
//
// Descr: Вторая реализация котировок
//
class Quotation2Core : public Quotation2Tbl {
public:
	static int FASTCALL PeriodToPeriodIdx(const DateRange * pPeriod, int32 * pPeriodIdx);
	static int FASTCALL PeriodIdxToPeriod(int32 periodIdx, DateRange * pPeriod);

	SLAPI  Quotation2Core();
	int    SLAPI VerifyRecord(Quotation2Tbl::Rec & rRec);
	int    SLAPI Verify();
	int    SLAPI GetRelByID(PPID relID, PPQuot * pVal);
	int    SLAPI GetRel(const PPQuot * pVal, PPID * pID, int createIfNExists, int use_ta);
	int    SLAPI GetRelListByFilt(const QuotFilt * pFilt, PPIDArray * pList);
	int    SLAPI Get(PPID goodsID, PPID relID, LDATETIME * pAfter, PPQuotArray * pList);
	int    SLAPI GetCurrList(PPID goodsID, PPID quotKindID, PPID locID, PPQuotArray & rQuotList);
	int    SLAPI GetCurrListByRelList(PPID goodsID, const PPIDArray & rRelList, PPQuotArray & rQuotList);
	int    SLAPI GetCurr(PPID goodsID, const QuotIdent & pIdent, double cost, double price, double * pQ, int useCache);
	int    SLAPI GetNearest(PPID goodsID, const QuotIdent & pIdent, PPQuot * pQuot, int useCache);
	//
	// Descr: Возвращает список идентификаторов товаров, имеющих котировки по фактору relID.
	//   Если параметр actualOnly != 0, то возвращается только список тех товаров,
	//   для которых есть актуальные записи.
	//
	int    SLAPI GetGoodsList(PPID relID, int actualOnly, PPIDArray & rList);
	int    SLAPI Set(const PPQuot & rQ, long qtaID, int logSj, int use_ta);
	int    SLAPI Set(PPQuotArray & rQList, long qtaID, int use_ta);
	int    SLAPI Set(PPQuotArray & rQList, long qtaID, const PPQuotArray * pTemplate, int noRmv, int use_ta);
	int    SLAPI RemoveAllForQuotKind(PPID quotKindID, int use_ta);
	int    SLAPI GetAddressLocList(PPIDArray & rList);

	int    SLAPI FetchRel(PPID relID, PPQuot * pVal);
	int    SLAPI RecToQuot(const Quotation2Tbl::Rec * pRec, PPQuot & rQuot);
	int    SLAPI RecToQuotRel(const Quotation2Tbl::Rec * pRec, PPQuot & rQuot);
	int    SLAPI FetchList(PPID goodsID, PPQuotArray & rList);
	int    SLAPI GetMatrix(PPID mtxQkID, PPID locID, PPIDArray * pList);
	int    SLAPI GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    SLAPI BelongToMatrix(PPID goodsID, PPID locID);
	//
	// Descr: Кэшированное извлечение матрицы товаров по складу locID.
	//
	int    SLAPI GetMatrix(PPID locID, PPIDArray * pResult);
	int    SLAPI GetMatrixListByLoc(PPID mtxQkID, PPID locID, PPIDArray & rList, PPIDArray & rNegList);
	//
	// Descr: Объявляет котировки по товару goodsID в кэше недействительными
	//
	int    SLAPI DirtyGoodsID(PPID goodsID);
	//
	// Descr: Очищает кэш котировок
	//
	int    SLAPI ClearCache();
	//
	// Descr: Объявляет матрицы товаров по списку складов pMtxLocList в кэше недействительными.
	//   Если pMtxLocList == 0 || pMtxLocList->getCount() == 0, то объявляет недействительными
	//   все товарные матрицы.
	//
	int    SLAPI DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList, int deferred);

	int    SLAPI ReplaceObj(PPID objType, PPID replacedID, PPID newID, int use_ta);

	Quot2RelTbl RelT;
private:
	int    SLAPI AdjustTime(Quotation2Tbl::Rec & rRec);
	int    SLAPI Helper_ReplaceRel(PPID replacedRelID, PPID newRelID, int use_ta);
	int    SLAPI RemoveAllForRel(PPID relID, const char * pPctMsg, int use_ta);
};
//
//
//
class QuotUpdFilt : public PPBaseFilt {
public:
	SLAPI  QuotUpdFilt();
	QuotUpdFilt & FASTCALL operator = (const QuotUpdFilt & s);
	int    FASTCALL IsQuotByAdvOptExists(const PPQuotArray *) const;
	int    FASTCALL IsQuotSuitesToAdvOpt(const PPQuot &) const;
	//int    SLAPI Write(SBuffer & rBuf, long) const;
	int    SLAPI Read_Pre720(SBuffer & rBuf, long);

	enum { // ByWhat
		byLots = 0,  // Изменение по ценам последнего лота
		byLastReval, // По последней переоценке
		byPctVal,    // По процентной величине QuotVal
		byAbsVal,    // По абсолютной величине QuotVal:QuotFlags
		byAddedQuot, // По значению котировки AdvOptQuotKindID:AdvOptLocID
		byDelete,    // Удалить
		byFormula    // По формуле
	};
	enum {
		fExistOnly         = 0x0001,  // Обновлять только существующие котировки
		fNonExistOnly      = 0x0002,  // Устанавливать только несуществующие котировки
		fSetupIfNotExists  = 0x0004,  // Обновить существующие и установить несуществующие
		fWarnExistsAbsQuot = 0x0008,  // Предупреждать о замене абсолютной котировки относительной
		fSkipNoDisGoods    = 0x0010,  // Не изменять котировки для товаров с признаком "Без скидки" (GF_NODISCOUNT)
		fSkipDatedQuot     = 0x0020,  // @v8.5.2 Не изменять значения котировок, заданные с периодом
		fSetupDatedSamples = 0x0040   // @v9.1.0 Устанавливать значения котировок по образцу вместе с периодом действия
	};
	char   ReserveStart[12]; // @anchor
	DateRange FiltQuotPeriod; // @v8.3.5 Фильтрующий критерий периода для значений котировок
	PPID   GoodsID;          // @v7.3.8
	DateRange QuotValPeriod; // @v7.3.5 Период, устанавливаемый в значения котировок
	PPID   QuotKindID;       //
	PPID   GoodsGrpID;       //
	PPID   ArticleID;        //
	PPID   RegisterOpID;     // Вид драфт-операции для создания документа, фиксирующего список товаров,
		// для которых изменилось значение котировки.
	int    ByWhat;           //
	long   Flags;            //
	long   EvTokID;          //
	long   QuotFlags;        //
	double QuotVal;          //
	// доп. условия для изменения котировок
	// (у данного товара на данном складе должна быть котировка с ук. ценой) {
	PPID   AdvOptQuotKindID; //
	PPID   AdvOptLocID;      //
	double AdvOptQuot;       //
	// } доп. условия для изменения котировок
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
	ObjIdListFilt LocList;   //
	ObjIdListFilt EventList; //
	ObjIdListFilt ArList;    // @v7.3.5
	SString Formula;         //
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};
//
// Стандарты штрихкодов
// В квадратных скобках приведены коэффициенты печати широких и узких полос (Print ratio)
//
#define BARCSTD_CODE11           1 // Code 11 (USD-8)                [2:1 - 3:1]
#define BARCSTD_INTRLVD2OF5      2 // Interleaved 2 of 5             [2:1 - 3:1]
#define BARCSTD_CODE39           3 // Code 39 (USD-3 & 3 of 9)       [2:1 - 3:1]
#define BARCSTD_CODE49           4 // Code 49                        [Fixed]
#define BARCSTD_PDF417           5 // PDF417                         [Fixed]
#define BARCSTD_EAN8             6 // EAN-8                          [Fixed]
#define BARCSTD_UPCE             7 // UPC-E                          [Fixed]
#define BARCSTD_CODE93           8 // Code 93 (USS-93)               [Fixed]
#define BARCSTD_CODE128          9 // Code 128 (USD-6)               [Fixed]
#define BARCSTD_EAN13           10 // EAN-13                         [Fixed]
#define BARCSTD_IND2OF5         11 // Industial 2 of 5               [2:1 - 3:1]
#define BARCSTD_STD2OF5         12 // Standard 2 of 5                [2:1 - 3:1]
#define BARCSTD_ANSI            13 // ANSI Codabar (USD-4 & 2 of 7)  [2:1 - 3:1]
#define BARCSTD_LOGMARS         14 // LOGMARS                        [2:1 - 3:1]
#define BARCSTD_MSI             15 // MSI                            [2:1 - 3:1]
#define BARCSTD_PLESSEY         16 // Plessey                        [2:1 - 3:1]
#define BARCSTD_UPCEAN2EXT      17 // UPC/EAN Extensions 2           [Fixed]
#define BARCSTD_UPCEAN5EXT      18 // UPC/EAN Extensions 5           [Fixed]
#define BARCSTD_UPCA            19 // UPCA                           [Fixed]
#define BARCSTD_POSTNET         20 // PostNet                        [Fixed]
#define BARCSTD_QR              21 // QR-code
//
// Конфигурация справочника товаров
// sizeof(PPGoodsConfig) == PROPRECFIXSIZE
//
// Опции справочника товаров
//
#define GCF_SUPPRLZERO                   0x00000001L  // Забивать ведущие нули в штрих-коде
#define GCF_ENABLEWP                     0x00000002L  // Разрешать ввод весового префикса
#define GCF_BCCHKDIG                     0x00000004L  // Штрихкод содержит контрольную цифру
#define GCF_BCNDIG                       0x00000008L  // В штрихкоде допускаются нецифровые символы
#define GCF_DISABLEWOTAXFLAG             0x00000010L  // Запрет установки флага "Цены без налогов"
#define GCF_LOADTOSCALEGID               0x00000020L  // На весы загружать вместо штрихкода строку,
	// состоящую из весового префикса и пятизначного идентификатора товара.
	// Такие сложности нужны для работы с кассой Ладога-Ф
#define GCF_FORCEBARCODE                 0x00000040L  // Запрет на ввод товара без штрихкода
#define GCF_RETAILPRICEBYMOSTRECENTLOT   0x00000080L  // Определять розничную цену по самому последнему лоту.
	// Если этот флаг не установлен, то функция ReceiptCore::GetCurrentGoodsPrice игнорирует флаг GPRET_MOSTRECENT
#define GCF_DONTSELPASSIVE               0x00000100L  // Не показывать пассивные товары в списках
#define GCF_XCHG_DONTRCVTAXGRPUPD        0x00000200L  // Не принимать изменение налоговой группы из другого раздела
#define GCF_ADDTOALTGRPWITHOUTMSG        0x00000400L  // Добавлять товар в альт. группу без предупреждения //
#define GCF_ONUNITEMOVEBARCODE           0x00000800L  // При объединении товаров переносить штрихкоды
#define GCF_VALID                        0x00001000L  // @transient Запись инициализирована
#define GCF_USEGOODSMATRIX               0x00002000L  // Использование матрицы товаров
#define GCF_XCHG_RCVSTRUCUPD             0x00004000L  // Принимать изменения товарных структур из других разделов
#define GCF_USESCALEBCPREFIX             0x00008000L  // Использовать весовые префиксы, определенные в записях весов
#define GCF_USEBRANDINGSELEXTDLG         0x00010000L  // Использовать бренд в расширенном диалоге ввода в товарных строках
#define GCF_AUTOPREFBARCODE              0x00020000L  // Автоматически присваивать первому штрихкоду признак предпочтительного
#define GCF_DONTDELFROMMTXGOODSINOPENORD 0x00040000L  // Не удалять из матрицы товары, которые находятся в отрытых заказах
#define GCF_XCHG_SENDGENGOODSCONTENT     0x00080000L  // @v7.7.12 Передавать в другие разделы содержимое обобщенных товаров
#define GCF_SHOWGSTRUCPRICE              0x00100000L  // @v8.0.0 В диалоге товарной структуры в списке вместо цены поступления показывать цену реализации
#define GCF_XCHG_SENDALTGROUP            0x00200000L  // @v8.1.12 Передавать в другие разделы альтернативные группы (не динамические) с содержимым
#define GCF_XCHG_SENDATTACHMENT          0x00400000L  // @v8.2.3  Передавать в другие разделы привязанные к товарам файлы (обычно, изображения)
#define GCF_IGNOREFOLDERMATRIX           0x00800000L  // @v8.3.4  Игнорировать значения товарной матрицы, установленные для товарных групп верхнего уровня

struct PPGoodsConfig { // @persistent @store(PropertyTbl)
	SLAPI  PPGoodsConfig();
	PPGoodsConfig & Clear();
	size_t GetSize_Pre770() const
	{
		return (size_t)(PTR8(&Ver__) - PTR8(this));
	}
	//
	// Descr: Определяет, является ли заданный штрихкод весовым
	// Returns:
	//   1 - префикс строки pBarcode совпадает с WghtPrefix
	//   2 - префикс строки pBarcode совпадает с WghtCntPrefix
	//   0 - pBarcode == 0 или префикс pBarcode не совпадает ни с WghtPrefix,
	//     ни с WghtCntPrefix (пустое значение WghtPrefix или WghtCntPrefix автоматически
	//     означает несовпадение).
	//
	int    FASTCALL IsWghtPrefix(const char * pBarcode) const;
	//
	// Descr: Возвращает список допустимых длин тованых штрихкодов
	//
	int    SLAPI GetCodeLenList(PPIDArray * pList, int * pAllowEmpty) const;

	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_GOODSCFG
	char   BarCodeLen[32];     // Список допустимых длин штрих-кодов напр.: "7,11"
	char   WghtPrefix[12];     // Префикс к штрих-коду весового товара
	long   Flags;              //
	PPID   DefUnitID;          // ->Ref(PPOBJ_UNIT)
	PPID   DefPckgTypeID;      //
	int16  MinUniqBcLen;       // Мин длина штрих-кода по которому
		// допускается идентифицировать товар при передаче между разделами БД
	int16  ACGI_Threshold;     // Количество дней с даты последнего прихода товара, в течении которых еще следует
		// загружать полностью израсходованный товар на кассы при полной загрузке (0 = infinity)
		// @v4.6.6 Этот параметр также определяет выбор товаров по цене лота
		// (просматриваются лоты, дата (Receipt.Dt) которых >= (OperDate-ACGI_Threshold))
	PPID   AssetGrpID;         // ->Ref(PPOBJ_GOODSGROUP) Группа основных средств
	PPID   MtxQkID;            // ->Ref(PPOBJ_QUOTKIND) Вид котировки товарной матрицы
	PPID   OwnArCodeCntrID;    // ->Ref(PPOBJ_OPCOUNTER) Счетчик собственных артикулов
	PPID   TareGrpID;          // ->Ref(PPOBJ_GOODSGROUP) Группа тары (для учета остатков по контрагентам)
	PPID   MtxRestrQkID;       // ->Ref(PPOBJ_QUOTKIND) Вид котировки ограничение товарной матрицы
	char   WghtCntPrefix[12];  // @v7.0.7 Префикс счетного весового товара (возможен специальный вариант передачи на весы).
	PPID   DefGroupID;         // @v7.2.7 Товарная группа по умолчанию
	SVerT  Ver__;              // @anchor @v7.7.0 Версия, сформировавшая запись. Если размер считанной записи меньше или равен,
		// чем (&Ver-this), то версия предшествует 7.7.0
	//
	PPID   BcPrefixGuaTagID;   // @v7.7.2 Тег, содержащий допустимые префиксы штрихкодов для глобальной учетной записи
	PPID   DefGoodsID;         // @v8.9.5 Товар по умолчанию для подстановки вместо неопределенных или не идентифицированных товаров
	uint8  Reserve[8];         // @v7.7.2
	TagFilt TagIndFilt;        // @anchor @v7.7.0 Фильтр тегов, определяющий окраску наименований товаров в отчетах
};
//
//
//
#define PPGDSK_GROUP      1L // Группы товаров
#define PPGDSK_GOODS      2L // Товары
#define PPGDSK_PCKGTYPE   3L // Типы пакетов
#define PPGDSK_TRANSPORT  4L // Транспортные средства
#define PPGDSK_BRAND      5L // Брэнды
#define PPGDSK_BRANDGROUP 6L // @v7.2.7 Группы брэндов
#define PPGDSK_SUPRWARE   7L // Составные товары // @vmiller

#define BARCODE_TYPE_PREFERRED 1000

class BarcodeArray : public TSArray <BarcodeTbl::Rec> {
public:
	int    SLAPI Add(const char * pCode, long codeType, double qtty);
	int    SLAPI Arrange();
	//
	// Descr: Возвращает единственный штрихкод из списка. Порядок предпочтения следующий:
	//    1. Если в списке нет ни одного элемента, то rBuf = 0 и код возврата -1.
	//    2. Если в списке единственный код, то возвращается он.
	//    3. Если в списке есть приоритетный код (BarcodeType == 1000 == BARCODE_TYPE_PREFERRED), то возращается он.
	//    4. Если в списке есть код с количеством == 1.0 то возвращается первый такой код (по порядку следования в списке)
	//    5. Если все предыдущие критерии не нашли своего удовлетворения, то возвращается самый первый код из списка.
	// Returns:
	//    <0 - список пуст
	//    2 - функция вернула приоритетный код, ассоциированный с количеством 1.0
	//    3 - функция вернула приоритетный код, ассоциированный с количеством, отличным от 1.0
	//    1 - функция вернула код по одному из критериев {2, 4, 5}
	//
	int    FASTCALL GetSingle(SString & rBuf) const;
	int    SLAPI SearchCode(const char * pCode, uint * pPos) const;
	BarcodeTbl::Rec * FASTCALL GetSingleItem(uint * pPos) const;
	BarcodeTbl::Rec * FASTCALL GetPreferredItem(uint * pPos) const;
	int    FASTCALL SetPreferredItem(uint pos);
	int    SLAPI Replace(const char * pSearchCode, const char * pReplaceCode);
};
//
//
//
#define CARGOUNIT_ITEM   1
#define CARGOUNIT_PCKG   2
#define CARGOUNIT_PALLET 3

typedef TSArray <ArGoodsCodeTbl::Rec> ArGoodsCodeArray;
//
// Descr: Параметры товара для заказа, транспортировки и хранения //
//   Property {PPOBJ_GOODS, Goods2.ID, GDSPRP_STOCKDATA}
//
struct GoodsStockExt {     // @persistent(DBX) @size=28+2*sizeof(SArray)
	//
	// Descr: Описание упаковки товара на паллете
	//
	struct Pallet { // @persistent @size=12
		int    IsValid() const
		{
			return BIN(PalletTypeID && PacksPerLayer > 0 && MaxLayers > 0);
		}
		PPID   PalletTypeID;   // ->Ref(PPOBJ_PALLET) Тип паллета
		int16  PacksPerLayer;  // Количество упаковок поставки в одном слое
		int16  MaxLayers;      // Максимальное число слоев на паллете
		uint32 Reserve;
	};
	SLAPI  GoodsStockExt();
	int    SLAPI Init();
	GoodsStockExt & FASTCALL operator = (const GoodsStockExt & rSrc);
	int    FASTCALL IsEqual(const GoodsStockExt & rS) const;
	int    SLAPI IsEmpty() const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Рассчитывает массу брутто qtty единиц товара в килограммах
	//
	double SLAPI CalcBrutto(double qtty) const;
	//
	// Descr: Рассчитывает объем qtty единиц товара в куб.метрах
	//
	double SLAPI CalcVolume(double qtty) const;
	//
	// Descr: Разносит объем, указанный одним числом (в куб. метрах)
	//   по полям Length, Width, Height (уже в миллиметрах)
	//
	int    SLAPI SetVolume(double volume);
	//
	// Descr: Возвращает минимальный запас товара на складе locID, Если locID == 0,
	// то запас товара общий для всех складов.
	// locID - склад (если 0, то для всех складов), useZeroLoc - если 1 и минимальный остаток по складу locID - 0,
	// то возвращаем минимальный остаток по складу 0.
	//
	double SLAPI GetMinStock(PPID locID, int useZeroLoc = 1);
	//
	// Descr: Возвращает максимальный минимальный запас товара и склад которому данный запас принадлежит.
	//
	double SLAPI GetMaxMinStock(PPID * pLocID);
	//
	// Устанавливает запас товара для склада locID.
	//
	int    SLAPI SetMinStock(PPID locID, double qtty);
	int    SLAPI GetSinglePalletEntry(Pallet * pEntry) const;
	int    SLAPI GetPalletEntry(PPID palletTypeID, Pallet * pEntry) const;
	int    SLAPI ConvertCargoUnits(int fromCargoUnit, int toCargoUnit, PPID palletTypeID, double srcVal, double * pDestVal, long flags) const;

	enum {
		fMultMinShipm = 0x0001 // MinShippmQtty одновременно определяет кратность отгужаемого количества
	};
	long   Brutto;         // Масса брутто, г (Если Package > 0, то масса упаковки поставки)
	PPDimention PckgDim;   // Габаритные размеры упаковки поставки, мм
	double Package;        // Емкость упаковки поставки (торговых единиц)
	int16  ExpiryPeriod;   // Срок годности товара (дней).
	int16  GseFlags;       // @v7.4.5 Reserve-->GseFlags
	double MinShippmQtty;  // @v7.2.7 Минимальное количество, которое можно отгрузить в одном документе
	PPDimention RtlDim;    // @v7.2.7 Габаритные размеры торговой единицы, мм
	RAssocArray MinStockList; // @anchor Минимальный запас товара по складам
	TSArray <Pallet> PltList; // Список описаний укладки упаковок на паллете
};

class GoodsCore : public Goods2Tbl {
public:
	friend class GoodsCache;

	SLAPI  GoodsCore();
	SLAPI ~GoodsCore();
	int    SLAPI Validate(const Goods2Tbl::Rec * pRec);
	int    SLAPI Update(PPID * pID, Goods2Tbl::Rec *, int use_ta);
	int    SLAPI UpdateBarcodes(PPID goodsID, const BarcodeArray * pCodeList, int use_ta);
	int    SLAPI UpdateArCodes(PPID goodsID, const ArGoodsCodeArray * pCodeList, int use_ta);
	int    SLAPI SetArCode(PPID goodsID, PPID arID, const char * pCode, int use_ta);
	int    SLAPI SetArCode(PPID goodsID, PPID arID, const char * pCode, int32 pack, int use_ta);
	int    SLAPI AddBarcode(PPID goodsID, const char * pBarcode, double qtty, int use_ta);
	int    SLAPI ReplaceArticleRefs(PPID replacedID, PPID newID, int use_ta);
		// @>>QuotationCore::ReplaceArticleRefs
	int    SLAPI Search(PPID, void * = 0);
	int    SLAPI SearchByName(long kind, const char * pName, PPID * pID, Goods2Tbl::Rec * pRec = 0);
	int    SLAPI SearchAnyRef(PPID objType, PPID objID, PPID * pID = 0);
	int    SLAPI SearchGListByStruc(PPID strucID, PPIDArray * pAry);
	int    SLAPI LoadNameList(const PPIDArray *, long flags, StrAssocArray *);
	int    SLAPI GetListByExtFilt(const ClsdGoodsFilt *, PPIDArray *);
	// @v8.6.4 @unused int    SLAPI SearchByExt(const ClsdGoodsFilt *, PPID *, Goods2Tbl::Rec * pRec);
	int    SLAPI SearchByExt(const GoodsExtTbl::Rec * pExtRec, PPID * pGoodsID, Goods2Tbl::Rec * pRec);
	int    SLAPI ReadBarcodes(PPID goodsID, BarcodeArray & rCodeList);
	//
	// Descr: Извлекате из базы данных список кодов, ассоциированных со статьями, по товару
	//   goodsID.
	//   Записи кодов вносятся в массив pCodeList (предварительно очищается функцией).
	// Returns:
	//   >0 - была извлечена по крайней мере одна искомая записись.
	//   <0 - нет ни одного подходящего кода
	//   0  - ошибка
	//
	int    SLAPI ReadArCodes(PPID goodsID, ArGoodsCodeArray * pCodeList);
	//
	// Descr: Извлекате из базы данных список кодов, ассоциированных со статьей arID, по товару
	//   goodsID. Если goodsID == 0, то извлекает все коды, связанные со статьей arID.
	//   Для arID == 0 извлекаются собственные коды по статьям.
	//   Записи кодов вносятся в массив pCodeList (предварительно очищается функцией).
	// Returns:
	//   >0 - была извлечена по крайней мере одна искомая записись.
	//   <0 - нет ни одного подходящего кода
	//   0  - ошибка
	//
	int    SLAPI ReadArCodesByAr(PPID goodsID, PPID arID, ArGoodsCodeArray * pCodeList);
	//
	// Descr: Возвращает список идентификатов товаров по аналитической статье codeArID.
	//   Идентификаторы заносятся в массив pList с проверкой уникальности (т.е. один и тот
	//   же ИД в массив не попадает). Функция предварительно массив не очищает.
	// Returns:
	//   >0 - был найден по крайней мере один товарный код, сопоставленный со статей codeArID
	//   <0 - не встретилось ни одного кода, сопоставленного с codeArID
	//   0  - ошибка
	//
	int    SLAPI GetListByAr(PPID codeArID, PPIDArray * pList);
	//
	// Descr: Переносит товарные коды по статьям со статьи srcArID на destArID.
	//   Если задан ид существующей товарной группы grpID, то переносятся только коды товаров,
	//   принадлежащих этой группе.
	//   Если srcArCode < 0 && grpID != 0 && destArID >= 0, тогда для статьи destArID
	//   генерируются коды товаров, принадлежащих группе grpID и не имеющих соотвествующих
	//   кодов.
	//   Если pLogger != 0, тогда информация о ходе процесса (и возможных проблемах) отображается в
	//   журнале.
	//
	int    SLAPI MoveArCodes(PPID destArID, PPID srcArID, PPID grpID, PPLogger * pLogger, int use_ta);
	int    SLAPI GetSingleBarcode(PPID id, SString & rBuf);
	int    SLAPI FetchSingleBarcode(PPID id, SString & rBuf);
	int    SLAPI SearchGoodsAnalogs(PPID id, PPIDArray & rList, SString * pTransitComponentBuf);
	// @v9.1.4 int    SLAPI GetGoodsArticle(PPID id, PPID * pArticle); // @5.2.5 VADIM
	//
	// Descr: Извлекает список идентификаторов товаров, имеющих штрихкоды, длина которых
	//   соответствует одной из указанных в массиве pLens. Если элементом массива
	//   явялется значение ноль, то перечисляются и те товары, которые вообще не имеют
	//   штрихкодов.
	// Note: Функция предварительно очищает список rList а после формирования сортирует
	//   и удаляет дубликаты.
	//
	int    SLAPI GetListByBarcodeLen(const PPIDArray * pLens, PPIDArray & rList);
	//
	// Descr: Извлекает список идентификаторов товаров, содержащих в наименовании
	//   подстроку pSubstr.
	// ARG(pSubstr      IN): Указатель на строку, которая должна содержаться в поле Name
	//   найденных товаров
	// ARG(pList       OUT): Указатель на массив, в который будут занесены идентификаторы
	//   найденных товаров.
	//   ! Функция не очищает список pList. То есть, те элементы, которые там уже есть
	//   в нем же и остануться.
	// ARG(skipPassive  IN):
	//   Если >0, то товары, которые имеют признак GF_PASSIV не будут
	//     заносится в список pList.
	//   Если 0, то функция не будет обращать внимание на признак GF_PASSIV в найденных товарах
	//   Если <0, то функция будет пропускать товары, имеющие признак GF_PASSIV только тогда,
	//     если в конфигурации товаров установлен флаг GCF_DONTSELPASSIVE.
	// ARG(srchByExtStr IN): Если !0, то кроме поля Name функция будет искать строку pSubstr
	//   в дополнительных полях товаров.
	//
	int    SLAPI GetListBySubstring(const char * pSubstr, PPIDArray * pList, int skipPassive, int srchByExtStr = 0);
		// @>>ExtStrSrch
	int    SLAPI GetListBySubstring(const char * pSubstr, StrAssocArray * pList, int skipPassive, int srchByExtStr = 0);
	//
	// Descr: Возвращает список товаров по списку брендов
	// Note: Список pBrandList должен быть отсортирован
	//
	int    SLAPI GetListByBrandList(const PPIDArray * pBrandList, PPIDArray * pGoodsList);
	int    SLAPI PutStockExt(PPID id, const GoodsStockExt * pData, int use_ta);
	int    SLAPI GetStockExt(PPID id, GoodsStockExt * pData, int useCache /*=0*/);
	int    SLAPI GetExt(PPID, GoodsExtTbl::Rec *);
	int    SLAPI PutExt(PPID, GoodsExtTbl::Rec *, int use_ta);
	//
	// Descr: находит товары, принадлежащих классу clsID с ненулевыми значениями свойства gcProp.
	//   Если параметр propVal != 0, то это усиливает требование к поиску: функция ищет только те
	//   товары значение свойства gcProp которых равно propVal.
	//   Если указатель pGoodsIdList не нулевой, то в него заносятся пары {GoodsID, PropVal} для //
	//   найденный товаров.
	// ARG(clsID         IN): @#{>0} ->Ref(PPOBJ_GOODSCLASS) ИД класса товара
	// ARG(gcProp        IN): @#{PPGdsCls::eKind, PPGdsCls::eGrade, PPGdsCls::eAdd, PPGdsCls::eAdd2} Классификатор товара
	// ARG(propVal       IN): @#{0..} Значение свойства товара, которое необходимо найти. Если 0, то
	//   перебираются все ненулевые значения.
	// ARG(pGoodsIdList OUT): @#{vptr0} Если !0 то в этот список заносятся пары {GoodsID, PropVal} для //
	//   найденных товаров.
	// Returns:
	//   >0 - найден по крайней мере один товар, удовлетворяющий заданным условиям.
	//   <0 - не найдено ни одного товара, удовлетворяющего условиям
	//   0  - ошибка
	//
	int    SLAPI GetExtPropRefList(PPID clsID, int gcProp, PPID propVal, LAssocArray * pGoodsIdList);
	int    SLAPI ReplaceExtObjRefs(PPID clsID, int gcProp, LAssocArray * pSubstList, int use_ta);
	int    SLAPI ReplaceExtDimScale(PPID clsID, int gcDim, long oldScale, long newScale, int use_ta);

	int    SLAPI Fetch(PPID id, Goods2Tbl::Rec * pRec);
	int    SLAPI Dirty(PPID id);
	int    SLAPI FetchConfig(PPGoodsConfig * pCfg);
	int    SLAPI DirtyConfig();
	//
	// Descr: Функция возвращает указатель на полный список товаров. Список представлен
	//   иерархическим массивом StrAssocArray содержащим идентификатор товара, идентификатор
	//   родительской группы товара и наименование товара.
	//
	//   Если текущий сеанс не поддерживает кэширование полного списка товаров, то
	//   возвращается 0.
	//   Если возникла ошибка, то возвращается 0.
	//
	//   Возвращаемый указатель является указателем на собственно массив, хранящийся в
	//   кэше. Так как этот кэш может совместно использоваться многими потоками, то
	//   после использования указателя необходимо разблокировать его вызовом GoodsCore::ReleaseFullList.
	//
	const StrAssocArray * SLAPI GetFullList();
	void   SLAPI ReleaseFullList(const StrAssocArray * pList);
	//
	// Descr: Сбрасывает кэш наименований товаров.
	//
	int    SLAPI ResetFullList();

	int    SLAPI SearchBarcode(const char * pCode, BarcodeTbl::Rec *);
	int    SLAPI SearchByBarcode(const char * pCode, BarcodeTbl::Rec *, Goods2Tbl::Rec * pGoodsRec = 0);
	int    SLAPI SearchBy2dBarcode(const char * pCodeLine, BarcodeTbl::Rec * pRec, Goods2Tbl::Rec * pGoodsRec);
	int    SLAPI SearchBarcodeSubstr(const char * pText, BarcodeArray * pCodes);
	int    SLAPI SearchBarcodeSubstrExt(const char * pText, BarcodeArray * pCodes);
	int    SLAPI SearchByArCode(PPID arID, const char * pBarcode, ArGoodsCodeTbl::Rec *, Goods2Tbl::Rec * pGoodsRec = 0);
	//
	// Descr: Ищет все товарные артикулы, связанные со статьей arID и содержащие подстроку substr.
	// ARG(arID IN): Идентификатор статьи, которой должны соотвествовать найденные коды.
	//   Если arID == -1, то ищутся собственные коды (ArID == 0).
	//   Если arID == 0, то ищутся все коды, независимо от статьи.
	// ARG(substr IN): Указатель на подстроку, которая должна содержаться во всех найденных
	//   артикулах.
	// ARG(codes OUT): Указатель на список найденных кодов. Обращаем внимание на то, что
	//   здесь используется именно BarcodeArray. Каждый элемент, внесенный данной функцией
	//   в этот массив содержит в поле BarcodeType идентификатор статьи, либо -1, если стать
	//   соответсвующего кода нулевая (такой трюк необходим для того, чтобы отличить этот
	//   элемент от настоящего штрихкода, в котором BarcodeType всегда равен нулю).
	// Returns:
	//   >0 - количество элементов, добавленных функцией в массив codes
	//   <0 - функция не нашла ни одного подходящего кода, либо в текущей конфигурации
	//        коды по статьям не исползуются.
	//   0  - ошибка
	// Note: Функция не очищает массив codes перед началом цикла поиска.
	//   то есть, все элементы, которые там были никуда не исчезнут.
	//
	int    SLAPI SearchArCodeSubstr(PPID arID, const char * substr, BarcodeArray * codes);
	int    SLAPI GetArCode(PPID arID, PPID goodsID, SString & rCode, int32 * pPack);
	int    SLAPI GetBarcodeByTemplate(PPID grp, const PPGoodsConfig & rCfg /*const char * pWghtPrefix*/, const char * pTempl, char * pBuf);
	//
	// Descr: Удаляет штрихкод, эквивалентный pCode и не принадлежащий товару goodsID
	// Note: Используется для устранения дубликатов штрихкодов перед сохранением
	//   пакета товара goodsID, имеющего более высокий приоритет по владению штрихкодов, нежели остальные
	//   записи в базе данных.
	//
	int    SLAPI RemoveDupBarcode(PPID goodsID, const char * pCode, int use_ta);
	int    SLAPI RemoveBarcodeLeadingZeros(int use_ta);
	//
	// Descr: переносит все товары из группы srcGrp в destGrp.
	//   Существование и валидность destGrp проверяется.
	//
	int    SLAPI MoveGrpToGrp(PPID srcGrp, PPID destGrp, int use_ta);
	int    SLAPI AssignGoodsToAltGrp(PPID goodsID, PPID grpID, long innerNum, int use_ta);
	//
	// Descr: Находит номер, идентифицирующий товар goodsID внутри альтернативной группы grpID.
	// ARG(goodsID    IN): Идентификатор товара
	// ARG(grpID      IN): Идентификатор альтернативной группы
	// ARG(pInnerNum OUT): Указатель, по которому присваивается значение номера.
	//   Если товар не принадлежит группе grpID или эта группа не является альтернативной либо
	//   является альтернативной динамической, то по указателю присваивается 0.
	// Returns:
	//   >0 - товар принадлежит альтернативной(не динамической) группе grpID. По указателю pInnerNum
	//      присвоено значение номера товара в этой группе.
	//   <0 - товар не принадлежит группе grpID либо эта группа не является альтернативной(не динамической).
	//    0 - ошибка
	//
	int    SLAPI GetGoodsCodeInAltGrp(PPID goodsID, PPID grpID, long * pInnerNum);
	int    SLAPI GetAltGroupsForGoods(PPID goodsID, PPIDArray * pGrpIDList);
	int    SLAPI IsExclusiveAltGrp(PPID altGrpID, PPID * pParentID);
	int    SLAPI CheckGoodsForExclusiveAltGrp(PPID goodsID, PPID altGrpID);
	int    SLAPI GetExclusiveAltParent(PPID goodsID, PPID parentID, PPID * pAltGrpID);

	int    SLAPI IsCompatibleByUnit(PPID id1, PPID id2, double * ratio);
	int    SLAPI IsChildOf(PPID, PPID parent);
	int    SLAPI IsAltGroup(PPID);
	int    SLAPI IsTempAltGroup(PPID);
	int    SLAPI IsDynamicAltGroup(PPID);
	//
	// Descr: Извлекает ЧЕРЕЗ КЭШ список терминальных групп, принадлежащих группе parentID.
	//
	int    SLAPI GetGroupTerminalList(PPID parentID, PPIDArray * pList, PPIDArray * pUntermList);
	//
	// Descr: Извлекает ЧЕРЕЗ КЭШ фильтр альтернативной группы grpID.
	//   Предварительно проверяет, чтобы grpID действительно была альтернативной группой.
	// ARG(grpID  IN): идентификатор группы, для которой нужно извлечь фильтр
	// ARG(pFilt OUT): #@{vptr} указатель по которому присваивается найденный фильтр.
	// Returns:
	//   >0 - группа grpID является альтернативной и ее фильтр успешно получен.
	//   <0 - либо группа grpID не является альтернативной, либо она не имеет фильтра.
	//        В этом случае по указателю pFilt присваивается пустой фильтр.
	//   0  - ошибка
	//        В этом случае по указателю pFilt присваивается пустой фильтр.
	//
	int    SLAPI GetAltGroupFilt(PPID grpID, GoodsFilt * pFilt);
	int    SLAPI GetGroupFilt(PPID grpID, GoodsFilt * pFilt);
	int    SLAPI BelongToGroup(PPID id, PPID grp, PPID * pSubGrp = 0);
	//
	// Descr: Определяет, принадлежит ли товар goodsID обобщению.
	// ARG(goodsID         IN): идентификатор товара, для которого требуется определить
	//   принадлежность обобщению
	// ARG(pGenGoodsID IN/OUT): @#{vptr} указатель на ид обобщения.
	//   Если *pGenGoodsID != 0, то функция определяет факт принадлежности товара
	//   обобщению *pGenGoodsID.
	//   Если *pGenGoodsID == 0, то функция определяет факт принадлежности товара
	//   любому обобщению идентификатор которого возврадает по адресу pGenGoodsID.
	// ARG(pAsscRec       OUT): @#{vptr0} указатель на структуру записи ассоциации,
	//   хранящей связку товар-обобщение. Если найденное обобщение является динамическим,
	//   то содержимое по этому указателю не изменяется.
	// Returns:
	//   1 - goodsID принадлежит обыкновенному обобщению
	//   2 - goodsID принадлежит динамическому обобщению
	//  <0 - goodsID не принадлежит обобщению
	//   0 - ошибка
	//
	int    SLAPI BelongToGen(PPID goodsID, PPID * pGenGoodsID, ObjAssocTbl::Rec * pAsscRec = 0);
		// @>>GoodsCore::BelongToDynGen
	//
	// Descr: Определяет, принадлежит ли товар goodsID динамическому обобщению.
	// ARG(goodsID         IN): идентификатор товара, для которого требуется определить
	//   принадлежность динамическому обобщению
	// ARG(pGenGoodsID IN/OUT): @#{vptr0} указатель на ид динамического обобщения.
	//   Если *pGenGoodsID != 0, то функция определяет факт принадлежности товара
	//   обобщению *pGenGoodsID.
	//   Если *pGenGoodsID == 0, то функция определяет факт принадлежности товара
	//   любому обобщению идентификатор которого возврадает по адресу pGenGoodsID.
	// ARG(pList IN): @#{vptr0) указатель на список, по которому (если не нулевой)
	//   присваивается список товаров, входящих в обобщение.
	// Returns:
	//  >0 - goodsID принадлежит динамическому обобщению
	//  <0 - goodsID не принадлежит обобщению
	//   0 - ошибка
	//
	int    SLAPI BelongToDynGen(PPID goodsID, PPID * pGenGoodsID, PPIDArray * pList);
	int    SLAPI GetGenericList(PPID genID, PPIDArray *);
	//
	// Descr: Возвращает список идентификаторов товаров, относящихся к динамическому обобщению
	//   genGoodsID.
	//
	int    SLAPI GetDynGenericList(PPID genGoodsID, PPIDArray * pList);
	int    SLAPI AssignGoodsToGen(PPID goodsID, PPID genID, int abbr, int use_ta);
	int    SLAPI RemoveGoodsFromGen(PPID goodsID, PPID genID, int use_ta);
	//
	// Descr: Заносит в БД полный список обобщения, ассоциированного с goodsID.
	//   Установленные до этого члены обобщения удаляются из базы данных.
	//
	int    SLAPI SetGenericList(PPID goodsID, const PPIDArray & rList, int use_ta);
	int    SLAPI SetAltGrpList(PPID grpID, const PPIDArray & rList, int use_ta);
	int    SLAPI MakeFullName(PPID grpID, PPID parentID, SString & rBuf);
	int    SLAPI GetQuot(PPID goodsID, const QuotIdent & rIdent, double cost, double price, double *, int useCache = 0);
	int    SLAPI GetQuotNearest(PPID goodsID, const QuotIdent & rIdent, PPQuot * pQuot, int useCache);
	int    SLAPI SetQuot(const PPQuot & rQ, int use_ta);
	int    SLAPI GetQuotList(PPID goodsID, PPID locID, PPQuotArray & rList);
	//
	// Descr: Удаляет все котировки имеющие вид qkID.
	// Note: Сервисная функция, используемая при удалении вида котировки. Прямое использование опасно и нежелательно.
	//
	int    SLAPI RemoveAllQuotForQuotKind(PPID qkID, int use_ta);
	//
	// Descr: Извлекает через кэш список котировок для товара goodsID.
	//   Параметры qkID и locID, если не нулевые, ограничивают возвращаемый список
	//   только теми элементами, которые содержать соотвествующие поля PPQuot::Kind и PPQuot::LocID.
	//
	int    SLAPI FetchQuotList(PPID goodsID, PPID qkID, PPID locID, PPQuotArray & rList);
	int    SLAPI SetQuotList(PPQuotArray & rQList, int use_ta);
	int    SLAPI ClearQuotCache();
	//
	// Descr: Более быстрый аналог функции SetQuotList: бережет время за счет использования уже загруженной копии
	//   списка котировок pTemplate.
	// Attention: Применять с осторожностью - если pTemplate будет неактуальным, для другого товара и т.д., то
	//   возможны тяжелые последствия. Крайне нежелателен вариант вызова с pTemplate != 0 и use_ta != 0 (когда
	//   список котировок из БД должен извлекаться внутри транзакции.
	//   В отладочной версии функции установлен assert(!(pTemplate && use_ta)).
	//
	int    SLAPI SetQuotListQ(PPQuotArray & rQList, const PPQuotArray * pTemplate, int noRmv, int use_ta);
	int    SLAPI GetMatrix(PPID locID, PPIDArray * pResult);
	int    SLAPI GetMatrix(const ObjIdListFilt & rLocList, int orRule, PPIDArray * pResult);
	int    SLAPI GetMatrixRestrict(PPID mtxRestrQkID, PPID goodsGrpID, PPID locID, int srchNearest, long * pResult);
	int    SLAPI BelongToMatrix(PPID goodsID, PPID locID);
	int    SLAPI DirtyMatrix(const PPIDArray * pGoodsList, PPIDArray * pMtxLocList);
	int    SLAPI CorrectCycleLink(PPID id, PPLogger * pLogger, int use_ta);
	//
	GoodsExtTbl & SLAPI GetExtTbl_() { return GeT; }       // really private
	BarcodeTbl  & SLAPI GetBcTbl_() { return BCTbl; }      // really private
	ArGoodsCodeTbl & SLAPI GetACodTbl_() { return ACodT; } // really private
private:
	BarcodeTbl    BCTbl;
	GoodsExtTbl   GeT;
	ArGoodsCodeTbl ACodT;
	Reference   * P_Ref;
	QuotationCore  * P_Qc;
	Quotation2Core * P_Qc2;

	int    SLAPI InitQc();
	DBQ  & SLAPI SetupDimDBQ(const PPGdsClsPacket *, int dim, const RealRange *);
		// @<<GoodsCore::GetListByExtFilt
	//int    SLAPI Helper_GetBarcodeByTempl(const char * pPrfx, const char * pSfx, int, long, long, int addChkDig, SString &);
	int    SLAPI Helper_GetBarcodeByTempl(const char * pPrfx, const char * pSfx, uint len, int64 low, int64 upp, int addChkDig, SString & rBarcode);
	int    SLAPI SearchAnyDynObjRef(PPID objType, PPID objID, PPID * pID);
		// @<<GoodsCore::SearchAnyRef
	int    SLAPI FetchStockExt(PPID id, GoodsStockExt * pExt);
	int    SLAPI Helper_ReadArCodes(PPID goodsID, PPID arID, ArGoodsCodeArray * pCodeList, PPIDArray * pIdList);
	int    SLAPI Helper_BelongToGroup(PPID id, PPID grp, PPID * pSubGrp, PPIDArray *);
	int    SLAPI Helper_GetGroupTerminalList(PPID parentID, PPIDArray & rList, PPIDArray & rUntermList);
	int    SLAPI Helper_GetMtxByLoc(PPID locID, PPIDArray & rResult);
	//
	enum {
		glsfStrList     = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		glsfSkipPassive = 0x0002,
		glsfDefPassive  = 0x0004,
		glsfByExtStr    = 0x0008
	};
	int    SLAPI Helper_GetListBySubstring(const char * pSubstr, void * pList, long flags);
};

//
// HistGoodsCore
//
class HistGoodsCore : public HistGoodsTbl {
public:
	int    SLAPI Insert(PPID * pHistID, SBuffer * pBuf, int use_ta);
	int    SLAPI Search(PPID goodsID, long ver, HistGoodsTbl::Rec * pRec);
	int    SLAPI Search(PPID histID, SBuffer * pBuf);
	long   SLAPI GetNextVer(PPID goodsID);
private:
};
//
// Структуры представления счетов. Существенно,
// что обе структуры имеют одинаковый размер.
//
#define ACCBIN_NATURE 1
#define ACCBIN_DB     2
//
// Бух. счет в формате внешнего представления (Nature format)
//
struct Acct {
	void   SLAPI Clear()
	{
		ac = 0;
		sb = 0;
		ar = 0;
	}
	Acct & FASTCALL operator = (const AcctRelTbl::Rec &);
	Acct & FASTCALL operator = (const PPAccount &);

	char * SLAPI ToStr(long format, char * pBuf) const; // ACCBIN_NATURE
	SString & SLAPI ToStr(long format, SString & rBuf) const;
	int    SLAPI FromStr(long format, const char *); // ACCBIN_NATURE

	int16  ac;            // Счет
	int16  sb;            // Субсчет
	long   ar;            // Аналитическая статья //
};

int SLAPI IsSuitableAcc(Acct * pAcc, int aco /* ACO_X */, Acct * pPattern);
//
// Бух. счет в форме ид-ров баз данных (DB format);
//
struct AcctID {
	void   SLAPI Clear()
	{
		ac = 0;
		ar = 0;
	}
	int    FASTCALL operator == (AcctID s) const
	{
		return (ac == s.ac && ar == s.ar);
	}
	int    FASTCALL operator != (AcctID s) const
	{
		return (ac != s.ac || ar != s.ar);
	}
	PPID   ac;
	PPID   ar;
};

// @v9.3.9 char * SLAPI AccToStr(const Acct *, long format, char *); // ACCBIN_NATURE
// @v9.3.9 SString & SLAPI AccToStr(const Acct * acc, long format, SString & rBuf);
// @v9.3.9 int    SLAPI StrToAcc(Acct *, long format, const char *); // ACCBIN_NATURE
//
// Тип STAcct подогнан под использование в списках ComboBox'а
//
// Тип STAcct может иметь размер [sizeof(int)+sizeof(int)] (без аналит.
// статьи), либо [sizeof(Acct)] (с аналит. статьей). Если размер больше
// чем sizeof(STAcct), то структура типа такова:
//
// { int16 ac; int16 sb; char name[DataType::s - sizeof(int) * 2]; }
//
class STAcct : public DataType {
public:
	SLAPI  STAcct(size_t = sizeof(Acct));
	char * SLAPI tostr(const void *, long, char *) const;
	int    SLAPI fromstr(void *, long, const char *) const;
};

void SLAPI RegisterSTAcct();

#define PPAF_DBFORMAT          0x0001L // Формат ACCBIN_DB (иначе ACCBIN_NATURE)
#define PPAF_TEMPLATE          0x0010L // Шаблон бухгалтерской проводки
#define PPAF_AUTOBILL          0x0020L // Проводка автоматически генерирует документ
#define PPAF_OUTBAL            0x0040L // Забалансовая проводка
#define PPAF_OUTBAL_WITHDRAWAL 0x0080L // Забалансовый расход (Withdrawal)
	// If PPAF_OUTBAL && !PPAF_OUTBAL_WITHDRAWAL then Deposit
#define PPAF_OUTBAL_TRANSFER   0x0100L // Забалансовый трансфер
	//
#define PPAF_REGISTER          0x0200L // Регистровая проводка
//
// Бухгалтерская проводка
//
// Замечание по забалансовым проводкам:
//   Приход (Deposit):
//     Flags: PPAF_OUTBAL; DbtID: Acc; CrdID: Zero; Amount > 0
//   Расход (Withdrawal):
//     Flags: PPAF_OUTBAL | PPAF_OUTBAL_WITHDRAWAL; DbtID: Acc; CrdID: Zero; Amount < 0
//   Трансфер (Transfer):
//     Flags: PPAF_OUTBAL | PPAF_OUTBAL_TRANSFER; DbtID: Receiver Acc; CrdID: Sender Acc; Amount > 0
//
struct PPAccTurn { // @persistent
	SLAPI  PPAccTurn();
	void   SLAPI SwapDbtCrd();
	int    FASTCALL IsEqual(const PPAccTurn & rS) const;

	AcctID DbtID;
	PPID   DbtSheet;
	AcctID CrdID;
	PPID   CrdSheet;
	LDATE  Date;
	char   BillCode[24];   // Код документа
	PPID   BillID;         // Идентификатор документа
	int16  RByBill;        // Номер проводки по документу
	int16  Reserve;        // @alignment
	PPID   CurID;          // Валюта проводки
	double CRate;          // Курс валюты CurID по отношению к базовой
	double Amount;         // Сумма в валюте CurID
	long   Opr;
	long   Flags;
};
//
// Шаблон бухгалтерской проводки
//
#define ATTF_DACCFIX        0x00000001L // Счет по дебету зафиксирован
#define ATTF_DARTFIX        0x00000002L // Статья по дебету зафиксирована
#define ATTF_CACCFIX        0x00000004L // Счет по кредиту зафиксирован
#define ATTF_CARTFIX        0x00000008L // Статья по кредиту зафиксирована
	//
	// Следующий флаг предназначен для разрешения неопределенности в присвоении идентификатора объекта.
	// В большинстве случаев неопределенности не возникает и этот флаг игнорируется, однако,
	// если в операции участвуют два однотипных объекта (склад-склад | клиент-клиент и тд), то может
	// возникнуть проблема какой стороне проводки какой объект присваивать. Если этот флаг установлен, то
	// первичный объект присваивается счету по кредиту, в противном случае по дебету.
	//
#define ATTF_PRIMONCREDIT   0x00000010L // Первичный объект по кредиту
#define ATTF_EXPRESSION     0x00000020L // Шаблон содержит выражение для суммы
	//
	// Следующие два флага предписывают опустить проводку, если отсутствует
	// ненулевой (первичный или вторичный соответственно) объект для подстановки.
	//
#define ATTF_PSKIPONZOBJ    0x00000040L
#define ATTF_FSKIPONZOBJ    0x00000080L
	//
	// Следующие два флага определяют существование явных правил подстановки
	// для первичного или вторичного объектов соответственно (в поле PPAccTurnTempl::Subst)
	//
#define ATTF_PSUBSTRULE     0x00000100L
#define ATTF_FSUBSTRULE     0x00000200L
#define ATTF_SKIPNEG        0x00000400L // Не проводить отрицательную сумму
#define ATTF_INVERTNEG      0x00000800L // Инвертировать счета при отрицательной сумме
#define ATTF_BASEPROJECTION 0x00001000L // Шаблон должет быть спроецирован на базовую валюту по всем валютам
#define ATTF_INTROUNDING    0x00002000L // Округлять сумму проводки до целых
#define ATTF_PASSIVE        0x00004000L // Пассивный шаблон (не генерировать проводку)
#define ATTF_SUBSTDACC      0x00010000L // Подставлять дебетовый счет из Secondary Obj
#define ATTF_SUBSTCACC      0x00020000L // Подставлять кредитовый счет из Secondary Obj
#define ATTF_BYADVLINES     0x00040000L // Проводки по каждой из строк расширения бух документа
#define ATTF_SKIPEMPTYALIAS 0x00080000L // Не проводить, если нет подстановки для алиаса счета
#define ATTF_CVT6406        0x00100000L // Запись сконвертирована в формат v6.4.06

class PPAccTurnTempl { // @persistent @store(PropertyTbl)
public:
	static int SLAPI Convert_6407(PropertyTbl::Rec * pRec);

	int    SLAPI SetupSubst(char * primStr, char * foreignStr);
	int    SLAPI SubstToStrings(SString & rPrimStr, SString & rForeignStr);
	int    SLAPI CreateAccturns(PPBillPacket *);
	int    SLAPI CreateBaseProjectionAccturns(PPBillPacket *);

	int    SLAPI AccTemplToStr(int side, SString & rBuf);
	int    SLAPI AccTemplFromStr(int side, const char * pBuf);

	PPID   ObjType;       // Const=PPOBJ_OPRKIND
	PPID   ObjID;         // ->Ref(PPOBJ_OPRKIND)
	PPID   ID;            // Номер шаблона для операции (1..PP_MAXATURNTEMPLATES)
	AcctID DbtID;
	AcctID CrdID;
	long   Flags;
	DateRange Period;     // Период действия шаблона
	//
	// В это поле сначала заносится порядок подстановки для первичного объекта, затем разделитель -1L,
	// затем порядок подстановки для вторичного объекта, затем двоичный нуль (0L).
	// Если для первичного объекта нет явного порядка, то Subst[0] == -1L.
	// Завершающий нуль должен присутствовать всегда (смотри предыдущий параграф).
	//
	PPID   Subst[8];      // Переменные объектов для подстановки в проводку
	uint8  Reserve[12];
	char   Expr[256];     // Формула для суммы проводки (текст)
private:
	struct ATSubstObjects {
		ATSubstObjects()
		{
		}
		void   destroy()
		{
			PrimList.clear();
			ForeignList.clear();
		}
		struct Item {
			Item()
			{
				Aid.Clear();
				AcsID = 0;
			}
			AcctID Aid;
			PPID   AcsID;
		};
		TSArray <ATSubstObjects::Item> PrimList;
		TSArray <ATSubstObjects::Item> ForeignList;
	};
	struct ATBillParam {
		enum {
			fIsRcknInited  = 0x0001,
			fAr            = 0x0002  // Поле AdvItemIdx применяется как номер статьи для подставновки
		};
		PPBillPacket * P_Pack;
		PPBillPacket * P_LinkPack;
		PPBillPacket * P_RcknPack;
		int    AdvItemIdx;
		PPID   AccSheetID;           // Таблица, с которой сопоставлена статья AdvItemIdx (Flags & fAr)
		long   Flags;
	};
	struct ExtLinesBlock {
		int    AccWrOff;        // Блок сформирован как перечисление по статьям таблицы AccSheetID
			// для списания по счетам
		uint   Idx;
		PPID   AccSheetID;
		int    SubstAr;
		const  PPBillPacket * P_Pack;
		PPIDArray SubstArList;
	};
	int    SLAPI SetupAccounts(ATBillParam & rParam, PPID curID, PPAccTurn * pAT) const;
		// @<<PPAccTurnTempl::CreateAccturns, @<<PPAccTurnTempl::CreateBaseProjectionAccturns
	int    SLAPI SubstAcct(int side, PPAccTurn *, const ATSubstObjects *, const AcctID *, const AcctID *) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    SLAPI ParseSubstString(const char * str, int * lp, int * skipzobj);
	int    SLAPI SubstToString(SString & rBuf, int * lp, int skipzobj);
	int    SLAPI GetObjByVar(PPID, ATBillParam *, PPID * pObjID) const;
	int    SLAPI GetSubstObjects(ATBillParam *, ATSubstObjects *, int byAcc) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    SLAPI ResolveAlias(int side, AcctID * pAcct, const ATSubstObjects * pAtso) const;
		// @<<PPAccTurnTempl::SetupAccounts
	int    SLAPI EnumerateExtLines(const PPBillPacket * pPack, ExtLinesBlock * pBlk) const;
};
//
// Descr: Блок параметров для бухгалтерской проводки по счету
//
struct AccTurnParam {
	int    Side; // Cторона баланса (PPDEBIT || PPCREDIT)
	double Amt;  // Cумма проводки (Amt != 0)
	double Low;  // Mинимальная допустимая разность (debit - credit) по счету после проводки
	double Upp;  // Mаксимальная допустимая разность (debit - credit) по счету после проводки
};
//
// Методы расчета доходности по операциям
//
#define INCM_DEFAULT              0  // По флажкам операций
#define INCM_BYSHIPMENT           1  // По отгрузке
#define INCM_BYPAYMENT            2  // По оплате
#define INCM_BYPAYMENTINPERIOD    3  // @v9.6.5 Специальный вариант, учитывающий оплаты только по документам, попадающим в тот же период
//
// Флаги общей конфигурации
//
#define CCFLG_PRICEWOEXCISE        0x00000001L // Цена задана без налога с продаж
#define CCFLG_TGGLEXCSNPRICE       0x00000002L // Переключать акциз не меняя цены
#define CCFLG_SETWLONLINK          0x00000004L // Устанавливать WL на связанные документы одновременно с основным документом
#define CCFLG_COSTWOVATBYDEF       0x00000008L // Цены поступления по умолчанию без НДС (в диалоге строки документа прихода  //
	// устанавливается соответствующий флаг)                     //
#define CCFLG_COSTWOVATBYSUM       0x00000010L // Если цена поступления задана
	// без НДС, то расчитывать НДС исходя из суммы, иначе - из цены.
	// По умолчанию в этом случае НДС расчитывается исходя из цены (и это правильно).
#define CCFLG_NOADJPRWROFFDRAFT    0x00000020L // @v9.3.4 Блокировка функции прецизионного выравнивания цен при списании драфт-документов
#define CCFLG_DONTUNDOOPCNTRONESC  0x00000040L // @v9.5.2 Не пытаться откатывать счетчик операций при отмене провоедения нового документа
#define CCFLG_USEGDSCLS            0x00000080L // Использовать классы товаров
#define CCFLG_USEGOODSPCKG         0x00000100L // Использовать товарные пакеты
#define CCFLG_USEDRAFTBILL         0x00000200L // Использовать драфт-документы
#define CCFLG_USENOUPDRESTOPFLAG   0x00000400L // Использовать флаг
	// "Не изменять остатки по лотам" в видах операций. Ошибочная устанока
	// флага может вызвать исключительно неблагоприятные последствия.
#define CCFLG_USEADVBILLITEMS      0x00000800L // Использовать расширенние бухгалтерских
	// документов. Устанавливается функцией SetupConfigByOps().
#define CCFLG_DISABLEACCTURN       0x00001000L // Запрет бухгалтерских проводок по документам
#define CCFLG_IGNOREORDERSDEBT     0x00002000L // Игнорировать долги по заказам
#define CCFLG_USEHISTBILL          0x00004000L // Вести историю документов
#define CCFLG_CHECKSPOILAGE        0x00008000L // Проверять на принадлежность товара к браку
#define CCFLG_DEBUG                0x00010000L // Отладочный режим
#define CCFLG_THROUGHSCARDUNIQ     0x00020000L // Сквозная уникальность дисконтных карт
#define CCFLG_USEHISTGOODS         0x00040000L // Вести историю товаров
#define CCFLG_USECCHECKEXT         0x00080000L // Использовать таблицу расширения кассовых чеков
#define CCFLG_TRFR_DONTRECALCREVAL 0x00100000L // Функция Transfer::UpdateForward не пересчитывает проводки после изменения строки переоценки
#define CCFLG_GENLOTONUNLIMORDER   0x00200000L // Генерировать лоты на нелимитируемые заказы
#define CCFLG_DEBUGTRFRERROR       0x00400000L // Проверять лоты и текущие товарные остатки после каждого проведения //
	// или изменения товарного документа
#define CCFLG_USEARGOODSCODE       0x00800000L // Использовать товарные коды, привязанные к статьям
// @v9.1.1 (заменено на sluifUseLargeDialogs в SLIB) #define CCFLG_USELARGEDIALOG       0x01000000L // Использовать большой диалог
#define CCFLG_USECCHECKLINEEXT     0x02000000L // Использовать расширения строк чеков
#define CCFLG_INDIVIDBILLEXTFILT   0x04000000L // Индивидуальная фильтрация по расширению документов
	// Если флаг включен, то при фильтрации документов с помощью функции BillCore::GetBillListByExt
	// используется отбор по вызову PPObjBill::FetchExt.
	// Необходимость в таком переключении может возникнуть в случае, если значительная часть документов
	// имеет расширение и учет ведется в течении длительного времени (BillCore::GetBillListByExt
	// работает в такой ситуации очень долго).
#define CCFLG_USEDISTRIBCOST       0x08000000L // Использовать распределение себестоимости
#define CCFLG_LOGCCHECK            0x10000000L // Заносить в журнал операции с чеками
#define CCFLG_RSRVSJ               0x20000000L // Если не удалось добавить запись в системный журнал,
	// то заносить ее в резервную таблицу.
#define CCFLG_3TIER                0x40000000L // Сеанс запущен в режиме 3tier
//
//
//
#define CCFLG2_QUOT2               0x00000001L // @v7.1.11 БД использует 2-е поколение котировок
#define CCFLG2_USESDONPURCHOP      0x00000002L // @v7.2.2  Проекция флага AGTF_USESDONPURCHOP в общем соглашении с поставщиками
#define CCFLG2_INDEXEADDR          0x00000004L // @v7.3.2  Индексировать телефоны из персоналий и адресов
	// Если этот флаг включен, то в таблицу EAddr записываются все телефоны из создаваемых и изменяемых
	// персоналий и адресов для ускоренного извлечения объектов, связанных с телефоном.
#define CCFLG2_SYNCLOT             0x00000008L // @v7.6.1 Синхронизировать лоты
#define CCFLG2_ADJCPANCCLINETRANS  0x00000010L // @v7.9.6 При преобразовании строки чека из кассовой панели в запись
	// CCheckLine корректировать разницу за счет скидки. Функция CCheckItem::GetRec().
	// Необходимость в установке пареметра может возникнуть при работе с товарами, которые продаются большими
	// количествами и по ценам, имеющим более двух знаков после точки.
	// Возможно, правило такой корректировки должно быть применено во всех случаях, однако, во
	// избежании проблем с работающими инсталляциями, страхуемся вводом данного параметра.
#define CCFLG2_USECCHECKEXTPAYM    0x00000020L // @v8.0.0 Использовать расширение оплат по чекам
#define CCFLG2_DONTUSE3TIERGMTX    0x00000040L // @v8.1.9 Не использовать извлечение товарной матрицы с сервера при 3-tier режиме работы
#define CCFLG2_USEOMTPAYMAMT       0x00000080L // @v8.5.8 Использовать включенную сумму оплаты по документам
#define CCFLG2_USESARTREDB         0x00000100L // @v9.7.11 Использовать базу данных Sartre (экпериментальная опция)
//
// Общие параметры конфигурации
//
struct PPCommConfig {      // @persistent @store(PropertyTbl)
	PPID   Tag;               // Const=PPOBJ_CONFIG
	PPID   ID;                // Const=PPCFG_MAIN
	PPID   Prop;              // Const=PPPRP_COMMCFG
	Acct   SupplAcct;         // Счет расчетов с поставщиками
	Acct   SellAcct;          // Счет расчетов с клиентами
	Acct   CashAcct;          // Счет кассы (для кассовой книги)
	PPID   SupplAccSheet;     // Таблица статей поставщиков
	PPID   SellAccSheet;      // Таблица статей покупателей
	short  Reserve2;          // DefPayPeriod-->Reserve2 @attention: Это поле может не быть равным нулю.
	short  IncomeCalcMethod;  // Метод расчета доходности операций (INCM_XXX)
	PPID   AutoComplOp;       // Операция автокомплектации
	long   Flags;             // CCFLG_XXX
	PPID   MainOrgID;         // Главная организация по умолчанию
	PPID   MainOrgDirector_;   // Директор главной организации
	PPID   MainOrgAccountant_; // Бухгалтер главной организации
	PPID   ReceiptOp;         // Операция прихода товара от поставщика
	PPID   RetailOp;          // Операция розничной продажи
	PPID   RetailRetOp;       // Операция розничного возврата
	PPID   IntrReceiptOp;     // Операция межскладского прихода

	int16  FRRL_Days;         // Порог включения блокировки пересчета
		// форвардных остатков при проводке документов задним числом.
		// Если (LConfig.OperDate - BillDate) >= FRRL_Days, то включается FRRL.
	int16  MaxGoodsBillLines;           // @def=300 Максимальное количество товарных строк в документе.
	int16  GRestCalcThreshold;          // @def=10  Порог расчета остатков товаров по группе, промилле
	char   PrepayInvoiceGoodsCode_obsolete[16];  // Код товара для печати счета-фактуры на предоплату по бухгалтерскому документу
	int16  CSessUnitingPeriod;          // @def=720=(12*60) Период объединения кассовых сессий в
		// суперсессии (минут). Если две сессии различаются по времени закрытия //
		// менее чем на это значение, то они объединяются в одну суперсессию.
	int16  CSessFwAsscPeriod;           // @def=1440=(24*60) Период ассоциирования неопределенных
		// кассовых чеков с форвардным Z-чеком (минут). Если существует Z-чек,
		// отстоящий от чека с неопределенной кассовой сессией менее чем на
		// на это значение, то система считает, что чек относится к сессии,
		// определяемой этим Z-чеком.
	Acct   ImprestAcct;                 // Счет для расчетов с подотчетными лицами (71)
	LDATE  _390_DisCalcMethodLockDate;  // Дата, до которой следует
		// отключать новый метод (@3.9.0) расчета скидки по документу (BPAKCALC.CPP)
		// Документы, с датой меньше или равной указанной расчитываются по-старому.
		// Новый метод правильнее, однако влечет за собой пересчет старых документов.
	LDATE _3918_TDisCalcMethodLockDate; // Дата, до которой следует отключать новый метод расчета общей скидки по товарному документу
	Acct   AssetAcct;                   // Счет для учета основных фондов (01)
	LDATE _405_TDisCalcMethodLockDate;  // Дата, до которой следует отключить новый метод расчета общей скидки по товарному документу
	LDATE _418_TDisCalcMethodLockDate;  // Дата, до которой следует отключить новый метод расчета общей скидки по товарному документу
	PPID   DraftRcptOp;                 //
	int16  LcrUsage;                    // Варианты использования текущих остатков по лотам:
		// 0 - не использовать, 1 - только поддерживать в актуальном состоянии, 2 - применять при расчетах остатков
	PPID   DynGoodsTypeForSupplAgent;   // Динамический тип товара для лотов, имеющих агента поставщика
	long   Flags2;                      // @v7.1.11 CCFLG2_XXX Дополнительное поле флагов
	int16  IltiCvtQttyEpsilon;          // @v7.6.3 1E-7 Величина количественного дефицита, которую следует игнорировать при
		// проведении расходных товарных операций. Умножается на 1E-7.
	int16  Reserve3;                    // @v7.6.3 @alignment
	LDATE  _InvcMergeTaxCalcAlg2Since;  // @v8.6.0 Дата, начиная с которой применяется алгорим 2 для расчета налогов по
		// объединенным строкам счет-фактуры (для печати).
	PPID   PrepayInvoiceGoodsID;        // @v9.7.0 Товара для печати счета-фактуры на предоплату по бухгалтерскому документу
		// Так же применяется для печати чеков без подробного содержания.
};
//
// Extra config flags (from pp.ini)
// Эти флаги храняться в экземпляре PPSession (общие всех потоков)
//
#define ECF_GOODSRESTPACK          0x00000001L
#define ECF_TRFRITEMPACK           0x00000002L
#define ECF_GOODSBILLFILTSHOWDEBT  0x00000004L
#define ECF_ECOGOODSSEL            0x00000008L
#define ECF_433OLDGENBARCODEMETHOD 0x00000010L // Использовать старый метод генерации штрихкода
	// Этот флаг инициализируется  параметром [config] 433OldGenBarcodeMethod в файле pp.ini
	// Различия в методах генерации штрихкода определены функцией
	// int SLAPI GoodsCore::Helper_GetBarcodeByTempl (goods.cpp)
#define ECF_SYSSERVICE			   0x00000020L // Работа в режиме системного сервиса
#define ECF_CLIENT				   0x00000040L // Работа в режиме клиента трехзвенки
#define ECF_AVERAGE                0x00000080L // Установленный флаг делает доступными некоторые аварийные операции
#define ECF_DBDICTDL600            0x00000100L // Использовать в качестве словаря описание таблицы БД в DL600
#define ECF_FULLGOODSCACHE         0x00000200L // Сеанс использует кэширование полного списка товаров
#define ECF_INITONLOGIN            0x00000400L // Специальный флаг, сигнализирующий о том, что та часть инициализации флагов,
	// за которую отвечает функция PPSession::Login осуществлена.
	// Это важно для многопоточного варианта, дабы снизить время авторизации и избежать конфликтов.
#define ECF_PREPROCBRWONCHGFILT    0x00000800L //
#define ECF_CHKPAN_USEGDSLOCASSOC  0x00001000L // В кассовой панели использовать ассоциации товар-склад.
	// В противном случае будут использоваться локальные по отношению к узлу ассоциации товар-кассовый узел.
	// Речь идет об ассоциациях, применяемых для раздельной печати одного чека на разные кассовые принтеры.
#define ECF_DEBUGDIRTYMTX          0x00002000L // @v7.3.11 Выводить в журнал mtxdirty.log информацию об актуализации
	// кэша товарной матрицы. Этот журнал - временный и отладочный. Необходим для решения изредка возникающих проблем
	// с актуализацией кэша матрицы сервером Papyrus.
#define ECF_USECDB                 0x00004000L // @v7.4.8 Использовать конфигурационную базу данных
#define ECF_RCPTDLVRLOCASWAREHOUSE 0x00008000L // @v7.5.9 При выборе адеса доставки в диалоге документа прихода товаров,
	// комбо-бокс будет отражать склады главной организации (для драфт-документов прихода такое поведение - безусловно).
#define ECF_DETECTCRDBTEXISTBYOPEN 0x00010000L // @v8.2.4 (видимо, временный) флаг, предписывающий системе иднтифицировать
	// существование Btrieve-файлов созданных для печати посредством функций Btrieve, но не через fileExists()
	// Устанавливается, если в pp.ini включен параметр DETECTDBTEXISTBYOPEN=100
#define ECF_USESJLOGINEVENT        0x00020000L // @v8.2.5
#define ECF_CODEPREFIXEDLIST       0x00040000L // @v8.4.11 Элементы списков некоторых объектов предваряются кодами
	// Устанавливается, если в pp.ini включен параметр CodePrefixedList=1
#define ECF_TRACESYNCLOT           0x00080000L // @v8.5.7 Отладочный флаг для трассировки синхронизации лотов
#define ECF_DISABLEASYNCADVQUEUE   0x00100000L // @v8.5.12 Защитный флаг, препятствующий применению техники асинхронной очереди системных событий
#define ECF_USEGEOTRACKING         0x00200000L // @v8.6.11 Если флаг не установлен, то коммуникации с мобильными устройствами по гео-трекингу отключены
#define ECF_DLLMODULE              0x00400000L // @v9.2.6 Работа в режиме DLL-модуля
#define ECF_OPENSOURCE             0x00800000L // @v9.4.9 Система собрана в opensource-варианте
//
//
//
struct PPLastInputData {
	double CalcMem;
	double VaPercent;
	char   Barcode[24];
	PPID   QuotCurID;
	PPID   BasketID;
	PPID   QCertID;
	DateRange GctPeriod; // PPViewGoodsRest::ViewGoodsOpGrouping()
};
//
// Descr: Структура, определяющая арранжировку штрихкодов с списке,
//   принадлежащем одному товару.
//
class BarcodeArrangeConfig {
public:
	SLAPI  BarcodeArrangeConfig();
	int    SLAPI Load();
	int    SLAPI Save();
	int    SLAPI IsLowPrior(const char * pBarcode) const;
private:
	enum {
		fDisableNonDigit = 0x0001 // Из списка штрихкодов удаляются те, что содержат нецифровые символы
	};
	char   LowPriorPrefix[10];
	int16  LowPriorLen;
	long   Flags;
};
//
// Descr: Команды сервера
//
#define PPSCMD_HELLO                 10001
#define PPSCMD_LOGIN                 10002
#define PPSCMD_LOGOUT                10003
#define PPSCMD_QUIT                  10004
#define PPSCMD_SPII                  10005
#define PPSCMD_STYLOBHT              10006
#define PPSCMD_GETBIZSCORES          10007 //
#define PPSCMD_STYLOBHTII            10008 //
#define PPSCMD_GETLASTERRMSG         10011 // Получить сообщение о последней ошибке
#define PPSCMD_SOBLK                 10019 // SELECT, SET, CREATE object //
#define PPSCMD_CHECKGLOBALCREDENTIAL 10020 // CheckGlobalCredential global_acc_name global_acc_password
#define PPSCMD_GETSERVERSTAT         10021 //
#define PPSCMD_STOPTHREAD            10022 // Остановить поток (PPJobSrvProtocol::StopThreadBlock)
#define PPSCMD_CREATEVIEW            10025 //
#define PPSCMD_DESTROYVIEW           10026 //
#define PPSCMD_HSH                   10027 // Handshake
#define PPSCMD_SUSPEND               10028 // SUSPEND переводит сеанс в режим ожидания и возвращает ИД сеанса
#define PPSCMD_RESUME                10029 // RESUME переключает работу на сеанс с которым до этого было приостановлена
	// работа (командой SUSPEND). Номером сеанса указывается параметром команды.
#define PPSCMD_CONFIG                10030 // CONFIG устанавливает конфигурационный параметр вказанный следующим за командой токеном.
#define PPSCMD_REFRESHVIEW           10031 // Требование серверу обновить содержимое PPView, идентификатор которого передается с командой.
#define PPSCMD_RFIDPRCSSR            10032
#define PPSCMD_GETTDDO               10033 // @v7.1.2 Извлечение текста по шаблону TDDO
#define PPSCMD_GETIMAGE              10034 // @v7.1.6 Извлечение изображения, связанного с объектом данных
#define PPSCMD_GETNEXTFILEPART       10035 // @v7.1.7 Получить очередную часть файла
#define PPSCMD_ACKFILE               10036 // @v7.1.7 Подтверждение приема файла клиентом
#define PPSCMD_CANCELFILE            10037 // @v7.1.7 Отмена приема файла клиентом
#define PPSCMD_EXECVIEWNF            10038 // @v7.1.8 Запуск отчета по именованному фильтру (EXECVIEW file_name [dl600_data_name])
#define PPSCMD_PREPAREPALMOUTDATA    10039 // @v7.1.x Подготовка данных для КПК на базе StyloAndroid
#define PPSCMD_PREPAREPALMINDATA     10040 // @v7.1.x Подготовка к приему данных с КПК на базе StyloAndroid
#define PPSCMD_GETFILE               10041 // @v7.1.x Получить файл с сервера
#define PPSCMD_PUTFILE               10042 // @v7.1.x Получить файл от клиента
#define PPSCMD_PUTNEXTFILEPART       10043 // @v7.1.x Получить файл следующую часть файла от клиента
#define PPSCMD_PROCESSPALMXMLDATA    10044 // @v7.1.x Обработать ранее полученные данные с КПК
#define PPSCMD_SETGLOBALUSER         10045 // @v7.2.4 Установить идентификатор текущего глобального аккаунта
#define PPSCMD_GETGLOBALUSER         10046 // @v7.2.4 Получить идентификатор текущего глобального аккаунта
#define PPSCMD_SETOBJECTTAG          10047 // @v7.2.4 Установить значение тега объекта
#define PPSCMD_GETOBJECTTAG          10048 // @v7.2.4 Получить значение тега объекта
#define PPSCMD_SETIMAGEMIME          10049 // @v7.2.12 Установка изображения, связанного с объектом данных
#define PPSCMD_SETIMAGE              10050 // @v7.3.0 Установка изображения, связанного с объектом данных (бинарный пакет)
#define PPSCMD_PING                  10051 // @v7.3.2 Тестовая команда, для проверки работоспособности сервера и клиента.
	// Может сопровождаться дополнительными параметрами при специфических тестах.
#define PPSCMD_GTACHECKIN            10052 // @v7.3.7 Регистрация тарифицируемой транзакции по глобальной учетной записи
#define PPSCMD_EXPTARIFFTA           10053 // @v7.3.7 Установить флаг - тарифицируемая транзакци
#define PPSCMD_SENDSMS               10054 // @v7.5.1 Отправка SMS
#define PPSCMD_POS_INIT              10055 //
#define PPSCMD_POS_RELEASE           10056 // CPOSRELEASE id
#define PPSCMD_POS_GETCCHECKLIST     10058 // CPOSGETCCHECKLIST
#define PPSCMD_POS_GETCCHECKLNCOUNT  10060 // CPOSGETCCHECKLNCOUNT
#define PPSCMD_POS_ADDCCHECKLINE     10061 // CPOSADDCCHECKLINE
#define PPSCMD_POS_RMVCCHECKLINE     10062 // CPOSRMVCCHECKLINE
#define PPSCMD_POS_CLEARCCHECK       10063 // CPOSCLEARCHECK
#define PPSCMD_POS_RMVCCHECK         10064 // CPOSRMVCCHECK
#define PPSCMD_POS_PRINTCCHECK       10065 // CPOSPRINTCHECK
#define PPSCMD_POS_GETCONFIG         10066 // CPOSGETCONFIG
#define PPSCMD_POS_SETCONFIG         10067 // CPOSSETCONFIG
#define PPSCMD_POS_GETSTATE          10068 // CPOSGETSTATE
#define PPSCMD_POS_SELECTCCHECK      10069 //
#define PPSCMD_POS_SUSPENDCCHECK     10070 //
#define PPSCMD_POS_SELECTCTABLE      10071
#define PPSCMD_POS_GETCPOSRIGHTS     10072
#define PPSCMD_POS_DECRYPTAUTHDATA   10074
#define PPSCMD_POS_GETGOODSPRICE     10075 // CPOSGETGOODSPRICE
#define PPSCMD_POS_PRINTCCHECKLOCAL  10076 // CPOSPRINTCHECKLOCAL
#define PPSCMD_POS_GETCURRENTSTATE   10077 // CPOSGETCURRENTSTATE
#define PPSCMD_POS_RESETCURRENTLINE  10078 // CPOSRESETCURRENTLINE
#define PPSCMD_POS_PROCESSBARCODE    10079 // CPOSPROCESSBARCODE
#define PPSCMD_POS_GETCTABLELIST     10080 // CPOSGETCTABLELIST
#define PPSCMD_POS_CPOSSETCCROWQUEUE 10081 // CPOSSETCCROWQUEUE
#define PPSCMD_POS_GETMODIFLIST      10082 // CPOSGETMODIFLIST goodsID

#define PPSCMD_RESETCACHE            10101 // RESETCACHE
#define PPSCMD_GETDISPLAYINFO        10102
#define PPSCMD_GETWORKBOOKCONTENT    10103
#define PPSCMD_SETTXTCMDTERM         10104 // @v8.1.0
#define PPSCMD_GETKEYWORDSEQ         10105 // @v8.2.9
#define PPSCMD_REGISTERSTYLO         10106 // @v8.7.1
#define PPSCMD_SETWORKBOOKCONTENT    10107 // @v8.7.7
#define PPSCMD_QUERYNATURALTOKEN     10108 // @v8.8.12
#define PPSCMD_GETARTICLEBYPERSON    10109 // @v8.9.0
#define PPSCMD_GETPERSONBYARTICLE    10110 // @v8.9.0

#define PPSCMD_TEST                  11000 // Сеанс тестирования //
//
//
//
class PPJobSrvProtocol : public SBuffer {
public:
	static const int16 CurrentProtocolVer;
	//
	// Descr: Типы данных, используемые в поле Header::Type (только для реплик,
	//   команды применяют поле Header::Type для идентификации собственно команды).
	//
	enum {
		htGeneric = 0,
		htGenericText,
		htStrAssocArray,
		htFile           // @v7.1.7 Файл (с предваряющим заголовком TransmitFileBlock)
	};
	//
	// Descr: Флаги заголовка реплики.
	//
	enum {
		hfAck      = 0x0001, // Простая реплика, подтверждающая обработку сервером
			// полученной команды.
		hfRepError = 0x0002, // Реплика сигнализирует об ошибке.
			// После инициализации чтения реплики функцией StartReading, если
			// реплика сигнализирует об ошибке, то возвращаемая функцией
			// структура заголовка будет содержать этот флаг.
		// @#{hfAck^hfRepError}
		hfInformer = 0x0004, // Реплика информирует клиента о ходе выолнения процесса.
			// Если тип данных равен htGenericText, то после заголовка следует
			// текстовая информация о ходе процесса.
		hfCmd      = 0x0008, // Пакет является командой (в противном случае - репликой)
		hfSlString = 0x0010, // Пакет представлен строкой, завершенной переводом каретки.
			// Это флаг соответствует неструктурированному пакету, по этому
			// в заголовке структурированного ответа не может быть такого типа.
			// Функция StartReading устанавливает в возвращаемой структуре заголовка
			// этот флаг, если засекает неструктурированный пакет (Header::Zero != 0).
		hfMore     = 0x0020  // Пакет не полностью передал данные. Требуется дополнительный
			// запрос на продолжение передачи. Пока этот флаг используется для передачи
			// больших файлов порциями.
	};

	struct Header {
		SString & FASTCALL ToStr(SString & rBuf) const;

		int16  Zero;        // Два нулевых байта, позволяющие отличить структурированную бинарную команду от текстовой
		int16  ProtocolVer; // Версия протокола. (1..)
		int32  DataLen;     // Полный размер пакета (включая заголовочную часть).
		int32  Type;        // Для команды: идент команды, для ответа: тип данных.
		int32  Flags;       // @flags
	};

	SLAPI  PPJobSrvProtocol();
	//
	// Descr: Идентифицирует тип ответа. Информация о типе заносится в
	//   блок PPJobSrvProtocol::H. Если ответ строковый и pRepString != 0,
	//   то копирует строку по этому указателю.
	//   Если ответ не строковый и pRepString != 0, то (*pRepString) = 0.
	//
	//   Если блок строковый, то при выходе из функции указатель
	//   чтения SBuffer::GetRdOffs находится в начале буфера.
	//   Если блок бинарный, то при выходе из функции указатель
	//   чтения SBuffer::GetRdOffs находится в позиции, следующей за заголовком.
	// Returns:
	//   1 - реплика бинарная.
	//   2 - реплика строковая.
	//   0 - ошибка.
	//
	int    FASTCALL StartReading(SString * pRepString);
	int    SLAPI Helper_Recv(TcpSocket & rSo, const char * pTerminal, size_t * pActualSize);
	const  Header & SLAPI GetH() const
	{
		return H;
	}
	SString & FASTCALL ToStr(SString & rBuf) const;
	int    SLAPI CheckRepError();

	struct StopThreadBlock {
		StopThreadBlock();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		ThreadID TId;
		MACAddr  MAddr;
		SString  HostName;
		SString  UserName;
	};
	//
	// Descr: Структура заголовка пакета передачи файла
	//
	struct TransmitFileBlock {
		SLAPI  TransmitFileBlock();
		//
		// Descr: Типы передачи файлов
		//
		enum {
			ttGeneric = 0,    // Общая //
			ttObjImage,       // Изображение объекта
			ttWorkbookContent // Содержание записи рабочей книги
		};

		int32  Cookie;         // @anchor Идентификатор, необходимый для продолжения скачивания файла.
		LDATETIME CrtTime;     // Время создания файла
		LDATETIME AccsTime;    // Время последнего доступа к файлу
		LDATETIME ModTime;     // Время последней модификации файла
		int64  Size;           // Полный размер файла
		int32  Format;         // SFileFormat::XXX
		int32  Flags;          // @flags @reserve
		uint32 PartSize;       // Размер части файла, передаваемой данным пакетом
		uint8  Hash[32];       // Hash-функция полного файла (возможно, пустая).
		int16  TransmType;     // Тип передачи
		int16  Reserve;        // @reserve
		int32  ObjType;        // Тип объекта
		int32  ObjID;          // Идентификатор объекта
		uint8  Reserve2[20];   // @reserve
		char   Name[256];      // Наименование файла (без пути - только имя с расширением)
	};
protected:
	int    SLAPI TestSpecToken(const char * pTok);

	enum {
		stStructured = 0x0001,
		stReading    = 0x0002
	};
	long   State;
	Header H; // Заголовок, считанный функцией StartReading
	SString ErrText;
	const char * P_TokAck;
	const char * P_TokErr;
};
//
// Descr: Представление бинарной команды сервера
//
class PPJobSrvCmd : public PPJobSrvProtocol {
public:
	SLAPI  PPJobSrvCmd();
	int    SLAPI StartWriting(int cmdId);
	int    SLAPI StartWriting(const char * pCmd);
	int    SLAPI FinishWriting();
};
//
// Descr: Класс, инкапсулирующий ответ JobServer'а (реплику).
//
class PPJobSrvReply : public PPJobSrvProtocol {
public:
	SLAPI  PPJobSrvReply(PPServerSession * pSess = 0);
	//
	// Функции записи
	//
	int    SLAPI StartWriting();
	int    SLAPI SetDataType(int dataType, const char * pDataTypeText);
	int    FASTCALL WriteString(const SString & rStr);
	int    SLAPI WriteFile(const char * pFileName);
	int    FASTCALL FinishWriting(int hdrFlags = 0);

	int    FASTCALL SetString(const char * pStr);
	int    FASTCALL SetString(const SString & rStr);
	int    FASTCALL SetInformer(const char * pMsg);
	//
	// Descr: Устанавливает реплику в состояние ошибки.
	//
	int    SLAPI SetError();
	//
	// Descr: Устанавливает реплику с состояние подтверждения усешного выполнения операции.
	//
	int    SLAPI SetAck();
	//
	// Descr: Специальная функция, посылающая клиенту информационное
	//   сообщение о ходе процесса. Сообщение посылается посредством
	//   приватного члена P_Sess (если P_Sess != 0).
	//
	int    FASTCALL SendInformer(const char * pMsg);
private:
	int32  DataType;
	SString DataTypeText;
	PPServerSession * P_Sess; // @notowned
};

class PPJobSrvClient {
public:
	enum {
		stConnected = 0x0001,
		stLoggedIn  = 0x0002,
		stLockExec  = 0x0004, // Сигнализирует от том, что Exec запущен. Необходим
			// для предотвращения параллельного вызова по cmIdle
		stDebugMode = 0x0008  // @v8.3.4 Клиент находится в отладочном режиме (вывод дополнительной информации в журнал)
	};

	SLAPI  PPJobSrvClient();
	SLAPI ~PPJobSrvClient();
	long   SLAPI GetState() const
	{
		return State;
	}
	int    SLAPI Connect(const char * pAddr, int port);
	int    SLAPI Disconnect();
	int    SLAPI Reconnect(const char * pAddr, int port);
	int    SLAPI Exec(const char * pCmd, PPJobSrvReply & rReply);
	int    SLAPI Exec(const char * pCmd, const char * pTerminal, PPJobSrvReply & rReply);
	int    SLAPI Exec(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	int    SLAPI Exec(PPJobSrvCmd & rCmd, const char * pTerminal, PPJobSrvReply & rReply);
	int    SLAPI Login(const char * pDbSymb, const char * pUserName, const char * pPassword);
	int    SLAPI Logout();
	int    SLAPI GetLastErr(SString & rBuf);

	int    SLAPI SetInformerProc(int (*proc)(const char * pMsg, void * pParam), void * pParam);
	//
	// Descr: Отсылает серверу запрос на подтверждение соединения по таймеру.
	// Returns:
	//   <0 - не наступило время отсылки сообщения //
	//   >0 - сообщение отослано и получено подтверждение.
	//   0  - не удалось получить подтверждение наличия соединения.
	//
	int    FASTCALL Sync(int force = 0);
	//
	// Descr: Тестовая функция, разрывающая соединение с сервером.
	//
	int    SLAPI TestBreakConnection();
private:
	long   SessId;
	long   State;
	TcpSocket So;
	SString InitAddr;
	int    InitPort;
	SString AuthCookie;
	SString TempBuf; // @allocreuse
	SString DebugLogFileName;
	SBuffer Reply;
	SCycleTimer SyncTimer; // Таймер, по котрому серверу
		// отсылаются запросы на подтверждение соединения.
	SMtLock ExecLock; // @v8.3.4 Блокировка для гарантированной сериализации
		// обращений к серверу.
	int    (*InformerCallbackProc)(const char * pMsg, void * pParam);
	void * P_InformerCallbackParam;
};
//
//
//
class PPUhttClient {
public:
	static int SLAPI TestUi_GetLocationListByPhone();
	static int SLAPI TestUi_GetQuotByLoc();

	SLAPI  PPUhttClient();
	SLAPI ~PPUhttClient();
	int    SLAPI HasAccount() const;
	int    SLAPI IsAuth() const;
	int    SLAPI PreprocessResult(const void * pResult, const PPSoapClientSession & rSess);
	int    SLAPI Auth();
	int    SLAPI Unauth();
	//
	// Application methods
	//
	int    SLAPI GetPersonByID(int id, UhttPersonPacket & rResult);
	int    SLAPI GetPersonByName(const char * pName, TSCollection <UhttPersonPacket> & rResult);

	int    SLAPI GetBrandByName(const char * pName, TSCollection <UhttBrandPacket> & rResult);
	int    SLAPI GetGoodsByCode(const char * pCode, TSCollection <UhttGoodsPacket> & rResult);
	int    SLAPI GetGoodsByName(const char * pName, TSCollection <UhttGoodsPacket> & rResult);
	int    SLAPI GetGoodsByID(int id, UhttGoodsPacket & rResult);
	int    SLAPI GetUhttGoodsRefList(LAssocArray & rList, StrAssocArray * pByCodeList);
	//
	// Descr: Разрешает идентификатор товара в Universe-HTT uhttID относительно текущей базы данных.
	//
	int    SLAPI ResolveGoodsByUhttID(int uhttID, UhttGoodsPacket * pUhttResult, PPID * pGoodsID, SString * pCode);
	int    SLAPI GetUhttGoods(PPID goodsID, long flags, int * pUhttID, UhttGoodsPacket * pUhttResult);
	int    SLAPI GetUhttGoodsList(PPID goodsID, long flags, TSCollection <UhttGoodsPacket> & rResult);
	int    SLAPI GetLocationByID(int id, UhttLocationPacket & rPack);
	int    SLAPI GetLocationByCode(const char * pCode, UhttLocationPacket & rPack);
	int    SLAPI GetLocationListByPhone(const char * pPhone, TSCollection <UhttLocationPacket> & rResult);
	int    SLAPI CreateStandaloneLocation(long * pID, const UhttLocationPacket & rPack);
	int    SLAPI CreateGoods(long * pID, const UhttGoodsPacket & rPack);
	int    SLAPI GetGoodsArCode(const char * pBarcode, const char * pPersonINN, SString & rArCode);
	int    SLAPI GetGoodsRestList(int uhttGoodsID, TSCollection <UhttGoodsRestListItem> & rResult);
	int    SLAPI SetObjImage(const char * pObjTypeSymb, PPID uhttObjID, const char * pFileName);
	int    SLAPI GetSpecSeriesByPeriod(const char * pPeriod, TSCollection <UhttSpecSeriesPacket> & rResult);
	int    SLAPI CreateSpecSeries(long * pID, const UhttSpecSeriesPacket & rPack);
	int    SLAPI GetSCardByNumber(const char * pPeriodNumber, UhttSCardPacket & rResult);
	int    SLAPI CreateSCardCheck(const char * pLocSymb, const char * pSCardNumber, const UhttCheckPacket & rPack);
	int    SLAPI CreateBill(UhttBillPacket & rPack);
	int    SLAPI GetBill(const UhttBillFilter & rFilt, TSCollection <UhttBillPacket> & rResult);
	int    SLAPI GetQuot(const UhttQuotFilter & rFilt, TSCollection <UhttQuotPacket> & rResult);
	int    SLAPI SetQuot(const UhttQuotPacket & rPack);
	int    SLAPI SetQuotList(const TSCollection <UhttQuotPacket> & rList, TSCollection <UhttStatus> & rResult);
	int    SLAPI DepositSCardAmount(const char * pNumber, const double amount);
	int    SLAPI WithdrawSCardAmount(const char * pNumber, const double amount);
	int    SLAPI GetSCardRest(const char * pNumber, const char * pDate, double & rRest);
	int    SLAPI FileVersionAdd(const char * pFileName, const char * pKey,
		const char * pVersionLabel, const char * pVersionMemo, SCopyFileProgressProc pp, void * pExtra);
	int    SLAPI GetVersionList(const char * pKey, TSCollection <UhttDCFileVersionInfo> & rResult, SVerT * pMinVer);
	int    SLAPI SendSms(const TSCollection <UhttSmsPacket> & rList, TSCollection <UhttStatus> & rResult);

	int    SLAPI GetWorkbookItemByID(int id, UhttWorkbookItemPacket & rPack);
	int    SLAPI GetWorkbookItemByCode(const char * pCode, UhttWorkbookItemPacket & rPack);
	int    SLAPI GetWorkbookListByParentCode(const char * pParentCode, TSCollection <UhttWorkbookItemPacket> & rResult);
	int    SLAPI GetWorkbookContentByID_ToFile(int id, const char * pFileName);
	int    SLAPI CreateWorkbookItem(long * pID, const UhttWorkbookItemPacket & rPack);
	int    SLAPI SetWorkbookContentByID(int id, const char * pFileName);
	//int    SLAPI SetObjImage(const char * pObjTypeSymb, PPID uhttObjID, const char * pFileName);

	int    SLAPI GetStyloDeviceByID(int id, UhttStyloDevicePacket & rPack);
	int    SLAPI GetStyloDeviceByCode(const char * pCode, UhttStyloDevicePacket & rPack);
	int    SLAPI CreateStyloDevice(long * pID, const UhttStyloDevicePacket & rPack);

	int    SLAPI GetProcessorByID(long id, UhttProcessorPacket & rPack);
	int    SLAPI GetProcessorByCode(const char * pCode, UhttProcessorPacket & rPack);
	int    SLAPI CreateProcessor(long * pID, const UhttProcessorPacket & rPack);

	int    SLAPI GetTSessionByID(long id, UhttTSessionPacket & rPack);
	int    SLAPI GetTSessionByUUID(const S_GUID & rUuid, UhttTSessionPacket & rPack);
	int    SLAPI GetTSessionByPrc(long prcID, const LDATETIME & rSince, TSCollection <UhttTSessionPacket> & rResult);
	int    SLAPI CreateTSession(long * pID, const UhttTSessionPacket & rPack);

	static int SLAPI ViewNewVerList(int showSelDlg);
	//
	//
	//
	int    SLAPI ConvertLocationPacket(const UhttLocationPacket & rUhttPack, LocationTbl::Rec & rLocRec) const;
	int    SLAPI ConvertPersonPacket(const UhttPersonPacket & rUhttPack, PPID kindID, PPPersonPacket & rPsnPack) const;
	const SString & SLAPI GetLastMessage() const
	{
		return LastMsg;
	}
	const SString & SLAPI GetUrlBase() const
	{
		return UrlBase;
	}
private:
	int    SLAPI StartTransferData(const char * pName, int64 totalRawSize, int32 chunkCount, int * pTransferID);
	int    SLAPI TransferData(int transferID, int chunkNumber, size_t rawChunkSize, const void * pBinaryChunkData);
	int    SLAPI FinishTransferData(int transferID);
	void   FASTCALL DestroyResult(void ** ppResult);

	enum {
		stAuth       = 0x0001,
		stHasAccount = 0x0002
	};
	long   State;
	SString Urn;
	SString UrlBase;
	SString Token;
	SString LastMsg;

	SDynLibrary * P_Lib;
	void * P_DestroyFunc;
};
//
//
//
struct PPAdviseEvent {
	PPAdviseEvent & FASTCALL operator = (const SysJournalTbl::Rec & rSjRec);

	class ExtObject {
	public:
		virtual ~ExtObject()
		{
		}
	};
	int64  Ident;
    LDATETIME Dtm;
    int32  Action;
    PPObjID Oid;
    int32  UserID;
    int32  SjExtra;
    long   Flags;
    ExtObject * ExtraObj; // @notowned
};
//
// Descr: Реализует очередь системных событий, заполняемую в отдельном потоке.
//   Поток-источник пишет новые события в очередь методом Push который блокирует
//   очередь с ожиданием. То есть, если кто-то читает очередь, то потор ждет
//   окончания чтения.
//
//   Реципиенты же, наоборот, забирают данные из очередь только после успешной блокировки
//   без ожидания - с целью избежать задерки.
//
class PPAdviseEventQueue : private TSArray <PPAdviseEvent> {
public:
	SLAPI  PPAdviseEventQueue();
    int    FASTCALL Push(const TSArray <PPAdviseEvent> & rList);
	uint   GetCount();
	int    Get(int64 lowIdent, TSArray <PPAdviseEvent> & rList);
	//int64  Marker(int64 _newMarker);
	int    Purge();

	class Client {
	public:
		friend class PPSession;

		~Client();
		int   IsConsistent() const;
		int64 GetMarker() const;
		int   Register(long dbPathID, PPAdviseEventQueue * pQueue);
	protected:
        Client();

		uint32 Sign;
		int64  Marker;
		TSArray <PPAdviseEvent> EvqList;
		LongArray RegDbList; // Список идентификаторов путей баз данных, в чьих очередях
			// клиент зарегистрирован. Необходим для ускорения процесса регистрации.
	};
	struct Stat {
		Stat();
        int64  LivingTime;       // Время жизни очереди (ms)
        int64  StartClock;       // Стартовое значение Clock() для отмеривания времени жизни очереди
        uint32 Push_Count;       // Количество запросов Push
        uint32 Get_Count;        // Количество запросов Get
        uint32 GetDecline_Count; // Количество отклоненных запросов Get по причине блокировки
        uint32 MaxLength;        // Максимальная длина очереди
	};

	int    FASTCALL RegisterClient(const Client * pCli);
	int    SLAPI   GetStat(Stat & rStat);
private:
	int64  LastIdent;
	Stat   S;
	SMtLock SLck; // Критическая секция для блока статистики S
	ReadWriteLock Lck;
	SMtLock ClLck; // Критическая секция для списка клиентов
	SCollection CliList; // Список указателей на клиентов очереди (без владения объектами)
		// Необходим для определения маркера, ниже которого записи очереди уже не нужны.
};
//
// Descr: Класс, обеспечивающий хранение глобальных данных, привязанных к потоку.
//
class PPThreadLocalArea {
public:
	friend class PPSession;
	SLAPI  PPThreadLocalArea();
	SLAPI ~PPThreadLocalArea();
	void * FASTCALL GetPtr(uint idx/*, int inc = 1*/) const;
	void * FASTCALL GetPtrNonIncrement(uint idx) const;
	int    SLAPI CreatePtr(uint idx, void *);
	int    FASTCALL ReleasePtr(uint idx);
	void   SLAPI PushErrContext();
	void   SLAPI PopErrContext();
	int    SLAPI IsConsistent() const;
	long   SLAPI GetId() const;
	//
	// Descr: Возвращает !0 если поток авторизован в базе данных Papyrus
	//
	int    SLAPI IsAuth() const;
	ThreadID SLAPI GetThreadID() const;

	PPView * SLAPI GetPPViewPtr(int32 id) const;
	int32  SLAPI CreatePPViewPtr(PPView *);
	int    SLAPI ReleasePPViewPtr(int32 id);
	//
	// Descr: До версии 8.6.1 некоторые атрибуты, связанные с текущим значением главной
	//   организации инициализировались при открытии сессии (PPSession::Login).
	//   Однако, выяснилось, что это - достаточно тяжелая операция. В связи с этим
	//   теперь инициализация указанных атрибутов выполняется при необходимости после
	//   чего в поле PPThreadLocalArea::State устанавливается флаг stMainOrgInit.
	//   Наличие этого флага означает, что все атрибуты правильно инициализированы,
	//   отсутствие - надо инициализировать.
	//   Функция InitMainOrgData, если reset == 0 проверяет установку флага stMainOrgInit
	//   и, если он не стоит, инициализирует атрибуты. Если флаг установлен, то ничего
	//   не делает.
	//   Если аргумент reset != 0, то функция сбрасывает флаг stMainOrgInit (это может
	//   быть необходимо, например, при изменении главной организации).
	//
    int    SLAPI InitMainOrgData(int reset);
    //
    //
    //
    int    SLAPI SetIfcConfigParam(const char * pParam, const char * pValue);
    int    SLAPI GetIfcConfigParam(const char * pParam, SString & rValue) const;
    //
    SrDatabase * SLAPI GetSrDatabase();
private:
	int    SLAPI RegisterAdviseObjects();
	void   SLAPI OnLogout();

	struct PtrEntry {
		void * Ptr;
		int    RefCounter;
		int    InUse;
	};
	struct ErrContext {
		int    Err;
		int    CrwErr;
		int    BtrErr;
		int    SlErr;
		PPObjID LastErrObj;
		SString AddedMsgString;
		SString DbFileName;
	};
	struct PrivateCart {
	public:
		PrivateCart();
		~PrivateCart();
		int    operator !() const;
		int    Is(PPID basketID) const;
		int    Set(const PPBasketPacket * pPack, int use_ta);
		PPBasketPacket * Get();
	private:
		PPBasketCombine * P;
	};
	int    Sign;           // Если Sign == SIGN_PPTLA, то данный объект является валидным (в частности, не разрушен деструктором)
	long   Id;             // @id
	ThreadID TId;          // Идентификатор потока
	uint   PtrVectDim;
	PtrEntry * P_PtrVect;
	ErrContext * P_ErrCtx;
	PPThread * P_AeqThrd;
	SrDatabase * P_SrDb; // @v9.7.11
public:
	class WaitBlock {
	public:
		SLAPI  WaitBlock();
		SLAPI ~WaitBlock();
		int    IsValid() const;
		HWND   GetWindowHandle() const;
		int    SLAPI Start();
		int    SLAPI Stop();
		int    SLAPI Hide();
		int    SLAPI Show();
		int    FASTCALL SetMessage(const char *);
		int    FASTCALL SetPercent(ulong p, ulong t, const char * msg);
	private:
		enum {
			stValid = 0x0001,
			stHide  = 0x0002,
		};
		long   State;
		HWND   hwndPB;  // Progress Bar
		HWND   hwndST;  // Static Text
		HWND   WaitDlg;
		HCURSOR WaitCur;
		HCURSOR OrgCur;
		TView * PrevView;
		ulong  PrevPercent;
		SString Text;
		SString PrevMsg;
		SCycleTimer IdleTimer;
	};
	int    LastErr;        // Last error code //
	int    LastCrwErr;     // Last Crystal Report Error Code
	PPConfig     Lc;       // Текущая локальная конфигурация //
	PPCommConfig Cc;       // Текущая общая конфигурация     //
	//
	// Следующие три поля извлекаются из общих условий соглашений с поставщиками
	// PPObjArticle::GetSupplAgreement(0, PPSupplAgreement *)
	//
	PPID   SupplDealQuotKindID;  // Вид котировки, определяющий контрактные цены поставщиков
	PPID   SupplDevUpQuotKindID; // Вид котировки, определяющий верхние отклонения от контрактных цен поставщиков
	PPID   SupplDevDnQuotKindID; // Вид котировки, определяющий нижние отклонения от контрактных цен поставщиков
	int16  InvalidSupplDealQuotAction; // действие при неверной контрактной цене
	int16  Reserve;              // @alignment
	PPID   GlobAccID;            // @v7.2.3 Текущий ИД глобальной учетной записи
	PPID   AgentAccSheetID;      // @v8.7.2 0 - не инициализирован, -1 - не удалось идентифицировать, >0 - валидное значение
	//
	// Descr: Флаги состояния State
	//
	enum {
		stExpTariffTa = 0x0001,
		stMainOrgInit = 0x0002,
		stAuth        = 0x0004  // @v8.6.11 Поток авторизован в базе данных Papyrus
	};
	int    State;                // @Muxa @v7.3.8 Флаги
	SysJournal * P_SysJ;
	ObjSyncCore * P_ObjSync;     // Откроем таблицу при входе в сеанс что бы не приходилось
		// ее открывать при каждом удалении объекта (в транзакции)
	GtaJournalCore * P_GtaJ;     // @v7.3.8
	Reference  * P_Ref;
	PPObjBill  * P_BObj;
	// @v8.3.6 Следущие два экземпляру инициализируются нулями и используются только в специальных случаях
	// (на текущий момент - для генерации последовательностей) {
	PPObjWorld * P_WObj;
	PPObjWorkbook * P_WbObj;
	// }
	PPObjPrjTask * P_TodoObj;    // @v8.5.11
	PPObjID  LastErrObj;         // Object's ID, by last generated error
	PPLastInputData Lid;
	int    PrnDirId;
	SCodepageIdent DL600XmlCp;   // @v9.4.6 Кодовая страница для стандартного экспорта DL600 в XML
	DlContext * P_ExpCtx;        // Контекст экспортных структур данных
	DlContext * P_IfcCtx;        // Контекст COM-интерфейсов
	//
	// Далее идут поля, типы данных которых имеют конструкторы
	//
	PPRights Rights;             // @anchor Rights for object's access
	ACount  RightsUpdateCounter; // Счетчки, предписывающий обновить права доступа экземплярам объектов.
		// Необходим для уведомления экземпляров PPObject о том, что флаги доступа были изменены посредством
		// включения или отключения PPObjSecur::Exclusion
	PPPaths Paths;               // Текущие пути доступа к файлам  //
	SString PrintDevice;         //
	SString UserName;            // @*PPSession::Login @.Имя текущего пользователя //
	SString GlobAccName;         // @Muxa @v7.3.8 Имя глобальной учетной записи
	SString AddedMsgString;
	SString AddedMsgStrNoRights; // Дополнительная строка контекста сообщения PPERR_NORIGHTS
	SString TempLogFile;         // Имя временного файла журнала, в котором дублируются все записи в журналы.
		// Используется для формирования файла отчета, который будет отправлен администратору по e-mail
	SString DL600XMLEntityParam; // Строка ограничения трансляции символов строк в сущности XML при экспорте в XML
	SStringTag SCardPatterns;    // Образцы разбора номеров дисконтных карт.
		// Загружаются из файла конфигурации pp.ini ([config] SCardPatterns).
		// Если SCardPatterns.Id != 0, то строка не загружена из конфигурации.
	//
	// Текущие наименования главной организации и раздела БД.
	// Используются для быстрого обновления строки статуса.
	//
	SStringTag MainOrgName;
	SString MainOrgCountryCode; // @v9.7.8 Код страны главной организации. Используется для идентификации собственной страны в адресах
	SStringTag CurDbDivName;
	BarcodeArrangeConfig Bac;
	SurKeyArray    SurIdList;    // Массив динамически идентифицируемых записей, используемых
		// для параметризации структур DL600, не имеющих естественного идентификатора (например SysJournalEntry).
	PPSync Sync;                 // Синхронизатор сетевых пользователей
	PPJobSrvClient SrvSess;      // Сессия связи с JobServer
	WaitBlock WD;
	Profile Prf;                 // @v8.0.3 Локальный по отношению к потоку профайлер
	PPUserFuncProfiler UfpSess;  // @v8.0.6 Точка профилирования длительности жизни потока (от Login до Logout)
private:
	PrivateCart Cart;            // Персональная корзина пользователя //

	class IdleCommand : public SCycleTimer {
	public:
		IdleCommand(long repeatEachSeconds);
		virtual ~IdleCommand();
		virtual int FASTCALL Run(const LDATETIME & rPrevRunTime);
	};
	TSCollection <IdleCommand> IdleCmdList;
	TSCollection <PPView> SrvViewList;
	StrStrAssocArray IfcConfig; // Параметры конфигурации интерфейсов.
		// Устанавливаются вызовом PPUtil::SetConfigParam
};

class __PPThrLocPtr {
public:
	SLAPI  __PPThrLocPtr();
	int    SLAPI IsOpened();
protected:
	void * FASTCALL Helper_Open(SClassWrapper &);
	void   FASTCALL Helper_Close(SClassWrapper &, void * ptr);
	uint   Idx;
};

template <class T> class PPThrLocPtr : public __PPThrLocPtr {
public:
	SLAPI  PPThrLocPtr() : __PPThrLocPtr() {}
	T *    SLAPI Open() { return (T *)Helper_Open(Cw); }
	void   SLAPI Close(T * p) { Helper_Close(Cw, p); }
	TSClassWrapper <T> Cw;
};

#define TLP(M)            __##M
#define TLP_MEMB(T,M)     static PPThrLocPtr<T> __##M; T * M
#define TLP_IMPL(C,T,M)   PPThrLocPtr <T> C::__##M
#define TLP_OPEN(M)       M=__##M.Open()
#define TLP_CLOSE(M)      __##M.Close(M)
//
//
//
struct PPNotifyEvent {
	SLAPI  PPNotifyEvent();
	void   SLAPI Clear();
	PPNotifyEvent & SLAPI SetFinishTag();
	int    SLAPI IsFinish() const;

	long   Action;
	PPID   ObjType;
	PPID   ObjID;
	long   ExtInt_;
	LDATETIME ExtDtm;
	SString ExtStr;
};
//
// Descr: callback-функция, вызываемая в ответ на событие.
//
typedef int (*PPAdviseProc)(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
//
// Descr: Блок установки требования на оповещение о событии
//
struct PPAdviseBlock {
	SLAPI  PPAdviseBlock();

	enum {
		evDirtyCacheBySysJ = 1, // Оповещать о событии в системном журнале в функции сбора событий
			                    // для установки "грязных" элементов кэша.
		evPPObjMsg,             // Оповещать о сообщении, инициированном для объектов PPObject
		evTodoChanged,          // Оповещать об изменении задач
		evBillChanged,          // Оповещать об изменении документов
		evSysJournalChanged,    // Оповещать об изменении в системном журнале
		evLogsChanged,          // Оповещать о изменениях выбранных журналов
		evBizScoreChanged,      // Оповещать об изменениях бизнес-показателей
		evWaitMsg,              // Оповещать о вызове PPWaitMsg или PPWaitPercent
		evQuartz,               // Оповещать через секундные интервалы
		evTSessChanged,         // Оповещать об изменениях технологических сессий
		evPsnEvChanged          // @v8.0.3  Оповещать об изменениях персональных операций
	};
	long   Cookie;     // for internal use
	int    Kind;       // PPAdivseBlock::evXXX Тип извещения, для которого сформирован этот блок.
	ThreadID TId;      // Если !0, то сообщения передаются только потоку с этим ИД.
	long   DbPathID;   // Если !0, то сообщения передаются только потокам, авторизованным в базе данных с этим ИД.
	long   Action;     // Событие, о котором необходимо провести оповещение. Зависит от Kind:
		// Если Kind==evDirtyCacheBySysJ, то Action = ACN_XXX, если Kind==evPPObjMsg, то Action = DBMSG_XXX
	PPID   ObjType;    // Тип объекта PPObject, которому соответствует событие Action
	long   Flags;
	// @v8.5.3 long   ProcExtVal; // Значение, передаваемое функции Proc при извещении о возникновении события //
	void * ProcExtPtr; // @v8.5.3 Значение, передаваемое функции Proc при извещении о возникновении события //
	PPAdviseProc Proc; // Процедура, которая должна быть вызвана в ответ на событие Action с типом объекта ObjType.
};

class PPAdviseList : private SArray {
public:
	friend class PPSession;

	SLAPI  PPAdviseList();
	//
	// Descr: Перебирает элементы списка.
	// Attention: Этот метод не-блокируемый. Его можно использовать
	//   только на локальной по отношению к потоку копии списка.
	//
	int    FASTCALL Enum(uint * pI, PPAdviseBlock *) const;
	uint   GetCount(); // @sync_wr
private:
	int    Advise(long *, const PPAdviseBlock *); // @sync_wr
	int    CreateList(int kind, ThreadID tId, long dbPathID, PPID objType, PPAdviseList & rList); // @sync_wr
	long   LastCookie; // Последний использованный идентификатор для AdviseList
	ReadWriteLock RwL;
};
//
//
//
struct ObjCacheEntry { // size=16
	//
	// Attention: Классы, порожденные от ObjCache могут использовать поле F
	//   для собственных флагов.
	//
	enum {
		fDirty = 0x0001,
		fUndef = 0x0002
	};
	PPID   ID;
	uint   NameIdx;
	uint16 F;       // Флаги ObjCacheEntry::fXXX
	uint16 __PadF;  // @alignment Ради быстродействия теряем два байта на каждом элементе
	ACount Counter; // Счетчик обращений к этому элементу
};

struct ObjCacheStat {
	int    SLAPI Init();

	long   DbPathID;
	long   ObjType;
	long   Hits;          // Количество попаданий
	long   Misses;        // Количество промахов
	long   Count;         // Количество обращений
	long   Collisions;    // Количество коллизий при нахождении слота (для ObjCacheHash)
	long   NumEntries;    // Общее количество слотов в хранилище кэша
	long   UnusedEntries; // Количество неиспользуемых слотов (для ObjCacheHash)
	long   DirtyEntries;  // Количество "грязных" элементов
	long   MaxCounter;    // Максимальный счетчик
	long   MinCounter;    // Минимальный счетчик
	SString DbPath;
	SString ObjTypeName;
};

class ObjCache {
public:
	enum {
		fOwnerArray   = 0x0001, // Порожденный кэш самостоятельно инициализирует массив P_Ary
		fUseUndefList = 0x0002  // Кэш поддерживат список неопределенных идентификаторов.
			// Если флаг установлен, и функция FetchEntry возвращает -100, то считается, что
			// заданный идентификатор не определен и должен быть вставлен в список неопределеннх
			// идентификаторов. При извлечении в дальнейшем элемента с таким идентификатором
			// функция ObjCache::Get возвращает указатель на ObjCacheEntry с полем ID равным
			// запрошенному идентификатору, полем F с флагом ObjCacheEntry::fUndef.
			// Остальные поля при этом могут иметь непредсказуемые значения.
	};
	SLAPI  ObjCache(PPID objType, size_t entrySize, long flags = 0);
	virtual SLAPI ~ObjCache();
	virtual int    SLAPI Get(PPID, void * pDataRec, long extraData = 0); // @sync_wr
	//
	// Desr: Помечает элемент с идентификатором id как недостоверный ("грязный")
	// Returns:
	//   >0 - элемент с идентификатором id найден и помечен
	//   <0 - элемент с идентификатором id не найден
	//   0  - ошибка
	//
	virtual int  SLAPI Dirty(PPID id); // @sync_w
	//
	// Descr: Должна возвратить количество элементов в хранилице.
	//   Внутренние методы класса полагаются на эту функцию при определении валидности
	//   индекса элемента.
	//
	virtual uint SLAPI GetCount() const;
	//
	// Descr: Ищет в кэше запись по ключу pKey с помощью функции f.
	//   Если такая запись найдена, то возвращает ее по указателю pDataRec.
	//   Если запись не найдена, то возвращает управление вызывающей функции.
	//   В отличии от ObjCache::Get эта функция не пытается самостоятельно
	//   занести требуемую запись в кэш (для этого просто нет механизма).
	//   То есть вызывающая функция должна самостоятельно извлечь не найденную
	//   в кэше запись из базы данных.
	// Perf: Поиск осуществляется линейно (SArray::lsearch). По этому для классов //
	//   со значительным количеством записей эта функция может оказаться медленней,
	//   чем какой-либо иной механизм.
	//
	int    SLAPI GetBySrchFunc(const void * pKey, CompFunc f, void * pDataRec); // @sync_r
	PPID   SLAPI GetObjType() const;
	size_t SLAPI GetEntrySize() const;
	int    SLAPI GetStat(ObjCacheStat *);
protected:
	//
	// Descr: Эта функция должна заполнить буфер pEntry значениями, взятыми из базы данных.
	//   Функция вызывается в том случае, когда кэш не содержит элемента, соответствующего
	//   идентификатору id или этот элемент необходимо обновить.
	// ARG(id         IN): идентификатор объекта, информацию о котором необходимо извлечь из БД
	// ARG(pEntry    OUT): указатель на буфер размером ObjCache::EntrySize, который должен быть
	//   заполнен полями, соответствующими объекту с идентификатором id. Вызывающая функция //
	//   обязательно распределяет пространство под этот указатель и заполняет его нулями.
	// ARG(extraParam IN): произвольное значение, переданное в функцию ObjCache::Get.
	// Returns:
	//   >0 - буфер pEntry успешно заполнен
	//   <0 - функция не выполнила контракт по "уважительным причинам" (например, объект
	//        с идентификатором id не существует.
	//   0  - ошибка
	//
	virtual int  SLAPI FetchEntry(PPID id, ObjCacheEntry * pEntry, long extraData = 0) = 0;
	virtual void SLAPI EntryToData(const ObjCacheEntry * pEntry, void * pDataRec) const = 0;
	//
	// Descr: Эта функция должна найти элемент с идентификатором id и вернуть его позицию
	//   в хранилище. Если элемент не найден, то функция должна присвоить по указателю
	//   pPos значение UNDEFPOS.
	// Returns:
	//   >0 - элемент с идентификатором id найден и не имеет признака ObjCacheEntry::fDirty
	//        по указателю pPos возвращается номер позиции, в которой находится элемент
	//   0  - элемент с идентификатором id не найден. По указателю pPos возвращается //
	//        значение UNDEFPOS
	//
	virtual int FASTCALL Search(PPID id, uint * pPos) const;
	//
	// Descr: Должна получить указатель на элемент кэша с индексом pos.
	//   Если incr != 0, то после извлечения элемента обязана уведичить счетчик обращений к нему.
	//
	virtual ObjCacheEntry * FASTCALL SearchByPos(uint pos, int incr) const; // @<<ObjCache::Helper_GetByPos
	//
	// Descr: Все, что должна сделать эта функция - вставить новый элемент в хранилище
	//   и по адресу pPos вернуть позицию в которой оказался новый элемент. Больше ничего
	//   делать не следует. Все операции по синхронизации выполняют вызывающие функции.
	// ARG(pEntry     IN): адрес, по которому находится буфкр данных для вставки
	// ARG(pPos   IN/OUT): адрес позиции, по которой следует добавить запись. Если
	//   *pPos == UNDEFPOS,  то добавляется новая запись, если
	//   *pPos != UNDEFPOS && *pPos < GetCount() то функция должна обновить запись в
	//   позиции *pPos.
	// Returns:
	//   >0 - элемент pEntry успешно добавлен в хранилище, по указателю pPos содержится //
	//        позиция, в которой находится этот элемент.
	//   0  - ошибка. В этом случае вызывающая функция не пытается интерпретировать значение
	//        по указателю pPos.
	//
	virtual int SLAPI AddItem(const ObjCacheEntry * pEntry, uint * pPos);
	int    FASTCALL PutName(const char * pName, ObjCacheEntry *);              // @<<(X:ObjCache)::FetchEntry
	int    FASTCALL GetName(const ObjCacheEntry *, char * buf, size_t buflen) const; // @<<(X:ObjCache)::EntryToData
	//
	// Descr: реализация удаления элемента кэша с идентификатором id.
	//   Если порожденный класс самостоятельно реализует
	//   функцию Dirty, то для наследования родительской реализации следует использовать
	//   Helper_Dirty, а не Remove, поскольку критическая секция должна охватывать всю
	//   реализацию Dirty.
	//
	int    FASTCALL Helper_Dirty(PPID id); // @<<ObjCache::Remove, @>>ObjCache::Helper_RemoveByPos

	class MultTextBlock {
	public:
		friend class ObjCache;

		MultTextBlock();
		MultTextBlock(const ObjCache * pCache, const ObjCacheEntry * pEntry);
		int    FASTCALL Add(const char *);
		int    FASTCALL Get(char * pBuf, size_t bufLen);
		int    FASTCALL Get(SString & rBuf);
	private:
		int    RdMode;
		uint   CurPos;
		StringSet Ss;
	};

	int    FASTCALL PutTextBlock(MultTextBlock & rBlk, ObjCacheEntry * pEntry);

	struct ExtTextBlock {
		void   FASTCALL Dirty(PPID id);
		int    SLAPI Fetch(PPID id, SString & rBuf, void * extraPtr);
		virtual int SLAPI Implement_Get(PPID id, SString & rBuf, void * extraPtr);

		UintHashTable MissingList; // Список идентификаторов, для которых нет текста
		StrAssocArray List;
		ReadWriteLock Lock;  // Блокировка списка ExtMemoList
	};

	StringSet Ss;
	//SMtLock L;
	ReadWriteLock RwL; // Блокировка "Один писатель - много читателей"
	//
	// Descr: Специализированный подкласс, реализующий кэширование объектов, хранящихся в
	//   Reference по символам.
	//
	class RefSymbArray : public StrAssocArray {
	public:
		RefSymbArray(PPID objType);
		void   FASTCALL Dirty(PPID id); // @sync_w
		int    SLAPI FetchBySymb(const char * pSymb, PPID * pID);
	private:
		PPID   ObjType;
		int    Inited;
		PPIDArray DirtyTable;

		ReadWriteLock SlLock;
	};
protected:
	struct Stat {
		ACount Hits;
		ACount Misses;
		ACount Count;
		ACount Collisions;    // Количество коллизий при нахождении слота (для ObjCacheHash)
		long   UnusedEntries; // Количество неиспользуемых слотов (для ObjCacheHash)
		long   MaxCounter;    // Максимальный счетчик
		long   MinCounter;    // Минимальный счетчик
	};
	int    SLAPI Put(PPID, uint *, long extraData); // @<<ObjCache::Get
	//
	// Descr: Извлекает запись из хранилища по позиции pos.
	// Returns:
	//   >0 - запись по позиции pos успешно извлечена
	//   <0 - запись по позиции pos имеет признак ObjCacheEntry::fDirty
	//   0  - ошибка
	//
	int    FASTCALL Helper_GetByPos(uint pos, void * pDataRec);
	int    SLAPI PackNames(); // @<<ObjCache::Remove

	PPID   ObjType;
	long   Flags;    // OBJCHF_XXX
	size_t EntrySize;
	size_t UnusedNameSpace; // Размер неиспользуемого пространства массива строк ss
	Stat   StatData;
	SArray * P_Ary;
	SString StatLogMsg;
private:
	int    FASTCALL Helper_Get(PPID id, void * pDataRec);

	int64  LastPackNamesClock; // @v8.1.4 Момент последнего вызова PackNames()
	UintHashTable UndefList;   // Используется если (Flags & fUseUndefList)
};
//
//
//
#define DEF_OBJCACHEHASH_SIZE     (256U*1024U)
#define DEF_OBJCACHEHASH_MAXTRIES 4

class ObjCacheHash : public ObjCache {
public:
	SLAPI  ObjCacheHash(PPID objType, size_t entrySize, size_t cacheSize, uint maxTries, long flags = 0);
	SLAPI ~ObjCacheHash();
protected:
	int    SLAPI Init(size_t cacheSize, uint maxTries);
	virtual uint SLAPI GetCount() const;
	virtual int  FASTCALL Search(PPID id, uint * pPos) const;
	virtual ObjCacheEntry * FASTCALL SearchByPos(uint pos, int incr) const; // @<<ObjCache::Helper_GetByPos
	virtual int SLAPI AddItem(const ObjCacheEntry * pEntry, uint * pPos);
private:
	uint   FASTCALL Hash(PPID id, uint n) const;

	uint   Size;
	uint   MaxItems;
	uint   MaxTries;
	ObjCacheEntry * P_Items;
};
//
//
//
struct DbLocalCacheEntry {
	long   DbPathID;
	long   ObjType; // == P_Cache->ObjType
	void * P_Cache; // if ObjType==PPOBJ_ADVEVENTQUEUE then (PPAdviseEventQueue *) else (ObjCache *)
};

class DbLocalCacheMng : private TSArray <DbLocalCacheEntry> {
public:
	SLAPI  DbLocalCacheMng();
	SLAPI ~DbLocalCacheMng();
	int    SLAPI CreateDbEntry(long dbPathID);
	int    SLAPI HasDbEntry(long dbPathID);
	ObjCache * FASTCALL GetCache(long dbPathID, PPID objType);
	int    SLAPI AddCache(long dbPathID, ObjCache *);
	int    SLAPI GetCacheStat(uint pos, ObjCacheStat *);
	int    SLAPI LogCacheStat();
	LDATETIME FASTCALL GetLastUpdate(long dbPathID);
	int    SLAPI SetLastUpdate(long dbPathID, LDATETIME dtm);

	int    SLAPI SetDeferredState(long dbPathID, int set);
	int    FASTCALL IsDeferredState(long dbPathID);
	//
	// Descr: Возвращает очередь системных событий, ассоциированную с базой данных dbPathID.
	//   Если такая очередь не существует, то функция пытается ее создать.
	//
	PPAdviseEventQueue * FASTCALL GetAdviseEventQueue(long dbPathID); // @v8.5.5
private:
	virtual void FASTCALL freeItem(void *);
	void * SLAPI Helper_GetEntry(long dbPathID, PPID objType, int lock);
	//
	// Descr: Флаги состояния кэша
	//
	enum {
		stDeferred = 0x0001 // Включен отложенный режим актуализации
	};
	struct CDbEntry {
		long   DbPathId;
		long   State;              // @v8.0.3
		LDATETIME LastCacheUpdate; // Время последнего обновления кэшей по системному журналу
	};
	SArray DbEntryList;
	ReadWriteLock RwL;
};

class PPVerHistory {
public:
	struct Info {
		SLAPI  Info();

		SVerT MinVer;
		SVerT CurVer;
		S_GUID DbUUID;
	};
	static int SLAPI Log();
	static int SLAPI Log(const char * pDataPath, const char * pLogPath);
	SLAPI  PPVerHistory();
	int    SLAPI Read(const char * pDataPath, Info * pInfo);
	int    SLAPI Write(const char * pDataPath, const Info * pInfo);
private:

	struct Header {
		uint32 Signature;
		uint32 CRC;
		SVerT CurVer;
		SVerT MinVer;
		S_GUID DbUUID;
		uint32 Reserved[7];
	};
	struct Record {
		LDATETIME Dtm;
		SVerT Ver;
		char   Machine[32];
		char   Reserved[20];
	};
};
//
// Descr: Структура с информацией о зарезервированном файле.
//
class PPRFile {
private:
	uint32 Sign;
public:
	SLAPI  PPRFile();
	SLAPI ~PPRFile();
	PPRFile & SLAPI Clear();
	int    SLAPI IsConsistent() const;

	PPID   ID;
	PPID   PathID;
	PPID   SrcPathID;
	long   Flags;
	SString Name;
	SString Descr;
};
//
//
//
class PPThread : public SlThread {
public:
	//
	// Descr: Структура, используемая для извлечения информации о потоках сервера.
	//
	struct Info {
		int     SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		enum {
			stLocalStop = 0x0004
		};

		int32   Id;            // Thread ID
		int32   Kind;          // PPThread::kXXX
		int32   Status;        // Состояние потока PPThread::Info::stXXX
		PPID    JobID;         // @v7.9.6 Идент задачи (Kind==kJob)
		LDATETIME StartMoment; // Время запуска
		SString Text;          // Текстовое обозначение потока (зависит от Kind)
		SString LastMsg;       //
		int32   UniqueSessID;  //
	};
	//
	// Descr: Вид потоков
	//
	enum {
		kUnknown = 0,    // Не определенный
		kJobServer,      // Серверный поток
		kNetServer,      //
		kJob,            // Исполняемое задание сервера
		kNetSession,     // Серверная сессия, свяазанная с удаленной клиентской сессией
		kDbDispatcher,   // Диспетчерский поток (один на каждую базу данных)
		kEventCollector, // Сборщик событий
		kLogger,         // @v8.9.12 Поток для вывода сообщений в журналы
		kDllSession,     // @v9.2.6 Поток созданный в DLL-модуле
		kPpppProcessor   // @v9.6.7 Поток, обеспечивающий обработку входящих данных на стороне автономного кассового узла
	};

	static int GetKindText(int kind, SString & rBuf);

	SLAPI  PPThread(int kind, const char * pText, void * pInitData);
	int    SLAPI GetKind() const;
	int    FASTCALL SetText(const char * pTxt);
	int    FASTCALL SetMessage(const char * pMsg);
	int    FASTCALL GetInfo(PPThread::Info & rInfo) const;
	int32  SLAPI GetUniqueSessID() const;
	virtual int SubstituteSock(TcpSocket & rSock, PPJobSrvReply * pReply)
	{
		return -1;
	}
protected:
	virtual void SLAPI Startup();
	void   FASTCALL SetJobID(PPID jobID); // @v7.9.6
public: // Метод Shutdown вызывается из функции DllMain
	virtual void SLAPI Shutdown();
private:
	int    Kind;
	PPID   JobID; // @v7.9.6
	LDATETIME StartMoment;
	SString Text;
	SString LastMsg_;
	int32   UniqueSessID;
};
//
//
//
struct PPLogMsgItem {
	void   SLAPI Clear();
	long   Options;
    SString FileName;
    SString DupFileName; // Имя дублирующего файла (опционально)
	SString Text;
	SString Prefix;
};

class PPLogMsgQueue : public SStrGroup {
public:
	struct Stat { //
		SLAPI   Stat();

		uint32  PushCount;       // Количество запросов Push
		uint32  PopCount;        // Количество запросов Pop
		uint32  MaxLenght;       // Максимальное количество сообщений в очереди
		size_t  MaxStrPoolSize;  // Максимальный объем пула строк
		uint32  NonEmptyEvCount; // Количество установок события NonEmptyEv
	};

	SLAPI  PPLogMsgQueue();
	SLAPI ~PPLogMsgQueue();
    int    FASTCALL Push(const PPLogMsgItem & rItem);
    int    FASTCALL Pop(PPLogMsgItem & rItem);
    void   FASTCALL GetStat(Stat & rS);

    Evnt   NonEmptyEv;
private:
	struct InnerItem {
		long    Options;
		uint    FileNameP;
		uint    DupFileNameP;
		uint    TextP;
		uint    PrefixP;
	};
	SQueue Q;
    SMtLock L;
    Stat   S;
};

class PPLogMsgSession : public PPThread {
public:
	struct Stat : public PPLogMsgQueue::Stat {
		SLAPI   Stat();

		uint32  MaxSingleOutputCount;       // Максимальное количество сообщений в очереди обработанное по одному событию PPLogMsgQueue::NonEmptyEv
		uint32  OutputCount;                // Количество выведенных сообщений
		uint32  FalseNonEmptyEvSwitchCount; // Количество срабатываний события PPLogMsgQueue::NonEmptyEv при которых очередь была пуста
	};
	SLAPI PPLogMsgSession(PPLogMsgQueue * pQueue);
	int   FASTCALL GetStat(Stat & rS);
private:
	virtual void Run();
	PPLogMsgQueue * P_Queue;
	Stat   S;
};
//
//
//
class PPSession {
public:
	enum {
		fInitPaths    = 0x0001, // Инициализировать пути (извлекает из pp.ini)
		fDenyLogQueue = 0x0002  // Не инициализировать очередь журнальных сообщений (вывод прямо в файл)
	};
	static const char * P_JobLogin; // "$SYSSERVICE$"
	static const char * P_EmptyBaseCreationLogin; // "$EMPTYBASECREATION$"

	SLAPI  PPSession();
	SLAPI ~PPSession();
	int    SLAPI Init(long flags /* PPSession::fInitXXX */, HINSTANCE hInst = NULL);
	int    SLAPI InitThread(const PPThread * pThread);
	void   SLAPI ReleaseThread();
	PPThreadLocalArea & SLAPI GetTLA(); // { return *(PPThreadLocalArea *)TlsGetValue(TlsIdx); }
	const PPThreadLocalArea & SLAPI GetConstTLA() const; // { return *(PPThreadLocalArea *)TlsGetValue(TlsIdx); }

	enum {
		stntText = 1,
		stntMessage
	};
	int    SetThreadNotification(int type, const void * pData);
	int    GetThreadInfoList(int type, TSCollection <PPThread::Info> & rList);
	int    GetThreadInfo(ThreadID tId, PPThread::Info & rInfo);
	//
	// Descr: Останавливает поток с идентификатором tId.
	// Note: Могут быть остановлены только потоки видов PPThread::kJob, PPThread::kNetSession.
	//
	int    SLAPI StopThread(ThreadID tId);
	//
	// Descr: Возвращает !0 если текущий поток получил требование остановиться.
	//
	int    SLAPI IsThreadStopped();

	enum {
		ldsLock      = 1,
		ldsUnlock    = 2,
		ldsCanUnload = 3
	};
	int    SLAPI LockingDllServer(int cmd);
	enum {
		ctxtExportData = 1,
		ctxtInterface,
		ctxDatabase
	};
	//
	// Descr: Возвращает контекст управления интерфейсными структурами или интерфейсными
	//   COM-объектами в зависимости от параметра ctxType.
	//   Вызывающие модули не должны делать никаких предположений о том, в каких файлах
	//   и как храняться возвращаемые контексты. Это требование формулируется для того,
	//   чтобы иметь возможности для оптимизации хранения и загрузки контекстов (их размер
	//   весьма внушителен, и, следовательно, в дальнейшем понадобятся меры для такой оптимизации).
	// ARG(ctxType IN): Тип контекста. Если ctxType == PPSession::ctxtExportData, то
	//   возвращает контекст управления структурами экспорта, если ctxType == PPSession::ctxtInterface,
	//   то возвращает контекст управления COM-объектами системы.
	//
	DlContext * SLAPI GetInterfaceContext(int ctxType);

	int    SLAPI GetUsedLicCount(int32 * pUsedLicCount);
	int    SLAPI LoadDriveMapping(PPIniFile *);
	int    SLAPI GetDriveMapping(int drive, SString & rMapping) const;
	int    SLAPI ConvertPathToUnc(SString & rPath) const;

	int    SLAPI CheckSystemAccount(DbLoginBlock * pDlb, PPSecur * pSecur);
	int    SLAPI Login(const char * pDbSymb, const char * pUserName, const char * pPassword);
	int    SLAPI Logout();
	//
	// Descr: Флаги функции OpenDictionary2
	//
	enum {
		odfDontInitSync = 0x0001 // Не открывать файл синхронизации Sync
	};
	int    SLAPI OpenDictionary2(DbLoginBlock * pBlk, long flags);
	int    SLAPI SetPath(PPID pathID, const char * pBuf, short flags, int replace);
	int    SLAPI GetPath(PPID pathID, SString & rBuf);
	//
	// Descr: Возвращает максимальный размер файла журнала в Kb.
	//
	long   SLAPI GetMaxLogFileSize() const;
	//
	// Descr: Возвращает информацию о зарезервированном файле с идентификатором fileId.
	//
	int    SLAPI GetRFileInfo(PPID fileId, PPRFile & rInfo);
	//
	// Descr: Возвращает енумератор для перечисления зарезервированных файлов.
	//
	SEnumImp * EnumRFileInfo();

	int    SLAPI SetLocation(PPID locID);
	void   SLAPI SetOperDate(LDATE);
	void   SLAPI SetCurCashNodeID(PPID);
	void   SLAPI SetDefBillCashID(PPID);
	void   SLAPI SetMenu(short);
	int    SLAPI SetDemoMode(int);
	long   SLAPI SetLCfgFlags(long);
	short  SLAPI SetRealizeOrder(short);
	int    SLAPI SetMainOrgID(PPID mainOrgID, int enforce);
	//
	// Descr: Устанавливает или снимает биты поля флагов ExtFlags.
	// ARG(f   IN): параметр, содержащие битовые флаги, которые необходимо установить или сбросить.
	//   ВСЕ БИТЫ, которые установлены в f будут, в зависимости от аргументы set, установлены или сброшены в ExtFlags.
	// ARG(set IN): параметр определяющий следует ли установить (set > 0) или сбросить (set == 0)
	//   биты ExtFlags маска которых задана аргументом f.
	// Returns:
	//   Значение ExtFlags предшествующее вызову SetExtFlags()
	// Note:
	//   Поле ExtFlags защищено критической секцией, применяемой в функциях SetExtFlags и CheckExtFlags.
	//   Не следует модифицировать или проверять значения 'того поля в обход этих функций.
	//
	long   SLAPI SetExtFlag(long f, int set);
	int    FASTCALL CheckExtFlag(long);
	void   SLAPI SetStateFlag(long, int set);
	int    SLAPI CheckStateFlag(long) const;
	ObjCache * FASTCALL GetDbLocalObjCache(PPID objType);
	int    SLAPI SetDbLocalObjCache(ObjCache * pCache);
	int    SLAPI DirtyDbCache(long dbPathID, /*int64 * pAdvQueueMarker*/PPAdviseEventQueue::Client * pCli);
	int    SLAPI SetDbCacheDeferredState(long dbPathID, int set);
	int    FASTCALL IsDbCacheDeferredState(long dbPathID);
	PPAdviseEventQueue * SLAPI GetAdviseEventQueue(PPAdviseEventQueue::Client * pCli);
	//
	// Descr: устанавливает флаг проверки остатков по счетам в соответствии с параметром и возвращает
	//   предыдущее значение. Если параметр (< 0), то просто возвращает текущее значение
	//
	int    SLAPI RestCheckingStatus(int = -1);
	int    SLAPI FetchConfig(PPID obj, PPID objID, PPConfig * pCfg);
	const  PPConfig & SLAPI LCfg() const { return GetConstTLA().Lc; }
	const  PPCommConfig & SLAPI CCfg() const { return GetConstTLA().Cc; }
	//
	// Descr: Извлекает через кэш конфигурацию глобального обмена PPAlbatrosConfig.
	// ARG(pCfg INOUT): Если pCfg != 0, то извлекает через кэш конфигурацию. Если pCfg == 0,
	//   то удаляет кэш конфигурации (dirty).
	//
	int    SLAPI FetchAlbatrosConfig(PPAlbatrosConfig * pCfg); // @cs
	//
	// Really const function: don't modify result object
	//
	const PPVersionInfo & SLAPI GetVersionInfo() const;
	SVerT SLAPI GetVersion() const;
	PPSync & SLAPI GetSync();
	int    SLAPI LogAction(PPID action, PPID obj, PPID id, long extData, int use_ta);
	int    SLAPI GetMachineID(MACAddr * pMachineID, int forceUpdate);
	GtaJournalCore * SLAPI GetGtaJ();

	void   SLAPI ProcessIdle();
	int    SLAPI Advise(long * pCookie, const PPAdviseBlock * pBlk);
	int    SLAPI Unadvise(long cookie);
	int    SLAPI GetAdviseList(int kind, PPID objType, PPAdviseList & rList);
	int    SLAPI GetObjectTitle(PPID objType, SString & rBuf);
	PPID   SLAPI GetObjectTypeBySymb(const char * pSymb, long * pExtraParam);
	int    SLAPI GetObjectTypeSymb(PPID objType, SString & rBuf);
	//
	// Descr: Устанавливает имя файла, в котором будут дублироваться все сообщения, //
	//   заносимые в любой из журналов.
	// ARG(pFileName IN): @#{vptr0} Если pFileName != 0, то это должно быть имя файла, возможно
	//   не существующего, но обязательно доступное для создания/записи. После вызова
	//   этой функции, все вызовы PPLogMessage() будут дублировать сообщения в этот файл.
	//   Вызов с параметром pFileName = 0 останавливает дублирование записи.
	//
	void   SLAPI SetTempLogFileName(const char * pFileName);
	int    SLAPI SetPrivateBasket(PPBasketPacket * pPack, int use_ta);
	PPBasketPacket * SLAPI GetPrivateBasket();
	PPJobSrvClient * SLAPI GetClientSession(int dontReconnect);
	int    SLAPI SetThreadSock(int32 uniqueSessID, TcpSocket & rSock, PPJobSrvReply * pReply);
	//
	// Функции профилирования //
	//
	// Descr: Возвращает абсолютное время в микросекундах для целей профилирования //
	// Note: использует локальный для потока объект PPThreadLocalArea::Prf
	//
	uint64 SLAPI GetProfileTime();
	//
	// Descr: Фиксирует начало профилирования участка кода файла pFileName строки lineNo.
	// Note: использует глобальный объект PPSession::GPrf
	//
	int    SLAPI GProfileStart(const char * pFileName, long lineNo, const char * pAddedInfo = 0);
	//
	// Descr: Фиксирует завершение профилирования участка кода файла pFileName строки lineNo.
	// Note: испольует глобальный объект PPSession::GPrf
	//
	int    SLAPI GProfileFinish(const char * pFileName, long lineNo);
	//
	// Descr: Структура регистрации сессии в системном реестре
	//
	struct RegSessData { // @persistent
		SLAPI  RegSessData();

		enum {
			fExtraUUID = 0x0001 // Структура получена по внешнему UUID (не связанному с регистрацией сессий в локальном реестре)
		};
		//
		// Поле включается в реестр Windows как ключ параметра
		//
		S_GUID Uuid;
		//
		// В значение параметра вносятся данные, начиная со следующего поля //
		//
		uint32 ReserveStart; // @anchor
		LDATETIME InitTime;
		SVerT Ver;
		long   Flags;
		uint8  Reserve[28];
	};
	//
	// Функции регистрации сессий в системном реестре
	//
	int    SLAPI Register();
	int    SLAPI Unregister();
	int    SLAPI GetRegisteredSess(const S_GUID & rUuid, PPSession::RegSessData * pData);
	//
	//
	//
	struct LoggerIntermediateBlock {
		SLAPI   LoggerIntermediateBlock(const PPSession & rS) : CfgMaxFileSize(rS.GetMaxLogFileSize())
		{
		}
		const   long CfgMaxFileSize;
		SString MsgBuf;
		SString TempBuf; // @allocreuse
		SString NewFileName;
	};

	int    FASTCALL PushLogMsgToQueue(const PPLogMsgItem & rItem);
	int    SLAPI Log(const char * pFileName, const char * pStr, long options);
	static int SLAPI Helper_Log(PPLogMsgItem & rMsgItem, PPSession::LoggerIntermediateBlock & rLb);
private:
	int    SLAPI Helper_SetPath(int pathId, SString & rPath);
	int    SLAPI MakeMachineID(MACAddr * pMachineID);
	int    SLAPI CheckLicense(MACAddr * pMachineID, int * pIsDemo);
	int    SLAPI SetupConfigByOps();
	int    SLAPI GetLocalPath(SString & rBuf);
	int    SLAPI CreateDbDispatchThread(long dbPathID, const char * pDbSymb);
	DlContext * SLAPI Helper_GetInterfaceContext(DlContext ** ppCtx, uint fileId, int crit);
	int    SLAPI SetExtFlagByIniIntParam(PPIniFile & rIniFile, uint sect, uint param, long extFlags, int reqValue);

	struct ObjIdentBlock {
		ObjIdentBlock();
		StrAssocArray TitleList;
		//SymbHashTable SymbList;
		const SymbHashTable * P_ShT;
	};

	long   TlsIdx;         // Ид локальной области потока    //
	long   Id;
	ACount LastThread;
	ACount DllRef;         // Счетчик активных клиентов для DLL-сервера
	long   MaxLogFileSize; // @v8.0.6 Максимальный размер файлов журналов в Kb. По умолчанию - 32768.
	PPVersionInfo Ver;
	SString BinPath;       // @v8.1.6 @*PPSession::Init()
	PPPaths CommonPaths;
	PPDriveMapping DrvMap;
	ObjIdentBlock * P_ObjIdentBlk;
	PPLogMsgQueue * P_LogQueue;
	//
	long   ExtFlags_;      // ECF_XXX
	SMtLock ExtFlagsLck;   // @v8.0.3 Блокировка доступа к ExtFlags
	//
	DbLocalCacheMng CMng;  // Менеджер локальных по отношению к базе данных объектных кэшей
	PPAdviseList AdvList;  // Подписка на извещения о событиях.
	DlContext * P_DbCtx;   // Контекст структуры базы данных. Контекст глобальный (не привязан к потокам)
	PPAlbatrosConfig * P_AlbatrosCfg; // @v7.2.8 Кэшированная конфигурация глобального обмена
		// Единственная точка прямого доступа к этому указателю - FetchAlbatrosConfig().
	Profile GPrf;          // @v8.0.3 Глобальный профайлер для всей сессии. Кроме него в каждом потоке
		// есть собственный профайлер PPThreadLocalArea::Prf

	class ThreadCollection : private TSCollection <PPThread> {
	public:
		ThreadCollection();
		int    FASTCALL Add(const PPThread * pThread);
		int    FASTCALL Remove(ThreadID id);
		//
		// ARG(id   IN): Идентификатор потока, для которого передается сообщение
		// ARG(kind IN):
		//   0 - устанавливает PPThread::Text
		//   1 - устанавливает PPThread::LastMsg
		// ARG(pMsg IN): @#{vptr0} Указатель на текст сообщения.
		//
		int    FASTCALL SetMessage(ThreadID id, int kind, const char * pMsg);
		uint   GetCount();
		int    FASTCALL GetInfoList(int type, TSCollection <PPThread::Info> & rList);
		int    FASTCALL GetInfo(ThreadID tId, PPThread::Info & rInfo);
		int    FASTCALL StopThread(ThreadID tId);

		PPThread * FASTCALL SearchById(ThreadID tId);
		PPThread * FASTCALL SearchBySessId(int32 sessId);
	private:
		ReadWriteLock RwL;
	};
	ThreadCollection ThreadList; // Список потоков. Конструктор снимает
		// флаг aryEachItem с этого экземпляра поскольку он не владеет указателями на потоки.
};

extern PPSession DS;

#ifdef LOCAL_PPERRCODE
	extern int PPErrCode;
#else
	#define PPErrCode (DS.GetTLA().LastErr)
#endif
#define LConfig   (DS.LCfg())
#define CConfig   (DS.CCfg())
#define CrwError  (DS.GetTLA().LastCrwErr)
#define BillObj   (DS.GetTLA().P_BObj)
#define PPRef     (DS.GetTLA().P_Ref)
#define PPMaster  (DS.LCfg().State & CFGST_MASTER)
#define ObjRts    (DS.GetConstTLA().Rights)
#define CS_SERVER (DS.CheckExtFlag(ECF_SYSSERVICE))
#define CS_CLIENT (DS.CheckExtFlag(ECF_CLIENT))

void   SLAPI PPSaveErrContext();
void   SLAPI PPRestoreErrContext();

int    SLAPI dbl_cmp(double, double);

DECL_CMPFUNC(PPLBItem);
DECL_CMPFUNC(PPTLBItem);
DECL_CMPFUNC(Acct);
//
// Descr: Набор точек входа в базы данных.
//   Описание точек входа в БД хранится в файле BIN\PP.INI в разделе [dbname]
//   В наборе одна из точек входа может быть активной (текущей). Эта характеристика
//   используется при выборе базы данных в диалогах и т.д.
//
class PPDbEntrySet2 : public DbLoginBlockArray {
public:
	PPDbEntrySet2();
	//
	// Descr: Считывает набор точек входа в БД из ini-файла pIniFile.
	// ARG(pIniFile IN): @#{vptr0} INI-файл, из которого следует считать данные.
	//   Если pInitFile == 0, то функция открывает файл BIN\PP_INI и считывает
	//   данные из него.
	// ARG(existsPathOnly  IN): Если этот параметр !0, то точки входа, каталоги
	//   хранения данных для которых не найдены, не считываются.
	// ARG(dontLoadDefDict IN): Если !0, то не в точку входа не загружается путь к словарю по умолчанию.
	//   Этот параметр используется при редактировании списка точек входа в базы данных
	//
	int    SLAPI ReadFromProfile(PPIniFile * pIniFile, int existsPathOnly = 1, int dontLoadDefDict = 0);
	int    SLAPI RegisterEntry(PPIniFile * pIniFile, const DbLoginBlock * pBlk);
	long   SLAPI SetDefaultSelection();
private:
	int    SLAPI MakeProfileLine(const DbLoginBlock * pBlk, SString & rBuf) const;
	int    SLAPI ParseProfileLine(const char * pLine, DbLoginBlock * pBlk) const;
};
//
// String loading and processing functions
//
int    SLAPI PPInitStrings(const char * pFileName = 0);
void   SLAPI PPReleaseStrings();
//
// Descr: Загружает строку, принадлежащую группе group с идентификатором code в буфер s.
// Returns:
//   !0 - строка успешно загружена
//   0  - ошибка (PPSetErrorSLib())
//
int    SLAPI PPLoadString(int group, int code, SString & s); // @cs
SString & SLAPI PPLoadStringS(int group, int code, SString & s); // @cs
int    FASTCALL PPLoadString(const char * pSignature, SString & s);
//
// Descr: Возвращает хэш-таблицу символов, ассоциированную с группой group
//   из внутреннего глобального хранилища.
// Note: Ни в коем случае не пытайтесь менять состояние объекта, на который
//   ссылается возвращаемый указатель. Если необходимы nonconst-действия, то сделайте
//   копию этого объекта и с ней работайте.
//
const  SymbHashTable * FASTCALL PPGetStringHash(int group);
//
// Descr: Если строка rS содержи макросы вида @{abc}, то
//   функция разрешает эти макросы извлекая строки с сигнатурами @abc
//   из строкового хранилища.
//
int    FASTCALL PPExpandString(SString & rS, int ctransf);
//
// Descr: Загружает строку категории PPSTR_TEXT в буфер s
//
int    FASTCALL PPLoadText(int code, SString & s);
SString & FASTCALL PPLoadTextS(int code, SString & s);
//
// Descr: Загружает строку с ошибкой в буфер s
//
int    FASTCALL PPLoadError(int code, SString & s, const char * pAddInfo);
//
// Descr: Загружает строку категории PPSTR_TEXT в буфер s и перекодирует ее функцией s.Transf(CTRANSF_INNER_TO_OUTER)
//
int    FASTCALL PPLoadTextWin(int code, SString & s);
// @v9.5.0 int    SLAPI PPLoadString(int grp, int code, char * pBuf, size_t buflen); // @cs
int    SLAPI PPGetSubStr(const char * pStr, int idx, SString &);
int    SLAPI PPGetSubStr(const char * pStr, int idx /* 0.. */, char * pBuf, size_t bufLen);
	// @>>PPGetSubStr(const char *, int, SString &)
int    SLAPI PPGetSubStr(uint strID, int idx, SString &);
int    SLAPI PPGetSubStr(uint strID, int idx /* 0.. */, char * buf, size_t buflen);
int    SLAPI PPCmpSubStr(const char * pStr, int idx /* 0.. */, const char * pTestStr, int ignoreCase);
int    SLAPI PPSearchSubStr(const char * pStr, int * pIdx, const char * pTestStr, int ignoreCase);
char * SLAPI numbertotext(double nmb, long fmt, char * pBuf);
char * SLAPI PPGetWord(uint wordId /* PPWORD_XXX */, int ansiCoding, char * pBuf, size_t bufLen); // @obsolete
SString & SLAPI PPGetWord(uint wordId /* PPWORD_XXX */, int ansiCoding, SString & rBuf);
//
// Descr: Извлекает подстроку из строки вида "1,str1;2,str2;3,str3;.." по номеру
//   предшествующему собственно подстроке (subId)
// Returns:
//   1 - подстрока обнаружена и присвоена буферу rBuf
//   0 - подстрока не обнаружена либо не удалось загрузить всю строку по идентификатору strId.
//
int    SLAPI PPGetSubStrById(int strId, int subId, SString & rBuf);
//
// Функция ideqvalstr прописывает в буфер pBuf текст "ID=id"
//
SString & FASTCALL ideqvalstr(long id, SString & rBuf);
char * FASTCALL ideqvalstr(long id, char * pBuf, size_t bufLen); // @obsolete
//
// Output message functions
//
SString & SLAPIV PPFormat(const SString & rFmt, SString * pBuf, ...);
SString & SLAPIV PPFormatT(int textCode, SString * pBuf, ...);
SString & SLAPIV PPFormatS(int textGroup, int textCode, SString * pBuf, ...);
void   FASTCALL PPSetAddedMsgString(const char * pStr);
void   SLAPI PPSetAddedMsgObjName(PPID objType, PPID objID);
int    SLAPI PPGetMessage(uint options, int msgcode, const char * pAddInfo, int rmvSpcChrs, SString & rBuf);
//
// Descr: Сокращенный аналог PPGetLastErrorMessage(rmvSpcChrs, rBuf)
//
int    FASTCALL PPGetLastErrorMessage(int rmvSpcChrs, SString & rBuf);
int    SLAPI PPOutputMessage(const char * msg, uint option);
int    FASTCALL PPMessage(uint options, int msgcode, const char * pAddInfo);
int    FASTCALL PPMessage(uint options, int msgcode);
int    FASTCALL PPError(int errcode, const char * pAddInfo = 0/*, int tooltip = 0*/);
int    SLAPI PPTooltipMessage(uint options, int msgcode, const char * pAddInfo);
int    SLAPI PPTooltipMessage(const char * pMsg, const char * pImgPath, HWND parent, long timer, COLORREF color, long flags);

//
// Descr: Единственная польза от следующей функции - снижение размера
//   бинарного кода за счет устранения передачи лишних параметров.
//   Вызов PPError() в кодах встречается более 1100 раз
//
int    SLAPI PPError(); // @>>PPError(-1, 0)
//
// Descr: То же, что и PPError() но гарантированно возвращает 0.
//   Создана для замены конструкции (PPError(), 0)
//
int    SLAPI PPErrorZ();
int    FASTCALL PPErrorTooltip(int errCode, const char * pAddedMsg);
//
// Descr: Устанавливает код текущей ошибки Papyrus в значение errCode и дополнительную строку pAddedMsg.
// Returns:
//   0
//
int    FASTCALL PPSetError(int errCode, const char * pAddedMsg);
int    FASTCALL PPSetError(int errCode, long val);
int    FASTCALL PPSetError(int errCode);
int    FASTCALL PPSetLibXmlError(const xmlParserCtxt * pCtx);
int    PPSetErrorNoMem();
int    PPSetErrorInvParam(); // @v9.6.3
//
// Returns:
//   0
//
int    PPSetErrorSLib();
//
// Returns:
//   0
//
int    PPSetErrorDB();
int    SLAPI PPDbSearchError(); // { return (BTROKORNFOUND) /**/ ? -1 : PPSetErrorDB(); }
int    SLAPI PPSetObjError(int errCode, PPID objType, PPID objID);
//
// Выдает сообщение "Функция в DOS-версии не поддерживается" и возвращает -1.
//
int    SLAPI DosStubMsg();
//
// Database chain functions
//
// Descr: Setup database chain
// ARG(pPassword IN): password for removing chain. If pPassword == 0, then
//   removing impossible.
int    SLAPI PPChainDatabase(const char * pPassword);
//
// Descr: Remove database chain
//
int    SLAPI PPUnchainDatabase(const char * pPassword);
//
// Descr: Check chain integrity.
// Returns:
//   >0 - ok
//   <0 - chain not installed
//   0  - chain integrity error
//
int    SLAPI PPCheckDatabaseChain();
//
// Некоторые файловые расширения используемые в системе
//
#define PPSEXT     ".PPS" // Файлы передачи данных между разделами БД
#define CHARRYEXT  ".CHY" // Файлы charry
//
// Path and file fuctions
//
int    FASTCALL PPGetPath(PPID pathID, SString & rBuf);
SString & FASTCALL PPGetFileName(uint fnameID, SString & rBuf);
int    FASTCALL PPGetFilePath(PPID pathID, const char * pFileName, SString & rBuf);
int    FASTCALL PPGetFilePath(PPID pathID, uint fnameID, SString & rBuf);
//
// Descr: Формирует уникальное имя временного файла в каталоге PPPATH_TEMP.
//
SString & SLAPI PPMakeTempFileName(const char * pPrefix, const char * pExt, long * pStart, SString & rBuf);
	// @>>MakeTempFileName
int    SLAPI PPRemoveFiles(const PPFileNameArray * pFileList);
int    SLAPI PPRemoveFilesByExt(const char * pSrc, const char * pExt);
int    SLAPI GetFilesFromMailServer(PPID mailAccID, const char * pDestPath, long filtFlags, int clean, int deleMsg);
//
// Передает выборку файлов по адресу pDestAddr, используя учетную запись mailAccID
// и тему сообщения pSubj.
//
int    SLAPI PutFilesToEmail(const PPFileNameArray *, PPID mailAccID, const char * pDestAddr, const char * pSubj, long trnsmFlags);
int    SLAPI PutFilesToEmail(const StringSet *, PPID mailAccID, const char * pDestAddr, const char * pSubj, long trnsmFlags);
//
// Descr: Загружает из ресурсов структуру SdRecord.
//   Тип ресурса - PP_RCDECLRECORD, идентификатор - rezID.
// ARG(rezID      IN): Идентификатор ресурса описания записи
// ARG(pRec      OUT): Указатель на структуру записи, которая буде заполнена из описания ресурса.
// ARG(headerOnly IN): Если !0, то загружаются только идентификатор и наименование ресурса.
//   Описания полей не загружаются.
// Returns:
//   >0 - структура успешно загружена
//   0  - ошибка
//
int    SLAPI LoadSdRecord(uint rezID, SdRecord * pRec, int headerOnly = 0); // @defined(PPUTIL.CPP)
//
// Следующие функции возвращают таблицу аналитических статей,
// ассоциированную соответственно с поставщиками, покупателями и агентами.
//
PPID   SLAPI GetSupplAccSheet();
//
// Descr: Возвращает идентификатор таблицы аналитических статей, представляющих покупателей.
//
PPID   SLAPI GetSellAccSheet();
//
// Descr: Возвращает идентификатор вида персоналий, представляющего покупателей.
//   Значение определяется как группа объектов, связанных с аналитическими статьями
//   таблицы GetSellAccSheet() если с этой таблицей связаны персоналии.
//
PPID   SLAPI GetSellPersonKind();
PPID   SLAPI GetAgentAccSheet();
//
// Descr: Если статья articleID соотносится с поставщиком, освобожденным от НДС,
//   то функция IsSupplVATFree возвращает (>0).
//
int    SLAPI IsSupplVATFree(PPID articleID); // @>>ArticleCache::IsSupplVatFree
int    SLAPI IsLotVATFree(const ReceiptTbl::Rec & rLotRec);
//
// Descr: GetSupplText если suppl != 0 возвращает строку вида "Поставщик: XXX" и
//   код возврата > 0. В противном случае - пустую строку и код < 0.
//   Используется при печати отчетов.
//
int    SLAPI GetSupplText(PPID suppl, SString & rBuf);
int    SLAPI GetCommConfig(PPCommConfig *);
int    SLAPI SetCommConfig(PPCommConfig *, int use_ta);
//
// Descr: вычисляет значение, на которое необходимо умножить сумму,
//   облагаемую налогом с продаж или НДС, (сумма включает значение налога)
//   чтобы получить величину налога к уплате.
// ARG(rate IN): задает номинальную ставку налога в %.
//
double SLAPI SalesTaxMult(double rate);
//
// Descr: вычисляет номинальную ставку НДС (%) по значениям облагаемой
//   базы (base) и суммы НДС к уплате (vat_sum). Полезна для расчета средней ставки НДС.
//
double SLAPI CalcVATRate(double base, double vat_sum);
//
//
//
enum PPDbTransactionUsage {
	pputSmart = -1,
	pputYes = 1,
	pputNo = 0
};
//
// Пример использования следующих трех функций:
// int proc(int use_ta)
// {
//     int ok = 1, ta = 0;
//	   THROW(PPStartTransaction(&ta, use_ta));
//     .
//     .
//     .
//     THROW(PPCommitWork(&ta));
//     CATCH
//         PPRollbackWork(&ta);
//         ok = 0;
//     ENDCATCH
//     return ok;
// }
//
int    FASTCALL PPStartTransaction(int * ta, int use_ta);
int    FASTCALL PPCommitWork(int * ta);
int    FASTCALL PPRollbackWork(int * ta);

enum PPDbDependTransaction {
	ppDbDependTransaction = 1
};

class PPTransaction {
public:
	//
	// Descr: Конструктор вызывает Start(dbDepended, use_ta)
	//
	PPTransaction(PPDbDependTransaction dbDepend, int use_ta);
	PPTransaction(int use_ta);
	~PPTransaction();
	int    operator !();
	//
	// Descr: Запускает транзакцию в зависимости от параметров dbDepended и use_ta.
	// Returns:
	//   >0 - транзакция была успешно запущена этой функцией
	//   <0 - транзакция до вызова функции уже запущена внутри этого экземпляра, либо условия {dbDepended, use_ta}
	//      и состояние менеджера базы данных не требуют запуска транзакции.
	//   0  - ошибка. Может быть связана либо с текущим состоянием экземлпяра (Err != 0), либо
	//      возникла в процессе запуска транзакции.
	//
	int    Start(int use_ta);
	int    Start(PPDbDependTransaction dbDepend, int use_ta);
	int    Commit();
private:
	int    Ta;
	int    Err;
};
//
// Descr: Ищет запись в таблице pTbl по идентификатору id.
//   Полагает, что первый (0) индекс подходит для этой цели. В случае успешного поиска
//   найденная запись копируется по адресу pBuf
//   Параметр objType необходим только для инициализации информации об
//   объекте, который не найден, для сообщения об ошибке.
// Returns:
//   <0 - запись не найдена
//   >0 - запись найдена
//   0  - ошибка
//
int    FASTCALL SearchByID(DBTable * pTbl, PPID objType, PPID id, void * pBuf);
int    FASTCALL SearchByID_ForUpdate(DBTable * pTbl, PPID objType, PPID id, void * pBuf);
int    FASTCALL SearchByKey(DBTable * pTbl, int idx, void * pKey, void * pData);
int    FASTCALL SearchByKey_ForUpdate(DBTable * pTbl, int idx, void * pKey, void * pData);
int    SLAPI    PPSetDbRecordByKey(DBTable * pTbl, int idx, void * pKey, const void * pData, int use_ta);
//
// Descr: Функцию следует использовать только в очень редких случаях.
//
int    FASTCALL AdjustNewObjID(DBTable * pTbl, PPID objType, void * b);
int    FASTCALL AddByID(DBTable *, PPID *, void *, int use_ta);
int    FASTCALL AddObjRecByID(DBTable * pTbl, PPID objType, PPID * pID, void * b, int use_ta);
//
// Descr: Изменяет запись таблицы pTbl, найдя ее по идентификатору objID.
// ARG(pTbl    IN): @#{vptr} Указатель на экземпляр таблицы, в которой неободимо изменить запись.
// ARG(objType IN): Опциональный тип объекта. Используется для вывода сообщения об
//   ошибке, если запись по идентификатору objID не найдена.
// ARG(objID   IN): Идентификатор записи, которую необходимо изменить.
// ARG(pRec    IN): @#{vptr} Указатель на буфер записи, который должен заместить
//   существующую запись.
// ARG(use_ta  IN): Если !0 то операция выполняется в рамках собственной транзакции.
// Returns:
//   >0 - запись изменена успешно
//   0  - ошибка.
//
int    FASTCALL UpdateByID(DBTable * pTbl, PPID objType, PPID objID, void * pRec, int use_ta);
//
// Descr: Изменяет запись таблицы pTbl, найдя ее по идентификатору objID. Отличается от
//   функции UpdateByID тем, что перед изменением сравнивает найденную запись в базе данных
//   с записью pRec и, если они равны, то не осуществляет изменения и возвращает -1.
//   Сравнение реализуется функцией BNFieldList::IsEqualRecords().
// ARG(pTbl    IN): @#{vptr} Указатель на экземпляр таблицы, в которой неободимо изменить запись.
// ARG(objType IN): Опциональный тип объекта. Используется для вывода сообщения об
//   ошибке, если запись по идентификатору objID не найдена.
// ARG(objID   IN): Идентификатор записи, которую необходимо изменить.
// ARG(pRec    IN): @#{vptr} Указатель на буфер записи, который должен заместить
//   существующую запись.
// ARG(use_ta  IN): Если !0 то операция выполняется в рамках собственной транзакции.
// Returns:
//   >0 - запись изменена успешно
//   <0 - запись не была изменена поскольку pRec не отличается от записи в базе данных.
//   0  - ошибка.
//
int    FASTCALL UpdateByID_Cmp(DBTable * pTbl, PPID objType, PPID id, void * pRec, int use_ta);
int    FASTCALL RemoveByID(DBTable *, PPID objID, int use_ta);
//
// Descr: находит первый доступный номер для члена oprno ключа вида
//   { LDATE date; long oprno; } за дату date. Параметр idx указывает номер индекса
//   в таблице pTbl. Используется функция DBTable::searchKey, поэтому на установку
//   позиции и заполнение буфера данных расчитывать нельзя.
//
int    SLAPI IncDateKey(DBTable * pTbl, int idx, LDATE, long * pOprno);
int    FASTCALL CheckTblPtr(DBTable *);
int    FASTCALL CheckQueryPtr(DBQuery *);
TempOrderTbl * SLAPI CreateTempOrderFile();

DBQ  & FASTCALL ppidlist(DBItem &, const PPIDArray *);
DBQ  * FASTCALL ppcheckfiltid(DBQ *, DBItem &, PPID);
DBQ  * FASTCALL ppcheckfiltidlist(DBQ *, DBItem &, const PPIDArray *);
//
// Descr: Добавляет к ограничению pDbq терм запроса, содержащий утверждение относительно
//   значения флага rItem. Если терм добавляется, то в конец выражения со связкой AND.
// ARG(pDbq  IN): Выражение ограничения, которому необходимо добавить терм
// ARG(rItem IN): Поле или выражение, к которому применяется проверка флага
// ARG(mask  IN): Значение маски флага, на которую проверяется выражение rItem
// ARG(test  IN): Параметр, определяющий способ сравнения выражения rItem с маской mask
//   >0 - Значение поля rItem проверяется на наличие флага mask:    (rItem & mask) == mask
//   <0 - Значение поля rItem проверяется на отсутствие флага mask: (rItem & mask) == 0
//   0  - Значение поля не проверяется и функция возвращает оригинальное выражение pDbq
// Returns:
//   Возможно модифицированное значение pDbq.
//
DBQ  * FASTCALL ppcheckflag(DBQ * pDbq, DBItem & rItem, long mask, int test);
DBQ  * FASTCALL ppcheckweekday(DBQ * pDbq, DBItem & rItem, int dayOfWeek);

SString & SLAPI GetMainOrgName(SString &);
int    SLAPI GetMainOrgID(PPID *);
int    SLAPI GetMainEmployerID(PPID *);
//
// Descr: Определяет город, в котором находится главная организация.
//   Город определяется по фактическому или (если нет фактического) юридическому
//   адресу главной организации.
// Returns:
//   <0 - не удалось идентифицировать город
//   1  - город идентифицирован по фактическому адресу
//   2  - город идентифицирован по юридическому адресу
//
int    SLAPI GetMainCityID(PPID * pCityID);
//
// Descr: Извлекает информацию о персоналии, ассоциированной с текущим пользователем (LConfig.User).
// ARG(pPersonID      OUT): @#{vptr0} Указатель, по которому функция присваивает идентификатор искомой
//   персоналии. Если pPersonID == 0, то функция не пытается ничего присвоить по этму адресу.
//   Если с пользователем не связана действительная запись персоналии, то по указателю присваивается 0.
// ARG(pPersonName IN/OUT): @#{vptr0} Указатель на строку, в которую, если указатель не нулевой,
//   функция записывает наименование найденной персоналии. Если указатель нулевой, то функция не пытается //
//   извлекать запись персоналии, связанной с пользователем.
//   Если с пользователем не связана действительная запись персоналии, то по указателю присваивается пустая строка.
// Returns:
//   >0 - с текущим пользователем связана действительная запись персоналии.
//   -2 - не найдена запись текущего пользователя //
//   -1 - с текущим польователем либо не связана персоналия, либо по связанному идентификатору не найдена
//        запись персоналии.
//   0  - ошибка
//
int    SLAPI GetCurUserPerson(PPID * pPersonID, SString * pPersonName);
int    SLAPI GetUserByPerson(PPID psnID, PPID * pUserID);
int    SLAPI GetLocationName(PPID locID, SString &);
int    SLAPI SearchDlvrAddr();
int    SLAPI EditDlvrAddrExtFields(LocationTbl::Rec * pData);
//
// Функция GetExtLocationName отличается от GetLocationName тем,
// что при locID == 0 копирует в буфер строку "Все объекты"
//
int    SLAPI GetExtLocationName(PPID locID, SString &);
//
// Descr: Заносит в буфер rBuf наименования складов из списка rLocList.
// ARG(rLocList IN): список идентификаторов складов. Если rLocList.IsEmpty(), то
//   в буфер rBuf заносится строка "Все склады"
// ARG(maxItems IN): максимальное количество складов из списка, чьи наименовани
//   необходимо занести в буфер rBuf. Если список rLocList содержит более maxItems
//   элементов, то после наименования последнего склада ставится разделить ';' и
//   две точки '..'. Если maxItems == 0, то список не ограничивается.
// ARG(rBuf    OUT): Буфер, в который заносятся наименования складов. Наименования //
//   разделяются символами '; '. Кодировка символов в буфере - OEM.
// Returns: ссылку на буфер rBuf
//
SString & SLAPI GetExtLocationName(const ObjIdListFilt & rLocList, size_t maxItems, SString & rBuf);
//
// Descr: Копирует в буфер rBuf имя текущего пользователя. Имя извлекается из
//   из локальной по отношению потоку переменной.
//   Обращений к базе данных при этом не происходит.
//   Глобальное состояние системы никак не меняется.
//
SString & SLAPI GetCurUserName(SString & rBuf);
int    FASTCALL GetPersonName(PPID id, SString & rBuf);
int    FASTCALL GetGoodsNameR(PPID goodsID, SString & rBuf);
SString & FASTCALL GetGoodsName(PPID goodsID, SString & rBuf);
int    FASTCALL GetAcctName(Acct *, PPID curID, long fmt, SString & rBuf);
int    FASTCALL GetAcctIDName(AcctID *, long fmt, SString & rBuf);
int    FASTCALL GetArticleName(PPID arID, SString & rBuf);
int    FASTCALL GetArticleSheetID(PPID arID, PPID * pAccSheetID, PPID * pLnkObjID = 0);
int    FASTCALL GetRegisterTypeName(PPID rtID, SString & rBuf);

enum PPArticleType {
	artypUnknown = 0,
	artypSuppl,
	artypBuyer,
	artypPayer,
	artypCntragnt
};

int    SLAPI GetArticleText(PPID, PPArticleType, SString & rBuf);
int    SLAPI AccIDToAcct(PPID id, int ord, Acct *);
int    SLAPI IsAccBelongToList(const Acct *, int side, const char * pList);
//
// Descr: конвертирует ид аналитической статьи в
//   ид персоналии, на которую эта статья ссылается. Если статья   //
//   ссылается не на персоналию, либо вообще не ссылается ни на
//   какой иной объект, то возвращает 0.
//
PPID   FASTCALL ObjectToPerson(PPID articleID, PPID * pAccSheetID = 0);
//
// Descr: производит простую операцию вычисления цены реализации по заданным цене
//   поступления, проценту наценки и параметрам округления. Опция force_dir указывает
//   в какую сторону необходимо округлять результат. Если force_dir < 0, то округляетс
//   до нижнего значения, если force_dir > 0, то до верхнего. 0 - до ближайшего.
//
double SLAPI CalcSelling(double cost, double pc, double prec, int force_dir);
double SLAPI CalcSelling(double cost, double pc);
double SLAPI Round(double v, double prec, int dir);
//
// Descr: округляет значение цены p в соответствии с параметрами, заданными в конфигурации
//
double SLAPI RoundUpPrice(double p);
int    FASTCALL CheckFiltID(PPID flt, PPID id);

class PPExtStringStorage {
public:
	PPExtStringStorage();
	int    Put(SString & rLine, int fldID, const char * pBuf);
	int    Get(const SString & rLine, int fldID, SString & rBuf);
	int    Enum(const SString & rLine, uint * pPos, int * pFldID, SString & rBuf);
private:
	CRegExp Re;
};

int    SLAPI PPGetExtStrData(int fldID, int defFldID, const SString & rLine, SString & rBuf);
int    SLAPI PPGetExtStrData(int fldID, const SString & rLine, SString & rBuf);
//
// Descr: Утилитный класс, используемый как базовый для классов, имеющих
//   строки расширения, идентифицируемые целочисленными значениями.
//
class PPExtStrContainer {
public:
	SLAPI  PPExtStrContainer();
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char * pStr);
	int    SLAPI SerializeB(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	void   FASTCALL SetBuffer(const char * pSrc);
	const  SString & SLAPI GetBuffer() const;
protected:
	SString ExtString;
};
//
// Descr: Сравнивает значения тегированных подстрок с идентификатором fldID в строке rLine1 и rLine2.
// ARG(fldID   IN): Идентификатор тега подстроки
// ARG(rLine1  IN): Первая строка, содержащая тегированную подстроку
// ARG(rLine2  IN): Вторая строка, содержащая тегированную подстроку
// ARG(options IN): Опции сравнения. Если установлен флаг srchNoCase (0x0200 slib.h)
//   то сравнение осуществляется без учета регистра символов.
// Returns:
//   0 - строки эквивалентны
//  <0 - строка из rLine1 лексикографически меньше, чем из rLine2
//  >0 - строка из rLine1 лексикографически больше, чем из rLine2
//
int    SLAPI PPCmpExtStrData(int fldID, const SString & rLine1, const SString & rLine2, long options);
int    SLAPI PPPutExtStrData(int fldID, SString & rLine, const char * pBuf);
//
// Descr: преобразует период *pPeriod в пересечение с периодом документов, определенным в правах
//   пользователя. Если результат является пустым, то возвращает 0 и устанавливает код ошибки (PPERR_NORTPERIOD).
//
int    FASTCALL AdjustPeriodToRights(DateRange & rPeriod, int checkOnly);
int    FASTCALL CalcBarcodeCheckDigit(const char * pBarcode);
int    FASTCALL CalcBarcodeCheckDigitL(const char * pBarcode, size_t len);
char * SLAPI AddBarcodeCheckDigit(char * pBarcode);
SString & SLAPI AddBarcodeCheckDigit(SString & rBarcode);
//
// Descr: Формирует строку штрихкода, пригодную для печати на обычном принтере
//   с использованием специализированных шрифтов.
// ARG(pBarcode IN): Символьная строка, содержащая штрихкод в формате, непосредственно редактируемом пользователем.
//   Функция принимает не более 63 символов из этого буфера.
// ARG(codeType IN): Тип кода.
//   0  - один из розничных штрихкодов (EAN13, EAN8, UPC-A, UPC-E). Исходя из длины кода pBarcode и символов, из
//        которых он состоит функция автоматически идентифицирует к какому из этих четырех типов принадлежит штрихкод.
//   39 - Code39. Этот код может содержать произвольное количество символов, включающих цифры и латинские заглавные буквы.
// ARG(pBuf    OUT): Указатель на буфер, в который функция запишет печатаемую версию штрихкода.
// ARG(bufLen   IN): Длина буфера pBuf. Функция не допускает переполнения буфера, если этот параметр не нулевой.
// Returns:
//   >0 - функция успешно конвертировала штрихкод
//   0  - ошибка. Переданный штрихкод не удовлетворяет ограничениям, накладываемым на заданный тип штрихкода.
//
int    SLAPI CreatePrintableBarcode(const char * pBarcode, int codeType, char * pBuf, size_t bufLen);
//int    SLAPI CreateBarcodeImage(const char * pBarcode, int codeType, int outpFormat, const char * pFileName);

class PPBarcode {
public:
	struct Entry {
		int    BcStd;
		SString Code;
	};
	static int SLAPI GetStdName(int bcstd, SString & rBuf);
	static int SLAPI RecognizeStdName(const char * pText);

	struct BarcodeImageParam {
		SLAPI BarcodeImageParam();
		enum {
			fWithCheckDigit = 0x0001 // Код содержит контрольную цифру
		};
		int   Std;               // BARCSTD_XXX Стандарт штрихкода
		long  Flags;
		int   OutputFormat;      // Формат вывода изображения:
			// 0 - в буфер Buffer, SFileFormat::Png, SFileFormat::Svg, SFileFormat::Gif, SFileFormat::Bmp
			// Остальные значения считаются инвалидными.
		int   Angle;             // Угол поворота изображения. Допустимы следующие значения: 0, 90, 180, 270
		TPoint Size;             // Размеры изображения в пикселах. Если 0, то используются размеры по умолчанию.
		SColor ColorFg;          // Цвет штрихов. Если ColorFg == ZEROCOLOR, то - черный
		SColor ColorBg;          // Цвет фона. Если ColorBg == ZROCOLOR, то - белый
		SString Code;            // Текстовое представление кода, который необходимо отобразить
		SString OutputFileName;  // Если oneof(OutputFormat, SFileFormat::Png, SFileFormat::Svg,
			// SFileFormat::Gif, SFileFormat::Bmp),
			// то изображение формируется в файле с этим именем. Расширение файла форсированно
			// заменяется на каноническое для соответствующего формата.
		SImageBuffer Buffer;     // Если OutputFormat == 0, то изображение формируется в этом буфере
	};

	static int SLAPI CreateImage(/*const char * pCode, int bcstd, int outpFormat, const char * pOutpFileName*/BarcodeImageParam & rParam);
	static int SLAPI RecognizeImage(const char * pInpFileName, TSCollection <PPBarcode::Entry> & rList);
	//
	// Descr: Конвертирует штрихкод в формате UPC-E в формат UPC-A
	// Note: Не проверяет входящий параметр pUpce на корректное представление UPC-E
	//
	static SString & FASTCALL ConvertUpceToUpca(const char * pUpce, SString & rUpca);
};
//
// Символьные обозначения и их транслятор
// @v8.6.1 define-->enum
//
enum {
	PPSYM_NONE = 0,
	PPSYM_LINK,        // @link       Связанный (документ и пр.)
	PPSYM_BILLNO,      // @billno     Номер документа
	PPSYM_DATE,        // @date       Дата
	PPSYM_PAYDATE,     // @paydate    Дата оплаты
	PPSYM_AMOUNT,      // @amount     Номинальная сумма
	PPSYM_LOCATION,    // @loc        Локация //
	PPSYM_OBJECT,      // @obj        Объект
	PPSYM_PAYER,       // @payer      Плательщик
	PPSYM_AGENT,       // @agent      Агент
	PPSYM_REGNAM,      // @regname    Наименование типа регистра
	PPSYM_REGSN,       // @regsn      Серия регистра
	PPSYM_REGNO,       // @regno      Номер регистра
	PPSYM_REGORG,      // @regorg     Регистрирующий орган
	PPSYM_TRADELIC,    // @tradelic   Торговая лицензия //
	PPSYM_BILLMEMO,    // @billmemo   Примечание к документу
	PPSYM_BILLOBJ2,    // @obj2       Дополнит объект по документу
	PPSYM_GC_NAME,     // @gcname     Наименование класса товара
	PPSYM_GC_KIND,     // @gckind     Вид товара
	PPSYM_GC_GRADE,    // @gcgrade    Сорт товара
	PPSYM_GC_ADDPROP,  // @gcaddprop  Доп свойство товара
	PPSYM_GC_DIMX,     // @gcdimx     Размерность X
	PPSYM_GC_DIMY,     // @gcdimy     Размерность Y
	PPSYM_GC_DIMZ,     // @gcdimz     Размерность Z
	PPSYM_ADVLNACC,    // @alacc      Счет из строки расширения бух. документа
	PPSYM_ADVLNAR,     // @alar       Статья из строки расширения бух. документа
	PPSYM_ADVLNAMT,    // @alamt      Сумма из строки расширения бух. документа
	PPSYM_RECKON,      // @rckn       Ссылка на зачетный документ из зачитывающего
	PPSYM_CLIENTADDR,  // @clientaddr Адрес контрагента
	PPSYM_GRNAME,      // @grname     Наименование группы товаров
	PPSYM_PHPERU,      // @phpu       Соотношение физ.ед/торг.ед в товаре
	PPSYM_BRAND,       // @brand      Торговая марка
	PPSYM_CLIENT,      // @client     Наименование клиента
	PPSYM_PARENT,      // .parent     Родительский объект, по отношению к предыдущему терму
	PPSYM_GC_ADD2PROP, // @gcadd2prop Доп 2 свойство товара
	PPSYM_GC_DIMW,     // @gcdimw     Размерность W
	PPSYM_TSESS,       // .tsess      Списываемая этим документом техн сессия //
	PPSYM_PRC,         // @prc        Наименование процессора
	PPSYM_TECH,        // @tech       Код технологической сессии
	PPSYM_MEMO,        // @memo       Примечание
	PPSYM_EXPIRY,      // @expiry     Дата окончания срока действия //
	PPSYM_AGTCODE,     // @agtcode    Номер соглашения с контрагентом
	PPSYM_AGTDATE,     // @agtdate    Дата соглашения с контрагентом
	PPSYM_AGTEXPIRY,   // @agtexpiry  Дата истечения срока действия соглашения с контрагентом
	PPSYM_MODEL,       // @model      (транспорт) Наименование модели
	PPSYM_CODE,        // @code       (транспорт) Регистрационный номер
	PPSYM_SUBCODE,     // @subcode    (транспорт) Регистрационный номер прицепа
	PPSYM_OWNER,       // @owner      (транспорт) Имя владельца
	PPSYM_CAPTAIN,     // @captain    (транспорт) Имя капитана (водителя)
	PPSYM_INVOICEDATE, // @invoicedate Дата счета-фактуры документа
	PPSYM_INVOICENO,   // @invoiceno   Номер счета-фактуры документа
	PPSYM_DLVRLOCCODE, // @dlvrloccode Код адреса доставки документа
	PPSYM_FGDATE,      // @fgdate      Дата в 'плоском' представлении (25032015)
	PPSYM_INN,         // @inn         ИНН персоналии.
	PPSYM_KPP,         // @kpp         КПП персоналии
	PPSYM_LOCCODE,     // @loccode     Код склада/адреса и т.д.
	PPSYM_DLVRLOCID,   // @dlvrlocid   ИД адреса доставки документа
    PPSYM_DUMMY        // @dummy       Пустое значение
};
//
class PPSymbTranslator {
public:
	SLAPI  PPSymbTranslator(uint strID = PPSSYM_SYMB);
	int    SLAPI operator !() const;
	//
	// Descr: пытается распознать слово по адресу (pString + (*pNextPos))
	//   и, если ей это удается, возвращает опознанный код (константа PPSYM_XXX).
	//   Индекс, на который указывает pNextPos, принимает значение следующего за
	//   распознанным словом символа. В случае неудачи этот индекс также может
	//   сместиться, так как функция самостоятельно пропускает пробелы и
	//   табуляции (' ', '\t'). Если pNextPos == 0, то полагается (*pNextPos == 0).
	//
	long   SLAPI Translate(const char * pString, size_t * pNextPos, uint flags = 0);
	long   SLAPI Translate(SStrScan & rScan);
	//
	// Descr: возвращает одну (первую) форму слова, соответствующего символу sym.
	//
	int    SLAPI Retranslate(long sym, char *, size_t bufLen) const;
	int    SLAPI Retranslate(long sym, SString & rBuf) const;
private:
	char * SLAPI NextStr(size_t * pPos, char * pBuf) const;

	int    ErrorCode;
	SString Coll;
};
//
//
//
class OptimalAmountDamper {
public:
    OptimalAmountDamper();
    int    GetOptimal(long & rPos, long * pExtPos, double * pOptQtty, double * pMaxPrice) const;
    int    Probe(double qtty, double price, long pos, long extPos = -1);
private:
    long   Pos;
    long   ExtPos;

    double OptQtty;
    double MaxPrice;
};
//
// Interobject message codes
//
#define DBMSG_OBJDELETE          1
#define DBMSG_OBJUPDATE          2
#define DBMSG_PERSONLOSEKIND     3
#define DBMSG_PERSONACQUIREKIND  4
#define DBMSG_OBJNAMEUPDATE      5
//
// Запрос на существование ссылок. Если существуют, то DBRPL_REFSFOUNDED иначе DBRPL_OK
// (пока работает лишь для избранных объектов. Полагаться на это сообщение в общем случае не следует).
//
#define DBMSG_CHECKREFS          6
//
// Запрос на существование ограничителей прав доступа. Если объект каким-либо образом
// квалифицирует права доступа, то в ответ на сообщение должен вернуть DBRPL_OK.
// Если объект полностью открыт, то должен вернуть DBRPL_CANCEL. Если объект возвращает
// DBRPL_OK, то он должен вернуть и количество байт, необходимых ему для хранения информации
// о правах. Это значение должно быть присвоено по адресу, передаваемому параметром extra
// функции HandleMsg как size_t.
//
#define DBMSG_SECURITY           7
//
// Извещение о том, что один объект замещается другим. Если объект, получивший это сообщение
// ссылается на замещаемый объект, то он должен либо заменить все ссылки новым идентификатором,
// либо, если не может этого сделать, вернуть код ошибки.
//
#define DBMSG_OBJREPLACE         8
//
// Добавлен склад.
// Частное сообщение, посылаемое объектом PPOBJ_LOCATION объекту
// PPOBJ_ARTICLE при создании нового склада для того, чтобы объект
// PPOBJ_ARTICLE мог создать статью, соответствующую этому складу.
//
#define DBMSG_WAREHOUSEADDED     9
#define DBMSG_DUMMY             10 // Пустое сообщение, необходимое для того, чтобы
	// все объекты данных создали необходимые таблицы в БД.
#define DBMSG_GLOBALACCADDED    11 // @v9.1.3 Посылается при создании новой глобальной учетной записи
//
// Object message reply codes
//
#define DBRPL_ERROR              0
#define DBRPL_OK                 1
#define DBRPL_CANCEL             2
#define DBRPL_REFSFOUNDED        3
//
// Замечание по приоритетам приема данных из других разделов (Priority):
// Приоритет по умолчанию:         1000
// Наивысший применяемый приоритет: 100 (для определений динамических объектов PPOBJ_DYNAMICOBJS)
// Приоритет тегов (PPOBJ_TAG):     120 (теги должны быть приняты до того, как начнут приниматься использующие их объекты)
// Остальные объекты должны выставлять приоритеты не ниже 121. При этом следует иметь в виду, что
// подавляющее большинство объектов будут иметь DefaultPriority (1000).
// Настоятельно рекомендуется использовать значения, кратные 10 для того, чтобы оставались
// зарезервированные "окна", которые можно будет использовать при необходимости.
//
// Приоритет 5000 используется для зависимых объектов, то есть тех, которые не должны
// акцептироваться в базе-приемнике самостоятельно (без объекта, от которого зависят).
//
struct PPObjPack {
	SLAPI  PPObjPack();
	enum {
		fDefinedHeader = 0x0001, //
		fCreationDtTm  = 0x0002, // Значение Mod является датой/временем создания (но не изменения) объекта
		fUpdate        = 0x0004, // Объект должен быть обновлен в разделе-получателе если его версия старше
		fForceUpdate   = 0x0008, // Объект должен быть безусловно обновлен в разделе-получателе
		fProcessed     = 0x0010, // internal use only
		fDispatcher    = 0x0020, // Раздел, в который принимается объект является диспетчером
		fSyncCmpObj    = 0x0040, // Пакет содержить только информацию о синхронизации
		fNoObj         = 0x0080, // Запись синхронизации виртуального объекта (например, лота)
		fRecover       = 0x0100  // @v8.2.3 Восстанавливающая передача объектов
	};
	SVerT SrcVer;               // Версия системы, сформировавшей пакет
	LDATETIME Mod;               // Дата/время модификации объекта в разделе-отправителе
	long   Priority;             // Приоритет обработки объекта при приеме данных
	long   Flags;                // Флаги (PPObjPack::fXXX)
	void * Data;                 // Данные пакета. Если (Flags & fSyncCmpObj) то данных нет
};
//
// Классы семейства PPObject организованы так, что если в некоторый
// момент времени существует несколько объектов одного класса, то они
// используют один экземпляр открытой таблицы данных. Это реализуется //
// либо через глобальный постоянно открытый объект таблицы данных, либо с
// помощью семафора. При этом, функции или классы создающие объекты классов
// семейства PPObject должны позаботиться о том, чтобы своевременно
// уничтожать созданные объекты.
//
// Любой экземпляр класса из семейства PPObject может иметь public-ссылку (или указатель)
// на соответствующую ему таблицу данных для использования извне. Из этого следует, что ни одна
// функция (внутренняя или внешняя по отношению к классу) не может полагаться на то, что позици
// файла данных сохранит свое значение сколько-нибудь продолжительное время.
//
// Функции-члены классов, порожденных от PPObject, должны быть терминальными в смысле обработки
// ошибок. То есть, в случае ошибки, они должны выдавать сообщения. Все вызовы этих
// функций обязаны полагаться на это их свойство.
//
class PPObject {
public:
	static int SLAPI ReplaceObj(PPID objType, PPID dest, PPID src, uint options /*= user_request*/);
	//
	// Descr: Открывает диалог объединения объектов типа objType.
	//   Если пользователь выбрал объекты для объединения и подтвердил выбор,
	//   то вызывается PPObject::ReplaceObj()
	//
	static int SLAPI ReplaceObjInteractive(PPID objType, PPID srcID = 0);
	//
	// Descr: Флаги функций MakeReserved и CreateReservedObjects
	//
	enum {
		mrfInitializeDb = 0x0001 // Функция MakeReserved должна создать объекты для пустой базы данных.
	};
	static int SLAPI CreateReservedObjects(long flags);
	static SString & SLAPI GetAcceptMsg(PPID objType, PPID objID, int upd, SString & rBuf);
	static int SLAPI Helper_PutConfig(PPID cfgPropID, PPID cfgObjType, int isNew, void * pData, size_t sz, int use_ta);
	//
	// Descr: Идентифицирует объект данных по символу типа pObjType и
	//   идентификатору или символу pObjIdent.
	// Note: Функция пока очень не совершенна: умеет идентифицировать только
	//   некоторые типы объектов.
	//
	static int SLAPI Identify(const char * pObjType, const char * pObjIdent, PPObjID * pIdent);

	static void SLAPI SetLastErrObj(PPID objType, PPID objID);
	static int  SLAPI IndexPhones();
	//
	// Если aObj != 0, то конструктор считывает поля Flags и OprFlags
	// записи прав доступа в поля Rt и ORt. Если при считывании прав
	// доступа произошла ошибка, то происходит Logout и выход из программы.
	// Если конкретный класс семейства PPObject требует дополнительных полей
	// из структуры прав доступа, то он должен их извлечь самостоятельно.
	//
	SLAPI  PPObject(PPID aObj = 0);
	virtual SLAPI ~PPObject();
	//
	// Descr: Проверяет наличие у текущего пользователя прав, заданных флагами
	//   rt для данного экземпляра объекта данных.
	//   Если в параметре rt задано более одного флага, то функция возвращает
	//   положительный ответ только если все эти права у пользователя есть.
	//
	int    FASTCALL CheckRights(long rt, int oprRights);
	//
	// Descr: == CheckRight(rt, 0)
	//
	int    FASTCALL CheckRights(long rt);
	//
	// Descr: Утилитная функция, текст которой выглядит так:
	//   {return pID ? CheckRights(*pID, PPR_MOD : PPR_INS) : (PPErrCode = PPERR_INVPARAM, 0);}
	//   Используется исключительно для уменьшения размера кода, так как эта конструкция //
	//   очень часто встречается.
	//   Кроме того, эта функция защищает вызывающую функцию от нулевого указателя pID.
	//
	int    SLAPI CheckRightsModByID(const PPID * pID);
	int    SLAPI GetLastModifEvent(PPID objID, LDATETIME *, int * pCr, SysJournalTbl::Rec * = 0);
	//
	// Descr: используя виртуальные функции Search и GetNamePtr находит и возвращает
	//   в буфере pBuf имя объекта с идентификатором id.
	//
	int    SLAPI GetName(PPID id, char * pBuf, size_t bufLen = 0);
	int    SLAPI GetName(PPID id, SString  * pBuf);
	//
	// Descr: определяет происходили ли с объектом с момента,
	//   определенного параметрами по указателям dt, tm, события,
	//   перечисленные в списке actions. Если да, то возвращает > 0,
	//   устанавливает указатель retAction в ID события, а значения по
	//   указателям dt, tm в соответствии с моментом события.
	//   Если возвращается (< 0), то такие события не происходили. 0 - ошибка.
	//   Если параметр actions == 0, то засекаются любые события по заданному объекту.
	//
	int    SLAPI IsLogged(PPID, PPIDArray * actions, LDATE * dt, LTIME * tm, PPID *);
	virtual int    SLAPI Browse(void * extraPtr);
	//
	// Descr: Функция редактирования нового либо существующего объекта данных.
	//   Если *pID != 0, должна самостоятельно извлечь объект из базы данных и вызывать
	//   диалог редактирования, чтобы пользователь смог изменить то, что ему надо.
	//   Если пользователь подтвердил сделанные изменения, функция должна сохранить
	//   запись объекта в базе данных.
	//   Если *pID == 0, то функция должна самостоятельно инициализировать запись объекта,
	//   возможно, с учетом параметра extraParam. После этого, вызывается диалог редактирования //
	//   и, если пользователь, подтвердил введенные данные, то функция должна создать
	//   новую запись объекта в базе данных и идентификатор созданной записи вернуть по адресу pID.
	//   Ошибка функция обрабатывает и сообщает о них пользователю самостоятельно.
	// Returns:
	//   cmOK -     пользователь что-то изменял и его работа была успешно зафиксирована в БД.
	//   cmCancel - пользователь отказался от изменения данных либо просто их не далал.
	//   0 - ошибка (функция сама должна сообщить пользователю о ней, если требуется).
	//
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	//
	// Descr: должна возвратить (> 0) если удаление состоялось без ошибок.
	//   Если была ошибка, то 0. Если пользователь не подтвердил удаление
	//   или оно не состоялось по какой-либо иной, не требующей дополнительной
	//   обработки, причине, то (<0). PPObject::Remove довольно развитая функция.
	//   Использует виртуальные методы Search и DeleteObj.
	//
	enum { // Remove's options
		use_transaction   = 0x0001, // Осуществляеть операцию внутри транзакции
		user_request      = 0x0002, // Запрашивать подтверждение на удаление и выводить сообщение об ошибке
		no_wait_indicator = 0x0004, // Не выводить окно "Подождите"
		rmv_default       = (use_transaction | user_request),
		not_addtolog      = 0x0008, // Не добавлять в журнал (для временных товарных групп)
		not_checkrights   = 0x0010, // Не проверять права (для временных товарныхгрупп)
		not_repl_remove   = 0x0020, // PPObject::ReplaceObj не удалять объединяемый объект
		not_objnotify     = 0x0040  // @v8.0.4  Удалять объект без посылки сообщений другим объектам (без проверки ссылочной целостности)
	};
	virtual int    SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
		// @>>PPObject::Search
		// @>>PPObject::DeleteObj
	//
	// Descr: должна физически удалить запись с идентификатором id
	//   и возможно другие связанные с ней записи (подотчетные данному объекту)
	//   без транзакции. Уведомления PPObjMessage посылать не следует. Перед
	//   вызовом DeleteObj функция PPObject::Remove устанавливает позицию в
	//   файле методом Search. В случае ошибки, DeleteObj должна установить
	//   PPErrCode. Никаких сообщений на экран выдавать не должна.
	//
	virtual int    SLAPI DeleteObj(PPID id); // @<<PPObject::Remove
	//
	// Descr: Очищает элемент с идентификатором id в кэше
	//   Общая реализация обрабатывает этот вызов, обращаясь к централизованному
	//   менеджеру объектных кэшей (see PPSession).
	// Returns:
	//   >0 - если объект id содержался в кэше и был очищен.
	//   <0 - если объекта id в кэше не было
	//   0  - ошибка
	//
	virtual int    SLAPI Dirty(PPID id);
	//
	// Если порожденный класс определяет виртуальную функцию MakeStrAssocList
	// и устанавливает в переменную ImplementFlags флаг implStrAssocMakeList,
	// то методы PPObject::Selector и PPObject::UpdateSelector реализуются автоматически
	// через использование этой функции.
	//
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	//
	// Descr: Метод PPObject::UpdateSelector по умолчанию вызывает
	//   функцию ListBoxDef::refresh. Это подходит для селекторов,
	//   использующих выборку с использованием DBQuery
	//
	virtual int    SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr); // @>>ListBoxDef::refresh()
	//
	// Descr: Метод ValidateSelection вызывается функцией PPObjListWindow::valid
	//   в ответ на команду cmOK. Если ValidateSelection возвращает
	//   (> 0) то все проходит как и должно пройти. Если 0, то команда
	//   отменяется. Если (< 0), то окно должно быть перерисовано в связи
	//   с какими-то изменениями, произведенными этой функцией. Этот
	//   код может быть использован для переопределения клавиши Enter
	//   или двойного нажатия мыши.
	//
	virtual int    SLAPI ValidateSelection(PPID, uint olwFlags, void * extraPtr); // @<<PPObjListWindow::valid()
	//
	// Descr: должна найти запись по идентификатору. Если запись найдена, то возвращает (>0).
	//   Если не найдена, то (<0). Ошибка - 0.
	//   Эта функция должна обязательно вернуть полную запись из таблицы и
	//   установить позицию записи (другими словами, использование кэширования для этой функции весьма ограничено).
	//
	virtual int    SLAPI Search(PPID id, void * = 0);
	//
	// Descr: Если эта функция реализована, то конструктор объекта должен установить в ImplementFlags
	//   бит implStrAssocMakeList. Функция должна создать список наименований объектов с учетом
	//   дополнительного параметра extraParam.
	//   В случае успешного завершения, функция должна вернуть указатель на созданный список
	//   StrAssocArray. Список разрушается вызывающей функцией.
	// Returns:
	//   !0 - указатель на созданный объект StrAssocArray
	//   0  - ошибка. Функция должна корректно установить значение PPErrCode
	//
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	//
	// Descr: реализует диалог редактирования прав доступа. Никаких модификаций в БД
	//   она делать не должна. Так как структура ObjRights имеет переменную длину, параметр
	//   bufSize передает размер буфера данных buf в пределах которого можно работать.
	//   Если объект не может уложиться в заданный размер он должен вернуть ошибку и
	//   установить PPErrCode = PPERR_OBJRTBUFSIZ.
	//   Для практических целей размер 32 байта будет более чем достаточен.
	//   Реальный размер записи прав доступа должен быть установлен функцией
	//   в поле ObjRights::Size.
	//   Эта функция не должна вызывать функцию интерактивного сообщения об ошибке.
	// Returns:
	//   >0 - Пользователь подтвердил редактирование прав
	//   <0 - Пользователь отменил или каким-либо иным образом редактирование не было
	//        подтверждено, но без ошибки
	//   0  - Ошибка
	// Note: Функция не обязана устанавливать поле ObjRights::ObjType,
	//   и не обязана проверять права пользователя на администрирование
	//   (то есть на изменение прав доступа).
	//
	virtual int    SLAPI EditRights(uint bufSize, ObjRights * buf, EmbedDialog * pDlg = 0);
	//
	// Descr: создает зарезервированные записи.
	// ARG(flags IN): 0 или один из флагов PPObject::mrfXXX
	//
	virtual int    SLAPI MakeReserved(long flags);
	virtual int    SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void   SLAPI Destroy(PPObjPack * p);
	//
	// Descr: Функция должна извлечь из потока (stream) или из базы данных (stream == 0)
	//   пакет объекта с идентификатором id.
	//   Если объект извлекается из базы данных и приоритет обработки объекта отличается //
	//   от обычного (1000), то в поле pPack->Priority функция должна установить требуемое значение.
	//
	virtual int    SLAPI Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	//
	// Descr: функция записи в поток или в базу данных бинарного представления объекта
	//   Извлеченное из базы данных или из потока представление храниться по указателю pPack->Data.
	//   Класс PPObjXXX сам определяет способ хранения представления объекта.
	// ARG(pPack IN) - Пакет, содержащий данные объекта (pPack->Data) и служебную информацию
	//   об условиях перемещения объекта (версия системы, создавшей объект, время последней
	//   модификации в разделе, передающем объект, флаги)
	// ARG(pID   IN/OUT) - Указатель на значение идентификатора объекта в принимающем разделе БД.
	//   Если *pID != 0, то вызывающая процедура, обрабатывающая прием объектов, идентифицировала
	//   объект (по таблице синхронизации), в противном случае, объект не был идетифицирован.
	//   Функция Write может самостоятельно идентифицировать объект по контекстным параметрам
	//   и вернуть по этому указателю измененное значение идентификатора.
	//   В любом случае, если функция Write создала или изменила объект, она обязана вернуть
	//   правильный идентификатор по этому указателю.
	// ARG(stream IN) - Если stream == 0, то функция должна записать объект в базу данных.
	//   В противном случае, stream - это указатель на структуру FILE, идентифицирующую файл,
	//   в который следует записать бинарное представление объекта.
	// ARG(reserve IN) - зарезервированный параметр. Должен быть 0.
	// Returns:
	//   0 -       Ошибка. Прием данных следует прервать.
	//   <0 -      Ошибка приема объекта. Прием данных следует продолжить.
	//   1 -       Объект успешно принят в базу данных или успешно записан в файловый поток.
	//   101 -     В окне журнала необходимо поместить сообщение о том, что объект успешно создан
	//   102 -     В окне журнала необходимо поместить сообщение о том, что объект успешно изменен
	//
	virtual int    SLAPI Write(PPObjPack * pPack, PPID * pID, void * stream, ObjTransmContext *);
	//
	// Returns:
	//   >0 - OK
	//   0  - Error
	//   -1 - OK ?
	//   -2 - Caller must skip receiving object
	//
	virtual int    SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	static  int    FASTCALL ProcessObjRefInArray(PPID, PPID *, PPObjIDArray *, int replace);
	static  int    FASTCALL ProcessObjRefInArray_NoPreprocess(PPID objTypeID, PPID * pObjID, PPObjIDArray * pArray, int replace);
	static  int    SLAPI ProcessObjListRefInArray(PPID, PPIDArray &, PPObjIDArray * pArray, int replace);
	// Возвращает PPObjListWindow
	virtual void * SLAPI CreateObjListWin(uint aFlags, void * extraPtr);

	enum {
		implTaggedStrMakeList = 0x0001, // Класс реализует виртуальнцю функцию TaggedStringArray * PPObject::MakeList_(long)
		implStrAssocMakeList  = 0x0002, // Класс реализует виртуальную функцию StrAssocArray * PPObject::MakeSStrAssocList(long)
		implTreeSelector      = 0x0004, // Класс реализует метод MakeSStrAssocList, возвращающий
			// древовидный список (функции Selector и UpdateSelector должна инициализировать StdTreeListBoxDef).
		implCharry            = 0x0008  // Объект поддерживает обмен по CHARRY
	};
	long   GetImplementFlags() const
	{
		return ImplementFlags;;
	}

	PPID   Obj;
	ObjFilterProc filt;
private:
	long   Rt_;  // Флаги доступа               // @v8.5.5 ushort-->long
	long   ORt_; // Операционные флаги доступа  // @v8.5.5 ushort-->long
	long   RightsUpdateCounter; // Значение счетчика PPThreadLocalArea::RightsUpdateCounter на момент получения значений Rt и ORt
protected:
	//
	// Descr: устанавливает идентификатор objID объекта objType как
	//   объект, на котором возникла ошибка (SetLastErrObj).
	//   Устанавливает код ошибки PPERR_REFSEXISTS и возвращает DBRPL_ERROR.
	//   Используется в функциях проверки наличия ссылок на объект.
	// Returns:
	//   DBRPL_ERROR
	//
	static int  FASTCALL RetRefsExistsErr(PPID objType, PPID objID);
	static int  FASTCALL ReadBlk(void * pBlk, size_t blkSize, void * stream);
	static int  FASTCALL WriteBlk(const void * pBlk, size_t blkSize, void * stream);
	static int  FASTCALL ReadSBuffer(SBuffer & rBuf, void * stream);
	static int  FASTCALL WriteSBuffer(SBuffer & rBuf, void * stream);

	virtual const char * SLAPI GetNamePtr();
	int    SLAPI RemoveSync(PPID);
	int    SLAPI EditSpcRightFlags(uint dlgID, uint flCtlID, uint sflCtlID, uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
	int    SLAPI EditPrereq(PPID * pID, TDialog * pDlg, int * pIsNew);
	void   FASTCALL Helper_GetRights(int onStartUp);

	long   ImplementFlags;
};

#define IMPL_DESTROY_OBJ_PACK(obj, typ) \
	void SLAPI obj::Destroy(PPObjPack * p) { if(p && p->Data) { delete ((typ *)p->Data); p->Data = 0; } }
#define IMPL_OBJ_FETCH(obj_cls, obj_rec, cache_cls) \
	int SLAPI obj_cls::Fetch(PPID id, obj_rec * pRec) \
	{ cache_cls * p_cache = GetDbLocalCachePtr <cache_cls> (Obj); return p_cache ? p_cache->Get(id, pRec) : Search(id, pRec); }
#define IMPL_OBJ_DIRTY(obj_cls, cache_cls) \
	int SLAPI obj_cls::Dirty(PPID id) \
	{ cache_cls * p_cache = GetDbLocalCachePtr <cache_cls> (Obj, 0); return p_cache ? p_cache->Dirty(id) : -1; }
//
// Descr: Проверяет наличие прав для конфигурации cfgID.
//
int SLAPI CheckCfgRights(PPID cfgID, ushort rt, int oprRights);
//
//
//
class TempAssoc {
public:
	static TempAssoc * SLAPI CreateInstance();
	SLAPI  TempAssoc();
	int    SLAPI IsValid() const;
	int    SLAPI Add(PPID prmrID, PPID scndID);
	int    SLAPI EnumPrmr(PPID * pPrmrID);
	int    SLAPI GetList(PPID prmrID, PPIDArray *);
private:
	TempAssocTbl * P_Tbl;
};
//
//
//
struct PPGeoTrackItem {
	SLAPI  PPGeoTrackItem();
	PPGeoTrackItem & FASTCALL operator = (const PPGeoTrackItem & rS);
	PPGeoTrackItem & FASTCALL operator = (const GeoTrackTbl::Rec & rS);
	int    FASTCALL Get(GeoTrackTbl::Rec & rD) const;

	enum {
        fNetworkProvider = 0x0001
	} ;

	PPObjID Oid;
	PPObjID ExtOid;
	LDATETIME Dtm;
	long   ExtEvent;
	long   Flags;
	double Latitude;
	double Longitude;
	double Altitude;   // Высота (м)
	double Speed;      // Скорость (м/с)
};

class GeoTrackCore : public GeoTrackTbl {
public:
	static LDATE FASTCALL ConvertStorageDate(int16 sd);
	static int16 FASTCALL GetStorageDate(LDATE dt);

    SLAPI  GeoTrackCore();
    int    SLAPI Search(PPObjID oid, LDATETIME dtm, PPGeoTrackItem * pItem);
    int    SLAPI PutItem(const PPGeoTrackItem & rItem, int use_ta);
    int    SLAPI PutChunk(const TSArray <PPGeoTrackItem> & rList, int use_ta);
};
//
// RegisterCore (Implemented in REGISTER.CPP)
//
int FASTCALL operator != (const RegisterTbl::Rec &, const RegisterTbl::Rec &);

struct PPBankAccount { // @#=sizeof(RegisterTbl::Rec)
	SLAPI  PPBankAccount();
	SLAPI  PPBankAccount(const RegisterTbl::Rec & rS);
	PPBankAccount & FASTCALL operator = (const RegisterTbl::Rec & rS);
	void   FASTCALL GetRegisterRec(RegisterTbl::Rec & rRec) const;

	PPID   ID;          // @# !0
	long   ObjType;     // Const=PPOBJ_PERSON
	long   PersonID;    //
	long   UnusedZero;  //
	long   RegTypeID;   // Const=PPREGT_BANKACCOUNT
	LDATE  OpenDate;    //
	long   BankID;      // ->Person.ID
	char   UnusedZ2[12]; //
	char   Acct[32];     // Номер счета
	LDATE  Expiry;       // Дата окончания действия счета
	long   UniqCntr;     // Счетчик, делающий индекс (RegTypeID, Serial, Number, UniqCntr) уникальным
	long   Flags;        //
	long   AccType;      //
};

class RegisterArray : public SArray {
public:
	SLAPI  RegisterArray();
	SLAPI  RegisterArray(const RegisterArray & s);
	RegisterTbl::Rec & FASTCALL at(uint pos) const;
	int    FASTCALL IsEqual(const RegisterArray & rS) const;
	int    FASTCALL HasEqual(const RegisterTbl::Rec & rRec) const;
	//
	// Descr: Ищет регистр типа regTyp начиная с позиции *pPos или 0 если pPos == 0.
	//   Если dt != ZERODATE, тогда проверяет чтобы дата истечения срока действия найденного
	//   регистра была либо нулевой либо больше или равна dt.
	// Returns:
	//   >0 - найдена запись удовлетворяющая условиям функции.
	//        По адресу pPos при этом присваивается позиция найденной записи +1,
	//        а по адресу pRec найденная запись.
	//   <0 - требуемая запись не найдена.
	//
	int    SLAPI GetRegister(PPID regTypeID, LDATE dt, uint * pPos, RegisterTbl::Rec * pRec) const;
	int    SLAPI GetListByType(PPID regTypeID, LDATE dt, RegisterArray * pList) const;
	int    SLAPI GetListByPeriod(PPID regTypeID, const DateRange & rPeriod, RegisterArray * pList) const;
	int    SLAPI GetBankAccountList(TSArray <PPBankAccount> * pList) const;
	int    SLAPI CheckDuplicateBankAccount(const PPBankAccount * pRec, long pos) const;
	//
	// Descr: Вносит в массив банковский счет pRec. Если pos >= getCount(),
	//   то добавляет новую запись, в противном случае - модифицирует существующую
	//
	int    SLAPI SetBankAccount(const PPBankAccount * pRec, uint pos);
	//
	// Descr: Ищет регистр типа regTyp начиная с позиции *pPos или 0 если pPos == 0.
	// Returns:
	//   >0 - найдена запись удовлетворяющая условиям функции.
	//   <0 - требуемая запись не найдена.
	//
	int    SLAPI GetRegister(PPID regType, uint * pos, RegisterTbl::Rec * pRec) const;
	int    SLAPI GetRegNumber(PPID regTyp, LDATE dt, SString & rBuf) const;
	int    SLAPI GetRegNumber(PPID regTyp, SString & rBuf) const;
	//
	// Descr: Возможные результаты выполнения функции SelectRegister
	//
	enum {
		srrNothing       = -1, // Нет ни одного подходящего регистра
		srrError         =  0, // Ошибка
		srrEmptyDateCrit =  1, // Критерий даты не задан (dt == ZERODATE)
		srrSingle        =  2, // Есть только один регистр, удовлетворяющий критериям
		srrMinStartDist  =  3, // Выбран регистр с минимальным расстоянием от даты начала действия
		srrMaxExpiryDist =  4, // Выбран регистр с максимальным расстоянием до даты истечения срока действия
		srrAmbig         =  5  // Есть более одного регистра, удовлетворящего критериям, с параметрами, не позволяющими
			// выбрать наиболее оптимальный вариант - выбран самый первый.
	};
	//
	// Descr: Выбирает из списка регистр максимально удовлетворяющий критерию даты dt.
	//   Правила отбора следующие:
	//   -- если dt == ZERODATE, то выбирается первый регистр, имеющий тип regType
	//   -- если есть более одного регистра с типом regType и dt != ZERODATE, то выбирается
	//      регистр с наименьшим не отрицательным расстоянием от даты dt до RegisterTbl::Rec::Dt (dt >= RegisterTbl::Rec::Dt)
	//   -- если нет регистра с не отрицательным расстоянием (dt - RegisterTbl::Rec::Dt), то выбирается регистр
	//      с наибольшим не отрицательным расстоянием от RegisterTbl::Rec::Expiry до dt (RegisterTbl::Rec::Expiry >= dt)
	//   В любом случае отбираются только регистры, дата начала и дата окончания которых не противоречат dt:
	//   (!dt || ((!RegisterTbl::Rec::Dt || dt >= RegisterTbl::Rec::Dt) && (!RegisterTbl::Rec::Expiry || dt <= RegisterTbl::Rec::Expiry)))
	// ARG(regType IN): Тип регистрационного документа
	// ARG(dt      IN): Дата актуальности искомого регистрационного документа
	// ARG(pPos   OUT): @#{vptr0} Опциональный указатель, по которому присваивается позиция найденного регистра.
	//  Позиция относительно 1. То есть, для получения по значению *pPos записи из массива необходимо
	//  уменьшить ее на 1
	//  {
	//     uint pos = 0;
	//     if(SelectRegister(reg_type_id, dt, &pos, 0) > 0)
	//         const RegisterTbl::Rec & r_rec = at(pos-1);
	//  }
	//  Если функцию вернула <= 0, то значение по указателю не изменяется.
	// ARG(pRec,  OUT): @#{vptr0} Опциональный указатель по которому присваивается найденная запись.
	//  Если функцию вернула <= 0, то запись по указателю обнуляется.
	// Returns:
	//   <0 - нет ни одного подходящего регистра
	//   0  - ошибка
	//   >0 - выбран регистр.
	//   Варианты возврата функции определены перечислением RegisterArray::srrXXX (см. выше)
	//
	int    SLAPI SelectRegister(PPID regTyp, LDATE dt, uint * pPos, RegisterTbl::Rec * pRec) const;
	//
	// Descr: Возвращает номер регистра, выбранного по правилам, определенным для метода SelectRegister()
	//
	int    SLAPI SelectRegNumber(PPID regTyp, LDATE dt, SString & rBuf) const;
	int    SLAPI Merge(const RegisterArray & rS);
	//
	// Descr: Сортирует массив {RegTypeID, Dt, Expiry}
	//
	void   SLAPI Sort();
	int    SLAPI ProcessObjRefs(PPObjIDArray * ary, int replace);
};
//
// Флаги записи RegisterTbl::Rec
//
#define PREGF_DUPNUMBER 0x0001L // {Серия,Номер} регистра могут дублироваться.
#define PREGF_INHERITED 0x0002L // @transient Наследуемый регистр

class RegisterCore : public RegisterTbl {
public:
	static int FASTCALL IsEqualRec(const RegisterTbl::Rec & rRec1, const RegisterTbl::Rec & rRec2);
	static int FASTCALL GetText(const RegisterTbl::Rec & rRec, SString & rBuf);
	static int FASTCALL CheckRecForFilt(const RegisterTbl::Rec & rRec, const RegisterFilt * pFilt);

	SLAPI  RegisterCore();
	int    SLAPI Search(PPID id, RegisterTbl::Rec * = 0);
	int    SLAPI Add(PPID *, RegisterTbl::Rec *, int use_ta);
	int    SLAPI Update(PPID, RegisterTbl::Rec *, int use_ta);
	int    SLAPI Remove(PPID, int use_ta);
	//
	// - Если pRec != 0, то функция устанавливает для персоналии personID регистр pRec.
	//   В этом случае параметр regTypeID игнорируется.
	// - Если pRec == 0, то функция удаляет регистры с типом regTypeID, принадлежащие персоналии.
	//   Если regTypeID == 0, удаляются все регистры, принадлежащие указанной персоналии.
	//
	int    SLAPI SetByPerson(PPID personID, PPID regTypeID, const RegisterTbl::Rec * pRec, int use_ta);
	//
	// Descr: Извлекает из БД список регистров, принадлежащих персоналии personID.
	// Returns:
	//   >0 - Найден по крайней мере один регистр
	//   <0 - Персоналия не содержит ни одного регистра
	//   0  - Ошибка
	//
	int    SLAPI GetByPerson(PPID personID, RegisterArray * pList);
	int    SLAPI GetByLocation(PPID locID, RegisterArray * pList);
	int    SLAPI GetByEvent(PPID eventID, RegisterArray * pList);

	int    SLAPI PutByEvent(PPID eventID, RegisterArray * pList, int use_ta);
	int    SLAPI PutByPerson(PPID personID, RegisterArray * pList, int use_ta);
	int    SLAPI PutByLocation(PPID locID, RegisterArray * pList, int use_ta);
	int    SLAPI SearchByNumber(PPID * pID, PPID regTypeID, const char * pSerial, const char * pNumber, RegisterTbl::Rec *);
	int    SLAPI SearchByFilt(const RegisterFilt *, PPIDArray * pResList, PPIDArray * pPsnList, PPIDArray * pRegTList);
	//
	// Descr: Функция аналогичная Add(), но с безусловным разрешением на дублирование номеров.
	// Note: @really private Не следует использовть иначе, как в экстренных случаях, требущих
	//   низкоуровневого вмешательства в управляемую уникальность нумерации в обход PPObjRegisterType
	//
	int    SLAPI Add_ForceDup(PPID * pID, RegisterTbl::Rec * pRec, int use_ta);
private:
	int    SLAPI GetUniqCntr(RegisterTbl::Rec * pRec, int forceDup);
	int    SLAPI _Get(PPID, PPID, RegisterArray *);
	int    SLAPI _Put(PPID, PPID, RegisterArray *, int use_ta);
};
//
//
//
class PPPerson { // Managed by class PersonCore
public:
	friend class PersonCore; // function PersonCore::Get need to have access to RelList

	SLAPI  PPPerson();
	PPPerson & FASTCALL operator = (const PPPerson &);
	void   SLAPI destroy();
	int    SLAPI AddRelation(PPID personID, PPID relTypeID, uint * pPos);
	int    SLAPI AddRelations(PPIDArray * pPersonList, PPID relTypeID, uint * pPos);
	int    SLAPI RemoveRelation(PPID personID, PPID relTypeID);
	//
	//     Descr: Удаляет отношения с персоналиями из списка pPersonList и типом отношения relTypeID
	//     Если pPersonList = 0, то будут удалены все отношения с типом отношения relTypeID
	//
	int    SLAPI RemoveRelations(PPIDArray * pPersonList, PPID relTypeID);
	int    SLAPI RemoveRelationByPos(uint pos);
	const  LAssocArray & SLAPI GetRelList() const;
	int    SLAPI GetRelList(PPID relTypeID, PPIDArray * pList) const;

	PersonTbl::Rec Rec;
	PPIDArray Kinds;
private:
	//
	// Descr: Список отношений с другими персоналиями.
	//   Каждое отношение храниться как {Key = PersonID, Val = PersonRelTypeID}
	//   В базе данных список отношений храниться в таблице ObjAssoc где:
	//   AsscType = PPASS_PERSONREL, PrmrObjID = this->Rec.ID, ScndObjID = RelList[].Key,
	//   Val1 = RelList[].Val
	//
	LAssocArray RelList;
};
//
// Флаги персоналий
//
#define PSNF_NOVATAX              0x00000001L // Освобожден от уплаты НДС (поставщики)
#define PSNF_CTRBANK              0x00000002L // Центральный банк страны (только банки)
#define PSNF_HASIMAGES            0x00000004L // К объекту присоединены картинки
#define PSNF_NONOTIFICATIONS      0x00000008L // Запрет на рассылку для этой персоналии

#define MAXSAMEPSNREL  4 // Максимальное число отношений между одинаковыми персоналиями

class PersonCore : public PersonTbl {
public:
	SLAPI  PersonCore();
	//
	// Descr: Определяет, принадлежит ли персоналия personID виду kindID.
	// Returns:
	//   >0 - персоналия personID принадлежит виду kindID
	//   0  - персоналия personID не принадлежит виду kindID
	//
	int    SLAPI IsBelongToKind(PPID personID, PPID kindID);
	int    SLAPI Put(PPID * pID, PPPerson * pPack, int use_ta);
	int    SLAPI Get(PPID id, PPPerson * pPack);
	int    SLAPI Search(PPID id, PersonTbl::Rec * pRec = 0);
	int    SLAPI SearchByName(const char * pName, PPID * pID, PersonTbl::Rec * pRec = 0);
	int    SLAPI SearchMainOrg(PersonTbl::Rec * pRec);
	int    SLAPI GetKindList(PPID personID, PPIDArray * pList);
	int    SLAPI AddKind(PPID id, PPID kind, int use_ta);
	int    SLAPI RemoveKind(PPID id, PPID kind, int us_ta);
	int    SLAPI GetVATFreePersonList(PPIDArray *);
	int    SLAPI PutRelList(PPID id, const LAssocArray *, int use_ta);
	//
	// Descr: Извлекает список отношений персоналии id с другими персоналиями.
	// ARG(id      IN): ИД персоналии
	// ARG(pList  OUT): список связей персоналии id с другими персоналиями
	// ARG(reverse IN): если !0, то функция извлекает список связей, идущих от других
	//   персоналий к той, которая имеет ИД = id.
	// Returns:
	//   >0 - функция отработала успешно
	//   <0 - нет ни одной связи
	//   0  - ошибка
	//
	int    SLAPI GetRelList(PPID id, LAssocArray * pList, int reverse = 0);
	int    SLAPI UpdateFlags(PPID id, long setF, long resetF, int use_ta);

	static int    SLAPI PutELinks(PPID id, PPELinkArray *, int use_ta);
	static int    SLAPI GetELinks(PPID id, PPELinkArray *);

	PersonKindTbl Kind;
	//
	// Descr: Структура отношения персоналия-персоналия //
	//   Является проекцией на записись таблицы БД ObjAssocTbl
	//
	struct RelationRecord { // @#size=sizeof(ObjAssocTbl::Rec)
		long   ID;             // @id
		long   AsscType;       // Const=PPASS_PERSONREL Тип ассоциации
		long   PrmrObjID;      // ИД первичного объекта
		long   ScndObjID;      // ИД вторичного объекта
		long   InnerNum;       // Номер вторичного объекта по внутренней классификации
		uint8  Reserve[48];    // @reserve
		long   RelTypeID;      // Тип отношения //
		long   Reserve2[3];    // @reserve
	};

	static int SLAPI Helper_GetELinksFromPropRec(const PropertyTbl::Rec * pRec, const size_t recLen, PPELinkArray * pList);
protected:
	int    SLAPI _SearchKind(PPID id, PPID kind);
	int    SLAPI PutKinds(PPID, PPPerson *);
};
//
// Типы локаций
//
#define LOCTYP_WAREHOUSE       1L // Склад | магазин
#define LOCTYP_WAREPLACE       2L // Складская зона хранения товара
#define LOCTYP_WHZONE          2L // Складская зона хранения товара
#define LOCTYP_ADDRESS         3L // Адрес персоналии
#define LOCTYP_DIVISION        4L // Структурное подразделение организации
#define LOCTYP_WAREHOUSEGROUP  5L // Группа складов

#define LOCTYP_WHCOLUMN        6L // Колонка зоны хранения //
#define LOCTYP_WHCELL          7L // Ячейка зоны хранения //
#define LOCTYP_WHAISLE         8L // Складской проход
#define LOCTYP_WHCELLAUTOGEN 100L // Специальное значение, используемое для выбора функции автоматической генерации ячеек для колонны.
//
// Флаги локаций
//
#define LOCF_VATFREE        0x0001L // Операции по складу освобождены от НДС
#define LOCF_MANUALADDR     0x0002L // Полный адрес задается в ручную //
#define LOCF_VOLUMEVAL      0x0004L // Объем места хранения задается одним значением
#define LOCF_COMPARABLE     0x0008L // Сравниваемый склад (обычно применяется в отношении магазинов для анализа данных)
#define LOCF_ADJINTRPRICE   0x0010L // При поступлении товара на этот склад через внутреннюю передачу
	//  с другого склада выравнивать учетную цену реализации по последенму лоту.
#define LOCF_WHAUTONAME     0x0020L // Автоматическое наименование для складской зоны/колонны/ячейки
	// (и для дочерних объектов)
#define LOCF_WHCODEPREFIX   0x0040L // @v7.1.11 В коды складских объектов добавлять как префикс код склада
#define LOCF_SEQCOLCODE     0x0080L // @v7.1.11 Сквозная нумерация колонн (не зависимо от принадлежности зоне)
#define LOCF_DISPOSEBILLS   0x0100L // @v7.1.12 Применять функции складского размещения для документов, принадлежащих этому складу
#define LOCF_STANDALONE     0x0200L // @v7.3.3  Автономный адрес. То есть, может быть не привязан ни к какому объекту.
	// Одновременно, если такой адрес привязан к объекту, то удаление объекта не влечет удаление адреса.


struct LocationFilt : public PPBaseFilt {
	SLAPI  LocationFilt(PPID locType = 0, PPID ownerID = 0, PPID parentID = 0);
	LocationFilt & FASTCALL operator = (const LocationFilt & rS);
	int    SLAPI GetExField(int fldId, SString & rBuf) const;
	int    SLAPI SetExField(int fldId, const char * pBuf);
	//
	// Descr: Идентификаторы дополнительных строк фильтрации
	//
	enum {
		exfPhone = 1 // Номер телефона
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   LocType;        // Тип локации (LOCTYP_XXX)
	PPID   Owner;          // Персоналия-владелец     ->Person.ID
	PPID   Parent;         // Локация верхнего уровня ->LocationID
	PPID   CurrID;         // Используется при создании нового элемента - ИД текущей записи в списке
	PPID   GoodsID;        // Товар, по наличию которого следует отбирать ячейки.
	uint8  Reserve[4];     // @anchor
	ObjIdListFilt ExtLocList; // @v8.1.9
	SString ExtString;        // @v8.3.2
 };
//
// Descr: Структура, описывающая особенности типа записи Location
//
struct LocTypeDescr {
	enum {
		fParentRequired = 0x0001, // Тип требует обязательного родительского объекта
		fParentDisabled = 0x0002, // Тип не может иметь родительского объекта
		fCodeRequired   = 0x0004  // Локация этого типа обязательно должна иметь не пустой код
	};
	int    LocType;        // Собственно, тип, который описывается данным дескриптором
	int    ParentLocType;  // Тип родительского объекта
	long   Flags;          // @flags
	SString Name;          // Строковое описание типа (извлекается из группирующей строки PPTXT_LOCTYPE)
};
//
// Идентификаторы строковых полей, хранящихся в хвостовой части записи LocationTbl
//
#define MAX_DLVRADDRFLDS     40 // Максимальное кол-во дополнительных полей адреса доставки // @v8.3.0 20-->40
#define MAX_DLVRADDRFLDLEN   64 // Максимальная длина дополнительного поля адреса доставки

#define LOCEXSTR_ZIP         1
#define LOCEXSTR_SHORTADDR   2
#define LOCEXSTR_FULLADDR    3
#define LOCEXSTR_PHONE       4   // @v7.0.7 Специальная опция для непривязанных (к персоналиям) адресов
#define LOCEXSTR_CONTACT     5   // @v7.3.1 Имя контактного лица, ассоциированного с адресом. Необходимость
	// в этом теге может быть обусловлена теми же причинами, что и LOCEXSTR_PHONE: адрес не связан с персоналией.
#define LOCEXSTR_EMAIL       6   // @v7.9.3 Специальная опция для непривязанных (к персоналиям) адресов
#define LOCEXSTR_EXTFLDSOFFS 100 // смещение для ид дополнительных полей адресов доставки

class LocationCore : public LocationTbl {
public:
	friend class PPTblEnum <LocationCore>;

	static int SLAPI GetAddress(const LocationTbl::Rec &, uint, SString & rBuf);
	static int FASTCALL IsEmptyAddressRec(const LocationTbl::Rec & rRec);
	static int SLAPI IsEqualRec(const LocationTbl::Rec & rRec1, const LocationTbl::Rec & rRec2);

	static int SLAPI GetExField(const LocationTbl::Rec * pRec, int fldId, SString & rBuf);
	static int SLAPI SetExField(LocationTbl::Rec * pRec, int fldId, const char * pBuf);
	//
	// Descr: Возвращает описатель типа локации locType.
	//
	static int SLAPI GetTypeDescription(int locType, LocTypeDescr * pDescr);

	SLAPI  LocationCore();
	SLAPI ~LocationCore();
	int    SLAPI Search(PPID id, LocationTbl::Rec * = 0);
	int    SLAPI SearchCode(PPID locType, const char * pCode, PPID * pID, LocationTbl::Rec * = 0);
	int    SLAPI GetListByCode(PPID locTyp, const char * pCode, PPIDArray * pIdList);
	int    SLAPI GetCodeByTemplate(const char * pTempl, SString & rBuf);
	int    SLAPI SearchMaxLike(const LocationTbl::Rec * pRec, long flags, PPID * pID, LocationTbl::Rec * pLikeRec = 0);
	//
	enum {
		eoParentAsOwner = 0x0001, // ИД родительского элемента (parentID) трактуется как LocationTbl::Rec::OwnerID
		eoIgnoreParent  = 0x0002  // parentID не трактуется как ограничение выборки.
	};
	SEnumImp * SLAPI Enum(PPID locTyp, PPID parentID, int options);
	int    SLAPI Add(PPID * pID, LocationTbl::Rec *, int use_ta);
	int    SLAPI SearchRef(PPID locType, PPID objType, PPID objID, PPID *);
	int    SLAPI SearchPersonRef(PPID locType, PPID personID, PPID *);
	int    SLAPI GetAddress_(PPID locID, uint flags, SString & rBuf);
	//
	//
	//
	int    SLAPI IndexPhone(const char * pPhone, const PPObjID * pObjId, int doRemove, int use_ta);
	int    SLAPI SearchPhoneIndex(const char * pPhone, long options, PPIDArray & rResultList);
	int    SLAPI GetEAddr(PPID id, EAddrTbl::Rec * pRec);
    int    SLAPI SearchEAddrByLink(PPID objType, PPID objID, PPIDArray & rResultList);
    int    SLAPI SearchEAddrMaxLikePhone(const char * pPhonePattern, long options, LongArray & rResult);
    int    SLAPI GetFullEaList(StrAssocArray & rList);
private:
	static int SLAPI Helper_IsEqExField(const LocationTbl::Rec & rRec1, const LocationTbl::Rec & rRec2, int fldId, SString & rBuf1, SString & rBuf2);
	int    SLAPI InitEnum(PPID locTyp, PPID parentID, int flags, long * pHandle);
	int    SLAPI Helper_GetCodeByTempl(const char * pPrfx, const char * pSfx, int len,
		long low, long upp, int addChkDig, SString & rCode);

	PPTblEnumList EnumList;
	EAddrCore * P_Eac;
};
//
//
//
struct PPEAddr { // @persistent size=16
	DECL_INVARIANT_C();
	int    Init(int type = tUndef);
	int    Set(uint32 ip4);
	int    Set(uint32 ip4Low, uint32 ip4Upp);
	int    SetPhone(const char * pPhone);
	int    GetPhone(SString & rBuf) const;
	int    FASTCALL operator == (const PPEAddr & rS) const;
	int    IsEmpty() const;

	enum {
		tUndef = 0,
		tIpV4,
		tIpV4Range,
		tIpV6,
		tIpV6Range,
		tPhone
	};
	struct IpV4 {
		uint32 A;
	};
	struct IpV4Range {
		uint32 Low;
		uint32 Upp;
	};
	struct IpV6 {
		uint8 A[6];
	};
	struct IpV6Range {
		uint8 Low[6];
		uint8 Upp[6];
	};
	struct Phone {
		static SString & FASTCALL NormalizeStr(const char * pOrgPhone, SString & rResult);
		static uint FASTCALL GenerateCheckNumber(const char * pOrgPhone, const char * pAddedumCode);
		static int  SLAPI VerifyCheckNumber(const char * pOrgPhone, const char * pAddedumCode, uint checkedNumber);

		DECL_INVARIANT_C();
		SString & FASTCALL ToStr(long fmt, SString & rBuf) const;
		int    FASTCALL FromStr(const char * pStr);
		//
		// Телефон кодируется в упакованном BCD формате. Т.е. каждые две цифры укладываются в один байт.
		// Символ 't' (тональный сигнал) кодируется как 0x0A, символ '+' кодируется как 0x0B.
		// Цифры от '0' до '9' кодируются как 0x00..0x09 соответственно.
		// Перед упаковкой номер освобождается от пробелов, тире и прочих символов отличных от 12-ти перечисленных.
		//
		uint8 A[12];
	};
	uint8  Type;       // Тип адреса (PPEAddr::tXXX)
	uint8  Flags;      // @reserve
	uint16 Reserve;    // @reserve
	union {
		IpV4 I4;
		IpV4Range I4R;
		IpV6 I6;
		IpV6Range I6R;
		Phone P;
	} U;
};

class PPEAddrArray : public TSArray <PPEAddr> {
public:
	SLAPI  PPEAddrArray();
	int    SLAPI AddPhone(const char * pPhone);
	int    SLAPI SearchPhone(const char * pPhone, long options, LongArray * pPosList) const;
};

class EAddrCore : public EAddrTbl {
public:
	SLAPI  EAddrCore();
	int    SLAPI Search(PPID id, EAddrTbl::Rec * pRec);
	int    SLAPI Search(const PPEAddr & rAddr, const PPObjID * pObjId, PPID * pID);
	int    SLAPI SearchLink(PPID objType, PPID objID, LongArray & rResult);
	int    SLAPI SearchIpV4(uint32 ip, long options, LongArray & rResult);
	int    SLAPI SearchPhone(const char * pPhone, long options, LongArray & rResult);
	int    SLAPI SearchMaxLikePhone(const char * pPhonePattern, long options, LongArray & rResult);
	int    SLAPI Put(PPID * pID, PPEAddr * pAddr, const PPObjID * pObjId, int use_ta);
};
//
// Descr: Структура соглашения с клиентом об условиях торговли
//   Хранится в таблице Property с координатами {PPOBJ_ARTICLE, ArtID, ARTPRP_CLIAGT}
//
//
#define AGTF_DEFAULT             0x0001L // @transient Default agreement. @*PPObjArticle::GetClientAgreement()
#define AGTF_LOADED              0x0002L // @transient Если этот флаг установлен, то структура извлечена из БД.
#define AGTF_DONTCALCDEBTINBILL  0x0004L // Не рассчитывать долг по клиенту в документах
#define AGTF_PRICEROUNDING       0x0008L // Округлять окончательную цену реализации в документах
#define AGTF_PRICEROUNDVAT       0x0010L // Окончательную цену округлять до значения, кратного ставке НДС
#define AGTF_USEMARKEDGOODSONLY  0x0020L // Для этого контрагента в товарный документ можно вставлять только
	// товары, имеющие код, связанный со статьей.
#define AGTF_SUBCOSTONSUBPARTSTR 0x0040L // При распределении по документу частичной структуры
	// с уменьшением начального количества, уменьшать себестоимость документа. Если этот
	// флаг не установлен, тогда себестоимость уменьшаемого товара ложится на компенсирующие
	// компоненты структуры.
	// @seealso GSIF_SUBPARTSTR
#define AGTF_AUTOORDER           0x0080L // Рассчитывать для данного поставщика заказ автоматически
#define AGTF_DDLIST715           0x0100L // @v7.1.5 Установленный флаг означает, что в БД запись сохранена с форматом списка DebtLimitList v7.1.5
#define AGTF_USESDONPURCHOP      0x0200L // @v7.2.1 Применять ограничение контрактных цен на операции закупки
#define AGTF_DONTUSEMINSHIPMQTTY 0x0400L // @v8.4.2 Не следует применять минимальное отгружаемое количество (GoodsStockExt;:MinShippmQtty)

struct PPClientAgreement { // @persistent
	SLAPI  PPClientAgreement();
	SLAPI  PPClientAgreement(const PPClientAgreement &);
	int    SLAPI Init();
	int    SLAPI IsEmpty() const;
	int    FASTCALL IsEqual(const PPClientAgreement & rS) const;
	PPClientAgreement & FASTCALL operator = (const PPClientAgreement &);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	//
	// Descr: Возвращает кредитный лимит контрагента, возможно, привязанный к долговой размерности debtDimID.
	//
	double SLAPI GetCreditLimit(PPID debtDimID) const;
	//
	// Desecr: Если с (не нулевой) долговой размерностью debtDimID ассоциирован
	//   признак Stop, то возвращает 1, иначе 0.
	//   Если соглашение не содержит элемента, ассоциированного с debtDimID,
	//   то функция возвращает -1 (признак Stop должен быть определен из аналитической статьи).
	//
	int    FASTCALL IsStopped(PPID debtDimID) const;

	struct DebtLimit {
		enum {
			fStop = 0x00000001L
		};
		PPID   DebtDimID;
		double Limit;
		long   Flags;
		LDATE  LockPrcBefore;  // @v7.1.5 Дата, до которой процессинг должников не меняет параметры размерности //
	};

	PPClientAgreement::DebtLimit * FASTCALL GetDebtDimEntry(PPID debtDimID) const;

	PPID   ClientID;       //
	long   Flags;          //
	LDATE  BegDt;          //
	LDATE  Expiry;         //
	double MaxCredit;      // Максимальный кредит
	double MaxDscnt;       // Максимальная скидка в %% (>= 100% - неограниченная)
	double Dscnt;          // Обычная скидка в %%
	int16  DefPayPeriod;   // Количество дней от отгрузки до оплаты по умолчанию
	int16  PriceRoundDir;  // Направление округления окончательной цены в документах
	PPID   DefAgentID;     // Агент, закрепленный за клиентом
	PPID   DefQuotKindID;  // Вид котировки, закрепленный за клиентом
	PPID   ExtObjectID;    // Дополнительный объект (таблица дополнительных объектов для общего соглашения)
	LDATE  LockPrcBefore;  // Дата, до которой процессинг должников не меняет параметры соглашения //
	char   Code[12];       // Номер соглашения //
	float  PriceRoundPrec; // Точность округления окончательной цены в документах
	int16  RetLimPrd;      // @v7.1.5 Период ограничения доли возвратов от суммы товарооборота
	uint16 RetLimPart;     // @v7.1.5 Макс доля возвратов от суммы товарооборота за период RetLimPrd (в промилле)
	//
	// Descr: Значения базы определения даты оплаты по документу
	//
	enum {
		pdbMain           = 0, // Основная дата документа
		pdbInvoice        = 1, // Дата счет-фактуры
		pdbFreightIssue   = 2, // Дата отправления (фрахт)
		pdbFreightArrival = 3, // Дата прибытия (фрахт)

		pdbTagBias        = 1000 // Если значение PaymDateBase выше pdbTagBias, то базовая дата извлекается из тэга
	};
	//
	// @v8.4.2 База для определения даты оплаты по документу.
	//
	long   PaymDateBase;
	uint8  Reserve2[4];    // @reserve
	TSArray <DebtLimit> DebtLimList; // долговые ограничения по командам агентов
};

class PPSupplAgreement {    // @persistent @store(PropertyTbl)
public:
	SLAPI  PPSupplAgreement();
	PPSupplAgreement & Clear();
	int    SLAPI IsEmpty() const;
	int    FASTCALL IsEqual(const PPSupplAgreement & rS) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    FASTCALL RestoreAutoOrderParams(const PPSupplAgreement & rS);

	enum {
		invpaRestrict  = 0,
		invpaWarning   = 1,
		invpaDoNothing = 2,
	};
	//
	// Descr: Параметры обмена данными с поставщиком.
	//   Вводится как замена структуры PPSupplExchangeCfg
	//
	class ExchangeParam {
	public:
		// Только этому классу дадим доступ к Serialize_ так как PPSupplAgreement контролирует
		// версию формата обмена
		friend class PPSupplAgreement;

		SLAPI  ExchangeParam();
		ExchangeParam & FASTCALL operator = (const ExchangeParam & rS);
		//
		// Descr: Функция, преобразующая конфигурацию формата до v8.5.0 в текущую
		//
		ExchangeParam & FASTCALL operator = (const PPSupplExchangeCfg & rS);
		int    FASTCALL Copy(const ExchangeParam & rS);
		int    FASTCALL IsEqual(const ExchangeParam & rS) const;
		ExchangeParam & Clear();
		int    SLAPI IsEmpty() const;
		int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
		int    SLAPI PutExtStrData(int fldID, const char * pStr);

		enum {
			extssClientCode   = 1, // Код данного клиента на сервере поставщика
			extssEDIPrvdrSymb = 2, // Символ провайдера EDI
			extssRemoveAddr   = 3, // @v9.2.0 Адрес для обмена данными (это может быть e-mail, url иди каталог)
			extssAccsName     = 4, // @v9.2.0 Имя аккаунат для доступа к обмену данными
			extssAccsPassw    = 5, // @v9.2.0 Пароль для доступа к обмену данными
			extssTechSymbol   = 6  // @v9.2.1 Символ технологии обмена
		};
		LDATE  LastDt;         // Дата последнего обмена
		PPID   GoodsGrpID;     // Группа товаров
		PPID   ExpendOp;       // Вид операции отгрузки
		PPID   RcptOp;         // Операция прихода
		PPID   SupplRetOp;     // Операция возврата поставщику
		PPID   RetOp;          // Операция возврата от покупател
		PPID   MovInOp;        // Перемещение со склада (расход)
		PPID   MovOutOp;       // Перемещение на склад (приход)
		PPID   PriceQuotID;    // Котировка по которой будем назначать цену в документах
		uint32 ProtVer;        // Версия протокола обмена
		struct FlatBlock {
			PPID   DefUnitID;      // @v9.2.4
			PPID   SequenceID;     // @v9.4.2 Внутренний счетчик для автоматической нумерации запросов
			PPID   CliCodeTagID;   // @v9.4.4 Тег персоналии для кода в терминах поставщика
			PPID   LocCodeTagID;   // @v9.4.4 Тег локации для кода в терминах поставщика
			PPID   StyloPalmID;    // @v9.5.5 Ссылка на запись группы устройств для получения некоторых атрибутов
				// Не смотря на то, что обмен с поставщиком не задействует непосредственно устройства StyloAgent,
				// функцинонально он может обеспечивать аналогичных набор сервисов. Соответственно, логично будет
				// не дублировать здесь атрибуты аналогичные StyloAgent, но сделать специальную запись StyloAgent
				// и администрировать такие атрибуты там.
			PPID   BillAckTagID;   // @v9.5.7 Тег документа, свидетельствующий о том, что он был передан поставщику.
				// Имеется в виду, как правило, документ продажи покупателю (возврата от покупателя) подукции
				// этого поставщика. Тип этого тега - строка или GUID. В качестве значения - какой-либо идентификатор,
				// присвоенный системой поставщика документу.
			uint8  FbReserve[8];   // @reserve @v9.2.4 [32]-->[28] // @v9.4.4 [24]-->[16]
		} Fb;                      // @anchor
        InetAddr ConnAddr;         // Адрес для соединения с сервером
        ObjIdListFilt DebtDimList; // @v9.1.3 Список долговых размерностей, по которым необходимо отчитываться о долгах контрагентов
	private:
		int    SLAPI Serialize_(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    SLAPI Serialize_Before_v9103_(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		SString ExtString;
	};
	//
	// Descr: Параметры расчета заказа поставщику
	//
	struct OrderParamEntry {
		SLAPI  OrderParamEntry();
		int    FASTCALL IsEqual(const OrderParamEntry & rS) const;
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		PPID   GoodsGrpID;       // ->Goods2.ID
		PPID   LocID;            // ->Location.ID
		PPID   MngrID;           // ->Person.ID Менеджер, закрепленный за этой группой закупки
		int16  OrdPrdDays;       // Период для расчета заказа поставщику при автоматическом формировании документов заказа поставщику (дней)
		int16  Reserve;          // @alignment
		DateRepeating Dr;        // Периодичность заказа
		struct FlatBlock {
			int16  DuePrdDays;    // Период исполнения заказа поставщиком (дней)
			uint8  FbReserve[30]; // @reserve
		} Fb;                     // @anchor
	};

	int    SLAPI SearchOrderParamEntry(const PPSupplAgreement::OrderParamEntry & rKey, int thisPos, uint * pFoundPos) const;
	int    SLAPI SetOrderParamEntry(int pos, PPSupplAgreement::OrderParamEntry & rEntry, uint * pResultPos);

	SVerT Ver;              // @v8.5.0 Версия системы, создавшей экземпляр
	PPID   SupplID;
	long   Flags;
	LDATE  BegDt;
	LDATE  Expiry;
	int16  DefPayPeriod;     // Количество дней от отгрузки до оплаты по умолчанию
	int16  InvPriceAction;   // Действие при неверной цене
	int16  DefDlvrTerm;      // Срок доставки товара в днях, начиная с даты документа закупки
	int16  PctRet;           // Максимальный объем возврата товара по накладной в процентах от суммы накладной //
	// @v8.5.2 int16  OrdPrdDays;       // Период для расчета заказа поставщику при автоматическом формировании документов заказа поставщику (дней)
	int16  Reserve_opd;      // @v8.5.2 @reserve Чтобы не ломать формат сериализации заменим устаревший OrdPrdDays на Reserve_opd
	int16  Reserve;          // @alignment
	PPID   DefAgentID;       // Агент, закрепленный за поставщиком
	PPID   CostQuotKindID;   // ! Вид котировки, управляющей контрактными ценами поставщиков
	PPID   PurchaseOpID;     // ! Вид операции закупки (драфт-приход)
	PPID   DevUpQuotKindID;  // ! Вид котировки, ограничивающий верхнюю границу отклонения фактических цен от контрактных
	PPID   DevDnQuotKindID;  // ! Вид котировки, ограничивающий нижнюю границу отклонения фактических цен от контрактных
	PPID   MngrRelID;        // ! Тип отношения, определяющий привязку поставщиков к менеджерам
	//PPSupplExchangeCfg ExchCfg; // Конфигурация обмена данными для данного поставщика @obsolete since @v8.5.0
	DateRepeating Dr;        // @v8.5.0
	// @v8.5.0 int16  OrdDrPrd;         // Календарь для автоматического создания документов
	// @v8.5.0 int16  OrdDrKind;        // заказа поставщику
	// @v8.5.0 int32  OrdDrDtl;         //
	struct FlatBlock {
		uint8  FbReserve[32]; // @reserve
	} Fb;                    // @v8.5.0
	ExchangeParam Ep;        // @anchor @v8.5.0
	TSArray <OrderParamEntry> OrderParamList; // @v8.5.0
};
//
//
//
class ArticleCore : public ArticleTbl {
public:
	SLAPI  ArticleCore();
	int    SLAPI Add(PPID * pID, void *, int use_ta);
	int    SLAPI Update(PPID, void *, int use_ta);
	int    SLAPI Remove(PPID, int use_ta);
	int    SLAPI Search(PPID, void * = 0);
	int    SLAPI SearchName(PPID accSheetID, const char * pName, void * = 0);
	int    SLAPI EnumBySheet(PPID sheetID, long * pArticleNo, void * = 0);
	int    SLAPI GetListBySheet(PPID accSheetID, PPIDArray * pList, long * pCount);
	int    SLAPI GetListByGroup(PPID grpArID, PPIDArray * pList);
	int    SLAPI Count(PPID accSheetID, long * pCount);
	//
	// Descr: Если в функции SearchNum параметр articleNo равен 0, то
	//   ищется первая статья для таблицы accSheetID.
	//
	int    SLAPI SearchNum(PPID accSheetID, long articleNo, void * = 0);
	int    SLAPI SearchFreeNum(PPID accSheetID, long * pArticleNo, void * = 0);
	int    SLAPI SearchObjRef(PPID accSheetID, PPID objID, ArticleTbl::Rec * pRec = 0);
	int    SLAPI PersonToArticle(PPID personID, PPID accSheetID, PPID * pArID);
private:
	int    SLAPI _SearchNum(PPID accSheetID, long articleNo, int spMode, void * = 0);
};
//
// Descr: Вспомогательная структура для обработки сумм документа
//
struct AmtEntry { // @persistent
	SLAPI  AmtEntry();
	SLAPI  AmtEntry(PPID amtTypeID);
	SLAPI  AmtEntry(PPID amtTypeID, PPID curID);
	SLAPI  AmtEntry(PPID amtTypeID, PPID curID, double amt);
	int    FASTCALL IsEqual(const AmtEntry & rS) const;

	PPID   AmtTypeID; // ->Ref(PPOBJ_AMOUNTTYPE)
	PPID   CurID;     // ->Ref(PPOBJ_CURRENCY)
	double Amt;
};

class AmtList : public TSArray <AmtEntry> { // @persistent
public:
	SLAPI  AmtList();
	AmtList & FASTCALL operator = (const AmtList &);
	int    SLAPI Search(PPID amtTypeID, PPID curID, uint * pPos) const;
	int    FASTCALL HasAmtTypeID(PPID amtTypeID) const;
	int    FASTCALL HasVatSum(const TaxAmountIDs * pTai) const;
	int    FASTCALL IsEqual(const AmtList *) const;
	//
	// Descr: возвращает список валют, для которых существует
	//   сумма amtTypeID в списке сумм. Если amtTypeID < 0, то возвращаетс
	//   список всех валют, которые присутствуют в списке сумм.
	//
	int    SLAPI GetCurList(PPID amtTypeID, PPIDArray *) const;
	int    SLAPI GetAmtTypeList(PPIDArray *) const;
	int    SLAPI Get(PPID amtTypeID, PPID curID, double *) const;
	double SLAPI Get(PPID amtTypeID, PPID curID) const;
	int    SLAPI Put(PPID amtID, PPID curID, double, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    SLAPI Put(const AmtEntry *, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    SLAPI Put(const AmtList  *, int ignoreZero /*= 1*/, int replace /*= 0*/);
	int    SLAPI Add(PPID amtID, PPID curID, double, int ignoreZero = 1);
	int    SLAPI Add(const AmtEntry *, int ignoreZero = 1);
	int    SLAPI Add(const AmtList  *, int ignoreZero = 1);
	int    SLAPI Sub(const AmtEntry *, int ignoreZero = 1);
	int    SLAPI Sub(const AmtList  *, int ignoreZero = 1);
	//
	// If curID < 0, then removed amounts with id amtTypeID by all currencies
	//
	int    SLAPI Remove(PPID amtTypeID, PPID curID);
};
//
// Descr: Сумма, связанная со штатной должностью либо штатным назначением.
//   Отличается от AmtEntry наличием периода действия.
//
struct StaffAmtEntry {
	DECL_INVARIANT_C();
	SLAPI  StaffAmtEntry(PPID amtTypeID = 0, PPID curID = 0, double amt = 0.0);
	int    FASTCALL IsEqual(const StaffAmtEntry & rS) const;

	PPID   AmtTypeID; // ->Ref(PPOBJ_AMOUNTTYPE)
	PPID   CurID;     // ->Ref(PPOBJ_CURRENCY)
	DateRange Period; // Период действия суммы
	double Amt;
};
//
// Descr: Список штатных сумм
//
class StaffAmtList : public TSArray <StaffAmtEntry> {
public:
	SLAPI  StaffAmtList();
	int    FASTCALL IsEqual(const StaffAmtList & rS) const;
	int    SLAPI Search(PPID amtTypeID, PPID curID, LDATE dt, uint * pPos) const;
	int    SLAPI Search(PPID amtTypeID, uint * pPos) const;
	//
	// Descr: Ищет в списке запись по критериям {amtTypeID, curID, dt}. Если находит,
	//   то по адресу pAmount присваивает значение суммы из найденного элемента.
	//   Если не находит, то по указателю pAmount присваивает 0.
	// Returns:
	//   >0 - искомый элемент найден
	//   <0 - искомый элемент не найден (*pAmount = 0)
	//   0  - ошибка (*pAmount = 0)
	//
	int    SLAPI Get(PPID amtTypeID, PPID curID, LDATE dt, double * pAmount) const;
	int    SLAPI CheckDup(int pos, const StaffAmtEntry *) const;
	int    SLAPI Add(const StaffAmtEntry *);
	int    SLAPI Put(uint pos, const StaffAmtEntry *);
};
//
// Package Declarations
//
#define PCKGF_UNIQUECODE 0x0001 // Код пакета, в соответствии с типом пакета, должен быть уникальным
#define PCKGF_MOUNTED    0x0002 // Пакет собран из существующих лотов
	// В этом случае используются сдвоенные операции перемещения товара,
	// аналогичные межскладской передаче.
#define PCKGF_SERIALCODE 0x0004 // Серийный номер лота. Пакет привязан
	// к одному лоту и не содержит элементов.
#define PCKGF_MIRROR     0x0008

class LPackage : private SArray {
public:
	SLAPI  LPackage();
	LPackage & FASTCALL operator = (const LPackage &);
	int    SLAPI Init();
	int    FASTCALL Copy(const LPackage &);
	int    SLAPI GetLotIDList(PPIDArray *) const;
	int    SLAPI SearchByID(PPID, int * pIdx) const;
	int    SLAPI SearchByIdx(int, PPID *) const;
	int    SLAPI AddLotIDList(const PPIDArray *);
	int    SLAPI AddItem(PPID lotID, int idx);
	int    SLAPI RemoveByID(PPID lotID);
	int    SLAPI RemoveByIdx(int idx);

	int    SLAPI EnumItems(uint * pI, int * pIdx, PPID * pID) const;
	int    SLAPI UpdateItem(uint i, int, PPID);
	int    FASTCALL ShiftIdx(int idx);

	PPID   ID;         //
	//
	// При передаче пакета на другой склад меняется его идентификатор
	// (так как он становится собственностью лота, образованного в результате межскладской передачи).
	// Для правильной идентификации пакета, при изменении его функцией PackageCore::PutPckg,
	// используется поле PrevID. Поле PrevID инициализируется функцией PPBillPacket::InitPckg.
	//
	PPID   PrevID;     //
	PPID   PckgTypeID;
	PPID   LocID;
	char   Code[16];
	int16  Closed;
	int16  UniqCntr;
	long   Flags;

	int16  PckgIdx;

	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
};

class LPackageList : public SCollection {
public:
	SLAPI  LPackageList();
	SLAPI ~LPackageList();

	int    SLAPI Add(const LPackage *);
	int    SLAPI ShiftIdx(int16);
	int    SLAPI RemoveByIdx(int16);
	LPackage * SLAPI GetByID(PPID);
	LPackage * SLAPI GetByIdx(int16);
	int    SLAPI EnumItems(uint *, LPackage **);
	int    SLAPI CheckCodeUnique(PPID pckgTypeID, const char *, int pos);
private:
	virtual	void FASTCALL freeItem(void *);
};

struct PckgFilt {
	PPID   PckgTypeID;
	PPID   GoodsID;
	PPID   LocID;
};

class PackageCore : public PackageTbl {
public:
	SLAPI  PackageCore();
	int    SLAPI Search(PPID, PackageTbl::Rec *);
	int    SLAPI SearchPrev(PPID prevID, PackageTbl::Rec *);
	int    SLAPI GetPckg(PPID, LPackage *);
	int    SLAPI PutPckg(PPID, const LPackage *, int use_ta);
	int    SLAPI SetClosedTag(PPID, int, int use_ta);

	int    SLAPI GetPckgLinkList(PPID, PPIDArray *);
	int    SLAPI GetLotLink(PPID lotID, PPID * pPckgID, PackageTbl::Rec * = 0);
	int    SLAPI AddPckgLink(PPID pckgID, PPID lotID);
	int    SLAPI RemovePckgLink(PPID pckgID, PPID lotID);

	int    SLAPI SearchByCode(PPID pckgTypeID, const char * pCode, PPIDArray *);
	int    SLAPI CheckCodeUnique(PPID pckgTypeID, PPID pckgID, const char *, long * pCntr);
	int    SLAPI AdjustUniqCntr(PackageTbl::Rec *);
private:
	PackageLinkTbl PL;
};
//
// Флаги товарных проводок
//
#define PPTFR_RECEIPT      0x00000001L // Строка генерирует запись лота
#define PPTFR_UNITEINTR    0x00000002L // Межскладскую передачу проводить одним документом по обоим складам
#define PPTFR_SELLING      0x00000004L // Операция в ценах реализации, иначе в ценах поступления //
//
// Временный флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
// установить флаг LOTF_ORDRESERVE для создаваемого лота
//
// #v7.8.10 #define PPTFR_ORDRESERVE   0x00000008L
#define PPTFR_CORRECTION   0x00000008L // Строка принадлежит корректирующему документу
//
// Временный флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
// изменить признак Closed лота и установить (снять) флаг LOTF_CLOSEDORDER
//
#define PPTFR_CLOSEDORDER  0x00000010L
#define PPTFR_LOTSYNC      0x00000020L // @v7.6.1 Строка документа, принятого из другого раздела и синхронизированная с ним по LotID
#define PPTFR_REVAL        0x00000040L // Признак переоценки
//
// Флаг PPTFR_ONORDER проставляется в строке товарного документа на продажу товара если эта строка покрывает
// (частично, полностью, либо перекрывает) строку ордера. При этом в структуре PPTransferItem
// используется поле OrdLotID (CorrLoc считается равным нулю).
//
#define PPTFR_ONORDER      0x00000080L
#define PPTFR_ORDER        0x00000100L // Строка заказа. При этом GoodsID < 0 и строка порождает лот (Flags & PPTFR_RECEIPT).
#define PPTFR_SHADOW       0x00000200L // Проставляется в строках теневого документа. При этом GoodsID < 0.
#define PPTFR_PARTSTRUSED  0x00000400L // К строке была применена частичная структура
//
// Флаг PPTFR_FORCESUPPL при определении поставщика для генерируемого лота
// заставляет считаться с полем PPTransferItem::Suppl, установленным до
// вызова PPObjBill::TurnPacket или PPObjBill::UpdatePacket. Если этот
// флаг не установлен, то функция PPTransferItem::InitBillConstrains, при определенных условиях,
// может инициализировать поле PPTransferItem::Suppl в значение BillTbl::Rec::Object.
//
#define PPTFR_FORCESUPPL   0x00000800L
#define PPTFR_UNLIM        0x00001000L // Неограниченный ресурс
#define PPTFR_ODDGOODS     0x00002000L // Товар нестандартного типа
//
// Два взаимоисключающих флага. Соответствуют приходу и расходу товара
// соответственно. До @v1.10.1 знак поля Quantity однозначно определялс
// видом операции (т.е. все строки одного документа имели это поле одного
// знака). С вводом операции модификации товаров один документ может
// содержать строки с положительным и отрицательным полем Quantity.
// Ради сохранения обратной совместимости придется обрабатывать ситуацию,
// когда оба флага не установлены, однако, начиная с @v1.10.1 эти флаги
// обязательно будем устанавливать во всех строках (если конечно строка
// влечет изменение остатка).
//
// Устанавливаться эти флаги должны только функциями инициализации:
//  PPTransferItem::PPTransferItem, PPTransferItem::Init,
//  PPTransferItem::InitShadow.
// Правильнее всего для выяснения знака будет пользоваться функцией
// PPTransferItem::GetSign().
//
#define PPTFR_PLUS         0x00004000L // Поступление товара
#define PPTFR_MINUS        0x00008000L // Расход товара
//
// @v1.10.1 Модификация товара.
// @v3.9.10 См. примечание к PPTFR_PCKG
// @v4.0.11 См. примечание к PPTFR_ASSETEXPL
//
#define PPTFR_MODIF        0x00010000L
#define PPTFR_AUTOCOMPL    0x00020000L // Автокомплектация //
//
// Флаг PPTFR_QUOT устанавливается тогда, когда цена (вместе со скидкой)
// строки указана по котировке. В этом случае установка общей скидки на
// документ не влечет изменение чистой цены (Price - Discount) по этой
// строчке.
//
#define PPTFR_QUOT         0x00040000L // Цена установлена по котировке
	// Если установлены одновременно флаги PPTFR_QUOT | PPTFR_RECEIPT, то это означает,
	// что на строку установлена цена реализации по расценке
#define PPTFR_RMVEXCISE    0x00080000L // Со строчки скидкой снят акциз
#define PPTFR_ACK          0x00100000L // Подтверждение
#define PPTFR_NODISCOUNT   0x00200000L // На строку не распространяется общая скидка
#define PPTFR_COSTWOVAT    0x00400000L // Цена поступления задана без НДС
#define PPTFR_COSTWSTAX    0x00800000L // Цена поступления задана с налогом с продаж
//
// @v3.3.4  Package operation (if PPTFR_RECEIPT, then generates package)
// @v3.9.10:
// Если флаги PPTFR_PCKG и PPTFR_MODIF установлены одновременно, то
// это означает операцию формирования пакета из существующих остатков
// (то есть в расходной операции). При этом функция PPTransfer::Init()
// устанавливает флаг PPTFR_RECEIPT и (посредством функции PPTransferItem::SetSignFlags) PPTFR_PLUS.
// В этом случае компоненты пакета получают признак PPTFR_UNITEINTR
// и генерируют зеркальные операции для присвоения пакету лотов.
//
#define PPTFR_PCKG         0x01000000L
#define PPTFR_PCKGGEN      0x02000000L // Row of component of package
#define PPTFR_FIXMODIFCOST 0x04000000L // Цена поступления строки модификации фиксирована.
	// Для такой строки не осуществляется пересчет цены поступления //
#define PPTFR_INDEPPHQTTY  0x08000000L // Строка учитывает операцию в торговых и в физических единицах независимо
#define PPTFR_PRICEWOTAXES 0x10000000L // Цена реализации задана без налогов
#define PPTFR_DRAFT        0x20000000L // Строка draft-операции
//
// Ввод в экплуатацию основных фондов.
// Может присутствовать только в:
// - приходе основных средств (PPOPT_GOODSRECEIPT; subtype = OPSUBT_ASSETRCV)
// - переоценке (PPOPT_GOODSREVAL; subtype = OPSUBT_ASSETEXPL).
// Если одновременно установлены флаги (PPTFR_REVAL | PPTFR_ASSETEXPL | PPTFR_MODIF)
// то это означает вывод из эксплуатации объекта основных средств
//
#define PPTFR_ASSETEXPL    0x40000000L
//                         0x80000000L // Reserved
//
//
// Будем различать следующие виды сумм элемента PPTransferItem
//
#define TIAMT_COST               1 // Cost * Quantity
#define TIAMT_PRICE              2 // NetPrice() * Quantity
#define TIAMT_AMOUNT             3 // CalcAmount()
#define TIAMT_ASSETEXPL          4 // Ввод основных средств в эксплуатацию
	// (используется в функции PPTransferItem::CalcTI)
//
// Флаги функции PPTransferItem::SetupLot
//
#define TISL_IGNCOST        0x0001 // Не присваивать цену поступления лота
#define TISL_IGNPRICE       0x0002 // Не присваивать цену реализации лота
#define TISL_ADJPRICE       0x0004 // Выравнивать скидкой существующую цену реализации
#define TISL_IGNPACK        0x0008 // Не присваивать емкость упаковки
#define TISL_IGNQCERT       0x0010 // Не присваивать сертификат
#define TISL_IGNEXPIRY      0x0020 // Не присваивать срок годности
//
// Флаги функции PPTransferItem::SetupGoods
//
#define TISG_SETPWOTF       0x0001 // Выставлять при необходимости флаг PPTFR_PRICEWOTAXES
//
// Значения параметра forceSign функции PPTransferItem::SetSingFlags (а также,
// PPTransferItem::PPTransferItem, PPTransferItem::Init).
//
#define TISIGN_PLUS          1
#define TISIGN_MINUS        -1
#define TISIGN_UNDEF         0
#define TISIGN_RECOMPLETE 1000
#define TISIGN_ASIS       2000 // @v9.3.1 Знак количества такой, какой установлен в поле PPTransferItem::Quantity_
//
//
//
class PPTransferItem { // @size=128
public:
	static int FASTCALL IsRecomplete(long flags);
	static int FASTCALL GetSign(PPID op, long flags);

	enum {
		initfForceSign  = 0x0001,
		initfPlus       = 0x0002,
		initfMinus      = 0x0004,
		initfRecomplete = 0x0008,
		initfAsIs       = 0x0010
	};

	SLAPI  PPTransferItem();
	SLAPI  PPTransferItem(const BillTbl::Rec * pBillRec, int forceSign /*= TISIGN_UNDEF*/);
	PPTransferItem & FASTCALL operator = (const PPTransferItem &);
	//
	// Descr: Если параметр forceSign < 0, тогда функция устанавливает флаг PPTFR_MINUS
	//   в поле Flags. Если forceSign > 0, тогда устанавливает флаг PPTFR_PLUS.
	//   Если forceSign = 0, то функция пытается самостоятельно определить какой знак у
	//   операции и, если ей это не удается (обычно для модификации), выдает ошибку
	//   PPERR_GMODIFITEMFLAG.
	//
	int    SLAPI Init(const BillTbl::Rec * pBillRec, int zeroRByBill = 1, int forceSign = TISIGN_UNDEF);
	int    SLAPI PreprocessCorrectionExp();
	double SLAPI GetEffCorrectionExpQtty() const;
	void   SLAPI InitShadow(const BillTbl::Rec *, const PPTransferItem * pOrder);
	//
	// Descr: инициирует элемент PPTransferItem с товаром GoodsID, определенным кодом
	//   PPCommConfig::PrepayInvoiceGoodsCode, Quantity = 1, Cost = pPack->Amount,
	//   Price = pPack->Amount. Если инициализация прошла успешно, то возвращается (>0).
	//   Эта функция используется при формировании счетов-фактур по бухгалтерским
	//   документам и оплатам, а также при заполнении книги продаж/покупок.
	//
	int    SLAPI InitAccturnInvoice(const PPBillPacket * pPack);
	// @v8.0.3 int    FASTCALL IsModified(const PPTransferItem * pattern) const;
	int    FASTCALL IsEqual(const PPTransferItem & rS) const; // @v8.0.3
	int    SLAPI IsCorrectionRcpt() const
	{
		return BIN(Flags & PPTFR_CORRECTION && Flags & PPTFR_REVAL);
	}
	int    SLAPI IsCorrectionExp() const
	{
		return BIN(Flags & PPTFR_CORRECTION && !(Flags & PPTFR_REVAL));
	}
	//
	// Descr: Реализует установку параметров структуры в зависимости от идентификатора
	//   товара goodsID.
	//
	int    SLAPI SetupGoods(PPID goodsID, uint = 0);
	int    SLAPI SetupLot(PPID, const ReceiptTbl::Rec * pLotRec, uint fl/* TISL_XXX */);
	//
	// Descr:
	// Returns:
	//   TISIGN_PLUS  - если приход товара
	//   TISIGN_MINUS - если расход
	//   0            - если строка не влияет на остаток.
	//
	int    FASTCALL GetSign(PPID op) const;
	//
	// Descr: Функция SetupSign работает только тогда, когда структура
	//   инициализирована. Необходимость в этой функции обусловлена тем, что
	//   диалоговые процедуры работают с абсолютным значением поля Quantity,
	//   а все остальные требуют корректно установленного знака.
	//
	void   FASTCALL SetupSign(PPID op);
	//
	// Descr: устанавливает флаги структуры, соответствующие знаку
	//   операции (приход, расход, рекомплектация и т.д.).
	//   Если вид операции относится к типу PPOPT_GOODSMODIF, то флаги выставляются в
	//   соответствии с параметром forceSign, в противном случае вид операции полностью
	//   определяет установку флагов.
	//   Если forceSign == TISIGN_RECOMPLETE (1000), то строка соответствует рекомплектуемому лоту.
	//
	int    SLAPI SetSignFlags(PPID op, int forceSign = TISIGN_UNDEF);
	//
	// Descr: Возвращает !0, если строка относится к нелимитируемому товару и
	//   не требует создания (привязке) к лоту.
	//   Для плавного перехода на технику учета заказов нелимитируемых позиций по лотам,
	//   в системной конфигурации PPCommConfig предусмотрен флаг CCFLG_GENLOTONUNLIMORDER.
	//   Если этот флаг не установлен, функция возвращает !0 если (Flags & (PPTFR_UNLIM|PPTFR_ACK)).
	//   Если же этот флаг установлен, то функция возвращает !0 если
	//     (Flags & PPTFR_ACK) || (Flags & PPTFR_UNLIM && !(Flags & (PPTFR_ORDER|PPTFR_SHADOW)))
	//
	int    SLAPI IsUnlimWoLot() const;
	int    SLAPI IsLotRet() const;
	int    SLAPI IsRecomplete() const;
	double FASTCALL SQtty(PPID op) const;
	//
	// Descr: Возвращает номинальную сумму элемента.
	// ARG(zeroCost IN): если !0, то заставляет возвращать нулевой результат если по
	//   правильному значению можно вычислить цену поступления. Эта опция необходима
	//   для ограничени доступа к ценам поступления.
	//
	double FASTCALL CalcAmount(int zeroCost = 0) const;
	double SLAPI CalcCurAmount() const;
	double SLAPI NetPrice() const;
	double SLAPI Qtty() const;
	void   FASTCALL ConvertMoney(TransferTbl::Rec * pRec) const;
	int    FASTCALL SetupByRec(const TransferTbl::Rec *);
	int    FASTCALL SetupByRec(const LocTransfTbl::Rec * pTr);
	int    SLAPI SetupQuot(double, int set);
	enum {
		valfRoundVat = 0x0001,
		valfCalcOnly = 0x0002
	};
	//
	// Descr: Расценивает строку в соответствии с видом котировки quotKindID и дополнительными
	//   параметрами округления.
	// Note: Функция создает экземпляр класса PPObjGoods. Во избежании замеделния работы следует
	//   позаботиться о том, чтобы вне этой функции уже существовал инициализированный экземпляр
	//   PPObjGoods.
	// ARG(quotKindID IN):
	// ARG(roundPrec  IN):
	// ARG(roundDir   IN):
	// ARG(flags      IN): PPTransferItem::valfXXX
	// ARG(pResult   OUT): @#{vptr0}
	// Returns:
	//   >0 - значение цены реализации успешно рассчитано.
	//   <0 - для товара не определена котировка либо значение цены получилось меньше или
	//     равное нулю.
	//   0  - ошибка
	//
	int    SLAPI Valuation(const PPBillConfig & rCfg, int calcOnly, double * pResult);
	double SLAPI RoundPrice(double price, double roundPrec, int roundDir, long flags) const;
	double SLAPI GetOrgCost() const;
	void   SLAPI SetOrgCost(double c);
	void   SLAPI SetZeroCost();

	LDATE  Date;
	PPID   BillID;
	int16  RByBill;
	int16  SrcIltiPos; // @v7.6.1 Номер позиции в пакете ILBillPacket, из которого была создана данная строка.
		// Необходим для трансляции идентификаторов лотов при синхронизации между разделами.
	PPID   CurID;      // ->Ref(PPOBJ_CURRENCY).ID Валюта @v7.6.1 int16-->PPID
	PPID   LocID;      // ->Location.ID Для складских операций - ИД ячейки
	PPID   GoodsID;
	PPID   LotID;
	union {
		PPID CorrLoc;  // Корреспондирующая позиция //
		//
		// Если this является внутренним пакетом автокомплектации, то
		// поле ACLinkLotID используется во время проводки пакета функциями
		// PPObjBill::TurnPacket и PPObjBill::UpdatePacket для сохранени
		// на время транзакции временного значения лота, связывающего
		// строки внешнего и внутреннего пакетов. При сбое в проводке
		// документов новые значения лотов, присвоенные функциями
		// Transfer::AddItem или Transfer::UpdateItem, откатываются в
		// значения, сохраненные в этом поле. В функции
		// Transfer::AddItem и Transfer::UpdateItem это поле не может
		// попасть с ненулевыми значениями.
		//
		PPID ACLinkLotID;
	};
	//
	// При загрузке строки теневого документа в пакет поле CorrLoc получает идентификатор этого теневого документа, а поле
	// BillID получает идентификатор документа заказа. Перед проводкой такой строки поле CorrLoc обнуляется.
	//
	PPID   OrdLotID;    // @transient Лот ордера (Flags & PPTFR_ONORDER) (В БД не заносится)
	double UnitPerPack; // Емкость упаковки (количество торговых единиц в одной упаковке)
	double Quantity_;   // Количество товара (до v7.8.10 при переоценке - старая цена поступления)
	double WtQtty;      // Независимо учитываемое количество в физических единицах
	union {
		double SpoilQtty;   // Количество товара, вычтенное из поступившего количества, как бракованное.
			// Поле Quantity содержит значение, поправленное на величину SpoilQtty. Таким образом,
			// изначально поступившее от поставщика количество равно Quantity+SpoilQtty.
			// Расчет SpoilQtty осуществляется по частичным структурам в документах прихода от поставщика.
		double RevalCost;   // Старая цена поступления при переоценке
			// До версии v7.8.10 для этой цели использовалось поле Quanitity.
			// При корректировке расхода - старая цена реализации
	};
	double Rest_;       // Остаток после операции (при проводке игнорируется)
	double Cost;        // Цена поступления (при переоценке - новая цена поступления)
	double ExtCost;     // Величина накладных расходов, включенная в Cost (хранится в ReceiptTbl)
		// Положительное значение увеличивает Cost, отрицательное - уменьшает.
		// Таким образом, оригинальное значение Cost_Orig = Cost - ExtCost;
	double Price;       // Цена реализации (при переоценке - новая цена реализации)
	double Discount;    // Скидка (при переоценке - старая цена реализации)
	double CurPrice;    // Валютная цена
	double QuotPrice;   // Фиксированная цена по котировке (при корректировке - оригинальное количество)
	PPID   LotTaxGrpID; // ->Ref(PPOBJ_GOODSTAX).ID Входящая налоговая группа по лоту
	PPID   QCert;       // ->QualityCert.ID Серитфикат качества
	PPID   Suppl;       // ->Article.ID     Поставщик
	long   Flags;       // PPTFR_XXX
	enum {
		tfDirty        = 0x0001, // Признак того, что элемент был успешно добавлен в БД во время транзакции.
			// По этому признаку в случае сбоя проводки других строк можно будет
			// определить, что элемент фактически добавлен не был, хотя и имеет признаки
			// проведенного (RByBill != 0). PPTransferItem::tfDirty
			//
		tfForceLotID   = 0x0002,
		tfLocTransf    = 0x0004,  // Складская операция //
		tfForceRemove  = 0x0008,  // @v7.5.4 При изменении документа строка должна быть удалена в форсированном порядке
			// то есть, даже не смотря на остатки и прочие препятствия //
		tfOrdReserve   = 0x0010,  // @v7.8.10 флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
			// установить флаг LOTF_ORDRESERVE для создаваемого лота.
			// До v7.8.10 использовался PPTFR_ORDRESERVE
		tfForceReplace = 0x0040,  // @v8.0.3 флаг, используемый внутри функции PPObjBill::UpdatePacket() для //
			// индикации необходимости полностью обновить строку в БД (удалить и добавить снова).
			// Флаг введен вместо обнуления поля RByBill так как создание новой строки может осуществляться и
			// при ненулевом значении RByBill (см флаг tfForceRByBill выше).
		tfForceNew     = 0x0080,  // @v8.0.3 Не смотря на то, что RByBill != 0 строка является новой (создана
			// в рамках акцепта документа, поступившего из другого раздела).
		tfForceNoRcpt  = 0x0100,  // @v8.0.9 Корректировочный флаг, блокирующий установку признака PPTFR_RECEIPT
			// функцией PPTransferItem::Init ради дополнения остатка существующего лота
		tfProblemQuot  = 0x0200   // @v8.2.0 Строка имеет проблемную котировку, выявленную при расценке либо
			// при назначении цены по котировке
	};
	long   TFlags;      // @transient tfXXX Не сохраняемые в БД признаки строки.
	LDATE  Expiry;      // Дата завершения пригодности товара к использованию
	union {
		LDATE  LotDate;     // Дата поступления товара.
		LTIME  LocTransfTm; // Для складской операции - время операции.
	};
};

int SLAPI IsUnlimWoLot(const TransferTbl::Rec & rRec);
//
// Intermediate Level Transfer Item
// Структура строки товарного документа промежуточного уровня //
// Предназначена для:
// - интерфейса с другими системами;
// - перемещения документов в рамках распределенной базы данных;
// - сохранения непроведенных документов
// - и др.
// Главная особенность этой структуры в сравнении с PPTransferItem
// в том, что она хранит строку товарного документа без ссылки на конкретный лот.
// Еще одно полезное свойство структуры ILTI заключается в способности
// аккумулировать множество строк PPTransferItem в том числе из многих
// документов.
//
struct ILTI { // @persistent(DBX) @size=80
	SLAPI  ILTI(const PPTransferItem * = 0);
	void   FASTCALL Init(const PPTransferItem * pTi);
	int    SLAPI Setup(PPID goodsID, int sign, double qtty, double cost, double price);
	//
	// Descr: Устанавливает поля Qtty и Rest в значение qtty с поправкой на флаги.
	// ARG(qtty   IN): Количество товара (в торговый единицах) устанавливаемое в поля//
	//   Qtty и Rest. Если в параметре flags не установлены флаги PPTFR_MINUS и PPTFR_PLUS,
	//   то qtty используется с тем же знаком, с которым передан от вызывающей функции.
	//   Если flags & PPTFR_PLUS, то функция форсирует положительное значение,
	//   Если flags & PPTFR_MINUS, то функция форсирует отрицательное значение.
	// ARG(wtQtty IN): Не используется.
	// ARG(flags  IN): Установленные в этом параметре флаги добавляются в поле Flags
	//   (this->Flags |= flags). Кроме того, эти флаги используются для установки знака
	//   полей Qtty и Rest (see ARG(qtty))
	// Returns:
	//   1
	//
	int    SLAPI SetQtty(double qtty, double wtQtty = 0.0, long flags = 0);
	int    SLAPI HasDeficit() const;

	PPID   BillID;      // ->Bill.ID   Ссылка на заголок документа
	PPID   GoodsID;     // ->Goods2.ID ИД товара
	PPID   LotSyncID;   // @v7.6.1 @synclot
	PPID   LotMirrID;   // @v7.6.1 @synclot Лот зеркальной записи для внутренней передачи
	double UnitPerPack; // Количество в упаковке
	double Quantity;    // Количество
	double Rest;        // Непроведенный остаток [0..Quantity]
	double Cost;        // Цена поступления (одной торговой единицы)
	double Price;       // Цена реализации  (одной торговой единицы)
	double CurPrice;    // Валютная цена
	double QuotPrice;   // Цена по котировке
	long   Flags;       // Флаги (PPTFR_XXX)
	long   Suppl;       // ->Article.ID Поставщик
	long   QCert;       // ->QualityCert.ID Сертификат
	LDATE  Expiry;      // Срок годности (только для элементов товарных корзин)
	PPID   InTaxGrpID;  // ->Ref(PPOBJ_GOODSTAXGROUP) Налоговая группа прихода
	int16  RByBill;     // @v8.0.3
	uint8  Reserve[10]; // @v8.0.3 @reserve
};
//
// Флаги документов (BillTbl::Rec.Flags)
//
#define BILLF_TOTALDISCOUNT  0x00000001L // Скидка задана на весь документ
#define BILLF_FREIGHT        0x00000002L // Документ содержит данные по фрахту
#define BILLF_NEEDPAYMENT    0x00000004L // Требует платежного документа
#define BILLF_PAYOUT         0x00000008L // Документ оплачен
#define BILLF_GRECEIPT       0x00000010L // Приход товара
#define BILLF_GEXPEND        0x00000020L // Расход товара
#define BILLF_SHIPPED        0x00000040L // Товар по документу отгружен
#define BILLF_NOLOADTRFR     0x00000080L // @transient При загрузке и обработке документа не следует загружать товарные строки
#define BILLF_CLOSEDORDER    0x00000100L // Закрытый заказ
#define BILLF_WRITEDOFF      BILLF_CLOSEDORDER // Списанный драфт
#define BILLF_GREVAL         0x00000200L // Переоценка товара
#define BILLF_CASH           0x00000400L // Кассовый документ
#define BILLF_CHECK          0x00000800L // Признак пробитого чека
#define BILLF_NOATURN        0x00001000L // Док без бух. проводок
#define BILLF_WHITELABEL     0x00002000L // Спец. метка
#define BILLF_EXTRA          0x00004000L // Существует дополнительная запись
#define BILLF_GMODIF         0x00008000L // Модификация товара
	// @#{BILLF_GRECEIPT^BILLF_GEXPEND^BILLF_GREVAL^BILLF_GMODIF}
// @v9.4.3 (следует использовать функцию IsGoodsDetail) #define BILLF_GOODS          (BILLF_GRECEIPT|BILLF_GEXPEND|BILLF_GREVAL|BILLF_GMODIF)
#define BILLF_NEGINVOICE     0x00010000L // Этот флаг используется только в структуре PPALDD GoodsBillBase и
	// порожденных для внутренней индикации того, что счет-фактуру следует печатать с отрицательными суммами
#define BILLF_RMVEXCISE      0x00020000L // Скидкой снят налог с продаж
#define BILLF_RENT           0x00040000L // С документом ассоциирован договор ренты
#define BILLF_RECKON         0x00080000L // Зачетный документ оплаты
#define BILLF_BANKING        0x00100000L // Банковский платежный документ
#define BILLF_FIXEDAMOUNTS   0x00200000L // Суммы по документу зафиксированы и не пересчитываются по товарным строкам
#define BILLF_CSESSWROFF     0x00400000L // Документ списания кассовой сессии
#define BILLF_PRINTINVOICE   0x00800000L // @transient Спец флаг, информирующий функцию заполнения данных для печати
	// документа, что печаться будет счет-фактура. Видимо в дальнейшем этот флаг будет упразднен.
#define BILLF_ADVANCEREP     0x01000000L // Авансовый отчет
#define BILLF_TGGLEXCSNPRICE 0x02000000L // Налог с продаж по документу установлен без изменения цены
#define BILLF_RECOMPLETE     0x04000000L // @#{BILLF_RECOMPLETE&BILLF_GMODIF} Рекомплектация  //
	// Этот флаг устанавливается, если в документ модификации вставляется товарная строка, имеющая    //
	// признак рекомплектации (PPTFR_MODIF|PPTFR_ACK|PPTFR_REVAL). Такая строка может быть удалена из //
	// документа только последней, после чего флаг BILLF_RECOMPLETE снимается                         //
#define BILLF_TSESSWROFF     0x08000000L // Документ списания технологической сессии
#define BILLF_CDFCTWROFF     0x10000000L // Документ сформирован на основе дефицита по кассовой сессии
#define BILLF_TDFCTWROFF     0x20000000L // Документ сформирован на основе дефицита по техн сессии
	// @#{BILLF_CDFCTWROFF^BILLF_CSESSWROFF^BILLF_TSESSWROFF^BILLF_TDFCTWROFF}
#define BILLF_SCARDOP        0x40000000L // По документу сформирована операция по кредитной карте
	// Флаг необходим для того, чтобы быстро принять решение (не обращаясь к таблице операций по карте) об удалении или изменении операции.
//
//
//
#define BILLF2_BHT           0x00000001L // @v7.2.0 Документ создан с BHT-терминала
#define BILLF2_FULLSYNC      0x00000002L // @v8.0.3 Признак того, что документ был принят из другого раздела с полным соответствием.
	// В результате такой документ потенциально сможет принять изменения исходного документа в последующем.
	// Важно: наличие данного флага является необходимым, но не достаточным условием для того, чтобы раздел
	// мог бы акцептировать изменение документа из другого раздела.
#define BILLF2_TSESSPAYM     0x00000004L // @v8.0.3 Документа платежа по технологической сессии
#define BILLF2_DONTCLOSDRAFT 0x00000008L // @v8.3.2 @transient Специализированный флаг, уведомляющий функцию PPObjBill::ProcessLink
	// о том, что не следует закрывать связанный драфт-документ.
#define BILLF2_DECLINED      0x00000010L // @v8.3.3 Документ (драфт), принятый нами по EDI-каналу нами же полностью отклонен
#define BILLF2_ACKPENDING    0x00000020L // @v8.8.0 Документ находится в состоянии ожидания завершения процедуры подтверждения //
	// То есть, отправлен запрос на подтверждение, но ответ еще не получен. У документа при этом может быть установлен
	// тег типа PPTAG_BILL_EDIACK. Если BILLF2_ACKPENDING установлен и в документе есть такой тег, то это означает,
	// что подтверждение уведомления об еще не было подтверждено со стороны сервиса EDI.
#define BILLF2_RECADV_ACCP   0x00000040L // @v8.8.6 На документ отправленный через EDI-канал получено подтверждение о получении покупателем
#define BILLF2_RECADV_DECL   0x00000080L // @v8.8.6 Документ отправленный через EDI-канал получено уведомление об отказе в приеме
	// Если установлены оба флага BILLF2_RECADV_ACCF и BILLF2_RECADV_DECL, то к документу привязывается драфт-документ приемки покупателем
#define BILLF2_EDIAR_AGR     0x00000100L // @v8.8.8 Ответ на подтверждение нашей отгрузки покупателем (согласны)
#define BILLF2_EDIAR_DISAGR  0x00000200L // @v8.8.8 Ответ на подтверждение нашей отгрузки покупателем (не согласны)
#define BILLF2_EDIREPEALREQ  0x00000400L // @v9.2.8 Для документа получен запрос на отмену в проведении на сервере EDI
	// Если этот флаг установлен, то смысл флагов BILLF2_EDIAR_AGR и BILLF2_EDIAR_DISAGR переключается на реакцию на
	// запрос об отмене проведения.
#define BILLF2_ROWLINKBYRBB  0x00000800L // @v9.4.3 @internal
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_EXTRA)
//
struct PPBillExt { // @persistent @store(PropertyTbl)
	SLAPI  PPBillExt();
	int    SLAPI IsEmpty() const;
	//
	// Descr: Сравнивает перманентные поля экземпляра структуры this с экземпляром pS.
	//   Перманентные поля не отмечены признаком @transient
	// Returns:
	//   !0 - экземпляры this и pS одинаковы
	//   0  - экземпляры this и pS не одинаковы
	//
	int    FASTCALL IsEqual(const PPBillExt & rS) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	PPID   PayerID;            // ->Article.ID Плательщик
	PPID   AgentID;            // ->Article.ID Агент
	char   InvoiceCode[24];    //
	LDATE  InvoiceDate;        //
	char   PaymBillCode[24];   // Номер платежного документа (для печати в счете-фактуре)
	LDATE  PaymBillDate;       // Дата  платежного документа (для печати в счете-фактуре)
	int16  IsShipped;          // @transient Признак отгруженного документа (проецируется на BillTbl::Rec.Flags как BILLF_SHIPPED)
	int16  Ft_STax;            // @transient (0 - ignored, <0 - off, >0 - on)
	int16  Ft_Declined;        // @v8.3.3 @transient (0 - ignored, <0 - off, >0 - on)
	int16  Reserve;            // @v8.3.3 @alignment @transient
	int16  EdiRecadvStatus;     // @v9.1.6 @transient Статус RECADV по каналу EDI
	int16  EdiRecadvConfStatus; // @v9.1.6 @transient Статус подтверждения на RECADV по каналу EDI
	PPID   CreatorID;          // @transient Критерий фильтрации по пользователю, создавшему документ
	PPID   ExtPriceQuotKindID; // Вид котировки, используемый для печати дополнительной цены в накладных
	PPID   SCardID;            // @transient Персональная карта, к которой привязан документ
		// Проекция поля BillTbl::Rec::SCardID
	DateRange DuePeriod;       // @transient Период даты исполнения документа. Проекция BillFilt::DuePeriod
};
//
// Descr: Массив движения по кредиту. Используется при начислении процентов по договору ренты.
//   Извлекается из БД функцией BillCore::GetCreditList(PPID billID, PctChargeArray *);
//
struct PctChargeEntry {
	LDATE  Dt;
	double Rest;
};

class PctChargeArray : private SArray {
public:
	SLAPI  PctChargeArray();
	int    SLAPI Add(LDATE, double amount);
	LDATE  SLAPI GetFirstDate() const;
	double SLAPI GetRest(LDATE);
	int    SLAPI EnumItems(uint * pIdx, PctChargeEntry *) const;
	int    SLAPI ChargePercent(LDATE since, LDATE end, double percent, double * pResult) const;
protected:
	PctChargeEntry & FASTCALL at(uint) const;
};
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_RENT)
//
#define RENTF_CLOSED    0x0001L // Закрытый договор
#define RENTF_PERCENT   0x0010L // Процентные начисления по ренте.

struct PPRentCondition {   // @size=48 @persistent @store(PropertyTbl[PPOBJ_BILL, @id, BILLPRP_RENT])
	int    SLAPI IsEmpty() const;
	int    FASTCALL IsEqual(const PPRentCondition & rS) const;
	int    SLAPI GetCycleList(PPCycleArray *) const;
	int    SLAPI GetChargeDate(const PPCycleArray *, uint cycleNo, LDATE *) const;
	int    SLAPI CalcRent(LDATE chargeDt, double * pAmount) const;
	//
	// Descr: Рассчитывает начисляемый процент за период [begDt..chargeDt].
	//   При расчете используется список pCreditList, хранящий информацию о движении по кредиту.
	//   Результат возвращается по указателю pAmount.
	//
	int    SLAPI CalcPercent(LDATE begDt, LDATE chargeDt, const PctChargeArray * pCreditList, double * pAmount) const;

	DateRange Period;      // Период действия ренты
	int16  Cycle;          // Период цикла начисления PRD_XXX (SLIB.H)
	int16  Reserve;        // @reserve
	double Percent;        // Годовой процент начисления (используется если Flags & RENTF_PERCENT) //
	double PartAmount;     // Частичная сумма начисления (на каждый период) //
	long   Flags;          // RENTF_XXX
	long   ChargeDayOffs;  // Смещение даты начисления (в днях)
	uint8  Reserve2[16];   // @reserve
};
//
// Value added record for PPOBJ_BILL
// Used if (BillTbl::Rec::Flags & BILLF_BANKING)
//
#define BNKPAYMMETHOD_UNDEF      0 // Неопределенный
#define BNKPAYMMETHOD_MAIL       1 // Почтой
#define BNKPAYMMETHOD_TELEGRAPH  2 // Телеграфом
#define BNKPAYMMETHOD_EMAIL      3 // Электронно
#define BNKPAYMMETHOD_URGENTLY   4 // Срочно
#define BNKPAYMMETHOD_DEFAULT    BNKPAYMMETHOD_EMAIL // По умолчанию

#define BNKQUEUEING_DEFAULT      5 // @v8.0.2 6-->5

#define BNKPAYMF_REQ        0x0001L // Платежное требование (иначе поручение)
#define BNKPAYMF_WOACCEPT   0x0002L // Без акцепта (иначе с акцептом)

struct PPTaxPeriod {       // @persistent @size=6
	SString & SLAPI Format(SString & rBuf) const;
	enum {
		eEmpty = 0, eYear, eSemiyear1, eSemiyear2, eQuart1, eQuart2, eQuart3, eQuart4,
		eMonth, eDec1, eDec2, eDec3, eDate
	};
	int16  Year;           //
	int8   Month;          // @#{1..12}
	int8   Day;            //
	int16  P;              // PPTaxPeriod::eXXX
};

struct PPBankingOrder { // @persistent @store(PropertyTbl)
	SLAPI  PPBankingOrder();
	//
	// Requirements:
	//   Dt != 0
	//   AckDt == 0 || AckDt >= Dt
	//   PayerID == PayerBnkAccID.PersonID
	//   RcvrID == RcvrBnkAccID.PerosnID;
	//   BnkQueueing == (1..10)
	//   Amount > 0
	//
	struct TaxMarkers {    // @size=90
		int    SLAPI IsEmpty() const;
		char   TaxClass[12];  // Код бюджетной классификации налога (7 знаков)
		char   OKATO[16];     // Код муниципального образования по ОКАТО (11 знаков)
		char   Reason[8];     // Код основания платежа
		PPTaxPeriod Period;   // Налоговый период
		char   DocNumber[12]; // Номер документа, согласно которому осуществляется оплата
		LDATE  DocDate;       // Дата подписи декларации
		char   PaymType[8];   // Тип платежа
		char   TaxClass2[24]; // Код бюджетной классификации налога с 2005 года (20 знаков)
		char   UIN[24];       // @v8.0.9 Код УИН
	};
	PPID   Tag;              // const = PPOBJ_BILL
	PPID   BillID;           // ИД документа
	PPID   PropID;           // const = BILLPRP_PAYMORDER
	LDATE  Dt;               // Дата платежа
	LDATE  AckDt;            // Дата подтверждения платежа
	char   Code[10];         // Номер документа @todo [10]-->[24]
	PPID   PayerKindID;      // Helper field for selecting payer
	PPID   RcvrKindID;       // Helper field for selecting receiver
	PPID   PayerID;          // ->Person.ID      Плательщик
	PPID   PayerBnkAccID;    // ->BankAccount.ID Банковский счет плательщика
	PPID   RcvrID;           // ->Person.ID      Получатель
	PPID   RcvrBnkAccID;     // ->BankAccount.ID Банковский счет получател
	short  BnkPaymMethod;    // Способ банковского платежа (BNKPAYMMETHOD_XXX)
	short  BnkQueueing;      // Очередность банковского платежа (1..)
	long   Flags;            // Флаги (BNKPAYMF_XXX)
	double Amount;           // Сумма платежа
	long   VATRate;          // Ставка НДС
	double VATSum;           // Сумма НДС
	int16  PayerStatus;      // Статус плательщика (1..7, default 1)
	// Part stored in variable tail of record
	TaxMarkers Txm;
};
//
// Descr: Информация по фрахту документа
//
struct PPFreight {         // @persistent @store(PropertyTbl)
	SLAPI  PPFreight();
	int    SLAPI IsEmpty() const;
	int    FASTCALL IsEqual(const PPFreight &) const;
	int    FASTCALL CheckForFilt(const FreightFilt & rFilt) const;

	PPID   Tag;            // Const=PPOBJ_BILL
	PPID   ID;             // ->Bill.ID
	PPID   PropID;         // Const=BILLPRP_FREIGHT
	char   Name[20];       //
	PPID   StorageLocID;   // @v8.8.5 Место хранения. Если весь документ (например, инвентаризация) ассоциирован
		// с одним местом хранения, то здесь оно может быть указано
	char   Reserve[2];     // @reserve
	PPID   DlvrAddrID;     // ->Location.ID Адрес разгрузки
	int16  NmbOrigsBsL;    // Количество печатаемых оригиналов коносаментов
	long   TrType;         // PPTRTYP_XXX
	PPID   PortOfLoading;  // ->City.ID
	PPID   PortOfDischarge; // ->City.ID
	LDATE  IssueDate;      // Дата отправления из пункта погрузки
	LDATE  ArrivalDate;    // Дата прибытия на конечный пункт
	PPID   CaptainID;      // ->Person.ID (Командиры транспортных средств)
	double Cost;           // Стоимость фрахта
	PPID   AgentID;        // ->Person.ID (Транспортные агентства)
	PPID   ShipID;         // ->Ship.ID
};
//
// Descr: Заголовок авансового отчета
//
struct PPAdvanceRep {      // @persistent @store(PropertyTbl)
	struct Rcpt {          // Size=48
		char   Text[28];   // Описание источника полученной суммы @todo Увеличить длину поля //
		PPID   BillID;     // Ассоциированный документ
		PPID   ObjectID;   // ->Article.ID Ассоциированных объект
		LDATE  Dt;         // Дата получения суммы
		double Amount;     // Сумма
	};
	PPID   Tag;            // const=PPOBJ_BILL
	PPID   BillID;         // ИД документа
	PPID   PropID;         // const=BILLPRP_ADVANCEREP
	double InRest;         // Остаток от предыдущего аванса
	double RcpAmount;      // Полученная сумма
	double ExpAmount;      // Израсходованная сумма
	double OutRest;        // Остаток
	int16  NumAddedBills;  // Количество прилагаемых первичных документов
	int16  NumAddedSheets; // Количество листов прилагаемых первичных документов
	Rcpt   Rcp[2];         // Информация о полученных суммах // @todo Увеличить количество элементов //
};

class PayPlanArray : public TSArray <PayPlanTbl::Rec> {
public:
	PayPlanArray();
	int    FASTCALL IsEqual(const PayPlanArray & rS) const;
	int    GetLast(LDATE * pDt, double * pAmount, double * pInterest) const;
	//
	// Descr: Ищет запись с датой dt. Если запись найдена, то возвращает !0
	//   и присваивает по указателю pPos позицию найденной записи, а по указателю
	//   pRec - саму запись. Если запись с датой dt не найдена, то данные по
	//   указателям pPos и pRec не меняются.
	//
	int    SearchDate(LDATE dt, uint * pPos, PayPlanTbl::Rec * pRec) const;
	void   SetBillID(PPID);
	int    Update(const PayPlanTbl::Rec * pItem, uint * pPos);
	void   Sort();
	int    AutoBuild(const PPBillPacket * pPack);
};

class PPBill {
public:
	SLAPI  PPBill();
	PPBill & FASTCALL operator = (const PPBill & rS);
	void   SLAPI BaseDestroy();
	int    FASTCALL Copy(const PPBill & rS);
	int    FASTCALL IsEqual(const PPBill & rS) const;
	int    FASTCALL GetLastPayDate(LDATE *) const;
	int    SLAPI AddPayDate(LDATE, double amount);
	//
	// Descr: Очищает список плана платежей и затем вызывает функцию PPBill::AddPayDate
	//
	int    SLAPI SetPayDate(LDATE dt, double amount);
	int    FASTCALL SetFreight(const PPFreight *);

	BillTbl::Rec Rec;
	AmtList      Amounts;
	PayPlanArray Pays;
	PPBillExt    Ext;
	PPRentCondition  Rent;
	PPBankingOrder * P_PaymOrder;
	PPFreight      * P_Freight;
	PPAdvanceRep   * P_AdvRep;
};
//
// Пакет документа
// Содержит всю необходимую информацию о товарном либо бухгалтерском документе.
// Основная структура, используемая в операциях с документами.
//
// Опции загрузки пакета из БД.
// Используются функцией PPObjBill::ExtractPacket.
//
#define BPLD_SKIPTRFR     0x0001 // Не загружать товарные строки
#define BPLD_LOCK         0x0002 // Устанавливать логич блокировку на документ
#define BPLD_FORCESERIALS 0x0004 // Обязательная загрузка серийных номеров по всем товарных строкам
	// Если этот флаг не установлен, то серийные номера загружаются только для строк, генерирующих лоты
//
// Опции обработки недостаточного количества составляющих комплектации
//
#define PCUG_USERCHOICE        0 // Предлагать диалог выбора способа обработки
#define PCUG_BALANCE           1 // Сбалансировать количество результирующего продукта
#define PCUG_ASGOODSAS         2 // Включить в комплект столько комплектующих, сколько есть в наличии
#define PCUG_EXCLUDE           3 // Полностью исключить недостающий комплектующий товар
#define PCUG_CANCEL            4 // Отменить операцию комплектации
//
// Descr: Список символьных номеров, ассоциированных с лотами
//   (грузовые таможенные декларации [Custom Lading Bill], серийные номера лотов)
// @todo @dbd_exchange Перевести объект на StrAssocArray
//
class ClbNumberList : private StrAssocArray { // @persistent(DBX)
public:
	SLAPI  ClbNumberList();
	int    SLAPI AddNumber(int rowIdx, const char * pClbNumber);
	int    SLAPI AddNumber(const IntArray * pRows, const char * pClbNumber);
	int    SLAPI GetNumber(int rowIdx, SString * pBuf) const;
	int    SLAPI SearchNumber(const char *, uint * pPos) const;
	int    SLAPI ReplacePosition(int rowIdx, int newRowIdx);
	void   SLAPI RemovePosition(int rowIdx);
	void   SLAPI Release();
	uint   SLAPI GetCount() const;
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);
};
//
// Descr: Список тегов, ассоциированных с товарными строками документа.
//   В качестве объекта привязки тегов - лоты. То есть, список
//   формируется и сохраняется в БД приходными документами, но может
//   использоваться любыми товарными документами, строки которых
//   ссылаются на лоты.
//
class PPLotTagContainer : private SArray {
public:
	SLAPI  PPLotTagContainer();
	SLAPI  PPLotTagContainer(const PPLotTagContainer & rS);
	PPLotTagContainer & FASTCALL operator = (const PPLotTagContainer & rS);
	int    FASTCALL Copy(const PPLotTagContainer & rS);
	void   SLAPI Release();
	uint   SLAPI GetCount() const;
	ObjTagList * FASTCALL Get(int rowIdx /*0..*/) const;
	int    SLAPI Set(int rowIdx /*0..*/, const ObjTagList *);
	const ObjTagItem * SLAPI GetTag(int rowIdx, PPID tagID) const;
	int    SLAPI SearchString(const char * pPattern, PPID tagID, long flags, LongArray & rRowIdxList) const;
	int    SLAPI GetTagStr(int rowIdx, PPID tagID, SString & rBuf) const;
	void   SLAPI RemovePosition(int rowIdx);
	int    SLAPI ReplacePosition(int rowIdx, int newRowIdx);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI ProcessObjRefs(PPObjIDArray * ary, int replace);
private:
	struct Item {
		int32  RowIdx;
		ObjTagList List;
	};
	virtual void FASTCALL freeItem(void * pItem);
};
//
// Descr: Шаблон транзитной валютной операции
//
struct PPCurTransit {      // @transient
	PPID   BillID;         // Идентификатор документа
	char   BillCode[24];   // Код документа
	LDATE  Date;
	PPID   OpID;
	PPID   AccSheetID;
	PPID   ObjectID;
	long   Flags;
	PPID   InCurID;
	double InCurAmount;
	double InCRate;
	PPID   OutCurID;
	double OutCurAmount;
	double OutCRate;
	double TransitCRate;
	char   Memo[160];
};
//
// Descr: Элементы расширения бухгалтерского документа
//
struct PPAdvBillItem {     // @persistent @store(AdvBillItem)
	SLAPI  PPAdvBillItem();
	int    FASTCALL IsEqual(const PPAdvBillItem & rS) const;
	enum {
		fWritedOff = 0x0001 // Строка документа списана (для долговой инвентаризации)
	};
	PPID   BillID;
	int16  RByBill;
	int16  Reserve2;        // @alignment
	char   AdvCode[24];
	LDATE  AdvDt;
	PPID   AdvBillKindID;
	//
	// Граф операций над связанным документом:
	// 1. Ссылка нулевая (или висячая)
	//    1.1 Операция "Редактировать"
	//       1.1.1 Добавить новый документ -->2.
	//       1.1.2 Добавить документ по фильтру -->2.
	// 2. Ненулевая ссылка на существующий док
	//    2.1 Операция "Редактировать"
	//       2.1.1 Редактировать связанный документ -->2.
	//       2.1.2 Заместить ссылку на связанный документ -->1.1
	//    2.2 Операция "Удалить"
	//       2.2.1 Разорвать ссылку на документ (документ остается, связь исчезает) -->1.
	//       2.2.2 Удалить связанный документ -->1.
	//
	PPID   AdvBillID;
	PPID   AccID;
	PPID   ArID;
	long   Flags;      // PPAdvBillItem::fXXX
	double Amount;     //
	double ExtAmt;     //
	char   Memo[128];  //
};

class PPAdvBillItemList : private SArray {
public:
	SLAPI  PPAdvBillItemList();
	int    FASTCALL IsEqual(const PPAdvBillItemList & rS) const;
	uint   SLAPI GetCount() const;
	PPAdvBillItem & FASTCALL Get(uint) const;
	int    SLAPI SearchBillLink(PPID billID, uint * pPos) const;
	int    SLAPI GetStorageForm(uint, AdvBillItemTbl::Rec *) const;
	int    SLAPI AddStorageForm(const AdvBillItemTbl::Rec *);
	int    SLAPI Add(const PPAdvBillItem *);
	int    SLAPI Remove(uint);
	void   SLAPI Clear();
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
};
//
//
//
struct BillVatEntry {
	double Rate;
	double VatSum;      // Сумма НДС
	double BaseAmount;  // Сумма налогооблагаемой базы (без НДС)
	double AmountByVat; // Сумма документа, соответствующая ставке НДС Rate.
		// Теоретически, AmountByVat = BaseAmount + VatSum, однако, из-за ошибок округления может
		// иногда возникать разница в пределах нескольких копеек.
};

class BillVatArray : public TSArray <BillVatEntry> {
public:
	SLAPI  BillVatArray();
	int    SLAPI Add(double rate, double sum, double base, double amtByVat);
	BillVatEntry * GetByRate(double rate) const;
};
//
// Флаги функции PPBillPacket::CalcTotal
//
#define BTC_CALCSALESTAXES  0x0001L // Рассчитывать налоги
#define BTC_CALCOUTAMOUNTS  0x0002L // Рассчитывать суммы для вывода
	// (В этом случае расчитывается только номинальная сумма и налоги по номинальной сумме).
#define BTC_EXCLUDEVAT      0x0004L // При расчете налогов считать, что НДС
	// отсутствует (if BTC_CALCOUTAMOUNTS only)
#define BTC_ONLYUNLIMGOODS  0x0008L // Рассчитывать суммы только для нелимитирумых товаров
#define BTC_CALCNOMINALGVAT 0x0010L // Рассчитывает суммы налогов исходя из номинальной
	// ставки НДС, определенной для товаров (не принимает во внимание налоговую группу по лоту
	// и признак освобождения поставщика от НДС).
	// Флаг действителен только если установлен BTC_CALCSALESTAXES.

struct BillTotalData {
	enum {
		fAllGoodsUnlim = 0x0001, // Все товары в документе - нелимитированные
		fExtCost       = 0x0002, // Документ содержит распределенную себестоимость
		fInitialized   = 0x0004  // Структура инициализирована рассчетом PPBillPacket::CalcTotal
	};
	SLAPI  BillTotalData();
	void   Clear();

	long   LinesCount;
	long   GoodsCount;
	long   Flags;
	double UnitsCount;
	double PhUnitsCount;
	double PackCount;
	double Brutto;         // Масса брутто входящего в документ товара, кг
	double Volume;         // Объем брутто входящего в документ товара, м*м*м
	double Amt;            // Номинальная сумма
	double CurAmt;         // Номинальная сумма в валюте
	double VAT;            // НДС в номинальных ценах
	double CVAT;           // НДС в ценах поступления //
	double PVAT;           // НДС в ценах реализации  //
	double Excise;         // Акциз
	double CExcise;        // Акциз в ценах поступления //
	double STax;           // Налог с продаж
	double CSTax;          // Налог с продаж в ценах поступления //

	AmtList      Amounts;  // @anchor
	BillVatArray VatList;
	BillVatArray CostVatList;  //
	BillVatArray PriceVatList; //
};
//
// Флаги слияния товарных строк документа для функции EnumTItemsExt
//
#define ETIEF_UNITEBYGOODS    0x0001L // Объединять строки с одинаковым товаром
#define ETIEF_DIFFBYCOST      0x0002L // Не объединять, если различаются Cost
#define ETIEF_DIFFBYPRICE     0x0004L // Не объединять, если различаются Price
#define ETIEF_DIFFBYINTAXGRP  0x0008L // Не объединять, если различаются LotTaxGrpID
#define ETIEF_DIFFBYPACK      0x0010L // Не объединять, если различаются UnitPerPack
#define ETIEF_DIFFBYQCERT     0x0020L // Не объединять, если различаются QCert
#define ETIEF_DIFFBYNETPRICE  0x0040L // Не объединять, если различаются NetPrice()
#define ETIEF_DIFFBYLOT       0x0080L // Не объединять, если различаются лоты
#define ETIEF_SORTBYNAME      0x0100L // Сортировать по наименованию товара
#define ETIEF_SORTBYCODE      0x0200L // Сортировать по коду
#define ETIEF_SALDOFILTGRP    0x0400L // Перечислять также те товары из группы FiltGrpID
	// которые не представлены в документе, но по которым есть ненулевое сальдо в разрезе
	// контрагента по документу.
#define ETIEF_LABELQUOTPRICE  0x0800L // @internal
#define ETIEF_DISPOSE         0x1000L // Включить в итерацию информацию о размещении строк по складским ячейкам
#define ETIEF_DONTUNITE       0x2000L // @v8.8.0 Безусловный запрет на объединение строк
#define ETIEF_FORCEUNITEGOODS 0x4000L // @v9.6.3 Форсированное объединение строк с одинаковым товаром (без оглядки на дополнительные условия).
	// ETIEF_DONTUNITE имеет приоритет над ETIEF_FORCEUNITEGOODS

#define SALDOLIST_POS_BIAS    100000

class TiIter {
public:
	enum Order {
		ordDefault = 0,
		ordByGoods,
		ordByGrpGoods,
		ordByBarcode,
		ordBySuppl,             //
		ordByLocation,          //
		ordByPLU,               //
		ordByQCert,             //
		ordByStorePlaceGrpGoods //
	};
	//
	// ARG(pPack     IN):
	// ARG(flags     IN): флаги перечисления ETIEF_XXX
	// ARG(filtGrpID IN): ид фильтрующей товарной группы
	// ARG(Order     IN): порядок сортировки строк
	//
	SLAPI  TiIter(PPBillPacket * pPack, long flags, long filtGrpID, Order = ordDefault);
	int    SLAPI Init(const PPBillPacket *, long flags, long filtGrpID, Order = ordDefault);
	int    FASTCALL IsPassedIdx(int idx) const;
	int    SLAPI IsAccsCost() const { return AccsCost; }
private:
	struct IndexItem {
		long   TiPos;
		long   Ext;
		long   DisposePos;
	};

	int    SLAPI OrderRows_Mem(const PPBillPacket *, Order);

	friend class PPBillPacket;
	long   Flags;
	uint   I, PckgI, PckgItemI;
	int    UseIndex;
	int    AccsCost;       // Если 0, то доступ к ценам поступления запрещен
	PPID   FiltGrpID;      // Товарная группа, ограничивающая выборку.
	LongArray Saw;
	TSArray <IndexItem> Index;
	RAssocArray SaldoList; // Список товаров, принадлежащих группе FiltGrpID и ассоциированных с величной сальдо по контаргенту.
	TSArray <LocTransfTbl::Rec> DispList;
};
//
//
//
struct PUGI { // @transient
	SLAPI  PUGI();
	enum {
		fTerminal = 0x0001 // Позиция является терминальной (не зависит от комплектации)
			// Этот признак может быть установлен при формировании элемента по MRP-таблице
	};
	uint   Pos;
	PPID   GoodsID;
	PPID   LocID;        // Location of deficit occurence
	long   Flags;        //
	double Cost;         //
	double Price;        //
	double NeededQty;
	double DeficitQty;
};

class PUGL : public SArray {
public:
	//
	// Descr: Дескриптор подстановки поставщика при списании дефицита
	//
	struct SupplSubstItem {
		SupplSubstItem(uint pos);
		SString & FASTCALL QttyToStr(SString & rBuf) const;

		enum {
			uAbs = 0,
			uPct = 1
		};
		uint   Position; // Номер позиции [1..] в PUGL к которой относится данный дескриптор.
			// Нуль означает, что дескриптор используется как шаблон
		PPID   SupplID;  // ->Article.ID ИД поставщика
		long   Unit;     // SupplSubstItem::uXXX
		double Qtty;     // Количество
	};
	SLAPI  PUGL();
	PUGL & FASTCALL operator = (const PUGL & s);
	int    FASTCALL SetHeader(const BillTbl::Rec *);
	int    SLAPI Add(const ILTI * pItem, PPID locID, uint itemPos, LDATE = ZERODATE);
	int    SLAPI Add(const PUGI *, LDATE = ZERODATE);
	int    SLAPI Add__(const PUGL *);
	int    SLAPI Log(PPLogger * pLogger) const;
	void   FASTCALL GetItemsLocList(PPIDArray & rList) const;
	int    SLAPI GetSupplSubstList(uint pos /*[1..]*/, TSArray <PUGL::SupplSubstItem> & rList) const;
	//
	// Descr: возвращает !0 если все элементы имеют признак PUGI::fTerminal
	//
	int    SLAPI IsTerminal() const;
	int    SLAPI SearchGoods(PPID goodsID, uint * pPos, PUGI * pItem = 0) const;
	void   SLAPI Clear();
	void   SLAPI ClearActions();
	int    SLAPI AddAction(int16);

	int    OPcug;
	PPID   LocID;
	LDATE  Dt;           // Date of the earliest deficit bill
	PPID   SupplAccSheetForSubstID; // @v9.2.1 Идент таблицы статей для подстановки поставщиков
		// Если 0, то подстановка поставщиков не может быть применена.
	uint16 ActionsCount; //
	int16  Actions[9];   //
	int    CostByCalc;
	double CalcCostPct;
	TSArray <SupplSubstItem> SupplSubstList; // Список определителей подстановки поставщиков,
		// применяемый для оприходования дефицита с привязкой к конкретным поставщикам

	static int BalanceSupplSubstList(TSArray <SupplSubstItem> & rList, double neededeQtty);
};
//
//
//
struct CompleteItem {
	enum {
		fExclude = 0x0001, // Этот лот исключен операцией рекомплектации
		fBranch  = 0x0002, // @v9.0.4 Лот, произведенный из исходного лота (выход)
		fSource  = 0x0004  // @v9.0.4 Источник (расход)
	};
	PPID   GoodsID;
	PPID   LotID;
	PPID   BillID;         // Ид документа, сформировавшего строку
	LDATE  Dt;             // Дата документа, сформировавшего эту строку
	LDATE  Expiry;         // Срок годности, лота, соответствующего строке
	PPID   ArID;           // Контрагент по документу, сформировавшему эту строку
	char   Serial[24];
	double Qtty;
	double Cost;
	double Price;
	long   Flags;
};

class CompleteArray : public TSArray <CompleteItem> {
public:
	SLAPI  CompleteArray();
	SLAPI  CompleteArray(const CompleteArray &);
	CompleteArray & FASTCALL operator = (const CompleteArray &);
	int    SLAPI IsExcludedLot(PPID lotID) const;
	int    SLAPI RemoveExludedItems(PPID exclLotID);
	int    SLAPI SearchLotID(PPID lotID, uint * pPos, CompleteItem *) const;
	int    SLAPI SearchGoodsID(PPID goodsID, uint * pPos, CompleteItem *) const;

	PPID   LotID;  // Лот, по которому строится массив
	PPID   BillID;
};
//
//
//
#define PPLNKFILE_ISNEW 0x00000001L

struct PPLinkFile {
	SLAPI  PPLinkFile();
	int    SLAPI Init(const char * pPath);
	size_t SLAPI Size() const;
	int    FASTCALL CopyFrom(const void * pBuf);
	int    SLAPI CopyTo(void ** ppBuf);

	PPID    Id;
	long    Flags;
	SString Ext;
	SString Path;
	SString Description;
};

class PPLinkFilesArray : public TSCollection <PPLinkFile> {
public:
	SLAPI  PPLinkFilesArray(const char * pStoreDir = 0);
	PPLinkFilesArray & FASTCALL operator = (const PPLinkFilesArray & s);
	int    SLAPI Init(const char * pStoreDir);
	int    SLAPI Add(PPLinkFile * pLink, uint * pPos);
	int    SLAPI AddNewByExt(const char * pExt, const char * pDescr, uint * pPos);
	int    SLAPI Remove(uint pos);
	int    SLAPI RemoveByAry(const PPLinkFilesArray * pAry);
	int    SLAPI GetFilePath(PPID id, const char * pExt, SString & rFilePath) const;
	int    SLAPI GetFilePath(uint pos, SString & rFilePath) const;
	int    SLAPI Edit(uint pos);
	int    SLAPI EditDescr(uint pos);
	int    SLAPI ReadFromProp(PPID billID);
	int    SLAPI WriteToProp(PPID billID, int useTa);
private:
	int    SLAPI CreateWordFile(const char * pPath);
	int    SLAPI CreateExcelFile(const char * pPath);
	PPID   SLAPI GetNewId() const;
	struct _Entry {
		PPID   Tag;            // Const=PPOBJ_BILL
		PPID   ID;             // BillID
		PPID   Prop;           // Const=BILLPRP_LINKFILES
		int16  ItemsCount;
		int16  Size;
	};
	SString StoreDir;
};

typedef TSArray <PPTransferItem> PPTrfrArray;
typedef TSArray <InventoryTbl::Rec> InventoryArray;
//
// Descr: Варианты распределения дополнительной себестоимости на себестоимость
//   отдельных строк товарного документа.
//
enum {
	ecalgCost = 1, // Пропорционально сумме в ценах поступления (без учета дополнительной себестоимости)
	ecalgPrice,    // Пропорционально сумме в ценах реализации
	ecalgQtty,     // Пропорционально количеству
	ecalgPhQtty,   // Пропорционально физическому количеству
	ecalgBrutto,   // Пропорционально массе брутто
	ecalgVolume,   // Пропорционально объему
};
//
// @todo @dbd_exchange Увеличить длину поля примечания //
//
class PPBillPacket : public PPBill {
public:
	enum PoolKind {
		bpkNone  = -1, // Отсутствует принадлежность пулу
		bpkOpBill = 0, // Управляемый пул документов (принадлежит документу)
		bpkReckon = 1, // Зачитывающие документы
		bpkCSess,      // Документы списания кассовой сессии
		bpkTSess,      // Документы списания технологической сессии
		bpkCSessDfct,  // Документы покрытия дефицита по кассовым сессиям
		bpkTSessDfct,  // Документы покрытия дефицита по технологическим сессиям
		bpkTodo,       // Документы, привязанные к задачам
		bpkPrj,        // Документы, привязанные к проектам
		bpkPrjPhase,   // Документы, привязанные к фазма проектов
		bpkTSessPaym   // @v8.0.3 Документы оплаты технологической сессии. Проецируется в тот же
			// тип ассоциации пулов документов, что и bpkTSess.
	};

	static PPBillPacket::PoolKind SLAPI ObjAssocToPoolKind(PPID assocID);
	static PPID SLAPI PoolKindToObjAssoc(PPBillPacket::PoolKind kind);

	SLAPI  PPBillPacket();
	SLAPI  PPBillPacket(const PPBillPacket & rS);
	SLAPI ~PPBillPacket();
	PPBillPacket & FASTCALL operator = (const PPBillPacket & rS);
	void   SLAPI destroy();
	int    FASTCALL Copy(const PPBillPacket & rS);
	int    SLAPI CreateBlank(PPID opID, PPID linkBill, PPID locID, int use_ta);
	int    SLAPI CreateBlank_WithoutCode(PPID oprKind, PPID linkBill, PPID locID, int use_ta);
	int    SLAPI CreateBlank2(PPID opID, LDATE dt, PPID locID, int use_ta);
	//
	// Descr: пытается из элементов массива ShLots создать теневой пакет. Если ей удается это сделать,
	//   то возвращает >0, если больше ни одного теневого пакета создать невозможно, то возвращает <0.
	//   В случае ошибки - 0. Те строки, которые уже использовались для создания теневых пакетов отмечаются //
	//   флагом TFlags & PPTransferItem::tfDirty. Поэтому перед первым вызовом следует сбросить этот флаг для всех элементов
	//   массива ShLots (если, конечно, он не нулевой) либо предварительно вызвать ее с нулевым параметром
	//   shadow. Эта функция самостоятельно инициализирует пакет shadow.
	//
	int    SLAPI CreateShadowPacket(PPBillPacket * pShadow);
	int    SLAPI CreateBlankBySample(PPID sampleBillID, int use_ta);
	int    SLAPI CreateBlankByFilt(PPID opID, const BillFilt * pFilt, int use_ta);
	//
	struct SetupObjectBlock {
		SLAPI  SetupObjectBlock();
		void   SLAPI Clear_();

		enum {
			fEnableStop = 0x0001 // @v9.5.10 Допускается устанавливать контрагента с признаком STOP
		};
		long   Flags; // @v9.5.10 [IN] Флаги вызова функции PPBillPacket::SetupObject
		enum {
			stHasCliAgreement   = 0x0001,
			stHasSupplAgreement = 0x0002
		};
		long   State;
		PPID   PsnID;
		SString Name;
		LAssocArray RegInfoList; // Список регистров, с которыми у контрагента существует проблема.
			// Поле Key каждого элемента хранит ID типа регистрационного документа,
			// а поле Val либо ID просроченного регистра персоналии, либо 0, если
			// контаргент должна иметь такой регистр, но не имеет.
		PPClientAgreement CliAgt;
		PPSupplAgreement  SupplAgt;
	};

	int    SLAPI SetupObject(PPID arID, SetupObjectBlock & rRet);
	int    SLAPI SetupObject2(PPID arID);
	LDATE  SLAPI CalcDefaultPayDate(int paymTerm, long paymDateBase) const;
	int    SLAPI SetupDefaultPayDate(int paymTerm, long paymDateBase);
	//
	// Descr: Возвращает адрес электронной почты, наиболее близко
	//   согласующийся с контекстом документа. Чаще всего, это - адрес
	//   контрагента, но не обязательно.
	//   Функция реализована с целью автоматизации пересылки
	//   результатов экспорта отчетов.
	//
	int    SLAPI GetContextEmailAddr(SString & rBuf) const;
	//
	// Descr: Заносит в массив rList список идентификаторов документов заказа, которые
	//   обслуживаются данным пакетом.
	//   Массив rList очищается в начале выполнения этой функции //
	// Returns:
	//   >0 - данный документ обслуживает как минимум один документ заказа
	//   <0 - данный документ не обслуживает документы заказов
	//   0  - ошибка
	//
	int    FASTCALL GetOrderList(PPIDArray & rList) const;
	//
	// Descr: Возвращает статус синхронизации документа.
	// Note: Аналогичный (но более подробный) результат можно получить
	//   используя функцию ObjSyncCore::GetSyncStatus() однако данная  функция //
	//   сохраняет результат первого вызова ObjSyncCore::GetSyncStatus() во внутреннем
	//   состоянии this с тем, чтобы ускорить последующие аналогичные вызовы.
	// Returns:
	//     >0 - документ синхронизирован с другим разделом
	//     <0 - документ не синхронизирован
	//
	int    SLAPI GetSyncStatus();
	int    FASTCALL EnumTItems(uint *, PPTransferItem **) const;
	int    SLAPI GetNextPLU(long * pPLU, SString & rObjAsscName);
	//
	// Descr: перечисляет товарные строки документа с одновременным слиянием,
	//   определяемым флагами flags. Если pIter == 0, то используется внутренний
	//   итератор, который должен быть предварительно инициализирован вызовом InitExtTIter.
	//
	int    SLAPI InitExtTIter(long flags, long filtGrpID = 0, TiIter::Order = TiIter::ordDefault);

	struct TiItemExt {
		TiItemExt();
		void   Clear();

		SString Clb;
		SString Pckg;
		LocTransfTbl::Rec LctRec;
		LongArray MergePosList; // Список позиций Lots (0..), слитых в одну в результате вызова MergeTI
	};
	int    SLAPI EnumTItemsExt(TiIter * pIter, PPTransferItem * pTi, TiItemExt * pExt = 0);
	uint   SLAPI GetTCount() const;
	int    FASTCALL SetTPointer(int);
	int    SLAPI GetTPointer() const;
	int    FASTCALL ChkTIdx(int) const;
	PPTransferItem & FASTCALL TI(uint) const;
	const  PPTransferItem & FASTCALL ConstTI(uint) const;
	const  PPTrfrArray & SLAPI GetLots() const;
	//
	// Descr: Функция устанавливает список строк документа пакета из источника rS.
	// Note: Ни в коем случае не используйте эту функцию, она предназначена только для аварийного
	//   восстановления пакета после ошибки в проведении.
	//
	int    SLAPI SetLots(const PPTrfrArray & rS);
	int    FASTCALL SearchTI(int rByBill, uint * pPos) const;
	int    SLAPI UsesDistribCost() const;
	//
	// Descr: заносит элемент pItem в список товарных строк документа
	// ARG(pItem   IN): @#{ptr} указатель на элемент для вставки в список
	// ARG(pClb    IN): @#{vptr0} номер ГТД, ассоциированный со строкой
	// ARG(pSerial IN): @#{vptr0} серийный номер, ассоциированный со строкой
	// Returns:
	//   !0 - элемент успешно добавлен в список
	//   0  - ошибка при добавлении элемента. pPos - не определен.
	//
	int    SLAPI LoadTItem(const PPTransferItem * pItem, const char * pClb, const char * pSerial);
	int    FASTCALL AddShadowItem(const PPTransferItem *);
	int    SLAPI AddShadowItem(const PPTransferItem * pOrdItem, uint * pPos);
	int    SLAPI InitACPacket();
	int    SLAPI CreateAccTurn(PPAccTurn *) const;
	int    SLAPI UngetCounter();
	void   SLAPI SetQuantitySign(int minus /*= -1*/);
	//
	// Descr: Сортирует строки по параметру PPTransferItem::RByBill
	// Note: Использовать очень аккуратно, поскольку существуют привязки к позициям строк в массиве Lots
	//
	void   SLAPI SortTI();
	//
	// Descr: Факторы различий строк пакетов при сравнении
	//
	enum {
		tidfQtty               = 0x0002, // Отличается количество
		tidfCost               = 0x0004, // Отличается цена поступления
		tidfPrice              = 0x0008, // Отличается учетная цена реализации
		tidfNetPrice           = 0x0010, // Отличается чистая цена (Price-Discount)
		tidfThisAbsent         = 0x0020, // В пакете this отсутствует строка, соответствующая строке в other
		tidfOtherAbsent        = 0x0040, // В пакете other отсутствует строка, соответствующая строке в this
		tidfRByBillPrec        = 0x0080, // Сравнение документов осуществляется с точностью до номера строки
			// (имеется в виду внутренний идентификатор позиции RByBill)
		tidfIgnoreGoods        = 0x0100, // @v8.9.4 Игнорировать отличие товаров в сравниваемых строках
		tidfStrictEgaisCodeTag = 0x0200, // @v8.9.4 Сопоставлять код ЕГАИС в теге лота
		tidfIgnoreSign         = 0x0400  // @v8.9.6 При сопоставлении игнорировать знаки операци (приход/расход)
	};
	struct TiDifferenceItem {
		TiDifferenceItem(long flags, const LongArray * pThisPList, const LongArray * pOtherPList);
		LongArray ThisPList;  // Список позиций строки в this
		LongArray OtherPList; // Список позиций строки в сравниваемом пакете
		long   Flags;     // Факторы расхождений
		double ThisQtty;
		double OtherQtty;
		double ThisCost;
		double OtherCost;
		double ThisPrice;
		double OtherPrice;
		double ThisNetPrice;
		double OtherNetPrice;
	};
	//
	// Descr: Функция сравнения товарных строк пакета this с пакетом rS.
	// ARG(rS         IN): Пакет документа, с которым сравнивается this
	// ARG(tidFlags   IN): PPBillPacket::tidfXXX Опции сравнения. Определяет флаги, соответствующие критериям сравнения строк.
	// ARG(filtGrpID  IN): Фильтрующая товарная группа ограничивающая перечисляемые строки пакетов.
	// ARG(rDiffList OUT): Результат сравнения - список элементов TiDifferenceItem определяющих рассогласование строк пакетов.
	//   Если при завершении функции список пуст, значит пакеты в пределах заданных критериев эквивалентны.
	//
    int    SLAPI CompareTI(PPBillPacket & rS, long tidFlags, long filtGrpID, TSCollection <TiDifferenceItem> & rDiffList);
    int    SLAPI CompareTIByCorrection(long tidFlags, long filtGrpID, TSCollection <TiDifferenceItem> & rDiffList);
	int    SLAPI SetPoolMembership(PoolKind billPoolKind, PPID poolID);
	//
	// Descr: Возвращает номинальную сумму из записи документа.
	//   Если параметр minus != 0, то возвращается значение с инвертированным знаком.
	//
	double FASTCALL GetAmount(int minus = 0) const;
	//
	// Descr: Возвращает номинальную сумму документа в базовой валюте.
	//   Если Rec.CurID, то результат эквивалентен GetAmount(int),
	//   в противном случае возвращается GetAmount(minus) * Amounts.Get(PPAMT_CRATE, Rec.CurID).
	//
	double FASTCALL GetBaseAmount(int minus = 0) const;
	int    SLAPI GetQuotKindList(PPIDArray * pList);
	int    SLAPI GetQuotExt(const PPTransferItem & rTi, double * pPrice);
	//
	// Descr: распределяет заданную на весь документ скидку по товарным строкам пакета.
	// ARG(dis       IN): значение скидки. Если dis == 0, то во всех строках значение скидки обнуляется.
	// ARG(pctdis    IN): если !0, то скидка задана в процентах (не в долях
	//   от единицы, а именно в процентах).
	// ARG(rmvexcise IN): указывает на необходимость снятия со всех строк налога с продаж.
	//   Скидка в этом случае рассчитывается на сумму без налога с продаж.
	//
	void   SLAPI SetTotalDiscount(double dis, int pctdis, int rmvexcise);
	int    SLAPI SumAmounts(AmtList *, int fromDB = 0);
	int    SLAPI InitAmounts(const AmtList *);
	int    SLAPI InitAmounts(int fromDB = 0);
	//
	// Descr: Идентифицирует долговую размерность, которой принадлежи документ.
	//   Идентификатор размерности возвращается по указателю pDebtDimID.
	// Returns:
	//   1 - найдена единственная размерность, соответствующая пакету.
	//   2 - существует более одной размерности, соответствующей пакету. Однако, по указателю
	//       pDebtDimID присвоено значение одной из них (порядок не документирутеся, такио образом,
	//       существует неопределенность).
	//  <0 - не найдено ни одной размерности, которой соответствова бы пакет.q
	//  0  - ошибка.
	//
	int    SLAPI GetDebtDim(PPID * pDebtDimID) const;
	int    SLAPI CalcModifCost();
	int    SLAPI CalcTotal(BillTotalData *, long btcFlags /* BTC_XXX */);
	int    SLAPI CalcTotal(BillTotalData *, PPID goodsTypeID, long btcFlags /* BTC_XXX */);
	int    SLAPI SearchGoods(PPID goodsID, uint * pPos) const;
	//
	// Descr: Опции функции CheckGoodsForRestrictions()
	//
	enum {
		cgrfAll              = 0xffffffff, // Полная проверка
		cgrfObject           = 0x00000001, // Проверять по статье документа
		cgrfObject2          = 0x00000002, // Проверять по дополнительной статье документа
		cgrfMatrix           = 0x00000004, // Проверять соответствие товарной матрице
		cgrfGoodsGrpRestrict = 0x00000008, // Проверять соответствие ограничению пользователя по товарным группам
		cgrfShipmControl     = 0x00000010, // @v8.1.11 Проверять на согласованность с предыдущими отгрузками/возвратами
		cgrfModifCmplmnry    = 0x00000020, // @v8.8.6 Проверять на комплементарность товаров в документе модификации
		cgrfQtty             = 0x00000040  // @v8.8.7 Проверять критерии в которых фигурирует количество товара
	};
	struct CgrRetBlock {
		CgrRetBlock();

		long   ScpDuration;
		long   ScpShipmBillCount;
		long   ScpRetBillCount;
		double ScpShipmQtty;
		double ScpRetQtty;
		double ScpResult;
		RealRange ScpRange;
	};
	//
	// Descr: Проверяет товар goodsID на допустимость нахождения в документе this.
	// ARG(rowIdx   IN): @[0..] Индекс строки документа, в которой находится проверяемый товар.
	//   Если rowIdx < 0, то проверяемый товар еще не в документе
	// ARG(goodsID  IN): ИД товара
	// ARG(sign     IN): @#{TISIGN_MINUS || TISIGN_PLUS || TISIGN_UNDEF} Знак операции.
	//   Имеет значение только при rowIdx < 0, в противном случае знак опредяляется из параметров существующей строки
	// ARG(qtty     IN): Количество товара
	// ARG(flags    IN): Флаги PPBillPacket::cgrfXXX
	// ARG(pRetBlk OUT): Указатель на блок, в который записывается информация о проверке
	//
	int    SLAPI CheckGoodsForRestrictions(int rowIdx, PPID goodsID, int sign, double qtty, long flags, CgrRetBlock * pRetBlk);
	int    SLAPI SearchLot(PPID lot, uint * pos) const;
	int    SLAPI SearchShLot(PPID lot, uint * pos) const;
	//
	// Следующие две функции определяют остаток по заданному лоту и заказному лоту соответственно
	// в контексте пакета. Вместе с идентификатором лота и указателем на остаток им необходимо
	// передать указатель на один элемент и его позицию в пакете. Это используется в диалоге
	// редактирования элемента пакета. Если передаваемый элемент не является членом пакета, то
	// его позиция должна быть равна -1. В этом случае можно вместо указателя на элемент передать
	// нулевой указатель. Функции RestByOrderLot передается элемент ShLots.
	// Нулевой ид лота обрабатывается нормально. Если rest == 0, то
	// возвращается 0.
	//
	int    SLAPI RestByLot(PPID, PPTransferItem *, int pos, double *) const; // @>>BillObj->trfr->GetRest
	int    SLAPI RestByOrderLot(PPID, const PPTransferItem *, int pos, double *) const;
	//
	// Descr: аналогична Transfer::GetBounds, но в контексте пакета.
	//   Относительно 2-го и 3-го параметров см. предыдущие комментарии.
	//
	int    SLAPI BoundsByLot(PPID lotID, const PPTransferItem * pTi, int pos, double * pDown, double * pUp) const;
		// @>>Transfer::GetBounds
	//
	// Descr: вычисляет остаток товара, перебирая все открытые лоты и вызывая RestByLot
	//   или RestByOrderLot в зависимости от знака goods. Если goodsID < 0, то по указателю pReserve
	//   возвращается зарезервированное количество товара (лоты заказов, имеющие признак LOTF_ORDRESERVE).
	//
	int    SLAPI GoodsRest(PPID goodsID, const PPTransferItem *, int pos, double * pRest, double * pReserve = 0);
	int    SLAPI CalcShadowQuantity(PPID lot, double * pQtty) const;
	int    SLAPI InsertRow(const PPTransferItem *, IntArray *, int pcug = PCUG_CANCEL);
	int    SLAPI RemoveRow(uint *);
	int    SLAPI RemoveRow(uint);
	int    SLAPI RemoveRows(IntArray * pPositions, int lowStop = 0);
	int    SLAPI ShrinkTRows(long fl = (ETIEF_DIFFBYLOT | ETIEF_UNITEBYGOODS));
	int    SLAPI InsertComplete(PPGoodsStruc * pGs, uint pos, PUGL *, int pcug, const GoodsReplacementArray * pGra = 0);
	int    SLAPI InsertPartitialStruc();
	int    SLAPI InsertAutoComplRow(uint pos, int pcug = PCUG_CANCEL);
	int    SLAPI UpdateAutoComplRow(uint pos, int pcug = PCUG_CANCEL);
	int    SLAPI RemoveAutoComplRow(uint pos);
	int    SLAPI GetComplete(PPID lotID, CompleteArray * pList);
	//
	// Descr: возвращает значение >0 если пакет относится к операции модификации и содержит
	//   как минимум одну товарную строку, помеченную признаками PPTFR_PLUS и
	//   PPTFR_RECEIPT (независимый выход). Такие строки недопустимы в пакете рекомплектации.
	//
	int    SLAPI HasIndepModifPlus() const;
	//
	// Descr: используется в диалоге TrfrItemDialog. Это весьма развитая функция.
	//   Она добавляет новую или изменяет существующую товарную строку, одновременно обрабатывая все
	//   служебные данные, связанные с этой строкой (заказ, автокомплект, дополнительное количество
	//   расходуемого товара сверх остатка текущего лота).
	//
	int    SLAPI SetupRow(int itemNo, PPTransferItem * pItem, const PPTransferItem * pOrdItem, double extraQtty);
	int    SLAPI AttachRowToOrder(int itemNo, const PPBillPacket * pOrdPack);
	int    SLAPI AttachToOrder(const PPBillPacket * pOrdPack);
	int    SLAPI SetupItemQuotInfo(int itemNo, PPID quotKindID, double quotValue, long flags);
	//
	// Descr: Проверяет размер документа и, если он слишком большой и genWarn != 0,
	//   то предупреждает об этом и рекомендует его сохранить, при этом
	//   возвращает !0. Если размер документа приемлем, то возвращает 0.
	//
	int    SLAPI CheckLargeBill(int genWarn) const;
	//
	// Descr: Преобразует пакет товарного документа в пакет кассового чека.
	//   Функция пригодна только для печати чека.
	//
	int    SLAPI ConvertToCheck(CCheckPacket * pCheckPack) const;
	int    SLAPI SetCurTransit(const PPCurTransit * pTrans /* In */);
	int    SLAPI GetCurTransit(PPCurTransit * pTrans /* Out */) const;
	int    SLAPI AddPckg(LPackage *);
	int    SLAPI CalcPckgTotals();
	//
	// Descr: инициализирует идентификаторы лотов пакета перед занесением пакета в базу данных.
	// @! Really PRIVATE function.
	//
	int    SLAPI InitPckg(); // @<<PPObjBill::PutPackgList
	//
	// Returns:
	//   !0 - вид операции (Rec.OpID), к которой относится данный пакет принадлежит
	//      одному из типов: {PPOPT_DRAFTRECEIPT, PPOPT_DRAFTEXPEND, PPOPT_DRAFTTRANSIT}
	//   0  - в противном случае
	//
	int    SLAPI IsDraft() const; //
	int    SLAPI IsGoodsDetail() const;
	int    SLAPI SetupVirtualTItems();
	int    SLAPI RemoveVirtualTItems();
	//
	// Descr: Извлекает идентификатор главной организации в контектсе пакета документа.
	// Note: Чаще всего результат идентичен вызову функции ::GetMainOrgID(), однако,
	//   если (PPBillConfig::Flags & BCF_EXTOBJASMAINORG) и дополнительная статья документа
	//   ссылается на главную организацию, то результатом будет эта главная организация.
	//
	int    SLAPI GetMainOrgID_(PPID * pID) const;
	//
	// Descr: Устанавливает GUID документа в значение rGuid. Если rGuid.IsZero(), то удаляет то, что есть.
	//
	int    SLAPI SetGuid(const S_GUID & rGuid);
	//
	// Descr: Генерирует GUID документа и уставливает его в пакет функцией SetGuid
	//
	int    SLAPI GenerateGuid(S_GUID * pGuid);
	//
	// Descr: Извлекает GUID документа из пакета. Если пакет не содержит GUID, то
	//   возвращает 0 и присваевает rGuid пустое значение.
	//
	int    SLAPI GetGuid(S_GUID & rGuid);
	//
	//
	//
	int    SLAPI AddTSessCip(PPID tsessID, const char * pPlaceCode, PPID personID);
	//
	// Поля ErrCause & ErrLine служат для диагностики ошибок при проводке документа.
	// Их значения существенны только в случае, если произошла ошибка в методах
	// PPObjBill::TurnPacket, PPObjBill::UpdatePacket и /PPObjBill::RemovePacket/. Если
	// ErrCause принимает значение err_on_line, то ошибка произошла при проводке (изменении/, удалении/)
	// товарной строки, при этом ErrLine содержит номер строки в массиве Lots. Если ErrCause
	// принимает значение err_on_accturn, то ошибка произошла в одной из бух. проводок документа.
	// Тогда ErrLine принимает номер этой проводки. ErrLine == -1 означает, что невозможно точно
	// указать строку с ошибкой.
	//
	enum {
		err_on_line = 1,
		err_on_accturn,
		err_on_advline
	};
	int    ErrCause;
	int    ErrLine;
	PPIDArray TiErrList; // Список номеров [0..] позиций строк, содержащих ошибки
	//
	// Следующее поле используется для указания того, в каких ценах
	// следует выводить документ на печать или на экспорт.
	// 1 - в ценах поступления (cost),
	// 2 - в ценах реализации (price-discount),
	// other - в обеих ценах (номинал по умолчанию)
	//
	int    OutAmtType;
	PPID   QuotKindID;         // @transient Вид котировки, применяемый в документе.
		// Актуально только во время одной сессии редактирования документа.
	PPID   AgtQuotKindID;      // @transient Вид котировки из соглашения с клиентом
		// Используется в диалогах товарных строк документов для выбора котировки
	PPID   OpTypeID;   // @v9.5.3 OprType-->OpTypeID
	PPID   AccSheetID; // @v9.5.3 AccSheet-->AccSheetID
	long   Counter;
	//
	// P_ShLots - теневые строки, отражающие исполнение заказов.
	// Строки Lots ссылаются на P_ShLots как OrdLotID->LotID.
	// Отношение типа многие-к-одному. То есть ShLots содержит
	// не более одного элемента с заданным лотом, на который
	// могут ссылаться более одного элемента из Lots.
	//
	PPTrfrArray * P_ShLots;
	TSArray <PPAccTurn> Turns; //
	PPAdvBillItemList AdvList; // Элементы расширения бух документа
	PPBillPacket * P_ACPack;   // Агрегированный пакет автокомплектации
	PPBillPacket * P_Outer;    // @notowned Внешний (агрегирующий) пакет
	PPBillPacket * P_LinkPack; // @transient Пакет связанного документа
	LPackageList * P_PckgList; //

	struct QuotSetupInfoItem {
		QuotSetupInfoItem();

		enum {
			fMissingQuot = 0x0001,
			fInvalidQuot = 0x0002
		};
		uint   TiPos;
		long   Flags;
		PPID   QkID;
		double Value;
	};
	TSArray <QuotSetupInfoItem> * P_QuotSetupInfoList;
	//
	// @todo Следующие четыре контейнера необходимо объединить в общий контейнер поскольку
	//  они представляют однотипные объекты (теги).
	//
	ClbNumberList  ClbL;       // Список номеров ГТД
	ClbNumberList  SnL;        // Список серийных номеров лотов
	PPLotTagContainer LTagL;   // Список тегов лотов
	PPLotTagContainer * P_MirrorLTagL; // Список тегов зеркальных лотов (созданных при межскладском перемещении)
	ObjTagList     BTagL;      // Список тегов документа
	//
	PPID   PaymBillID;         // @*PPObjBill::ExtractPacket Платежный документ (зачеты).
	PPID   CSessID;            // Кассовая или технологическая сессия, которую списывает документ
	PPID   SampleBillID;       // Документ, по образцу которого создается this документ
	//
	// Descr: Флаги обработки документа
	//
	enum { // @transient
		pfHasVirtualTI          = 0x00000001, // Пакет содержит виртуальные товарные строки
		pfPrintOnlyUnlimGoods   = 0x00000002, // Вывод на печать только нелимитируемых товаров
		pfPrintPLabel           = 0x00000004, // Печатать ценник
		pfPrintQCertList        = 0x00000008, // Серификаты к документу печатать списком "для каждого товара - все серитфикаты"
		pfViewPercentOnTurn     = 0x00000010, // Показывать проценты при проведении документа
		pfErrOnTiLoading        = 0x00000020, // Признак ошибки загрузки товарных строк документа
			// Устанавливается функцией Transfer::LoadItems
		pfPrintTareSaldo        = 0x00000040, // Печатать сальдо по отгрузке тары
		pfAllGoodsUnlim         = 0x00000080, // @*PPBillPacket::CalcTotal() Все товары в документе - нелимитированные
		pfHasExtCost            = 0x00000100, // @*PPBillPacket::SumAmounts() Товарный документ содержит
			// распределенную себестоимость. Флаг используется при редактировании строк документа с целью быстро
			// определить необходимость пересчета себестоимости.
		pfPrintChangedPriceOnly = 0x00000200, // Печать только тех товаров, цены на которые изменились в сравнении с последним лотом
		pfRestrictByArCodes     = 0x00000400, // Запрет на добавление в документ товаров, не имеющих
			// кода, связанного с основной статьей документа.
		pfSubCostOnSubPartStr   = 0x00000800, // При распределении частичной структуры, вычитающей количество
			// из основного товара, уменьшать себестоимость документа.
			// @seealso AGTF_SUBCOSTONSUBPARTSTR
		pfChargeSCard           = 0x00001000, // С документом связана карта и есть сумма, по которую
			// необходимо начислить на кредитную карту.
		pfForeignSync           = 0x00002000, // @v8.0.3 Пакет создан в рамках приема данных из другого раздела
		pfIgnoreStatusRestr     = 0x00004000, // @v8.6.6 При изменении документа игнорировать ограничения статуса
		pfForceRByBill          = 0x00008000, // @v8.8.6 Для новых строк документа использовать тот RByBill, который указан (не обнулять)
		pfNoLoadTrfr            = 0x00010000, // @v9.4.3 @construction При загрузке и обработке документа не следует загружать товарные строки
		pfUpdateProhibited      = 0x00020000  // @v9.5.1 Проведение этого пакета функцией PPObjBill::UpdatePacket запрещено
			// (например, по причене не полной загрузки).
	};
	long   ProcessFlags;       // @transient
	PPLinkFilesArray LnkFiles;
	//
	// @v8.7.8 Список персональных регистраций, ассоциированных с документом.
	// Note: Здесь нельзя использовать высокоуровневый класс PPCheckInPersonArray
	//   поскольку он полностью ассоциирован с одной техсессией в то время как
	//   с документом может быть связано несколько регистраций, принадлежащих разным сессиям.
	//
	struct CipBlock {
		SLAPI  CipBlock();
		SLAPI  CipBlock(const CipBlock & rS);
		SLAPI ~CipBlock();
		CipBlock & FASTCALL operator = (const CipBlock & rS);
		int    FASTCALL Copy(const CipBlock & rS);
		void   SLAPI destroy();

		TSArray <PPCheckInPersonItem> * P_CipList;
		PPObjTSession * P_TSesObj;
	};
	CipBlock CipB;
	LDATETIME LoadMoment; // @transient Момент загрузки пакета из базы данных.
private:
	void   SLAPI Helper_Init();
	int    SLAPI _CreateBlank(PPID oprKind, PPID linkBill, PPID locID, int dontInitCode, int use_ta);
	int    SLAPI AdjustLotQtty(PPID lot, const PPTransferItem *, int, double *) const;
		// @>>BillObj->trfr->SubtractBillQtty()
	int    SLAPI MergeTI(PPTransferItem * pItem, int idx, long flags, LongArray & rTotalMergeList, LongArray * pMergePosList);
	int    SLAPI Helper_DistributeExtCost(double extCostSum, int alg);
	int    SLAPI DistributeExtCost();

	PPTrfrArray Lots;
	TiIter * P_Iter;
	PPObjBill * P_BObj;
	LAssocArray * P_GoodsGrpRestrict; // @transient Список товарных групп, с которыми ассоциированы
		// опции ограничений на вставку соответствующих товаров в документ.
	int16  SyncStatus; // Статус синхронизации документа с другими разделами. -2 - состояние не определено
	int16  Reserve;    // @alignment
};
//
// Intermediate Level Bill Packet
// Пакет документа, хранящий товарные строки в формате ILTI.
//
#define ILBPF_LOADAMTNOTLOTS  0x0001   // Загружать список сумм Amounts, а не товарные строки (функция Load)

struct ILBillPacket : public PPBill {
	SLAPI  ILBillPacket();
	SLAPI ~ILBillPacket();
	void   SLAPI destroy();
	//
	// Descr: конвертирует пакет this в пакет документа PPBillPacket.
	//   Параметр *pWarnLevel получает значение 1 если не сошлась номинальная //
	//   сумма исходного и полученного пакетов, значение 2 если хотя бы в одной строчке исходного
	//   пакета осталось ненулевым поле ILTI::Rest. Если таковых проблем не встретилось, то
	//   параметр *warnlevel получает значение 0. Указатель pWarnLevel может быть нулевым
	//   (тогда, естественно, он и не инициализируется в функции).
	//
	int    SLAPI ConvertToBillPacket(PPBillPacket & rPack, int * pWarnLevel, ObjTransmContext * pCtx, int use_ta);
		// @<<PPObjBill::Write
	int    SLAPI ConvertRow(ILTI *, PPBillPacket *);
	int    SLAPI SearchGoodsID(PPID goodsID, uint * pPos) const;
	int    SLAPI SearchRByBill(int rbb, uint * pPos) const;
	int    SLAPI Load(PPID billID, long flags /* ILBPF_XXX */, PPID cvtToOpID = 0);
	int    SLAPI SerializeLots(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		ilbfConvertedIntrExp = 0x0001 // Внутренняя передача конвертированная в межскладской приход.
			// Признак необходим для правильной синхронизации лотов.
	};
	//
	// Так как таблица складов тесно взаимодействует с соответствующей аналитической таблицей,
	// то для переноса документа между разделами базы данных необходимо перенести и ссылку на
	// аналитическую статью, соответствующую складу, которому соответствует документ.
	//
	PPID   LocObj;
	long   IlbFlags;
	TSArray <ILTI> Lots;
	TSArray <PPAccTurn> Turns;
	ClbNumberList  ClbL;       // Список ГТД, ассоциированных с лотами
	ClbNumberList  SnL;        // Список серийных номеров лотов
	PPLotTagContainer LTagL;   // @v7.3.5 Список тегов лотов
	ObjTagList     BTagL;      // @v7.3.5 Список тегов документа
	PPAdvBillItemList AdvList; // Элементы расширения бух документа
	PPIDArray OrderBillList;   // Список документов заказа, которые "закрываются" данным документом
	InventoryArray InvList;    // Список строк инвентаризации
};
//
// Descr: Абстрактный класс-контейнер. Реализация этого интерфейса должна обеспечивать
//   хранение списка выходных дней раздельно по каждому складу (locID).
//   Формат представления выходного дня следующий {DD/MM/YYYY}:
//   1. День недели: {[1..7]/00/0000}
//   2. Календарный день: {DD/MM/0000}
//   3. Дата: {DD/MM/YYYY}
//
class PPHolidays {
public:
	//
	// Возвращает вид выходного дня:
	// 1 - Дата
	// 2 - Календарный день
	// 3 - День недели
	//
	static int    SLAPI GetKind(LDATE);
	static SString & SLAPI Format(LDATE, SString & rBuf);
	//
	// Descr: должна добавить в контейнер новое значение выходного дня или,
	//   если параметр rmv != 0, то удалить указанное значение.
	//   В случае, если rmv != 0 и указанное значение для заданного склада уже существует,
	//   функция должна вернуть -1.
	//   Если rmv == 0 и указанное значение для заданного склада не существует,
	//   функция также должна вернуть -1.
	//   Если добавление или удаление элемента прошло успешно, функция возвращает 1.
	//   В случае ошибки, следует вернуть 0 и инициализировать переменную PPErrCode.
	//
	virtual int SLAPI SetHoliday(PPID locID, LDATE, int rmv) = 0;
	//
	// Descr: должна вернуть !0 если указанная дата для списка складов pLocList
	//   является выходным днем. В противном случае функция должна вернуть 0.
	//
	virtual int SLAPI IsHoliday(const ObjIdListFilt * pLocList, LDATE) = 0;
	virtual int SLAPI EnumHolidays(PPID locID, LDATE *) = 0;
};
//
// Виды связей от зависимого документа к связывающему
//
#define BLNK_ALL        0xffff // Все связанные документы
#define BLNK_SHADOW     0x0001 // Теневые документы
#define BLNK_PAYMENT    0x0002 // Оплаты
#define BLNK_RETURN     0x0004 // Возвраты
#define BLNK_CHARGE     0x0008 // Начисления //
#define BLNK_ACK        0x0010 // Acknowledge
#define BLNK_CHARGEPAYM 0x0020 // Начисление с признаком отрицательной оплаты (OPKF_CHARGENEGPAYM)
#define BLNK_WROFFDRAFT 0x0040 // Документы списания драфт-документа
#define BLNK_PAYMRETN   (BLNK_PAYMENT|BLNK_RETURN)
#define BLNK_EDIRECADV  0x0080 // @v8.8.6 Документы подтверждения получения товара от контрагента, полученные по канала EDI
#define BLNK_CORRECTION 0x0100 // @v8.9.0 Корректирующие документы
//
// Descr: Функция подстановки в метод BillCore::PayPlanEnumerator()
//
typedef int (*PayPlanEnumProc)(PayPlanTbl::Rec *, long);
//
// Descr: реализует общие механизмы работы с документами
//
class BillCore : public BillTbl {
public:
	friend class PPTblEnum <BillCore>;

	static char * SLAPI SetCode(char * code, long f);
	static char * SLAPI GetCode(char * code);
	static SString & SLAPI GetCode(SString & rCode);
	static double SLAPI GetQttyEpsilon();
	//
	// Descr: Возвращает значение статуса ответа (RECADV) на уведомление об отгрузке (DESADV)
	// Returns:
	//    PPEDI_RECADV_STATUS_UNDEF || PPEDI_RECADV_STATUS_ACCEPT || PPEDI_RECADV_STATUS_PARTACCEPT || PPEDI_RECADV_STATUS_REJECT
	//
	static int SLAPI GetRecadvStatus(const BillTbl::Rec & rRec);
	static int SLAPI SetRecadvStatus(int recadvStatus, BillTbl::Rec & rRec);
	static int SLAPI GetRecadvConfStatus(const BillTbl::Rec & rRec);
	static int SLAPI SetRecadvConfStatus(int recadvConfStatus, BillTbl::Rec & rRec);

	SLAPI  BillCore();
	int    SLAPI Search(PPID id, BillTbl::Rec * pRec = 0);
	int    SLAPI GetAmountList(PPID billID, AmtList * pList);
	int    SLAPI GetAmount(PPID, PPID amtTypeID, PPID curID, double *);
	//
	// Descr: Проверяет наличие ссылки на тип суммы amtTypeID в таблице Amounts
	//   (BillAmountTbl).
	// ARG(amtTypeID IN): ИД типа суммы, ссылки на который следует проверить.
	// ARG(pBillID  OUT): @#{vptr0} указатель, по которому функция присвоит ИД документа,
	//   ссылка на который обнаружена в таблице
	// Returns:
	//   >0 - ссылка существует
	//   <0 - ссылок не существует
	//   0  - ошибка
	//
	int    SLAPI CheckAmtTypeRef(PPID amtTypeID, PPID * pBillID);
	int    SLAPI UpdateAmount(PPID, const AmtEntry *, int removeZero);

	int    SLAPI GetPayPlan(PPID billID, PayPlanArray * pList);
	int    SLAPI PutPayPlan(PPID billID, const PayPlanArray *, int use_ta);
	int    SLAPI PayPlanEnumerator(const DateRange *, PayPlanEnumProc, long extraParam);
	int    SLAPI GetLastPayDate(PPID, LDATE *);
	//
	// Descr: Находит последний в хронологическом порядке документ оплаты по документу billID,
	//   сумма которого (оплата) больше нуля.
	// Returns:
	//   >0 - искомый документ оплаты найден
	//   <0 - не найдено ни одного документа оплаты, привязанного к billID и такого, чтобы
	//        сумма была больше нуля и тип операции был PPOPT_PAYMENT.
	//   0  - ошибка
	//
	int    SLAPI GetLastPayment(PPID billID, BillTbl::Rec * pRec);

	int    SLAPI GetExtraData(PPID id, PPBillExt *);
	int    SLAPI PutExtraData(PPID id, const PPBillExt * pExt, int use_ta);
	int    SLAPI Extract(PPID id, PPBill * pPack);
	int    SLAPI EditRec(PPID * pID, BillTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет поле Flags записи документа так, что если set != 0
	//   то флаг flag устанавливается, в противном случае - снимается.
	// Note: функция рассчитана на то, что в аргументе flag установлен только один бит.
	// Returns:
	//   >0 - запись изменена
	//   <0 - флаг в записи уже имеет заданное значение - ничего не изменялось.
	//   0  - ошибка.
	//
	int    SLAPI SetRecFlag(PPID billID, long flag, int set, int use_ta);
	//
	// Descr: Функция аналогична SetRecFlag, но модифицирует поле BillTbl::Flags2
	//
	int    SLAPI SetRecFlag2(PPID billID, long flag2, int set, int use_ta);
	int    SLAPI Edit(PPID * pID, PPBill * pPack, int use_ta);
	//
	// Descr: Изменяет сумму текущей оплаты по документу (PPAMT_PAYMENT) и, если
	//   документ после этого стал полностью оплаченным, выставляет
	//   флаг BILLF_PAYOUT в поле BillTbl::Rec.Flags.
	//   Новая сумма текущей оплаты становится равной payment + newAmt - orgAmt,
	//   где
	//     payment - сумма текущей оплаты до вызова функции (используется вызов
	//               GetAmount(billID, PPAMT_PAYMENT, curID, &payment)
	//     newAmt  - новое значение суммы частичной оплаты
	//     orgAmt  - предыдущее значение суммы частичной оплаты
	//     Если функция вызывается по факту добавления новой частичной оплаты, то
	//     orgAmt = 0.
	// @attention: Функция работает без транзакции
	//
	int    SLAPI UpdatePaymAmount(PPID billID, PPID curID, double newAmt, double orgAmt);
	int    SLAPI Remove(PPID, int use_ta);
	//
	// Descr: разрывает связь от документа linkBillID к документу baseBillID.
	// ARG(linkKind IN): 1 - link, 2 - pool
	//
	int    SLAPI BreakOffLink(PPID linkBillID, PPID baseBillID, int linkKind, int use_ta);
	int    SLAPI EnumLinks(PPID billID, DateIter *, uint blnk /* BLNK_XXX flags */, BillTbl::Rec * = 0);
	int    SLAPI EnumByObj(PPID arID, DateIter *, void * = 0);
	int    SLAPI EnumByOpr(PPID opID, DateIter *, void * = 0);
	int    SLAPI EnumByDate(DateIter *, BillTbl::Rec * pRec = 0);

	SEnumImp * SLAPI EnumByOp(PPID opID, DateRange * pPeriod, int options);
	//
	// Descr: Находит список документов заказа, по которым отгружен документ billID.
	// Returns:
	//   >0 - существует по крайней мере один документ заказа, к которому привязана отгрузка billID
	//   <0 - не существует ни одного документа заказа, к которому был бы привязан документ billID
	//    0 - ошибка
	//
	int    SLAPI GetListOfOrdersByLading(PPID billID, PPIDArray * pOrderBillList);
	int    SLAPI GetTrnovrBySCard(PPID cardID, const DateRange * pPeriod, PPID restrGoodsGrpID, double * pDbt, double * pCrd);
	int    SLAPI CreateSCardsTurnoverList(const DateRange *, RAssocArray *);
	int    SLAPI CalcPayment(PPID billID, int byLinks, const DateRange *, PPID curID, double * pPaymentAmount);
	int    SLAPI CalcPaymentSieve(PPID id, PPID curID, const PPCycleArray * pSieve, RAssocArray * pList, double * pPaym);
	int    SLAPI GetCreditList(PPID id, PctChargeArray * pList);
	int    SLAPI SearchAnalog(const BillTbl::Rec * pSample, PPID * pID, BillTbl::Rec * pRec);

	int    SLAPI GetRentCondition(PPID, PPRentCondition *);
	int    SLAPI SetFreight(PPID id, PPFreight * pFreight, int use_ta);
	int    SLAPI GetFreight(PPID, PPFreight * pFreight);
	int    SLAPI GetDlvrAddrList(LAssocArray * pList);
	int    SLAPI GetListByFreightFilt(const FreightFilt & rFilt, UintHashTable & rList);
	//
	// Descr: Возвращает дату первого документа в базе данных.
	//   Если opID != 0, то ищет первый документ, относящийся //
	//   к указанному виду операции.
	//
	int    SLAPI GetFirstDate(PPID opID, LDATE *);
	//
	// Descr: Возвращает дату последнего документа в базе данных.
	//   Если opID != 0, то ищет последний документ, относящийся //
	//   к указанному виду операции.
	//
	int    SLAPI GetLastDate(PPID opID, LDATE *);
	//
	// mode > 0   то установить метку;
	// mode == 0  снять метку
	// mode < 0   переключить метку
	//
	int    SLAPI SetWLabel(PPID billID, int mode, int use_ta);
	int    SLAPI HasWLabel(PPID);
	//
	// mode > 0   - установить флаг BILLF_SHIPPED
	// mode == 0  - снять флаг BILLF_SHIPPED
	// mode < 0   - переключить флаг BILLF_SHIPPED
	//
	int    SLAPI SetShippedTag(PPID billID, int mode);
	int    SLAPI _GetBillNo(LDATE, long * billno);
	int    SLAPI EnumMembersOfPool(PPID poolType, PPID poolOwnerID, PPID * pMemberID, ObjAssocTbl::Rec * = 0);
	int    SLAPI GetPoolMembersList(PPID poolType, PPID poolOwnerID, PPIDArray * pList);
	//
	// Descr: Извлекает список идентификаторов владельцев пулов типа poolType, которым
	//   принадлежит документ billID.
	// ARG(billID   IN): идентификатор докумумента-члена пула
	// ARG(poolType IN): тип пулов документов, принадлежность которым документа billID выясняется //
	// ARG(pList   OUT): @#{vptr0} Указатель на массив, в который вносятся идентификаторы владельцев
	//   пулов, которым принадлежит billID.
	// Returns:
	//   >0 - документ billID принадлежит по крайней одному пулу типа poolType
	//   <0 - документ billID не принадлежит ни одному пулу типа poolType
	//
	int    SLAPI GetPoolOwnerList(PPID billID, PPID poolType, PPIDArray * pList);
	int    SLAPI GetPoolList(PPID poolType, LAssocArray * pAry);
	int    SLAPI IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID);
	int    SLAPI UpdatePool(PPID billID, PPID poolType, PPID poolOwnerID, int use_ta);
	int    SLAPI RemoveFromPool(PPID billID, PPID poolType, PPID poolOwnerID, int use_ta);
	int    SLAPI CalcPoolAmounts(PPID poolType, PPID poolOwnerID, AmtList *);
	//
	// Descr: Возвращает список идентификаторов документов, чьи расширения соответствую критериям фильтрации
	//   по агенту (agentID) и плательщику (payerID). Если значение какого-либо из критериев нулевое,
	//   то этот критерий игнорируется.
	// Note: Функция предварительно очищает список rList а после заполнения сортирует его и удаляет дубликаты.
	// Returns:
	//   >0 - в список добавлен по крайней мере один идентификатор
	//   <0 - не найдено ни одного документа, удовлетворяющего критериям
	//   0  - ошибка
	//
	int    SLAPI GetBillListByExt(PPID agentID, PPID payerID, PPIDArray & rList);
	int    SLAPI GetAdvanceBillList(PPID objID, PPID exclBillID, DateRange *, double * pAdvRest, PPIDArray *);
	//
	// Descr: Находит список локаций ассоциированных с документами, относящимися к виду операции opID.
	// ARG(opID IN): Идентификатор вида операции. Обобщенные операции не разворачиваются.
	//   Нулевое значение не обрабатывается - результат будет пустым.
	// ARG(rList OUT): Массив, в который заносятся идентификаторы всех найденных локаций. Функция
	//   предварительно очищает список вызовом LongArray::clear()
	// Note: При значительном количестве документов функция может выполняться длительное время.
	//
	int    SLAPI GetLocListByOp(PPID opID, PPIDArray & rList);
	//
	// Descr: пытается обнаружить дни, в течении которых не проведено
	//   ни одного документа операции opID по складу locID. Обнаруживая такие дни,
	//   функция заносит их в контейнер PPHolidays, используя виртуальный метод
	//   PPHolidays::SetHoliday().
	//   Перебирая дни, фукция сверяется с виртуальным методом PPHolidays::IsHoliday.
	//   Если этот метод возвращает положительное значение, то не рассматривает такой
	//   день. Период, который перебирается функцией, определяется параметром pPeriod.
	//   Если нижняя граница периода не определена, то используется дата, выясняемая //
	//   вызовом метода BillCore::GetFirstDate. Если верхняя граница периода не
	//   определена, то используется дата, выясняемая вызовом метода BillCore::GetLastDate.
	//
	//   Если locID == 0, то функция вызывает себя рекурсивно для каждого склада, полученного //
	//   вызовом функции PPObjLocation::GetWarehouseList().
	//
	int    SLAPI ScanHolidays(PPID locID, PPID opID, const DateRange * pPeriod, PPHolidays * pHld);

	struct Extra_Strg {      // sizeof(Extra_Strg) == PROPRECFIXSIZE
		PPID   ObjType;            // const=PPOBJ_BILL
		PPID   ObjID;              // -> Bill.ID
		PPID   PropID;             // const=BILLPRP_EXTRA
		PPID   ExtPriceQuotKindID; //
		char   InvoiceCode[24];    //
		LDATE  InvoiceDate;        //
		char   PaymBillCode[24];   // Номер платежного документа (для печати в счете-фактуре)
		LDATE  PaymBillDate;       // Дата  платежного документа (для печати в счете-фактуре)
		uint8  CvtTag;             // 1 - признак конвертации v6.4.6
		char   Reserve[3];         // @reserve
		PPID   AgentID;            // Агент      -> Article.ID
		PPID   PayerID;            // Плательщик -> Article.ID
	};
private:
	//
	// Descr: предназначена для перечисления записей по индексам вида { id, date, billno }.
	//
	int    SLAPI _Enum(int key, PPID, DateIter *, void * b);
	int    SLAPI _PrepareWriting(const BillTbl::Rec * pRec);
	int    SLAPI PutBillProp(PPID billID, PPID propID, long isThere, void *, size_t);
	//
	// Descr: извлекает из БД запись дополнительных полей авансового отчета.
	//
	int    SLAPI GetAdvanceRep(PPID id, PPAdvanceRep ** ppData);
		// @<<BillCore::Extract, ILBillPacket::Load
	//
	// Функция IsThereBill выясняет существует ли по складу locID за день dt
	// хотя бы один документ относящийся к одной из операций в списке pOpList.
	// Если pOpList == 0 или pOpList->getCount() == 0, тогда функция пытаетс
	// обнаружить документ по любой операции.
	// Returns:
	// 	> 0 - найден по крайней мере один документ, удовлетворяющий условию
	//  < 0 - не найдено ни одного документа
	//    0 - ошибка
	//
	int    SLAPI IsThereBill(PPID locID, const PPIDArray * pOpList, LDATE dt);
	int    SLAPI Helper_CalcPayment(PPID id, PPID curID, const PPCycleArray * pSieve, RAssocArray * pList, double * pPaym);
	int    SLAPI InitEnumByOp(PPID opID, DateRange * pPeriod, int flags, long * pHandle);
	int    SLAPI NextEnum(long enumHandle, BillTbl::Rec * pRec);
	int    SLAPI DestroyIter(long enumHandle);

	BillAmountTbl  AmtT;
	PayPlanTbl     Pays;
	PPTblEnumList  EnumList;
};
//
// История документов
//
#define HISTBILL_MAXVER 100000L

class PPHistBillPacket {
public:
	SLAPI  PPHistBillPacket();
	SLAPI ~PPHistBillPacket();
	void   SLAPI destroy();
	PPHistBillPacket & FASTCALL operator = (const PPHistBillPacket & aPack);

	int    SLAPI Init(PPBillPacket * pPack);
	int    SLAPI ConvertToBillPack(PPBillPacket * pPack);

	uint   SLAPI GetCount() const;
	HistTrfrTbl::Rec & FASTCALL Item(uint);
	int    SLAPI EnumItems(uint *, HistTrfrTbl::Rec **) const;
	int    SLAPI InsertRow(HistTrfrTbl::Rec *);
	int    SLAPI RemoveRow(uint);
	int    SLAPI RemoveRows(IntArray * pPositions);

	HistBillTbl::Rec Head;
private:
	TSArray <HistTrfrTbl::Rec> Items;
};

class HistBillCore : public HistBillTbl {
public:
	SLAPI  HistBillCore();
	int    SLAPI Search(PPID id, HistBillTbl::Rec * pRec);
	int    SLAPI SearchOpenBill(PPID billID, HistBillTbl::Rec * pRec);
	int    SLAPI PutPacket(PPID * pID, PPHistBillPacket * pPack, int close, int use_ta);
	int    SLAPI GetPacket(PPID id, PPHistBillPacket * pPack);
	static int SLAPI HBRecToBRec(HistBillTbl::Rec * pHBRec, BillTbl::Rec * pBRec);
	int    SLAPI DoMaintain(LDATE toDt, int recover, PPLogger * pLogger);
		// @>>DoDBMaintain
	int    SLAPI Remove(PPID id, int useTa);
private:
	int    SLAPI GetIdx(PPID billID, PPID * pVer, PPID * pInnerID);
	int    SLAPI LoadItems(PPID histBillID, PPHistBillPacket *);

	HistTrfrTbl ItemsTbl;
};
//
// Значения, передаваемые в качестве опций, а также возвращаемые функцией
// ReceiptCore::GetCurrentGoodsPrice
//
#define GPRET_NOLOTS      -0x0100 // В системе нет ни одного лота с заданным товаром
#define GPRET_ERROR        0 // Ошибка
#define GPRET_OTHERLOC     0x0004 // На заданном складе лотов нет, но есть на других складах
#define GPRET_CLOSEDLOTS   0x0002 // На заданном складе есть только закрытые лоты
#define GPRET_PRESENT      0x0001 // На заданном складе имеется ненулевой остаток товара
#define GPRET_MOSTRECENT   0x0100 // Возвращать самый последний лот до текущей
	// операционной даты (включительно) независимо от того, есть на нем остаток или нет
#define GPRET_FORCELOTID   0x0200 // По указателю pRec в функцию передана структура в поле
	// ID которой установлен идентификатор лота, который следует использовать в первую очередь.
	// Функция ReceiptCore::GetCurrentGoodsPrice проверяет этот лот на принадлежность товару
	// и складу, переданными соответствующими аргументами фукнции и, если они удовлетворительны
	// то применяет именно этот лот.
#define GPRET_INDEF        (GPRET_MOSTRECENT|GPRET_PRESENT|GPRET_CLOSEDLOTS) // Наиболее
	// популярное сочетание флагов, используемое для нахождения последнего лота
//
// Флаги ReceiptTbl::Rec::Flags
//
#define LOTF_COSTWOVAT     0x0001L // Цена поступления задана без НДС
#define LOTF_COSTWSTAX     0x0002L // Цена поступления задана с налогом с продаж
#define LOTF_PCKG          0x0004L // Лот пакета
#define LOTF_PRICEWOTAXES  0x0008L // Цена реализации без всех налогов
#define LOTF_CLOSEDORDER   0x0010L // Закрытый ордер
		// if Receipt.Closed == 0 and Receipt.Flags & LOTF_CLOSEDORDER then
		// Receipt.Rest > 0 is valid
#define LOTF_ORDRESERVE    0x0020L // Резервирующий заказ
#define LOTF_COMPLETE      0x0040L // Скоплектованный лот
#define LOTF_CLOSED        0x0080L // @transient Закрытый лот (применяется в кэше для замены признака ReceiptTbl::Rec::Closed)
#define LOTF_SURROGATE     0x0100L // @v9.6.7 @constraction Суррогатный лот, созданный без привязки к документу для отображения
	// текущих остатков и прочих атрибутов товаров. В частности, для автономного кассового узла.
//
// Специальные флаги временной таблицы TempLotTbl::SFlags
//
#define LOTSF_FIRST        0x0001 // Лот является первым по этому товару на этом складе
#define LOTSF_COSTUP       0x0002 // Цена поступления лота выше, чем у предыдущего
#define LOTSF_COSTDOWN     0x0004 // Цена поступления лота ниже, чем у предыдущего
#define LOTSF_PRICEUP      0x0008 // Цена реализации лота выше, чем у предыдущего
#define LOTSF_PRICEDOWN    0x0010 // Цена реализации лота ниже, чем у предыдущего
#define LOTSF_LINKCOSTUP   0x0020 // Цена поступления выше, чем цена в документе заказа, на основании которого вводится данный док
#define LOTSF_LINKCOSTDN   0x0040 // Цена поступления ниже, чем цена в документе заказа, на основании которого вводится данный док
#define LOTSF_RESTRBOUNDS  0x0080 // Цена выходит за границы диапазона, определяемого ограничениями товарных величин

typedef TSArray <ReceiptTbl::Rec> LotArray;

class ReceiptCore : public ReceiptTbl {
public:
	struct LotDimensions {
		static int SLAPI EditTag(const PPGdsClsPacket * pGcPack, ObjTagItem * pItem);
		SLAPI  LotDimensions();
		void   SLAPI Clear();
		SString & FASTCALL ToString(SString & rBuf) const;
		int    FASTCALL FromString(const char * pBuf);

		double X;
		double Y;
		double Z;
		uint8  Reserve[64];
	};

	static SString & SLAPI MakeCodeString(const ReceiptTbl::Rec * pRec, int options, SString & rBuf);

	SLAPI  ReceiptCore();
	int    SLAPI Search(PPID id, ReceiptTbl::Rec * pRec = 0);
	//
	// Descr: ищет по связанным лотам, начиная с *pLot цикл,
	//   замкнутый на локацию locID.
	// Returns:
	//   > 0 - найдено (*pLot равен ид-ру замыкающего лота)
	//   < 0 - не найдено (*pLot = 0)
	//   0   - ошибка (*pLot не определен).
	//
	int    SLAPI SearchLoop(PPID * pLotID, PPID locID);
	//
	// Descr: ищет самый первый лот по цепочке lotID - PrevLot.
	//   По указателю pOrgRec возвращается запись найденного оригинального лота.
	//   По указателю pThisRec возвращается запись лота и ИД lotID.
	//   Оба указателя могут быть нулевыми.
	// Returns:
	//   > 0 - идентифицирован первый лот в цепочке. По указателю pOrgLotID
	//       присваивается ИД найденного лота (возможно *pOrgLotID == lotID),
	//       по указателю pRec присваивается запись, соответствующая этому лоту.
	//   0 - ошибка. Это либо цепочка разорвана (нет записи, соответствующей одному
	//       из идентификаторов в цепи), либо цепочка лотов зациклена
	//       (PPErrCode = PPERR_LOTLOOP), либо ошибка выборки записи
	//       (PPErrCode = PPERR_DBENGINE).
	//
	int    SLAPI SearchOrigin(PPID lotID, PPID * pOrgLotID, ReceiptTbl::Rec * pThisRec, ReceiptTbl::Rec * pOrgRec);
		// @<<ReceiptCore::GetOriginDate
		// @<<Transfer::EnumItems,Transfer::LoadItems,Transfer::EnumAssetOp,Transfer::IsCompletedLot
		// @<<PPObjBill::MakeAssetCard,PPObjBill::GetComplete
		// @<<PPViewGoodsOpAnalyze::PutBillToTempTable
		// @<<PPViewTrfrAnlz::Add
	//
	// Descr: по записи pLotRec извлекает лот, по которому изначально в
	//   систему поступил товар, и возвращает дату и ИД документа оригинального лота.
	//   Для определения оригинального лота используется функция ReceiptCore::SearchOrigin.
	//   Если поле pLotRec->PrevLotID == 0, то возвращает информацию из этой записи.
	//
	int    SLAPI GetOriginDate(const ReceiptTbl::Rec * pLotRec, LDATE * pDate, PPID * pBillID = 0);
	int    SLAPI GetList(PPID goodsID, PPID locID, PPID supplID, LDATE beforeDt,
		int openedOnly, int nzRestOnly, SArray * pRecList);
	int    SLAPI EnumLots(PPID goodsID, PPID locID, DateIter *, void * = 0);
	int    SLAPI EnumLastLots(PPID goodsID, PPID locID, LDATE *, long * oprno, ReceiptTbl::Rec * pRec = 0);
	int    SLAPI GetLastLot(PPID goodsID, PPID locID, LDATE date, ReceiptTbl::Rec * pLotRec);
		// @>>ReceiptCore::EnumLastLots(goodsID, locID, &date, &(o = MAXDATE), pLotRec)
	int    SLAPI GetLastOpenedLot(PPID goodsID, PPID locID, LDATE, void * = 0);
		// @<<ReceiptCore::GetCurrentGoodsPrice
	int    SLAPI GetFirstLot(PPID goodsID, PPID locID, ReceiptTbl::Rec * pLotRec);
	//
	// Descr: Возвращает лот, предшествующий паре {dt, oprNo} и относящийся к товару goodsID
	//   и складу locID. Если locID <= 0, то принадлежность к складу не учитывается.
	//
	int    SLAPI GetPreviousLot(PPID goodsID, PPID locID, LDATE dt, long oprNo, ReceiptTbl::Rec * pRec);
	int    SLAPI EnumByGoods(PPID goodsID, DateIter *, ReceiptTbl::Rec *);
	//
	// Descr: возвращает зарезервированное количество товара goodsID.
	//   Если locID != 0, тогда возвращается резерв на складе с таким идентификатором,
	//   иначе, по всем складам.
	//   Величина резерва определяется как сумма текущих остатков по лотам заказов
	//   (GoodsID < 0), имеющим признак (Flags & LOTF_ORDRESERVE).
	//   Признак резервирующего заказа устанавливается на лот при его создании,
	//   если документ, создавший его относится к виду операции, имеющей признак OPKF_ORDRESERVE.
	// Returns:
	//   > 0 - OK
	//   < 0 - нет резервирующих заказов на товар (*pValue = 0)
	//   0   - Error (*pValue unpredictable)
	//
	int    SLAPI GetReserve(PPID goodsID, PPID locID, double * pValue);
	int    SLAPI Add(PPID * pID, ReceiptTbl::Rec * pRec, int use_ta);
	int    SLAPI Update(PPID id, ReceiptTbl::Rec * pRec, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI EnumRefs(PPID prev, LDATE *, long * oprno, void * = 0);
	int    SLAPI GetListOfOpenedLots(int dir, PPID goodsID, PPID locID, LDATE beforeDt, LotArray * pList);
	//
	// ARG(rGoodsList IN): список идентификаторов товаров, для которых необходимо найти открытые лоты.
	//   !Список обязательно должен быть отсортирован.
	//
	int    SLAPI GetListOfOpenedLots(const PPIDArray & rGoodsList, PPID locID, LotArray * pList);
	//
	// Descr: собирает все лоты, порожденные от parent и удовлетворяющие функции test
	//   в массив ary. Если test == 0, то полагается (test() != 0)
	//   Лот parent в массив не попадет ни при каких условиях.
	//   Массив ary не упорядочивается по каким-либо критериям.
	//   Случай ary == 0 обрабатывается нормально (функция отрабатывает
	//   все лоты, удовлетворяющие test, но их идентификаторы не сохраняет).
	//   Параметр extra передается функции test.
	//
	int    SLAPI GatherChilds(PPID parent, PPIDArray * ary, int (*test)(ReceiptTbl::Rec *, void *), void * extraPtr);
	//
	// Descr: возвращает текущую цену товара goodsID
	//   по складу locID. Если остаток товара по складу больше нуля, то
	//   возвращается GPRET_PRESENT, если нулевой остаток, но есть закрытые лоты,
	//   то возвращается GPRET_CLOSEDLOTS и устанавливается цена последнего лота.
	//   Если на складе нет ни одного лота по заданному товару, то возвращается //
	//   GPRET_OTHERLOC и цена последнего лота по любому из складов.
	//   Если в базе данных вообще нет лотов такого товара, то возвращается     //
	//   GPRET_NOLOTS и цена 0.
	//   В случае ошибки возвращается GPRET_ERROR (0).
	//
	//   Параметр flags позволяет указать, какие возвращаемые значения являются //
	//   допустимыми. Это может быть комбинация флагов GPRET_PRESENT,
	//   GPRET_OTHERLOC, GPRET_CLOSEDLOTS. Указав комбинацию первого и (или)
	//   второго флага, можно добиться некоторого ускорения работы функции.
	//
	//   Если в параметре flags установлен флаг GPRET_MOSTRECENT, то в первую очередь
	//   функция ищет самый последний лот по заданному складу независимо от, того, есть
	//   на нем остаток или нет.
	//
	//   Некоторые подробности использования флагов см выше в декларации самих флагов GPRET_XXX
	//
	int    SLAPI GetCurrentGoodsPrice(PPID goodsID, PPID locID, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	//
	// Descr: То же, что и GetCurrentGoodsPrice только ищет лоты, которые пришли не позднее чем date.
	//
	int    SLAPI GetGoodsPrice(PPID goodsID, PPID locID, LDATE date, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	int    SLAPI GetLastQCert(PPID goodsID, PPID * pQCertID);
	int    SLAPI IsThereOpenedLotForQCert(PPID qcertID);
	//
	// Descr:
	//   Возвращает список поставщиков данного товара. В списке не встречаются повторящиеся ID поставщиков.
	//   Извлекается список лотов до даты lastDate за период не более 90 дней до последнего прихода или не
	//   менее 3 лотов.
	//
	int    SLAPI GetSupplList(PPID goodsID, const PPIDArray * pLocList, LDATE lastDate, PPIDArray * pSupplList);
protected:
	int    SLAPI _SearchLot(int closed, PPID goods, PPID loc, LDATE, long oprno, int spMode);
private:
	int    SLAPI Helper_GetLastLot(PPID goodsID, PPID locID, LDATE dt, ReceiptTbl::Rec * pRec);
	int    IgnoreGpretMostRecentFlags; // В функции GetCurrentGoodsPrice игнорировать флаг
		// GPRET_MOSTRECENT. Проекция флага (PPGoodsConfig::Flags | GCF_RETAILPRICEBYMOSTRECENTLOT)
		// Изначально инициализируется в -1 (что означает неопределенность и необходимость извлечь
		// конфигурацию товаров).
	int    SLAPI Helper_GetCurrentGoodsPrice(
		PPID goodsID, PPID locID, LDATE date, uint flags, double * pPrice, ReceiptTbl::Rec * pRec);
	int    SLAPI Helper_GetList(PPID goodsID, PPID locID, PPID supplID, LDATE beforeDt,
		int closedTag, int nzRestOnly, SArray * pRecList);
};

int SLAPI GetCurGoodsPrice(PPID goodsID, PPID locID, uint flags, double * pPrice, ReceiptTbl::Rec * = 0);
	// @<<BillObj->trfr->Rcpt.GetCurrentGoodsPrice
//
//
//
struct GoodsRestVal {
	SLAPI  GoodsRestVal(const ReceiptTbl::Rec * = 0, double = 0.0);
	void   SLAPI Init(const ReceiptTbl::Rec * = 0, double = 0.0);

	int    Count;
	double UnitsPerPack;
	double Rest;
	double Cost;
	double Price;
	PPID   LocID;
	PPID   LotID; // @v8.1.1
	double Deficit;
	double DraftRcpt;
	char   Serial[24];
	char   LotTagText[128];
};

class GoodsRestParam : public TSArray <GoodsRestVal> {
public:
	SLAPI  GoodsRestParam();
	GoodsRestParam & FASTCALL operator = (const GoodsRestParam &);
	void   SLAPI Init();
	void   SLAPI InitVal();
	void   SLAPI Set(const GoodsRestFilt & rF);
	PPID   SLAPI DiffByTag() const
	{
		return (DiffParam == _diffLotTag && DiffLotTagID) ? DiffLotTagID : 0;
	}
	int    FASTCALL CanMerge(const GoodsRestVal *, const GoodsRestVal *) const;
	int    SLAPI AddToItem(int p, LDATE dt, long opn, GoodsRestVal *);
	int    SLAPI AddLot(Transfer *, const ReceiptTbl::Rec *, double rest, LDATE orgLotDate);
	void   SLAPI DivRestPrices();
	int    SLAPI CheckBill(const ReceiptTbl::Rec *, LDATE * pOrgDate) const;
	double FASTCALL GetRestByLoc(PPID locID) const;
	enum { // calcMethod (Метод расчета цен)
		pcmAvg        = 0, // По среднему
		pcmFirstLot   = 1, // По первому лоту
		pcmLastLot    = 2, // По последнему лоту
		pcmSum        = 3, // Суммарное значение
		pcmDiff       = 4, // Возвращать все лоты с ненулевым остатком
		pcmMostRecent = 5  // По самому последнему лоту (не смотря на остаток)
	};
	enum { // flags (Опции)
		fLabelOnly    = 0x00000040, // Только лоты, созданные помеченными документами
		fPriceByQuot  = 0x00000080, // Цены по котировке
		fCostByQuot   = 0x00000100, // @v9.5.8 Цены поступления по котировке
		fCWoVat		  = 0x00004000, // Цены поступления без НДС
		fZeroAgent    = 0x00010000  // @v7.5.11 Только с нулевым агентом поставщика
	};
	enum {
		_diffNone   = 0,
		_diffCost   = 0x0001,
		_diffPrice  = 0x0002,
		_diffPack   = 0x0004,
		_diffSerial = 0x0008,
		_diffLoc    = 0x0010,
		_diffLotTag = 0x0020,
		_diffLotID  = 0x0040
	};
	uint   CalcMethod;
	uint   Flags_;
	uint32 DiffParam;      // @v8.1.0 Флаги дифференциации записей (GoodsRestParam::_diffXXX)
	LDATE  Date;
	long   OprNo;          // @v7.6.2 Если Dt != 0 и OprNo > 0, то остаток по лотам брать до {Date, OprNo}
	PPID   LocID;
	PPID   GoodsID;
	PPID   SupplID;
	PPID   AgentID;        // Агент, связанный с документом прихода товара (агент поставщика)
	PPID   QuotKindID;     //
	PPID   DiffLotTagID;   // @v7.2.8 Тип тега лотов, по значениям которого следует дифференцировать отчет
	PPIDArray LocList;
	GoodsRestVal Total;
	//
	// Указатель на массив идентификаторов (id) документов, имеющих атрибут PPBillExt(id)::AgentID == this->AgentID.
	// Структура GoodsRestParam не является владельцем объекта, на который ссылается этот указатель.
	// Конструктор GoodsRestParam::GoodsRestParam инициализирует этот указатель в NULL, а деструктор
	// не разрушает его. Вызывающая процедура обязана сама заботиться об указателе P_SupplAgentBillList.
	// Функция Transfer::GetRest и вызываемые ею используют указываемый список для быстрого определени
	// принадлежности лота агенту поставщика AgentID. Если AgentID != 0 && P_SupplAgentBillList == 0,
	// то эти функции отработают правильно, но медленнее. Функции, использующие список, на который
	// ссылается P_SupplAgentBillList не полагаются на то, что он отсортирован.
	//
	const  PPIDArray * P_SupplAgentBillList;
private:
	LDATE  Md_;
	long   Mo_;
	PPID   GoodsTaxGrpID;
};
//
//
//
struct UhttGoodsRestVal {
	PPID   GoodsID;
	PPID   LocID;
	double Rest;
	LDATE  RestBillDt;
};
//
//
//
struct PPLotFault {
	enum {
		Ok = 0,
		// Первая операция по лоту (создание лота)
		NoOps,                // !?
		FirstBillID,          // !
		FirstDt,              // !
		FirstCost,            //
		FirstPrice,           //
		Quantity,             // !
		// Целостность ссылок
		RefGoods,             // Висячая ссылка на товара в лоте
		RefGoodsZero,         // Нулевой идентификатор товара в лоте
		RefQCert,             //
		RefPrevLot,           //
		RefSuppl,             //
		RefPrevEqID,          // !
		// Операции по лоту
		OpGoodsID,            // !?
		OpLocation,           // !?
		OpRest,               // !
		OpCost,               //
		OpPrice,              //
		OpFlagsCWoVat,        // Неверно установлено значение флага PPTFR_COSTWOVAT
		// Итоговые значения и признаки лота
		Rest,                 // !
		CloseTag,             // !
		CloseDate,            // !

		OrdReserveFlag,       // Неверно установлен либо не установлен флаг "Резервирующий заказ"
		CyclicLink,           // Циклическая ссылка в лотах
		LinkNotFound,         // Лот ссылается на несуществующий родительский лот

		WtRest,               // Неправильный текущий остаток по лоту в физ единицах
		OpWtRest,             // Неправильный остаток после операции в физ единицах

		NoPack,               // Отсутствует емкость упаковки
		PrevLotGoods,         // Товар в лоте не соответствует товару в лоте-предшественнике
		PrevLotLoc,           // Склад в лоте тот же, что и в лоте предшественнике
		PrevLotFlagsCWoVat,   // Не эквивалентная установка флага LOTF_COSTWOVAT с лотом-предшественником

		LcrInvRest,           // Неверный остаток в записи таблицы остатков по лотам
		LcrAbsence,           // Отсутствует запись в таблице остатков по лотам
		LcrWaste,             // Лишняя запись в таблице остатков по лотам
		LcrDb,                // Ошибка извлечения записи из таблицы остатков по лотам
		RevalOldCost,         // @v7.1.8 Неверная старая цена поступления в переоценке
		RevalOldPrice,        // @v7.1.8 Неверная старая цена поступления в переоценке
		NonUniqSerial,        // @v7.3.0 Неуникальный в пределах товара серийный номер лота
		OrdOpOnSimpleLot,     // @v7.5.3 Операия заказа привязана к обыкновенному лоту
		NegativeRest,         // @v8.0.9 Отрицательный текущий остаток по лоту
		InadqIndepPhFlagOn,   // @v8.3.9 В строке Transfer установлен флаг PPTFR_INDEPPHQTTY в то время как товара не имеет флага GF_USEINDEPWT
		InadqIndepPhFlagOff,  // @v8.3.9 В строке Transfer не установлен флаг PPTFR_INDEPPHQTTY в то время как товара имеет флаг GF_USEINDEPWT
		NonSingleRcptOp,      // @v8.5.7 К лоту привязано более одной строки, имеющей флаг PPTFR_RECEIPT
		PackDifferentGSE,     // @v8.8.1 Емкость упаковки лота отличается от ненулевой емкости упаковки поставки товара
		InadqLotWoTaxFlagOn,  // @v8.9.0 В лоте установлен флаг LOTF_PRICEWOTAXES в то время как товар не имеет флага GF_PRICEWOTAXES
		InadqTrfrWoTaxFlagOn, // @v8.9.0 В строке Transfer устанолен флаг PPTFR_PRICEWOTAXES в то время как товар не имеет флага GF_PRICEWOTAXES
		EgaisCodeAlone,       // @v9.3.1 Лот содержит тег кода продукции ЕГАИС, но ни один товар не имеет такого кода
		NoEgaisCode,          // @v9.7.8 Лот не содержит тега кода алкогольной продукции в то время как товар содержит такой код
		NoEgaisCodeAmbig      // @v9.7.8 Лот не содержит тега кода алкогольной продукции в то время как товар содержит более одного ЕГАИС-кода
	};
	int    Fault;
	LDATE  Dt;
	LDATE  EndDate;         // Для групповых ошибок Lcr (LcrAbsence, LcrWaste)
	long   OprNo;
	double ActualVal;
	double ValidVal;
	//
	// Пара лотов, идентифицирующая циклическую связь.
	// Как правило, рвать необходимо связку ChildLotID->ParentLotID
	//
	PPID   ChildLotID;
	PPID   ParentLotID;
};

// Класс для работы с ЭЦП
struct StTspResponse; // Описание в ppeds.cpp

class PPEds {
public:
	//
	// Descr: Подписывает документ. Подпись отсоединенная, то есть документ никак не меняетс
	//		и остается таким же доступным, как и до подписания.
	//	ARG(pSignerName		   IN): Имя подписанта
	//	ARG(pFileName		   IN): Имя документа, который надо подписать
	//	ARG(rSignFileName  IN/OUT): Если передана пустая строка, то создается файл с подписью
	//								"имя_документа.p7s". Если передано имя уже существующего
	//								файла с подписью/подписями, то оусуществляется операци
	//								добавления подписи
	// Returns:
	//		0 - ошибка
	//		1 - подпись создана
	//
	int    SignData(const char * pSignerName, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Заверяет указанную подпись в документе
	// ARG(pCountersignerName	IN): Имя заверителя подписи
	// ARG(signerNumber			IN): Номер подписи, котороую нужно заверить. Список подписей
	//								можно получить с помощью функции GetSignersInDoc(). Каждой
	//								подписи соотвествует номер, пока что начиная с единицы
	//								(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//								Этот номер и нужно указать
	// ARG(pFileName			IN): Имя подписанного документа
	// ARG(pSignFileName		IN): Имя файла с подписью
	// Returns:
	//		0 - ошибка
	//		1 - подпись заверена
	int CountersignData(const char * pCountersignerName, int signerNumber, const char * pFileName, const char * pSignFileName);
	// Descr: Удаляет подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signNumber		IN): Номер подписи в документе. Список подписей
	//						можно получить с помощью функции GetSignersInDoc(). Каждой
	//						подписи соотвествует номер, пока что начиная с единицы
	//						(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//						Этот номер и нужно указать
	// Returns:
	//		0 - ошибка
	//		1 - подпись успешно удалена
	int DeleteSign(const char * pSignFileName, int signNumber);
	// Descr: Удаляет заверяющую подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер заверенной подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соотвествует номер, пока что начиная с единицы
	//							зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - нет заверяющей подписи
	//		 0 - ошибка
	//		 1 - подпись удалена
	int DeleteCountersign(char * pSignFileName, int signerNumber);
	// Descr: Шифрует документ. При шифровании создается документ с именем "имя_документа_encoded".
	//		При этом можно оставить оба файла (исходный и получившийся зашифрованный),
	//		можно оставить только зашифрованный вариант, тогда он будет называться как исходный
	// ARG(pOwnerName		IN): Имя владельца сертификата, чьим закрытым ключом будет зашифровн документ
	// ARG(pFileName		IN): Имя документа
	// ARG(sameFile			IN): Указывает, перезаписать документ или сохранить закодированные данные
	//						в файл "имя_документа_encoded"
	//						0 - записать закодированные данные в отдельный файл
	//						1 - перезаписать документ
	// Returns:
	//		0 - ошибка
	//		1 - документ зашифрован
    int EncodeData(const char * pOwnerName, const char * pFileName, int sameFile = 1);
	int DecodeData(const char * pOwnerName, const char * pFileName/*, int sameFile = 1*/);

	// Descr: Получает из файла список подписей
	// ARG(pFileName	IN): Имя подписанного документа
	// ARG(rSignersArr OUT): Список имен владельцев подписей, содержащихся в документе.
	// Returns:
	//		-1 - документ не подписан
	//		 0 - ошибка
	//		 1 - список имен получен
	//int GetSignersInDoc(const char * pFileName, StrAssocArray & rSignersArr);


	// Descr: Проверяет подпись
	// ARG(pFileName		IN): Имя подписанного документа
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер подписи для проверки. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соотвествует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - подпись не верна
	//		 0 - ошибка
	//		 1 - подпись верна
	int    VerifySign(const char * pFileName, const char * pSignFileName, int signerNumber);
	//
	// Descr: Проверяет заверяющую подпись
	// ARG(pSignFileName	IN): Имя файла с подписью
	// ARG(signerNumber		IN): Номер заверенной подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соотвествует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// Returns:
	//		-1 - нет заверяющей подписи
	//		 0 - ошибка
	//		 1 - заверяющая подпись верна
	//
	int    VerifyCountersign(const char * pSignFileName, int signerNumber);
	//
	// Descr: Возвращает всех владельцев сертификатов подписей в хранилище сертификатов "My"
	//
	int    GetSignerNamesInStore(StrAssocArray & rStrArray);
	//
	// Descr: Возвращает список файлов с подписями, связанные с указанным документом.
	//		Вообще-то нет регламента, который указывал бы, как должны называться файлы,
	//		все зависит от конкретного оператора ЭДО, если речь об этом. Поэтому
	//		пока что зададим условие, что имя файла с подписью должно начинаться с "имя_документа" + "_"
	// ARG(pFileName	 IN): Имя документа, для которого надо найти файлы с подписями
	// ARG(rFilesLis	OUT): Массив имен файлов с подписями
	// Returns:
	//		 0 - ошибка
	//		 1 - хотя бы один файл найден
	//
	int    GetSignFilesForDoc(const char * pFileName, StrAssocArray & rFilesLis);
	//
	// Descr: Получает имя владельца пописи по ее порядковому номеру в файле подписи
	// ARG(pSignFileName	IN): Имя файла с подписями
	// ARG(signNumber		IN): Номер подписи. Список подписей
	//							можно получить с помощью функции GetSignersInDoc(). Каждой
	//							подписи соотвествует номер, пока что начиная с единицы
	//							(зависит от того, с какой позиции считает SmartListBox::getCurID()).
	//							Этот номер и нужно указать
	// ARG(rSignerName OUT): Имя владельца подписи
	// Returns:
	//		-1 - подписи с таким номером нет
	//		 0 - ошибка
	//		 1 - имя владельца подпсии получено
	int GetSignerNameByNumber(const char * pSignFileName, int signNumber, SString & rSignerName);
private:
	//
	// Descr: Возвращает число подписей в документе
	// ARG(pSignFileName	 IN): Имя файла с подписями
	// ARG(rCount			OUT): Число подписей в документе
	// Returns:
	//		  -1 - ошибка
	//		>= 0 - число подписей
	//
	int    GetSignsCount(const char * pSignFileName, int & rCount);
	//
	// Descr: Получает указатель на структуру типа HCRYPTPROV (информация о криптопровайдере)
	// ARG(cert			IN): Указатель на структуру CERT_CONTEXT с информацией о сертификате подписи
	// ARG(rCryptoProv OUT): Указатель на структуру с инфоомацией о криптопровайдере
	// ARG(rKeySpec	   OUT): Тип пары ключей подписи (AT_KEYEXCHANGE или AT_SIGNATURE)
	// Returns:
	//		0 - ошибка
	//		1 - криптопровайдер получен
	//
	int    GetCryptoProv(PCCERT_CONTEXT & cert, HCRYPTPROV & rCryptoProv, DWORD & rKeySpec);
	//
	// Будем работать с отсоединенной (detached) подписью
	// Descr: Ставит первую подпись в документе
	// ARG(pSgnerName			IN): Имя владельца пописи
	// ARG(pFileName			IN): Имя документа
	// ARG(pSignFileName	IN/OUT): Если передается пустая строка, создается файл "имя_документа.p7s",
	//								в который сохранится созднаная подпись. Если передается имя уже
	//								существующего файла с подписью, то он будет перезаписан.
	// Returns:
	//	   -1 - пользователь отменил действие
	//		0 - ошибка
	//		1 - подпись поставлена
	//
	int    FirstSignData(const char * pSignerName, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Добавляет подпись в документ
	// ARG(pCosignerName	IN): Имя владельца подписи
	// ARG(pFileName		IN): Имя документа
	// ARG(pSignFileName	IN): Имя файла с подписями
	// Returns:
	//	   -1 - пользователь отменил действие
	//		0 - ошибка
	//		1 - подпись успешно добавлена
	//
	int    CoSignData(const char * pCosignerName, const char * pFileName, const char * pSignFileName);
	//
	// Descr: Проверяет цепочку сертификатов, начиная с сертификата, указанного во входном параметре
	//
	int CheckCertChain(PCCERT_CONTEXT & cert);
	//
	// Descr: Возвращает указатели на хранилище сертификатов и на сертификат по имени его владельца
	// ARG(rCertStore	OUT): Указатель на хранилище сертификатов
	// ARG(rCert		OUT): Указатель на структуру CERT_CONTEXT, содержащую информацию о сертификате
	// ARG(pOwnerName	 IN): Имя владельца сертификата
	// Returns:
	//		0 - ошибка
	//		1 - сертификат найден
	//
	int GetCert(HCERTSTORE & rCertSore, PCCERT_CONTEXT & rCert, const char * pOwnerName);
	//
	// Descr: Возвращает сертификат владельца через диалог выбора контейнера ключей
	//
	int GetCert(PCCERT_CONTEXT & rCert);
	//
	// Descr: При подписании документа сохраняется не только подпись, но и некоторая инфа о сертификате
	//		владельца подписи. Если подписей несколько, то не факт, что порядковый номер подписи
	//		в файле совпадает с порядковым номером сертификата. Эта функция позволяет по имени
	//		владельца подписи найти номер соответствующего ей сертификата.
	// ARG(pSignFileName	IN): Имя файла с подписями
	// ARG(pSignerName	IN): Имя владельца подписи
	// ARG(rCert	   OUT): Номер сертификата
	// Returns:
	//		0 - ошибка
	//		1 - номер сертификата определен
	//
	int GetCertIndexBySignerName(const char * pSignerFileName, const char * pSignerName, int & rCertIndex);
	//
	// Descr: Включает кеширование провайдера ключей. Чтобы при подписании документа окно ввода
	//		пароля появилось только один раз
	// ARG(cert	IN): Сертификат, для которого устанавливается кеширование
	//
	int CashOn(PCCERT_CONTEXT & cert);
	int CashOff(PCCERT_CONTEXT & cert);
	//
	// Descr: Возвращает имя заверителя, который заверил подпись с указанным номером в указанном файле
	//		с подписями
	// ARG(pSignFileName		 IN): Имя файла с подписями
	// ARG(signerNumber			 IN): Порядковый номер заверенной подписи
	// ARG(rCounterSignerName	OUT): Имя заверител
	//
	int GetCountersignerNameBySignerNumber(const char * pSignFileName, int signerNumber, SString & rCounterSignerName);
	//
	// Descr: Преобразует имя подписываемого документа, изменяя его расширение на ".p7s".
	//		В итоге получается файл для хранения подписей для данного документа.
	// ARG(pDocName		  IN): Имя документа, который будет подписан или уже содержит подписи
	// ARG(rSignFileName OUT): Имя файла подписей
	//
	void GetSignFileName(const char * pFileName, SString & rSignFileName);
	//
	// Descr: Получает от сервера штампов времени штамп на указанную подпись и сохраняет его
	//			в атрибутах подписи
	// ARG(pSignFileName	 IN): Имя файла с подписями
	// ARG(signerNumber		 IN): Номер подписи в файле с подписями
	// ARG(rResponse		OUT): Структура, содержащая разобранный ответ от сервера штампов времени
	// Returns:
	//		0 - ошибка
	//		1 - штамп времени получен
	//
	int GetTimeStamp(const char * pSignFileName, int signerNumber, StTspResponse & rResponse);
	//
	// Descr: Возвращает хеш, расчитанный для указанной подписи. Функцию необходимо
	//		вызвать дважды. В первый раз параметр pHashedData должен быть равен NULL, тогда
	//		в rSizeHashedData вернется размер данных. После чего надо выделить память под
	//		pHashedData и вызвать функцию во второй раз. В итоге в pHashedData будут
	//		храниться данные о хеше.
	// ARG(pData				 IN): Данные, считанные из файла с подписями
	// ARG(dataSize				 IN): Размер данных из файла с подписями
	// ARG(signNumber		 	 IN): Номер подписи, для чей хеш надо получить
	// ARG(pHashedData			OUT): Данные о хеше
	// ARG(rSizeHashedData	 IN/OUT): Размер данных о хеше
	//
	int GetHash(void * pData, DWORD dataSize, int signNumber, BYTE * pHashedData, DWORD & rSizeHashedData);
	//
	// Descr: Кодирует объектные идентификаторы в der-кодировку. Используется в
	//		функции получения штампа времени.
	// ARG(objIdfr		 IN): Строка, содержащая объектный идентификатор
	// ARG(rEncodedStr	OUT): Объектный идентификатор в der-кодировке
	//
	int ObjIdfrDerEncode(const char * objIdfr, SString & rEncodedStr);
	//
	// Descr: Возвращает имя закодированного документа. Имя зависит от параметра sameFile.
	//		Используется при кодировании файла. Если параметр sameFile = 0, то закодированные
	//		данные сохраняться в отдельный файл. Если sameFile = 1, то закодированные данные
	//		сохранятся в файл "имя_документа_1", который потом будет переименован в "имя_документа",
	//		то есть исходный документ будет перезаписан.
	// ARG(pFileName		 IN): Исходное имя документа
	// ARG(rEncryptFileName	OUT): Имя закодированного документа
	// ARG(sameFile			 IN): Параметр, определяющий, каким будет имя документа.
	//							0 - "имя_документа_encoded"
	//							1 - "имя_документа_1"
	//
	void GetEncryptedFileName(const char * pFileName, SString & rEncryptFileName, int sameFile = 1);
	//
	// Descr: По заданному номеру выбранной позиции из списка диалога и имени документа возвращает
	//			имя файла подписи, которой принадлежит выбранная подпись
	// ARG(posInList		 IN): Номер выбранной позиции в списке диалога
	// ARG(pFileName		 IN): Имя документа, который надо подписать
	// ARG(rSignFileName	OUT): Имя файла подписи
	//
	int GetSignFileAndSignNames(int posInList, const char * pFileName, SString & rSignFileName);
	//
	// Descr: Разбирает ответ, полученный от сервера штапма времени
	// ARG(pResponse		 IN): Ответ (последовательность байт), полученный от сервера штампа времени
	// ARG(rResponseFmtd	OUT): Разобранный ответ
	// Returns:
	//		0 - ошибка разбора
	//		1 - ответ разобран
	//
	int ParseTSAResponse(const char * pResponse, StTspResponse & rResponseFmtd);
};

class PPLotFaultArray : public SArray {
public:
	SLAPI  PPLotFaultArray(PPID lotID, PPLogger & rLogger);
	int    SLAPI AddFault(int fault, const TransferTbl::Rec *, double act, double valid);
	int    SLAPI AddFault(int fault, const ReceiptTbl::Rec * pRec, PPID childID, PPID parentID);
	PPLotFault & FASTCALL at(uint p) const;
	int    SLAPI AddMessage();
	SString & SLAPI Message(uint p, SString &);
	int    SLAPI HasFault(int faultId, PPLotFault *, uint * pPos) const;
	int    SLAPI HasCostOpFault(LDATE, long, uint * p) const;
	int    SLAPI HasPriceOpFault(LDATE, long, uint * p) const;
	int    SLAPI HasLcrFault() const;
	int    SLAPI _HasOpFault(int fault, LDATE dt, long oprno, uint * p) const;
	PPID   LotID;
private:
	PPLogger * P_Logger; // @notowned
};
//
//
//
#define CPTFREXSTR_SERIAL 1
#define CPTFREXSTR_CLB    2

struct CpTrfrExt {
	char   PartNo[24];
	char   Clb[24];
};

class CpTransfCore : public CpTransfTbl {
public:
	SLAPI  CpTransfCore();

	static int FASTCALL PutExt(CpTransfTbl::Rec & rRec, const CpTrfrExt * pExt);
	static int FASTCALL GetExt(CpTransfTbl::Rec & rRec, CpTrfrExt * pExt);

	int    SLAPI PutItem(PPTransferItem * pTi, int16 forceRByBill, const CpTrfrExt * pExt, int use_ta);
	int    SLAPI RemoveItem(PPID billID, int rByBill, int use_ta);
	int    SLAPI EnumItems(PPID billID, int * pRByBill, PPTransferItem *, CpTrfrExt *);
	int    SLAPI LoadItems(PPID billID, PPBillPacket * pPack, const PPIDArray * pGoodsList);
	int    SLAPI Search(PPID billID, int rByBill, CpTransfTbl::Rec * pRec = 0);
	int    SLAPI SearchGoodsRef(PPID goodsID, CpTransfTbl::Rec * pRec = 0);
	int    SLAPI ReplaceGoods(PPID destGoodsID, PPID srcGoodsID, int use_ta);
};
//
// Флаги функции Transfer::RecoverLot
//
#define TLRF_REPAIR            0x0001 // Общий флаг, предписывающий запускать корректировку. Если этот флаг
	// не установлен, то никакая корректировка запускаться не будет.
#define TLRF_REPAIRPACK        0x0002 // Корректировать емкости упаковок
#define TLRF_REPAIRCOST        0x0004 // Исправлять цены поступления //
#define TLRF_REPAIRPRICE       0x0008 // Исправлять цены реализации  //
#define TLRF_RMVLOST           0x0010 // Удалять лоты, не имеющие ни одной операции
#define TLRF_CHECKUNIQSERIAL   0x0020 // @v7.3.0 Проверять серийные номера на уникальность в пределах товара
#define TLRF_ADJUNUQSERIAL     0x0040 // @v7.3.0 Исправлять неуникальные в пределах товара серийные номера
	// (доступно только если в конфигурации документов определен суффикс уникальности серий).
#define TLRF_INDEPHQTTY        0x0080 // @v8.3.9 Корректировать флаг PPTFR_INDEPPHQTTY в записях Transfer в соответствии
	// с флагом GF_USEINDEPWT установленным в товаре
#define TLRF_REPAIRPACKUNCOND  0x0100 // @v8.8.1 Безусловно корректировать емкости упаковок в лотав по значению, заданному в карточке товара
#define TLRF_REPAIRWOTAXFLAGS  0x0200 // @v8.9.0
#define TLRF_SETALCCODETOGOODS 0x0400 // @v9.3.1 Если лот содержит тег PPTAG_LOT_FSRARLOTGOODSCODE то добавлять такой код
	// в список кодов товара, если ни один из товаров не содержит такой код
#define TLRF_SETALCCODETOLOTS  0x0800 // @v9.7.8 Если товар содержит код алкогольной продукции, а лот - нет, то в тег лота
	// PPTAG_LOT_FSRARLOTGOODSCODE переносить этот код.
//
// Флаги функции Transfer::MoveLotOps
//
#define TMLOF_RMVSRCLOT        0x0001 // Удалить донора
#define TMLOF_RMVREVAL         0x0002 // Удалять переоценки по донору (подразумевается если TMLOF_RMVSRCLOT)
#define TMLOF_ADDLOTS          0x0004 // Прибавить количество донора к акцептору
#define TMLOF_AVGCOST          0x0010 // Усреднить цены поступления акцептора по ценам донора
	// (если !TMLOF_ADDLOTS то игнорируется)
#define TMLOF_AVGPRICE         0x0020 // Усреднить цены реализации акцептора по ценам донора
	// (если !TMLOF_ADDLOTS то игнорируется)
#define TMLOF_NORECALCDESTBILL 0x0040 // Не пересчитывать суммы и проводки документа акцептора
	// (если !TMLOF_ADDLOTS то игнорируется)

//
// Параметр и флаги функции Transfer::UpdateCascadeLot
//
struct TrUCL_Param {
	PPID   GoodsID;
	PPID   SupplID;
	PPID   LotTaxGrpID;
	double Cost;
	double Price;
	double LotCost;  // Out
	double LotPrice; // Out
};

#define TRUCLF_UPDGOODS  0x0001U
#define TRUCLF_UPDSUPPL  0x0002U
#define TRUCLF_UPDCOST   0x0004U
#define TRUCLF_UPDPRICE  0x0008U
#define TRUCLF_UPDTAXGRP 0x0010U
#define TRUCLF_UPDCP     (TRUCLF_UPDCOST | TRUCLF_UPDPRICE)
//
// Коды операций над основными средствами
//
#define ASSTOPC_UNDEF    0 // Неопределенная операция //
#define ASSTOPC_RCPT     1 // Приход с вводом в эксплуатацию
#define ASSTOPC_RCPTEXPL 2 // Приход без ввода в эксплуатацию
#define ASSTOPC_EXPL     3 // Ввод в эксплуатацию
#define ASSTOPC_EXPLOUT  4 // Вывод из эксплуатации
#define ASSTOPC_MOV      5 // Перемещение на другой склад
#define ASSTOPC_DEPREC   6 // Начисление амортизации
#define ASSTOPC_REVAL    7 // Переоценка
#define ASSTOPC_EXPEND   8 // Расход
//
// Параметр функции Transfer::GetGoodsIdList
//
struct GoodsByTransferFilt {
	SLAPI  GoodsByTransferFilt(const GoodsFilt * pGoodsFilt = 0);
	int    SLAPI IsEmpty() const;
	enum {
		fNoZeroRestOnLotPeriod = 0x0001,
		fIncludeIntr           = 0x0002,
		fNewLots               = 0x0004
	};
	PPID   SupplID;
	DateRange LotPeriod;
	long   Flags;
	ObjIdListFilt LocList;
};
//
//
//
struct UnlimOrderParam {
	PPID   GoodsID;       // ИД товара
	PPID   ArID;          // ИД контрагента
	DateRange OrdPeriod;  // Период заказов
	DateRange ShpPeriod;  // Период отгрузки
	long   Flags;
};

struct UnlimOrderEntry {
	PPID   GoodsID;       // ИД товара
	PPID   OrdBillID;     // ИД документа заказа
	PPID   ShpBillID;     // ИД документа отгрузки по заказу
	double OrdQtty;       // Заказанное количество
	double ShpQtty;       // Отгруженное количество
};
//
//
//
class Transfer : public TransferTbl {
public:
	SLAPI  Transfer();
	SLAPI ~Transfer();
	int    SLAPI SearchByBill(PPID billID, int reverse, short rByBill, TransferTbl::Rec * pRec);
	int    SLAPI SearchMirror(LDATE dt, long oprno, TransferTbl::Rec *);
	int    SLAPI SearchReval(PPID lotID, LDATE, long oprno = 0, TransferTbl::Rec * = 0);
	//
	// Descr: По указателю pOprNo присваивает номер операции для новой записи.
	//
	int    SLAPI GetOprNo(LDATE, long * pOprNo);
	//
	// Если EnumItems возвращает значение > 0 (найдена очередная запись),
	// то в таблице Rcpt запись установлена по ид-ру PPTransferItem::LotID
	//
	int    SLAPI EnumItems(PPID billID, int * rByBill, PPTransferItem *);
	int    SLAPI EnumByLot(PPID lotID, LDATE *, long *, TransferTbl::Rec * = 0);
	int    SLAPI EnumByLot(PPID lotID, DateIter *, TransferTbl::Rec * = 0);
	int    SLAPI GetLastOpByGoods(PPID goodsID, LDATE beforeDt, long beforeOprNo, TransferTbl::Rec * pRec);
	int    SLAPI EnumAssetOp(PPID lotID, DateIter * pIter, int * pOpCode /* ASSTOPC_XXX */, PPID * pDestLotID, TransferTbl::Rec * pRec);
	int    SLAPI EnumAssetOp(PPID * pLotID, DateIter * pIter, int * pOpCode, TransferTbl::Rec * pRec);
	int    SLAPI CalcUnlimOrder(const UnlimOrderParam *, TSArray <UnlimOrderEntry> *);
	//
	// Descr: Возвращает списко идентификаторов товаров, которые когда-либо были на складе locID.
	//
	int    SLAPI GetLocGoodsList(PPID locID, UintHashTable & rList);
	//
	// Descr: Возвращает значение >0, если по лоту lotID нет ни одной операции
	//   кроме операции, создавшей этот лот.
	//
	int    SLAPI IsDeadLot(PPID lotID);
	//
	// Descr: Определяет является ли лот lotID скоплектованным документом модификации.
	// Returns:
	//   >0 - оригинальный лот был скомплектован документом модификации
	//   <0 - ни сам лот, ни его предки не были скомплектованы
	//   0  - ошибка
	//
	int    SLAPI IsCompletedLot(PPID lotID);
	//
	// Descr: Загружает товарные строки документа из таблицы Transfer.
	// ARG(billID     IN): Идентификатор документа, для которого необходимо загрузить строки
	// ARG(pPack  IN/OUT): Пакет документа, в который загружаются строки (PPBillPacket::Lots)
	// Returns:
	//   1 - строки успешно загружены
	//   0 - ошибка
	//
	int    SLAPI LoadItems(PPBillPacket & rPack, const PPIDArray * pGoodsList); // @<<PPObjBill::ExtractPacket
	int    SLAPI SetupItemByLot(PPTransferItem *, ReceiptTbl::Rec * pLotRec, int checkLotPrices, long oprno);
	struct BillTotal {
		long   LineCount; // Количество строк в документе
	};
	//
	// Descr: Рассчитывает итоги по документу billID.
	//   Если pGoodsIdList != 0, то заносит в этот массив все встреченные в документе идентификаторы товаров.
	// Note: В массив pGoodsIdList идентификаторы товаров вносятся без контроля дублирования (ради ускорения).
	//   В связи с этим, после вызова функции (серии вызовов) следует применить метод LongArray::sortAndUndup() к pGoodsIdList.
	//
	int    SLAPI CalcBillTotal(PPID billID, BillTotal * pTotal, PPIDArray * pGoodsIdList);
	//
	// Descr: Возвращает список товаров, соответствующих фильтру pFilt.
	//
	int    SLAPI GetGoodsIdList(const GoodsByTransferFilt & rFilt, PPIDArray & rList);
	//
	// В следующих двух функциях если первый параметр предписывает давать
	// разбивку по лотам (GoodsRestParam::calcMethod == GoodsRestParam::pcmDiff),
	// и два последних параметра не равны нулю, параметру *count присваиваетс
	// количество лотов с ненулевыми остатками, а по адресу, заданному
	// последним параметром присваивается динамическая область памяти
	// со значениями для этих лотов. При этом структура, заданная первым
	// параметром получает значения такие как если бы calcMethod был бы
	// равен GoodsRestParam::pcmSum.
	//
	int    SLAPI GetRest(GoodsRestParam *);
	int    SLAPI GetCurRest(GoodsRestParam *);
	int    SLAPI GetLcrList(LDATE dt, UintHashTable * pLotList, RAssocArray * pRestList);
	int    SLAPI CalcAssetDeprec(PPID lotID, const DateRange *, double * pDeprec);
	//
	// Descr: Берет остаток по лоту на заданную дату сразу после (!) операции oprno.
	//   Т.е. если операция {dt, oprno} относится к лоту lot, то берется остаток по этой операции.
	//
	int    SLAPI GetRest(PPID lotID, LDATE, long oprno, double * pRest, double * pPhRest = 0);
	int    SLAPI GetRest(PPID lotID, LDATE, double * pRest, double * pPhRest = 0);
	//
	// Descr: Вычисляет предельно допустимые изменения количества товара по
	//   лоту lotID на заданнуе дату и номер операции, следующий за oprno.
	//   Если oprno < 0, то это все равно, что {dt+1, 0} (точнее {dt, MAXLONG}).
	//   Указатели down и up могут быть нулевыми. Если up == 0, то функция //
	//   отработает несколько быстрее.
	//
	int    SLAPI GetBounds(PPID lotID, LDATE, long oprno, double * down, double * up);
	//
	// Descr: Рассчитывает доступный остаток товара goodsID по складу locID.
	//   Рассматриваются только открытые лоты, попадающие в период rPeriod.
	//   Если аргумент ignoreEpsilon > 0, то игнорируются лоты, имеющие остаток меньший чем ignoreEpsilon.
	//
	int    SLAPI GetAvailableGoodsRest(PPID goodsID, PPID locID, const DateRange & rPeriod, double ignoreEpsilon, double * pRest);
	//
	// Descr: Получает оригинальные значения количества и цены для строки корректирующего документа rTi.
	// ARG(rTi IN): Строка корректирующего документа
	// ARG(rBillChain IN): Цепочка идентификаторов документов, начинающаяся от оригинального и включающая
	//   все документы коррекции, предшествующие rTi.BillID. Эта цепочка формируется функцией
	//   PPObjBill::GetCorrectionBackChain.
	// ARG(pOrgQtty OUT): Результирующая велична оригинального количества
	// ARG(pOrgPrice OUT): Результирующая велична оригинальной цены (включает скидку).
	// Returns:
	//   <0 - строка rTi не является строкой корректировки либо не найдено даже
	//     оригинального корректируемого документа
	//    1 - найдена строка, относящаяся к оригинальному корректируемому документу
	//    2 - найдена строка, относящаяся к оригинальному корректируемому документу, а также
	//      одна или более строк, принадлежащих другим документам коррекции.
	//
	int    SLAPI GetOriginalValuesForCorrection(const PPTransferItem & rTi, const PPIDArray & rBillChain, double * pOrgQtty, double * pOrgPrice);
	int    SLAPI AddLotItem(PPTransferItem * pTi, PPID forceID = 0);
	int    SLAPI AddItem(PPTransferItem * pTi, int16 & rByBill, int use_ta);
	enum {
		fUpdEnableUpdChildLot = 0x0001
	};
	int    SLAPI UpdateItem(PPTransferItem * pTI, int16 & rByBill, long flags, int use_ta);
	int    SLAPI RemoveItem(PPID billID, int rByBill, int force, int use_ta);
	int    SLAPI CorrectReverse();
	int    SLAPI CorrectIntrUnite();
	//
	// Функция CorrectByLot проверяет и исправляет следующие ошибки:
	// 1. Неверное начальное количество в записи лота
	// 2. Неверные остатки в записях операций по лоту
	// 3. Неправильно установленный флаг Closed в записи лота
	// 4. Ошибочную цену поступления в операции
	// 5. Ошибочную цену реализации в операции
	//
	// При обнаружении ошибки вызывается пользовательская функци
	// MsgProc с параметрами:
	// err - Номер ошибки (см. список выше)
	// lot - Ид. лота
	// rec - Запись из таблицы Transfer с ошибкой. Для ошибки 3 эта
	//       запись будет содержать бессмысленное значение.
	//
	// Если необходимо исправить ошибку, MsgProc должна вернуть
	// значение > 0. 0 означает пропуск ошибки. < 0 - прервать процесс.
	// MsgProc == 0 - означает безусловное исправление всех найденных ошибок.
	//
	// Функция CorrectByLot все исправления делает внутри транзакции.
	//
	int    SLAPI CorrectByLot(PPID, int (*MsgProc)(int err, PPID, const TransferTbl::Rec *));
	//
	// Descr: проверяет записи таблицы CurRest. Обнаруженные ошибки она записывает в файл с именем, заданным
	//   параметром pLogName. Параметр correct предписывает исправлять обнаруженные ошибки.
	//
	int    SLAPI CorrectCurRest(const char * pLogName, int correct);
	int    SLAPI CorrectCurRest(PPID goodsID, const PPIDArray * pLocList, PPLogger * pLogger, int correct);
	int    SLAPI CorrectLotTaxGrp();
	//
	// Descr: Если в функции GetLotPrices параметр oprno равен нулю, то ищется //
	//   переоценка, начиная со следующего за date дня, иначе ищется переоценка
	//   начиная с даты date и операции (oprno + 1)
	//
	int    SLAPI GetLotPrices(ReceiptTbl::Rec * pLotRec, LDATE, long oprno = 0);
	int    SLAPI UpdateForward(PPID lotID, LDATE dt, long oprno, int check, double * pAdd, double * pPhAdd);
	//int    SLAPI CheckForward(PPID lotID, DATE dt, long oprno,
	int    SLAPI RecByBill(PPID billID, short * rByBill);
	int    SLAPI UpdateCascadeLot(PPID lotID, PPID ownBillID, TrUCL_Param * p, uint flags, int use_ta);
	//
	// Descr: Используется для расчета текущего свободного остатка по лоту в контексте
	//   пакета PPBillPacket. Задача этой функции - быстро найти все товарные строки,
	//   принадлежащие пакету с ид billID и относящиеся к лоту lotID и вычесть из остатка
	//   *pRest поле Quantity каждой из таких строк.
	//
	int    SLAPI SubtractBillQtty(PPID billID, PPID lotID, double * pRest);
	int    SLAPI PreprocessCorrectionExp(PPTransferItem & rTi, const PPIDArray & rBillChain);
	int    SLAPI CheckLot(PPID lotID, const ReceiptTbl::Rec *, long flags, PPLotFaultArray *);
	int    SLAPI RecoverLot(PPID lotID, PPLotFaultArray *, long flags /* TLRF_XXX */, int use_ta);
	int    SLAPI RecalcLcr();
	int    SLAPI MoveLotOp(PPID srcLotID, LDATE dt, long oprno, PPID destLotID, int use_ta);
	int    SLAPI MoveLotOps(PPID srcLotID, PPID destLotID, long flags /* TMLOF_XXX */, int use_ta);
	int    SLAPI Cutting(LDATE endDate, int use_ta);

	class GetLotPricesCache {
	public:
		SLAPI  GetLotPricesCache(LDATE dt, const PPIDArray * pLocList);
		int    SLAPI Get(ReceiptTbl::Rec * pLotRec);
	private:
		LDATE  Date;
		PPIDArray RLotList; // Список лотов, по которым были переоценки после Date
	};
private:
	//
	// Descr: Блок обработки текущих остатков по лотам
	//   Все изменения в базе данных методами класса делаются без
	//   транзакции. Ergo: вызывающие функции должны позаботиться о транзактивности.
	//
	class LcrBlock {
	public:
		enum {
			opTest = 1, // Проверка правильности заполнения данных
			opRecalc,   // Полный пересчет записей текуших остатков
			opUpdate    // Пересчет в ответ на изменение записи Transfer
		};
		enum {
			statusAddRec = -3, // Запись необходимо добавить
			statusUpdRec = -2, // Запись необходимо изменить
			statusRmvRec = -1, // Запись необходимо удалить
			statusNone   = 0,  // Запись верная //
			statusInvRest,     // Неверный остаток
			statusAbsence,     // Отсутствующая запись
			statusWaste,       // Лишняя запись
			statusDb           // Ошибка извлечения записи
		};
		LcrBlock(int op, LotCurRestTbl * pTbl, BExtInsert * pBei);
		int    InitLot(PPID lotID);
		//
		// Descr: Изменяет актуальное состояние таблицы в ответ на изменение
		//   остатка по лоту lotID на дату dt и на величину addendum.
		//
		int    Update(PPID lotID, LDATE dt, double addendum);
		int    FASTCALL Process(const TransferTbl::Rec & rTrfrRec);
		int    FinishLot();
		int    TranslateErr(PPLotFaultArray * pLfa) const;
		int    HasError() const;
	private:
		int    AddItem(int status, LDATE dt, double exRest, double newRest);

		int    Op;
		//
		// Descr: Определитель записи. Используется как для обновления состояния таблицы,
		//   так и для диагностики ошибок.
		//
		struct Item {
			LDATE  Dt;         // Дата записи
			int    Status;     // Статус записи
			double ExRest;     // Значение остатка в текущем состоянии записи
			double ValidRest;  // Правильное или новое значение остатка.
		};
		TSArray <Item> List;
		PPID   LotID;
		LDATE  LastDate;
		double LastRest;
		double CurTrfrRest; //
		LotCurRestTbl * P_Tbl;
		BExtInsert * P_Bei;
	};
	struct LotOpMovParam {
		PPID   SrcLotID;
		PPID   DestLotID;
		ReceiptTbl::Rec  SrcLot;
		ReceiptTbl::Rec  DestLot;
		TransferTbl::Rec TrRec;
	};
	int    SLAPI ProcessLotFault(PPLotFaultArray *, int fault, double act, double valid);
	int    SLAPI UpdateFwRevalCostAndPrice(PPID lotID, LDATE dt, long oprno,
		double cost, double price, uint * pUF /* TRUCLF_UPDCOST || TRUCLF_UPDPRICE */);
	int    SLAPI UpdateFwRevalCostAndPrice2(PPID lotID, LDATE dt, long oprno, double cost, double price, uint * pUF);
	int    SLAPI Search(PPID lot, LDATE, long oprno, int spMode);
	int    SLAPI GetLotOprNo(LDATE, long * oprno);
	int    SLAPI UpdateForward(const TransferTbl::Rec &, double addendum, double phAdd);
	int    SLAPI UpdateCurRest(PPID goodsID, PPID loc, double addendum);
	int    SLAPI RemoveItem(PPID bill, int rvrs, short rByBill, int force, int use_ta);
	int    SLAPI UpdateItem(PPTransferItem *, int16 & rByBill, int rvrs, long flags, int use_ta);
	int    SLAPI UpdateReceipt(PPID lotID, PPTransferItem *, PPID prevLotID, long flags);
		// @<<Transfer::UpdateItem(PPTransferItem *, int, long, int)
	int    SLAPI EnumIncorrectReverse(PPID * billID, short * rByBill, TransferTbl::Rec * orgRec);
	int    SLAPI InitLotOpMovParam(PPID srcLotID, PPID destLotID, LotOpMovParam *, int = 0);
	int    SLAPI MoveOp(LotOpMovParam *, int use_ta);
	int    SLAPI MergeLots(LotOpMovParam *, uint flags, int use_ta);
	int    SLAPI CuttingLotOperations(PPID lotID, LDATE endDate, double * pEndQtty);
	int    SLAPI Helper_RecalcLotCRest(PPID lotID, BExtInsert * pBei, int forceRebuild);

	LotCurRestTbl * P_LcrT; //
public:
	ReceiptCore  Rcpt;
	CurRestTbl   CRest;
	// Realy private
	int    __DontCheckQttyInUpdateTransferItem__;
};
//
//   GoodsSaldoCore
//
class GoodsSaldoCore : public GoodsDebtTbl {
public:
	SLAPI  GoodsSaldoCore();
	//
	// Функция GetLastSaldo возвращает в pDt дату последнего рассчитаного сальдо <= *pDt.
	// Если *pDt == ZERODATE, то возвращает дату самого последнего рассчитаного сальдо.
	// Если код возврата < 0 - нет ни одного рассчитаного сальдо, *pDt = ZERODATE.
	//
	int    SLAPI GetLastSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, LDATE * pDt, GoodsDebtTbl::Rec * pRec);
	int    SLAPI GetLastCalcDate(PPID gdsGrpID, PPID gdsID, PPID arID, PPID dlvrLocID, LDATE * pDt);
	int    SLAPI Add_(PPID gdsID, PPID artID, LDATE dt, double qtty, double amt, int use_ta);
	int    SLAPI DeleteRecsByPeriod_(PPID gdsID, PPID artID, const DateRange * pPeriod, int use_ta);
};
//
//
//
struct PriceLineIdent {
	SLAPI  PriceLineIdent();
	PPID   PListID;
	PPID   GoodsID;
	PPID   QuotKindID;
	int16  LineNo;
};

class PriceListCore : public PriceListTbl {
public:
	SLAPI  PriceListCore();
	int    SLAPI Search(PPID id, void * b = 0);
	int    SLAPI Add(PPID * pID, void *, int use_ta);
	int    SLAPI Update(PPID id, void *, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI SearchLine(const PriceLineIdent *, void * = 0);
	int    SLAPI SearchGoodsLine(PriceLineIdent * pIdent, void * = 0);
	int    SLAPI EnumLines(const PriceLineIdent * pIdent, PriceLineIdent * pIter, void * = 0);
	int    SLAPI AddLine(PPID listID, void *, PriceLineIdent *, int useSubst, int use_ta); // AHTOXA
	int    SLAPI UpdateLine(const PriceLineIdent *, PriceLineTbl::Rec *, int useSubst, int use_ta); // AHTOXA
	int    SLAPI RemoveLine(const PriceLineIdent *, int use_ta);
private:
	int    SLAPI GetLineNo(const PriceLineIdent *, short * pLineNo);
	PriceLineTbl::Key0 * SLAPI IdentToKey0(const PriceLineIdent *, PriceLineTbl::Key0 *);
public:
	PriceLineTbl Lines;
};
//
// Системный журнал
//
enum SubstGrpSysJournal {
	sgsjNone    = 0,
	sgsjOp      = 1,
	sgsjUser    = 2,
	sgsjObjType = 3
};

class SysJournal : public SysJournalTbl {
public:
	SLAPI  SysJournal();
	SLAPI ~SysJournal();
	int    SLAPI LogEvent(PPID action, PPID obj, PPID id, long extData, int use_ta = 0);
	//
	// Descr: Находит запись события action
	// ARG(action     IN): Системное событие (PPACN_XXX), которое следует найти
	// ARG(mode       IN): Режим поиска события //
	//   -1 - до момента *pDtm
	//    1 - после момента *pDtm
	// ARG(pDtm   IN/OUT): @#{vptr0}
	//    Если функция нашла требуемую запись, то по этому указателю присваивается //
	//    дата и время найденной записи.
	// ARG(maxDays    IN): Если параметр >0, то функция ограничивает просмотр событий периодом
	//   [pDtm->d-maxDays..pDtm] (mode = -1) и [pDtm..pDtm->d+maxDays] (mode = 1)
	// ARG(pRec      OUT): @#{vptr0} По этому указателю, если он не нулевой, функция //
	//   возвращает первую найденную запись.
	//
	int    SLAPI GetEvent(PPID action, int mode, LDATETIME * pDtm, int maxDays, SysJournalTbl::Rec * pRec = 0);
	int    SLAPI GetLastEvent(PPID action, LDATETIME * pDtm, int maxDays, SysJournalTbl::Rec * = 0);
	int    SLAPI GetLastUserEvent(PPID action, PPID userID, PPID sessID, const DateRange * pSrchPeriod, LDATETIME *, SysJournalTbl::Rec * pRec = 0);
	int    SLAPI GetObjCreationEvent(PPID objType, PPID objID, SysJournalTbl::Rec * pRec);
	int    SLAPI GetLastObjModifEvent(PPID objType, PPID objID, LDATETIME *, int * pCreation, SysJournalTbl::Rec * pRec = 0);
	int    SLAPI GetLastObjEvent(PPID objType, PPID objID, const PPIDArray * pActAry, LDATETIME * pDtm, SysJournalTbl::Rec * pRec = 0);
	int    SLAPI GetLastObjUnifyEvent(PPID objType, PPID objID, PPID * pDestID, SysJournalTbl::Rec * pRec);
	int    SLAPI GetObjListByEventSince(PPID objType, const PPIDArray * pActList, const LDATETIME & rSince, PPIDArray & rObjList);
	int    SLAPI GetObjListByEventPeriod(PPID objType, PPID userID, const PPIDArray * pActList, const DateRange * pPeriod, PPIDArray & rObjList);
	int    SLAPI IsEventExists(PPID objType, PPID objID, PPID userID, const PPIDArray * pActList);
	int    SLAPI CheckObjForFilt(PPID objType, PPID objID, const SysJournalFilt * pFilt);
	int    SLAPI DoMaintain(LDATE toDt, int recover, PPLogger * pLogger);
	int    SLAPI Subst(SubstGrpSysJournal sgsj, PPID opID, PPID prmrID, PPID scndID, PPID * pID);
	int    SLAPI GetSubstName(SubstGrpSysJournal sgsj, PPID id, char * pBuf, size_t bufLen);
private:
	int    SLAPI GetObjEventList(PPID objType, PPID objID, const PPIDArray * pActList, SArray * pResultList);
	SjRsrvTbl * P_RsrvT;
	//
	// Что бы при ошибке регистрации события не тратить лишнее время на формирования сообщений журнала
	// используем постоянные буферы.
	//
	SString FmtBuf;
	SString MsgBuf;
	SString AddedBuf;
	SString TempBuf; // @allocreuse
};
//
//
//
/* @v9.6.4 (useless) class DGQCore : public DGQTbl {
public:
	SLAPI  DGQCore();
	int    SLAPI SearchQuery(const S_GUID & rUuid, DGQTbl::Rec * pRec);
    int    SLAPI PutQuery(const S_GUID & rUuid, int queryType, int use_ta);
    int    SLAPI CommitQuery(const S_GUID & rUuid, int use_ta);
}; */
//
// Класс ObjSync управляет синхронизацией объектов в распределенной БД
//
struct PPCommSyncID { // @persistent @size=6
	SLAPI  PPCommSyncID();
	int    FASTCALL operator == (const PPCommSyncID s) const;
	int    FASTCALL operator != (const PPCommSyncID s) const;
	int    SLAPI IsZero() const;
	PPCommSyncID & SLAPI SetZero();
	PPCommSyncID FASTCALL operator = (const PPCommSyncID s);
	PPCommSyncID FASTCALL operator = (const ObjSyncTbl::Rec & rRec);
	PPCommSyncID FASTCALL operator = (const ObjSyncQueueTbl::Rec & rRec);
	PPCommSyncID FASTCALL operator = (const TempSyncCmpTbl::Rec & rRec);
	void   FASTCALL Get(ObjSyncTbl::Rec * pRec) const;
	void   FASTCALL Get(ObjSyncQueueTbl::Rec * pRec) const;
	void   FASTCALL Get(TempSyncCmpTbl::Rec * pRec) const;
	SString & ToStr(long fmt, SString &) const;
	int    FASTCALL FromStr(const char *);

	int16  P;
	int32  I;
};

struct ObjSyncIdent {
	int16  fComm;     // ObjID - is Common ID, otherwise - Private ID
	PPCommSyncID CommID;
	PPID   ObjType;
	PPID   ObjID;
	PPID   DBID;
};
//
// Флаги записей таблицы ObjSync
//
#define OBJSYNCF_DELETED 0x0001 // Объект, соответствующий записи, удален

class ObjSyncCore : public ObjSyncTbl {
public:
	SLAPI  ObjSyncCore();
	int    SLAPI SearchPrivate(PPID objType, PPID id, PPID dbid, ObjSyncTbl::Rec * = 0);
	int    SLAPI SearchCommon(PPID objType, PPCommSyncID id, PPID dbid, ObjSyncTbl::Rec * = 0);
	int    SLAPI SearchSync(PPID obj, PPID privateID, PPID dbID, int foreign, ObjSyncTbl::Rec * pRec);
	int    SLAPI GetSyncStatus(PPID objType, PPID privID, PPCommSyncID * pCommId, PPIDArray * pDbDivList);
	//
	// Descr: Возвращает список идентификаторов объектов в собственной базе данных, соответствующих
	//   чужому идентификатору foreignID. Предполагается, что вызывающая функция не знает какому
	//   разделу принадлежит foreignID.
	//
	int    SLAPI GetPrivateObjectsByForeignID(PPID objType, PPID foreignID, PPIDArray * pPrivateIdList);
	int    SLAPI Search(const ObjSyncIdent * pIdent, ObjSyncTbl::Rec * pRec);
	int    SLAPI Remove_S(const ObjSyncIdent * pIdent, int use_ta);
	int    SLAPI Update(const ObjSyncIdent *, const ObjSyncTbl::Rec * pRec, int use_ta);
	int    SLAPI AddRawRecord(ObjSyncTbl::Rec * pRec, int use_ta);

	int    SLAPI TransmitObj(PPObjID obj, PPCommSyncID * pCommID, int use_ta);
	int    SLAPI SearchCommonObj(PPID, PPCommSyncID commID, PPID * pID, ObjSyncTbl::Rec * = 0);
	int    SLAPI AckObj(PPID objType, PPID foreinID, PPCommSyncID commID, PPID dbid, const LDATETIME * pDtm, int use_ta);
	int    SLAPI SelfSync(PPID obj, PPID id, PPID destDbID, int use_ta);
	int    SLAPI RemoveByCommID(PPID objType, PPCommSyncID commID, PPID dbid, int use_ta);
	int    SLAPI RemoveByPrivateID(PPID objType, PPID objID, int use_ta);
	int    SLAPI _RcvObj(PPID obj, PPID id, PPCommSyncID commonID, PPID dbid, const LDATETIME * pDtm, int use_ta);
private:
	int    SLAPI GetFreeCommonID(PPID, PPCommSyncID * pCommID);
};
//
//
//
class ObjSyncQueueCore : public ObjSyncQueueTbl {
public:
	struct FileInfo {
		SLAPI  FileInfo();
		long   QueueID;        // Идентификатор записи о файле в очереди
		SString InnerFileName; // Имя внутреннего файла (возможно, с путем)
		SString OrgFileName;   // Имя оригинального файла (возможно, с путем)
		LDATETIME Mod;         // Время модификации файла OrgFileName
		SVerT  Ver;           // Версия системы, создавшая OrgFileName
		long    Flags;         // Флаги из заголовка OrgFileName
	};
	SLAPI  ObjSyncQueueCore();
	int    SLAPI Search(PPID queueID, ObjSyncQueueTbl::Rec * pRec);
	int    SLAPI SearchObject_(PPID objType, PPID objID, PPID dbID, ObjSyncQueueTbl::Rec * pRec);
	//
	// Descr: Возвращает список идентификаторов записей, содержащих информацию о необработанных объектах.
	// Returns:
	//   >0 - есть по крайней мере один необработанный объект
	//   <0 - нет ни одного необработанного объекта
	//    0 - ошибка
	//
	int    SLAPI GetUnprocessedList(PPIDArray * pList);
	int    SLAPI AddFileRecord(PPID * pID, const ObjSyncQueueCore::FileInfo & rInfo, int use_ta);
	int    SLAPI GetFileRecord(PPID id, ObjSyncQueueCore::FileInfo & rInfo);
	int    SLAPI SearchRefToOrgFile(const char * pFileName, ObjSyncQueueCore::FileInfo * pInfo);
	int    SLAPI MarkAsProcessed(PPID queueID, PPID primaryID, int use_ta);
	//
	// Descr: Полностью очищает очередь приема объектов и удаляет файлы из
	//   каталога очереди
	// Returns:
	//   !0 - функция успешно выполнена
	//   0  - ошибка
	//
	int    SLAPI Clear();
	//
	// Descr: Отладочная функция, выводящая в журнал информацию об объектах типа objType в очереди.
	//
	int    SLAPI PrintDebugObjList(PPID objType);
};
//
// Специальные серии (брак, ...)
//
#define SPCSERIK_SPOILAGE 1L

#define SPCSELIF_FALSIFICATION 0x00000001L // Товар фальсифицирован
#define SPCSELIF_ALLOW         0x00000002L // Товар разрешен к продаже
//
// Идентификаторы строковых полей, хранящихся в хвостовой части записи SpecSeries2Tbl
//
#define SPCSNEXSTR_GOODSNAME        1 // Текстовое наименование товара (может отличаться от GoodsID.Name)
#define SPCSNEXSTR_MANUFNAME        2 // Текстовое наименование производителя (может отличаться от ManufID.Name)
#define SPCSNEXSTR_LABNAME          3 // Текстовое наименование лаборатории, осущетсвлявшей анализ
#define SPCSNEXSTR_MANUFCOUNTRYNAME 4 // Текстовое наименование страны происхождения (может отличаться от ManufCountryID.Name)
#define SPCSNEXSTR_DESCRIPTION      5 // Текстовое описание серии (характер дефекта и т.д.)

class SpecSeriesCore : public SpecSeries2Tbl {
public:
	static int SLAPI GetExField(const SpecSeries2Tbl::Rec * pRec, int fldId, SString & rBuf);
	static int SLAPI SetExField(SpecSeries2Tbl::Rec * pRec, int fldId, const char * pBuf);

	SLAPI  SpecSeriesCore();
	int    SLAPI Search(PPID id, SpecSeries2Tbl::Rec *);
	int    SLAPI Put(PPID * pID, SpecSeries2Tbl::Rec *, int use_ta);
	int    SLAPI ClearAll();
	int    SLAPI SearchBySerial(PPID infoKind, const char * pBuf, SpecSeries2Tbl::Rec * = 0);
	int    SLAPI GetListBySerial(PPID kind, const char * pSerial, StrAssocArray * pList);
private:
};
//
// Descr: Вектор занятости процессора
//
struct PrcBusy : public STimeChunk {
	int    SLAPI Init(const LDATETIME &, const LDATETIME &, int status, int idle = 0);
	int    SLAPI Init(const LDATETIME &, long cont, int status, int idle = 0);
	//
	// Descr: Находит пересечение векторов *this и rTest.
	// ARG(rTest    IN): Вектор, на пересечение с которым проверяется *this.
	// ARG(pResult OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается //
	//   результат пересечения *this и rTest.
	// Returns:
	//   !0 - вектора *this и rTest пересекаются //
	//   0  - вектора *this и rTest не пересекаются //
	//
	int    SLAPI Intersect(const PrcBusy & rTest, PrcBusy * pResult) const;

	PPID   TSessID; // ИД сессии, которая занимает процессор в это время //
	int16  Status;  // PPSESST_XXX
	int16  Idle;    // Если !0 - период простоя //
};

class PrcBusyArray : public STimeChunkArray {
public:
	SLAPI  PrcBusyArray();
	int    SLAPI Add(const PrcBusy &, int checkForFree);
	int    SLAPI IsFreeEntry(const PrcBusy & entry, PPID * pTSessID) const;
	int    SLAPI IsFreeEntry(const LDATETIME &, long cont, PPID * pTSessID) const;
	//
	// Descr: Получает список доступных периодов процессора
	//   До вызова этой функции массив this должен быть отсортирован функцией PrcBusyArray::Sort.
	//
	int    SLAPI GetFreeList(PrcBusyArray * pList) const;
};
//
// Технологические сессии
// Класс, управляющий таблицами технологических сессий.
//
struct TSessGoodsTotal {
	long   Count;
	double Qtty;
	double PhQtty;
	double Amount;
};

class TSessLineCore : public TSessLineTbl {
public:
	PPTblEnumList EnumList;
};

class TSessionCore : public TSessionTbl {
public:
	friend class PPTblEnum <TSessLineCore>;

	SLAPI  TSessionCore();
	int    SLAPI Search(PPID id, TSessionTbl::Rec * pRec);
	int    SLAPI SearchByPrcTime(PPID prcID, int kind, const LDATETIME & rDtm, TSessionTbl::Rec * pRec);
	//
	// Descr: Флаги функции GetChildIDList
	//
	enum {
		gclfSubSess   = 0x0001,
		gclfRecursive = 0x0002
	};
	//
	// Descr: возвращает список дочерних по отношению к superSessID сессий
	//   (rec.ParentID == superSessID).
	//   Массив pList предварительно не очищается.
	//   Новые элементы добавляются функцией pList->addUnique - то есть,
	//   вызов этой функции не приведет к появлению в массиве дублируемых элементов.
	//   Если pList == 0, то функция отработает корректно, специф Returns остается в силе.
	// Returns:
	//   >0 - найдена как минимум одна дочерняя сесси
	//   <0 - не найдено ни одной дочерней сессии
	//   0  - ошибка
	//
	int    SLAPI GetChildIDList(PPID superSessID, long flags, PPIDArray * pList);
	int    SLAPI SearchLine(PPID sessID, long oprNo, TSessLineTbl::Rec *);
		// @>>TSessionCore::SearchOprNo
	int    SLAPI SearchLineByTime(PPID sessID, const LDATETIME & rDtm, TSessLineTbl::Rec *);
	//
	//
	//
	enum {
		sserLast = 0x0001, // Брать только самую последнюю строку
		sserRest = 0x0002  // Брать только строки остатков
	};
	int    SLAPI SearchSerial(const char * pSerial, PPID sessID, int sign, long flags, TSessLineTbl::Rec * pRec);
	//
	// Descr: ищет первую (в хронологическом порядке) работающую сессию
	//   (Status == TSESST_INPROCESS) на процессоре prcID.
	//   Если параметр kind == TSESK_IDLE, то ищет сессию простоя,
	//   если kind == TSESK_PLAN, то ищет сессию плана,
	//   в противном случае ищет обычную активную сессию.
	// Returns:
	//   <0 - работающих сессий на процессоре prcID нет
	//   >0 - найдена работающая сессия на процессоре prcID. В буфер pRec
	//        копируется запись найденной сессии
	//   0  - ошибка
	// Remark: спецификация не допускает существование одновременно двух
	//   или более работющих сессий на одном процессоре.
	//
	int    SLAPI GetProcessed(PPID prcID, int kind, TSessionTbl::Rec * pRec);
	int    SLAPI InitPrcEntry(const TSessionTbl::Rec *, PrcBusy *) const;
	//
	// Descr: Заполняет список периодов, в течении которых процессор prcID занят.
	//   При нахождении этого списка пропускаются техн сессии со статусом TSESST_CANCELED.
	// ARG(prcID      IN): ИД процессора, для которого заполняется список периодов занятости
	// ARG(exclTSesID IN): ИД сессии, которую не следует принимать во внимание. Если вызывающая //
	//   функция хочет определить допустимый диапазон для какао-либо сессии, то ИД этой сессии
	//   следует передать этим параметром.
	// ARG(kind       IN): @#{TSESK_SESSION || TSESK_PLAN || TSESK_IDLE} Вид сессий, которые
	//   необходимо рассматривать при заполнении массива. Система допускает пересечение обычных
	//   сессий с сессиями простоя и с сессиями плана. В тоже время сессии одного вида друг с другом
	//   пересекаться не могут.
	// ARG(pPeriod    IN): @#{vptr0} Указатель на период, которым должен быть ограничен загружаемый
	//   массив. Если какой-либо элемент массива пересекает границу периода, то его продолжительности
	//   обрезается по границе этого периода.
	// ARG(pList     OUT): Указатель на массив, в который функция заносит периоды занятости.
	// Returns:
	//   >0 - функция успешно выполнена
	//   0  - ошибка
	//
	int    SLAPI LoadBusyArray(PPID prcID, PPID exclTSesID, int kind, const STimeChunk * pPeriod, PrcBusyArray * pList);
		// @<<TSessionCore::InitPrcEntry

	int    SLAPI Put(PPID * pID, TSessionTbl::Rec * pRec, int use_ta);
	int    SLAPI UpdateFlags(PPID id, long setF, long resetF, int use_ta);
	int    SLAPI UpdateSuperSessCompleteness(PPID sessID, int use_ta);
	int    SLAPI AdjustLineTime(TSessLineTbl::Rec * pRec);

	int    SLAPI InitLineEnum(PPID sessID, long * pHandle);
	int    SLAPI InitLineEnumBySerial(const char * pSerial, int sign, long * pHandle);
	//
	// Descr: Вызов с параметром pRec == 0 разрушает итератор с хандлером enumHandle
	//
	int    SLAPI NextLineEnum(long enumHandle, TSessLineTbl::Rec * pRec);
	int    SLAPI DestroyIter(long enumHandle);

	SEnumImp * SLAPI EnumLines(PPID sessID);
	SEnumImp * SLAPI EnumLinesBySerial(const char * pSerial, int sign);
	//
	// Descr: Подсчитывает итоги по технологической сессии sessID.
	//   Если параметр goodsID != 0, то подсчитывает итоги только по строкам, соответствующим этому товару.
	//   Если goodsID ялвяется обобщенным товаром либо группой, то суммирование ведется по строкам,
	//   товар в которых относится к этому обобщению либо группе.
	//
	int    SLAPI CalcGoodsTotal(PPID sessID, PPID goodsID, TSessGoodsTotal * pTotal);
	int    SLAPI SearchOprNo(PPID sessID, long * pOprNo, TSessLineTbl::Rec *);
	int    SLAPI SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	//
	// Descr: Заменяет все ссылки на статью dest ссылками на статью src.
	// @attension Функция выполняется без транзакции.
	// Returns:
	//   >0 - найдена и заменена по крайней мере одна ссылка
	//   <0 - не найдено ни одной ссылки на статью dest
	//   0  - ошибка
	//
	int    SLAPI ReplaceArticle(PPID dest, PPID src);
	//
	// Descr: Заменяет все ссылки на товар dest ссылками на товар src.
	// @attension Функция выполняется без транзакции.
	// Returns:
	//   >0 - найдена и заменена по крайней мере одна ссылка
	//   <0 - не найдено ни одной ссылки на товар dest
	//   0  - ошибка
	//
	int    SLAPI ReplaceGoods(PPID dest, PPID src);

	TSessLineCore Lines;
private:
	int    SLAPI SearchSessNumber(PPID prcID, long * pNumber, TSessionTbl::Rec * pRec);
	//
	// Descr: Если pRec->StDt == 0, то увеличивает время pRec->StTm на одну сотую секунды
	//   до тех пор, пока запись не станет уникальной по ключу {PrcID, StDt, StTm}.
	//   Это необъодимо, поскольку pRec->StDt == 0 является признаком неопределенности времени
	//   начала работы сессии. Следовательно проверка на уникальность ключа {PrcID, StDt, StTm}
	//   становится избыточной.
	// ARG(pRec IN/OUT): @#{vptr} указатель на запись перед добавлением ее в таблицу.
	// Returns:
	//   >0 - Поле pRec->StTm было изменено
	//   <0 - Функция не изменила состояния записи pRec
	//   0  - Ошибка
	// @attention: при массовом добавлении записей в таблицу (BExtInsert)
	//   эта функция не поможет: вероятно возникновение ошибки "Дублирование значения индекса"
	//
	int    SLAPI AdjustTime(TSessionTbl::Rec * pRec);
		// @<<TSessionCore::Put
	int    SLAPI Helper_GetChildIDList(PPID superSessID, long flags, PPIDArray * pList);
};
//
// Управление задачами
//
//
// Виды записей таблицы PrjTask (PrjTaskTbl::Rec.Kind)
//
#define TODOKIND_TASK        1 // Собственно задача
#define TODOKIND_TEMPLATE    2 // Шаблон задач
//
// Приоритеты задач (PrjTaskTbl::Rec.Priority)
// Строки соответствий: {PPSTR_TEXT; PPTXT_TODO_PRIOR}
//
#define TODOPRIOR_HIGHEST    1 // Максимальный
#define TODOPRIOR_HIGH       2 // Высокий
#define TODOPRIOR_NORMAL     3 // Нормальный
#define TODOPRIOR_LOW        4 // Низкий
#define TODOPRIOR_LOWEST     5 // Минимальный
//
// Статусы задач (PrjTaskTbl::Rec.Status)
// Строки соответствий для задач:    {PPSTR_TEXT; PPTXT_TODO_STATUS}
// Строки соответствий для шаблонов: {PPSTR_TEXT; PPTXT_TODOTEMPL_STATUS}
//
#define TODOSTTS_NEW         1 // Новая       (для шаблона - нормальный)//
#define TODOSTTS_REJECTED    2 // Отменена    (для шаблона - отменен)   //
#define TODOSTTS_INPROGRESS  3 // Выполняется (для шаблона не используется) //
#define TODOSTTS_ONHOLD      4 // В ожидании  (для шаблона не используется) //
#define TODOSTTS_COMPLETED   5 // Завершена   (для шаблона не используется) //

class PrjTaskCore : public PrjTaskTbl {
public:
	static int SLAPI IsValidStatus(int s) { return (s >= 1 && s <= 5) ? 1 : PPSetError(PPERR_INVTODOSTATUS); }
	static int SLAPI IsValidPrior(int p) { return (p >= 1 && p <= 5); }

	SLAPI  PrjTaskCore();
	int    SLAPI Search(PPID, void * = 0);
	int    SLAPI SearchByTime(const LDATETIME &, PPID * pID, PrjTaskTbl::Rec *);
	int    SLAPI SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	int    SLAPI ReplaceRefs(PPID objType, PPID replacedID, PPID newID, int use_ta);
	//
	// Descr: Ищет первую запись, сформированную по шаблону tempID и
	//   имеющую дату начала работ startDt
	//
	int    SLAPI SearchByTemplate(PPID templID, LDATE startDate, PrjTaskTbl::Rec *);
	int    SLAPI GetSingleByCode(long kind, const char * pCode, PPID * pID);
	int    SLAPI Add(PPID * pID, PrjTaskTbl::Rec *, int use_ta);
	int    SLAPI Update(PPID id, PrjTaskTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет статус задачи id на значение newStatus.
	// Returns:
	//   >0 - Статус задачи успешно изменен
	//   <0 - Задача id уже имеет статус newStatus - ничего не изменилось
	//   0  - Ошибка
	//
	int    SLAPI UpdateStatus(PPID id, int newStatus, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI RemoveByProject(PPID prjID, int use_ta);
};
//
// PredictSalesCore
//
// Максимальные значения параметров модели
//
#define MAX_ARMA_P 30
#define MAX_ARMA_Q 30
//
// Флаги записей таблицы PredictSalesTbl
//
#define PRSALF_ZERO     0x0001 // Нулевое значение
#define PRSALF_HOLE     0x0002 // Отсутствует реальная информация о продажах
//
// Типы записей таблицы PredictSalesTbl (RType)
//
#define PSRECTYPE_DAY        1 // Дневные продажи
#define PSRECTYPE_AVERAGE    2
#define PSRECTYPE_LAST_DAY   5 // Последний заполненный день
#define PSRECTYPE_LOCTAB     6 // Элемент таблицы соответствия склад-индекс
#define PSRECTYPE_HOLIDAY    7 // Запись соответствует выходному дню. GoodsID == 0, Quantity == 0, Amt == 0.
//
// Так как таблица PredictSalesTbl содержит очень много записей, для снижения размера
// файла и ускорения доступа к данным используются следующие трюки:
// 1. Идентификаторы складов заменяются на двухбайтовые индексы в таблице складов.
//    Эта таблица хранится в виде записей с типом PSRECTYPE_LOCTAB (6).
//    Для преобразования идентификатора склада в его индекс используется функция ShinkLoc
//    Для обратного преобразования - ExpandLoc
// 2. Даты хранятся в виде смещения в днях от 31/12/1995.
//    Для преобразования даты в смещение используется функция ShrinkDate
//    Для обратного преобразования - ExpandDate
//
struct PredictSalesItem {
	LDATE  Dt;
	double Qtty;
	double Amount;
};

class PsiArray : public TSArray <PredictSalesItem> {
public:
	SLAPI  PsiArray();
	int    SLAPI Add(const PredictSalesItem *);
	int    SLAPI ShrinkByCycleList(const PPCycleArray *, PsiArray *) const;
};
//
// Параметр pssValType, передаваемый в функции расчета значений PredictSalesStat::xxx()
//
#define PSSV_QTTY            1 // Рассчитать значение в количественных терминах
#define PSSV_AMT             2 // Рассчитать значение в суммовых терминах

#define PSSF_USELSSLIN  0x0001 // Рассчитывать параметры линейной аппроксимации

struct PredictSalesStat {
	SLAPI  PredictSalesStat(PPID coeffQkID = 0, const  PPQuotArray * pCoeffQList = 0);
	SLAPI ~PredictSalesStat();
	PredictSalesStat & FASTCALL operator = (const PredictSalesStat &);
	int    SLAPI Init();
	int    FASTCALL Step(const PredictSalesItem *);
	int    SLAPI Step(const PsiArray *, const DateRange * = 0);
	int    SLAPI Finish();
	//
	// Descr: Возвращает среднее арифметическое продаж товара
	//
	double FASTCALL GetAverage(int pssValType) const;
	//
	// Descr: Возвращает стандартное отклонение продаж товара
	//
	double FASTCALL GetSigma(int pssValType) const;
	//
	// Descr: Возвращает коэффициент вариации продаж товара
	//
	double FASTCALL GetVar(int pssValType) const;
	//
	// Descr: Возвращает оборачиваемость товара в днях (1 / GetAverage(int pssValType))
	//
	double FASTCALL GetTrnovr(int pssValType) const;
	double SLAPI Predict(int pssValType, LDATE, double * pYErr) const;

	PPID   LocID;          // @anchor
	PPID   GoodsID;
	LDATE  LastDate;
	LDATE  FirstPointDate; //
	long   Count;
	double QttySum;
	double QttySqSum;
	double AmtSum;
	double AmtSqSum;
	LssLin QttyLss;        // Параметры линейной аппроксимации по количеству
	LssLin AmtLss;         // Параметры линейной аппроксимации по сумме
	long   Flags;          // @anchor PSSF_XXX
private:
	const  PPID  CoeffQkID;            // @v7.8.12
	const  PPQuotArray * P_CoeffQList; // @notowned @v7.8.12
	SArray * P_List;
};

typedef int (FASTCALL * EnumPredictSalesProc)(PredictSalesItem *, long);

class PredictSalesCore : public PredictSalesTbl, public PPHolidays {
public:
	SLAPI  PredictSalesCore();
	SLAPI ~PredictSalesCore();

	//int    SLAPI MakeSalesRec(PPID locID, PPID goodsID, LDATE dt, double qtty, double amount, PredictSalesTbl::Rec * pRec);
	int    SLAPI Remove(const PredictSalesTbl::Rec * pRec);
	int    SLAPI SetValue(PPID locID, PPID goodsID, LDATE dt, double qtty, double amount);
	virtual int SLAPI IsHoliday(const ObjIdListFilt * pLocList, LDATE);
	virtual int SLAPI EnumHolidays(PPID locID, LDATE *);
	int    SLAPI IsHoliday(PPID locID, LDATE dt) const;
	int    SLAPI IsHolidayByLocIdx(int16 locIdx, LDATE dt) const;
	//
	// После одного или нескольких вызовов одной из следующих трех функций следует
	// вызвать Finish() для сохранения изменений в базе данных.
	//
	virtual int SLAPI SetHoliday(PPID locID, LDATE, int rmv = 0);
	int    SLAPI SetWeekdayAsHoliday(PPID locID, int dayOfWeek, int rmv = 0);
	int    SLAPI SetDayOfYearAsHoliday(PPID locID, int day, int month, int rmv = 0);
	int    SLAPI ClearHolidays();
	//
	// Пара функция SaveHolidays и RestoreHolidays используется при заполнении таблицы
	// продаж. С целью временной идентификации дней, в которых не было документов как выходных.
	// При использовании таблицы для прогнозирования такие дни, поскольку они были в прошлом,
	// не учитываются.
	//
	int    SLAPI SaveHolidays();
	int    SLAPI RestoreHolidays();
	//
	// Descr: Удаляет все содержимое таблиц PredictSales и GoodsStat
	//
	int    SLAPI ClearAll();
	int    SLAPI ClearByPeriod(DateRange period, PPID gGrpID, int use_ta);
	//
	// Descr: Завершает обновление таблицы.
	//
	int    SLAPI Finish(int locTabOnly, int use_ta);
	int    SLAPI SearchItem(int recType, PPID locID, PPID goodsID, LDATE, void * = 0);
	//
	// Descr: Функция оптимизированного перебора записей таблицы. На каждую найденную запись
	//   вызывается процедура proc со структурой PredictSalesItem и параметром extraParam.
	// ARG(locID      IN): ИД склада, по которому осуществляется поиск. Если locID < 0, тогда
	//   функция вызывается рекурсивно для всех складов по которым
	//   сформирована хотя бы одна запись в таблице.
	// ARG(goodsID    IN): ИД товара, по которому осуществляется поиск.
	// ARG(pPeriod    IN): Период, в который должны попадать найденные записи.
	//   Если pPeriod == 0, то выбираются записи независимо от даты.
	// ARG(maxItems   IN): Максимальное количество элементов, которые необходимо получить.
	//   Если maxItems < 0, то перебор начинается с более поздних дат, во всех остальных
	//   случаях перебор идет по возрастанию дат. Если maxItems != 0 и locID < 0, функция //
	//   вызывается рекурсивно для каждого склада. В связи с этим фактически может быть
	//   возвращено значительно больше записей, чем |maxItems|. В этом случае вызывающая  //
	//   функция должна будет самостоятельно разобраться с полученными значениями.
	// ARG(proc       IN): Callback-процедура, вызываемая для каждой найденной записи. Процедура имеет
	//   два параметра: указатель на структуру PredictSalesItem и extraParam,
	//   переданный изначально функции Enumerate в виде одноименного параметра.
	//   Реакция функции Enumerate на значение, возвращаемое из proc:
	//     > 0 - продолжает работу
	//     <= 0 - завершает работу и возвращает значение, возвращенное процедурой proc
	// ARG(extraParam IN): Произвольный параметр, передаваемый функцией Enumerate
	//   callback-процедуре proc.
	//
	int    SLAPI Enumerate(PPID goodsID, const ObjIdListFilt & rLocList, const DateRange * pPeriod, int maxItems, EnumPredictSalesProc proc, long extraParam);
	void   FASTCALL GetLocList(PPIDArray & rList) const;
	//
	// Descr: Удаляет все записи по складу locID и товару goodsID за период pPeriod.
	//   Если locID < 0, то удаляются записи по всем складам, зарегистрированным в таблице P_LocTab.
	//
	int    SLAPI RemovePeriod(PPID locID, PPID goodsID, const DateRange * pPeriod, int use_ta);
	int    SLAPI GetFirstDate(PPID locID, PPID goodsID, LDATE *);
	int    SLAPI GetPeriod(const ObjIdListFilt * pLocList, PPID goodsID, DateRange *);
	int    SLAPI GetPeriod(const ObjIdListFilt * pLocList, const PPIDArray * pGoodsList, DateRange *);

	int    SLAPI GetTblUpdateDt(LDATE *);
	int    SLAPI SetTblUpdateDt(LDATE);
	//
	// Descr: Рассчитывает статистику товара на складе locID по таблице PredictSales
	//
	int    SLAPI CalcStat(PPID goodsID, const ObjIdListFilt & rLocList, const DateRange *, int maxItems, PredictSalesStat *);
	int    SLAPI CalcStat(const PPIDArray & rGoodsIdList, const ObjIdListFilt rLocList, const DateRange * pPeriod, PredictSalesStat * pStat);
	int    SLAPI GetSeries(const PPIDArray & rGoodsIDList, const ObjIdListFilt & rLocList, const DateRange * pPeriod, PsiArray * pList);
	//
	// Извлекает статистику по товару goodsID на складе locID из таблицы GoodsStat
	//
	int    SLAPI GetStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);
	int    SLAPI GetLastUpdate(PPID goodsID, const ObjIdListFilt & rLocList, LDATE * pLastDate);
	//
	// Descr: хранит максимальную ошибку, возникающую из за различных
	//  форматов хранения данных в таблице базы данных.
	//
	struct StatStoreErr {
		long   Count;
		double QttySum;
		double QttySqSum;
		double AmtSum;
		double AmtSqSum;
	};
	int    SLAPI StoreStatByGoodsList(const PPIDArray & rGoodsList, LDATE commonLastDate, StatStoreErr * pErr, int use_ta);
		// @<<PrcssrPrediction::ProcessGoods
	//
	// Descr: Проверяет соотвествие таблиц данных текущей версии системы.
	//
	int    SLAPI CheckTableStruct();
	static int FASTCALL ShrinkDate(LDATE dt, int16 * pSDt);
	static int FASTCALL ExpandDate(int16 sdt, LDATE * pDt);

	int    SLAPI AddLocEntry(PPID locID, int16 * pLocIdx);
	int    FASTCALL ShrinkLoc(PPID locID, int16 * pLocIdx) const;
	int    FASTCALL ExpandLoc(int16 locIdx, PPID * pLocID);
	void * SLAPI SetKey(PredictSalesTbl::Key0 *, int typ, PPID locID, PPID goodsID, LDATE);

	GoodsStatTbl StT;
private:
	struct LocTabEntry {
		PPID   LocID;
		int16  LocIdx;
	};
	struct HldTabEntry {
		int16  LocIdx;
		int16  Day;
	};
	//
	// Descr: Добавляет продажи по товару goodsID на складе locID на дату dt.
	// Returns:
	//   1 - запись успешно добавлена
	//   2 - запись с таким ключом уже существовала, но была изменена
	//   0 - ошибка
	//
	int    SLAPI AddItem(long typ, PPID locID, PPID goodsID, LDATE dt, double qtty, double amount, long f);
	int    SLAPI WriteLocTab(int use_ta);
	int    SLAPI ReadLocTab();
	int    SLAPI WriteHolidays(int use_ta);
	int    SLAPI ReadHolidays();
	int    SLAPI SearchHoliday(int16 locIdx, int16 day, uint * pPos) const;
	int    FASTCALL SearchHoliday(HldTabEntry) const;
	int    SLAPI SetHldEntry(const HldTabEntry *, int rmv);
	int    SLAPI ShrinkHoliday(LDATE, int16 *);
	int    SLAPI ExpandHoliday(int16, LDATE *);
	int    SLAPI SearchStat(PPID goodsID, PPID locID, GoodsStatTbl::Rec * pRec);
	int    SLAPI SearchStat(PPID goodsID, const ObjIdListFilt & rLocList, GoodsStatTbl::Rec * pRec);
	int    SLAPI Helper_Enumerate(PPID goodsID, PPID locID, const DateRange * pPeriod, int maxItems, EnumPredictSalesProc proc, long extraData);

	TSArray <LocTabEntry> LocTab;
	int    IsLocTabUpdated;
	//
	// Descr: Таблица P_HldTab содержит записи выходных дней по каждому складу.
	//   Если запись имеет индекс склада равный нулю, то соответствующий ей выходной
	//   соответствует всем складам.
	//   Записи, содержащие индекс дня меньший нуля и больший -100, относятся к дням недели.
	//   Например запись {3, -6} означает, что склад с индексом (не идентификатором) 3 имеет
	//   выходной день субботу.
	//   Записи, содержащии индекс дня меньший или равный -100, относятся к датам, не
	//   зависящим от года. Например {2, -101} означает, что склад с индексом 2 имеет
	//   выходной 2 января во все года.
	//   Алгорим выяснения является ли некоторый день выходным следующий:
	//   1. Ищется запись {склад, дата}
	//   2. Если предыдущий пункт не привел к успеху, то ищется запись {склад, -день недели}
	//   3. Если предыдущий пункт не привел к успеху, то ищется запись {склад, -(день/месяц/1996)-100}
	//   4. Если предыдущий пункт не привел к успеху, то ищется запись {0, дата}
	//   5. Если предыдущий пункт не привел к успеху, то ищется запись {0, -день недели}
	//   6. Если предыдущий пункт не привел к успеху, то ищется запись {0, -(день/месяц/1996)-100}
	//   7. Если предыдущий пункт не привел к успеху, заданный день - рабочий
	//
	SArray * P_HldTab;
	int    IsHldTabUpdated;
	SArray * P_SaveHldTab;
};
//
// Descr: Флаги операция по персональным картам
//
#define SCARDOPF_FREEZING 0x0004 // Операция приостановки действия карты

class SCardCore : public SCardTbl {
public:
	//
	// Descr: Структура, определяющая операцию по кредитной карте.
	//
	struct OpBlock {
		static int CheckFreezingPeriod(const DateRange & rPeriod, LDATE expiry);

		OpBlock();
		OpBlock & Init(SCardOpTbl::Rec * pRec = 0);
		int    CheckFreezingPeriod(LDATE expiry) const;

		enum {
			fEdit     = 0x0001, // @transient Признак операции, уже отраженной в БД. Для такой
				// операции не допустимо изменене даты/времени и установка карты-приемника (DestSCardID)
			fRemove   = 0x0002, // @transient Признак требования удалить записи
			fFreezing = 0x0004  // @persistent @v8.6.4 Операция приостановки действия карты
		};
		PPID   SCardID;
		PPID   DestSCardID;
		PPObjID LinkOi;
		LDATETIME Dtm;
		DateRange FreezingPeriod;
		long   Flags;
		double Amount;
		//
		double PrevRest;     // @*SCardCore::GetOp() Остаток по карте SCardID перед операцией (Flags & fEdit)
		double PrevDestRest; // @*SCardCore::GetOp() Остаток по карте DestSCardID перед операцией (Flags & fEdit)
	};
	//
	struct UpdateRestNotifyEntry {
		PPID   SCardID;
		double PrevRest;
		double NewRest;
	};
	//
	// Descr: Определяет диапазон префиксов карт, которые могут быть сгенерированы
	//   по шаблону pTemplate.
	//
	static int SLAPI GetCodeRange(const char * pTemplate, SString & rLow, SString & rUpp);

	SLAPI  SCardCore();
	int    SLAPI Search(PPID, SCardTbl::Rec * = 0);
	int    SLAPI SearchCode(PPID seriesID, const char * pCode, SCardTbl::Rec *);
	//
	// Descr: Находит все карты, имеющие код pCode. Как правило, в базе данных есть только одна или ни одной
	//   карты с заданным кодом. Однако, если не применяется правило сквозной уникальности номеров карт,
	//   то возможно (не ошибочное, но намеренное) существование более одной карты с заданным номером.
	// Returns:
	//   -1 - не найдено ни одной карты с номером pCode
	//   >0 - количество карт, имеющих код pCode
	//    0 - ошибка. Если возинк сбой при чтении из таблицы, но найдена одна или более
	//       записей, то все равно будет возвращен 0, но в массив pList (если pList != 0) будут занесены
	//       все найденные идентификаторы.
	//
	int    SLAPI GetListByCode(const char * pCode, PPIDArray * pList);
	//
	// Descr: Находит все карты, связанные с персоналией personID. Если seriesID != 0, то
	//   ищет только те карты, которые принадлежат серии seriesID.
	// Note: Результирующий список pList не очищается при вызове функции, таким образом,
	//   идентификаторы найденных карт будут добавлены в конец списка.
	//
	int    SLAPI GetListByPerson(PPID personID, PPID seriesID, PPIDArray * pList);
	int    SLAPI GetListByLoc(PPID locID, PPID seriesID, PPIDArray * pList);
	int    SLAPI AutoFill(const PPSCardSeries2 * pSerRec, const char * pPattern, int use_ta);

	int    SLAPI SearchOp(PPID cardID, LDATE, LTIME, SCardOpTbl::Rec * pRec);
	int    SLAPI SearchOpByCheck(PPID checkID, SCardOpTbl::Rec * pRec);
	int    SLAPI SearchOpByLinkObj(PPID objType, PPID objID, SCardOpTbl::Rec * pRec);
	//
	// Descr: Находит последнюю операцию по карте cardID на дату, предшествующую dt.
	//   Если dt == 0, тогда находит абсолютно последнюю операцию.
	// Returns:
	//  >0 - searching is successfull
	//  <0 - nothing found
	//  0  - error
	//
	int    SLAPI GetLastOpByCard(PPID cardID, LDATE dt, SCardOpTbl::Rec *);
	int    SLAPI EnumOpByCard(PPID cardID, LDATETIME *, SCardOpTbl::Rec *);
	int    SLAPI PutOpByBill(PPID billID, PPID scardID, LDATE dt, double amount, int use_ta);
	int    SLAPI PutOpRec(const SCardOpTbl::Rec * pRec, TSArray <UpdateRestNotifyEntry> * pNotifyList, int use_ta);

	int    SLAPI GetOp(PPID cardID, const LDATETIME & rDtm, OpBlock * pBlk);
	int    SLAPI PutOpBlk(const OpBlock & rBlk, TSArray <UpdateRestNotifyEntry> * pNotifyList, int use_ta);
	int    SLAPI GetOpByLinkObj(PPObjID oid, TSArray <OpBlock> & rList);
	int    SLAPI GetFreezingOpList(PPID cardID, TSArray <OpBlock> & rList);

	int    SLAPI RemoveOp(PPID cardID, LDATE, LTIME, int use_ta);
	int    SLAPI RemoveOpByCheck(PPID checkID, int use_ta);
	int    SLAPI RemoveOpAll(PPID cardID, int use_ta);
	int    SLAPI RecalcForwardRests(PPID cardID, LDATE, LTIME, double * pRest, int use_ta);
	int    SLAPI RecalcRests(PPID cardID, double * pRest, int use_ta);
	//
	// Descr: Возвращает остаток по кредитной карте на дату dt. Если dt == ZERODATE или dt == MAXDATE,
	//   то возвращается текущий остаток по карте.
	//
	int    SLAPI GetRest(PPID cardID, LDATE dt, double * pRest);
	int    SLAPI Update(PPID id, SCardCore::Rec * pRec, int useTa);
	int    SLAPI UpdateDiscount(PPID, double discount, int use_ta);
	int    SLAPI AddTurnover(PPID, double add, int use_ta);
	int    SLAPI AddTurnover_Test(PPID id, double add, int use_ta); // @test
	int    SLAPI RecalcRestsBySeries(PPID serID, int use_ta);
	int    SLAPI MakeCodeByTemplate(PPID seriesID, const char * pPattern, SString & rCode);

	struct PrefixRange {
		uint   Len;
        SString Low;
        SString Upp;
	};

	int    SLAPI GetPrefixRanges(PPID seriesID, uint maxLen, TSCollection <PrefixRange> & rRanges);

	SCardOpTbl ScOp;
private:
	int    SLAPI UpdateRest_(PPID, double rest, TSArray <UpdateRestNotifyEntry> * pNotifyList, int use_ta);
	int    SLAPI UpdateExpiryDelta(PPID id, long delta, int use_ta);
};
//
// Descr: Конфигурация оборудования //
//
struct PPEquipConfig { // @persistent @store(PropertyTbl)
	SLAPI  PPEquipConfig();
	PPID   SLAPI GetCashierTabNumberRegTypeID();

	enum {
		fCheckScaleInput           = 0x00000001, // Сканировать весы при вводе документов
		fComplDeficit              = 0x00000002, // Компенсировать дефицит по кассовым сессиям за счет
			// комплектации недостающих товаров (для товаров, имеющих коплектуемую структуру)
		fCloseSessTo10Level        = 0x00000004, // Закрывать кассовые сессии до 10-го уровня //
		fIgnAcsReadyTags           = 0x00000008, // Не проверять признаки готовности асинхронных
			// кассовых машин к экспорту данных из Papyrus'а. Если этот флаг установлен,
			// то функция PPAsyncCashSession::OpenSession игнорирует результат вызова
			// функции PPAsyncCashSession::IsReadyForExport (но все равно вызывает ее).
		fIgnGenGoodsOnDeficit      = 0x00000010, // Не использовать обобщенные товары
			// для компенсации дефицита по кассовым сессиям
		fUseQuotAsPrice            = 0x00000020, // Для определения цены на товар с приоритетом
			// используется базовая котировка. Если котировка для заданных условий не определена,
			// тогда используется учетная цена реализации. Если этот флаг не установлен, то
			// для определения цены всегда используется учетная цена реализации
		fIntrPriceByRetailRules    = 0x00000040, // При формировании драфт-документа покрытия   //
			// дефицита для другого склада, цену реализации рассчитывать по правилам определения //
			// розничной цены продажи для своего склада.
		fValidateChecksOnSessClose = 0x00000080, // При закрытии асинхронной кассовой сессии проверять чеки.
		fWriteToChkOpJrnl          = 0x00000100, // Вести журнал чековых операций
		fRecognizeCode             = 0x00000200, // В кассовой панели распознавать назначение кода.
		fUnifiedPayment            = 0x00000400, // Унифицированный расчет в кассовой панели
		fIgnoreNoDisGoodsTag       = 0x00000800, // В кассовой панели игнорировать признак товара "Без скидки"
		fRestrictQttyByUnitRnd     = 0x00001000, // В кассовой панели ограничивать ввод количества
			// признаком целочисленности единицы измерения и ее параметром точности округления //
		fDisableManualSCardInput   = 0x00002000, // @v7.0.10 Запрет ввода номера дисконтной карты в ручную
		fUncondAsyncBasePrice      = 0x00004000, // @v7.1.3  Безусловная базовая цена для асинхронных узлов
		fDisableAdjWrOffAmount     = 0x00008000, // @v8.6.6  Запрет на корректировку суммы документов списания для уравнивания с кассовой сессией
		fUnifiedPaymentCfmBank     = 0x00010000, // @v8.6.6  Дополнительное подтверждение для оплаты по банку после унифицированной панели оплаты
		fAutosaveSyncChecks        = 0x00020000  // @v8.7.7  Автоматически сохранять синхронные чеки при каждом изменении
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_EQUIPCFG
	PPID   CshrsPsnKindID;  // Код вида персоналий - кассиры
	PPID   DefCashNodeID;   // Код кассового узла по умолчанию
	PPID   ScaleID_unused;  // Код весов // @v9.0.4 @unused (заменен на DefCashNode::ScaleID)
	long   Flags;           //
	PPID   OpOnDfctThisLoc; // Операция формирования документа по дефициту для своего склада
	PPID   OpOnDfctOthrLoc; // Операция формирования документа по дефициту для другого склада
	PPID   OpOnTempSess;    // Операция формирования документа по временным сессиям
	PPID   QuotKindID;      // Вид котировки
	//
	// Если AgentCodeLen && AgentPrefix[0] != 0, тогда в кассовой панели
	// ввод строки длиной AgentCodeLen начинающейся с AgentPrefix воспринимается //
	// как ввод агента.
	//
	// В противном случае код агента распознается по префиксу SAL
	//
	int16  AgentCodeLen;    // Длина кода агента.
	char   AgentPrefix[6];  // Префикс кода агента
	//
	PPID   FtpAcctID;       // Ид ftp-аккаунта
	PPID   SalesGoodsGrp;   // Группа-папка содержащая группы продаж
	IntRange DeficitSubstPriceDevRange; // Диапазон отличия цены подстановки товара
		// от фактической цены продажи дефицитного товара. хранится в промилле.
	PPID   WrOffAccOpID;      // Вид операции для бухгалтерского документа списания кассовых сессий.
    long   BHTRngLimWgtGoods; // Предел изменения для весового товара
	long   BHTRngLimPrice;    // Предел изменения цены для терминала BHT (от цены в документе образца)
	uint32 Reserve;
	char   SuspCcPrefix[8];   // @v8.1.9 Префикс номера отложенного чека для быстрого восстановления чека по номеру в кассовой панели
};

int  SLAPI ReadEquipConfig(PPEquipConfig * pCfg);
int  SLAPI EditEquipConfig();
PPID SLAPI GetCashiersPsnKindID();
//
//
//
struct CSessTotal {
	SLAPI  CSessTotal();
	int    FASTCALL Add(const CSessTotal * pSubTotal);

	PPID   SessID;         // Для выборки сессий - 0
	long   SessCount;      // Для итога по выборке сессий
	long   CheckCount;     // Количество чеков
	double Amount;         // Сумма по чекам
	double Discount;       // Скидка по чекам
	long   AggrCount;      // Количество агрегирующих строк
	double AggrAmount;     // Сумма по агрегирующим строкам
	double AggrRest;       // Сумма излишков по агрегирующим строкам
	long   WrOffBillCount; // Количество документов списания //
	double WrOffAmount;    // Списанная сумма
	double WrOffCost;      // AHTOXA
	double Income;         // AHTOXA
	double BnkAmount;      // Безналичная оплата
	double RetAmount;      // @v7.5.0 Общая сумма возвратов
	double RetBnkAmount;   // @v7.5.0 Сумма возвратов с оплатой через банк
	double WORetAmount;    // Сумма по чекам без чеков возврата
	double WORetBnkAmount; // Сумма безнал оплат без чеков возврата
	double BnkDiscount;    // Сумма безналичных скидок
	double CSCardAmount;   // Сумма по корпоративным кредитным картам
	double FiscalAmount;   // @v7.5.8 Фискальная сумма чеков
	long   SaleCheckCount; // Количество чеков продаж
	long   SaleBnkCount;   // @v7.5.0 Количество чеков продаж с оплатой через банк
	long   RetCheckCount;  // Количество чеков возврата
	long   RetBnkCount;    // @v7.5.0 Количество чеков возврата с оплатой через банк
};

struct CSessInfo {
	CSessionTbl::Rec  Rec;
	CSessTotal        Total;
};
//
// Степени незавершенности кассовых сессий
//
#define CSESSINCMPL_CHECKS   10 // Чеки приняты, но не сгруппированы суперсессии и товарные строки
#define CSESSINCMPL_GLINES    5 // Не полностью сформированы документы
#define CSESSINCMPL_COMPLETE  0 // Сессия полностью обработана, кроме,
	// возможно, не поступивших в систему извне чеков и излишков по сессии.

class CSessionCore : public CSessionTbl {
public:
	//
	// Descr: Возвращает период объединения сессий в суперсессии в секундах.
	//
	static long SLAPI GetUnitingPeriodSec();

	SLAPI  CSessionCore();
	int    SLAPI Search(PPID id, CSessionTbl::Rec * pRec = 0);
	int    SLAPI SearchByNumber(PPID * pID, PPID cashNodeID, long cashN, long sessN, LDATE);
	//
	// Descr: Находит последнюю сессию по кассовому узлу cashNodeID с уровнем завершенности
	//   меньшим или равным, чем incompl.
	// Note: Термин "последняя сессия" интерпретируется как сессия, имеющая максимальную
	//   валидную пару { Dt, Tm } и не имеющая признака 'Временная'.
	//   Искомая сессия считается удовлетворяющей условиям поиска не зависимо от того,
	//   является ли она простой или супер-сессией.
	// ARG(cashNodeID IN): ИД кассового узла
	// ARG(incompl    IN): Максимальное значение уровня завершенности искомой сессии.
	//   Note: специальное смещение 1000 позволяет пропустить сессию, являющуюся текущей
	//     для кассового узла cashNodeID (если это - синхронный узел).
	// ARG(pID       OUT):
	// ARG(pRec      OUT):
	// Returns:
	//   >0 - найдена искомая сессия
	//   <0 - искомая сессия не найдена. Значения по указателям pID и pRec не присваиваются.
	//   0  - ошибка
	//
	int    SLAPI SearchLast(PPID cashNodeID, int incompl, PPID * pID, CSessionTbl::Rec * pRec);
	int    SLAPI SearchSuperCandidate(PPID nodeID, const LDATETIME & rDtm, PPIDArray * pList);
	int    SLAPI HasChild(PPID sessID);
	int    SLAPI GetSubSessList(PPID superSessID, PPIDArray *);
	int    SLAPI GetLastNumber(PPID cashNodeID, long cashNumber, long * pNumber, CSessionTbl::Rec * pRec = 0);
	int    SLAPI GetIncompleteSessList(int grade /* CSESSINCMPL_XXX */, PPID cashNodeID, PPIDArray *);
	int    SLAPI CreateSess(PPID *, PPID cashNodeID, long cashN, long sessN, LDATETIME, int temporary);
	int    SLAPI CreateSuperSess(PPID * pSuperSessID, PPID cashNodeID, const PPIDArray & rSessList, int use_ta);
	int    SLAPI AttachToSuperSess(PPID superSessID, const PPIDArray & rSessList, int use_ta);
	int    SLAPI UpdateTotal(PPID id, const CSessTotal * pTotal, int wrOffSum, int completness, int use_ta);
	int    SLAPI SetSessIncompletness(PPID, int grade /* CSESSINCMPL_XXX */, int use_ta);
	int    SLAPI SetSessDateTime(PPID sessID, const LDATETIME & rDtm, int use_ta);
	int    SLAPI ResetTempSessTag(PPID, int use_ta);
	//
	// Descr: Заносит в массив pSessList список активных (не закрытых) на данный момент
	//   временных (CSessionTbl::Rec::Temporary != 0) асинхронных кассовых сессий по кассовому узлу nodeID.
	//   Массив pSessList предварительно функцией не очищается.
	// Returns:
	//   >0 - обнаружена по крайней мере одна подходящая сессия //
	//   <0 - нет ни одной подходящей сессии
	//   0  - ошибка
	//
	int    SLAPI GetTempAsyncSessList(PPID nodeID, const DateRange * pPeriod, PPIDArray * pSessList);
	int    SLAPI GetActiveSessList(PPID locID, ObjIdListFilt * pActiveSessList);
	//
	// Descr: Проверяет уникальность сочетания {cashNodeID, *pDt, *pTm}
	//   Если запись с таким сочетанием уже существует, то увеличивает на одну
	//   миллисекунду время, и проверяет уникальность снова. И так до тех пор, пока
	//   не будет найдено подходящее значение.
	// Returns:
	//   1 - значения по указателям pDt и pTm не были изменены
	//   2 - значения по указателям pDt и pTm были изменены
	//
	int    SLAPI CheckUniqueDateTime(PPID cashNodeID, LDATE * pDt, LTIME * pTm);
	int    SLAPI CheckUniqueDateTime(PPID superSessID, long posNumber, LDATE * pDt, LTIME * pTm);
	//
	//
	//
	long   SLAPI GetCcGroupingFlags(const CSessionTbl::Rec & rCsRec, PPID subSessID);
};
//
// @ModuleDecl(CCheckCore)
//
typedef TSArray <CCheckLineTbl::Rec> CCheckLineArray;

class CTableOrder {
public:
	struct Packet {
		Packet();
		void   Init(PPID posNodeID, LDATETIME initDtm, long initDuration);
		//
		PPID   PosNodeID;     // Ид кассового узла
		PPID   ChkID;         // Ид чека заказа
		long   CcNo;          // Номер чека заказа
		LDATETIME CcDtm;      // Дата/время чека заказа
		int16  TableNo;       // Номер стола
		int16  Status;        // 0 - открытый заказ, -1 - отмененный заказ, 1 - закрытый заказ
		PPID   SCardID;       // Ид кредитной карты, на которую начисляется сумма предоплаты
		double PrepayAmount;  // Сумма предоплаты
		STimeChunk Chunk;     // Период начала и завершения заказанного посещения.
		SString Memo;         // @v7.1.3 @memo
	};
	struct Param { // @persistent
		Param();
		int    Serialize(int dit, SBuffer & rBuf, SSerializeContext * pCtx);

		enum {
			fShowTimeGraph = 0x0001
		};

		long   Ver;
		PPID   PosNodeID;
		LDATETIME StartTime;
		long   InitDuration;
		long   Flags;
		long   TableNo;
		uint8  Reserve[32];
	};

	static int ShowTimeGraph(PPID posNodeID, int modeless);

	CTableOrder();
	~CTableOrder();
	int    HasRight(long rt);
	int    Edit(Packet * pPack);
	int    EditParam(Param * pParam);
	int    Create(Param *);
	int    Update(const Packet * pPack, int use_ta);
	int    Cancel(PPID ordCheckID);
	int    Print(const Packet * pPack);
	int    CheckTableBusyStatus(long tableNo, const STimeChunk & rChunk);
	int    GetCheck(PPID chkID, Packet * pPack);
	int    GetCheck(const CCheckTbl::Rec * pCcRec, const CCheckExtTbl::Rec * pCcExtRec, Packet * pPack);
	int    GetSCard(PPID scardID, SCardTbl::Rec * pScRec);
	int    SetupGrid(PPID posNodeID);
	int    UpdateGridItem(long tableNo, PPID checkID, const STimeChunk & rNewChunk);
private:
	int    MakeCCheckPacket(const Packet * pPack, CCheckPacket * pCcPack);
	enum {
		stRtUndef = 0x0001,
		stRtAll   = 0x0002
	};
	Packet P;
	long   State;
	PPObjSCard * P_ScObj;
	PPObjCashNode * P_CnObj;
	STimeChunkGrid * P_Grid;
};
//
// Descr: Смещение значения CCheckLineTbl::Rec::DivID, индицирующее признак того, что строка
//   была уже отправлена на кухонный принтер.
//
#define CHECK_LINE_IS_PRINTED_BIAS   10000
//
// Descr: Флаги элемента CCheckItem
//
enum {
	cifIsPrinted     = 0x0001, // Строка напечатана
	cifGift          = 0x0002, // Товар в строке является подарком
	cifUsedByGift    = 0x0004, // По строке был предоставлен подарок
	cifQuotedByGift  = 0x0008, // Подарок по строке был предоставлен в виде котировочной цены
		// @#{!cifQuotedByGift || cifUsedByGift}
	cifGrouped       = 0x0010, // Строка сгруппирована с предыдущей в списке
	cifPartOfComplex = 0x0020, // Строка является частью комплексного товара
	cifBySCard       = 0x0040, // Строка сгенерирована автоматически по факту установки карты.
		// (Карта имеет ненулевое значение SCardTbl::Rec::AutoGoodsID)
	cifPriceBySerial = 0x0080, // Цена на строку установлена по серийному номеру.
	cifGiftDiscount  = 0x0100, // @v7.0.2 Строка преодставляет подарочную суммовую скидку (по котировке PPQUOTK_GIFT).
		// При формировании окончательного чека сумма по этой строке полностью обнуляется а скидка разносится на весь чек.
	cifMainGiftItem  = 0x0200, // @#{!cifMainGiftItem || cifUsedByGift} @v7.0.6 Строка соответствует основному
		// компоненту подарочной структуры
	cifModifier      = 0x0400,  // @v7.2.0 Элемент является модификатором предшествующего элемента, не имеющего
		// такого признака (элемент может иметь несколько модификаторов, следующих один за другим).
	cifManualGift    = 0x0800, // @v7.3.7 @#{!cifManualGift || cifGift} Подарочная позиция была выбрана в ручную.
		// Позиции с таким признаком обрабатываются специальным образом, дабы не заставлять пользователя по-новой
		// выбирать один и тот же подарок много раз.
	cifHasModifier   = 0x1000, // @v8.6.9 Специальный избыточный флаг, идентифицирующий позицию, к которой привязан модификатор
		// Устанавливается при печати во временную структуру.
	cifFixedPrice    = 0x2000  // @v8.6.12 Цена по строке не должна пересчитываться при общем пересчете чека
		// Флаг введен в ответ на новую технику обработки чеков при которой все цены по строкам пересчитываются
		// по текущим ценам при внесении каких-либо изменений в чек.
};
//
// Descr: Специализированная структура, используемая для унифицированного
//   представления строки чека в коде системы.
//
struct CCheckItem { // @transient
	CCheckItem();
	CCheckItem & Init();
	CCheckItem & FASTCALL operator = (const CCheckItem & rS);
	CCheckItem & FASTCALL operator = (const CCheckLineTbl::Rec & rS);
	CCheckItem & FASTCALL operator = (const CCheckLineExtTbl::Rec & rS);
	int    GetRec(CCheckLineTbl::Rec & rRec, int ret) const;
	int    GetRec(CCheckLineExtTbl::Rec & rRec) const;
	int    SplitByQtty(double restQtty, CCheckItem & rNewItem);

	double NetPrice() const;
	double GetAmount() const;
	int    SetupGiftQuot(double quot, int forceZero);
	int    ResetGiftQuot();
	int    CanMerge(const CCheckPacket * pPack, const CCheckItem & rItem) const;

	PPID   GoodsID;         //
	double Quantity;        //
	double PhQtty;          //
	double Price;           //
	double Discount;        //
	double BeforeGiftPrice; // Цена строки, до того как к ней была применена подарочная котировка.
		// Поле имеет значение только в том случае, если Flags & cifQuotedByGift.
	PPID   GiftID;          // Если строка - подарочная, то это - идентификатор структуры, по которой подарок предоставлен.
	long   Flags;           // cifXXX
	int16  Division;        // Номер отдела
	int16  LineGrpN;        // Номер группы строк (используется только для печати и инициируется функцией
		// CheckPaneDialog::InitIteration
	int8   Queue;           // Очередность подачи
	int8   Reserve[3];      // @alignment
	char   BarCode[24];     // @v8.8.0 [16]-->[24]
	char   GoodsName[128];  //
	char   Serial[24];      //
	char   EgaisMark[80];   // @v9.0.9 Марка алкогольной продукции ЕГАИС
};

typedef TSArray <CCheckItem> CCheckItemArray;
//
// Типы сумм кассовых чеков
//
#define CCAMTTYP_AMOUNT      1 // Общая сумма чека
#define CCAMTTYP_DISCOUNT    2 // Сумма скидки
#define CCAMTTYP_FISCAL      3 // Фискальная сумма
#define CCAMTTYP_NONFISCAL   4 // Нефискальная сумма
#define CCAMTTYP_CASH        5 // Сумма наличными
#define CCAMTTYP_BANK        6 // Сумма, уплаченная через банк
#define CCAMTTYP_CRDCARD     7 // Сумма, зачтенная по корпоративной кредитной карте
#define CCAMTTYP_ADDCRDCARD  8 // Сумма, зачтенная по дополнительной корпоративной кредитной карте
#define CCAMTTYP_COUNT       9 // Количество чеков (используется для итогового суммирования выборки чеков)
#define CCAMTTYP_BANKDSCNT  11 // Скидка по безналичному чеку (используется для итогового суммирования выборки чеков)
#define CCAMTTYP_CSCCHARGE  12 // @v8.1.4 Специальная сумма, идентифицирующая начисление на кредитную карту по строкам
	// чека, содержащим товар для начисления. Такая сумма не включается в список оплат чека, сохраняемый вместе с чеком
#define CCAMTTYP_NOTE       13 // @v8.7.4 Сумма, полученная от покупателя (без учета сдачи)
#define CCAMTTYP_DELIVERY   14 // @v8.7.4 Сумма сдачи, возвращенная покупателю
//
// Invariants:
// CCAMTTYP_FISCAL+CCAMTTYP_NONFISCAL=CCAMTTYP_AMOUNT
// CCAMTTYP_CASH+CCAMTTYP_BANK+CCAMTTYP_CRDCARD=CCAMTTYP_AMOUNT
// CCAMTTYP_ADDCRDCARD < CCAMTTYP_CRDCARD
//

//
// Descr: Сумма по чеку
//
struct CcAmountEntry {
	CcAmountEntry();
	int    FASTCALL IsEqual(const CcAmountEntry & rS) const;
	int    GetTypeText(SString & rBuf) const;

	PPID   CheckID;    // Идентификатор чека. Важен, если собираются однотипные суммы по выборке чеков
	int32  Type;       // CCAMTTYP_XXX
	int32  AddedID;    // Дополнительный идент. Для PaymType == CCAMTTYP_CRDCARD - ид карты
	PPID   CurID;      // @v9.0.4 Валюта платежа
	double CurAmount;  // @v9.0.4 Сумма в валюте CurID. Если CurID == 0, то CurAmount == 0.0
	double Amount;     // Величина суммы
};
//
//
//
class CcAmountList : public TSArray <CcAmountEntry> {
public:
	CcAmountList();
	CcAmountList & Clear();
	int    GetSign() const;
	int    Search(int type, int32 addedID, uint * pPos) const;
	int    SearchAddedID(int32 addedID, uint * pPos) const;
	int    Set(int type, double amt, int32 addedID = 0);
	int    Add(int type, double amt, int32 addedID = 0);
	int    Normalize();
	int    InvertSign();
	double ScaleTo(double targetAmount);
	double Replace(int type, double amt, int32 addedID, int r1, int r2);
	double ReplaceDontRemove(int type, double amt, int32 addedID, int r1, int r2);
	double FASTCALL Get(int type) const;
	double Get(int type, LongArray * pAddedIdList) const;
	double Get(int type, int32 addedID) const;
	//
	// Descr: Возвращает сумму оплат по бонусным картам.
	// ARG(pScObj IN): Указатель на 'кземпляр объекта PPObjSCard, используемый
	//   для получения информации о приндалежности платежных карт бонусным сериям.
	//   Если pScObj == 0, то функция создаст собственный 'кземпляр PPObjSCard, однако такой
	//   вариант скажется на производительности (создание объекта PPObjSCard может быть дорогим).
	//
	double GetBonusAmount(PPObjSCard * pScObj) const;
	double GetTotal() const;
private:
	int    Implement_Set(int type, double amt, int32 addedID, int replace, int dontRemove);
	double Implement_Replace(int type, double amt, int32 addedID, int dontRemove, int r1, int r2);
};
//
// Descr: Идентификатор текстовых свойств чека, по которому хранятся текстовые расширения строк чека.
// <101>......<202>......<1001>.....<1003>..<1302>
// 1-я строка 2-я строка 10-я строка        13-я строка
// Значение, деленное на 100 - номер свойства строки
//
#define PPTRPROP_CC_LNEXT (PPTRPROP_USER+1)

class CCheckPacket : public PPExtStrContainer {
public:
	struct LineExt { // @transient
		enum {
			fGroup         = 0x01,
			fModifier      = 0x02,
			fPartOfComplex = 0x04, // @v7.4.5
			fQuotedByGift  = 0x08, // @v7.4.10
			fFixedPrice    = 0x10  // @v8.6.12
		};
		LineExt();
		int    IsEmpty() const;

		uint   ItemIdx;    // Индекс позиции (+1) в Items_
		int8   Queue;
		uint8  Flags;      // @flags
		uint8  Reserve[2]; // @alignment
	};
	//
	//
	//
	enum {
		extssMemo     = 1, // @reserved Примечание
		extssSign     = 2, // Строка подписи чека (ЕГАИС)
		extssEgaisUrl = 3  // @v9.1.7 Текст URL информации о чеке ЕГАИС
	};
	//
	// Descr: Идентификаторы текстовых расширений строк чека
	//
	enum {
		lnextSerial    = 1, // Серийный номер
		lnextEgaisMark = 2  // Марка ЕГАИС
	};
	//
	// Двум следующим классам необходим открытый доступ к полям Items_ и SerialList
	// для сериализации объекта CCheckPacket
	//
	friend class CCheckCore;
	friend class CSessTransmitPacket;
	//
	DECL_INVARIANT_C();
	//
	// Descr: Функция, обеспечивающая централизованный механиз распаковки текстовых расширений строк чека.
	//
	static int SLAPI Helper_UnpackLineTextExt(const SString & rBuf, StrAssocArray & rList);
	static int SLAPI Helper_SetLineTextExt(int pos /* 1.. */, int lnextId, StrAssocArray & rList, const char * pText);
	static int SLAPI Helper_GetLineTextExt(int pos /* 1.. */, int lnextId, const StrAssocArray & rList, SString & rBuf);

	SLAPI  CCheckPacket();
	SLAPI ~CCheckPacket();
	void   SLAPI Init();
	int    SLAPI IsEqual(const CCheckPacket & rS, long options) const;
	//
	// Descr: Возвращает !0 если есть не пустые поля расширения чека (Ext).
	//
	int    SLAPI HasExt() const;
	uint   SLAPI GetCount() const;
	const  CCheckLineTbl::Rec & FASTCALL GetLine(uint pos) const;
	int    SLAPI EnumLines(uint * pPos, CCheckLineTbl::Rec * pItem, SString * pSerial = 0) const;
	int    SLAPI EnumLines(uint * pPos, CCheckItem * pItem) const;
	int    SLAPI InitLineIteration();
	int    SLAPI NextLineIteration(CCheckLineTbl::Rec * pItem, SString * pSerial = 0);
	int    SLAPI RemoveLine_(uint pos);
	int    SLAPI CopyLines(const CCheckPacket & rS);
	int    SLAPI SearchLine(int rByCheck, uint * pPos) const;
	int    SLAPI SetLineTextExt(int pos /* 1.. */, int lnextId, const char *); // @v9.0.9
	int    SLAPI GetLineTextExt(int pos /* 1.. */, int lnextId, SString & rBuf) const; // @v9.0.9
	// @v9.0.9 int    SLAPI SetSerial(int pos /* 1.. */, const char *);
	// @v9.0.9 int    SLAPI GetSerial(int pos /* 1.. */, SString & rBuf) const;
	int    SLAPI SetLineExt(int pos /* 1.. */, const LineExt & pExt);
	int    SLAPI GetLineExt(int pos /* 1.. */, LineExt & rExt) const;
	//
	// Descr: Объединяет позиции, у которых одинаковые идентификаторы товаров
	// Note: В дальнейшем критерии объединения будут усложнены.
	//
	int    SLAPI MergeLines(long /*options*/);
	int    SLAPI ClearLines();
	int    SLAPI InsertItem_(const CCheckLineTbl::Rec *, const char * pSerial = 0, const char * pEgaisMark = 0);
	int    SLAPI InsertItem(PPID goodsID, double qtty, double price, double dscnt, short div = 0, int isPrinted = 0);
	int    SLAPI InsertItem(const CCheckItem & rItem);

	double FASTCALL GetItemAmount(const CCheckLineTbl::Rec & rItem) const;
	double FASTCALL GetItemDiscount(const CCheckLineTbl::Rec & rItem) const;

	int    SLAPI SetupPaymList(const CcAmountList * pList);
	//
	// Descr: Флаги функции SetTotalDiscount
	//
	enum {
		stdfPctDis      = 0x0001, // Параметр dis задает размер скидки в процентах. Иначе - абсолютное значение.
		stdfPlus        = 0x0002  // Скидка увеличивает сумму чека
	};
	int    SLAPI SetTotalDiscount(double dis, long flags);
	int    SLAPI CalcAmount(double * pAmt, double * pDscnt) const;
	//
	// Descr: Расчитывает суммы чека по строкам и устанавливает их в поля Rec.Amount
	//   и Rec.Discount.
	//   Если вызывающая функция нуждается в значениях рассчитанных сумм, то она
	//   может передать указатели pAmt и (или) pDscnt.
	//
	int    SLAPI SetupAmount(double * pAmt, double * pDscnt);
	double SLAPI GetFiscalAmount() const;
	int    SLAPI HasNonFiscalAmount(double * pFiscal, double * pNonFiscal) const;

	int    SLAPI SetDlvrAddr(const LocationTbl::Rec * pRec);
	const  LocationTbl::Rec * SLAPI GetDlvrAddr() const;

	struct BarcodeIdentStruc {
		int    Prefix;
		long   PosId;
		long   CcCode;
	};

	SString & SLAPI MakeBarcodeIdent(SString & rBuf) const;
	static int SLAPI ParseBarcodeIdent(const char * pIdent, BarcodeIdentStruc * pResult);

	CcAmountList & AL()
	{
		return CcAl;
	}
	const CcAmountList & AL_Const() const
	{
		return CcAl;
	}

	enum {
		ufCheckInvariant = 0x0001, // Функция CCheckCore::TurnCheck не допускает проведение пакета,
			// если он не проходит тест CCheckPacket::InvariantC.
			// @v8.4.2 Начиная с релиза 8.4.2 блокировка на проведение чека снимается, но в журнале pperror.log
			// отмечается информация об ошибке в чеке.
		ufSkipUhtt       = 0x0002  // Функция CCheckCore::TurnCheck не проводит операции по картам через сервер Universe-HTT
	};
	long   UpdFlags;       // @transient @v7.0.0 Флаги, определяющие правила изменения пакета
	int    PctDis;         // @transient if !0 - then Discount in percent
	double Discount;       // @transient
	double _Cash;          // @transient Сумма, уплаченная наличными
	double _OrdPrepay;     // @transient @!CheckPaneDialog::GetCheckInfo() Сумма предоплаты по заказу.
		// Заполняется для чека заказа и для чека, связанного с заказом.
	CCheckExtTbl::Rec Ext; // @transient Расширение записи чека
	CCheckTbl::Rec Rec;    //
	SString UhttScHash;    // @transient @v7.4.10 Код доступа к информации о карте, синхронизированной с Universe-HTT
private:
	int    SLAPI PackLineTextExt(SString & rResult) const;
	int    SLAPI UnpackLineTextExt(const SString & rBuf);
	// @v9.0.11 int    SLAPI PrepareForWriting(PPID ccheckID, int16 lastRbc);

	CCheckLineArray Items_; //
	TSArray <LineExt> ExtList;
	CcAmountList CcAl;      // @v7.6.1 Список оплат по чеку. Используется только, если по чеку было более
		// одного типа оплаты. Например: безналичная оплата + доплата наличными.
	//
	// Серийные номера храняться в виде ассоциаций {position, serial}.
	// position - позиция соответствующей строки в Items_ плюс 1.
	// То есть, серия для первой строки (индекс 0) хранится с номером 1.
	//
	StrAssocArray LnTextList;
	LocationTbl::Rec * P_DlvrAddr; // @transient
};
//
// Классы, управляющие кассовыми чеками
//

//
// Флаги записей CCheckTbl
//
#define CCHKF_PREPRINT     0x00000001L // По чеку распечатан счет
#define CCHKF_ORDER        0x00000002L // Чек заказа стола
#define CCHKF_CLOSEDORDER  0x00000004L // Закрытый заказ стола (на этот чек заказа есть как минимум одна ссылка от чека продажи).
#define CCHKF_ADDINCORPCRD 0x00000008L // В оплату чека включена дополнительная кредитная карта.
	// ИД этой карты хранится в поле CCheckExtTbl::AddCrdCardID, а сумма, списываемая с нее - в поле CCheckExtTbl::AddCrdCardPaym.
	// Доп кредитная карта никогда не применяется для начисления на нее денег.
#define CCHKF_DELIVERY     0x00000010L // @v7.0.7 Чек с опцией доставки (в расширении может быть введен адрес и указано время доставки)
#define CCHKF_BONUSCARD    0x00000020L // @v7.4.3 Чек проведен по бонусной карте. Этот флаг (кроме всего прочего) влияет на интерпретацию сумм оплаты.
#define CCHKF_PAYMLIST     0x00000040L // @v7.6.1 Чек имеет список оплат.
	// Если этот флаг установлен, флаги CCHKF_BANKING, CCHKF_ADDPAYM, CCHKF_ADDINCORPCRD и поля CCheckExt::AddPaym, CCheckExt::AddCrdCardID, CCheckExt::AddCrdCardPaym
	// утрачивают смысл (не принимаются в рассмотрение).
#define CCHKF_TEMPREPLACE  0x00000080L // @v7.7.11 Пометка временного чека, который должен заместить чек с таким же номером в кассовой сессии
#define CCHKF_IMPORTED     0x00000100L // @v8.4.8 Обозначает синхронный чек, импортированный из внешней системы
#define CCHKF_FIXEDPRICE   0x00000200L // @v8.7.7 Цены по строкам чека зафиксированы. Если этот флаг не установлен,
	// то строка чека все равно может иметь зафиксированную цену, если в ней установлен флаг CCheckPacket::LineExt::fFixedPrice
#define CCHKF_ABSTRACTSALE 0x00000400L // @v9.5.10 Абстрактный товар (продажа по цене)
#define CCHKF_ALTREG       0x00000800L // @v9.6.11 Чек отпечатан на альтернативном регистраторе
// @v9.7.5 #define CCHKF_NOTICE       0x00001000L // @v9.0.1 Специальный вид чека, используемый только для пометки некоторого события с одним или
	// несколькими товарами. Чек с таким флагом автоматически получает флаги CCHKF_SKIP, CCHKF_SUSPENDED
#define CCHKF_SPFINISHED   0x00001000L // @v9.7.5 Специальный признак окончательного финиширования чека. Применяется, например,
	// для пометки факта доставки и(или) окончательной оплаты по чеку со стороны покупателя.
	// @v9.7.8 @fix 0x00000800L-->0x00001000L
#define CCHKF_SYNC         0x00010000L // Чек сформирован синхронной сессией
#define CCHKF_NOTUSED      0x00020000L // Чек не просуммирован в таблице CGoodsLine
#define CCHKF_PRINTED      0x00040000L // Чек был отпечатан (пробит на ККМ)
#define CCHKF_RETURN       0x00080000L // Чек возврата
#define CCHKF_ZCHECK       0x00100000L // Чек Z-отчета (для некоторых кассовых аппаратов)
#define CCHKF_TEMPSESS     0x00200000L // @transient Чек создан по временной сессии
#define CCHKF_TRANSMIT     0x00400000L // @transient Признак перемещения чека из другого раздела БД
#define CCHKF_BANKING      0x00800000L // Чек оплачен банковской кредитной картой
#define CCHKF_INCORPCRD    0x01000000L // Чек оплачен корпоративной кредитной картой
#define CCHKF_SKIP         0x02000000L // Чек не обрабатывается процедурой списания сессии.
	// Если это чек заказа (CCHKF_ORDER) то наличие этого флага означает отмененный заказ.
#define CCHKF_SUSPENDED    0x04000000L // Отложенный чек. При установке этого флага следует установить и флаг
	// CCHKF_SKIP, при сбросе этого флага следует сбросить признак CCHKF_SKIP если нет других причин для того,
	// чтобы его оставить.
#define CCHKF_EXT          0x08000000L // Для чека есть запись расширения //
#define CCHKF_JUNK         0x10000000L // Отложенный чек, который загружен в чековую панель. Чек с этим
	// признаком не должен загружаться в чековую панель (нарушение синхронизации). При повторном акцепте
	// отложенного чека, соответствующий ему JUNK-чек удаляется.
#define CCHKF_LINEEXT      0x20000000L // По крайней мере одна строка чека имеет расширение в таблице CCheckLineExt
#define CCHKF_ADDPAYM      0x40000000L // Чек имеет ненулевую сумму доплаты в расширении записи чека CCheckExt
	// Вспомогательный флаг, используемый для быстрого определения (не обращаясь к доп записи) есть ли у чека сумма доплаты.
#define CCHKF_HASGIFT      0x80000000L // По чеку был предоставлен подарок  (не уточняется какой именно)
//
struct CCheckGoodsEntry {  // size=32
	enum {
		fAdj = 0x0001 // Элемент использован для выравнивания суммы агрегации с суммой по чекам
	};
	LDATE  Dt;
	int16  Sign;           // @#{-1;+1}
	int16  Flags;          //
	PPID   GoodsID;        //
	PPID   SerialID;       // Идентификатор серийного номера
	double Qtty;
	double Sum;
};

class CCheckGoodsArray : public TSArray <CCheckGoodsEntry> {
public:
	SLAPI  CCheckGoodsArray();
	int    SLAPI Add(LDATE dt, const CCheckLineTbl::Rec *, PPID serialID = 0);
	int    SLAPI GetMaxDate(LDATE * pDt) const;
	int    SLAPI AdjustToSess(double sessAmount);
private:
	double Sum;
};

struct DraftRcptItem {
	PPID   GoodsID;
	PPID   LocID;
	double Qtty;
};

typedef TSArray <DraftRcptItem> DraftRcptArray;

DECL_CMPFUNC(DraftRcptItem);
//
// Descr: Дескриптор статуса стола кафе.
//
struct CTableStatus {
	CTableStatus(const CCheckViewItem * pCcItem = 0);
	int    Displace(const CTableStatus & rNewItem);
	enum {
		sUnkn = 0,  // Не удалось определить статус стола
		sFree = 1,  // Стол свободен
		sBusy,      // Стол занят
		sOnPayment, // Стол занят, но по чеку распечатан счет
		sOrder      // Стол заказан
	};
	long   TableNo;
	int    Status;
	PPID   CheckID;
	LDATETIME CheckDtm;
	STimeChunk OrderTime;
};

//
class CCheckCore : public CCheckTbl {
public:
	static SString & SLAPI MakeCodeString(const CCheckTbl::Rec *, SString &);
	static int SLAPI FetchCTableStatus(long tableNo, CTableStatus * pStatus);
	static int SLAPI FetchCTableOrderList(TSArray <CTableStatus> & rList);
	static int SLAPI RecognizeOrdBarcode(const char * pCode, PPID * pOrdCheckID);
	static int SLAPI Helper_GetPaymList(CCheckPaymTbl * pCpTbl, PPID id, CcAmountList & rList);
	static int FASTCALL IsExtRecEq(const CCheckExtTbl::Rec & r1, const CCheckExtTbl::Rec & r2);

	SLAPI  CCheckCore();
	SLAPI ~CCheckCore();
	int    SLAPI Search(PPID, CCheckTbl::Rec * pRec = 0);
	int    SLAPI Search(PPID cashID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    SLAPI SearchByTimeAndCard(PPID cardID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    SLAPI SearchByDateAndCode(long code, LDATE dt, SArray * pChkList);
	int    SLAPI SearchForwardZCheck(PPID cashID, LDATE, LTIME, CCheckTbl::Rec * pRec = 0);
	int    SLAPI GetExt(PPID id, CCheckExtTbl::Rec * pExt);
	int    SLAPI GetPaymList(PPID id, CcAmountList & rList);
	int    SLAPI GetListByExtFilt(const CCheckFilt & rFlt, ObjIdListFilt & rList);
	int    SLAPI GetListByCode(long cashN, long code, TSArray <CCheckTbl::Rec> * pRecList);
	//
	// Descr: Возвращает список идентификаторов чеков, обслуживающих чек заказа orderCheckID.
	// Note: В подавляющем большинстве случаев список  будет либо пустым, либо будет содержать
	//   только один элемент.
	// Returns:
	//   >0 - чек заказа обслужен по крайней мере одним чеком.
	//   <0 - заказ не обслуживался.
	//   0  - ошибка
	//
	int    SLAPI GetOrderServersCheckList(PPID orderCheckID, PPIDArray & rList);
	//
	// Descr: Проверяет правильность чека.
	// ARG(id        IN): Идентификатор чека
	// ARG(tolerance IN): Максимальное допустимое различие между суммой чека и суммами по строкам
	//   (суммой скидки и суммами скидки по строкам), при превышении которого функция рапортует об ошибке.
	// ARG(rLogger   IN): Журнал вывода сообщений об ошибках.
	// Returns:
	//   !0 - ошибок в чеке не обнаружено.
	//    0 - чек содержит по крайней мере одну ошибку.
	//
	int    ValidateCheck(PPID id, double tolerance, PPLogger & rLogger);
	//
	// Descr: Возвращает ИД кассового узла, которому принадлежит чек checkID.
	//   Так как непосредственно чек на кассовый узел (в общем случае) не ссылается,
	//   то процесс состоит в следующем: функция извлекает чек с ИД = checkID,
	//   далее, извлекается кассовая сессия, которой принадлежит этот чек, и, наконец,
	//   из записи кассовой сессии извлекается ИД кассового узла.
	// Attension:
	//   Функция создает экземпляр PPObjCSession. Если вверху по стеку не было создано
	//   экземпляра этого объекта, то функция будет потреблять неадекватно много времени.
	// Returns:
	//   >0 - кассовый узел, которому принадлежит чек успешно определен.
	//   <0 - либо чек, либо сессия, которой он принадлежит не найдены.
	//   0  - ошибка
	//
	int    SLAPI GetNodeID(PPID checkID, PPID * pNodeID);
	int    SLAPI LineByCheck(PPID, int16 *);
	int    SLAPI EnumLines(PPID, int *, CCheckLineTbl::Rec * = 0);
	int    SLAPI RemoveZeroLinkLines(int use_ta);
	//
	// Descr: Загружает строки чека checkID в массив pList. Если параметр goodsID != 0,
	//   то загружает только строки, ссылающиеся на товар goodsID.
	// Note: Не очищает массив строк чека перед загрузкой.
	//
	int    SLAPI LoadLines(PPID checkID, PPID goodsID, CCheckPacket * pPack);
	int    SLAPI LoadChecksByList(const ObjIdListFilt * pSessList, const PPIDArray * pCashIDList, ObjIdListFilt * pCheckList, LDATETIME * pLastCheckDt);
	int    SLAPI LoadLinesByList(PPID goodsID, const ObjIdListFilt * pCheckList, CCheckLineArray * pLinesList);
	//
	// Descr: Вызывает сначала LoadChecksByList, а уже затем LoadLinesByList
	//
	int    SLAPI LoadLinesBySessList(PPID goodsID, const PPIDArray * pSessList, const PPIDArray * pCashList, CCheckLineArray * pLinesList, LDATETIME * pLastCheckDt);
	int    SLAPI GetLastCheck(PPID sessID, long cashN, CCheckTbl::Rec *);
	int    SLAPI GetLastCheckByCode(long cashN, CCheckTbl::Rec * pRec);
	int    SLAPI Add(PPID * pID, const CCheckTbl::Rec * pRec, int use_ta);
	//
	// Descr: Кассовые чеки нельзя править. Их можно только добавлять
	//   или, в крайнем случае, удалять.
	//
	int    SLAPI TurnCheck(CCheckPacket * pPack, int use_ta);
	int    SLAPI UpdateCheck(CCheckPacket * pPack, int use_ta);
	//
	// Descr: Опции функции TurnSCardPayment
	//
	enum {
		tscpfSkipUhtt   = 0x0001, // Не проводить операции с картами Universe-HTT
		tscpfCorrection = 0x0002  // Специальный флаг обозначающий вызов функции с целью корректировки
	};
	//
	// Descr: Функция проведения платежей по чеку кредитными картами.
	//   Используется в составе функции TurnCheck и для аварийных целей.
	//
	int    SLAPI TurnSCardPayment(CCheckPacket * pPack, long flags, int use_ta);
	int    SLAPI RemovePacket(PPID, int use_ta);
	//
	// Descr: Опции функции CCheckCore::LoadPacket
	//
	enum {
		lpfNoLines     = 0x0001 // Не загружать строки чека
	};
	//
	// Descr: Загружает из базы данных пакет чека
	//
	int    SLAPI LoadPacket(PPID id, long flags, CCheckPacket *);
	int    SLAPI GetLineExt(PPID checkID, int rByCheck, CCheckLineExtTbl::Rec * pRec);
	//
	// Descr: Флаги функций GroupingToGoodsLines(), GetSessTotal(), GetListBySess().
	//
	enum {
		gglfUpdChecks           = 0x0001, // Снять признак CCHKF_NOTUSED после группировки
		gglfSkipUnprintedChecks = 0x0002, // Пропускать чеки без флага CCHKF_PRINTED
		gglfUseFullCcPackets    = 0x0004  // @v7.5.8
	};
	int    SLAPI GetSessTotal(PPID sessID, long flags, CSessTotal *, BVATAccmArray * pVatList);
	int    SLAPI GroupingToGoodsLines(PPID sessID, CSessTotal *, CCheckGoodsArray *, long flags, int use_ta);
	int    SLAPI GetListBySess(PPID sessID, long flags, PPIDArray & rList);
	int    SLAPI RemoveSess(PPID sessID, int use_ta);
	//
	// Descr: Изменяет значение поля Flags записи с идентификатором checkID.
	//   Не проверяет права доступа (это обязана сделать вызывающая функция, если
	//   она находится на уровне слоя PPObject или выше).
	//
	int    SLAPI UpdateFlags(PPID checkID, long flags, int use_ta);
	//
	// Descr: Изменяет некоторые параметры чека. Функция должна вызываться с максимальной отсорожностью.
	//
	int    SLAPI UpdateRec(PPID checkID, const CCheckTbl::Rec * pRec, int use_ta);
	//
	// Descr: Изменяет запись расширения чека. Изменены могут быть только следующие поля:
	//     TableNo, CreationDtm, StartOrdDtm, EndOrdDtm, Memo, GuestCount.
	//     Если переданная параметром pExt запись не содержит изменений в перечисленных
	//     полях, то изменение в базе данных не фиксируется.
	// Returns:
	//     >0 - запись изменена.
	//     <0 - запись не изменена либо по тому, что конфигруация не предусматривает
	//        расширений чеков, либо по тому, что ни одно из полей, которое можно
	//        изменить в базе данных не отличается от тех, что в записи, переданной
	//        параметром pExt.
	//     0  - ошибка.
	//
	int    SLAPI UpdateExt(PPID id, CCheckExtTbl::Rec * pExt, int use_ta);
	int    SLAPI PutExt(CCheckTbl::Rec * pRec, CCheckExtTbl::Rec * pExt, int useTa);
	//
	// Descr: Изменяет значение поля SCardID записи с идентификатором checkID.
	//   Не проверяет права доступа (это обязана сделать вызывающая функция, если
	//   она находится на уровне слоя PPObject или выше).
	//
	int    SLAPI UpdateSCard(PPID checkID, PPID newSCardID, int use_ta);
	//
	// Descr: Изменяет признак закрытой доставки по чеку.
	//
	int    SLAPI ToggleDeliveryCloseTag(PPID checkID, const LDATETIME & rDtm, int set, int use_ta);
	//
	// Descr: заменяет ссылки на карты destCardID на ссылки на карты srcCardID.
	//
	int    SLAPI ReplaceSCard(PPID destCardID, PPID srcCardID, int use_ta);
	int    SLAPI GetTrnovrBySCard(PPID cardID, int alg /*PPObjSCard::gtalgXXX*/, const DateRange * pPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	int    SLAPI CreateSCardsTurnoverList(const DateRange *, RAssocArray *);
	int    SLAPI GetListByCard(PPID cardID, const LDATETIME * pMoment, PPIDArray * pList);
	int    SLAPI RecalcSCardsTurnover(int use_ta);
	int    SLAPI UpdateSCardOpsBySess(PPID sessID, int use_ta);
	int    SLAPI SetFlagsBySess(PPID sessID, long setFlags, long resetFlags, int use_ta);
	int    SLAPI IsCheckWFlags(PPID sessID, long chkFlags);
	//
	// Descr: Утилитная функция, позволяющая (с некоторой вероятностью) определить
	//   используются ли в базе данных записи расширения чеков. Если установлен флаг
	//   (CConfig.Flags & CCFLG_USECCHECKEXT) и таблица CCheckExt содержит более 10 записей,
	//   то функция возвращает 1, иначе - 0.
	//
	int    SLAPI HasExt();
	int    SLAPI CalcActiveExpendByGoods(PPID goodsID, PPID locID, const char * pSerial, double * pResult);
	int    SLAPI GetActiveExpendByLocList(const ObjIdListFilt * pLocList, DraftRcptArray * pList);
	//
	// Descr: Рассчитывает остаток товара goodsID на дату dt по складу locID.
	//   Расчет осуществляется следующим образом: извлекается остаток по учетным
	//   товарным операциям (Transfer::GetRest) и из него вычитается количество,
	//   проданное по всем активным синхронным кассовым сессиям, принадлежащим складу locID
	//   (CCheckCore::CalcActiveExpendByGoods).
	//
	int    SLAPI CalcGoodsRest(PPID goodsID, LDATE dt, PPID locID, double * pRest);
	int    SLAPI AddRecToSessTotal(const CCheckTbl::Rec * pRec, CSessTotal * pTotal);
	//
	// Descr: Функция выясняет принадлежал ли чек с признаком CCHKF_JUNK потерянной сессии.
	// Note: Фактически, чек id может принадлежать сессии, которая еще работает на данном компьютере под
	//   текущей системной учетной записью.
	//
	int    SLAPI IsLostJunkCheck(PPID id, S_GUID * pExtUuid, PPSession::RegSessData * pSessData);
	//
	// Descr: Типы сообщений, записываемых в файл журнала ccheck.log
	//   в отладочном режиме (CConfig.Flags & CCFLG_DEBUG)
	//
	enum { // @persistent
		logPrinted      = 0,  // Чек отпечатан
		logWrited       = 1,  // Чек записан в БД
		logRestored     = 2,  // Отложенный чек восстановлен из БД
		logRemoved      = 3,  // Чек удален из БД
		logCleared      = 4,  // Чек очищен в чековой панели
		logSuspended    = 5,  // Чек отложен
		logRowCleared   = 6,  // Строка чека удалена в чековой панели
		logRowDiscount  = 7,  // Скидка на строку чека
		logAgentChanged = 8,  // @v8.2.1 Изменен текущий агент в чеке
		logJunkRemoved  = 9   // @v8.2.1 Junk-чек удален из БД
	};

	int    SLAPI SerializePacket(int dir, CCheckPacket * pPack, SBuffer & rBuf, SSerializeContext * pCtx);
	void   SLAPI WriteCCheckLogFile(const CCheckPacket * pPack, const CCheckLineTbl::Rec * pLineRec, int action /* CCheckCore::logXXX */, int use_ta);
	void   SLAPI WriteCCheckLogFile(const CCheckTbl::Rec * pRec, int action /* CCheckCore::logXXX */, int use_ta);
	//
	//
	//
	int    SLAPI CorrectCCLineProblem01();

	CCheckLineTbl Lines;
	CCheckPaymTbl PaymT;    // @v7.6.1 Таблица платежей по чекам
	SCardCore     Cards;
	CCheckLineExtTbl * P_LnExt; // Таблица расширения строк чеков private->public
private:
	int    SLAPI Helper_TurnSCardPayment(CCheckPacket * pPack, long flags, double * pUfpFactor, double * pUfpFactorUhtt, int use_ta);
	int    SLAPI PreprocessPacket(CCheckPacket * pPack);
	int    SLAPI PreparePacketForWriting(PPID id, CCheckPacket * pPack, double & rUfpFactor);
	int    SLAPI Update(PPID id, const CCheckTbl::Rec * pRec, int use_ta);

	CCheckExtTbl * P_Ext;
	CheckOpJrnl * P_ChkOpJrnl;
};
//
// Descr: Вспомогательная структура, используемая для быстрого извлечения и
//   анализа дефицита по кассовым сессиям
//
struct CSessDfctItem {
	PPID   GoodsID;      // Товар, по которому возник дефицит
	PPID   SessID;       // Кассовая сессия, в которой возник дефицит
	LDATE  Dt;           // Дата возникновения дефицита
	double Qtty;         // Проданное количество товара GoodsID
	double Dfct;         // Количество не списанное из-за дефицита
	double Sum;          // Сумма продажи товара (для количества Qtty)
	PPID   AltGoodsID;   // Альтернативный товар
	double AltGoodsQtty; // Количество списанное по альтернативному товару
};

class CSessDfctList : public TSArray <CSessDfctItem> {
public:
	enum {
		uniteNone = 0,
		uniteByGoods,
		uniteByDateGoods
	};
	SLAPI  CSessDfctList();
	int    SLAPI Add(const CSessDfctItem *, int unite);
	int    SLAPI SearchByDateGoods(LDATE dt, PPID goodsID, uint * pPos, CSessDfctItem *) const;
private:
	int    SLAPI Search(const CSessDfctItem *, int unite, uint * pPos) const;
};
//
//
//
struct CSessDfctGoodsItem {
	double SLAPI GetPrice() const;
	PPID   GoodsID;
	double Qtty;
	double Sum;
};

class CSessDfctGoodsList : public TSArray <CSessDfctGoodsItem> {
public:
	int    SLAPI Search(PPID goodsID, CSessDfctGoodsItem * pItem);
	int    SLAPI Add(const CSessDfctGoodsItem * pItem);
};
//
//
//
#define CGOODSLINESIGN_ALTGOODSREC 100 // Если в поле Sign данное значение,
	// то эта запись соответствия дефицитный товар/альтернативный товар

class CGoodsLine : public CGoodsLineTbl {
public:
	SLAPI  CGoodsLine(char * pFileName = 0);
	int    SLAPI Add(PPID sessID, const CCheckGoodsArray * pList, int use_ta);
	int    SLAPI Update(CGoodsLineTbl::Rec * pRec, int use_ta);
	int    SLAPI UndoWritingOff(PPID);                       // Without transaction
	int    SLAPI RemoveSess(PPID sessID);                    // Without transaction
	int    SLAPI HasAnyLineForSess(PPID sessID);
	int    SLAPI CalcSessTotal(PPID sessID, CSessTotal *);
	int    SLAPI GetDfctList(int sign, PPID sessID, PPID goodsID, const DateRange *, int unite,
		CSessDfctList *, PPIDArray * pDateList);
	int   SLAPI  GetDfctGoodsList(int sign, PPID sessID,
		const DateRange * pPeriod, CSessDfctGoodsList * pList);
	int   SLAPI  GetDfctSubstList(PPID sessID, LAssocArray * pList);
	int   SLAPI  SetDfctSubstList(PPID sessID, const LAssocArray * pList, int use_ta);
private:
	int    SLAPI Search_ForUpdate(PPID sessID, LDATE dt, PPID goodsID, int sign, PPID serialID, CGoodsLineTbl::Rec * pRec);
};
//
// Descr: Класс, реализующий группировку строк кассовых чеков для сохранения в
//  таблице CGoodsLine и конвертации этой группировки в товарные документы
//
class CSessGrouping {
public:
	SLAPI  CSessGrouping();
	int    SLAPI GetSess(PPID sessID, CSessionTbl::Rec * pRec);
	int    SLAPI Grouping(PPID sessID, CSessTotal * pTotal, const LAssocArray * pSubstList, int use_ta);
	int    SLAPI UndoGrouping(PPID sessID, LAssocArray * pSubstList, int use_ta);
	int    SLAPI ConvertToBills(PPID sessID, PPID locID, const char * pMsg, uint sessNo, uint sessCount, int use_ta);
	int    SLAPI ConvertTempSessToBills(const PPIDArray * pSessList, PPID locID, PPID * pBillID, int use_ta);
	int    SLAPI AttachSessToSupersess(PPID nodeID, PPID sessID, PPID * pSuperSessID, int use_ta);
	int    SLAPI CompleteSession(PPID sessID);
	int    SLAPI ConvertSessListToBills(const PPIDArray * pSessList, PPID locID, int use_ta);
	int    SLAPI GroupingSessList(PPID nodeID, const PPIDArray * pList, PPIDArray * pOutList, PPIDArray * pOutTempList, int use_ta);
	//
	// Descr: Реализует удаление или откат списания по кассовой сессии sessID.
	//   уровень отката определяется параметром grade.
	// ARG(sessID IN): Идентификатор кассовой сессии, которая должна быть удалена
	// ARG(grade  IN):
	//   CSESSINCMPL_GLINES   - Undo writing off
	//   CSESSINCMPL_CHECKS   - Nothing
	//   CSESSINCMPL_COMPLETE - Totaly removes session with checks and write off bills
	//
	int    SLAPI RemoveSession(PPID sessID, int grade);
protected:
	CSessionCore CS;
	CCheckCore   CC;
	CGoodsLine   GL;
	PPEquipConfig EqCfg;
private:
	int    SLAPI TurnBill(PPBillPacket * pPack, CSessTotal * pTotal, int isRet, OptimalAmountDamper * pOad);
	int    SLAPI ConvertSign(const int sign, const PPID sessID, const PPID locID, void * pData, CSessTotal * pTotal, OptimalAmountDamper * pOad);
	int    SLAPI Convert(PPID sessID, PPID locID, void * pData, CSessTotal * pTotal, int use_ta);
	int    SLAPI ConvertDeficit(PPID sessID, PPID locID, CSessTotal * pTotal);

	int    ComplDfct;
	int    IgnGenGoods;
	PPID   SellOpID;
	PPID   RetOpID;
	PPLogger Logger;
	SString WMsg;
};
//
// Класс генерации соответствий {id, string} для подстановки в запросы DBQuery
//
#if 0 // @snippet {
void foo()
{
	// Массив содержит 5 элементов
	static DbqStringSubst subst(5); // @global @threadsafe
	XTbl * t = new XTbl;
	DBE * dbe = 0;
	// PPTXT_XXX - ид строки (PPSTR_TEXT) формата "1,string 1;2,string 2;3,string 3"
	dbe = & enumtoa(t->IntField, 5, subst.Get(PPTXT_XXX));
	q = & select(t->ID, *dbe, 0L).from(t, 0L);
	delete dbe;
}
#endif // } @snippet

class DbqStringSubst {
public:
	SLAPI  DbqStringSubst(size_t numItems);
	SLAPI ~DbqStringSubst();
	char ** FASTCALL Get(uint strID);
private:
	void   FASTCALL Init(uint strID);
	struct Subst {
		int16  Id;
		char   Str[32];
	};
	size_t NumItems;
	Subst * Items;
	Subst ** P_Items;
	int    IsInited;
};
//
// Макрос для генерации функции создания временного файла
//
#define PP_CREATE_TEMP_FILE_PROC(proc,nam)                 \
static nam##Tbl * SLAPI proc() { nam##Tbl * t = new nam##Tbl(DBTable::CrTempFileNamePtr); \
  if(t && t->IsOpened()) return t; else { delete t; t = 0; return (PPSetErrorDB(), (nam##Tbl *)0); }}

template <class T> inline T * CreateTempFile()
{
	T * t = new T(DBTable::CrTempFileNamePtr);
	if(!t || !t->IsOpened()) {
		ZDELETE(t);
		PPSetErrorDB();
	}
	return t;
}

template <class T> int SerializeDbTableByFileName(int dir, T ** ppT, SBuffer & rBuf, SSerializeContext * pCtx)
{
	int    ok = 1;
	SString temp_buf;
	if(dir > 0) {
		if((*ppT) != 0)
			temp_buf = (*ppT)->fileName;
		else
			temp_buf = 0;
		THROW_SL(pCtx->Serialize(dir, temp_buf, rBuf));
	}
	else if(dir < 0) {
		ZDELETE(*ppT);
		THROW_SL(pCtx->Serialize(-1, temp_buf, rBuf));
		if(temp_buf.NotEmptyS()) {
			THROW_MEM((*ppT) = new T(temp_buf));
		}
	}
	CATCHZOK
	return ok;
}
//
// @ModuleDecl(PPView)
//
//
// Descr: Базовый класс для контроллеров анализа данных
//
class PPView {
public:
	static int SLAPI CreateInstance(int viewID, PPView ** ppV);
	static int SLAPI CreateFiltInstance(int filtID, PPBaseFilt ** ppF);
	static int SLAPI CreateFiltInstanceBySymb(const char * pSymb, PPBaseFilt ** ppF);
	static int SLAPI WriteFiltPtr(SBuffer & rBuf, PPBaseFilt * pFilt);
	static int SLAPI ReadFiltPtr(SBuffer & rBuf, PPBaseFilt ** ppFilt);

	enum {
		exefModeless     = 0x0001,
		exefDisable3Tier = 0x0002
	};
	static int SLAPI Execute(int viewID, const PPBaseFilt * pFilt, int flags /* exefXXX */, void * extraPtr);

	static int SLAPI ExecuteServer(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int SLAPI Destroy(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int SLAPI Refresh(PPJobSrvCmd & rCmd, PPJobSrvReply & rReply);
	static int SLAPI ExecuteNF(const char * pNamedFiltSymb, const char * pDl600Name, SString & rResultFileName);

	struct Rc {
		long   Id;
		SString Symb;
		SString Descr;
	};
	//
	// Descr: Загружает из ресурсов описание объекта PPView или PPBaseFilt
	// ARG(kind  IN): 0 - PPView, 1 - PPBaseFilt
	// ARG(id    IN): Идентификатор ресурса
	// ARG(rRc  OUT): Структура дескриптора ресурса
	//
	static int SLAPI LoadResource(int kind, int id, PPView::Rc & rRc);

	SLAPI  PPView(PPObject * pObj = 0, PPBaseFilt * pFilt = 0, int viewId = 0);
	virtual SLAPI ~PPView();
	int    SLAPI IsConsistent() const;
	//
	// Descr: Создает экземпляр класса PPBaseFilt. Дополнительный параметр extraParam
	//   позволяет задать специфичную информацию для инициализации фильтра.
	//   Полученный указатель после использования должен быть разрушен вызывающей функцией
	//   обращением к "delete p_flt;"
	//
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	//
	// Descr: Инициализирует экземпляр класса в соответствии с фильром pFilt.
	//
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	virtual const IterCounter & SLAPI GetCounter() const;
	//
	// Descr: Функция вызывается из функции PPViewBrowser::execute до запуска броузера если
	//   броузер модальный, если же броузер немодальный, то функция вызывается непосредственно после
	//   запуска броузера на выполнение (при этом возвращаемое функцией значение игнорируется).
	// Returns:
	//   <0  - PPViewBrowser::execute должен реализовать свое исполнение в обычном режиме
	//   >=0 - PPViewBrowser::execute должен прекратить исполнение и вернуть это значение (ushort)
	//
	virtual int   SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int   SLAPI Browse(int modeless);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	//
	// Протокол передачи серверу задания на формирование PPView:
	// 1. Клиент передает серверу команду CREATEVIEW view_name filter (filter - в бинарном виде)
	// 2. Сервер создает экземпляр PPView и вызывает PPView::Init_(filter)
	// 3. Сервер упаковывает состояние объекта вызовом PPView::SerializeState(+1, buf, 0)
	// 4. Сервер передает клиенту состояние объекта
	// 5. Клиент получает состояние объекта PPView вызовом PPView::SerializeState(-1, buf, 0)
	// 6. Клиент отправляет серверу подтверждение акцепта состояния.
	// 7. Сервер разрушает собственный объект PPView. Если было получено подтверждение акцепта
	//    состояния клиентом, то сервер предпринимает меры для того, чтобы временные таблицы,
	//    ссылки на которые были переданы клиенту, не были бы разрушены.
	//
	virtual int   SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	const  PPBaseFilt * SLAPI GetBaseFilt() const;
	int    SLAPI GetOuterChangesStatus() const;
	//
	// Descr: Отправляет данные на экспорт в формате XML. Функция реализует тот же самый
	//   экспорт, который может быть выполнен пользователем при вызове функции печати
	//   с ручным вызовом экспорта в XML.
	// @nointeract
	//
	int    SLAPI ExportXml(uint rptId, int ord = 0);
	PPObject * GetObj() const;
	const  char * SLAPI GetSymb() const;
	const  char * SLAPI GetDescr() const;
	int    SLAPI IsCrosstab() const;
	//
	// Descr: Устанавливает заголовок отображаемой таблицы. Эта функция должна быть вызвана после метода
	//   PPView::Init_ поскольку он очищает внешний заголовок.
	//   Если внешний заголовок не определен (пустой), то порожденный класс сам устанавливает
	//   заголовок отображаемой таблицы.
	//
	void   SLAPI SetOuterTitle(const char * pOuterTitle);
	int    SLAPI GetOuterTitle(SString * pBuf) const;
private:
	uint32 Sign; // Подпись экземпляра класса. Используется для идентификации инвалидных экземпляров.
	int    ExecFlags; // @v8.3.2 Флаги, с которыми была вызвана функция PPView::Execute()
	LongArray * P_LastUpdatedObjects; // @v9.0.4 Список идентификаторов объектов, созданных, измененных
		// или удаленный при последнем вызове PPView::ProcessCommand. Необходим для того,
		// что бы порожденный класс мог отреагировать на обработку событий базовым классом.

	static int SLAPI CreateInstance(int viewID, int32 * pSrvInstId, PPView ** ppV);
	int    SLAPI Helper_Init(const PPBaseFilt * pFilt, int flags /* exefXXX */);
protected:
	static DBQuery * CrosstabDbQueryStub; // realy const (bad ptr)
	//
	// Returns:
	//   1 - функция отработала успешно
	//   100 - функция отработала успешно. В буфере  хранился пустой экземпляр DBTable:
	//     вызывающая функция должна разрушить pTbl.
	//   0 - ошибка
	//
	static int SLAPI SerializeTableSpec(int dir, DBTable * pTbl, SBuffer & rBuf, SSerializeContext * pCtx);

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	//
	// Descr: callback функция, вызываемая из функции PPView::Browse после создания //
	//   таблицы pBrw и перед ее показом. Может быть переопределена порожденным классом
	//   для добавления дополнительных столбцов или удаления ненужных, а также для других установок.
	// Returns:
	//   <0 - функция ничего не делает
	//   >0 - были сделаны какие-либо изменения в таблице pBrw
	//   0  - ошибка. В этом случае функция PPView::Browse прерывает исполнение.
	//
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw); // @<<PPView::Browse
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int32  GetServerInstId() const { return ServerInstId; }
	//
	// Descr: Вспомогательная функция, обеспечивающая верификацию и установку
	//   фильтра в функции Init_().
	// Returns:
	//   >0 - фильтр верифицирован и инициализирован
	//   0  - ошибка
	//
	int    SLAPI Helper_InitBaseFilt(const PPBaseFilt *);
	int    SLAPI DefaultCmdProcessor(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI Helper_Print(uint rptId, int ord = 0);
	int    SLAPI ChangeFilt(int refreshOnly, PPViewBrowser * pW);
	void   SLAPI SetExtToolbar(uint toolbarId);
	//
	// Descr: Изменяет данные во временной диаграмме, связанной с этим объектом.
	//   Функция должна быть вызвана при разрушении объекта, а также при существенном изменении
	//   данных, по которым строится связанная диаграмма
	// ARG(pGrid   IN): Указатель на управляющий объект временной диаграммы
	// ARG(pTitle  IN): Если !0 и !destroy, то функция установит окну диаграммы заголовок pTitle
	// ARG(destroy IN): Если !0, то диаграмма разрушается.
	// Returns:
	//   >0 - связанная диаграмма обнаружена и над ней произведены указанные действия //
	//   <0 - нет связанной диаграммы
	//
	int    SLAPI UpdateTimeBrowser(const STimeChunkGrid * pGrid, const char * pTitle, int destroy);
	int    SLAPI GetLastUpdatedObjects(long extId, LongArray & rList) const;
	void   SLAPI Helper_FormatCycle(const PPCycleFilt & rCf, const PPCycleArray & rCa, LDATE dt, char * pBuf, size_t bufLen);

	IterCounter Counter;
	BExtQuery * P_IterQuery;
	Crosstab  * P_Ct;
	enum {
		implChangeFilt                  = 0x0001, // Порожденный класс самостоятельно обрабатывает команду PPVCMD_CHANGEFILT
		implOnAddSetupPos               = 0x0002, // Базовый класс PPView должен установить позицию по новому идентификатору
			// после обработки PPVCMD_ADDITEM.
		implDontDelTempTables           = 0x0004, // Не удалять файлы временных данных
		implDontSetupCtColumnsOnChgFilt = 0x0008, // Не устанавливать кросс-таб столбцы в функции PPView::ChangeFilt
			// (порожденный класс самостоятельно сделает это функцией PreprocessBrowser).
		implBrowseArray                 = 0x0010, // Данные для броузера поcтавляются массивом SArray а не запросом DBQuery
		implUseServer                   = 0x0020, // Объект может делегировать инициализацию серверу
		implDontEditNullFilter          = 0x0040  // Если указатель на фильтр равен 0, то использовать пустой фильтр и не вызывать диалог редактирования фильтра
	};
	long   ImplementFlags;
	enum {
		bsOuterChangesStatus = 0x0001, // Реализация класса PPView может установить этот флаг, если считает,
			// что сделала изменения в данных, существенные для вызывающего метод Browse() модуля.
		bsServerInst         = 0x0002, // Экземпляр является серверным (созданным в ответ на запрос клиента).
			// Если это состояние установлено, то ServerInstId является идентификатором, с котороым
			// связан указатель в PPThreadLocalArea (PPThreadLocalArea::GetPtr)
		bsServerInstDestr    = 0x0004  // Устанавливается деструктором PPView::~PPView если
			// серверный экземпляр (если существовал) был нормально разрушен.
	};
	long   BaseState;
	long   DefReportId;         // Базовая функция Print() вызывает Helper_Print(DefReportId, 0)
		// если это поле не нулевое. Таким образом, если реализация Print() в унаследованном классе
		// сводится только к такому вызову, этому классу достаточно в конструкторе инициализировать
		// поле DefReportId и не реализовывать Print().
		// В более сложных случаях придется самостоятельно определять этот метод.
private:
	uint   ExtToolbarId; // Идентификатор тулбара, который следует загрузить в броузер
		// при выполнении функции Browse
	int32  ViewId;       // Идентификатор объекта (PPVIEW_XXX)
	int32  ServerInstId; // Идентификатор серверного экземпляра объекта.
	SString Symb;        // @*PPView::CreateInstance Строка символа объекта (например Processor для PPViewProcessor)
	SString Descr;       // @*PPView::CreateInstance Строка описания объекта
	SString OuterTitle;  // @*PPView::Init_, PPView::SetOuterTitle
	PPBaseFilt * P_F;    // not owned by base class
	PPObject * P_Obj;    // not owned by base class
};
//
// RegisterFilt
//
struct RegisterFilt : public PPBaseFilt {
	SLAPI  RegisterFilt();
    virtual int SLAPI IsEmpty() const;

	uint8  ReserveStart[20]; // @anchor
	PPObjID Oid;             // @v9.0.4
	PPID   ExclLocID;        // @v8.3.6
	PPID   ExclPersonID;
	PPID   RegTypeID;
	DateRange RegPeriod;
	DateRange ExpiryPeriod;
	SString SerPattern;      // @anchor
	SString NmbPattern;
};
//
// @ModuleDecl(PPCommand)
//
typedef int (*CmdItemIterFunc)(const PPCommandItem *, long parentID, void * extraPtr);

struct PPCommandDescr {
	enum {
		fNoParam = 0x0001 // Команда не имеет параметров
	};
	static const char * P_FactoryPrfx;

	static int   SLAPI GetResourceList(int loadText, StrAssocArray * pList);
	static int   SLAPI GetResourceList(LAssocArray * pList);

	SLAPI  PPCommandDescr();
	void   SLAPI Init();
	int    SLAPI LoadResource(long cmdDescrID);
	int    SLAPI GetFactoryFuncName(SString &) const;
	int    SLAPI Write(SBuffer &, long) const;
	int    SLAPI Read(SBuffer &, long);
	PPCommandHandler * SLAPI CreateInstance(long cmdDescrID);
	int    SLAPI DoCommand(PPCommand * pCmd, long extra);
	int    SLAPI DoCommandSimple(PPID cmdDescrID, int allowEditParam, const char * pTextFilt, long extra);
	int    SLAPI EditCommandParam(PPID cmdDescrID, long cmdID, SBuffer * pParam, long extra);

	long   CmdID;
	long   Flags;
	long   MenuCm;
	long   IconId;
	long   ToolbarId;
	long   ViewId;         //
	long   FiltId;         //
	long   FiltExtId;      //
	long   Reserve;        // @reserve
	SString Symb;
	SString Text;
};

class PPCommandItem {
public:
	enum {
		kCommand   = 1,
		kFolder    = 2,
		kGroup     = 3,
		kSeparator = 4
	};
	enum {
		fBkgndGradient    = 0x0001,
		fNotUseDefDesktop = 0x0002,
		fAllowEditFilt    = 0x0004, // При вызове команды по иконке пользователю будет
			// предлагаться изменить фильтр.
		fBkgndImage       = 0x0008, // @v8.1.6 "лемент имеет привязанный файл изображения. Только для kGroup //
		fBkgndImageLoaded = 0x0010  // @v8.1.6 @transient Признак того, что при загрузке из хранилища объект содержал изображение. Только для kGroup //
	};
	SLAPI  PPCommandItem(int kind = kSeparator);
	virtual SLAPI ~PPCommandItem();
	virtual int SLAPI Write(SBuffer &, long) const;
	virtual int SLAPI Read(SBuffer &, long);
	virtual const PPCommandItem * SLAPI Next(uint * pPos) const;
	virtual PPCommandItem * SLAPI Dup() const;
	virtual int SLAPI SetUniqueID(long * pID);

	int    FASTCALL Copy(const PPCommandItem &);
	int    SLAPI Enumerate(CmdItemIterFunc func, long parentID, void * extraPtr) const;

	int16  Kind;
	int16  Flags;
	long   ID;
	SString Name;
	SString Icon;
};

class PPCommand : public PPCommandItem {
public:
	SLAPI  PPCommand();
	virtual int SLAPI Write(SBuffer &, long) const;
	virtual int SLAPI Read(SBuffer &, long);
	virtual PPCommandItem * SLAPI Dup() const;
	int    FASTCALL Copy(const PPCommand &);

	long   CmdID;          // Идентификатор дескриптора команды (PPCommandDescr)
	TPoint P;
	//uint16 X;
	//uint16 Y;
	char   Reserve[28];    // @reserve
	SBuffer Param;
};

class PPCommandFolder : public PPCommandItem {
public:
	static int SLAPI GetMenuList(const PPCommandGroup * pGrp, StrAssocArray * pAry, int isDesktop);

	enum Direction {
		nextUp = 0,
		nextDown,
		nextLeft,
		nextRight
	};
	SLAPI  PPCommandFolder();
	virtual int SLAPI Write(SBuffer &, long) const;
	virtual int SLAPI Read(SBuffer &, long);
	virtual const PPCommandItem * SLAPI Next(uint * pPos) const;
	virtual PPCommandItem * SLAPI Dup() const;
	int    FASTCALL Copy(const PPCommandFolder &);
	PPCommandFolder & FASTCALL operator = (const PPCommandFolder &);
	uint   SLAPI GetCount() const;
	const  PPCommandItem * SLAPI Get(uint pos) const;
	const  PPCommandItem * SLAPI SearchByID(long id, uint * pPos) const;
	const  PPCommandItem * SLAPI SearchByIDRecursive(long id, long * pParentID);
	const  PPCommandItem * SLAPI SearchByName(const char * pName, const char * pDbSymb, uint * pPos) const;
	const  PPCommandItem * SLAPI SearchByCoord(TPoint coord, const PPDesktop & rD, uint * pPos) const;
	int    SLAPI SearchFreeCoord(RECT r, const PPDesktop & rD, TPoint * pCoord) const;
	const PPCommandItem * SLAPI SearchNextByCoord(POINT coord, const PPDesktop & rD, Direction next, uint * pPos);
	const PPCommandItem * SLAPI SearchFirst(uint * pPos);
	int    SLAPI GetIntersectIDs(TPoint coord, const PPDesktop & rD, PPIDArray * pAry);
	//int    SLAPI GetIntersectIDs(RECT rect, const PPDesktop & rD, PPIDArray * pAry);
	int    SLAPI GetIntersectIDs(const TRect & rR, const PPDesktop & rD, PPIDArray * pAry);
	int    SLAPI GetIconRect(long id, const PPDesktop & rD, TRect * pRect) const;
	int    SLAPI Add(int pos, const PPCommandItem * pItem);
	int    SLAPI AddSeparator(int pos);
	int    SLAPI Remove(uint pos);
	int    SLAPI Update(uint pos, const PPCommandItem * pItem);
	int    SLAPI GetUniqueID(long * pID) const;
	int    SLAPI GetCommandList(StrAssocArray * pList, int onlyFolders);
	virtual int SLAPI SetUniqueID(long * pID);
protected:
	TSCollection <PPCommandItem> List;
};

class PPCommandGroup : public PPCommandFolder {
public:
	SLAPI  PPCommandGroup();
	virtual int SLAPI Write(SBuffer &, long) const;
	virtual int SLAPI Read(SBuffer &, long);
	virtual PPCommandItem * SLAPI Dup() const;
	int    FASTCALL SetDbSymb(const char * pDbSymb);
	int    FASTCALL IsDbSymbEq(const char * pDbSymb) const;
	int    FASTCALL IsDbSymbEq(const PPCommandGroup & rGrp) const;
	int    SLAPI SetLogo(const char * pPath);
	const  SString & GetLogo() const;
	int    FASTCALL Copy(const PPCommandGroup &);
	PPCommandGroup * FASTCALL GetDesktop(long id);
	PPCommandGroup & FASTCALL operator = (const PPCommandGroup &);

	int    SLAPI InitDefaultDesktop(const char * pName);
	int    SLAPI LoadLogo();
	int    SLAPI StoreLogo();
private:
	SString DbSymb;
	SString Logo_;
};
//
// Descr: Интерфейс, реализующий функции команд
//
class PPCommandHandler {
public:
	SLAPI   PPCommandHandler(const PPCommandDescr * pDescr);
	virtual SLAPI ~PPCommandHandler();
	virtual int SLAPI EditParam(SBuffer * pParam, long iconID, long);
	virtual int SLAPI Run(SBuffer * pParam, long iconID, long extraParam);
protected:
	int    SLAPI CheckParamBuf(const SBuffer *, size_t neededSize) const;
	PPCommandDescr D;
};

extern "C" typedef PPCommandHandler * (*FN_CMD_FACTORY)(PPCommandDescr *);

#define CMD_HDL_FACTORY(cmdSymb)  CFF_##cmdSymb
#define IMPLEMENT_CMD_HDL_FACTORY(cmdSymb) \
	extern "C" __declspec(dllexport) PPCommandHandler * CFF_##cmdSymb(PPCommandDescr * pDescr) \
	{ return new CMD_HDL_CLS(cmdSymb)(pDescr); }
#define CMD_HDL_CLS(cmdSymb)      CmdHandler_##cmdSymb
//
//
//
class PPCommandMngr {
public:
	SLAPI  PPCommandMngr(const char * pFileName, int readOnly);
	SLAPI ~PPCommandMngr();
	int    SLAPI IsValid_() const;
	int    SLAPI Save__(const PPCommandGroup *);
	int    SLAPI Load__(PPCommandGroup *);
private:
	struct Hdr {
		long   Signature;
		uint32 Crc;
		uint32 IndexOffset;
		char   Reserve[48];
		uint32 Locking;
	};
	SFile  F;
	int    ReadOnly;
};

PPCommandMngr * SLAPI GetCommandMngr(int readOnly, int isDesktop, const char * pPath = 0);
//
// @ModuleDecl(PPJob)
//

//
// Descr: Дескриптор задачи.
//   Определяет задачу ВНЕ КОНТЕКСТА базы данных, времени исполнения и параметров.
//
struct PPJobDescr { // @persistent
	enum {
		fNoParam = 0x0001, // Задание не имеет параметров
		fNoLogin = 0x0002  // Для выполнения задания не требуется авторизоваться в базе данных
	};
	static const char * P_FactoryPrfx;

	SLAPI  PPJobDescr();
	int    FASTCALL GetFactoryFuncName(SString &) const;
	int    FASTCALL Write(SBuffer & rBuf) const;
	int    FASTCALL Read(SBuffer & rBuf);

	long   CmdID;
	long   Flags;
	char   Reserve[32];
	SString Symb;
	SString Text;
};
//
// Descr: Задача, конкретизированная относительно базы данных и расписания.
//
class PPJob : public PPExtStrContainer { // @persistent // @v9.2.3 PPExtStrContainer
public:
	SLAPI  PPJob();
	PPJob & FASTCALL operator = (const PPJob &);
	int    FASTCALL Write(SBuffer & rBuf);
	int    FASTCALL Read(SBuffer & rBuf);
	enum {
		fV579                  = 0x0001,
		fNotifyByMail          = 0x0002, //
		fDisable               = 0x0004, // Задача не должна запускаться //
		fOnStartUp             = 0x0008, // @v7.9.6 Задачу запускать при запуске сервера
		fPermanent             = 0x0010, // @v7.9.6 Перманентая задача (запускается один раз и постоянно работает)
		fUnSheduled            = 0x0020, // @v8.2.5 Непланируемая по времени задача. Такая задача исполняется либо при запуске,
			// либо после другой задачи, либо вообще не исполняется.
		fSkipEmptyNotification = 0x0040  // @v9.2.11 Не отсылать уведомления, если журналы пустые
	};
	enum {
		extssEMailAddrList  = 1, // Список e-mail адресов для отсылки почтовых извещений о состоянии выполнения задачи
		extssEMailSubj      = 2  // Тема e-mail сообщения. Если пусто, то формируется автоматически
	};
	PPID   ID;
	SString Name;
	SString DbSymb;
	PPJobDescr Descr;
	DateTimeRepeating Dtr;     // План повторений запуска
	long   Flags;              //
	long   EstimatedTime;      // Ожидаемое время исполнения (sec).
	LDATETIME LastRunningTime; // Время последнего запуска работы (0 - не запускалась)
	long   Ver;                // Номер версии хранимой копии задачи
	PPID   NextJobID;          // Задача запускаемая в случае успешного выполнения текущей задачи
	char   Symb[20];           // Уникальный (или пустой) символ задачи
	PPID   EmailAccID;         // @v9.2.3 Учетная запись электронной почты
	LTIME  ScheduleBeforeTime; // @v9.2.11 Время, после которого задачу выполнять не следует
	char   Reserve[4];         // @reserve @v9.2.3 [12]-->[8] // @v9.2.11 [8]-->[4]
	SBuffer Param;
};
//
// Descr: Интерфейс, реализующий функции задачи
//
class PPJobHandler {
public:
	SLAPI   PPJobHandler(const PPJobDescr * pDescr);
	virtual SLAPI ~PPJobHandler();
	virtual int SLAPI EditParam(SBuffer * pParam, void * extraPtr);
	virtual int SLAPI Run(SBuffer * pParam, void * extraPtr);
	virtual const PPJobDescr & SLAPI GetDescr();
protected:
	int    SLAPI CheckParamBuf(const SBuffer *, size_t neededSize) const;
private:
	PPJobDescr D;
};

extern "C" typedef PPJobHandler * (*FN_JOB_FACTORY)(PPJobDescr *);

#define JOB_HDL_FACTORY(jobSymb)  JFF_##jobSymb
#define IMPLEMENT_JOB_HDL_FACTORY(jobSymb) \
	extern "C" __declspec(dllexport) PPJobHandler * JFF_##jobSymb(PPJobDescr * pDescr) \
	{ return new JOB_HDL_CLS(jobSymb)(pDescr); }
#define JOB_HDL_CLS(jobSymb)      JobHandler_##jobSymb
//
// Descr: Пул задач. Хранит задачи, конкретизированные относительно базы данных
//   и расписания.
//
class PPJobPool : private TSCollection <PPJob> {
public:
	friend class PPJobMngr;

	SLAPI  PPJobPool(PPJobMngr * pMngr, const char * pDbSymb, int readOnly);
	const  SString & SLAPI GetDbSymb() const;
	int    FASTCALL IsJobSuited(const PPJob *) const;
	uint   SLAPI GetCount() const;
	int    SLAPI CheckUniqueJob(const PPJob * pJob) const;
	//
	// Descr: Извлекает задачу с идентификатором, следующим за *pID.
	//   Используется для перечисления задач в цикле.
	// ARG(pID      IN/OUT): @#{vptr} Указатель на идентификатор задачи,
	//   непосредственно предшествующий тому, который будет извлечен функцией.
	//   Если требуемая задача найдена, то по этому указателю присваиваетс
	//   значение идентификатора такой задачи.
	// ARG(pJob        OUT): @#{vptr0} Указатель по которому будет присвоено
	//   найденное задание.
	// ARG(ignoreDbSymb IN): Если этот аргумент равен нулю, то перечисляются только
	//   те задания, которые принадлежат базе данных с символом DbSymb. В противном
	//   случае проверка на символ базы данных не осуществляется.
	// Returns:
	//   >0 - найдено очередное задание.
	//   0  - нет больше ни одного задания, идентификатор которого был бы более
	//      *pID и удловлеворяющего необходимым критериям.
	//
	int    SLAPI Enum(PPID * pID, PPJob * pJob, int ignoreDbSymb = 0) const;
	const  PPJob * SLAPI GetJob(PPID id, int ignoreDbSymb = 0) const;
	int    SLAPI PutJob(PPID * pID, const PPJob * pJob);
private:
	enum {
		fReadOnly = 0x0001 // пул только для чтения //
	};
	long   Flags;
	SString DbSymb; // база данных, к которой относятся задачи пула
	PPJobMngr * P_Mngr; // @notowned @v7.7.9
};
//
// Descr: Управляет ресурсами задач и пулами задач
//
class PPJobMngr {
public:
	SLAPI  PPJobMngr();
	SLAPI ~PPJobMngr();
	int    SLAPI LoadResource(PPID jobID, PPJobDescr * pJob);
 	int    SLAPI LoadResourceBySymb(const char * pSymb, PPJobDescr * pJob);
	int    SLAPI GetResourceList(int loadText, StrAssocArray * pList);
	int    SLAPI LoadPool(const char * pDbSymb, PPJobPool *, int readOnly);
	int    SLAPI SavePool(const PPJobPool *);
	int    SLAPI IsPoolChanged() const;
	DirChangeNotification * SLAPI CreateDcn();
	PPJobHandler * SLAPI CreateInstance(PPID jobID, const PPJobDescr * pDescr);
	int    SLAPI DoJob(PPID jobID, SBuffer * pParam);
	int    SLAPI EditJobParam(PPID jobID, SBuffer * pParam);

	long   SLAPI AcquireNewId();
	int    FASTCALL UpdateLastId(long id);
private:
	int    SLAPI Helper_ReadHeader(SFile & rF, void * pHdr, int lockMode);
	int    SLAPI CreatePool();
	int    SLAPI CloseFile();

	TVRez  * P_Rez;

	// Путь к файлу, в котором хранится пул задач. Мы сохраняем этот
	//   путь в переменной по тому, что при обработке задач все нужно делать
	//   очень быстро.
	SString FilePath; // @*PPJobMngr::PPJobMngr

	// Время последнего вызова функции LoadPool
	// Используется для определения факта изменения файла пула
	// с момена последней загрузки
	LDATETIME LastLoading;
	long   LastId; // @persistent Используется для присвоения уникального идентификатора новым задачам
	int    LckH;   // @transient  Дескриптор блокировки заголовка файла
	SFile * P_F;   // Файл, из которого считаны данные в режиме 'на запись'. Если данные извлекаются только для чтения,
		// то файл тут же закрывается и P_F остается нулевым.
};
//
// @ModuleDecl(PPNamedFilt)
//
class PPNamedFilt {
public:
	SLAPI  PPNamedFilt();
	SLAPI ~PPNamedFilt();
	PPNamedFilt & FASTCALL operator = (const PPNamedFilt &);
	//
	// Descr: Записать данные класса в буфер
	//
	int    SLAPI Write(SBuffer &, long) const;
	//
	// Descr: Прочитать из буфера данные и спроецировать на класс
	//
	int    SLAPI Read(SBuffer &, long);
	enum {
		fDontWriteXmlDTD = 0x0001 // В исходящий XML-файле на писать DTD
	};
	PPID   ID;          // Уникальный идентификатор фильтра внутри пула
	long   Ver;         // Номер версии хранимой копии именованного фильтра
    long   ViewID;      // Идентификатор обьекта PPView, по которому строится фильтр
    long   Flags;       // @v8.4.2
	char   Reserve[28]; // @reserve
	SString Name;       // Уникальная строка описания именованного фильтра
	SString DbSymb;     // Символ базы данных, относительно которой определен именованный фильтр
	SString Symb;       // Уникальная (непустая) строка символа именованного фильтра
	SString ViewSymb;   // Строка символа обьекта PPView, по которому строится фильтр
	SBuffer Param;      // Хранит данные о настройках фильтра PPBaseFilt
};

//
// Descr: Пул именованных фильтров. Хранит фильтры, конкретизированные относительно базы данных
//
class PPNamedFiltPool : private TSCollection <PPNamedFilt> {
public:
	friend class PPNamedFiltMngr;

	SLAPI  PPNamedFiltPool(const char * pDbSymb, int readOnly);
	const  SString & SLAPI GetDbSymb() const;
	//
	// Descr: Проверяет, относится ли именованный фильтр к данной БД
	// Returns:
	//	>0	-	Фильтр относится к этой БД
	//	0	-	Фильтр относится к другой БД
	//
	int    SLAPI IsNamedFiltSuited(const PPNamedFilt *) const;
	uint   SLAPI GetCount() const;
	//
	// Descr: Проверяет пул на существование похожих фильтров
	// Returns:
	//	>0	-	В пуле нет фильтров, совпадающих по имени и/или символу
	//			с заданным и имеющих другой id
	//	0	-	Существует фильтр, совпадающий по имени и/или символу
	//			с заданным и имеющий другой id
	//
	int    SLAPI CheckUniqueNamedFilt(const PPNamedFilt * pNamedFilt) const;
	//
	// Descr: Извлекает фильтр с идентификатором, следующим за *pID.
	//   Используется для перечисления фильтров в цикле.
	// ARG(pID      IN/OUT): @#{vptr} Указатель на идентификатор фильтра, непосредственно
	//   предшествующий тому, который будет извлечен функцией.
	//   Если требуемый фильтр найден, то по этому указателю присваивается значение
	//   идентификатора такого фильтра.
	// ARG(pNamedFilt        OUT): @#{vptr0} Указатель по которому будет присвоен
	//   найденный фильтр.
	// ARG(ignoreDbSymb IN): Если этот аргумент равен нулю, то перечисляются только
	//   те фильтры, которые принадлежат базе данных с символом DbSymb. В противном
	//   случае проверка на символ базы данных не осуществляется.
	// Returns:
	//   >0 - найден очередной фильтр.
	//   0  - нет больше ни одного фильтра, идентификатор которого был бы более
	//      *pID и удовлеворяющего необходимым критериям.
	//
	int    SLAPI Enum(PPID * pID, PPNamedFilt * pNamedFilt, int ignoreDbSymb = 0) const;
	//
	// Descr: Получает фильтр с идентификатором *pID из пула
	// ARG(id			IN): идентификатор
	// ARG(ignoreDbSymb	IN): если !0 то игнорировать принадлежность к базе данных
	// Returns:
	//	0  - не найдено фильтров, удовлетворяющих необходимым критериям
	//
	const  PPNamedFilt * SLAPI GetByID(PPID id, int ignoreDbSymb = 0) const;
	const  PPNamedFilt * SLAPI GetBySymb(const char * pSymb, int ignoreDbSymb = 0) const;
	//
	// Descr: Помещает фильтр в пул
	//
	// Returns:
	//	>0	-	фильтр с таким id уже существовал и был успешно заменен
	//	0	-	произошла ошибка
	//	<0	-	фильтр была добавлен в пул
	//
	int    SLAPI PutNamedFilt(PPID * pID, const PPNamedFilt * pNamedFilt);
private:
	enum {
		fReadOnly = 0x0001 // пул только для чтения //
	};
	long   Flags;
	SString DbSymb; // база данных, к которой относятся фильтры пула
};
//
// Descr: Управляет ресурсами фильтров, и пулами фильтров
//
class PPNamedFiltMngr {
public:
	SLAPI  PPNamedFiltMngr();
	SLAPI ~PPNamedFiltMngr();
	//
	// Descr: Получить данные об объекте PPView
	// ARG(viewId  IN): идентификатор объекта PPView
	// ARG(symb   OUT): строка символа
	// ARG(text   OUT): строка описани
	// ARG(pFlags OUT): флаги
	// Returns:
	//	>0 - успешно
	//  0  - ошибка
	//
	int    SLAPI LoadResource(PPID viewId, SString & symb, SString & text, long * pFlags) const;
	//
	// Descr: Загрузить список ассоциаций обьектов PPView в два списка
	// ARG(pSymbList OUT): Список ассоциаций объектов PPView {id, строка символа}
	// ARG(pTextList OUT): Список ассоциаций объектов PPView {id, строка описания}, упорядочен по описанию
	// Returns:
	//  >0 - успешно
	//	0  - ошибка
	//
	int    SLAPI GetResourceLists(StrAssocArray * pSymbList, StrAssocArray * pTextList) const;
	//
	// Descr: Прочитать пул фильтров из файла
	// ARG(pDbSymb	IN): символ базы данных, который будет присвоен прочитанному пулу
	// ARG(*	   OUT): пул фильтров
	// ARG(readOnly	IN): флаг "пул только для чтения", который будет присвоен прочитанному пулу
	// Returns:
	//  >0 - успешно
	//	0  - ошибка
	//
	int    SLAPI LoadPool(const char * pDbSymb, PPNamedFiltPool *, int readOnly);
	//
	// Descr: Сохранить пул фильтров в файл
	// ARG(*	IN): пул для сохранени
	// Returns:
	//	>0 - успешно
	//  0  - ошибка
	//
	int    SLAPI SavePool(const PPNamedFiltPool *) const;
private:
	TVRez  * P_Rez;

	// Путь к файлу, в котором хранится пул фильтров. Мы сохраняем этот
	// путь в переменной потому, что при обработке фильтров все нужно делать
	// очень быстро.
	SString FilePath; // @*PPNamedFiltMngr::PPNamedFiltMngr

	// Время последнего вызова функции LoadPool
	//  Используется для определения факта изменения файла пула
	//  с момента последней загрузки
	LDATETIME LastLoading;
};
//
// PPObjListWindow & PPObjBrowser flags
//
#define OLW_CANINSERT     0x0001
#define OLW_CANDELETE     0x0002
#define OLW_CANEDIT       0x0004
#define OLW_SORTBYTEXT    0x0008
#define OLW_CANSELUPLEVEL 0x0010 // Позволяет выбирать элемент, имеющий подуровни
#define OLW_SHOWPASSIVE   0x0020 // Показывать пассивные объекты
	// (работает только для объектов, поддерживающих признак пассивности)
#define OLW_SETUPSINGLE   0x0040 // Если в списке всего один элемент, и вызывающая функция //
	// не указала явно, какой элемент устанавливать в комбо-бокс, то устанавливается единственный.
#define OLW_LOADDEFONOPEN 0x0080 // Загружает данные для списка при первом открытии
#define OLW_WORDSELECTOR  0x0100 // @v7.5.1 При поиске отображать список строк, удовлетворяющих строке поиска
#define OWL_OUTERLIST     0x0200 // @v9.0.1 Данные для списка были приложены к PPObjListWindow
	// при создании экземпляра - не следует перестраивать список при изменении элемента.
//
// Строки соответствующие SubstGrpPersonEvent: PPTXT_SUBSTPSNEVLIST
//
enum SubstGrpPersonEvent {
	sgpeNone = 0,
	sgpeOp,            // Операция   //
	sgpePerson,        // Персоналия //
	sgpeCntrAg         // Контрагент //
};

int    SLAPI ShrinkSubstDate(SubstGrpDate sgd, LDATE orgDt, LDATE * pDestDt);
int    SLAPI ShrinkSubstDateExt(SubstGrpDate sgd, LDATE orgDt, LTIME orgTm, LDATE * pDestDt, LTIME * pDestTm);
int    SLAPI ExpandSubstDate(SubstGrpDate sgd, LDATE dt, DateRange *);
int    SLAPI ExpandSubstDateExt(SubstGrpDate sgd, LDATE dt, LTIME tm, DateRange * pPeriod, TimeRange * pTmPeriod);
int    SLAPI AdjustPeriodToSubst(SubstGrpDate sgd, DateRange *);
void   SLAPI FormatSubstDate(SubstGrpDate sgd, LDATE dt, SString & rBuf, long fmt = 0);
void   SLAPI FormatSubstDate(SubstGrpDate sgd, LDATE dt, char * pBuf, size_t bufLen, long fmt = 0);
void   SLAPI FormatSubstDateExt(SubstGrpDate sgd, LDATE dt, LTIME tm, SString & rBuf, long dtFmt = 0, long tmFmt = 0);

struct PPCommObjEntry {
	enum {
		fPassive      = 0x0001,
		fHierarchical = 0x0002  // @v8.2.3 Только для типов динамических объектов: записи допускают иерархию
	};
	PPCommObjEntry(PPID objType = 0, PPID id = 0, const char * pName = 0, const char * pSymb = 0, long flags = 0);

	PPID   ObjType;
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	long   Flags;
	long   ParentID; // @v8.2.3
};
//
//
//
class PPObjReference : public PPObject {
public:
	//
	// Descr: Диалог редактирования простого элемента справочника
	// Return:
	//   >0 - OK
	//   <0 - CANCEL
	//   0  - ERROR
	//
	static int SLAPI EditCommObjItem(PPCommObjEntry *);

	SLAPI  PPObjReference(PPID aObj, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  SLAPI Search(PPID id, void * pRec = 0);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual int  SLAPI MakeReserved(long flags);
	int    SLAPI EnumItems(PPID * pID, void * pRec = 0);
	//
	// Descr: Стандартный енумератор.
	// Note: Просто вызывает енумератор Reference::Enum(Obj, options)
	// ARG(options IN): Опции перечисления Reference::eoXXX
	//
	SEnumImp * FASTCALL Enum(int options);
	SEnumImp * SLAPI EnumByIdxVal(int valN, long val);

	int    SLAPI SearchByName(const char *, PPID *, void * = 0);
	int    SLAPI SearchBySymb(const char * pSymb, PPID * pID, void * pRec = 0);
	int    SLAPI CheckDupName(PPID objID, const char * pName);
	int    SLAPI CheckDupSymb(PPID objID, const char * pSymb);
	//
	// Descr: Проверяет имя pName обекта id. Если имя пустое или в базе данных
	//   уже есть объект с таким именем, но идентификатором, отличным от id, то
	//   возвращает нулевое значение.
	// ARG(id     IN): идентификатор записи, которой принадлежит имя //
	//   Если id == 0, то это означает новую запись.
	// ARG(pName  IN): проверяемое имя.
	// ARG(silent IN): если этот параметр нулевой, то функция вызывает PPError().
	//   В противном случае просто устанавливается код ошибки в переменную PPErrCode.
	// Returns:
	//   !0 - наименование объекта является допустимым
	//   0  - наименование объекта недопустимое
	//
	int    SLAPI CheckName(PPID id, const char * pName, int silent);
	PPID   SLAPI GetSingle();
	int    SLAPI UpdateItem(PPID id, void * pRec, int use_ta);
	int    SLAPI AddItem(PPID * pID, void * pRec, int use_ta);
protected:
	virtual const char * SLAPI GetNamePtr();
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI ProcessReservedItem(TVRez &);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	//
	// Descr: Функция, идентифицирующая факт эквивалентности записей rR1 и rR2.
	//   Реализация по умолчанию сравнивает каждое поля ReferenceTbl::Rec. Однако, порожденные
	//   классы могут по разному использовать некоторые поля записи, по этому, должны реализовать
	//   метод для корректного определения являются ли записи равными.
	//   Используется в методах Write и UpdateItem
	// Returns:
	//   >0 - записи rR1 и rR2 эквивалентны
	//   0  - записи rR1 и rR2 не эквивалентны
	//
	virtual int  SLAPI IsRecEq(const ReferenceTbl::Rec & rR1, const ReferenceTbl::Rec & rR2);
	int    SLAPI EditItem(PPID obj, PPID id, void * rec, int use_ta);
	int    SLAPI LoadReservedItems(uint rezID);
	int    SLAPI Serialize_(int dir, ReferenceTbl::Rec * pPack, void * stream, ObjTransmContext * pCtx);
public:
	//long   extra;
	void * ExtraPtr;
	Reference * ref; // Equal to extern PPRef
};
//
// @ModuleDecl(PPObjDynamicObjs)
// Управляет динамически создаваемыми типами объектов данных
//
//
// Descr: Запись 'лемента динамического объекта
//
struct PPDynanicObjItem { // @persistent @store(Reference2Tbl+)
	long   ObjType;        // ->Ref(PPOBJ_DYNAMICOBJS)
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	uint8  ExtData[64];    //
	long   Flags;          //
	long   ParentID;       //
};

class PPObjDynamicObjs : public PPObjReference {
public:
	// static int SLAPI ReplaceObjs(PPID srcID = 0);

	SLAPI  PPObjDynamicObjs(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
private:
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
};
//
// @ModuleDecl(PPObjTag)
//
#define OBJTAG_ONLYGROUP -1L
#define OBJTAG_ONLYTAGS  -2L

struct ObjTagFilt {
	enum {
		fOnlyGroups   = 0x0001, // Только группы тегов
		fOnlyTags     = 0x0002, // Только терминальные теги
		// @#{fOnlyGroups^fOnlyTags}
		fAnyObjects   = 0x0004, // @v8.2.8 Исторически, ObjTypeID == 0 трактуется как ObjTypeID = PPOBJ_PERSON,
			// по этому, чтобы получить теги по всем типам объектов необходимо установить данный флаг.
		fObjTypeRoots = 0x0008  // @v8.5.3 Добавить узлы, соответствующие типам объектов.
			// Идентификаторы узлов формируются по следующему правилу: ObjType * 100000
	};

#define TAG_OBJTYPEROOT_MULT 100000

	static long    FASTCALL MakeObjTypeRootIdent(PPID objType);
	static int     FASTCALL ObjTypeRootIdentToObjType(long rootIdent, PPID * pObjType);

	SLAPI  ObjTagFilt(PPID objTypeID = 0, long flags = 0, PPID parentID = 0);

	PPID   ObjTypeID;  // Тип связанного объекта данных
	PPID   ParentID;   // Группа тегов
	long   Flags;      //
};

class PPObjTag : public PPObjReference {
public:
	static int     SLAPI EditEnumListDialog(PPTagEnumList *);
	static int     SLAPI CheckForTagFilt(PPID objType, PPID objID, const TagFilt * pFilt);
	//
	// Descr: Вспомогательная функция для извлечения тега объекта {objType; objID}
	//   по символу типа тега pTagSymb и присвоения его суррогатному идентификатору,
	//   который и возвращается функцией.
	//   Используется только в методах PPALDD_XXX::EvaluateFunc().
	//
	static PPID    SLAPI Helper_GetTag(PPID objType, PPID objID, const char * pTagSymb);
	static PPID    SLAPI Helper_GetTagByID(PPID objType, PPID objID, PPID tagID);
	static int     SLAPI RecoverLostUnifiedLinks();

	SLAPI  PPObjTag(void * extraPtr = 0);
	SLAPI ~PPObjTag();
	virtual int  SLAPI Edit(PPID *, void * extraPtr);
	// @v8.5.3 virtual int  SLAPI Browse(long);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI CheckForFilt(const ObjTagFilt * pFilt, const PPObjectTag & rRec) const;
	int    SLAPI GetObjListByFilt(PPID objType, const TagFilt * pFilt, UintHashTable & rList, UintHashTable & rExcludeList);
	int    SLAPI GetPacket(PPID id, PPObjTagPacket *);
	int    SLAPI PutPacket(PPID * pID, PPObjTagPacket *, int use_ta);
	//
	// Descr: создает список тегов с родителем parent. Если задан текущий элемент списка
	//   current, то значение parent замещается на элемент, являющийся родителем для current.
	//   Если parent < 0, то выбираются только группы, но не сами теги.
	//
	SArray * SLAPI CreateList(long current, long parent);
	int    SLAPI GetListByFlag(long mask, PPIDArray & rList);
	int    SLAPI NormalizeTextCriterion(PPID tagID, const char * pCrit, SString & rNormCrit);
	//
	// Descr: Возвращает информацию о тегах, которые отсутствуют в списке pTagList либо
	//   имеют недопустимое значение. Типы тегов, для которых проверяется условие определяется //
	//   по наличию у тега флага OTF_WARNZERO.
	// ARG(pTagList     IN): @#{vptr0} Список тегов, для которых проверяеются условия //
	// ARG(pResultList OUT): @#{vptr0} Список ассоциация {tag, message} в котором перечиляются //
	//   отсутствующие или имеющие недопустимое значени теги и соответствующие им сообщения.
	// ARG(pInfoList   OUT): @#{vptr0} Список ассоциация {tag, value} в котором перечисляются //
	//   соответсвующие условиям проверки теги и их значения (в текстовом виде)
	// Returns:
	//   >0 - обнаружена по крайней мере одна проблема
	//   <0 - все теги удовлетворяют условиям
	//    0 - ошибка
	//
	int    SLAPI GetWarnList(const ObjTagList * pTagList, StrAssocArray * pResultList, StrAssocArray * pInfoList);
	int    SLAPI Fetch(PPID, PPObjectTag *);
	//
	// Descr: Находит идентификатор типа тега по символу. Функция работает очень быстро благодаря кэшированию.
	//
	int    SLAPI FetchBySymb(const char * pSymb, PPID * pID);
	//
	// Descr: Функция определяет является ли тег "неотражаемым" в котнектсе лотов.
	//   Под "неотражаемостью" подразумевается требование не переносить тег на
	//   заркальные лоты при внутреннем перемещении товара.
	// Returns:
	//   !0 - тег неотражаемый
	//   0  - тег отражаемый (может и должен быть перенесен на зеркальный лот при внутреннем перемещении товара)
	//
	int    FASTCALL IsUnmirrored(PPID tagID);
	int    SLAPI GetCurrTagVal(const ObjTagItem * pItem, SString & rBuf);
	int    SLAPI FetchTag(PPID objID, PPID tagID, ObjTagItem * pItem);
	int    SLAPI DirtyTag(PPID objType, PPID objID, PPID tagID);
protected:
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	virtual int  SLAPI Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  SLAPI MakeReserved(long flags);
private:
	ObjTagFilt & SLAPI InitFilt(void * extraPtr, ObjTagFilt & rFilt) const;
	int    SLAPI Helper_CreateEnumObject(PPObjTagPacket & rPack);

	ObjTagFilt OtFilt; // @#{!PPObject::extra || PPObject::extra == &CurFilt}
};
//
// Descr: Объект данных, представляющий типы системных событий.
//   Объект фантомный. То есть, физически записи в базе данных не хранятся (начиная с v6.0.0).
//   Все записи извлекаются из ресурса строк PPSTR_ACTION.
//   Последняя запись имеет ID = PPACN_LAST
//
class PPObjSysAction : public PPObjReference {
public:
	SLAPI  PPObjSysAction(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr); // Ничего не делает
	virtual int  SLAPI Search(PPID, void * = 0);
private:
	virtual int  SLAPI Remove(PPID id, long, uint options); // Ничего не делает
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual const char * SLAPI GetNamePtr();

	SString NameBuf; // Returns by GetNamePtr
};
//
// Descr: Объект данных, представляющий типы системных событий.
//   Объект фантомный. То есть, физически записи в базе данных не хранятся.
//   Все записи извлекаются из ресурса строк PPSTR_GTA.
//   Последняя запись имеет ID = PPGTA_LAST
//
class PPObjGtaAction : public PPObjReference {
public:
	SLAPI  PPObjGtaAction(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr); // Ничего не делает
	virtual int  SLAPI Search(PPID, void * = 0);
private:
	virtual int  SLAPI Remove(PPID id, long, uint options); // Ничего не делает
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual const char * SLAPI GetNamePtr();

	SString NameBuf; // Returns by GetNamePtr
};
//
// @ModuleDecl(PPObjUnit)
// Единицы измерения //
//
struct PPUnit2 {           // @persistent @store(Reference2Tbl+)
	enum {
		SI       = 0x0001, // (S) Единица системы СИ
		Phisical = 0x0002, // (P) Физическая единица
		Trade    = 0x0004, // (T) Торговая единица (может не иметь однозначного физ. эквивалента)
		Hide     = 0x0008, // (H) Единицу не следует показывать
		IntVal   = 0x0010, // (I) Единица может быть только целочисленной
		Common   = 0x0020  // Унифицированная единица измерения (имеет конкретные габариты и, возможно, массу и емкость) //
	};
	long   Tag;            // Const=PPOBJ_UNIT
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Abbr[20];       // Символьный код единицы измерения //
	char   Code[12];       // Цифровой код единицы измерения //
	char   Reserve[16];    // @reserve
	double Rounding;       // Округление величины. (0.001 - до трех знаков после точки, 1 - целое и т.д.)
	//
	// Следующие 4 поля будут использованы для унифицированной системы обработки атрибутов товарной логистики
	//
	long   X;              // Length (mm)
	long   Y;              // Width (mm)
	long   Z;              // Height (mm)
	long   Mass;           // Mass (g)
	double BaseRatio;      //
	long   Flags;          //
	PPID   BaseUnitID;     // ->Ref(PPOBJ_UNIT)
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPUnit);

class PPObjUnit : public PPObjReference {
public:
	SLAPI  PPObjUnit(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи  //
	//   по идентификатору ID. Если pRec == 0, то запись содержится в буфере ref->data.
	//
	int    SLAPI Fetch(PPID, PPUnit * pRec);
	int    SLAPI IsPhisical(PPID);
	int    SLAPI IsInteger(PPID);
	int    SLAPI AddSimple(PPID * pID, const char * pName, long flags, int use_ta);
	int    SLAPI SearchMaxLike(const PPUnit * pRec, PPID * pID);
	int    SLAPI UniteMaxLike();
protected:
	virtual int  SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI ProcessReservedItem(TVRez &);
};
//
// @ModuleDecl(PPObjNamedObjAssoc)
//
struct PPNamedObjAssoc2 {  // @persistent @store(Reference2Tbl+)
	enum {
		fLocAsWarehouse = 0x0001,
		fLocAsWareplace = 0x0002
	};
	long   Tag;            // Const=PPOBJ_NAMEDOBJASSOC
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	long   ScndObjGrp;     //
	long   Flags;          //
	long   PrmrObjType;    // PPOBJ_GOODS ||
	long   ScndObjType;    // PPOBJ_WAREHOUSE || PPOBJ_WAREPLACE || PPOBJ_ARTICLE
};

DECL_REF_REC(PPNamedObjAssoc);

class PPObjNamedObjAssoc : public PPObjReference {
public:
	SLAPI  PPObjNamedObjAssoc(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjPersonKind)
//
// Descr: Вид персоналии //
//
struct PPPersonKind2 {     // @persistent @store(Reference2Tbl+)
	//
	// Descr: флаги вида персоналии
	//
	enum {
		fUseShortPersonDialog = 0x0001 // При создании новой персоналии этого вида использовать сокращенный диалог
	};
	long   Tag;            // Const=PPOBJ_PRSNKIND
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	long   Flags;          // @flags
	PPID   DefStatusID;    // ->Ref(PPOBJ_PRSNSTATUS) Статус новой персоналии по умолчанию
	char   Reserve[56];    // @reserve
	long   CodeRegTypeID;  // Тип регистрационного документа, используемого для поиска
	PPID   FolderRegTypeID; // Тип регистра, идентифицирующего наименование каталога с документами по персоналии
};

DECL_REF_REC(PPPersonKind);

class PPObjPersonKind : public PPObjReference {
public:
	SLAPI  PPObjPersonKind(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, PPPersonKind * pRec);
protected:
	virtual int  SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjPersonStatus)
// Юридические статусы персоналий
//
#define PSNSTF_PRIVATE   0x0001L // Физическое лицо, иначе юридическое

struct PPPersonStatus2 {   // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_PRSNSTATUS
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          // PSNSTF_XXX
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPPersonStatus);

class PPObjPersonStatus : public PPObjReference {
public:
	SLAPI  PPObjPersonStatus(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Fetch(PPID id, PPPersonStatus * pRec);
};
//
// @ModuleDecl(PPObjPersonCat)
//
struct PPPersonCat {
	long   Tag;            // Const=PPOBJ_PRSNCATEGORY
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[64];    // @reserve
	long   Reserve2[2];    // @reserve
};

class PPObjPersonCat : public PPObjReference {
public:
	SLAPI  PPObjPersonCat(void * extraPtr = 0);
	int    SLAPI Fetch(PPID id, PPPersonCat * pRec);
private:
	virtual int SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx); // @srlz
};
//
// Виды адресов электронной связи (PPOBJ_ELINKKIND)
//
//
// Типы адресов электронной связи (зарезервированы, не справочник)
//
#define ELNKRT_UNKNOWN      0L
#define ELNKRT_PHONE        1L
#define ELNKRT_FAX          2L
#define ELNKRT_PAGER        3L
#define ELNKRT_EMAIL        4L
#define ELNKRT_WEBADDR      5L

#define ELNKF_PREF     0x0001L // Предпочтительный адрес (Flags)

#define MAXPREFELNKK        5  // Максимум предпочтительных адресов

struct PPELinkKind2 {      // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_ELINKKIND
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          //
	PPID   Type;           // ELNKRT_XXX
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPELinkKind);

class PPObjELinkKind : public PPObjReference {
public:
	SLAPI  PPObjELinkKind(void * extraPTr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	//
	// 1. Проверяет, является ли *pID зарезервированным номером ?
	//    1.1 YES: проверяет существование объекта с таким идентификатором.
	//        1.1.1 EXISTS: return (> 0),
	//        1.1.2 NOT EXISTS: создает запись с таким ID, именем Name и типом ELNKRT_UNKNOWN
	//    1.2 NO: проверяет существование объекта с именем Name
	//        1.2.1 EXISTS: return ( > 0) и в *pID записывается идентификатор найденного объекта
	//        1.2.2 NOT EXISTS: создает объект с именем Name и типом ELNKRT_UNKNOWN.
	//              по указателю *pID присваивается ИД нового объекта. return (> 0)
	// On error: return (< 0)
	//
	int    SLAPI AddSimple(PPID * pID, const char * pName, int use_ta);
	int    SLAPI Fetch(PPID id, PPELinkKind * pRec);
private:
	virtual int  SLAPI ProcessReservedItem(TVRez &);
};

struct PPELink {
	PPID   KindID;    // ->Ref(PPOBJ_ELINKKIND)
	char   Addr[64];  //
};

class PPELinkArray : public TSArray <PPELink> {
public:
	SLAPI  PPELinkArray();
	int    FASTCALL IsEqual(const PPELinkArray & rS) const;
	int    SLAPI AddItem(PPID kindID, const char * pAddr);
	int    SLAPI GetItem(PPID kindID, SString & rBuf) const;
	int    SLAPI SearchByText(const char * pText, uint * pPos) const;
	int    SLAPI GetSinglePhone(SString & rBuf, uint * pPos) const;
	int    SLAPI GetPhones(uint maxCount, SString & rBuf, long elinkType = ELNKRT_PHONE) const;
	int    SLAPI GetListByType(PPID eLinkType, StringSet & rSs) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
};
//
// @ModuleDecl(PPObjCurrency)
// Валюты
//
struct PPCurrency2 {       // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_CURRENCY
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve1[60];   // @reserve
	long   Flags;          //
	long   Code;           // Numeric currency code
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPCurrency);

struct PPCurrencyConfig {  // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_CURRENCYCFG
	PPID   BaseCurID;      // Базовая валюта учета
	PPID   BaseRateTypeID; // Базовый тип курса
	char   Reserve1[36];
	long   Flags;
	char   Reserve2[24];
};

class PPObjCurrency : public PPObjReference {
public:
	SLAPI  PPObjCurrency(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI AddItem(PPID * pID, PPCurrency * pCurrency, int use_ta);
	StrAssocArray * SLAPI CreateSelectorList(int asSymb, PPIDArray * pInclList, PPIDArray * pExclList);
	int    SLAPI Select(int asSymb, PPIDArray * pInclList, PPIDArray * pExclList, PPID * pID);
	int    SLAPI Fetch(PPID id, PPCurrency * pRec);
	int    SLAPI SearchSymb(PPID * pID, const char * pSymb);
	//
	// Descr: Ищет запись валюты по коду code.
	// Returns:
	//   1 - найдена единственная запись валюты с ненулевым значением Code == code
	//   2 - существует более одной записи валюты с ненулевым значением Code == code
	//      возвращается идентификатор первой найденной записи.
	//  <0 - не найдено ни одной записи валюты с кодом code, либо параметр code == 0
	//   0 - ошибка
	//
	int    SLAPI SearchCode(PPID * pID, long code);
};
//
// @ModuleDecl(PPObjCurRateType)
// Типы валютных курсов
//
struct PPCurRateType2 {    // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_CURRATETYPE
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPCurRateType);

class PPObjCurRateType : public PPObjReference {
public:
	SLAPI  PPObjCurRateType(void * extraPtr = 0);
	virtual int SLAPI Browse(void * extraPtr);
};
//
// @ModuleDecl(CurRateCore)
// Валютные курсы
//
struct CurRateIdent {
	PPID   CurID;
	PPID   BaseCurID;
	PPID   RateTypeID;
	LDATE  Dt;
};

struct UhttCurRateIdent {
	CurRateIdent Ident;
	double Rate;
};

class CurRateCore : public CurrencyRateTbl {
public:
	SLAPI  CurRateCore();
	int    SLAPI SearchRate(const CurRateIdent *, CurrencyRateTbl::Rec * = 0);
	int    SLAPI GetRate(PPID curID, PPID rateTypeID, PPID relCurID, LDATE *, double *);
	int    SLAPI UpdateRate(const CurRateIdent *, double, int use_ta);
	int    SLAPI RemoveRate(const CurRateIdent *, int use_ta);
};
//
// @ModuleDecl(PPObjAmountType)
// Типы сумм документов
//
struct PPAmountType2 {     // @persistent @store(Reference2Tbl+)
	int    SLAPI IsTax(PPID taxID  /* GTAX_XXX */) const;
	int    SLAPI IsComplementary() const;
	enum {
		fErrOnDefault = 0x0001, // Если сумма в документе отсутствует, то генерировать сообщение об ошибке
		fManual       = 0x0002, // Сумма может быть введена в ручную.
			// Если флаг установлен, то допускается ручной ввод суммы.
			// Если нет, то сумма расчитывается автоматически по содержанию
			// документа. Исключение - номинальная сумма (PPAMT_MAIN).
			// Она может быть как автоматической так и устанавливаемой в
			// ручную в зависимости от вида операции.
		fTax          = 0x0004, // Сумма налога. Если этот флаг установлен,
			// то значение суммы отражает сумму налога Tax со ставкой (TaxRate*100) %,
			// которым облагается данная операция.
		//
		// Назначение следующих трех флагов в том, чтобы можно было быстро определить итоговые
		// обобщенные суммы GenCost, GenPrice, GenDiscount по товарному документу.
		//
		fReplaceCost     = 0x0010, // Замещает сумму в ценах поступления (Cost)
		fReplacePrice    = 0x0020, // Замещает сумму в ценах реализациия (Price)
		fReplaceDiscount = 0x0040, // Замещает скидку (Discount) @#{fReplaceCost^fReplacePrice^fReplaceDiscount}
		fInAmount        = 0x0080, // Входящая сумма, комплементарная сумме RefAmtTypeID
		fOutAmount       = 0x0100, // Исходящая сумма, комплементарная сумме RefAmtTypeID @#{fTax^fInAmount^fOutAmount}
		fReplaces        = (fReplaceCost | fReplacePrice | fReplaceDiscount),
		fStaffAmount     = 0x0200, // Штатная сумма (используется для расчета зарплаты)
		fFormula         = 0x0400, // С суммой ассоциирована формула.
			// Если такая сумма определена в виде операции, то для документа
			// значение этой суммы автоматически рассчитывается по указанной формуле.
		fDistribCost     = 0x0800, // Распределять сумму на себестоимость строк товарного документа.
		fDcNeg           = 0x1000  // На себестоимость строк документа распределяется отрицательное значение суммы (уменьшает себестоимость).
	};
	long   Tag;            // Const=PPOBJ_AMOUNTTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ для представления в формулах
	char   Reserve[56];    // @reserve
	int16  EcAlg;          // Алгоритм распределения суммы на себестоимость строк документа.
	int16  Reserve2;       // @alignment
	long   Flags;          // Флаги
	long   Tax;            // Налог (GTAX_XXX)
	union {
		long   TaxRate;       // Ставка налога в сотых долях процента (Flags & fTax)
		PPID   RefAmtTypeID;  // Сумма, комплементарная данной (Flags & (fInAmount | fOutAmount))
	};
};

DECL_REF_REC(PPAmountType);

struct PPAmountTypePacket {
	SLAPI  PPAmountTypePacket();
	int    FASTCALL IsEqual(const PPAmountTypePacket & rS) const;

	PPAmountType Rec;
	SString Formula;
};

struct TaxAmountIDs {
	PPID   VatAmtID[3];
	long   VatRate[3];
	PPID   STaxAmtID;
	long   STaxRate;
};

class PPObjAmountType : public PPObjReference {
public:
	SLAPI  PPObjAmountType(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI SearchSymb(PPID *, const char * pSymb);
	int    SLAPI GetTaxAmountIDs(TaxAmountIDs *, int useCache);
	int    SLAPI CheckDupTax(PPID, PPID tax, long taxRate);
	enum {
		selStaffOnly = 0x0001
	};
	StrAssocArray * SLAPI CreateSelectorList(long options, const PPIDArray * pIncludeList);
	int    SLAPI PutPacket(PPID * pID, PPAmountTypePacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPAmountTypePacket * pPack);
	int    SLAPI GetFormulaList(StrAssocArray * pList);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Symb, Flags, Tax, TaxRate, RefAmtTypeID}
	//
	int    SLAPI Fetch(PPID id, PPAmountType * pRec);
	int    SLAPI FetchByTax(PPID *, PPID tax, double rate);
	int    SLAPI FetchCompl(PPID srcAmtID, PPID * pInAmtID, PPID * pOutAmtID);
	//
	// Descr: Если существует хотя бы один тип суммы, требующий распределения //
	//   по себестоимости строк приходного документа, то функция возвращает 1.
	//   В противном случае возвращает 0.
	//
	int    SLAPI IsThereDistribCostAmounts();
private:
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI ProcessReservedItem(TVRez &);
	virtual int  SLAPI Dirty(PPID);
	int    SLAPI SerializePacket(int dir, PPAmountTypePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI GetFormula(PPID id, SString & rBuf);
};
//
// @ModuleDecl(PPObjOprType)
// Типы операций
//
struct PPOprType2 {        // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_OPRTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	char   Pict[8];        //
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPOprType);

class PPObjOprType : public PPObjReference {
public:
	SLAPI  PPObjOprType(void * extraPtr);
	//virtual int SLAPI Edit(PPID *, long);
};
//
// @ModuleDecl(PPObjOpCounter)
// @todo Создать отдельную таблицу Seq для хранения значений счетчиков (вместо PPOpCounter2::Counter)
//
#define OPCNTF_LOCKINCR    0x00000001L // Не изменять значение счетчика при получении очередной величины
#define OPCNTF_DIFFBYLOC   0x00000002L // Счетчики, рездельные по складам

struct PPOpCounter2 {      // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_OPCOUNTER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // @symb
	char   CodeTemplate[24]; // Шаблон нумерации
	char   Reserve[32];    // @reserve
	PPID   ObjType;        // Тип объекта, владеющего счетчиком. Если 0, то PPOBJ_OPRKIND
	long   Flags;          // OPCNTF_XXX
	long   Counter;        //
	long   OwnerObjID;     // Объект-владелец счетчика (если 0, то может принадлежать более чем одной операции)
		// Если OwnerObjID == -1, то счетчик принадлежит конфигурации объекта ObjType
};

DECL_REF_REC(PPOpCounter);

class PPOpCounterPacket {
public:
	SLAPI  PPOpCounterPacket();
	SLAPI ~PPOpCounterPacket();
	PPOpCounterPacket & FASTCALL operator = (const PPOpCounterPacket &aPack);
	int    SLAPI Init(const PPOpCounter *, const LAssocArray *);
	int    SLAPI Init(const LAssocArray *);
	int    SLAPI CopyUnnamed(const PPOpCounterPacket *);
	int    SLAPI GetCounter(PPID locID, long * pCounter);
	int    SLAPI SetCounter(PPID locID, long counter);
	int    SLAPI CounterIncr(PPID locID, long * pCounter, int incr = 1);
	int    SLAPI UngetCounter(PPID locID, long counter);
	int    SLAPI ResetAll();

	PPOpCounter Head;
	LAssocArray * P_Items;
	enum {
		fDontLogUpdAction = 0x0001, // Функция PutPacket не фиксирует событие изменения объекта.
			// Эта опция используется при автоматическом увеличении счетчика функцией PPObjOpCounter::
		fDontUpdCounter   = 0x0002  // Функция PutPacket не изменяет значение счетчика
	};
	long   Flags;
};

class PPObjOpCounter : public PPObjReference {
public:
	static int SLAPI ResetAll();

	SLAPI  PPObjOpCounter(void * extraPtr = 0);
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI Edit(PPID *, void * extraPtr);
	//int    SLAPI SetItem(PPID * pID, PPOpCounterPacket * pPack, int use_ta); // @<<::Convert301()
	int    SLAPI CodeByTemplate(const char * pTempl, long counter, SString & rBuf);
	int    SLAPI CheckCodeTemplate(const char * pTempl, size_t bufSize);
	int    SLAPI UpdateCounter(PPID id, long counter, long flags, PPID locID, int use_ta);
		// @<<PPObjBill::UpdateOpCounter
	int    SLAPI GetCounter(PPID id, PPID locID, long * pCounter, int use_ta);
	int    SLAPI GetCode(PPID id, long * pCounter, char * pBuf, size_t buflen, PPID locID, int use_ta);
	int    SLAPI UngetCounter(PPID id, long counter, PPID locID, int use_ta);
	int    SLAPI PutPacket(PPID *pOpCntrID, const PPOpCounterPacket *, int use_ta);
	int    SLAPI GetPacket(PPID opCntrID, PPOpCounterPacket *); // AHTOXA
private:
	virtual int SLAPI MakeReserved(long flags);
	int    SLAPI Helper_GetCounter(PPID id, PPID locID, long * pCounter, SString * pCodeBuf, int use_ta);
};
//
// @ModuleDecl(PPObjGoodsClass)
// Классы товаров
//
struct PPGdsClsProp {
	SLAPI  PPGdsClsProp();
	PPGdsClsProp & FASTCALL operator = (const PPGdsClsProp &);
	void   SLAPI Init();

	char   Name[32];
	PPID   ItemsListID;
};

struct PPGdsClsDim {
	SLAPI  PPGdsClsDim();
	PPGdsClsDim & FASTCALL operator = (const PPGdsClsDim &);
	void   SLAPI Init();
	int    SLAPI ToStr(int, char *, size_t);
	int    SLAPI FromStr(int, const char *);

	char   Name[32];
	long   Scale;
	PPIDArray ValList;
};

struct PPGdsCls2 {         // @persistent @store(Reference2Tbl+)
	static int   SLAPI IsEqByDynGenMask(long mask, const GoodsExtTbl::Rec * p1, const GoodsExtTbl::Rec * p2);
	static long  FASTCALL UseFlagToE(long useFlag);
	static long  FASTCALL EToUseFlag(long e);

	void   SLAPI SetDynGenMask(int fld, int val);
	int    SLAPI GetDynGenMask(int fld) const;

	enum { // @persistent
		eKind  = 1,
		eGrade = 2,
		eAdd   = 3,
		eX     = 4,
		eY     = 5,
		eZ     = 6,
		eW     = 7,
		eAdd2  = 8
	};
	enum { // @persistent
		fUsePropKind    = 0x0001,
		fUsePropGrade   = 0x0002,
		fUsePropAdd     = 0x0004,
		fUseDimX        = 0x0008,
		fUseDimY        = 0x0010,
		fUseDimZ        = 0x0020,
		fStdEditDlg     = 0x0100, // Используется стандартный, а не редуцированный диалог
			// редактирования товаров, относящихся к классу
		fDupCombine     = 0x0200, // Комбинации {PropKind, PropGrade, DimX, DimY, DimZ}
			// могут дублироваться //
		fDisableFreeDim = 0x0400, // Запрет на ввод размерностей не перечисленных в списке
		fUseDimW        = 0x0800, // Использует размерность W
		fUsePropAdd2    = 0x1000, // Использует свойство Add2
		fPrintDiffLots  = 0x2000  // @v8.7.9 При печати разделять строки, относящиеся к разным лотам
	};

	long   Tag;            // Const=PPOBJ_GOODSCLASS
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve // @v8.9.1 [32]-->[24]
	PPID   LotDimUnitID;   // @v8.9.1 Единица измерения для размерностей лота
	uint8  LotDimCount;    // @v8.9.1 Количество размерностей лота [0..3]
	uint8  Reserve3;       // @v8.9.1 @reserve
	uint16 Reserve4;       // @v8.9.1 @reserve
	PPID   DefGrpID;       // Группа товара по умолчанию. Используется в случае создания товара только по параметрам расширения.
	PPID   DefUnitID;      //
	PPID   DefPhUnitID;    //
	long   DefPhUPerU;     // @unused
	PPID   DefTaxGrpID;    //
	PPID   DefGoodsTypeID; //
	uint16 EditDlgID;      //
	uint16 FiltDlgID;      //
	long   Flags;          //
	long   Reserve2;       // @reserve
	long   DynGenMask;     // Маска динамического обобщения. Флаги маски соответствуют
		// элементам перечисления (1<<(PPGdsCls::eXXX-1)). Если система видит обобщенный товар G с
		// параметрами расширения, соответствующими маске, эквивалентными некоторому товару X,
		// то считает, что X принадлежит G.
};

DECL_REF_REC(PPGdsCls);

struct PPGdsClsFormula {
	void   SLAPI Clear();
	int    FASTCALL PutToBuffer(SString & rBuf) const;
	int    FASTCALL GetFromBuffer(const char * pBuf);
	enum {
		fDefault = 0x0001 // Формула по умолчанию (в диалоге расчета, если
			// существует более одной формулы, эта формула устанавливается автоматом //
	};
	SString Name;
	SString Formula;
	SString Var1Name; // "@1"
	SString Var2Name; // "@2"
	SString Var3Name; // "@3"
	long   Flags;
};

struct PPGdsClsPacket {
	SLAPI  PPGdsClsPacket();
	PPGdsClsPacket & FASTCALL operator = (const PPGdsClsPacket &);
	void   SLAPI Init();
	int    FASTCALL Copy(const PPGdsClsPacket &);
	int    SLAPI CompleteGoodsPacket(PPGoodsPacket *);
	int    SLAPI GetPropName(int prop, SString & rBuf) const;
	int    SLAPI FormatProp(const PPGdsClsProp *, PPID propVal, SString & rBuf) const;
	int    SLAPI FormatDim(const PPGdsClsDim *, long dimVal, SString & rBuf) const;
	int    SLAPI GetNameByTemplate(PPGoodsPacket *, const char * pTemplate, char * pBuf, size_t bufLen, SubstGrpGoods sgg = sggNone) const;
	int    SLAPI PropNameToID(int prop, const char * pName, PPID * pID, int forceCreate, int use_ta);
	int    SLAPI PropSymbToID(int prop, const char * pSymb, PPID * pID);
	int    SLAPI GetExtDim(const GoodsExtTbl::Rec * pRec, int dim, double * pVal) const;
	int    SLAPI GetExtProp(const GoodsExtTbl::Rec * pRec, int prop, long * pID, SString & rBuf) const;
	int    SLAPI RealToExtDim(double realVal, int dim, long * pLongVal) const;
	int    SLAPI RealToExtDim(double realVal, int dim, GoodsExtTbl::Rec & rExtRec) const;
	int    SLAPI GetDynGenFilt(const GoodsExtTbl::Rec * pRec, ClsdGoodsFilt * pFilt) const;
	//
	// Формулы индексируются в списке от единицы (1..)
	//
	int    SLAPI PutFormula(int * pIdx, const PPGdsClsFormula *);
	int    SLAPI GetFormula(int idx, PPGdsClsFormula *) const;

	int    SLAPI PutFormulaListToBuf(SString & rBuf) const;
	int    SLAPI GetFormulaListFromBuf(const char *);
	//
	// Descr: Устанавливает у формулы, находящейся в позиции pos списка FormulaList
	//   флаг PPGdsClsFormula::fDefault. Одновременно снимает (если установлен) этот
	//   флаг у остальных формул списка.
	// ARG(idx IN): @#[1..FormulaList.getCount()] Индекс формулы в списке.
	//
	int    SLAPI SetDefaultFormula(int idx);

	PPGdsCls Rec;
	SString NameConv;
	SString AbbrConv;
	SString PhUPerU_Formula;
	SString TaxMult_Formula;
	SString Package_Formula;
	SString LotDimQtty_Formula; // @v8.9.10 Формула пересчета размерностей лота в количество
	PPGdsClsProp PropKind;
	PPGdsClsProp PropGrade;
	PPGdsClsProp PropAdd;
	PPGdsClsProp PropAdd2;
	PPGdsClsDim  DimX;
	PPGdsClsDim  DimY;
	PPGdsClsDim  DimZ;
	PPGdsClsDim  DimW;
	SStrCollection FormulaList; // Список формул
private:
	int    SLAPI CheckForSgg(long sym, SubstGrpGoods sgg) const; // AHTOXA
		// @<<PPGdsClsPacket::GetNameByTemplate
};

class PPObjGoodsClass : public PPObjReference {
public:
	SLAPI  PPObjGoodsClass(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID *, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);

	int    SLAPI GetPacket(PPID, PPGdsClsPacket *);
	int    SLAPI PutPacket(PPID *, PPGdsClsPacket *, int use_ta);
	int    SLAPI Fetch(PPID id, PPGdsClsPacket *); // AHTOXA
	//
	// Descr: Печатает список классов по структуре GoodsClassView
	// ARG(id IN): Не используется //
	//
	int    SLAPI Print(PPID /*id*/);
private:
	static int SLAPI PutProp(SString & rLineBuf, uint fldID, PPGdsClsProp *);
	static int SLAPI GetProp(SString & rLineBuf, uint fldID, PPGdsClsProp *);
	static int SLAPI PutPropsToLine(SString & rLine, PPGdsClsPacket * pPack);
	static int SLAPI GetPropsFromLine(SString & rLine, PPGdsClsPacket * pPack);
	static int SLAPI SerializeDim(int dir, PPGdsClsDim * p, SBuffer & rBuf, SSerializeContext * pSCtx);

	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack*);

	int    SLAPI PutDim(PPID gdsClsID, PPID propID, PPGdsClsDim *);
	int    SLAPI GetDim(PPID gdsClsID, PPID propID, PPGdsClsDim *);
	int    SLAPI ReplacePropRefList(PPID prevObjType, PPID newObjType, LAssocArray * pAssc, LAssocArray * pBadRefList);
		// @<<PPObjGoodsClass::UpdatePropObjType
	int    SLAPI UpdatePropObjType(PPID clsID, int gcProp, PPID prevObjType, PPID newObjType, LAssocArray * pBadRefList);
		// @<<PPObjGoodsClass::Edit
	int    SLAPI SerializePacket(int dir, PPGdsClsPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// @ModuleDecl(PPObjAssetWrOffGrp)
// Группы списания основных средств
//
#define AWOGT_AMRTZ_LIN   1L // Линейное списание амортизации
#define AWOGT_AMRTZ_ACCEL 2L // Ускоренное списание амортизации
#define AWOGT_INDIRCOST   3L // Списание непрямых издержек как прямых

struct PPAssetWrOffGrp2 {  // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_ASSTWROFFGRP
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Code[20];       // Код нормы амортизационных отчислений
	char   Reserve[48];    // @reserve
	long   WrOffType;      // Тип списания (AWOGT_XXX)
	long   WrOffTerm;      // Months
	long   Limit;          // Предельная остаточная стоимость (% от начальной стоимости)
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPAssetWrOffGrp);

class PPObjAssetWrOffGrp : public PPObjReference {
public:
	SLAPI  PPObjAssetWrOffGrp(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID *, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjOprKind)
// Виды операций
//
//
// Флаги видов операций
//
#define OPKF_NEEDPAYMENT     0x00000001L // Операция требует платежного документа
#define OPKF_GRECEIPT        0x00000002L // Приход товара
#define OPKF_GEXPEND         0x00000004L // Расход товара
#define OPKF_BUYING          0x00000008L // Номинал операции в ценах поступления //
#define OPKF_SELLING         0x00000010L // Номинал операции в ценах реализации  //
#define OPKF_NOUPDLOTREST    0x00000020L // Товарная операция, не изменяющая остаток по лоту
#define OPKF_ADVACC          0x00000040L // Бухгалтерская операция, позволяющая документу содержать строки расширения //
#define OPKF_PROFITABLE      0x00000080L // Операция доходная //
#define OPKF_ONORDER         0x00000100L // Операция продажи, допускающая продажу по заказу
#define OPKF_FREIGHT         0x00000200L // Операция поддерживает ввод данных фрахта
#define OPKF_PCKGMOUNTING    0x00000400L // Расходная операция только для формирования пакетов
#define OPKF_ORDEXSTONLY     0x00000800L // В заказах видны только те товары, которые есть на остатке
#define OPKF_ORDRESERVE      0x00001000L // Резервирующий заказ
#define OPKF_CALCSTAXES      0x00002000L // Считать налоги с продаж (НДС и акциз)
#define OPKF_CHARGENEGPAYM   0x00004000L // Начисление ренты интерпретировать как отрицательную оплату основного документа
#define OPKF_AUTOWL          0x00008000L // Автоматическая метка в документе
#define OPKF_ATTACHFILES     0x00010000L // Присоединять файлы к документам
#define OPKF_USEPAYER        0x00020000L // Использовать поле PPBill::Payer плательщика
#define OPKF_ORDERBYLOC      0x00040000L // Заказ привязан к складу (заказ от подразделения)
#define OPKF_NEEDVALUATION   0x00080000L // Операция требует расценки @only(PPOPT_GOODSRECEIPT)
#define OPKF_OUTBALACCTURN   0x00100000L // Забалансовая бух проводка
#define OPKF_EXTACCTURN      0x00200000L // Расширенная бух проводка
#define OPKF_EXTAMTLIST      0x00400000L // Операция поддерживает список доп сумм
#define OPKF_DENYREVALCOST   0x00800000L // Не допускается переоценка цен поступления @only(PPOPT_GOODSREVAL)
#define OPKF_RENT            0x01000000L // С документом может быть ассоциирован договор ренты
#define OPKF_NEEDACK         0x02000000L // Документ требует подтверждения      //
#define OPKF_NOCALCTIORD     0x04000000L // Не расчитывать заказ товара в строках документа
#define OPKF_RECKON          0x08000000L // Операция используется как платежная //
#define OPKF_BANKING         0x10000000L // Банковский платежный документ
#define OPKF_PASSIVE         0x20000000L // Пассивная операция (не видна в списках выбора)
#define OPKF_CURTRANSIT      0x40000000L // Транзитная валютная операция        //
#define OPKF_RESTRICTBYMTX   0x80000000L // Ограничивать выбор товара по операции товарной матрицей
#define OPKF_GOODS           (OPKF_GRECEIPT|OPKF_GEXPEND)
//
// Расширенные флаги видов операций
//
#define OPKFX_RESTRICTPRICE  0x00000001L // Ограничивать цену реализации формулой
#define OPKFX_ALLOWPARTSTR   0x00000002L // Допускается распределение частичных структур по документам
#define OPKFX_UNLINKRET      0x00000004L // @v7.1.10 Непривязанный возврат (от покупателя или поставщику)
	// Специализированный флаг, не используемый в учете, но лишь для расчета лимита возвратов.
#define OPKFX_USESUPPLDEAL   0x00000008L // @v7.2.11 (для драфт-приходов) При вводе строки применять контрактную цену
	// поставщика как цену поступления.
#define OPKFX_CANBEDECLINED  0x00000010L // @v8.3.3 (для драфт-документов) Допускается функция отклонения документа
#define OPKFX_MCR_GROUP      0x00000020L // @v8.8.6 Ограничение комплементарности позиций в документе модификации (общая группа)
#define OPKFX_MCR_SUBSTSTRUC 0x00000040L // @v8.8.6 Ограничение комплементарности позиций в документе модификации (подстановочная структура)
#define OPKFX_MCR_EQQTTY     0x00000080L // @v8.8.7 Ограничение комплементарности позиций в документе модификации (одинаковое количество)
#define OPKFX_DSBLHALFMODIF  0x00000100L // @v9.0.0 Запрет "половинчатой" модификации. То есть, в документе модификации
	// должны быть и вход и выход
#define OPKFX_DLVRLOCASWH    0x00000200L // @v9.1.10 Адрес доставки в приходных (и драфт-приходных) документах трактовать как склад-получатель
#define OPKFX_SOURCESERIAL   0x00000400L // @v9.3.6 (драфт-приходы и модификация)  Допускает выбор серийного номера исходного лота

#define OPKF_PRT_INCINVC     0x00000001L // Входящая счет-фактура на предоплату
#define OPKF_PRT_NEGINVC     0x00000002L // Счет-фактура с отрицательными суммами
#define OPKF_PRT_CHECK       0x00000004L // Печатать чек по документу
#define OPKF_PRT_CHECKTI     0x00000008L // Печатать чек по документу с товарными строками
#define OPKF_PRT_SRVACT      0x00000010L // Печатать акт выполненных работ
#define OPKF_PRT_BUYING      0x00000020L // Печатать в ценах поступления //
#define OPKF_PRT_SELLING     0x00000040L // Печатать в ценах реализации  //
#define OPKF_PRT_EXTOBJ2OBJ  0x00000080L // В структуре GoodsBillBase вместо object подставлять extobject
#define OPKF_PRT_TARESALDO   0x00000100L // Печатать сальдо по таре (только если определено PPGoodsConfig::TareGrpID)
#define OPKF_PRT_QCERT       0x00000200L // Печатать сертификаты
#define OPKF_PRT_NBILLN      0x00000400L // В первичном документе не печатать номер
#define OPKF_PRT_VATAX       0x00000800L // В накладной печатать колонки НДС
#define OPKF_PRT_INVOICE     0x00001000L // Печатать счет-фактуру
#define OPKF_PRT_QCG         0x00004000L // Печатать сертификаты с товаром
#define OPKF_PRT_SHRTORG     0x00010000L // Печатать сокращ. наименование гл. организации
#define OPKF_PRT_CASHORD     0x00080000L // Печатать кассовый ордер
#define OPKF_PRT_SELPRICE    0x00100000L // Печать цен в накладной на выбор
#define OPKF_PRT_NDISCNT     0x00800000L // Не печатать скидку в накладной
#define OPKF_PRT_PAYPLAN     0x02000000L // Печатать план платежей по документу
#define OPKF_PRT_LADING      0x04000000L // Печатать товарно-транспортную накладную
#define OPKF_PRT_MERGETI     0x08000000L // Объединять товарные строки
#define OPKF_PRT_PLABEL      0x10000000L // Печатать ценник
#define OPKF_PRT_BCODELIST   0x20000000L // Печатать в накладной список штрихкодов
#define OPKF_PRT_QCERTLIST   0x40000000L // Печатать список сертификатов
#define OPKF_PRT_LOTTAGIMG   0x80000000L // Печать изображений из тегов лотов

#define OPKF_PRT_EXTFORMFLAGS (OPKF_PRT_CASHORD|OPKF_PRT_INVOICE|OPKF_PRT_QCERT|OPKF_PRT_LADING|OPKF_PRT_SRVACT|OPKF_PRT_PLABEL|OPKF_PRT_TARESALDO|OPKF_PRT_LOTTAGIMG)

#define OPSUBT_COMMON                 0 // Без подтипа (поведение определяется по типу операции и по флажкам)
#define OPSUBT_ADVANCEREP             1 // PPOPT_ACCTURN      Авансовый отчет
#define OPSUBT_REGISTER               2 // PPOPT_ACCTURN      Регистровая общая проводка (автоматом снимает признак OPKF_EXTACCTURN)
#define OPSUBT_ASSETRCV               3 // PPOPT_GOODSRECEIPT Приобретение основных средств
#define OPSUBT_ASSETEXPL              4 // PPOPT_GOODSREVAL   Ввод в эксплуатацию основных средств
#define OPSUBT_WARRANT                5 // Доверенность
#define OPSUBT_ASSETMODIF             6 // Модификация основных средств
#define OPSUBT_DEBTINVENT             7 // Инвентаризация задолженности
#define OPSUBT_TRADEPLAN              8 // План торговли (драфт-операции)
#define OPSUBT_ACCWROFF               9 // PPOPT_ACCTURN Списание по бухгалтерским счетам
//
// Descr: Заголовочная запись вида операций
//
struct PPOprKind2 {        // @persistent @store(Reference2Tbl+)
	SLAPI  PPOprKind2()
	{
		THISZERO();
	}

	long   Tag;            // Const=PPOBJ_OPRKIND
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	PPID   InitStatusID;   // Статус для новых документов
	long   ExtFlags;       // Расширенные флаги
	int16  Rank;           //
	int16  Reserve2;       // @reserve
	PPID   LinkOpID;       //
	PPID   AccSheet2ID;    //
	PPID   OpCounterID;    //
	long   PrnFlags;       //
	PPID   DefLocID;       //
	int16  PrnOrder;       //
	int16  SubType;        // OPSUBT_XXX
	long   Flags;          // OPKF_XXX
	PPID   OpTypeID;       //
	PPID   AccSheetID;     //
};

DECL_REF_REC(PPOprKind);
//
// Дополнительная информация об операции инвентаризации
//
#define INVOPF_COSTNOMINAL       0x0001L // Номинал в ценах поступления (иначе в ценах реализации)
#define INVOPF_ZERODEFAULT       0x0002L // Остаток по умолчанию нулевой
#define INVOPF_WROFFWODSCNT      0x0004L // Списание без скидки
#define INVOPF_USEPACKS          0x0008L // Использовать параметры упаковки при вводе
#define INVOPF_SELGOODSBYNAME    0x0010L // Выбирать товары по полному наименованию, а не по сокращению
#define INVOPF_USEANOTERLOCLOTS  0x0020L // При списании излишков использовать информацию о лотах с других складов
#define INVOPF_INVBYCLIENT       0x0040L // Инвентаризация по клиенту (не списывается)
#define INVOPF_ACCELADDITEMS     0x0080L // Ускоренное добавление позиций по штрихкоду
#define INVOPF_ASSET             0x0100L // Инвентаризация по основным средствам (в обычную инвентаризацию основные средства не входят)
#define INVOPF_USESERIAL         0x0200L // Использовать серийные номера в строках инвентаризации
#define INVOPF_ACCELADDITEMSQTTY 0x0400L // @v9.7.6 Ускоренное добавление позиций по штрихкоду с количеством

struct PPInventoryOpEx {   // @persistent @store(PropertyTbl)
	SLAPI  PPInventoryOpEx();
	static int FASTCALL Helper_GetAccelInputMode(long flags);
	int    SLAPI GetAccelInputMode() const;
	void   SLAPI SetAccelInputMode(int mode);

	enum { // Методы расчета цен
		acmLIFO     = 0,
		acmFIFO,
		acmAVG
	};
	enum { // Методы автозаполнения //
		afmPresents = 0,
		afmAll,
		afmPrev,
		afmByCurLotRest // По текущим остаткам лотов
	};
	enum { // Методы ускоренного ввода строк
        accsliNo = 0,      // Нет
        accsliCode,        // Ввод кода с автоматическим количеством равным 1
        accsliCodeAndQtty  // Ввод кода с дополнительным вводом количества
	};
	PPID   Tag;              // Const=PPOBJ_OPRKIND
	PPID   ID;               // ->Ref(PPOBJ_OPRKIND)
	PPID   Prop;             // Const=OPKPRP_INVENTORY
	PPID   WrDnOp;           // Операция списания недостач
	PPID   WrDnObj;          // Контрагент списания недостач
	PPID   WrUpOp;           // Операция списания излишков
	PPID   WrUpObj;          // Контрагент списания излишков
	int16  Reserve1;         //
	int16  AmountCalcMethod; // Метод расчета цен
	int16  AutoFillMethod;   // Метод автозаполнени
	int16  Reserve2;         //
	char   Reserve3[40];     //
	long   Flags;            // INVOPF_XXX
	long   Reserve4;         //
};
//
// Descr: Дополнительная запись инвентаризации задолженности
//
struct PPDebtInventOpEx {    // @persistent @store(PropertyTbl)
	PPID   Tag;              // Const=PPOBJ_OPRKIND
	PPID   ID;               // ->Ref(PPOBJ_OPRKIND)
	PPID   Prop;             // Const=OPKPRP_DEBTINVENT
	PPID   WrDnOp;           // Операция покрытия долга
	PPID   WrUpOp;           // Операция покрытия переплаты
	PPID   WrDnGoodsID;      // Товар, используемый для товарных документов покрытия долга
	PPID   WrUpGoodsID;      // Товар, используемый для товарных документов покрытия переплаты
	long   Reserve1[6];      // @reserve
	long   Flags;            // @flags
	long   Reserve2;         // @reserve
};
//
// Дополнительные опции зачетной операции
//
#define ROXF_BEGISBILLDT     0x0001L // Началом периода является дата платежного док-та
#define ROXF_ENDISBILLDT     0x0002L // Концом периода является дата платежного док-та
#define ROXF_AUTOPAYM        0x0004L // Автоматически зачитывать платежные док-ты
#define ROXF_CFM_PAYM        0x0008L // Подтверждать зачет платежного док-та
#define ROXF_AUTODEBT        0x0010L // Автоматически зачитывать долговые док-ты
#define ROXF_CFM_DEBT        0x0020L // Подтверждать зачет долгового документа
#define ROXF_THISLOCONLY     0x0040L // Зачитывать документы только по тому же складу
#define ROXF_BYEXTOBJ        0x0080L // Reckon by BillTbl::Object2
	// (forward reckoning only) if Object2 == 0, then use Object
#define ROXF_REQALTOBJ       0x0100L // If !automat then request user for alternate object for reckoning
#define ROXF_THISALTOBJONLY  0x0200L // Зачитывать документы только по той же дополнительной статье документа
	// Если доп статья нулевая, то зачитывать только на нулевые доп статьи

#define ROX_HDR_DW_COUNT     8

struct PPReckonOpEx {
	SLAPI  PPReckonOpEx();
	void   SLAPI Init();
	int    SLAPI IsEmpty() const;
	PPReckonOpEx & FASTCALL operator = (const PPReckonOpEx &);
	int    SLAPI GetReckonPeriod(LDATE debtDate, DateRange *) const;
	int    SLAPI GetDebtPeriod(LDATE paymDate, DateRange *) const;
	int    SLAPI PeriodToStr(SString & rBuf) const;
	int    SLAPI StrToPeriod(const char *);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	LDATE  Beg;
	LDATE  End;
	long   Flags;           //
	PPID   PersonRelTypeID; // Тип персонального отношения, используемый для коллективного зачета
	long   Reserve[4];      // @reserve
	PPIDArray OpList;       // Список операций оплат, применяемых для зечета этой операции
};
//
// Дополнительные опции драфт-операций
//
#define DROXF_CREMPTYBILL      0x0001L // Вместо списания создавать пустой документ
#define DROXF_USEPARTSTRUC     0x0002L // Списывать частичные структуры в документах списания //
#define DROXF_WROFFCURDATE     0x0004L // Документ списания формировать текущей системной датой
#define DROXF_DONTINHEXPIRY    0x0008L // При списании драфт-документа в приходный документ
	// не наследовать срок годности из строк драфт-документа.
#define DROXF_MULTWROFF        0x0010L // Документ допускает множественное списание (то есть, к одному
	// драфт-документу может быть привязано несколько документов списания).
#define DROXF_MULTDRFTWROFF    0x0020L // @v8.8.11 Списание драфт-прихода в модификацию осуществляется таким образом, что
	// на каждую строку исходного документа генерируется отдельный документ модификации
#define DROXF_SELSUPPLONCOMPL  0x0040L // @v9.1.12 При компенсации дефицита запрашивать поставщиков приходуемого товара

struct PPDraftOpEx {
	SLAPI  PPDraftOpEx();
	void   SLAPI Init();
	PPDraftOpEx & FASTCALL operator = (const PPDraftOpEx &);

	PPID   WrOffOpID;       // Операция списания                        //
	PPID   WrOffObjID;      // Контрагент для операции списания //
	PPID   WrOffComplOpID;  // Операция комплектации, для формирования остатков, списываемых операцией WrOffOpID
	long   Reserve[10];     //
	long   Flags;           // DROXF_XXX
};
//
// Дополнительные опции операции пула документов
//
#define BPOXF_ONEOP          0x0001L // Объединять только по одной операции
#define BPOXF_ONEDATE        0x0002L // Объединять только по одной дате
#define BPOXF_ONEOBJECT      0x0004L // Объединять только по одному контрагенту
#define BPOXF_UNITEACCTURNS  0x0008L // Объединять бухгалтерские проводки
#define BPOXF_UNITEPAYMENTS  0x0010L // Объединять оплаты

#define BPOX_HDR_DW_COUNT    17

struct PPBillPoolOpEx {
	SLAPI  PPBillPoolOpEx();
	void   SLAPI Init();
	PPBillPoolOpEx & FASTCALL operator = (PPBillPoolOpEx &);

	long   Reserve[16];
	long   Flags;        // BPOXF_XXX
	PPIDArray OpList;
};
//
// Специфические флаги доступа PPObjOprKind (в дополнение к общим RT_XXX)
//
#define OPKRT_MODIFYATT      0x0100 // Право модификации шаблонов проводок
#define OPKRT_MODIFYOPTIONS  0x0200 // Право модификации опций
#define OPKRT_MODIFYCOUNTER  0x0400 // Право модификации счетчика
//
// Коды дополнительных строковых значений вида операции
//
// Дополнительные строковые поля вида операции хранятся в таблице Property
// с координатами {PPOBJ_OPRKIND; OpID; OPKPRP_EXTSTRDATA} в следующем формате:
// "<id1> string1 <id2> string2 ... "
// Если строка не содержит служебные коды <id>, то для совместимости с
// предыдущими версиями вся эта строка интерпретируется как шаблон примечания.
//
// Example: "<1>This is memo for bill of some op<2>Bank"
//
#define OPKEXSTR_MEMO        1 // Шаблон примечания //
#define OPKEXSTR_OBJ2NAME    2 // Наименование дополнительного объекта
#define OPKEXSTR_DEFPRNFORM  3 // Печатная форма документа по умолчанию
#define OPKEXSTR_AMTFORMULA  4 // Формула для вычисления номинальной суммы
#define OPKEXSTR_ATTCHFILEXT 5 // Расширения присоединяемых файлов
#define OPKEXSTR_EXPSYMB     6 // Символ вида операции, используемый при экспорте документов.
	// Papyrus не использует и никак не проверяет этот атрибут, но позволяет передать его внешним приложениям.
//
// Флаги элемента обобщенной операции
//
#define GOIF_NEGATIVE        0x0001 // В отчетах значения, соответствующие этой операции вычитаются //

typedef TSArray <PPAccTurnTempl> PPAccTurnTemplArray;

class PPOprKindPacket {
public:
	SLAPI  PPOprKindPacket();
	SLAPI ~PPOprKindPacket();
	int    SLAPI Init();
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char *);
	PPOprKindPacket & FASTCALL operator = (const PPOprKindPacket & rSrc);

	PPOprKind Rec;
	PPIDArray Amounts;
	PPAccTurnTemplArray ATTmpls;
	SString ExtString;
	PPInventoryOpEx  * P_IOE;
	ObjRestrictArray * P_GenList;
	PPReckonOpEx     * P_ReckonData;
	PPBillPoolOpEx   * P_PoolData;  //
	PPDraftOpEx      * P_DraftData; //
	PPDebtInventOpEx * P_DIOE;      //
	PPOpCounterPacket OpCntrPack;   //
};
//
// Флаги функции PPObjOprKind::MakeOprKindList
//
#define OPKLF_OPLIST        0x0001 // В переданном списке перечислены виды операций, иначе - типы)
#define OPKLF_SHOWPASSIVE   0x0002 // Показывать пассивные операции
#define OPKLF_IGNORERIGHTS  0x0004 // Игнорировать права доступа по операциям
#define OPKLF_FIXEDLOC      0x0008 // @v8.5.3 Специальная опция для BillPrelude - блокирует возможность измененя склада

class PPObjOprKind : public PPObjReference {
public:
	static int SLAPI GetATTemplList(PPID opID, PPAccTurnTemplArray * pList);
	static StrAssocArray * SLAPI MakeOprKindList(PPID linkOp, const PPIDArray *, uint flags /* OPKLF_XXX */);

	SLAPI  PPObjOprKind(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID*, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI Edit(PPID *, long opTypeID, long linkOpID);
	//
	// Descr: Вызывает диалог редактирования пакета вида операции.
	//   Может изменить поля пакета даже в том случае, если пользователь не нажал [OK]
	//   Проверяет уникальность имени пакета обращением к функции PPObjReference::CheckDupName.
	//
	int    SLAPI EditPacket(PPOprKindPacket *);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI GetExtStrData(PPID opID, int fldID, SString & rBuf);
	int    SLAPI GetExAmountList(PPID, PPIDArray *);
	int    SLAPI GetGenericList(PPID, ObjRestrictArray *);
	int    SLAPI GetGenericList(PPID, PPIDArray *);
	int    SLAPI GetReckonExData(PPID, PPReckonOpEx *);
	int    SLAPI GetPoolExData(PPID, PPBillPoolOpEx *);
	int    SLAPI GetDraftExData(PPID, PPDraftOpEx *);
	int    SLAPI GetPacket(PPID, PPOprKindPacket *);
	int    SLAPI PutPacket(PPID *, PPOprKindPacket *, int use_ta);
	int    SLAPI FetchInventoryData(PPID, PPInventoryOpEx *);

	int    SLAPI GetPaymentOpList(PPID linkOpID, PPIDArray *);
	//
	// Descr: Возвращает список видов операций, требующих оплаты и связанных
	//   с таблицей статей accSheetID.
	//   Операции относящиеся к типу PPOPT_GOODSORDER пропускаются, если
	//   в конфигурации установлена опция CCFLG_IGNOREORDERSDEBT.
	//   Если accSheetID == -1, то извлекаются все виды операций, требующие
	//   оплаты (с учетом флага конфигурации CCFLG_IGNOREORDERSDEBT).
	//
	int    SLAPI GetPayableOpList(PPID accSheetID, PPIDArray * pList);
	int    SLAPI GetProfitableOpList(PPID accSheetID, PPIDArray * pList);

	int    SLAPI GetEdiRecadvOp(PPID * pID, int use_ta);
	int    SLAPI GetEdiStockOp(PPID * pID, int use_ta);
	int    SLAPI GetEdiShopChargeOnOp(PPID * pID, int use_ta);
	int    SLAPI GetEdiWrOffShopOp(PPID * pID, int use_ta);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack*);
	virtual int  SLAPI MakeReserved(long flags);
	int    SLAPI SetReckonExData(PPID, PPReckonOpEx *, int use_ta);
	int    SLAPI SetPoolExData(PPID, PPBillPoolOpEx *, int use_ta);
	int    SLAPI SetDraftExData(PPID id, const PPDraftOpEx * pData);
	int    SLAPI SerializePacket(int dir, PPOprKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	struct ReservedOpCreateBlock {
		SLAPI  ReservedOpCreateBlock();
		PPID   OpID;
		PPID   OpTypeID;
		uint   NameTxtId;
		PPID   AccSheetID; // @v9.4.8
		long   Flags;
		const char * P_Symb;
		const char * P_CodeTempl;
	};

	int    SLAPI Helper_GetReservedOp(PPID * pID, const ReservedOpCreateBlock & rBlk, int use_ta);
};
//
// Descr: возвращает запись PPOprKind, соответствующую идентификатору вида операции opID.
//   Возвращаемая запись извлекается из кэша, поэтому, не все поля в ней заполнены так,
//   как в базе данных (Name не определено). Параметр pData может быть равен нулю. В случае ошибки
//   возвращает 0.
//
int    FASTCALL GetOpData(PPID opID, PPOprKind * pData);
//
// Descr: Через кэш извлекает запись вида операции по символу pSymb.
//
int    FASTCALL GetOpBySymb(const char * pSymb, PPOprKind * pData);
int    FASTCALL GetOpName(PPID opID, char * buf, size_t buflen); // @obsolete use GetOpName(PPID opID, SString &)
int    FASTCALL GetOpName(PPID opID, SString &);
//
// Descr: проверяет флаги операции opID по следующему алгоритму:
//   if (GetOpData(oprKind) == 0) return 0;
//   if (andF && (Flags & andF) != andF) return 0;
//   if (notF && (Flags & notF) == notF) return 0;
//   In another cases return 1;
//
int    FASTCALL CheckOpFlags(PPID opID, long andF, long notF = 0);
int    FASTCALL CheckOpPrnFlags(PPID opID, long andF);
PPID   FASTCALL GetOpType(PPID opID, PPOprKind * = 0);
int    FASTCALL GetOpSubType(PPID opID);
int    FASTCALL GetOpList(PPID opTypeID, PPIDArray * pList);
//
// Descr: возвращает (>0) если операция op принадлежит типу
//   PPOPT_GENERIC, (<0) если op == 0 и (0) в противном случае.
//
int    FASTCALL IsGenericOp(PPID opID);
//
// Descr: возвращает параметром pList список операций,
//   обобщаемых операцией opID. Если opID == 0 или opID не является обобщенной
//   операцией, то возвращается (<0). Если возникла ошибка, то возвращается 0.
//
int    FASTCALL GetGenericOpList(PPID opID, ObjRestrictArray * pList);
//
// Descr: Редуцированный вариант предыдущей функции. Возвращает только список операций без флагов.
//
int    FASTCALL GetGenericOpList(PPID opID, PPIDArray * pList);
int    FASTCALL IsOpBelongTo(PPID testOpID, PPID anotherOpID);
int    SLAPI GetOpCommonAccSheet(PPID opID, PPID * pAccSheetID, PPID * pAccSheet2ID);
//
// Descr: Утилитная функция. Определяет, является ли операция возвратом либо
//   оплатой. Эта проверка используется весьма часто.
// Returns:
//   0 - вид операции не является ни оплатой, ни возвратом
//  !0 - тип операции, к которому относится операция opID (PPOPT_PAYMENT || PPOPT_GOODSRETURN || PPOPT_CHARGE).
//
PPID   FASTCALL IsOpPaymOrRetn(PPID opID);
//
// Descr: Определяет, является ли операция оплатой.
//   Отличается от IsOpPaymOrRetn только тем, что для операции возврата возвращает 0.
//
int    FASTCALL IsOpPaym(PPID opID);
//
// Descr: Если операция товарная и оценивается в ценах реализации, то функция IsSellingOperation
//   возвращает (> 0), если товарная и оценивается в ценах поступления, то 0, для нетоварных операций
//   возвращает (< 0).
//
int    FASTCALL IsSellingOp(PPID);
//
// Descr: по спецификации идентична IsSellingOp. Существенная разница в том, что IsSellingOp извлекает ответ
//   из состояния флажка OPKF_SELLING структуры PPOprKind, а _IsSellingOp дает ответ полагаясь на
//   подразумеваемые свойства зарезервированных видов и типов операций. Функция _IsSellingOp необходима
//   лишь в редких случаях. Например для оценки корректности установки вышеозначенного флажка в диалоге пользователем.
//
int    FASTCALL _IsSellingOp(PPID);
int    FASTCALL IsExpendOp(PPID);
//
#define INTREXPND 1
#define INTRRCPT  2
//
// Descr: определяет является ли операция межскладской передачей. Если возвращаемое значение равно 0,
//   то ответ отрицательный. Если 1 - то межскладской расход, 2 - межскладской приход.
//   Признаком межскладской операции является условие: (Op(o).AccSheet == LConfig.LocSheet) &&
//     (Op(o)::Type == PPOPT_GOODSEXPEND || Op(o)::Type == PPOPT_GOODSRECEIPT).
//
int    FASTCALL IsIntrOp(PPID opID);
int    FASTCALL IsIntrExpndOp(PPID opID); // {IsIntrOp(opID) == INTREXPND}
int    FASTCALL IsDraftOp(PPID opID);
int    FASTCALL IsGoodsDetailOp(PPID opID);
int    SLAPI EnumOperations(PPID oprType, PPID *, PPOprKind * = 0);
PPID   SLAPI GetCashOp();
PPID   SLAPI GetCashRetOp();
PPID   SLAPI GetReceiptOp();
//
// Descr: возвращает ИД операции, если она единственная принадлежит
//   заданному типу oprType. Если существует более одной такой операции,
//   то возвращается <0. Если вообще нет таких операций, то возвращается 0.
//
PPID   FASTCALL GetSingleOp(PPID oprType);
//
// Descr: Возвращает список зачетных операций
//
int    FASTCALL GetReckonOpList(PPIDArray *);
//
// @ModuleDecl(PPObjBillStatus)
// Статусы документов
//
#define BILSTF_DENY_MOD               0x0001 // Документы нельзя модифицировать
#define BILSTF_DENY_DEL               0x0002 // Документы нельзя удалять
#define BILSTF_DENY_TRANSM            0x0004 // Документы нельзя передавать в другой раздел
#define BILSTF_DENY_CHANGELINK        0x0008 // Связанные документы нельзя изменять
#define BILSTF_DENY_RANKDOWN          0x0010 // Нельзя изменять статус документа до статуса, имеющего меньший ранг, чем текущий
#define BILSTF_LOCK_ACCTURN           0x0020 // Для документов этого статуса не проводить бух проводки
#define BILSTF_LOCK_PAYMENT           0x0040 // Не учитывать документ как оплату
#define BILSTF_LOCDISPOSE             0x0080 // @v7.2.0 Автоматически размещать товарный документ по ячейкам склада после
	// установки этого статуса.
#define BILSTF_READYFOREDIACK         0x0100 // @v8.8.0 Документ с таким статусом готов к отправке по нему подтверждения провайдеру EDI
//
// Флаги обязательности атрибутов документа
//
#define BILCHECKF_AGENT           0x00000001 //
#define BILCHECKF_PAYER           0x00000002 //
#define BILCHECKF_DLVRADDR        0x00000004
#define BILCHECKF_PORTOFLOADING   0x00000008
#define BILCHECKF_PORTOFDISCHARGE 0x00000010
#define BILCHECKF_ISSUEDT         0x00000020
#define BILCHECKF_ARRIVALDT       0x00000040
#define BILCHECKF_SHIP            0x00000080
#define BILCHECKF_FREIGHTCOST     0x00000100
#define BILCHECKF_OBJECT          0x00000200
#define BILCHECKF_CAPTAIN         0x00000400
#define BILCHECKF_TRBROKER        0x00000800
#define BILCHECKF_OBJECT2         0x00001000 // @v7.0.4
#define BILCHECKF_DUEDATE         0x00002000 // @v8.3.5
#define BILCHECKF_CODE            0x00004000 // @v8.5.2 Проверка не не пустой номер документа
#define BILCHECKF_FREIGHT         (BILCHECKF_DLVRADDR|BILCHECKF_PORTOFLOADING|BILCHECKF_PORTOFDISCHARGE|\
	BILCHECKF_ARRIVALDT|BILCHECKF_SHIP|BILCHECKF_FREIGHTCOST|BILCHECKF_CAPTAIN|BILCHECKF_TRBROKER)

struct PPBillStatus2 {     // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_BILLSTATUS
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символ статуса
	char   Reserve[48];    // @reserve
	PPID   CounterID;      // Счетчик, по которому назначается номер документа при присвоении данного статуса
	PPID   RestrictOpID;   // Вид операции (возможно, обобщенный) документам которого может быть присвоен данный статус.
	int16  Rank;           //
	int16  Reserve2;       // @alignment
	long   Flags;          // BILSF_XXX
	long   CheckFields;    // BILCHECKF_XXX Обязательные поля документа
	long   Reserve3;       // @reserve
};

DECL_REF_REC(PPBillStatus);

class PPObjBillStatus : public PPObjReference {
public:
	SLAPI  PPObjBillStatus(void * extraPtr = 0);
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Fetch(PPID id, PPBillStatus * pRec);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
};
//
// Descr: Размерность расчета долгов
//
struct PPDebtDim {
	long   Tag;            // Const=PPOBJ_DEBTDIM
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ размерности
	uint8  Reserve[64];    // @reserve
	long   Reserve2[2];    // @reserve
};

struct PPDebtDimPacket {
	SLAPI  PPDebtDimPacket();

	PPDebtDim Rec;
	ObjIdListFilt AgentList;
};

class PPObjDebtDim : public PPObjReference {
public:
	//
	// Descr: Вызывает диалог выбора размерности
	//
	static PPID SLAPI Select();

	SLAPI  PPObjDebtDim();
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, PPDebtDim * pRec);
	int    SLAPI FetchAgentList(LAssocArray * pList);
	int    SLAPI Dirty(PPID id);
	int    SLAPI GetPacket(PPID id, PPDebtDimPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPDebtDimPacket * pPack, int use_ta);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);

	int    SLAPI SerializePacket(int dir, PPDebtDimPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
//
//
class PPObjSecur : public PPObjReference {
public:
	enum {
		maskUserGroup = 0x08000000,
		maskConfig    = 0x10000000,
		maskUER       = 0x20000000,
		mask          = (maskUserGroup|maskConfig|maskUER)
	};
	struct ExtraParam {
		ExtraParam();
		ExtraParam & FASTCALL operator = (const ExtraParam & rS);
		int    IsConsistent() const;

		enum {
			fShowAll       = 0x0001, // Флаг для отображения в списке всех типов объектов Secur
			fSelectNewType = 0x0002  // При создании нового объекта предписывает предлагать выбор типа объекта (группа, пользователь, UER)
		};
		const  uint32 Signature; // @anchor Специальный признак, идентифицирующий то, что по указателю находится именно этот объект
        PPID   Type;
        PPID   ParentID;
        long   Flags;
	};
	class Exclusion {
	public:
		Exclusion(int exclrt);
		~Exclusion();
	private:
		enum {
			stMerged = 0x0001
		};
		long   State;
		PPRights Preserve;
	};
	SLAPI  PPObjSecur(PPID aObj, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int  SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  SLAPI ProcessReservedItem(TVRez &);
	int    SLAPI AssignPrivateDesktop(PPID userID, PPID desktopID, const char * pDeskName, int use_ta);
	int    SLAPI GetPrivateDesktop(PPID userID, PPID * pDesktopID);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Name, Flags, PersonID, ParentID}
	//
	int    SLAPI Fetch(PPID id, PPSecur *);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI AssignImages(ListBoxDef * pDef);

	ExtraParam SelectorP; // Блок параметров, с которым был вызван последний Selector.
		// Необходим для правильной обработки UpdateSelector
};
//
// @ModuleDecl(PPObjBizScore)
//
//
// Флаги значений бизнес-показателей
//
#define BISCVF_BOUNDLOW  0x0001 // Значение выходит за нижнюю допустимую границу
#define BISCVF_BOUNDUPP  0x0002 // Значение выходит за верхнюю допустимую границу

class BizScoreCore : public BizScoreTbl {
public:
	SLAPI  BizScoreCore();
	int    SLAPI Search(LDATE actualDate, PPID scID, PPID objID, BizScoreTbl::Rec * pRec);
	int    SLAPI SetItem(LDATE actualDate, PPID scID, PPID userID, long flags, double val, int use_ta);
	int    SLAPI SetItem(LDATE actualDate, PPID scID, PPID userID, const char * pStr, int use_ta);
	int    SLAPI SetItem(LDATE actualDate, PPID scID, PPID userID, PPObjID obj, const char * pStr, int use_ta);
	int    SLAPI DeleteItem(LDATE actualDate, PPID scID, PPID objID, int use_ta);
};

int SLAPI GetBizScoresVals(const char * pUserName, const char * pPassword, TcpSocket * pSock);

struct PPBizScore {
	SLAPI  PPBizScore();

	long   Tag;            // Const=PPOBJ_BIZSCORE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ показателя //
	char   Reserve[44];    // @reserve
	RealRange Bounds;      // Допустимые границы значения показателя //
	long   Flags;          // @flags
	long   UserID;         // ->Ref(PPOBJ_USR) Пользователь, которому принадлежит показатель
	long   Reserve2;       // @reserve
};

struct PPBizScorePacket {
	PPBizScore Rec;
	SString Descr;
	SString Formula;
};

class PPObjBizScore : public PPObjReference {
public:
	SLAPI  PPObjBizScore(void * extraPtr = 0);
	SLAPI ~PPObjBizScore();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr /*userID*/);
	virtual int  SLAPI Browse(void * extraPtr /*userID*/);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI Fetch(PPID, PPBizScorePacket *);
	int    SLAPI GetPacket(PPID id, PPBizScorePacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPBizScorePacket * pPack, int use_ta);
	int    SLAPI TestPacket(PPBizScorePacket * pPack, SString & rResult);
	int    SLAPI ReverseFormula(PPBizScorePacket * pPack, SString & rResult);
private:
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);

	DL2_Resolver * P_Resolver;
	BizScoreCore * P_ValTbl;
};
//
// @ModuleDecl(PPViewBizScore)
//
struct BizScoreFilt : public PPBaseFilt {
	SLAPI  BizScoreFilt();
	BizScoreFilt & FASTCALL operator = (const BizScoreFilt & s);

	uint8  ReserveStart[32]; // @anchor
	PPID   UserID;
	long   Flags;
	long   Order;
	SString DescrPattern;    // @anchor
	SString FormulaPattern;
};

struct BizScoreViewItem {
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	PPID   UserID;
	long   Flags;
	char   Descr[256];
	char   Formula[256];
};

class PPViewBizScore : public PPView {
public:
	SLAPI  PPViewBizScore();

	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BizScoreViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI OnExecBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * SLAPI GetEditExtraParam();

	BizScoreFilt Filt;
	PPObjBizScore BscObj;
};

class PrcssrBizScore {
public:
	struct Param { // @persistent
	public:
		SLAPI  Param();
		void   SLAPI Init();
		int    SLAPI Read(SBuffer & rBuf, long);
		int    SLAPI Write(SBuffer & rBuf, long);
		enum {
			fExportXml = 0x0001, // Экспортировать данные в XML сразу после расчета
			fSendToFTP = 0x0002  // Отправить данные на FTP сервер
		};
		uint32 Ver;
		PPID   FtpAcctID;
		uint8  Reserve[24]; // @reserve @v7.8.2 [28]-->[24]
		PPID   BzsID;       // @v7.8.2 Идентификатор единственного показателя, который следует рассчитать
		DateRange Period;
		long   Flags;
		long   Reserve2;    // @reserve
	private:
		static const uint32 CVer;
	};
	SLAPI  PrcssrBizScore();
	SLAPI ~PrcssrBizScore();
	int    SLAPI InitParam(Param *);
	int    SLAPI EditParam(Param *);
	int    SLAPI Init(const Param *);
	int    SLAPI Run();
private:
	int    SLAPI Helper_Calc(LDATE actualDate, PPLogger & rLogger, int use_ta);

	BizScoreCore Tbl;
	DL2_Resolver * P_Resolver;
	Param P;
};

struct BizScoreValFilt : public PPBaseFilt {
	SLAPI  BizScoreValFilt();
	BizScoreValFilt & FASTCALL operator = (const BizScoreValFilt & s);

	uint8  ReserveStart[32]; // @anchor
	DateRange Period;        // Период расчетной даты
	PPID   UserID;           // ->Ref(PPOBJ_USR)
	PPID   BizScoreID;       // ->Ref(PPOBJ_BIZSCORE)
	LDATETIME Since;         // Отбираются записи, измененные с момента Since
	long   Flags;            //
	long   Order;            //
	long   Reserve;          // @anchor
};

struct BizScoreValTotal {
	long   Count;
	double Sum;
};

typedef BizScoreTbl::Rec BizScoreValViewItem;

class PPViewBizScoreVal : public PPView {
public:
	static int SLAPI SendXml(PPID ftpAcctID, const char * pFilePath); // Отправка xml файла на FTP-сервер

	SLAPI  PPViewBizScoreVal();
	SLAPI ~PPViewBizScoreVal();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BizScoreValViewItem *);
	int    SLAPI CheckForFilt(const BizScoreTbl::Rec * pRec) const;
	int    SLAPI CalcTotal(BizScoreValTotal * pTotal);
	int    SLAPI ViewGraph();
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);

	BizScoreCore Tbl;
	BizScoreValFilt Filt;
};
//
// Descr: Структура для транзитного хранения глобального значения бизнес-показателя //
//
struct GlobalBizScoreVal {
	S_GUID LocalDbUuid;
	long   LocalUserID;
	LDATE  ActualDate;
	LDATETIME Dtm;
	long   LocalScoreID;
	long   Flags;          // BISCVF_XXX
	SString LocalScoreName;
	SString LocalScoreDescr;
	SString StrVal;
	double Val;
};

struct PPGlobalUserAcc;

class GlobalBizScoreArray : public TSCollection <GlobalBizScoreVal> {
public:
	SLAPI  GlobalBizScoreArray();
	int    Add(const PPGlobalUserAcc & rGuaRec, const GlobalBizScoreTbl::Rec & rRec);
};
//
// Descr: Таблица для хранения и извлечения глобальных значений бизнес-показателей
//
class GlobalBizScoreCore : public GlobalBizScoreTbl {
public:
	SLAPI  GlobalBizScoreCore();
	int    SLAPI SetItem(long counter, const GlobalBizScoreVal & rVal, int use_ta);
	int    SLAPI SetList(const GlobalBizScoreArray & rList, int use_ta);
	int    SLAPI GetLastList(PPID globalUserID, GlobalBizScoreArray * pList);
};
//
// @ModuleDecl(PPObjGlobalUserAcc)
//
struct PPGlobalUserAccConfig {
	enum {
		fValid = 0x0001 // @transient Структура извлечена из базы данных
	};
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_GLOBALUSERACCCFG
	long   Flags;          // @flags
	PPID   PersonKindID;   // ->Ref(PPOBJ_PRSNKIND)    Вид персоналии, используемый для владельцев записей.
	PPID   SCardSerID;     // ->Ref(PPOBJ_SCARDSERIES) Серия кредитных карт, используемая для учета тарифицируемых транзакции по аккаунту.
	char   Reserve1[52];   // @reserve
	long   Reserve2[2];    // @reserve
};

struct PPGlobalUserAcc {
	long   Tag;            // Const=PPOBJ_GLOBALUSERACC
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ //
	S_GUID LocalDbUuid;    // GUID локальной базы данных
	char   Password[40];   // Пароль (зашифрован и свернут в строку кодировкой MIME64)
	long   Reserve;        // @reserve
	long   Flags;          // @flags
	long   LocalUserID;    // Ид пользователя, относительно локальной базы данных
	PPID   PersonID;       // -->Person.ID
};
//
// @v7.2.3
//
class PPGlobalUserAccPacket {
public:
	SLAPI  PPGlobalUserAccPacket();
	int    FASTCALL IsEqual(const PPGlobalUserAccPacket & rS) const;

	PPGlobalUserAcc Rec;
	ObjTagList   TagL;        // Список тегов
};

class PPObjGlobalUserAcc : public PPObjReference {
public:
	static int SLAPI ReadConfig(PPGlobalUserAccConfig * pCfg);
	static int SLAPI EditConfig();

	SLAPI  PPObjGlobalUserAcc(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Fetch(PPID id, PPGlobalUserAcc * pRec);
	int    SLAPI PutPacket(PPID * pID, PPGlobalUserAccPacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPGlobalUserAccPacket * pPack);
	int    SLAPI SerializePacket(int dir, PPGlobalUserAccPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI SearchByLocalID(const S_GUID & rDbUuid, PPID localUserID, PPID * pID, PPGlobalUserAcc * pRec);
	//
	// Descr: Ищет записи, ассоциированные с персоналией personID и возвращает их идентификаторы в
	//   массиве rList.
	// Returns:
	//   >0 - найдена одна или более искомых записей
	//   <0 - не найдено ни одной записи, ассоциированной с персоналией personID
	//   0  - ошибка
	//
	int    SLAPI SearchByAssociatedPersonID(PPID personID, PPIDArray & rList);
	int    SLAPI CheckPassword(const char * pName, const char * pPassword, PPGlobalUserAcc * pUserAcc = 0);
	int    SLAPI Register(PPID & ID, const char * pName, const char * pPassword, const S_GUID & rDbUuid, PPID localUserID, PPID personID);
	int    SLAPI Unregister(const char * pName, const char * pPassword);
	int    SLAPI ChangePassword(const char * pName, const char * pOldPassword, const char * pNewPassword);
	int    SLAPI FetchConfig(PPGlobalUserAccConfig * pCfg);
	int    SLAPI DirtyConfig();
protected:
	virtual void SLAPI Destroy(PPObjPack*);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
};
//
//
// @Muxa {
//
class PPGlobalAccRights {
public:
	enum {
		fAccess       = 0x0001,   // A Разрешен доступ
		fCreate       = 0x0002,   // C Разрешено создание
		fEdit         = 0x0004,   // E Разрешено изменение
		fDelete       = 0x0008,   // D Разрешено удаление
		fOperation    = 0x0010,   // O Разрешено оперирование объектом
		fAccessByID   = 0x0020,   // I только для автономных адресов @v8.3.2
		fAccessBySymb = 0x0040    // S только для автономных адресов @v8.3.2
	};
	static int SLAPI EditDialog(PPID tagID, SString & rLine);

	SLAPI  PPGlobalAccRights(const int tagID);
	SLAPI  PPGlobalAccRights(const SString & rStr);
	SLAPI ~PPGlobalAccRights();
	int    SLAPI IsAllow(int flags, const char * pScope = "@def") const;
private:
	int    SLAPI Parse(const SString & rStr);
	struct Rec {
		Rec()
		{
			Scope[0] = 0;
			Flags = 0;
		}
		char  Scope[128];
		int   Flags;
	};
	TSArray <Rec> Recs;
};
// }
//
// PPViewGlobalUser
//
class GlobalUserAccFilt : public PPBaseFilt {
public:
	SLAPI  GlobalUserAccFilt();
	GlobalUserAccFilt & FASTCALL operator = (const GlobalUserAccFilt &);

	char   ReserveStart[24];
	char   Reserve[256];
	long   ReserveEnd;
};

typedef PPGlobalUserAcc GlobalUserAccViewItem;

class PPViewGlobalUserAcc : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewGlobalUserAcc();
	SLAPI ~PPViewGlobalUserAcc();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GlobalUserAccViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList);
	int    SLAPI MakeTempEntry(const PPGlobalUserAcc * pRec, TempGlobUserAccTbl::Rec * pTempRec);
	int    SLAPI CheckForFilt(const PPGlobalUserAcc * pRec) const;

	GlobalUserAccFilt  Filt;
	PPObjGlobalUserAcc ObjGlobAcc;
	TempGlobUserAccTbl * P_TempTbl;
};
//
// @ModuleDecl(GtaJournal)
// Учет тарифицируемых транзакций глобальных учетных записей.
//
#define GTAOP_NOOP               0
#define GTAOP_OBJGET             1
#define GTAOP_OBJADD             2
#define GTAOP_OBJMOD             3
#define GTAOP_OBJRMV             4
#define GTAOP_CCHECKCREATE       5
#define GTAOP_SCARDWITHDRAW      6
#define GTAOP_FILEUPLOAD         7
#define GTAOP_FILEDOWNLOAD       8
#define GTAOP_BILLCREATE         9
#define GTAOP_SMSSEND           10
#define GTAOP_SCARDDEPOSIT      11
#define GTAOP_LAST              11

struct PPGta {
	PPGta()
	{
		THISZERO();
	}
	int    Op;
	PPID   GlobalUserID;
	PPObjID ObjId;
	LDATETIME Dtm;
	long   Count;
	long   Duration;
	//
	PPID   SCardID;        // @*PPObjBill::InitGta Кредитная карта, ассоциированная с глобальной учетной записью
	double Quot;           // @*PPObjBill::InitGta Стоимость транзакции
	double SCardRest;      // @*PPObjBill::InitGta Остаток на карте SCardID на момент инициализации.
		// Извлекается только в том случае, если Quot != 0.0
	double SCardMaxCredit; // @*PPObjBill::InitGta Максимальный кредит по карте SCardID на момент инициализации.
		// Извлекается только в том случае, если Quot != 0.0
};

class GtaJournalCore : public GtaJournalTbl {
public:
	SLAPI  GtaJournalCore();
	int    SLAPI CheckInOp(PPGta & rGta, int use_ta);
};
//
//
//
struct PPEdiProvider {
	SLAPI  PPEdiProvider();
	int    FASTCALL IsEqual(const PPEdiProvider & rS) const;

	enum {
		fPassive = 0x0001
	};
	long   Tag;            // Const=PPOBJ_EDIPROVIDER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символьный код единицы измерения //

	long   Flags;
	long   SuppOpFlags;    // Флаги поддерживаемый операций (1 << PPEDIOP_XXX)
	int32  AddrPort;       // IP-порт адреса
	int32  AddrPort2;      // IP-порт резервного адреса
	uint8  Reserve[48];
	PPID   GuaID;          // Ид глобальной учетной записи, используемой для авторизации
	long   Reserve2;
};

class PPEdiProviderPacket {
public:
	enum { // @persistent
		extssDllModuleName =  1,
		extssTempPath      =  2,
		extssAddr          = 11,
		extssAddr2         = 12,
	};

	SLAPI  PPEdiProviderPacket();
	SLAPI ~PPEdiProviderPacket();
	int    FASTCALL IsEqual(const PPEdiProviderPacket & rS) const;
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char *);

	PPEdiProvider Rec;
	SString ExtString;
};

class PPObjEdiProvider : public PPObjReference {
public:
	SLAPI  PPObjEdiProvider(void * extraPtr = 0);
	SLAPI ~PPObjEdiProvider();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPEdiProviderPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPEdiProviderPacket * pPack, int use_ta);
private:
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket(int dir, PPEdiProviderPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// @construction {
//
class PrcssrEdi {
public:
	enum {
		aUnkn = 0,
		aImportBill = 1,
	};
    struct Param {
		long   Flags;
		StringSet ProviderSymbList;
		LongArray ActionList;
    };
};
// } @construction
//
// @ModuleDecl(PPObjAccSheet)
// Таблицы аналитических статей
//
#define ACSHF_AUTOCREATART  0x0001L // Автоматически создавать статьи при создании объекта
#define ACSHF_USECLIAGT     0x0002L // Использует соглашения с клиентами
#define ACSHF_USEALIASSUBST 0x0004L // Использует подстановку алиасов счетов
#define ACSHF_USESUPPLAGT   0x0008L // Использует соглашения с поставщиками

struct PPAccSheet2 {       // @persistent @store(Reference2Tbl+)
	SLAPI  PPAccSheet2();
	void   SLAPI Init();

	long   Tag;            // Const=PPOBJ_ACCSHEET
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[52];   // @reserve
	PPID   BinArID;        // Статья для сброса остатков по закрываемым статьям
	PPID   CodeRegTypeID;  // ИД типа регистрационного документа, идентифицирующего персоналию, соответствующую статье.
	long   Flags;          // ACSHF_XXX
	long   Assoc;          // @#{0L, PPOBJ_PERSON, PPOBJ_LOCATION, PPOBJ_ACCOUNT} Ассоциированный объект
	long   ObjGroup;       // Подгруппа ассоциированных объектов
};

DECL_REF_REC(PPAccSheet);

class PPObjAccSheet : public PPObjReference {
public:
	SLAPI  PPObjAccSheet(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	// @v8.5.4 virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, PPAccSheet * pRec);
	int    SLAPI IsAssoc(PPID acsID, PPID objType, PPAccSheet *);
	int    SLAPI IsLinkedToMainOrg(PPID acsID);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	virtual int  SLAPI MakeReserved(long flags);
};
//
// @ModuleDecl(PPAbstractDevice)
//
//
// Классы устройств
// @persistent
// Наименования типов перечислены в строковом ресурсе PPTXT_ABSTRACTDEVICETYPENAMES
//
#define DVCCLS_UNKN             0 // Неопределенный тип (недопустимое значение)
#define DVCCLS_TOGGLE           1 // Переключатель
#define DVCCLS_SCALES           2 // Весы // @vmiller
#define DVCCLS_SYNCPOS          3 // Синхронные кассы // @vmiller
#define	DVCCLS_DISPLAY          4 // Дисплеи // @v7.9.6 DVCCLS_CUSTDISP-->DVCCLS_DISPLAY
#define DVCCLS_BNKTERM          5 // Банковские терминалы
#define DVCCLS_READER           6 // @v7.9.6 Считыватель
//
// Типы реализации драйверов устройств
//
#define DVCDRVIMPL_UNKN         0 // Неопределенный тип
#define DVCDRVIMPL_DLL          1 // DLL
//
// Команды устройств
//
#define DVCCMD_PING             1
#define DVCCMD_SETTEXT          2
#define DVCCMD_TOGGLE           3
//
// Теги параметров команд устройств
//
#define DVCCMDPAR_TEXT          1 // string
#define DVCCMDPAR_COUNT         2 // int
#define DVCCMDPAR_CARD          3 // string
#define DVCCMDPAR_CREDIT        4 // real
#define DVCCMDPAR_AMOUNT        5 // real
#define DVCCMDPAR_QTTY          6 // real
//
// Descr: Базовый класс для интерфейса с устройством.
//
class PPAbstractDevice {
public:
	//
	// Descr: Отправляет команду pCmd и необходимые параметры pInput устройству.
	// ARG(pCmd IN): Имя команды.
	// ARG(pInput IN): Список входных параметров. Представляет собой пары имя_параметра=значение_параемтра, перечисленные через ";".
	// ARG(pOutput OUT): Список выходных параметров или код ошибки. Список представляет собой пары имя_параметра=значение_параметра, перечисленных через ";".
	// ARG(outputBufSize IN): Размер буфера pOutput.
	// Returns:
	//		0 - нет ошибок
	//		1 - ошибка выполнения команды
	//		2 - недостаточный размер выходного буфера
	//
	typedef int (/*STDAPICALLTYPE*/ * ProcDevDll)(const char * , const char * , char * , size_t); // @vmiller заменила на CALLBACK

	struct Capability {
		long   Cls;
		long   Dvc; // @vmiller Определяет конкретное устройство из класса
		long   Flags;
		int16  DispLineSize;
		int16  DispLinesCount;
		SString DllName; // @vmiller
	};
	struct Command {
		int32  InnerId;
		int32  UnifyId;
		SString Symb;
		SString Text;
	};
	struct ConnectionParam {
		ConnectionParam();
		int    IsEqualAddr(const ConnectionParam & rParam) const;

		//char   Port[8];
		long   DeviceNo;
		PPID   DeviceID;
		CommPortParams Cpp;
		CommPortTimeouts Cpt;
		SString Address;
		SString DeviceName;
		int8   NotOwned;  // Not Owned P_Conn
		int8   ReleCount; // Кол-во срабатывний реле [0..255], 255 - удерживает аппарат на 6 секунд
		long   GoodsID;
		long   P_Conn;    // SComPort или TcpSocket
	};

	static int SLAPI CreateInstance(const char * pSymb, PPAbstractDevice ** ppDvc);
	//
	// Descr: Возвращает наименование и идентификатор секции файла ppdrv.ini по классу
	//   устройства dvcClass.
	// ARG(dvcClass IN): Класс устройсва DVCCLS_XXX
	// ARG(pReserveTypesStrId OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается значение идентификатора
	//   ресурса строки, содержащей перечисление зарезервированных типов устройств класса dvcClass.
	//   Если для заданного класса нет зарезервированных типов, то возвращается 0.
	// ARG(pSectName OUT): @#{vptr0} Если указатель не нулевой, то по нему присваивается текстовое наименование
	//   секции ppdrv.ini, содержащей определители драйверов устройсв.
	// Returns:
	//   >0 - идентификатор секции (PPINISECT_XXX)
	//   <0 - класс устройсва валидный, но идентификатор секции не определен. По адресу pSectName
	//     возвращается наименование секции.
	//   0  - инвалидный класс устройства
	//
	static int SLAPI GetDrvIniSectByDvcClass(int dvcClass, int * pReserveTypesStrId, SString * pSectName);
	//
	// Descr: Разбирает значение определителя драйвера устройства, описанное в ppdrv.ini.
	// Note: Определитель драйвера устройства в файле ppdrv.ini выглядит так:
	//   symbol=drv_name,drv_impl,drv_path
	//   Здесь:
	//     symbol - уникальный символ, идентифицирующий определитель драйвера
	//     drv_name - имя драйвера устройства
	//     drv_impl - тип реализации драйвера. Сейчас только DLL (DVCDRVIMPL_DLL)
	//     drv_path - путь к файлу dll или только имя файла (тогда файл ищется в стандартном каталоге драйверов)
	//
	// Returns:
	//   1 - строка содержит все необходимые термы
	//   2 - строка не содержит префикс symbol= (аргумент rSymbol обнуляется).
	//   0  - недопустимая строка определителя.
	//
	static int SLAPI ParseRegEntry(const char * pLine, SString & rSymbol, SString & rDrvName, SString & rDrvPath, int * pDrvImpl);

	PPAbstractDevice(const char * pDvcName);
	virtual ~PPAbstractDevice();
	virtual int GetCapability(Capability * pCpb);
	virtual int OpenConnection(const ConnectionParam &);
	virtual int CloseConnection();
	virtual int GetConnParam(ConnectionParam *);
	virtual int GetSessionPrice(PPObjGoods *, double *);
	virtual int RunCmd(int innerId, const StrAssocArray & rIn, StrAssocArray & rOut);

	//
	// Descr: метод для работы с dll-файлами устройств.
	// ARG(cmdID	IN): ID команды, которую должно выполнить устройство
	// ARG(rIn		IN): параметры, необходимые для выполнения команды
	// ARG(rOut	   OUT): результат выполнения команды (либо данные с устройства, лиюо сообщение об ошибке)
	// Returns:
	//  -1 - команда выполнена успешно, но устройство вернуло ошибку (код ошибки передается в rOut)
	//   0 - ошибка
	//   1 - успешное выполнение команды
	//
	int    RunCmd__(int cmdID, const StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
	int    RunCmd(const char * pCommandLine, StrAssocArray & rOut);
	int    GetDllName(int dvcClass, long devTypeId, SString & dllName); // @vmiller
	int    GetDllName(int dvcClass, const char * pName, SString & rDllName);
	int    IdentifyDevice(const char * pSymb); // @vmiller
	int    IdentifyDevice(int dvcClass, const char * pName);

	Capability PCpb; // @vmiller
protected:
	int    Helper_RunCmd(SString & rCmd, SString & rArg, StrAssocArray & rOut);

	enum {
		stError     = 0x0001,
		stConnected = 0x0002
	};
	class IdentBlock {
	public:
		IdentBlock();
		~IdentBlock();
		int operator !() const;
		void Release();
		int  Set(SDynLibrary * pLib, int setOwnership);

		ProcDevDll Func;
	private:
		SDynLibrary * P_Lib;
		int    IsLibOwner; // Если 0, то не разрушает объект P_Lib
	};
	IdentBlock Ib;
	long	State;
	SString DvcName;
	STempBuffer RetBuf; // @v9.7.6 Буфер для приема возвращаемой драйвером строки
};

extern "C" typedef PPAbstractDevice * (*FN_PPDEVICE_FACTORY)();

#define PPDEVICE_FACTORY(dvcSymb)  ADF_##dvcSymb
#define IMPLEMENT_PPDEVICE_FACTORY(dvcSymb) \
	extern "C" __declspec(dllexport) PPAbstractDevice * ADF_##dvcSymb() { return new dvcSymb(); }
//
//
//

//
// @ModuleDecl(PPObjCachNode)
//
// Флаги кассового узла
//
#define CASHF_DAYCLOSED           0x00000001L // Текущий день закрыт
#define CASHF_DAYSTARTED          0x00000002L // За день были сделаны проводки
#define CASHF_CHKPAN              0x00000004L // Для ввода чеков применяется кассовая панель (иначе - устаревшая техника микродокументов).
#define CASHF_NAFCL               0x00000008L // Не активизировать первую товарную строку чека
#define CASHF_OPENBOX             0x00000010L // (sync)  При печати чека открывать ящик
#define CASHF_LASTCHKCANCELLED    0x00000020L // (sync)  Печать последнего чека была прервана
#define CASHF_SELALLGOODS         0x00000040L // (sync)  Выбор товаров независимо от того, имеются они на остатке или нет
#define CASHF_ABOVEZEROSALE       0x00000080L // (sync) Не разрешать продажу если остаток не достаточен
//
// Следующие два флага взаимоисключающие. Если оба флага имеют одинаковое
// значение, то (а)синхронность кассового узла определяется неявным образом.
//
#define CASHF_SYNC                0x00000100L // Синхронный кассовый узел
#define CASHF_ASYNC               0x00000200L // Асинхронный кассовый узел
#define CASHF_EXPCHECKD           0x00000400L // (async) Export check digit of barcode
#define CASHF_EXTFRM349           0x00000800L // Запись переведена на формат @v3.4.9
#define CASHF_IMPORTCHECKSWOZR    0x00001000L // (async) Импортировать чеки независимо от наличия Z-отчета.
#define CASHF_DISROUNDUP          0x00002000L // (sync)  Округлять скидку в большую сторону
#define CASHF_DISROUNDDOWN        0x00004000L // (sync)  Округлять скидку в меньшую сторону
#define CASHF_EXPDIVN             0x00008000L // (async) Экспортировать в кассовый модуль номера отделов
#define CASHF_ROUNDINT            0x00010000L // (sync)  округлять %% скидку
	// при печати чека до целого
#define CASHF_EXPGOODSREST        0x00020000L // (async) Экспортировать товарные остатки
#define CASHF_AUTO_PRINTCOPY      0x00040000L // (sync)  Автоматически печатать копию чека
#define CASHF_USEQUOT             0x00080000L // (sync)  Использовать котировку в кассовой панели
	// Если этот флаг установлен, то при выборе товара в кассовой панели цена определяется по следующему алгоритму:
	// 1. Ищется базовая котировка по складу, к которому привязан кассовый узел
	// 2. Если на предыдущем шаге котировка не найдена, то ищется базовая котировка для всех складов
	// 3. Если на предыдущем шаге котировка не найдена, то используется обычное правило определение цены по лотам
#define CASHF_NOASKPAYMTYPE       0x00100000L // (sync)  не запрашивать вид оплаты
#define CASHF_SHOWREST            0x00200000L // (sync)  в панели ввода чеков показывать остаток
#define CASHF_KEYBOARDWKEY        0x00400000L // (sync)  используется клавиатура с ключом
#define CASHF_WORKWHENLOCK        0x00800000L // (sync)  разрешить работу с кассовой панелью при блокировке
#define CASHF_NOMODALCHECKVIEW    0x01000000L // (sync)  По команде "Чеки" после показа кассовой панели не показывать таблицу чеков
#define CASHF_DISABLEZEROAGENT    0x02000000L // (sync)  В панели чеков не разрешать проводить/откладывать/печатать чеки без явного указания агента
#define CASHF_EXPGOODSGROUPS      0x04000000L // (async) Экспортировать товарные группы
#define CASHF_NOTUSECHECKCUTTER   0x08000000L // (sync)  Не использовать отрезчик чеков
#define CASHF_UNIFYGDSATCHECK     0x10000000L // (sync)  Объединять одинаковые товары в чеке
#define CASHF_UNIFYGDSTOPRINT     0x20000000L // (sync)  Объединять одинаковые товары при печати
#define CASHF_SKIPUNPRINTEDCHECKS 0x40000000L // (sync)  При списании не учитывать "неотпечатанные" чеки
#define CASHF_CHECKFORPRESENT     0x80000000L // (sync)  Проверять на выдачу подарка
//
//
//
#define CASHFX_ROUNDAMTUP         0x00000001L // Округлять сумму вверх
#define CASHFX_ROUNDAMTDOWN       0x00000002L // Округлять сумму вниз
#define CASHFX_SELSERIALBYGOODS   0x00000004L // Предлагать выбор партии после выбора товара
#define CASHFX_FORCEDIVISION      0x00000008L // Не допускает проведение чека пока не будет выбран отдел
#define CASHFX_GLASSOCPRINTONLY   0x00000010L // Именованную ассоциацию товар-склад использовать только для печати
#define CASHFX_EXTSCARDSEL        0x00000020L // Улучшенный режим выбора дисконтной карты
#define CASHFX_EXPLOCPRNASSOC     0x00000040L // (async) Экспортировать символ ассоциированного
	// с товаром (посредством склада) локального принтера
#define CASHFX_UNITEGRPWROFF      0x00000080L // Объединенное списание сессий по кассовым узлам принадлежащим группе.
#define CASHFX_APPLYUNITRND       0x00000100L // (async) Применять дробность округления, заданную в единице измерения товара.
#define CASHFX_RESTRUSERGGRP      0x00000200L // (async) Ограничивать загрузку изменений только товарами, входящими в группу,
	// которой ограничен пользователь (PPAccessRestriction::OnlyGoodsGrpID)
#define CASHFX_SUSPLISTWODLVR     0x00000400L // @unused @v7.3.5 (sync) В списке отложенных чеков не показывать чеки с доставкой
#define CASHFX_RMVPASSIVEGOODS    0x00000800L // @v7.4.12 (async) Посылать модулю требование на удаление пассивных товаров
#define CASHFX_KEEPORGCCUSER      0x00001000L // @v7.5.6  (sync)  При отложении-восстановлении чеков сохранять оригинального
	// пользователя, создавшего чек.
#define CASHFX_CREATEOBJSONIMP    0x00002000L // @v7.6.8  (async) Создавать объекты при импорте чеков
#define CASHFX_PASSIVE            0x00004000L // @v7.6.9  Пассивный узел (не отображается в списках)
#define CASHFX_SEPARATERCPPRN     0x00010000L // @v7.9.7  (async) Загружать номера кассовых аппаратов
#define CASHFX_INPGUESTCFTBL      0x00020000L // @v8.0.12 (sync) После выбора стола требовать ввода количества гостей
#define CASHFX_DISABLEZEROSCARD   0x00040000L // @v8.2.3  (sync) Запрет операция без выбора персональной карты
#define CASHFX_UHTTORDIMPORT      0x00080000L // @v8.2.3  (sync) Импортировать заказа с сервера Universe-HTT
#define CASHFX_IGNLOOKBACKPRICES  0x00100000L // @v8.9.10 (async) Игноририровать обратный анализ доступных цены на специальные товары
#define CASHFX_ABSTRGOODSALLOWED  0x00200000L // @v9.5.10 (sync) Допускается прожажа абстрактного товара по цене (в конфигурации товаров
	// должен быть указан DefGoodsID).
#define CASHFX_EXTNODEASALT       0x00400000L // @v9.6.9 (sync) Дополнительный кассовый узел используется как альтернативный принтер
//
// Идентификаторы строковых свойств кассоых узлов.
// Attention: Ни в коем случае не менять значения идентификаторов - @persistent
//
#define ACN_EXTSTR_FLD_IMPFILES      1 // @persistent
#define ACN_EXTSTR_FLD_EXPPATHS      2 // @persistent
#define ACN_EXTSTR_FLD_LOGNUMS       3 // @persistent
#define SCN_EXTSTR_FLD_CUSTDISPPORT  4 // @persistent
#define SCN_PRINTERPORT              5 // @persistent
#define SCN_CAFETABLE_DGR_PATH       6 // @persistent
#define ACN_EXTSTR_FLD_ADDEDMSGSIGN  7 // @persistent
#define SCN_BNKTERMPATH              8 // @persistent
#define SCN_SLIPFMTPATH              9 // @persistent Путь к файлу описания slip-отчетов. Если не указан, то используется bin\stdslip.fmt
#define SCN_CASHDRAWER_PORT         10 // @persistent @v7.8.1
#define SCN_CASHDRAWER_CMD          11 // @persistent @v7.8.1
#define SCN_KITCHENBELL_PORT        12 // @persistent @v7.8.1
#define SCN_KITCHENBELL_CMD         13 // @persistent @v7.8.1
#define SCN_RPTPRNPORT              14 // @persistent @v8.8.3 Порт принтера для печати отчетов (предчеков)
#define SCN_MANUFSERIAL             15 // @persistent @v9.0.10 Заводской номер кассового аппарата
//
// Кассовый узел
//
class CashNodePaneFilt : public PPBaseFilt {
public:
	CashNodePaneFilt();

	long   ReserveStart;
	PPID   CashNodeID;
	long   CommandID;
	PPID   ParentID;
	char   Reserve[60];
	long   ReserveEnd;
};

struct PPCashNode2 {       // @persistent @store(Reference2Tbl+)
	//
	// Descr: Варианты специализации кассового узла
	//
	enum {
		spDefault = 0, // То же, что и spGeneral
		spGeneral = 1, // Общий.
		spCafe,        // Кафе (выбор столов, заказы столов, количество гостей и т.д.)
		spShop,        // Магазин (выбор отдела, подбор товара по цене и т.д.)
		spDelivery,    // Доставка
		spApteka       // Аптека
	};
	long   Tag;            // Const=PPOBJ_CASHNODE
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	uint16 DisRoundPrec;   // .01 @#{0..50000} Точность округления скидки //
	uint16 AmtRoundPrec;   // .01 @#{0..50000} Точность окрнугления результирующей суммы чека
	long   ExtFlags;       // CASHFX_XXX
	char   Port[8];        // Имя порта (LPT1, COM1, ...)
	PPID   GoodsLocAssocID; // Именованная ассоциация товар-склад, используемая для печати чеков и списания //
	uint16 SleepTimeout;   // Таймаут бездействия (сек), после которого панель блокируется //
	uint16 Speciality;     // PPCashNode::spXXX Специализация кассового узла
	PPID   CurRestBillID;  // Временный документ текущих остатков по незакрытым кассовым сессиям
	PPID   ParentID;       // Ссылка на родительскую группу
	PPID   GoodsGrpID;     // @v7.2.12 Товарная группа, которой следует ограничивать загрузку товаров в асинхр модуль либо
		// отбор товаров в синхронном узле. // Reserve4-->GoodsGrpID
	//
	// Поле DownBill имеет специальное назначение.
	// При закрытии синхронной кассовой сессии количество вбитых чеков может
	// быть настолько большим, что в рамках одной транзакции не удается //
	// собрать их все в один документ (ошибка Btrieve = 2). По-этому
	// каждый чек вливается в единый документ отдельной транзакцией. Но
	// если процесс был прерван в результате ошибки, то частично заполненный
	// новый документ остается. Поле DownBill как раз и сохраняет
	// идентификатор этого документа. После устранения ошибки процесс
	// закрытия кассовой сессии можно продолжить с этим документом.
	// В нормальной ситуации это поле всегда нулевое.
	//
	PPID   DownBill;       //
	PPID   CashType;       // Тип ККМ (PPCMT_XXX)
	long   LogNum;         // Логический номер кассы
	int16  DrvVerMajor;    //
	int16  DrvVerMinor;    //
	PPID   ExtQuotID;      // ->Ref(PPOBJ_QUOTKIND) Дополнительная котировка (используется некоторыми типами ККМ)
	LDATE  CurDate;        // Текущая операционная дата
	long   Flags;          // CASHF_XXX      Флаги
	long   LocID;          // ->Location.ID  Склад
	PPID   CurSessID;      // ->CSession.ID  Текущая кассовая сессия (для синхронных узлов)
};

DECL_REF_REC(PPCashNode);

class PPGenCashNode {        // @transient
public:
	struct DivGrpAssc {
		PPID   GrpID;        // ->Goods2.ID (GoodsGroup)
		short  DivN;         // Номер отдела
	};
	struct RoundParam {
		int    DisRoundDir;  // Направление округления скидки
		int    AmtRoundDir;  // Направление округления результирующей суммы чека
		double DisRoundPrec; // Точность округления скидки
		double AmtRoundPrec; // Точность округления результирующей суммы чека
	};
	struct PosIdentEntry {
		SLAPI  PosIdentEntry();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

        long   N;
        S_GUID Uuid;
        SString Name;
	};
	SLAPI  PPGenCashNode();
	virtual SLAPI ~PPGenCashNode();
	PPGenCashNode & FASTCALL operator = (const PPGenCashNode &);
	int    FASTCALL Copy(const PPGenCashNode & rS);
	int    SLAPI SetRoundParam(const RoundParam * pParam);
	int    SLAPI GetRoundParam(RoundParam * pParam) const;

	PPID   ID;               // @id
	char   Name[48];         // @name
	char   Symb[20];         //
	PPID   CurRestBillID;    // Временный документ текущих остатков по незакрытым кассовым сессиям
	PPID   CashType;         // Тип ККМ (PPCMT_XXX)
	int16  DrvVerMajor;      //
	int16  DrvVerMinor;      //
	uint16 DisRoundPrec;     // .01 @#{0..50000} Точность округления скидки //
	uint16 AmtRoundPrec;     // .01 @#{0..50000} Точность округления результирующей суммы чека
	PPID   LocID;            //
	PPID   ExtQuotID;        // ->Ref(PPOBJ_QUOTKIND) Дополнительная котировка
	long   Flags;            //
	long   ExtFlags;         //
	PPID   GoodsLocAssocID;  // Именованная ассоциация товар-склад, спользуемая для печати чеков и списания //
	PPID   ParentID;         // Группа кассовых узлов
	PPID   GoodsGrpID;       // Товарная группа, которой следует ограничивать загрузку товаров в асинхр модуль либо
		// отбор товаров в синхронном узле. // Reserve4-->GoodsGrpID
	SArray * P_DivGrpList;   // (move from PPAsyncCashNode)
	ObjTagList  TagL;        // @v9.6.5 @dbd_exchange Список тегов
};

class PPAsyncCashNode : public PPGenCashNode {
public:
	SLAPI  PPAsyncCashNode();
	PPAsyncCashNode & FASTCALL operator = (const PPAsyncCashNode &);
	int    FASTCALL Copy(const PPAsyncCashNode & rS);
	int    FASTCALL GetLogNumList(PPIDArray & rList) const;

	SString ExpPaths;
	SString ImpFiles;
	SString LogNumList;
	SString AddedMsgSign;    // Описание формы загрузки доп полей товара в кассовый модуль
	TSCollection <PosIdentEntry> ApnCorrList; // @v9.6.5
};

class PPSyncCashNode : public PPGenCashNode {
public:
	SLAPI  PPSyncCashNode();
	SString & SLAPI CTblListToString(SString & rBuf) const;
	int    SLAPI CTblListFromString(const char * pBuf);
	int    SLAPI SetPropString(int propId, const char * pValue);
	int    SLAPI GetPropString(int propId, SString & rBuf) const;
	enum {
		btfPinpad = 0x0001
	};
	enum {
		cdfUsb = 0x0001
	};
	//
	// Descr: Параметры фильтрации отложенных чеков в кассовой панели
	//
	struct SuspCheckFilt {
		SLAPI  SuspCheckFilt();
		int    SLAPI IsEmpty() const;
		enum {
			fNotSpFinished = 0x0001
		};
		uint16 DaysPeriod;
		int16  DlvrItemsShowTag; // 0 - показывать не зависимо от статуса доставки, <0 - только без доставки, >0 - только с доставкой
		long   Flags;       // @v9.7.5 @flags
		uint8  Reserve[28]; // @v9.7.5 [32]-->[28]
	};
	char   Port[8];          // Имя порта (LPT1, COM1, ...)
	PPID   DownBill;         //
	LDATE  CurDate;          // Текущая операционная дата
	PPID   CurSessID;        // ->Bill.ID Текущая кассовая сессия //
	PPID   TouchScreenID;    //
	PPID   ExtCashNodeID;    //
	//PPID   PapyrusNodeID_unused; // ИД кассового узла Папирус @v9.6.8 unused
	PPID   AlternateRegID;   // @v9.7.10 Явно обозначенный альтернативный регистратор
		// (if ExtFlags & CASHFX_EXTNODEASALT && !AlternateRegID) то альтернативным регистратором является ExtCashNodeID
	PPID   ScaleID;          //
	PPID   CustDispType;     // Тип дисплея покупателя //
	char   CustDispPort[8];  // Имя порта дисплея покупателя (COM)
	uint16 CustDispFlags;	 // cdfXXX
	int16  EgaisMode;        // @v9.0.9 Режим работы с УТМ ЕГАИС. 0 - не использовать, 1 - использовать, 2 - тестовый режим

	long   BnkTermType;		 // Тип банковского терминала
	uint16 BnkTermLogNum;	 // Логический номер банковского терминала
	uint16 BnkTermFlags;	 // btfXXX
	char   BnkTermPort[8];	 // Имя порта банковского терминала (COM)

	uint16 ClearCDYTimeout;  // Таймаут очистки дисплея покупателя после печати чека
	uint16 SleepTimeout;     //
	PPID   LocalTouchScrID;  // Локальный (по отношению к компютеру) идентификатор записи PPObjTouchScreen
	uint16 Speciality;       //
	uint16 BonusMaxPart;     // Максимальная часть чека, которая может быть оплачена бонусом
		// Ограничение хранится в промилле. Example: 152 = 15.2% от суммы чека
	PPID   PhnSvcID;         // Телефонный сервис (для обслуживания заказов столов и доставки)
	SuspCheckFilt Scf;       // Фильтр отображения списка отложенных чеков
	SString PrinterPort;     // Для печати напрямую на windows printer
	SString TableSelWhatman; // Имя файла ватмана для выбора стола кафе
	SString BnkTermPath;	 // Путь к промежуточной dll банковского терминала
	SString SlipFmtPath;     // Путь к файлу описания slip-отчетов
	SString ExtString;       // Строка, содержащая конфигурационные строки, которые могут быть извлечены вызовом GetPropString(int, SString &)
	LongArray CTblList;      // Список номеров столов
};

class PPObjCashNode : public PPObjReference {
public:
	struct SelFilt {
		SelFilt();

		enum {
			fSkipPassive  = 0x0001,
			fIgnoreRights = 0x0002 // @v8.9.4 Игнорировать список доступных кассовых узлов
		};
		PPID   LocID;
		int    SyncGroup;
		int    OnlyGroups; // -1 - кассовые узлы без групп, 0 - все, 1- только группы
		long   Flags;
		PPID   ParentID;
	};

	static int  SLAPI Lock(PPID);
	static int  SLAPI Unlock(PPID);
	static int  SLAPI IsLocked(PPID);
	static int  SLAPI IsExtCashNode(PPID nodeID, PPID * pParentID);
	//
	// Descr: Вызывает список выбора кассового узла. В списке отображаются узлы
	//   в соотвествии со следующими условиями:
	//   1. Если locID != 0, то только те, которые относятся к складу locID
	//   2. Если syncGroup == 1, то выбираются только синхронные узлы
	//   3. Если syncGroup == 2, то выбираются только асинхронные узлы
	//   4. Если syncGroup == 0, то выбор узла не зависит от признака синхронности
	//   5. Узлы, имеющие признак CASHFX_PASSIVE пропускаются // @v7.6.9
	//   Если существует только один кассовый узел, соответствующий заданным критериям,
	//   то он возвращается без отображения списка выбора. При этом, если параметр
	//   pSingle != 0, то по этому указателю присваивается 1.
	// ARG(locID     IN): если !0 то узлы фильтруются по принадлежности к складу locID
	// ARG(syncGroup IN): см. выше
	// ARG(pSingle  OUT): @#{vptr0} см.выше
	// ARG(isAny     IN): если этот параметр !0 то функция только проверяет
	//   наличие кассовых узлов, соответствующих заданным критериям.
	// Returns:
	//   0 - если ARG(isAny) == 0, то это означает ошибку, в противном случае -
	//       нет ни одного доступного узла, удовлетворяющего критериям.
	//  -1 - нет кассовых узлов, удовлетворяющих заданным критериям отбора либо
	//       пользователь отказался от выбора.
	//  !0 - если ARG(isAny) == 0, то возвращается ИД вбранного кассовго узла,
	//       в противном случае возвращается количество доступных кассовых узлов.
	//
	static PPID SLAPI Select(PPID locID, int syncGroup, int * pSingle = 0, int isAny = 0);
	//
	// Descr: Возвращает текст наименования стола с номером ctblN.
	//   Если в справочнике столов ресторанного зала PPOBJ_CAFETABLE есть запись с символом ctblN,
	//   то функция в буфер rBuf заносит наименование этой записи, в противном случае в rBuf
	//   заносится текстовое представление ctblN.
	// ARG(ctblN IN): @#{>0} номер стола
	// ARG(rBuf OUT): буфер, в который заносится наименование стола
	// Returns:
	//   1 - найдена запись PPOBJ_CAFETABLE с символом ctblN
	//   2 - запись PPOBJ_CAFETABLE с символом ctblN не найдена
	//   0 - ошибка (аргумент ctblN <= 0)
	//
	static int  SLAPI GetCafeTableName(int ctblN, SString & rBuf);
	static const int SubstCTblID; // Специализированный идентификатор стола, применяемый для замещения не определенного списка столов. =999

	SLAPI  PPObjCashNode(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {Tag, ID, Name, Symb, CashType, ExtQuotID, LocID, Flags }
	//
	int    SLAPI Fetch(PPID id, PPCashNode * pRec);
	int    SLAPI GetSync(PPID, PPSyncCashNode *);
	int    SLAPI GetAsync(PPID, PPAsyncCashNode *);
	int    SLAPI EditGroup(PPGenCashNode * pData);
	int    SLAPI EditDistrib(PPGenCashNode * pData);
	int    SLAPI Get(PPID, PPGenCashNode *, PPCashNode * = 0);
	int    SLAPI Put(PPID *, PPGenCashNode *, int use_ta);
	int    SLAPI Validate(PPGenCashNode * pRec, long);
	//
	// Descr: Возвращает список кассовых узлов, привязанных к складу locID.
	// Note: Функция не очищает массив rList. То есть, если до вызова в массиве были
	//   какие-либо элементы, то они там и остануться после выхода из функции.
	//
	//   Новые элементы в массив добавляются методом LongArray::addUnique по этому
	//   ни одного дубликата функция в массив не добавит (то есть, если их там не было,
	//   то и не появятся).
	//
	//   Функция предполагает, что locID - идентификатор терминального склада, а не
	//   группы складов и тем более не места хранения. То есть, вызывающая функция //
	//   должна позаботиться об этом (см. PPObjLocation::ResolveWarehouseList).
	//
	// ARG(locID  IN): ИД склада для которого ищутся привязанные кассовые узлы.
	// ARG(rList OUT): Массив, в который заносятся кассовые узлы, привязанные к locID.
	// Returns:
	//   >0 - существует по крайней мере один узел, привязанный к locID
	//   <0 - не существует ни одного узла, привязанного к locID
	//   0  - ошибка
	//
	int    SLAPI GetListByLoc(PPID locID, PPIDArray & rList);
	int    SLAPI GetListByGroup(PPID grpID, PPIDArray & rList);
	int    SLAPI ResolveList(const PPIDArray * pSrcList, PPIDArray & rDestList);
private:
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI EditSync(PPSyncCashNode *);
	int    SLAPI EditAsync(PPAsyncCashNode *);
	int    SLAPI Helper_ResolveItem(PPID id, PPIDArray & rDestList, LAssocArray & rFullList); // @recursion
};
//
// @ModuleDecl(PPCashMachine)
//
// Общий интерфейс к высокоуровневым операциям с кассовыми машинами
//
// Будем различать два класса интерфейсов с кассовыми машинами: синхронные и асинхронные.
//   Синхронный интерфейс предусматривает непосредственное подключение
// кассовой машины к компьютеру, на котором работает наша программа.
// Такой интерфейс как минимум должен уметь отпечатать чек и одновременно
// модифицировать фискальную память кассовой машины в соответствии с
// проданным товаром.
//   Асинхронный интерфейс предполагает экспорт справочника товаров
// в кассовую машину перед началом кассовой сессии и импорт результатов
// продаж в конце кассовой сессии.
//   Кассовая машина может одновременно поддерживать и синхронный и
// асинхронный интерфейсы, однако кассовый узел (PPOBJ_CASHNODE)
// может использовать либо то либо другое, не не оба вместе.
//
class PPSyncCashSession;
class PPAsyncCashSession;
class PPCashMachine;

typedef PPCashMachine * (SLAPI * RegCashMachineFunc)(PPID cashID);

struct AsyncCashNPrepParam {
	enum {
		fUpdateOnly = 0x00000001L
	};
	PPID   CashNodeID;
	long   Flags;
};
//
// Descr: Класс, управляющий блокировкой кассового узла
//
class CmLocking {
public:
	CmLocking(const PPCashNode & rNodeRec);
	~CmLocking();
	int    operator !() const;
	int    IsForeignLocking() const
	{
		return BIN(Flags & fForeignLocking);
	}
private:
	enum {
		fError          = 0x0001,
		fLocking        = 0x0002,
		fForeignLocking = 0x0004
	};
	long   Flags;
	const  PPCashNode & R_NodeRec;
};

class PPCashMachine {
public:
	friend class CmLocking;

	static PPCashMachine * SLAPI CreateInstance(PPID cashID);
	static int SLAPI RegisterMachine(PPID, RegCashMachineFunc, int _sync, int _async);
	static int SLAPI IsSyncCMT(PPID cmtID);
	static int SLAPI IsAsyncCMT(PPID cmtID);

	virtual SLAPI ~PPCashMachine();
	virtual PPSyncCashSession  * SLAPI SyncInterface()  { return 0; }
	virtual PPAsyncCashSession * SLAPI AsyncInterface() { return 0; }
	//
	// Синхронные методы
	//
	int    SLAPI SyncOpenSession(LDATE *);
	int    SLAPI SyncCloseSession();
	//
	// Descr: Опции отображения панели итогов по кассовой сессии SyncViewSessionStat()
	//
	enum {
		cssoCloseSession = 0x0001, // Закрытие сессии (Z-отчет)
		cssoXReport      = 0x0002  // Пересменка (X-отчет)
		// @#cssoCloseSession^cssoXReport
	};

	int    SLAPI SyncViewSessionStat(long options);
	int    SLAPI SyncGetSummator(double *);
	int    SLAPI SyncAddSummator(double);
	int    SLAPI SyncPrintCheck(CCheckPacket *, int addSummator);
	int    SLAPI SyncPrintCheckByBill(const PPBillPacket * pPack, double multiplier, int departN);
	int    SLAPI SyncPrintCheckCopy(CCheckPacket * pPack, const char * pFormatName);
	int    SLAPI SyncPrintSlipDocument(CCheckPacket * pPack, const char * pFormatName);
	int    SLAPI SyncPrintXReport();
	int    SLAPI SyncPrintZReportCopy(const CSessInfo * pInfo);
	int    SLAPI SyncPrintIncasso();
	int    SLAPI SyncAllowPrint();
	int    SLAPI SyncBrowseCheckList(const char * pCheckPanInitStr, long checkPanFlags);
	int    SLAPI SyncLockCashKeyb();
	int    SLAPI SyncUnlockCashKeyb();
	int    SLAPI SyncOpenBox();
	int    SLAPI SyncCheckForSessionOver();
	int    SLAPI GetSlipFormatList(StrAssocArray * pList, int getSlipDocForms);
	//
	//   Функция SyncGetPrintErrCode возвращает код ошибки при печати чека:
	//     0 - ошибка собственно в SyncPrintCheck или при печати на АМС-100Ф
	//     1 - ошибка после печати чека     |
	//     2 - ошибка при печати чека       | для Штрих-ФР-Ф
	//     3 - печать прервана оператором   |
	//
	int    SLAPI SyncGetPrintErrCode() const { return SyncPrintErrCode; }
	int	   SLAPI SyncPrintBnkTermReport(long pinpad, const char * pZCheck); // @vmiller
	//
	// Асинхронные методы
	//
	int    SLAPI AsyncOpenSession(int update, PPID sinceDlsID);
	int    SLAPI AsyncCloseSession(int asTempSess = 0, DateRange * pPrd = 0);
	int    SLAPI AsyncUpdateSession();
	int    SLAPI AsyncBrowseCheckList();
	int    SLAPI AsyncBrowseExcess();
	int    SLAPI AsyncInteractiveQuery();
	//
	// Общие методы
	//
	int    SLAPI IsValid() const;
	const  PPCashNode & SLAPI GetNodeData() const;
	//
	// Descr: Возвращает ИД текущей кассовой сессии узла NodeID.
	// Note: Для получения этого значения нельзя использовать GetNodeData() по тому,
	//   что при одновременной работе нескольких компьютеров с одним кассовым узлом
	//   возможна ситуация, когда один узел закрыл/открыл сессию, а другой об этом
	//   ни чего не знает.
	//
	PPID   SLAPI GetCurSessID();
	void   SLAPI SetParentNode(PPID parentNodeID);
	//
	// Descr: проверяет корректность чека. Если в чеке есть ошибка,
	//   то текст ошибки возвращается в буфере pErrBuf. Если параметр correct != 0,
	//   тогда эта функция пытается исправить чек.
	// Returns:
	//   1 - check is valid
	//   2 - function not supported
	//  -1 - check is invalid (not corrected)
	//  -2 - check is invalid (corrected). Record pRec contains corrected data.
	//   0 - error
	//
	virtual int SLAPI ValidateCheck(CCheckTbl::Rec * pRec, int correct, char * pErrBuf, size_t errBufLen);
	//
	int    SLAPI TestPrintCheck(CCheckPacket * pPack);
protected:
	SLAPI  PPCashMachine(PPID cashID);
	int    SLAPI GetNode();
	int    SLAPI UpdateNode(int use_ta);

	int    Valid;
	PPID   NodeID;
	PPID   ParentNodeID;
	PPCashNode NodeRec;
private:
	static int SLAPI GetRegEntry(PPID cmtID, uint * pPos);
	//
	// Descr: Проверяет кассовый узел на синхронность, если он описан в ppdrv.ini
	//
	static int SLAPI SyncOrAsync(int cashID, int & s); // @vmiller
	int    SLAPI NewDayDialog(LDATE *);
	int    SLAPI GetSyncIntrf();
	int    SLAPI GetAsyncIntrf();
	int    SLAPI _SyncCloseBill(int ret, int use_ta);
	int    SLAPI SyncSetPrintErrCode(int retCode, int updateNode);
	static void * P_RegData; // @global @threadsafe
	PPSyncCashSession  * P_SyncIntrf;
	PPAsyncCashSession * P_AsyncIntrf;
	int    SyncPrintErrCode;
};
//
//
//
#define HORZNT_LEFT		0
#define HORZNT_RIGHT	1
#define HORZNT_CENTER	2
#define ALIGN_CURPOS	3 // Горизонтальная табуляция (текущая позиция)
#define VERTAB_CURPOS	2 // Вертикальная табуляция (текущая позиция)
//
// Descr: Базовый класс интерфейса с дисплеем покупателя //
//
class PPCustDisp {
public:
	enum CustDispFlags {
		fcdShowTime      = 0x0001,
		fcd850CodePage   = 0x0002,
		fcdTyssoCodePage = 0x0004,
		fcdUsb           = 0x0005
	};
	static int IsComPort(const char * pPortName);
	SLAPI  PPCustDisp(int portNo, int dispStrLen, long flags, int usb = 0);
	SLAPI ~PPCustDisp();
	int    SLAPI IsError() const
	{
		return BIN(State & stError);
	}
	virtual int SLAPI ClearDisplay();
	virtual int SLAPI OpenedCash();
	virtual int SLAPI ClosedCash();
	virtual int SLAPI SetGoodsName(const char * pName);
	virtual int SLAPI SetPresent();
	virtual int SLAPI SetAmt(double price, double qtty);
	virtual int SLAPI SetDiscount(double percent, double discount);
	virtual int SLAPI SetTotal(double sum);
	virtual int SLAPI SetChange(double cash, double change);
protected:
	enum {
		upp,
		down
	};
	enum {
		stError     = 0x0001,
		stConnected = 0x0002
	};
	int    SLAPI InitPort();
	int    SLAPI Init(int usb = 0);
	int    SLAPI PutChar(int c);
	//int    SLAPI PutString(const char * pStr); // @vmiller comment
	int	   SLAPI PutString(const char * pStr, int align = ALIGN_LEFT, int verTab = VERTAB_CURPOS); // @vmiller
	int    SLAPI PutCenteredString(const char * pStr);
	int    SLAPI SetLine(int lineNo);
	int    SLAPI ClearLine(int lineNo);
	int    SLAPI SetCurTime();
	int    SLAPI OpenOrCloseCash(int open);
	int    SLAPI GetConfig(); // @vmiller
	int	   SLAPI ExecOper(int cmd, StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
	int    Port;
	//uint   IsConnected; // @vmiller
	uint   DispStrLen;
	long   Flags; // fcdXXX
	long   State; // stXXX
	char * P_DispBuf;
	SString Words;
	//SCommPort * P_ComPort; // @vmiller comment
	// @vmiller {
	PPAbstractDevice * P_AbstrDvc;
	StrAssocArray Arr_In;
	StrAssocArray Arr_Out;
	// } @vmiller
};

PPCustDisp * SLAPI GetCustDisp(PPID custDispID, char * pPortName, int usb);

//
// Класс для работы с банковскими терминалами
//
class PPBnkTerminal { // BnkTerm
public:
	PPBnkTerminal(PPID bnkTermId, uint logNum, int port, const char * pPath);
	~PPBnkTerminal();
	int    Connect(int port);
	int    Disconnect();
	int    Pay(double amount, SString & rSlip);
	int    Refund(double amount, SString & rSlip);
	int    Cancel();
	int    GetSessReport(SString & rZCheck);
	int    GetErrorMsg(SString & rStr);
	int    IsInited() const;
	int    IsConnected() const;
private:
	int    Init(const char * pPath);
	int    SetConfig(uint logNum);
	int    Release();
	int    ExecOper(int cmd, StrAssocArray & rIn, StrAssocArray & rOut);

	//int    Inited;
	//int    Connected;
	enum {
		stInited    = 0x0001,
		stConnected = 0x0002
	};
	long   State;
	PPAbstractDevice * P_AbstrDvc;
	StrAssocArray Arr_In;
	StrAssocArray Arr_Out;
};

PPBnkTerminal * SLAPI GetBnkTerm(PPID bnkTermID, uint logNum, const char * pPort, const char * pPath);
//
// @ModuleDecl(PPObjLocPrinter)
// Descr: Принтеры, привязанные к складам
//
struct PPLocPrinter2 {     // @persistent @store(Reference2Tbl+)
	SLAPI  PPLocPrinter2()
	{
		THISZERO();
	}
	enum {
		fHasKitchenBell = 0x0001 // @v7.0.10 Принтер имеет кухонных звонок.
			// При печати на этот принтер следует отправлять сигнал для подачи звонка.
	};
	long   Tag;            // Const=PPOBJ_LOCPRINTER
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[12];    // @reserve
	char   Port[48];       // Имя порта вывода
	long   Flags;          //
	long   LocID;          // ->Location.ID  Склад
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPLocPrinter);

class PPObjLocPrinter : public PPObjReference {
public:
	SLAPI  PPObjLocPrinter(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPLocPrinter * pPack);
	int    SLAPI PutPacket(PPID * pID, PPLocPrinter * pPack, int use_ta);
	int    SLAPI GetPrinterByLocation(PPID locID, SString & rPrnPort, PPLocPrinter * pRec);
	//
	// Descr: Формирует список ассоциация склад-локальный принтер (key - LocID, val - LocPrinterID).
	//   Список функцией предварительно очищается.
	// Note: Каждый склад в списке уникален. То есть, если в справочнике существуют
	//   более одной записи принтера, имеющюх один и тот же склад, то в списко попадет
	//   только запись с наименьшим идентификатором.
	//   Если существует запись без склада (PPLocPrinter::LocID == 0), то она попадет в список.
	// Returns:
	//   >0 - в список добавлена по крайней мере одна запись.
	//   <0 - нет ни одной записи в справочнике.
	//   0  - ошибка.
	//
	int    SLAPI GetLocPrnAssoc(LAssocArray & rList);
	int    SLAPI IsPrinter();
};
//
//
//
#define ACF_FREEREST        0x0001L // Даже имея субсчета и (или) статьи, счет допускает прямые проводки
#define ACF_HASBRANCH       0x0002L // Счет имеет субсчет(а)
#define ACF_CURRENCY        0x0004L // Валютный счет
#define ACF_FRRL            0x0008L // Флаг блокировки пересчета форвардных остатков
#define ACF_EXCLINNERTRNOVR 0x0010L // Исключать взаимные обороты (для группирующего счета)
#define ACF_SYSNUMBER       0x0020L // Номер счета генерируется системой (только для регистров и группирующих счетов)
//
// Флаги элемента группирующего счета
//
#define ACGF_ACO1GRP        0x0001L // Группировать по счету 1-го порядка
#define ACGF_ACO2GRP        0x0002L // Группировать по счету 2-го порядка
	// !(flags & (ACGF_ACO1GRP | ACGF_ACO2GRP)) - терминальный счет
#define ACGF_NEGATIVE       0x0004L // Изменять знак при суммировании

int FASTCALL GetAcoByGenFlags(long);

#define MINGENACCNUMBER     10000   // Минимальное значение номера группирующего счета
#define MAXGENACCNUMBER     19999   // Максимальное значение номера группирующего счета
//
// Descr: Структура бухгалтерского счета
//
struct PPAccount { // @persistent
	long   Tag;         // Const=PPOBJ_ACCOUNT2
	long   ID;          // @id
	char   Name[48];
	char   Code[20];
	uint8  Reserve[20];
	PPID   MainOrgID;
	PPID   CurID;
	PPID   ParentID;
	int16  Type;
	int16  Kind;
	long   Flags;
	LDATE  OpenDate;
	LDATE  Frrl_Date;
	double Limit;
	double Overdraft;
	struct _A_ {
		//
		// Важно: Порядок полей именно такой, поскольку в результате счет 20.2 > 20.1
		//
		int16  Sb;
		int16  Ac;
	} A;
	PPID   AccSheetID;
};
// } @construction

struct PPAccountPacket {
	SLAPI  PPAccountPacket();
	void   SLAPI  Init();
	PPAccountPacket & FASTCALL operator = (const PPAccountPacket &);

	//PPAccount Rec;
	PPAccount Rec;
	PPIDArray CurList;
	ObjRestrictArray GenList;   // Список группируемых счетов (для группирующего счета)
};

#if 0 // @v9.0.4 {

class AccountCore : public Account_Pre9004Tbl {
public:
	//
	// Descr: Генерирует код счета в формате Ac.Sb
	//
	static int SLAPI GenerateCode(PPAccount *);

	SLAPI  AccountCore();
	//
	// Descr: Генерирует номер счета по его коду и типу и заносит его в поля Ac и Sb
	//
	int    SLAPI GenerateNumber(PPAccount *);
	int    SLAPI Remove(PPID, int use_ta);
	int    SLAPI Search(PPID, PPAccount * pRec = 0);
	int    SLAPI GetCurList(int ac, int sb, PPIDArray * pAccList, PPIDArray * pCurList);
	int    SLAPI GetCurList(PPID accID, PPIDArray * pAccList, PPIDArray * pCurList);
	int    SLAPI GetIntersectCurList(PPID accID_1, PPID accID_2, PPIDArray *);
	int    SLAPI GetPacket(PPID, PPAccountPacket *);
	int    SLAPI PutPacket(PPID *, PPAccountPacket *, int use_ta);
	int    SLAPI SearchCode(const char * pCode, PPID curID, PPAccount * = 0);
	int    SLAPI SearchBase(PPID curAccID, PPID * pBaseAccID, void * = 0);
	int    SLAPI SearchCur(PPID accID, PPID curID, PPID * pCurAccID, void * = 0);
	//
	// Descr: возвращает (>0) если у счета с номером ac имеется хотя бы один субсчет.
	//   Если нет, то возвращается (<0). В случае ошибки возвращает 0.
	//
	int    SLAPI HasAnySubacct(int ac);
	int    SLAPI GetSubacctList(int ac, int sb, PPID curID, PPIDArray *);
	int    SLAPI InitAccSheetForAcctID(AcctID * pAcctId, PPID * pSheetID);
	int    SLAPI ParseString(const char * pStr, int tok[]);
private:
	int    SLAPI AddCurRecord(PPAccount * pBaseRec, PPID curID);
	int    SLAPI GetAggrNumber(PPAccount *);
};

#endif // } 0 @v9.0.4
//
// @ModuleDecl(PPObjAccount)
//
#define ACY_SEL_BAL          ACY_BAL
#define ACY_SEL_OBAL         ACY_OBAL
#define ACY_SEL_REGISTER     ACY_REGISTER
#define ACY_SEL_AGGR         ACY_AGGR
#define ACY_SEL_ALIAS        ACY_ALIAS
#define ACY_SEL_BUDGET       ACY_BUDGET
#define ACY_SEL_BALCUR       -1
#define ACY_SEL_BALOBAL      -2
#define ACY_SEL_BALOBALCUR   -3
#define ACY_SEL_BALOBALALIAS -4
#define ACY_SEL_ALL          -100

class PPObjAccount : public PPObjReference {
public:
	SLAPI  PPObjAccount(void * extraPtr = 0);
	SLAPI ~PPObjAccount();

	static Reference2Tbl::Key2 & MakeAcctKey(int ac, int sb, Reference2Tbl::Key2 & rKey);
	static int CheckRecursion(PPID id, PPID parentID);
	static int SLAPI GenerateCode(PPAccount * pRec);

	virtual int  SLAPI Edit(PPID *, void * extraPtr);
	int    SLAPI ParseString(const char * pStr, int tok[]);
	int    SLAPI PutPacket(PPID * pID, PPAccountPacket * pAccPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPAccountPacket * pAccPack);
	int    SLAPI GetCurList(int ac, int sb, PPIDArray * pAccList, PPIDArray * pCurList);
	int    SLAPI GetCurList(PPID accID, PPIDArray * pAccList, PPIDArray * pCurList);
	int    SLAPI GetIntersectCurList(PPID accID_1, PPID accID_2, PPIDArray * pCurList);
	int    SLAPI GetSubacctList(int ac, int sb, PPID curID, PPIDArray * pList);
	int    SLAPI HasAnySubacct(int ac);
	int    SLAPI InitAccSheetForAcctID(AcctID * pAcctId, PPID * pAccSheetID);
	//
	// Для функции Selector дополнительное значение:
	//  ACY_SEL_AGGR         - только группирующие счета
	//  ACY_SEL_REGISTER     - только регистры
	//  ACY_SEL_OBAL         - только забалансовые счета
	//  ACY_SEL_BAL          - только балансовые счета (валютные и невалютные)
	//  ACY_SEL_ALIAS        - только алиасы
	//  ACY_SEL_BALCUR       - только валютные балансовые счета
	//  ACY_SEL_BALOBAL      - балансовые и забалансовые
	//  ACY_SEL_BALOBALCUR   - только валютные балансовые и забалансовые
	//  ACY_SEL_BALOBALALIAS - балансовы, забалансовые счета и алиасы счетов
	//  ACY_SEL_ALL          - все счета
	//  1000L+AccSheetID - балансовые счета с таблицей аналитического учета AccSheetID
	// -------------------------------------------
	// Для функции Browse дополнительные значения:
	//  ACY_AGGR        - только группирующие счета
	//  ACY_REGISTER    - только регистры
	//  ACY_OBAL        - только забалансовые счета
	//  ACY_BAL         - только балансовые счета (валютные и невалютные)
	//  ACY_ALIAS       - только алиасы
	//  0               - все счета
	//
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Dirty(PPID id);
	//
	// Descr: Если в функции SearchNum параметр sb == -1, то ищется //
	//   первый субсчет для счета ac
	//
	int    SLAPI SearchNum(int ac, int sb, PPID curID, PPAccount * = 0);
	int    SLAPI SearchBase(PPID curAccID, PPID * pBaseAccID, PPAccount * pRec);
	int    SLAPI SearchCur(PPID accID, PPID curID, PPID * pCurAccID, PPAccount * pRec);
	int    SLAPI SearchCode(const char * pCode, PPID curID, PPAccount * pRec);
	int    SLAPI GenerateNumber(PPAccount * pRec);
	int    SLAPI Fetch(PPID id, PPAccount * pRec);
	int    SLAPI FetchNum(int ac, int sb, PPID curID, PPAccount * pRec);
	int    SLAPI GetChildList(PPID acctID, StrAssocArray * pChildList);
	int    SLAPI GetParentList(PPID acctID, StrAssocArray * pParentList);
	int    SLAPI BelongTo(PPID acctID, PPID parentID);

	int    SLAPI GetListByAccSheet(PPID accSheetID, PPIDArray & rList);
	int    SLAPI LockFRR(PPID accID, LDATE dt, int doUnlock);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI AddCurRecord(const PPAccount * pBaseRec, PPID curID);
	int    SLAPI SerializePacket(int dir, PPAccountPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	void * ExtraPtr;
public:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*acySelType*/);
	// TLP_MEMB(AccountCore, P_Tbl);
};
//
//
//
class Balance : public BalanceTbl {
public:
	SLAPI  Balance(char * fName = 0);
	int    SLAPI Turn(PPID bal, LDATE, AccTurnParam * param, int use_ta);
	int    SLAPI RollbackTurn(PPID bal, LDATE, AccTurnParam * param, int use_ta);
	int    SLAPI Search(PPID * bal, LDATE *, int spMode);
	int    SLAPI GetRest(PPID bal, LDATE, double * dbt, double * crd);
	int    SLAPI GetTurnover(PPID bal, LDATE beg, LDATE end, double * dbt, double * crd);
	//
	// Descr: передает обороты и исходящие остатки по счету
	//   за период [beg..end]. Результаты присваиваются элементам массива row
	//   в следующем порядке: {dbtTurnover, crdTurnover, dbtRest, crdRest}.
	//
	int    SLAPI GetBalance(PPID bal, LDATE beg, LDATE end, double row[]);
	double SLAPI _Rest() const;
	double SLAPI _Rest(int side) const;
	void   SLAPI _SetRest(int side, double val);
	int    SLAPI _Turn(PPID bal, LDATE, AccTurnParam * param, uint flags);
};
//
//
//
#define ACRF_FRRL 0x0008L // Флаг блокировки пересчета форвардных остатков

class AcctRel : public AcctRelTbl {
public:
	friend class PPTblEnum <AcctRel>;

	SLAPI  AcctRel();
	int    SLAPI Search(PPID id, AcctRelTbl::Rec * pRec = 0);
	int    SLAPI Fetch(PPID id, AcctRelTbl::Rec * pRec);
	//
	// Descr: перебирает записи, соответствующие счету accID и возвращает
	//   каждую найденную запись в буфере pRec.
	//   Счетчиком итераций является указатель на ИД статьи аналитического учета pArID.
	//   Начинать перебор следует со значения *pArID = 0. Если существует сочетание {accID, 0},
	//   то функция вернет его.
	// Returns:
	//   >0 - найдена очередная запись, соответствующая счету accID
	//   <0 - записей, соответствующих сочетанию {accID, *pArID+1 (или больше)} нет
	//   0  - ошибка
	//
	int    SLAPI EnumByAcc(PPID accID, PPID * pArID, AcctRelTbl::Rec *);
	//
	// Descr: перебирает записи, соответствующие статье arID и возвращает
	//   каждую найденную запись в буфере pRec.
	//   Счетчиком итераций является указатель на ИД счета pAccID.
	//   Начинать перебор следует со значения *pAccID = 0. Если существует сочетание {0, arID},
	//   то функция вернет его.
	// Returns:
	//   >0 - найдена очередная запись, соответствующая статье arID
	//   <0 - записей, соответствующих сочетанию {*pAccID+1 (или больше), arID} нет
	//   0  - ошибка
	//
	int    SLAPI EnumByArticle(PPID arID, PPID * pAccID, AcctRelTbl::Rec *);
	SEnumImp * SLAPI EnumByAcc(PPID accID);
	SEnumImp * SLAPI EnumByArticle(PPID arID);
	//
	// Заменяет все сочетания {oldAc, oldSb} на {newAc, newSb}
	// @! Без транзакции
	//
	int    SLAPI ReplaceAcct(int oldAc, int oldSb, int newAc, int newSb);
	int    SLAPI SearchAcctID(const AcctID * pAcctId, AcctRelTbl::Rec * pRec = 0);
	//
	// Descr: Если параметр closed == -1, то ищет последний закрытый счет с
	//   номером acct. Иначе ищет точное соответствие { closed, acct }
	//
	int    SLAPI SearchNum(int closed, Acct * pAcct, PPID curID, AcctRelTbl::Rec * pRec = 0);
	//
	// Так как операции модификации этой таблицы, кроме CloseAcct,
	// не используются самостоятельно, то транзакции здесь не применяются //
	//
	int    SLAPI OpenAcct(PPID *, Acct *, PPID curID, AcctID *, int accKind, int accsLevel = 0);
	int    SLAPI CloseAcct(PPID, int use_ta);
private:
	SEnumImp * SLAPI Enum(int keyN, PPID keyID);

	PPTblEnumList EnumList;
};
//
//
//
struct RecoverBalanceParam {
	SLAPI  RecoverBalanceParam();
	enum {
		fCorrect = 0x0001
	};
	DateRange Period;
	PPID   BalAccID;
	long   Flags;
	SString LogFileName;
};

struct CurRevalParam {
	SLAPI  CurRevalParam();
	int    SLAPI Init();
	CurRevalParam & FASTCALL operator = (const CurRevalParam &);
	LDATE  Dt;
	Acct   CorrAcc;
	Acct   NegCorrAcc;
	PPID   LocID;
	long   Flags;
	PPIDArray AccList;
	AmtList   CRateList;
};
//
// @ModuleDecl(AccTurnCore)
//
// Flags of function AccTurnCore::Repair()
//
#define ATRPRF_CHECKBILLLINK   0x0001
#define ATRPRF_CHECKACCLINK    0x0002
#define ATRPRF_REPAIRMIRROR    0x0004
#define ATRPRF_RMVZEROBILLLINK 0x0008
#define ATRPRF_RMVZEROACCLINK  0x0010
//
// Flags of function AccTurnCore::GetBalRest
//
#define BALRESTF_INCOMING        0x0001 // Входящее сальдо
#define BALRESTF_ACO1GROUPING    0x0002 // Группировать по счету первого порядка
#define BALRESTF_SPREADBYSUBACC  0x0004 // Разворачивать по субсчетам (предполагает BALRESTF_GROUPBYACO1)
#define BALRESTF_SPREADBYARTICLE 0x0008 // Разворачивать по субконто
#define BALRESTF_SPREAD          (BALRESTF_SPREADBYSUBACC|BALRESTF_SPREADBYARTICLE)

class AccTurnCore : public AccTurnTbl {
public:
	SLAPI  AccTurnCore();
	int    SLAPI SearchByBill(PPID, int reverse, short rByBill, void * = 0);
	int    SLAPI GetAcctCurID(int aco, PPID accID, PPID * pCurID);
	int    SLAPI GetAccRelIDs(const AccTurnTbl::Rec *, PPID * pDbtRelID, PPID * pCrdRelID) const;
	int    SLAPI ConvertRec(const AccTurnTbl::Rec *, PPAccTurn *, int useCache);
	int    SLAPI Turn(PPAccTurn*, int use_ta);
	int    SLAPI RollbackTurn(PPID, short rByBill, int use_ta);
	int    SLAPI UpdateAmount(PPID, short rByBill, double newAmt, double cRate, int use_ta);
	int    SLAPI AcctIDToRel(const AcctID *, PPID * rel);
	int    SLAPI AcctRelToID(PPID relID, AcctID *, PPID * pAccSheetID);
	int    SLAPI GetAcctRel(PPID accID, PPID arID, AcctRelTbl::Rec * pRec, int createIfNExists, int use_ta);
	//
	// Descr: возвращает список счетов 2-го порядка (pAccList),
	//   по идентификатору группирующего счета genAccID. С каждым из возвращенных счетов ассоциировано поле флагов
	//   ((pAccList->)::Flags), соответствующих таковому в исходном списке группирующего счета.
	//   В списке pCurList возращается объедининение валют по всем счетам списка pAccList.
	// Returns:
	//   >0 - pAccList->getCount() > 0
	//   <0 - pAccList->getCount() == 0
	//   0  - Error (PPERR_NOMEM, PPERR_SLIB, PPERR_ACCNGEN)
	//
	int    SLAPI GetExtentAccListByGen(PPID genAccID, ObjRestrictArray *, PPIDArray * pCurList);
	int    SLAPI GetBaseAcctID(AcctID * pCurAcctId, AcctID * pBaseAcctId);
	int    SLAPI ConvertAcct(const Acct *, PPID curID, AcctID *, PPID * pSheetID);
	int    SLAPI ConvertAcctID(const AcctID *, Acct *, PPID * pCurID, int useCache);
	int    SLAPI ConvertStr(const char *, PPID curID, Acct *, AcctID *, PPID * pSheetID);
	int    SLAPI GetAcctRest(LDATE, PPID accrel, double *, int incoming);
	//
	// Descr: Возвращает дебитовый и кредитовый остатки по балансовому счету accID на
	//   дату dt, по указателям pDbt и pCrd.
	//   Параметр flags задает опции расчета сальдо (см. BALRESTF_XXX)
	//
	int    SLAPI GetBalRest(LDATE, PPID accID, double * pDbt, double * pCrd, uint flags = 0);
	int    SLAPI EnumByBill(PPID billID, int * rByBill, PPAccTurn *);

	int    SLAPI CalcRest(int aco, PPID accID, const DateRange *, double * pInRest, double * pOutRest);
	int    SLAPI CalcComplexRest(long aco, PPID accID, PPID curID, PPID personRelID, const DateRange *, AmtList * pInRest, AmtList * pOutRest);
	int    SLAPI CalcComplexRestOnGenList(ObjRestrictArray *, PPID curID, const DateRange *, AmtList * pInRest, AmtList * pOutRest);
	//
	// Descr: проверяет и пересчитывает остатки в записях проводок по счету и ид. acc (->AcctRel.ID).
	//   Всякий раз, при обнаружении неверной записи вызывается пользовательская функция MsgProc.
	//   Если эта функция возвращает > 0, то запись исправляется.
	//   Если 0, то не исправляется, если < 0, то RecalcRest завершается без исправления последней записи.
	//   Функция MsgProc не должна обращаться к транзакии.
	//   Если параметр MsgProc == 0, то проверяются и исправляются все проводки.
	//
	int    SLAPI RecalcRest(PPID accRelID, LDATE startDate, int (*MsgProc)(PPID, LDATE, long, double, void * paramPtr), void * paramPtr, int use_ta);
	int    SLAPI UpdateAccNum(PPID accID, int newAc, int newSb, int use_ta);
	//
	// Descr: проверяет остатки в таблице Balance по балансовому счету balID за период beg..end.
	//   В зависимости от параметра flags функция может записывать ошибки
	//   в файл balance.err и исправлять найденные ошибки.
	//
	enum {
		chkBalLog     = 0x0001,
		chkBalCorrect = 0x0002
	};
	int    SLAPI RecalcBalance(RecoverBalanceParam *, PPLogger &);
	int    SLAPI RecalcBalance(PPID accID, LDATE startDate, int use_ta);
	int    SLAPI Repair(long flags, int (*MsgProc)(int msgCode, PPID accID, PPID billID, LDATE dt, long oprno, void * paramPtr), void * paramPtr);
	int    SLAPI RemoveEmptyAcctRels();
	int    SLAPI AccBelongToOrd(PPID accID, int ord, const Acct * pAcct, PPID curID, int useCache);
	int    SLAPI UpdateRelsArRef(PPID arID, long arNo, int use_ta);
	int    SLAPI NormalyzeAcc(int aco, PPID * pAccID, PPID * pCurID); // @unused
	//
	// Descr: Идентифицирует нормализованный идентификатор счета *pAccID.
	//   Если этот ид скрывает за собой семейство счетов (aco == ACO_1 || curID < 0),
	//   то по указателю pAccList заполняется список соответствующих
	//   идентификаторов счетов. Если результирующий список содержит более одного
	//   элемента, то ид по указателю pAccID остается в нормализованной форме,
	//   если же pAccList->getCount() == 1, то *pAccID = pAccList->at(0).
	//
	int    SLAPI IdentifyAcc(long * pAco, PPID * pAccID, PPID curID, PPID personRelID, PPIDArray * pAccList);
	int    SLAPI LockingFRR(int lock, int * pFRRL_Tag, int use_ta);
	int    SLAPI IsFRRLocked();
	int    SLAPI RevalCurRests(const CurRevalParam *);

	int    SLAPI SortGenAccList(ObjRestrictArray *);
	int    SLAPI ReplaceArticle(PPID dest, PPID src);
	int    SLAPI SearchAccRef(PPID accID, int removeUnusedRel);
	int    SLAPI SearchArticleRef(PPID arID, int removeUnusedRel, PPID * pBillID);
private:
	int    SLAPI SetupAccTurnParam(AccTurnParam * p, int side, int kind);
	int    SLAPI GetBill(PPAccTurn *);
	int    SLAPI _OprNo(LDATE, long * oprno);
	int    SLAPI _RecByBill(PPID billID, short * rByBill);
	int    SLAPI _UpdateForward(LDATE, long, PPID accRel, AccTurnParam *);
	int    SLAPI _Turn(const PPAccTurn * pAt, PPID accRel, PPID corrAccRel, AccTurnParam *);
	int    SLAPI _ProcessAcct(int side, PPID curID, AcctID *, PPID * pAccRelID, AccTurnParam *);
	int    SLAPI _RollbackTurn(int side, LDATE date, long oprNo, PPID bal, PPID rel, double);
	int    SLAPI _UpdateTurn(PPID billID, short rByBill, double newAmt, double cRate, int use_ta);

	int    SLAPI _RecalcBalance(PPID, const RecoverBalanceParam *, PPLogger &);
	int    SLAPI _CheckBalance(PPID, LDATE, double, double, char *, int correct, PPLogger &, int use_ta);
	int    SLAPI LockFRR(PPID accRelID, LDATE dt);
	int    SLAPI RevalCurRest(const CurRevalParam & rParam, const Acct * pAcc, const PPIDArray * pCurList, int use_ta);
	int    SLAPI UpdateItemInExtGenAccList(PPID objID, long f, PPID accID, ObjRestrictArray *, PPIDArray *);
	int    SLAPI Helper_Repair(long flags, int reverse, int (*MsgProc)(int msgCode, PPID accID,
		PPID billID, LDATE dt, long oprno, void * paramPtr), void * paramPtr);

	struct FrrlData {
		int    Counter;
		PPIDArray AccrelIdList;
	};
	TLP_MEMB(FrrlData, Frrl);
public:
	PPObjAccount AccObj;
	//AccountCore & AccT;
	ArticleCore Art;
	AcctRel     AccRel;
	Balance     BalTurn;
};
//
//
//
/* @v9.0.0
class FormattedCheck {
public:
	static FormattedCheck * SLAPI CreateInstance(uint chkStrlen);
	SLAPI  FormattedCheck(uint chkStrlen);
	virtual SLAPI ~FormattedCheck() {}
	virtual int SLAPI SetPacket(const CCheckPacket * pPack, uint flags) = 0;
	virtual int SLAPI GetCheckLine(int * pUseJrnlRbn, SString &rBuf) = 0;
protected:
	uint   ChkStrLen;
};
*/
//
// PPSlipFormatter
//
struct SlipLineParam {
	SLAPI  SlipLineParam();
	void   SLAPI Init();
	//
	// Descr: Флаги
	//
	enum {
		fRegRegular  = 0x0001, // Регистрация на чековой лента
		fRegJournal  = 0x0002, // Регистрация на контрольной чековой ленте
		fRegFiscal   = 0x0004, // Регистрация в фискальной памяти
		fRegSlip     = 0x0008, // Регистрация на подкладном документе
		fBcTextAbove = 0x0010, // Текст штрихкода печатать сверху
		fBcTextBelow = 0x0020  // Текст штрихкода печатать снизу
	};
	//
	// Descr: Вид данного элемента
	//
	enum {
		lkRegister   = 1, // Регистрация продажи
		lkText,           // Просто текст
		lkPict,           // Изображение
		lkBarcode,        // Штрихкод на элемент чека
		lkSignBarcode     // Подписывающий штрихкод для всего чека
	};
	int    Font;          // для подкладного документа - номер шрифта подкладного документа;
		// для ленты: 1 - обычный шрифт, >1 - широкий шрифт
	int    Kind;          // lkXXX
	int    Flags;         // fXXX
	double Qtty;          // для regtoFiscal
	double Price;         // для regtoFiscal
	double VatRate;       // для regtoFiscal
	short  DivID;         // для regtoFiscal
	short  FontSize;      // Размер шрифта (для обычного принтера)
	int    BarcodeStd;    // BARCSTD_XXX Стандарт штрихкода
	int    BarcodeWd;     // Ширина штрихкода (в точках)
	int    BarcodeHt;     // Высота штрихкода (в точках)
	TRect  PictCoord;     // Координаты изображения
	SString FontName;     // Наименование гарнитуры шрифта (для обычного принтера)
	SString PictPath;     // Путь к файлу изображения
	SString Text;         // @v9.5.7
	SString Code;         // @v9.5.7
};

struct SlipDocCommonParam {
	SString Title;
	SString DocNumber;
	uint   PageWidth;
	uint   PageLength;
	uint   HeadLines;
	uint   RegTo;         // SlipLineParam::regtoXXX
	uint   TextOutput; // @vmiller
	SString PictPath;
	RECT   PictCoord;
};

class PPSlipFormatter {
public:
	PPSlipFormatter(const char * pFmtFileName);
	 ~PPSlipFormatter();
	int    Init(const char * pFormatName, SlipDocCommonParam * pParam);
	int    InitIteration(const CCheckPacket *);
	int    InitIteration(const PPBillPacket *);
	int    InitIteration(const CSessInfo *);
	int    NextIteration(SString & rBuf, SlipLineParam * pParam);
	int    GetFormList(StrAssocArray * pList, int getSlipDocForms = 0);
private:
	SString SlipFmtPath;
	void * P_SlipFormat;
};
//
// PPSyncCashSession
// Базовый класс интерфейса с синхронными кассовыми сессиями
//
#define CSHCHK_CHECKBAND         0x0001
#define CSHCHK_CTRLBAND          0x0002
#define CSHCHK_WIDE              0x0100
//
// Флаги функции PPSyncCashSession::PrintCheck
//
#define PRNCHK_ADDFISCCNTR       0x0001 // Изменять фискальный счетчик
#define PRNCHK_ADDSESSCNTR       0x0002 // Изменять сменный счетчик
#define PRNCHK_NODISPLAY         0x0004 // Подавить вывод на дисплей ККМ
#define PRNCHK_REPRINT           0x0008 // Перепечатка последнего чека
#define PRNCHK_OPENBOX           0x0010 // Открыть денежный ящик
#define PRNCHK_RETURN            0x0020 // Чек возврата
#define PRNCHK_LASTCHKANNUL      0x0040 // Перед печатью аннулировать последний чек
#define PRNCHK_BANKING           0x0080 // Чек оплачен банковской кредитной картой
#define PRNCHK_ROUNDINT          0x0100 // %% скидку в чеке округлять до целого
//
// Коды возврата функции PPSyncCashSession::GetPrintErrCode()
//
#define SYNCPRN_NO_ERROR              0 // OK
#define SYNCPRN_ERROR_AFTER_PRINT     1 // Сбой после печати чека
#define SYNCPRN_ERROR                 2 // Сбой
#define SYNCPRN_ERROR_WHILE_PRINT     3 // Сбой во время печати чека
#define SYNCPRN_CANCEL                4 // Отмена до начала печати чека
#define SYNCPRN_CANCEL_WHILE_PRINT    5 // Отмена во время печати чека

class PPSyncCashSession {
public:
	SLAPI  PPSyncCashSession(PPID cnID, const char * pName, const char * pPort);
	virtual SLAPI ~PPSyncCashSession();
	int    SLAPI Init(const char * pName, const char * pPort);
	int    SLAPI IsError() const
	{
		return BIN(State & stError);
	}
	virtual int SLAPI InitChannel() { return -1; }
	//
	// Функции кассового аппарата уровня приложения //
	//
	//
	// Descr: печатает документ pack на принтере ККМ, выводит сообщение
	//   на дисплей ККМ (если на noDisplay) и, если установлены соответствующие флаги,
	//   обновляет счетчики ККМ. Если pPack == 0, то выводится пустой чек.
	//
	virtual int SLAPI PrintCheck(CCheckPacket * pPack, uint flags) { return -1; }
	virtual int SLAPI PrintCheckByBill(const PPBillPacket *, double multiplier, int departN)
	{
		return -1;
	}
	virtual int SLAPI PrintCheckCopy(CCheckPacket * pPack, const char * pFormatName, uint flags) { return -1; }
	virtual int SLAPI PrintSlipDoc(CCheckPacket * pPack, const char * pFormatName, uint flags) { return -1; }
	virtual int SLAPI PrintXReport(const CSessInfo *) { return -1; }
	virtual int SLAPI PrintZReportCopy(const CSessInfo *) { return -1; }
	virtual int SLAPI PrintIncasso(double sum, int isIncome) { return -1; }
	virtual int SLAPI GetSummator(double * val) { return -1; }
	virtual int SLAPI AddSummator(double add) { return -1; }
	virtual int SLAPI EnableCashKeyb(int) { return -1; }
	virtual int SLAPI CloseSession(PPID sessID) { return -1; }
	virtual int SLAPI GetPrintErrCode() { return 0; }
	virtual int SLAPI OpenBox() { return -1; }
	virtual int SLAPI CheckForSessionOver() { return -1; }
	virtual int SLAPI PrintBnkTermReport(const char * pZCheck) { return -1; }
	//
	// Редактирование особых параметров устройства
	// На данный момент эта функция используется в универсальном драйвере АТОЛ
	// для редактирования и выбора кассы
	//
	virtual int SLAPI EditParam(void *)
	{
		return -1;
	}
	const  char * GetName() const
	{
		return Name;
	}
	PPSlipFormatter * GetSlipFormatter()
	{
		return P_SlipFmt;
	}
	int    SLAPI CompleteSession(PPID sessID);
protected:
	enum {
		stError = 0x0001
	};
	PPID   NodeID;
	char   Port[128]; // @v7.4.1 [16]-->[128]
	char   Name[48];  // @v7.4.1 [16]-->[48]
	int    PortType;  // 0 - file, 1 - lpt, 2 - com
	int    Handle;    //
	long   State;
	PPSlipFormatter * P_SlipFmt;
	PPObjCashNode CnObj;
	PPSyncCashNode SCn;
};
//
// Флаги PPAsyncCashSession
//
#define PPACSF_TEMPSESS         0x0001L // Временная сессия //
#define PPACSF_LOADRESTWOSALES  0x0002L // Загружать остатки без учета продаж (для Атола)

class DeviceLoadingStat;
//
// Descr: Базовый класс интерфейса с асинхронными кассовыми сессиями
//
class PPAsyncCashSession : public CSessGrouping {
public:
	SLAPI  PPAsyncCashSession(PPID cashNodeID);
	virtual SLAPI ~PPAsyncCashSession();
	int    SLAPI OpenSession(int updOnly, PPID sinceDlsID);
	int    SLAPI CloseSession(int asTempSess = 0, DateRange * pPrd = 0);
	PPID   SLAPI GetLocation();
	//int    SLAPI CompleteSession(PPID sessID);
	//
	// Descr: производит действие, определяемое параметром action над файлом, определенным параметром //
	//   pFileName относительно набора каталогов экспорта, заданного полем PPAsyncCashNode::P_ExpPaths.
	//   Возможные действия (action):
	//     0 - скопировать файл pFileName в каждый из каталогов экспорта
	//         @!Код возвращаемый функцией копирования не проверяется.
	//     1 - удалить файлы с именем, заданным параметром pFileName (путь, входящий в эту строку
	//         игнорируется) в каталогах экспорта
	//         @!Успешность удаления не проверяется.
	//     2 - проверить наличие файла с именем, заданным параметром pFileName (путь, входящий в эту строку
	//         игнорируется) в каталогах экспорта.
	//     3 - проверить доступность каталогов назначения на запись (параметр pFileName игнорируется).
	//         Функция пытается создать временный файл в каждом из каталогов назначения. Если попытка прошла
	//         успешно, то файл сразу удаляется.
	//
	//     pSubDir    - Вместо папки назначения будет использован следующий путь: диск назначения:\pSubDir
	//     pEmailSubj - Тема письма для отправки файла через email, если путь указан как почтовый адрес
	//
	//
	// Returns:
	//   0 - неверный параметр action или не удалось получить значение каталогов экспорта из
	//       записи кассового узла.
	//   For action == 0:
	//     1  - каталоги экспорта определены и предпринята попытка скопировать заданный файл в
	//          эти каталоги.
	//     -1 - в кассовом узле не задано ни одного каталога экспорта
	//   For action == 1:
	//     1  - каталоги экспорта определены и предпринята попытка удалить файл с заданным именем
	//          из этих каталогов.
	//     -1 - в кассовом узле не задано ни одного каталога экспорта
	//   For action == 2:
	//     1  - по крайней мере в одном из каталогов экспорта существует файл с заданным именем
	//     -1 - ни в одном из каталогов экспорта файла с заданным именем нет.
	//   For action == 3:
	//     1 - все каталоги доступны для записи
	//     0 - как минимум один из каталогов не доступен для записи
	//
	int    SLAPI DistributeFile(const char * pFileName, int action, const char * pSubDir = 0, const char * pEmailSubj = 0);
	//
	// Descr: Если поддерживаются запросы к кассовому узлу, то эта функция
	//   должна отправить серверу узла запрос (возможно в интерактивном режиме).
	// Note: Не предполагается, что функция должна дождаться ответа на запрос (но и не возбраняется).
	// Returns:
	//   >0 - запрос был отправлен
	//   <0 - функция не поддерживается либо пользователь отказался от функции
	//   0  - ошибка
	//
	virtual int SLAPI InteractiveQuery();
protected:
	//
	// Descr: должна сформировать файлы, необходимые для загрузки кассовых аппаратов.
	// ARG(mode IN):
	//   0 - полная загрузка данных
	//   1 - загрузка изменений. Если SinceDlsID != 0, то экспортируются изменения начиная с момента SinceDlsID
	//   2 - повторная загрузка данных, экспортированных начиная с SinceDlsID
	//
	virtual int SLAPI ExportData(int updOnly) = 0;
	//
	// Descr: должна инициализировать информацию о
	//   подлежащих импорту кассовых сессиях и вернуть вызывающей функции
	//   количество импортируемых сессий и признак являются ли эти сессии
	//   форвардными или нет.
	//
	//   Форвардные сессии отличаются от нефорвардных
	//   тем, что на момент пробития чека и занесения его в файл неизвестно,
	//   к сессии с каким номером он относится. То есть, чек форвардной сессии
	//   не несет информации о принадлежности к какой-либо сессии.
	//
	virtual int SLAPI GetSessionData(int * pSessCount, int * pIsForwardSess, DateRange * pPrd = 0) = 0;
	//
	// Descr: должна конвертировать файлы кассовой сессии с
	//   индексом sessionNo в таблицы временной сессии (P_TmpCcTbl и P_TmpCclTbl).
	//
	virtual int SLAPI ImportSession(int sessionNo) = 0;
	//
	// Descr: вызывается после конвертации всех сессий отмеченных функцией GetSessionData.
	//   Здесь должны быть произведены завершающие операции по импорту сессий. Функция может
	//   добавить в список закрываемых сессий элементы, используя метод PPIDArray::addUnique
	//
	virtual int SLAPI FinishImportSession(PPIDArray * pSessList);
	//
	// Descr: вызывается перед вызовом PPAsyncCashSession::ExportData для определения //
	//   возможности кассовой машины принять данные из Papyrus'а.
	//   Если функция вернула 0, то ExportData вызвана не будет.
	//   Если (PPEquipConfig::Flags & fIgnAcsReadyTags), то функция OpenSession
	//   игнорирует результат вызова этой функции (но в любом случае вызывает ее).
	// Returns:
	//   >0 - кассовая машина готова принять данные (ExportData() вызывается)
	//   0  - кассовая машина не готова принять данные (ExportData() не вызывается)
	//   <0 - функция не поддерживается данной реализацией (ExportData() вызывается)
	//
	virtual int SLAPI IsReadyForExport();
		// @<<PPAsyncCashSession::OpenSession
	virtual int SLAPI SetGoodsRestLoadFlag(int updOnly);
	int    SLAPI CreateTables();
	int    SLAPI DestroyTables();
	int    SLAPI IsCheckExistence(PPID cashID, long code, const LDATETIME * pDT, PPID * pTempReplaceID);
	int    SLAPI SearchTempCheckByCode(PPID cashID, PPID code, PPID sessNo = -1L);
	int    SLAPI SearchTempCheckByTime(PPID cashID, const LDATETIME *);
	int    SLAPI AddTempCheck(PPID * pID, long sessNumber, long flags /* CCHKF_XXX */,
		PPID cash, PPID code, PPID user, PPID cardID, LDATETIME *, double amt, double dscnt/*, double addPaym = 0, double extAmt = 0*/);
	int    SLAPI AddTempCheckAmounts(PPID checkID, double amt, double dis);
	int    SLAPI AddTempCheckPaym(long checkID, int paymType, double amount, long scardID);
	int    SLAPI UpdateTempCheckFlags(long checkID, long flags);
	int    SLAPI SetTempCheckAmounts(PPID checkID, double amt, double dis);
	int    SLAPI AddTempCheckSCardID(PPID checkID, PPID scardID);
	int    SLAPI AddTempCheckGiftCardID(PPID checkID, PPID giftCardID);
	int    SLAPI SetupTempCcLineRec(TempCCheckLineTbl::Rec * pRec, long ccID, long ccCode, LDATE dt, int div, PPID goodsID);
	int    SLAPI SetTempCcLineValues(TempCCheckLineTbl::Rec * pRec, double qtty, double price, double discount, const char * pBarcode = 0);
	int    SLAPI GetExpPathSet(StringSet *);
	int    FASTCALL CheckCnFlag(long);
	int    FASTCALL CheckCnExtFlag(long);
	int    SLAPI GetNodeData(PPAsyncCashNode *);
	void   FASTCALL AdjustSCardCode(char * pCode);
	//
	// Descr: Добавляет контрольную цифру в конец штрихкода при следующих условиях:
	// 1. В кассовом узле установлен флаг CASHF_EXPCHECKD
	// 2. Штрихкоды базе данных указаны без контрольных цифр (флаг GCF_BCCHKDIG в конфигурации
	//    справочника товаров не установлен)
	// 3. Длина кода превышает три символа
	// 4. Префикс штрихкода отличен от префикса весового штрихкода
	//
	int    FASTCALL AddCheckDigToBarcode(char * pBarcode);
	const  PPGoodsConfig & SLAPI GetGoodsCfg();
	//
	// Descr: заносит в журнал ppinfo.log строку с информацией об экспортируемом товаре,
	//   которую извлекает из структуры pInfo.
	// ARG(pInfo IN): @#{vptr0} указатель на структуру AsyncCashGoodsInfo, используемую
	//   порожденными классами для экспорта справочника товаров в асинхронный кассовый узел.
	//
	int    SLAPI LogExportingGoodsItem(const AsyncCashGoodsInfo * pInfo);
	//
	// Descr: Заносит в журнал debug.log строку pMsg.
	//   Функция отрабатывает только в том случае, если установлен флаг CConfig.Flags & CCFLG_DEBUG.
	//
	int    SLAPI LogDebug(const char * pMsg);

	PPID   NodeID;
	long   Flags;      // PPACSF_XXX
	PPID   SinceDlsID; // @v7.1.11 Ид записи статистики загрузки, начиная (включая) с которой следует выгрузить изменения //
	// Temp Session {
	TempCCheckTbl     * P_TmpCcTbl;
	TempCCheckLineTbl * P_TmpCclTbl;
	CCheckPaymTbl * P_TmpCpTbl;     // @v8.1.0
	// }
	DeviceLoadingStat * P_Dls;
private:
	int    SLAPI GetLastSess(long cashNumber, LDATETIME dtm, long * pSessNumber, PPID * pSessID);
	int    SLAPI SetLastSess(long cashNumber, long sessNumber, PPID sessID, LDATETIME dtm);
	int    SLAPI GetCashSessID(LDATETIME dtm, long cashNumber, long sessNumber, int forwardSess, int temporary, PPID * pSessID);
	int    SLAPI CalcSessionTotal(PPID sessID, CSessTotal *);
	//int    SLAPI GroupingSessList(const PPIDArray * pSessList, PPIDArray * pOutList, PPIDArray * pOutTempList, int use_ta);
	int    SLAPI ConvertTempSession(int forwardSess, PPIDArray * pSessList);
	//int    SLAPI ConvertSessListToBills(PPIDArray * pSessList, PPID locID, int use_ta);
	int    SLAPI FlashTempCcLines(SArray *, LAssocArray * pHasExLineList);

	LDATE  Beg, End;
	long   CnFlags;     // Флаги узла PPCashNode(NodeID) если ~0, то не инициализированы
	long   CnExtFlags;  // @v8.9.10 Расширенные флаги узла PPCashNode(NodeID) если ~0, то не инициализированы
	PPGoodsConfig * P_GCfg;

	struct LastSess {
		long  CashNumber;
		long  SessNumber;
		PPID  SessID;
		LDATETIME Dtm;
	};
	SArray * P_LastSessList;
	PPIDArray SessList;
	SString LogFmt_ExpGoods; // @used LogExportingGoodsItem()
};
//
// Descr: Общий базовый класс для некоторых асинхронных кассовых аппаратов,
//   работающих через DBF-таблицы.
//
class CS_1 : public PPAsyncCashSession {
public:
	SLAPI  CS_1(PPID);
	SLAPI ~CS_1();
	virtual int SLAPI ExportData(int) = 0;
	virtual int SLAPI GetSessionData(int * pSessCount, int * pIsForwardSess, DateRange * pPrd = 0) = 0;
	virtual int SLAPI ImportSession(int) = 0;
protected:
	int    SLAPI GetFileSet(char * pSectName, uint filesPerSet);
	DbfTable   * SLAPI OpenDBFTable(uint num, uint fn);
	BarcodeTbl * SLAPI CreateTmpBarToID(int, int fn, int fldGoodsID, int fldBarCode, int fldUnitPerPack);
	int    SLAPI ConvertCashList(int);
	int    SLAPI ConvertWareList(int);

	int    Valid;
	uint   FilesPerSet;
	uint   NumEntries;
	struct InFiles {
		char fn[5][MAXPATH];
	} * P_Entries;
};
//
// Макросы для регистрации кассового аппарата
//
#define REGISTER_CMT(nm,sync,async) \
static PPCashMachine * SLAPI Create_##nm(PPID cashID) { return (PPCashMachine*)new CM_##nm(cashID); } \
struct Registrar_##nm { Registrar_##nm(); }; \
void _Register_##nm() { PPCashMachine::RegisterMachine(PPCMT_##nm, Create_##nm, sync, async); } \
Registrar_##nm::Registrar_##nm() { _Register_##nm(); }
//
// @ModuleDecl(PPObjBarcodePrinter)
// Принтеры штрихкодов
//
struct PPBarcodePrinter2 { // @persistent @store(Reference2Tbl+)
	SLAPI  PPBarcodePrinter2()
	{
		THISZERO();
	}
	void   SLAPI Normalyze();

	enum {
		fPortEx = 0x0001 // Запись использует расширенное поле имени порта вывода
	};
	PPID   Tag;            // Const=PPOBJ_BCODEPRINTER
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   LabelName[20];  //
	char   Reserve[28];    // @reserve
	int16  BcNarrowPt;     // @v8.0.9 Толщина узких полос штрихкода (точек)
	int16  BcWidePt;       // @v8.0.9 Толщина широких полос штрихкода (точек)
	char   Port[20];       //
	CommPortParams Cpp;    // Size=6
	int16  Cp;             // @v9.2.7 Кодовая страница при выводе текста
	// @v9.2.7 int16  Reserve2;       // @alignment
	long   Flags;          //
	PPID   PrinterType;    // PPBCPT_ZEBRA | PPBCPT_DATAMAX
	long   Reserve3;       // @reserve
	//
	SString PortEx;        // @persistent @store(PropertyTbl[PPOBJ_BCODEPRINTER, id, BCPPRP_PORTEX]) @anchor
};

DECL_REF_REC(PPBarcodePrinter);

class PPObjBarcodePrinter : public PPObjReference {
public:
	SLAPI  PPObjBarcodePrinter(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPBarcodePrinter * pPack);
	int    SLAPI PutPacket(PPID * pID, PPBarcodePrinter * pPack, int use_ta);
};
//
// Descr: Интерфейс для работы с принтерами штрихкодов
//
class BarcodeLabelPrinter {
public:
	struct BarcodeLabelPrintParam {
		SLAPI  BarcodeLabelPrintParam();
		enum {
			fPrintAll    = 0x0001, // Печать всей выборки
			fQttyAsPack  = 0x0002, // Количество этикеток по каждой строке документа
				// рассчитывается как количество упаковок (в противном случае - количество торговых единиц)
			fInteractive = 0x0004  // @v9.6.6 Выводить дополнительный диалог перед печатью (для Windows-принтеров)
		};
		PPID   PrinterID;
		int16  NumCopies;
		int16  Pad;       // @alignment
		PPID   LocID;     // Склад, для которого печатается этикетка (от этого зависит цена и, возможно, ряд других параметров)
		long   Flags;     // @flags
		SString Port;     //
	};
	// @v9.2.7 static BarcodeLabelPrinter * SLAPI CreateInstance(PPID printerTypeID /* PPBCPT_XXX */);
	static BarcodeLabelPrinter * SLAPI CreateInstance(/*PPID printerTypeID*/const PPBarcodePrinter & rPrnPack); // @v9.2.7
	static int SLAPI PrintGoodsLabel(PPID goodsID);
	//
	// Descr: Печатает на принтер этикетку по данным, определенным параметром pRgi.
	//   Если параметр silent == 0, то предварительно выдает диалог, в котором пользователь
	//   может выбрать принтер, порт вывода и др параметры печати. Если silent != 0, то
	//   диалог не выдается, а печать реализуется по тем параметрам, которые заданы в
	//   характеристиках принтера prnID.
	//   Если silent != 0, то в случае возникновения ошибки, функция этого сообщения на
	//   экран не выводит.
	// Returns:
	//   >0 - этикетка успешно отпечатана
	//   <0 - пользователь отказался от печати
	//   0  - ошибка
	//
	static int SLAPI PrintGoodsLabel__(RetailGoodsInfo * pRgi, PPID prnID /*= 0*/, int silent /*= 0*/);
	static int SLAPI PrintGoodsLabel2(RetailGoodsInfo * pRgi, PPID prnID /*= 0*/, int silent /*= 0*/);
	static int SLAPI PrintLotLabel(PPID lotID);
		// @>>BarcodeLabelPrinter::PrintGoodsLabel
	static int SLAPI PrintLabelByBill__(PPBillPacket * pPack, uint pos);
	static int SLAPI PrintLabelByBill2(const PPBillPacket * pPack, uint pos);
	static int SLAPI UpLoad(PPID prnID, const char * pLoadName, int silent);
	static int SLAPI LoadFonts(PPID prnID, int silent);

	SLAPI  BarcodeLabelPrinter(const PPBarcodePrinter & rPrnPack);
	virtual SLAPI ~BarcodeLabelPrinter();
	virtual int SLAPI StartLabel(const BarcodeLabelParam *, int numCopies) = 0;
	virtual int SLAPI EndLabel() = 0;
	virtual int SLAPI PutDataEntry(const BarcodeLabelEntry *) = 0;
	virtual int SLAPI PrintLabel(const char * pPortName, const CommPortParams *);
	int    SLAPI PrintLabelUsb(PPID devType); // @vmiller
protected:
	int    FASTCALL PutStr(const char *);
	int    FASTCALL PutChr(char);
	int    SLAPI PutInt(int, int numDigits);

	PPBarcodePrinter PrnPack;
private:
	int    SLAPI Helper_PrintRgiCollection(const BarcodeLabelPrintParam & rBclpp, TSCollection <RetailGoodsInfo> & rList);

	SBuffer Buf;
};
//
// @ModuleDecl(PPObjStyloPalm)
//
#define PLMF_IMPASCHECKS      0x0001 // Документы с устройства можно импортировать как чеки.
	// Этот флаг не исключает возможности принимать документы с устройства и как обычные документы.
#define PLMF_GENERIC          0x0002 // Обобщенная запись, определяющая конфигурацию для нескольких устройств
#define PLMF_EXPCLIDEBT       0x0004 // Экспортировать долги по клиентам
#define PLMF_EXPSELL          0x0008 // Экспортировать продажи
#define PLMF_EXPBRAND         0x0010 // Экспортировать бренды и владельцев брендов
#define PLMF_INHFLAGS         0x0020 // Все флаги (кроме этого, конечно) наследуются от родительской группы
#define PLMF_EXPLOC           0x0040 // Экспортировать склады
#define PLMF_EXPSTOPFLAG      0x0080 // Экспортировать признак 'стоп' для клиентов
#define PLMF_ANDROID          0x0100 // КПК на базе google android. Экспорт/импорт в виде xml файла
#define PLMF_EXPIMAGES        0x0200 // Экспортировать картинки
#define PLMF_PALMLINKED       0x0400 // Данная учетная запись связана с КПК (только для Андроид)
#define PLMF_DISABLCEDISCOUNT 0x0800 // @v8.6.10 Запрет на установку общей скидки по заказу
#define PLMF_REGISTERED       0x1000 // @v8.7.0 Признак состоявшейся централизованной регистрации устройса. Если установлен, то последующая регистрация не возможна
#define PLMF_BLOCKED          0x2000 // @v9.4.7 Признак блокированного (украденного) устройства
#define PLMF_INHMASK          (PLMF_IMPASCHECKS|PLMF_EXPCLIDEBT|PLMF_EXPSELL|PLMF_EXPBRAND|PLMF_EXPLOC|PLMF_EXPSTOPFLAG|PLMF_DISABLCEDISCOUNT)
#define PLMF_TRANSMITMASK     (PLMF_DISABLCEDISCOUNT) // @v8.6.10 Флаги, которые передаются на устройство полем StyloFlags
//
// Descr: Флаги режима отслеживания гео-позиции устройства
//
#define GTMF_AUTO             0x0001 // Автоматически через заданные промежутки времени
#define GTMF_CHECKIN          0x0002 // Ручная регистрация местоположения
#define GTMF_EVNT_BILL        0x0004 // По событию создания документа
#define GTMF_FORCEGPSON       0x0008 // По возможности форсированно включать геолокацию на устройстве

struct PPGeoTrackingMode { // @persistent @size==8
	SLAPI  PPGeoTrackingMode();
	PPGeoTrackingMode & SLAPI Clear();
	int    FASTCALL operator == (const PPGeoTrackingMode & rS) const;
	int    FASTCALL operator != (const PPGeoTrackingMode & rS) const;

	int32  Mode;  // @flags GTMF_XXX
	int32  Cycle; // Периодичность автоматической регистрации положения устройства (ms)
};

struct PPStyloPalm2 {          // @persistent @store(Reference2Tbl+)
	PPID   Tag;                // Const=PPOBJ_STYLOPALM
	PPID   ID;                 // @id
	char   Name[48];           // @name @!refname
	char   Symb[20];           //
	int32  MaxUnsentOrders;  // Максимальное кол-во неотправленных заявок. При достижении этого числа, блокируется создание новой заявки.
	LDATETIME RegisterTime;    // @v8.7.0 Время регистрации (для централизованной регистрации устройств)
	LDATETIME LastExchgTime;   // @v8.7.0 Время последнего обмена данными
	uint32 DeviceVer;          // @v8.7.0 Версия системы на устройсве, считанная при последнем обмене
  	int16  TransfDaysAgo;      // @v9.2.2 Количество дней назад, начиная с которого надо отправлять документы с устройства. 0 - все, что есть
  	char   Reserve1[6];        // @reserve // @v9.2.2 [12]-->[10]
  	int32  InhBillTagVal;      // @v9.2.10 Значение тега документа, наследуемое принимаемыми заказами от устройства
		// Сам тег определяется в конфигурации StyloPalm
	PPGeoTrackingMode Gtm;     // @v8.6.8 Режим отслеживания положения устройства
	PPID   ObsoleteLocID;      // ->Location.ID // @v8.6.8 LocID-->ObsoleteLocID поле более не используется - только список складов PPStyloPalmPacket::LocList
	PPID   GoodsGrpID;         //
	PPID   OrderOpID;          // ->Ref(PPOBJ_OPRKIND)
	PPID   FTPAcctID;          //
	long   Flags;              // PLMF_XXX
	PPID   GroupID;            // ->Ref(PPOBJ_STYLOPALM) Группа, которой принадлежит устройство
		// Запись, порожденная от группы, наследует у группы следующие поля: LocID, OrderOpID,
		// Flags & (PLMF_IMPASCHECKS|PLMF_EXPCLIDEBT|PLMF_EXPSELL|PLMF_EXPBRAND), PPStyloPalmPacket::P_LocList
	PPID   AgentID;            // ->Article.ID; Agent - owner of palm
};

DECL_REF_REC(PPStyloPalm);

struct PPStyloPalmPacket {
public:
	SLAPI  PPStyloPalmPacket();
	SLAPI ~PPStyloPalmPacket();
	void   SLAPI destroy();
	PPStyloPalmPacket & FASTCALL operator = (const PPStyloPalmPacket &);
	int    SLAPI Setup();
	//
	// Returns:
	//   !0 - если P_Path != 0
	//    0 - если P_Path == 0
	int    SLAPI MakeOutputPath(SString & rBuf) const; // @>>PPStyloPalmPacket::MakePath
	//
	// Returns:
	//   !0 - если P_Path != 0
	//    0 - если P_Path == 0
	int    SLAPI MakeInputPath(SString & rBuf) const;  // @>>PPStyloPalmPacket::MakePath
	int    SLAPI MakePath(const char * pSuffix, SString & rBuf) const;

	PPStyloPalm Rec;
	char * P_Path;
	char * P_FTPPath;
	ObjIdListFilt LocList;
	ObjIdListFilt QkList; // @v9.5.5 Список видов котировок, используемых для передачи цен на устройства
};
//
//
//
struct PalmBillItem {
	PPID   GoodsID;
	double Qtty;
	double Price;
};

class PalmBillPacket : private SArray {
public:
	SLAPI  PalmBillPacket();
	int    SLAPI Init();
	uint   SLAPI GetItemsCount() const;
	int    SLAPI EnumItems(uint * pPos, PalmBillItem *) const;
	int    SLAPI AddItem(const PalmBillItem *);
	int    SLAPI RemoveItem(uint);

	struct Header {
		PPID   PalmID;
		long   ID;             // ИД документа на устройстве + смещение, необходимое для того, чтобы идентификаторы от разных устройств отличались
		long   OrgID;          // Оригинальный ИД документа на устройстве (без смещения)
		long   Op;             // Код операции (1 - заказ, 2 - инвентаризация)
		char   Code[12];
		LDATE  Dt;
		PPID   ClientID;
		PPID   AgentID;        //
		PPID   DlvrAddrID;
		PPID   QuotKindID;
		double Amount;
		double PctDis;
		char   Memo[160];
		PPID   LocID;
		LDATETIME CreateDtm;
		LDATETIME CreateDtmEnd;
		double Latitude;
		double Longitude;
		double LatitudeEnd;
		double LongitudeEnd;
	};

	Header Hdr;
};

struct PalmToDoItem { // @transient
	PPID   ID;            // ИД задачи в базе данных
	LDATE  DueDate;       // Дата планового завершения задачи
	LDATE  ComplDate;     // Дата фактического выполнения задачи
	PPID   AgentID;       // ->Article.ID
	int    Priority;      // Приоритет TODOPRIOR_XXX
	int    Completed;     // Признак завершенной задачи
	char   Descript[256];
	char   Memo[256];
};

struct PalmDebtMemoItem {
	PPID   BillID;     // Ид. долгового документа
	char   Memo[256];  // Примечание
};

class PalmBillQueue : private SArray {
public:
	SLAPI  PalmBillQueue();
	uint   SLAPI GetItemsCount() const;
	long   SLAPI GetBillIdBias() const;
	int    SLAPI IsEmpty() const;
	int    SLAPI Push(PalmBillPacket *);
	int    SLAPI PushUnique(PalmBillPacket * pPack);
	PalmBillPacket * SLAPI Pop();
	PalmBillPacket * SLAPI Peek();
	int    SLAPI AddItem(PPID billID, const PalmBillItem *, uint * pPos);
	int    SLAPI Destroy();

	int    SLAPI SetIdAssoc(PPID dvcID, PPID outerID, PPID innerID);
	PPID   SLAPI GetInnerIdByOuter(PPID dvcID, PPID outerID) const;
private:
	struct IdAssocItem {
		PPID   DvcID;
		PPID   OuterBillID;
		PPID   InnerBillID;
	};
    TSArray <IdAssocItem> IdAssocList; // Сопоставление внешних идентификаторов документов с идентификаторами в принимающей базе данных
};

struct PalmInputParam {
	SLAPI  PalmInputParam();

	PalmBillQueue * P_BillQueue;
	SQueue * P_ToDoQueue; // Queue of PalmToDoItem
	SQueue * P_DebtMemoQueue;
	TSArray <PPGeoTrackItem> * P_GtList;
};
//
// Descr: Класс, опрелеляющий блок данных для отображения на удаленном дисплее.
//
class PalmDisplayBlock {
public:
	friend class PPObjStyloPalm;
	friend class StyloDisplayQueue;

	SLAPI  PalmDisplayBlock();
	PalmDisplayBlock & Clear();

	enum {
		ctxNone = 0,
		ctxPersonEvent
	};
	enum {
		fError = 0x0001
	};
	SVerT Ver;
	PPID   DvcID;
	long   Flags;
	int32  Ctx;         // Тип контекста
	SBuffer CtxData;    // Контекстные данные
	SString DirectMsg;  // Прямое сообщение для устройства
private:
	uint32  QueuePos;   // @inner Идентификатор, с которым блок хранится в очереди.
		// Необходим для корректного удаления блока после подтверждения приема от устройства.
};
//
// Конфигурация обмена данными между Papyrus'ом и StyloPalm'ом
//
struct PPStyloPalmConfig {  // @persistent @store(PropertyTbl)
	enum {
		ordercodeIdHash = 1,
		ordercodeSymbName,
		ordercodeNameSymb
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_STYLOPALMCFG
	int16  SellAnlzTerm;    // Период (недель), на который необходимо подготовить данные о продажах (0 - не готовить)
	PPID   SellOpID;        // Вид операции продаж
	PPID   CliInvOpID;      // Вид операции инвентаризации клиентов
	int16  Reserve;         // @alignment
	int32  OrderCodeFormatType; // @v8.7.10 Тип формата номеров заказов
	PPID   InhBillTagID;    // @v9.2.11 Тег документа, наследуемый принимаемыми заказами от устройства
	char   Reserve1[40];
	long   Flags;
	long   Reserve2[2];
};

struct PalmPaneData {
	SLAPI  PalmPaneData();

	enum {
		fUpdateData   = 0x0001,
		fExportFTP    = 0x0002,
		fImportFTP    = 0x0004,
		fDelImpData   = 0x0008,
		fForceEdit    = 0x0010, // @v8.7.0 @internal При вызове функции PPObjStyloPalm::ImpExp() будет открываться диалог редактирования
			// параметров не зависимо от значения остальных полей этой структуры
		fExclExpDebts = 0x0020  // @v9.0.0 Не готовить данные для экспорта по долгам (ради ускорения процесса)
	};
	PPID   PalmID;
	PPID   OpID;
	PPID   LocID;
	long   Flags;
};

class PPObjStyloPalm : public PPObjReference {
public:
	static int SLAPI ReadConfig(PPStyloPalmConfig *);
	static int SLAPI EditConfig();
	static int SLAPI ImpExp(PalmPaneData *);
	static int SLAPI EditImpExpData(PalmPaneData *);
	static int SLAPI XmlCmpDtm(LDATE dt, LTIME tm, const char * pXmlPath);

	static int SLAPI PutDisplayBlock(PalmDisplayBlock & rBlk);
	static int SLAPI LockDisplayQueue(PPID dvcID);
	static int SLAPI UnlockDisplayQueue(PPID dvcID);
	static int SLAPI PeekDisplayBlock(PPID dvcID, PalmDisplayBlock & rBlk, int lock);
	static int SLAPI RemoveDisplayBlock(const PalmDisplayBlock & rBlk);
	static int SLAPI PopDisplayBlock(PPID dvcID, PalmDisplayBlock * pBlk, int lock);

	SLAPI  PPObjStyloPalm(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);

	int    SLAPI IsPacketEq(const PPStyloPalmPacket & rS1, const PPStyloPalmPacket & rS2, long flags);
	int    SLAPI GetChildList(PPID id, PPIDArray & rPalmList);
	int    SLAPI GetLocList(PPID id, ObjIdListFilt & rLocList);
	int    SLAPI GetQuotKindList(PPID id, ObjIdListFilt & rQuotKindList);
	int    SLAPI GetPacket(PPID id, PPStyloPalmPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPStyloPalmPacket * pPack, int use_ta);
	int    SLAPI CheckSignalForInput(const char * pPath);
	void   SLAPI ClearInputSemaphore(const char * pPath);
	int    SLAPI ReadInput(PPID id, PalmInputParam * pParam, long flags, PPLogger * pLogger, long * pOrdCount);
		// @<<PPObjStyloPalm::ImportData, @<<PalmImportWaiter::Activate
	int    SLAPI ExportData(const PalmPaneData & rParam);
	int    SLAPI CopyToFTP(PPID, int delAfterCopy, PPLogger *);
	int    SLAPI CopyFromFTP(PPID, int delAfterCopy, PPLogger *);
	int    SLAPI DeleteImportData(PPID id);
	//
	//
	//
	struct RegisterDeviceBlock {
        uint8  DeviceID[16];
	};

	int    SLAPI RegisterDevice(PPID id, RegisterDeviceBlock * pBlk, int use_ta);
private:
	class ExportBlock {
	public:
		struct GoodsGrpEntry {
			PPID   ID;
			PPID   ParentID;
			char   Name[64];
		};
		struct BrandEntry {
			PPID   BrandID;
			PPID   OwnerID;
			char   BrandName[64];
			char   OwnerName[128];
		};
		struct WhEntry {
			PPID   WhID;
			char   WhName[48];
		};
		ExportBlock();
		~ExportBlock();

        PPObjGoods * P_GObj;
        PPObjBrand * P_BrObj;
        PPObjPerson * P_PsnObj;
        PPObjLocation * P_LocObj;
        PPObjArticle * P_ArObj;
        PPViewDebtTrnovr * P_DebtView;
        PPViewGoodsRest * P_GrView;
        TSArray <BrandEntry> * P_BrandList;
        TSArray <WhEntry> * P_WhList;
        TSArray <GoodsGrpEntry> * P_GgList;
        StrAssocArray QkList;
	};
	virtual int  SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI CreateQkList(ExportBlock & rBlk);
	int    SLAPI CreateBrandList(ExportBlock & rBlk);
	int    SLAPI CreateWhList(ExportBlock & rBlk);
	int    SLAPI CreateGoodsGrpList(ExportBlock & rBlk);
	int    SLAPI Helper_GetPacket(PPID id, PPStyloPalmPacket * pPack, PPIDArray * pStack);
	int    SLAPI Helper_GetChildList(PPID id, PPIDArray & rPalmList, PPIDArray * pStack);
	int    SLAPI ResolveClientID(const char * pInTblPath, PPID inID, PPID * pOutID);
	int    SLAPI ImportData_(PPID id, PPID opID);
	int    SLAPI ReadInputBill(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger * pLogger, long * pOrdCount);
		//
	// Документы инвентаризации заносятся в туже очередь, что и документы заказов, но
	// поле PalmBillHeader::Op = 2
	//
	int    SLAPI ReadInputInv(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger *);
	int    SLAPI ReadInputToDo(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/, PPLogger *);
	int    SLAPI ReadInputDebtMemo(PPStyloPalm *, const char * pPath, PalmInputParam *, long /*flags*/);
	int    SLAPI ImportData(PPID, PPID opID, PPID locID, PPLogger * pLog);
		// @<<PPObjStyloPalm::ImpExp
	int    SLAPI ImportBill(PalmBillQueue * pQueue, PPID opID, PPID locID, PPLogger * pLogger, long ordCount, int use_ta);
		// @<<PPObjStyloPalm::ImportData
	int    SLAPI ImportOrder(PalmBillPacket * pSrcPack, PPID opID, PPID locID,
		/*int orderCodeFormatType*/const PPStyloPalmConfig & rCfg, PPID * pResultID, PPLogger * pLogger, int use_ta);
	int    SLAPI ImportInventory(PalmBillPacket * pSrcPack, PPID opID, PPID locID, PPLogger * pLogger, int use_ta);
	int    SLAPI ImportToDo(SQueue *, PPLogger * pLogger, int use_ta);
	int    SLAPI ImportToDo(const PPStyloPalmPacket *);
	int    SLAPI ImportDebtMemo(SQueue *, PPLogger * pLogger, int use_ta);
	int    SLAPI ExportGoods(const PPStyloPalmPacket * pPack, ExportBlock & rBlk);
	int    SLAPI ExportClients(PPID acsID, long palmFlags, ExportBlock & rBlk);
};
//
// Класс PalmImportWaiter реализует функции ожидания, постановки в очередь и
// обработки документов, поступивших с PDA в компьютер.
//

//
// Функция PalmImportProc должна возвращать следующие значения //
//
#define PIPR_ERROR_BREAK  0 // пакет не обработан по причине возникновения ошибки, следует прервать обработку очереди
#define PIPR_OK_CONTINUE  1 // пакет успешно обработан и функция готова к обработке следующего пакета
#define PIPR_OK_BREAK     2 // пакет успешно обработан, но обслуживание очереди следует прервать
#define PIPR_OK_DESTROY   3 // пакет успешно обработан, обслуживание очереди прервать и очистить очередь

typedef int (*PalmImportProc)(PalmBillPacket *, void *);

class PalmImportWaiter {
public:
	SLAPI  PalmImportWaiter(PalmImportProc, void * procExtraPtr);
	SLAPI ~PalmImportWaiter();
	int    SLAPI Activate();
private:
	int    SLAPI InitDeviceList();
	int    SLAPI ProcessQueue();

	struct DeviceEntry {
		PPID   ID;
		char   Path[MAXPATH];
	};
	PPObjStyloPalm PalmObj;
	SArray * P_DeviceList;
	PalmBillQueue Queue;
	PalmImportProc Proc;
	void * ProcExtraPtr;
	int    Semaphore;
};
//
// @ModuleDecl(PPObjTouchScreen)
// TouchScreen
//
#define TSF_PRINTSLIPDOC  0x0001 // Печать подкладного документа (вместо печати на принтер)
#define TSF_TXTSTYLEBTN   0x0002 // Текст на кнопках

struct PPTouchScreen2 {    // @persistent @store(Reference2Tbl+)
	SLAPI  PPTouchScreen2()
	{
		THISZERO();
	}
	PPID   Tag;                 // Const=PPOBJ_TOUCHSCREEN
	PPID   ID;                  // @id
	char   Name[48];            // @name @!refname
	char   Symb[20];            //
	char   Reserve[20];         // @reserve
	long   GdsListFontHight;    //
	char   GdsListFontName[32]; //
	uint8  GdsListEntryGap;     // Дополнительное слагаемое высоты строки списка выбора товара (pixel)
		// Рекомендуемый диапазон: [0..8]
	uint8  Reserve2[3];         // @alignment
	long   Flags;               // TSF_XXX
	PPID   TouchScreenType;     //
	PPID   AltGdsGrpID;         // Альтернативная группа, товары из которой показываются в кассовой панели по умолчанию
};

DECL_REF_REC(PPTouchScreen);

class PPTouchScreenPacket {
public:
	SLAPI  PPTouchScreenPacket();
	PPTouchScreenPacket & FASTCALL operator = (const PPTouchScreenPacket &);
	PPTouchScreen Rec;
	PPIDArray GrpIDList;
};

class PPObjTouchScreen : public PPObjReference {
public:
	SLAPI  PPObjTouchScreen(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPTouchScreenPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPTouchScreenPacket * pPack, int use_ta);
};
//
//
//
#define PHNSVCTYPE_ASTERISK 1

struct PPPhoneService {
	PPPhoneService();

	PPID   Tag;                 // Const=PPOBJ_PHONESERVICE
	PPID   ID;                  // @id
	char   Name[48];            // @name
	char   Symb[20];            // @symb
	char   Reserve[60];         // @reserve
	long   Flags;               // @flags
	long   DvcType;             // Тип устройства
	long   Val2;                //
};

#define PHNSVCEXSTR_ADDR     1
#define PHNSVCEXSTR_PORT     2
#define PHNSVCEXSTR_USER     3
#define PHNSVCEXSTR_PASSWORD 4

class PPPhoneServicePacket {
public:
	SLAPI  PPPhoneServicePacket();
	int    SLAPI GetExField(int fldId, SString & rBuf) const;
	int    SLAPI SetExField(int fldId, const char * pBuf);
	int    SLAPI GetPassword(SString & rBuf) const;
	int    SLAPI SetPassword(const char * pPassword);

	PPPhoneService Rec;
	SString Tail;
	SString LocalChannelSymb; // Символ локального канала. хранится в реестре Windows
};

class PPObjPhoneService : public PPObjReference {
public:
	SLAPI  PPObjPhoneService(void * extraPtr);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI PutPacket(PPID * pID, PPPhoneServicePacket *, int use_ta);
	int    SLAPI GetPacket(PPID id, PPPhoneServicePacket *);
};
//
//
//
struct PhnSvcChannelStatus {
	enum {
		stDown     = 0,    // Channel is down and available
		stReserved = 1,    // Channel is down, but reserved
		stOffHook,         // Channel is off hook
		stDialing,         // Digits (or equivalent) have been dialed
		stRing,            // Line is ringing
		stRinging,         // Remote end is ringing
		stUp,              // Line is up
		stBusy,            // Line is busy
		stDialingOffHook,  // Digits (or equivalent) have been dialed while offhook
		stPreRing          // Channel has detected an incoming call and is waiting for ring
	};
	enum {
		fMute = 0x0001
	};
	PhnSvcChannelStatus();
	PhnSvcChannelStatus & Clear();

	long   State;
	long   Flags;
	long   Priority;
	long   Seconds;
	SString Channel;
	SString CallerId;
	SString ConnectedLineNum; // @v7.8.0
};

class PhnSvcChannelStatusPool : SArray {
public:
	PhnSvcChannelStatusPool();
	uint   GetCount() const;
	int    FASTCALL Add(const PhnSvcChannelStatus & rStatus);
	int    FASTCALL Get(uint idx, PhnSvcChannelStatus & rStatus) const;
	PhnSvcChannelStatusPool & Clear();
private:
	struct Item_ {
		long   State;
		long   Flags;
		long   Priority;
		long   Seconds;
		uint   ChannelPos;
		uint   CallerIdPos;
		uint   ConnectedLineNumPos; // @v7.8.0
	};
	StringSet Pool;
};

class AsteriskAmiClient {
public:
	enum {
		stConnected = 0x0001,
		stLoggedOn  = 0x0002
	};
	class Message : public StringSet {
	public:
		struct ReplyStatus {
			int    Code;          // -1 undef; 1 - success; 0 - error
			int    EventListFlag; // -1 - undef; 0 - start; 1 - end or complete; 2 - cancelled
			SString Message;
		};
		Message();
		Message(const char * pReply);

		int    Get(uint * pPos, SString & rTag, SString & rValue) const;
		int    GetTag(const char * pTag, SString & rValue) const;
		int    Convert(SString & rBuf) const;
		Message & Clear();
		int    Add(const char * pTag, const char * pValue);
		int    AddAction(const char * pValue);
		int    ParseReply(const char *);
		int    GetReplyStatus(ReplyStatus & rS) const;
	};

	static int GetStateText(long state, SString & rBuf);
	static int GetStateVal(const char * pText, long * pState);

	AsteriskAmiClient();
	~AsteriskAmiClient();
	int    Connect(const char * pServerAddr, int serverPort);
	int    Login(const char * pUserName, const char * pPassword);
	int    Logout();
	int    GetChannelList(const char * pChannelName, PhnSvcChannelStatusPool & rList);
	int    GetChannelStatus(const char * pChannelName, PhnSvcChannelStatusPool & rList);
	int    ExecCommand(const Message & rIn, Message * pOut);
	int    ReadReply(Message & rOut);
	int    Read(Message & rMsg);
private:
	int    Log(const char * pText);

	struct AsteriskAmiStateStr {
		long   State;
		const char * P_Str;
	};
	static AsteriskAmiStateStr StateList[];
	long   State;
	TcpSocket S;
};
//
// @ModuleDecl(PPObjInternetAccount)
//
#define MAEXSTR_SENDSERVER       1 // Сервер исходящей почты (SMTP)
#define MAEXSTR_SENDPORT         2 // Порт исходящей почты (SMTP)
#define MAEXSTR_RSRVSENDSERVER   3 // Резервный сервер исходящей почты (SMTP)
#define MAEXSTR_RSRVSENDPORT     4 // Резервный порт исходящей почты (SMTP)
#define MAEXSTR_RCVSERVER        5 // Сервер входящей почты (POP3)
#define MAEXSTR_RCVPORT          6 // Порт входящей почты (POP3)
#define MAEXSTR_RCVNAME          7 // Имя для доступа к серверу входящей почты (POP3)
#define MAEXSTR_RCVPASSWORD      8 // Пароль для доступа к серверу входящей почты (POP3)
#define MAEXSTR_FROMADDRESS      9 // Обратный почтовый адрес
#define FTPAEXSTR_HOST           MAEXSTR_SENDSERVER     // Ftp сервер
#define FTPAEXSTR_PORT           MAEXSTR_SENDPORT       // Порт ftp сервера
#define FTPAEXSTR_PROXY          MAEXSTR_RSRVSENDSERVER // Proxy сервер
#define FTPAEXSTR_PROXYPORT      MAEXSTR_RSRVSENDPORT   // Порт proxy сервера
#define FTPAEXSTR_USER           MAEXSTR_RCVNAME        // Имя для доступа к ftp серверу
#define FTPAEXSTR_PASSWORD       MAEXSTR_RCVPASSWORD    // Пароль для доступа к ftp серверу
#define FTPAEXSTR_PROXYUSER     10 // Имя для доступа к proxy серверу
#define FTPAEXSTR_PROXYPASSWORD 11 // Пароль для доступа к proxy серверу
//
// Тип аутентификации для отправки почты
//
/* @v8.3.5
#define PPMSMTPAUTHTYPE_PLAIN    1L
#define PPMSMTPAUTHTYPE_LOGIN    2L
#define PPMSMTPAUTHTYPE_MD5      3L
#define PPMSMTPAUTHTYPE_POP3     4L
*/

struct PPInternetAccount2 { // @persistent @store(Reference2Tbl+)
	enum {
		fFtpAccount = 0x0001L,
		fFtpPassive = 0x0002L, // Пассивный режим
		fUseSSL     = 0x0004L  // @v8.3.5
	};
	SLAPI  PPInternetAccount2();
	void   SLAPI Init();
	int    SLAPI Cmp(PPInternetAccount2 * pAccount); // realy const
	int    SLAPI NotEmpty();
	//int    SLAPI GetExtField(int fldID, char * pBuf, size_t bufLen);
	int    SLAPI GetExtField(int fldID, SString & rBuf);
	int    SLAPI SetExtField(int fldID, const char * pBuf);
	int    SLAPI SetPassword(const char *, int fldID = MAEXSTR_RCVPASSWORD);
	int    SLAPI GetPassword(char * pBuf, size_t bufLen, int fldID = MAEXSTR_RCVPASSWORD);
	int    SLAPI SetMimedPassword(const char * pPassword, int fldID  = MAEXSTR_RCVPASSWORD);
	int    SLAPI GetMimedPassword(char * pBuf, size_t bufLen, int fldID = MAEXSTR_RCVPASSWORD);
	int    SLAPI GetSendPort();
	int    SLAPI GetRcvPort();
	//
	long   Tag;            // Const=PPOBJ_INTERNETACCOUNT
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	uint16 SmtpAuthType;   // Тип аутентификации для соединения с SMTP сервером
	int16  Timeout;        // Таймаут сервера (сек)
	long   Flags;          //
	PPID   PersonID;       // ->Person.ID
	long   Reserve2;       // @reserve
	//
	SString ExtStr;        // @anchor
};

DECL_REF_REC(PPInternetAccount);

typedef TSCollection <PPInternetAccount> PPInetAccntArray;

#define INETACCT_ONLYMAIL 0L
#define INETACCT_ONLYFTP  1L

class PPObjInternetAccount : public PPObjReference {
public:
	SLAPI  PPObjInternetAccount(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI Get(PPID id, PPInternetAccount * pPack);
	int    SLAPI Put(PPID * pID, PPInternetAccount * pPack, int use_ta);
};
//
//
//
struct StConfig {
	StConfig();
	void   Clear();
	/* @v9.5.12 (emitted)
	int    SetConfig_(const char * pHost, uint port, const char * pSystemId, const char * pLogin,
		const char * pPassword, const char * pSystemType, uint sourceAddressTon, uint sourceAddressNpi,
		uint destAddressTon, uint destAddressNpi, uint dataCoding, const char * pFrom, uint splitLongMsg);
	*/
	SString Host;
	uint   Port;
	SString SystemId; // Идентификатор клиента в системе
	SString Login;
	SString Password;
	SString SystemType; // Тип системы
	SString AddressRange; // Фильтр адресов отправителя
	uint   SourceAddressTon; // Тип номера отправителя
	uint   SourceAddressNpi; //Цифровой индикатор плана отправителя
	uint   DestAddressTon; // Тип номера получателя
	uint   DestAddressNpi; // Цифровой индикатор плана получателя
	uint   DataCoding; // Схема кодирования сообщения
	uint   EsmClass; // Тип сообщения и режим отправки сообщения
	SString From; // Имя или номер отправителя
	uint   SplitLongMsg; // Разбивать или нет длинные сообщения
	uint16 ResponseTimeout;
	uint16 ResendMsgQueueTimeout;
	uint16 ResendTriesNum;
	uint16 ReconnectTimeout;
	uint16 ReconnectTriesNum;
};

class SmsClient {
public:
	SLAPI  SmsClient(PPLogger * pLogger);
	SLAPI ~SmsClient();
	//int    SLAPI IsConnected() const;
	int    SLAPI SendSms(const char * pTo, const char * pText, SString & rStatus);
	int    SLAPI SmsInit_(PPID accID, const char * pFrom);
	int    SLAPI SendingSms_(PPID personId, const char * pPhone, const char * pText);
	int    SLAPI SmsRelease_();
	//
	// @v8.5.4 void   SetRecvTimeout(int timeout) { RecvTimeout = timeout; }
private:
	struct StSubmitSMParam { // Структура параметров запроса submit_sm
		StSubmitSMParam();
		void   Clear();

		uchar  SourceAddressTon;
		uchar  SourceAddressNpi;
		uchar  DestinationAddressTon;
		uchar  DestinationAddressNpi;
		uchar  EsmClass;
		uchar  ProtocolId;
		uchar  PriorityFlag;
		uchar  ReplaceIfPresentFlag;
		uchar  DataCoding;
		uchar  SmDefaultMsgId;
		uint8  Reserve[2]; // @alignment
		SString SourceAddress;
		SString DestinationAddress;
		SString SheduleDeliveryTime;
		SString ValidityPeriod;
	};
	struct StSMResults {
		StSMResults();
		int    GetResult(int kindOfResult);

		int    BindResult;
		int    UnbindResult;
		int    SubmitResult;
		int    DataResult;
		int    EnquireLinkResult;
		int    GenericNackResult;
	};
	// @v9.5.11 (emitted) int    CanSend() const;
	//
	// Descr: Считывает из массива ErrorSubmitArr номер абонента и описание ошибки отправленного сообщения
	//
	// @v9.5.11 (emitted) int    GetErrorSubmit(SString & rDestNum, SString & rErrText, size_t pos) const;
	//
	// Descr: Считывает номер абонента и описание состояния сообщения из массива состояний StatusCodesArr
	//
	// @v9.5.11 (emitted) int    GetStatusCode(SString & rDestNum, SString & rStatus, size_t pos) const;
	//
	// Descr: Добавляет информацию об ошибочных командах посылки смс в массив ErrorSubmitArr
	//
	void   AddErrorSubmit(const char * pDestNum, int errCode);
	void   DecodeDeliverSm(int sequenceNumber, void * pPduBody, size_t bodyLength);
	void   DisconnectSocket();
	//
	// Descr: Добавляет статус смс в массив StatusCodesArr
	//
	void   AddStatusCode(const char * pDestNum, int statusCode, const char * pError);
	int    SendSms_(const char * pFrom, const char * pTo, const char * pText);
	//int    Send_(const void * data, size_t bufLen);
	int    Send(const SmsProtocolBuf & rBuf, int tryReconnect);
	int    Bind();
	int    Unbind();
	int    SubmitSM(const StSubmitSMParam & rParam, const char * pMessage, bool payloadMessage);
	int    ConnectToSMSC();
	int    TryToReconnect(uint & rRecconectionCount);
	// @v9.5.12 (emitted) int    SendEnquireLink(int sequenceNumber);
	// @v9.5.12 (emitted) int    SendEnquireLinkResp(int sequenceNnumber);
	int    SendGenericNack(int sequenceNumber, int commandStatus);
	// @v9.5.12 (emitted) int    SendDeliverSmResp(int sequenceNumber);
	int    Receive(uint timeout);
	//
	// Descr: Если USE_ENQUIRELINK = true, то посылает команду на проверку связи через каждый промежуток времени ENQUIRE_LINK_TIMEOUT
	//
	int    ReceiveToTimer();

	PPUhttClient * P_UhttCli;
	TcpSocket ClientSocket;
	LDATETIME StartTime;
	StConfig Config;
	StSMResults SMResults;
	StSubmitSMParam SMParams;
	//
	// Массив с информацией об ошибочных запросах посылки смс. Сруктура записи: номер_получателя;описание_ошибки
	//
	StrAssocArray ErrorSubmitArr;
	//
	// Массив структур состояний сообщений, в том числе и ошибочных. Сруктура записи: номер_получателя;состояние_сообщения
	//
	StrAssocArray StatusCodesArr;
	int    ConnectionState;
	uint   ResendErrLenMsg; // Счетчик попыток переотправить сообщение при неверной его длине
	uint   ReSendQueueMsgTryNums; // Счетчик попыток переотправить смс, которые не были отправлены из-за переполнения очереди
	uint   MessageCount; // Счетчик успешных запросов отправки сообщения (submit_sm)
	uint   SequenceNumber; // Номер пакета
	uint   AddStatusCodeNum; // Счетчик элементов массива StatusCodesArr
	uint   AddErrorSubmitNum; // Счетчик эелементов массива ErrorSubmitArr
	uint   UndeliverableMessages; // Счетчик недоставляемых сообщений
	// @v8.5.4 int    RecvTimeout;  // Таймаут получение данных
	PPLogger * P_Logger;
};
//
// @ModuleDecl(PPObjSmsPrvAccount)
//
#define	SMEXTSTR_HOST          1 // Интрефейс, через который работает клиент
#define	SMEXTSTR_PORT_OBSOLETE 2 // @v8.5.4 SMEXTSTR_PORT-->SMEXTSTR_PORT_OBSOLETE
#define	SMEXTSTR_SYSTEMID      3 // Идентификатор клиента в системе
#define	SMEXTSTR_PASSWORD      4 // Пароль доступа к SMPP-сервису
#define	SMEXTSTR_FROM          5 // Имя отправителя в том виде, как его будут видеть получатели
#define	SMEXTSTR_SYSTYPE       6 // Тип системы
//
// Общая структура для смс-уведомлений (автоматическая рассылка)
//
struct PPAutoSmsConfig {
	enum {
		asmsDaysMon = 0x01,
		asmsDaysTue = 0x02,
		asmsDaysWed = 0x04,
		asmsDaysThu = 0x08,
		asmsDaysFri = 0x10,
		asmsDaysSat = 0x20,
		asmsDaysSun = 0x40
	};
	PPAutoSmsConfig();
	int    SLAPI IsEmpty() const
	{
		return TddoPath.Empty() || !AllowedWeekDays || !AllowedStartTm || !AllowedEndTm;
	}
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx); // для запихивания стурктуры в буфер

	uint8  Reserve[32];
	SString TddoPath; // Путь к файлу шаблона сообщения //
	uint16 AllowedWeekDays;
	uint16 Reserve2;
	LTIME  AllowedStartTm;
	LTIME  AllowedEndTm;
};
//
// @todo Передалать структуру - она ужасна.
//
struct PPSmsAccount { // size=sizeof(Reference2Tbl::Rec)
	enum {
		smacfSpliLongMsg = 0x0001,
		smacfUseUHTT     = 0x0002
	};
	SLAPI  PPSmsAccount();
	int    FASTCALL IsEqual(const PPSmsAccount & rS) const;

	long   Tag;            // Const=PPOBJ_SMSPRVACCOUNT
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[46];    // @reserve [60] --> [50]
	int32  ServerPort;     // Порт сервера (адрес хранится в PPSmsAccPacket::ExtStr[SMEXTSTR_HOST]
	long   Flags;          // smacfXXX
	PPID   PersonID;       // ->Person.ID
	long   Reserve2;       // @reserve
	//
	// System params {
	//
	uint16 ResponseTimeout;
	uint16 ResendMsgQueueTimeout;
	uint16 ResendTriesNum;
	uint16 ReconnectTimeout;
	uint16 ReconnectTriesNum;
	// }
};
//
// @v8.5.4 DECL_REF_REC(PPSmsAccount);
//
class PPSmsAccPacket {
public:
	SLAPI  PPSmsAccPacket();
	void   SLAPI Init();
	int    FASTCALL IsEqual(const PPSmsAccPacket & rS) const;
	//
	// Descr: Опции функции PPSmsAccPacket::Verify
	//
	enum {
        vfEditingOnly = 0x0001 // Проверка только для этапа редактирования учетной записи
	};

	int    SLAPI Verify(long flags) const;
	int    SLAPI SetPassword(const char *);
	int    SLAPI GetPassword(SString & rBuf) const;

	PPSmsAccount Rec;
	SString ExtStr;
};

typedef TSCollection <PPSmsAccount> PPSmsAccntArray;

class PPObjSmsAccount : public PPObjReference {
public:
	static int SLAPI VerifyString(const SString & rStr, int options);
	static int SLAPI BeginDelivery(PPID accID, StrAssocArray & rPrsnIdArr, StrAssocArray & rPhoneArr);
	static int SLAPI BeginDelivery(PPID accID, StrAssocArray & rPrsnIdArr, StrAssocArray & rPhoneArr, PPID objTypeId, StrAssocArray & rObjIdArr);

	SLAPI  PPObjSmsAccount(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPSmsAccPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPSmsAccPacket * pPack, int use_ta);
};

int    GetSmsConfig(PPSmsAccPacket & rPack, StConfig & rConfig);
int    FormatPhone(const char * pOldPhone, SString & rNewPhone, SString & rMsg);

class PPSmsSender {
public:
	struct FormatMessageBlock {
		FormatMessageBlock()
		{
			PersonID = 0;
		}
		PPID   PersonID;
	};
	static int SLAPI FormatMessage(const char * pTemplate, SString & rResult, FormatMessageBlock * pFmBlk);
	static int SLAPI GetSubstVar(long p, SString & rBuf);

	SLAPI  PPSmsSender();
	SLAPI ~PPSmsSender();
};
//
// @ModuleDecl(PPObjSmsText)
//
#define	SENDSMEXTSTR_TEXT	1	// Текст сообщения //

struct PPSendSmsParam {
	SLAPI  PPSendSmsParam();
	void   SLAPI Init();
	int    SLAPI NotEmpty();

	long   Tag;            // Const=PPOBJ_SENDSMS
	long   ID;             //
	int	   SymbolCount;
	int	   SmsCount;
	//
	SString ExtStr;        // @anchor
};

class PPObjSendSms : public PPObjReference {
public:
	SLAPI  PPObjSendSms(void * extraPtr = 0);
	//virtual int SLAPI Edit(PPID *, long);
	//virtual int SLAPI Browse(long extra);
	int    SLAPI Get(PPID id, PPSendSmsParam *);
	int    SLAPI Put(PPID * pID, PPSendSmsParam *, int use_ta);
};
//
// @v7.6.1 @Muxa {
//
// @ModuleDecl(PPObjUhttStore)
//
struct PPUhttStore { // @size=sizeof(Reference2Tbl::Rec)
	enum {
		fUseGoodsPkg           = 0x0001, // Использовать емкость упаковки
		fShowRest              = 0x0002, // Показывать остатки
		fDontShowZeroRestItems = 0x0004, // Не показывать позиции для которых остаток нулевой
		fCreateBuyerPerson     = 0x0008  // @v8.8.1 При регистрации продажи (заказа) по возможности создавать персоналию (
			// в противном случае создается автономный адрес)
	};
	enum {
		kGenericStore          = 0, // Магазин, продающий товары
		kTSessCip              = 1  // Выставляется на продажу персональная регистрация в технологических сессиях
	};
	long   Tag;            // Const=PPOBJ_UHTTSTORE
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	long   Kind;           // Вид торговой площадки PPUhttStore::kXXX
	double UpRestShowThreshold; // Порог остатка, значения выше которого следует отабражать как, например, "более 8"
	long   Flags;          // @flags
	PPID   PersonID;       // ->Person.ID
	PPID   LocID;          // ->Location.ID
};

class PPUhttStoreSelDescr : private SStrGroup {
public:
	friend class PPObjUhttStore;

	enum {
		attrGroup     = 1,
		attrBrand     = 2,
		attrName      = 3,
		attrClass     = 4,
		attrTag       = 5,

		attrPeriod    = 6,
		attrProcessor = 7,
		attrCity      = 8
	};
	struct Entry {
		Entry();

		int    Attr;
		union {
			PPID   ClsID;
			PPID   TagID;
		};
		int    GcClsf; // Классификатор товара, принадлежащего классу PPGdsCls::eXXX
		SString Title;
	};

	SLAPI  PPUhttStoreSelDescr();
	PPUhttStoreSelDescr & SLAPI Destroy();
	int    FASTCALL IsEqual(const PPUhttStoreSelDescr & rS) const;
	uint   SLAPI GetCount() const;
	int    SLAPI ValidateEntry(const Entry * pEntry) const;
	int    SLAPI AddEntry(uint * pPos, const Entry * pEntry);
	int    SLAPI UpdateEntry(uint pos, const Entry * pEntry);
	int    SLAPI GetEntry(uint pos, Entry & rEntry) const;
	int    SLAPI GetDefaultEntryTitle(uint pos, SString & rBuf) const;
	int    SLAPI Pack();
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	struct InnerEntry {
		int32  Attr;
		int32  ExtID;
		int32  GcClsf; // Классификатор товара, принадлежащего классу PPGdsCls::eXXX
		uint   TitleP;
	};
	SVerT Ver; // Для сериализации
	TSArray <InnerEntry> L;
};

class PPUhttStorePacket {
public:
	SLAPI  PPUhttStorePacket();
	SLAPI ~PPUhttStorePacket();
	int    FASTCALL IsEqual(const PPUhttStorePacket & rS) const;
	void   SLAPI destroy();
	//
	// Descr: Возвращает список селекторов, откорректированный с учетом
	//   переданного параметром clsID товарного класса.
	//   Возвращаемый список содержит пару { key; val }, где
	//   key - [1..] целочисленная позиция селектора в списке Sd
	//   val - строковый заголовок селектора
	//
	int    SLAPI GetSelectorListInfo(PPID clsID, StrAssocArray & rList) const;

	PPUhttStore Rec;
	ObjTagList  TagL;        // Список тегов
	PPUhttStoreSelDescr Sd;  // Селекторы
};

class PPObjUhttStore : public PPObjReference {
public:
	SLAPI  PPObjUhttStore(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI ValidatePacket(const PPUhttStorePacket * pPack, long flags);
	int    SLAPI Fetch(PPID id, PPUhttStore * pRec);
	int    SLAPI PutPacket(PPID * pID, PPUhttStorePacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPUhttStorePacket * pPack);
private:
	int    SLAPI SerializePacket(int dir, PPUhttStorePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	virtual void SLAPI Destroy(PPObjPack*);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
};
// } @v7.6.1 @Muxa
//
// @v7.9.2 @Muxa {
//
// @ModuleDecl(PPObjWorkbook)
//
//
// Descr: Типы записей Workbook
// @persistent
//
#define PPWBTYP_UNDEF   0
#define PPWBTYP_PAGE    1
#define PPWBTYP_CSS     2
#define PPWBTYP_MEDIA   3
#define PPWBTYP_FOLDER  4
#define PPWBTYP_SITE    5
#define PPWBTYP_KEYWORD 6
//
// Descr: Флаги записей Workbook
// @persistent
//
#define PPWBF_HIDDEN           0x0001
#define PPWBF_DONTSHOWCHILDREN 0x0002
#define PPWBF_KWDONTSHOWMAINC  0x0004
//
// Descr: Коды дополнительных строковых значений записей рабочей книги
//
#define WBEXSTR_DESCRIPTION    1

struct PPWorkbookConfig { // @persistent @store(PropertyTbl)
	SLAPI  PPWorkbookConfig();
	PPWorkbookConfig & SLAPI Clear();

	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_WORKBOOKCFG
	PPID   SymbCntrID;         // ->Ref(PPOBJ_OPCOUNTER)
	PPID   DefImageFolderID;   // ->Ref(PPOBJ_WORKBOOK)
	PPID   UhttXEvTokID;       // @v9.3.9 ->Ref(PPOBJ_EVENTTOKEN) Событийная метка последнего обмена с Universe-HTT
	uint8  Reserve[52];        // @reserve
	long   ReservVal1;         // @reserve
	long   ReserveVal2;        // @reserve
};

class PPWorkbookPacket {
public:
	SLAPI  PPWorkbookPacket();
	SLAPI ~PPWorkbookPacket();
	int    FASTCALL IsEqual(const PPWorkbookPacket & rS) const;
	void   SLAPI destroy();
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char * pBuf);
	int    SLAPI SetLongSymb(const char * pSymb);

	WorkbookTbl::Rec Rec;
	enum {
		ufDontChgContent = 0x0001, // Функция PPObjWorkbook::PutPacket не должна изменять контент записей
	};
	long   UpdFlags;        // @transient @v8.2.3 Флаги, определяющие правила изменения некоторых полей

	ObjTagList TagL;        // Список тегов
	ObjLinkFiles F;
	SString ExtString;
};

class WorkbookCore : public WorkbookTbl {
public:
	friend class PPTblEnum <WorkbookCore>;
	enum {
		idxfldParent = 1,
		idxfldType
	};
	enum {
		eoIdName = 0x0001, // Инициализировать запрос на поля ID, Name, Rank
		eoIdSymb = 0x0002  // Инициализировать запрос на поля ID, Symb, Rank
		// Если указаны и eoIdName и eoIdSymb, то запрос результат содержит {ID, Rank, ObjName, Symb}
	};

	SLAPI  WorkbookCore();
	int    SLAPI GetChildList(PPID id, int recursive, PPIDArray & rList);
	SEnumImp * SLAPI Enum(int options);
	SEnumImp * SLAPI EnumByParent(PPID parentID, int options);
	SEnumImp * SLAPI EnumByType(long type, int options);
	int    SLAPI NextEnum(long enumHandle, WorkbookTbl::Rec * pRec);
	int    SLAPI Arrange(PPID rootID);
private:
	int    SLAPI Helper_GetChildList(PPID id, int recursive, PPIDArray & rList, PPIDArray * pRecurTrace);
	int    SLAPI InitEnum(int options, long * pHandle);
	int    SLAPI InitEnumByParam(int fldId, PPID param, int flags, long * pHandle);

	PPTblEnumList EnumList;
};

class PPObjWorkbook : public PPObject {
public:
	static int SLAPI ReadConfig(PPWorkbookConfig * pCfg);
	static int SLAPI EditConfig();

	SLAPI  PPObjWorkbook(void * extraPtr = 0);
	SLAPI ~PPObjWorkbook();
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);

	virtual int  SLAPI Search(PPID id, void * b = 0);
	int    SLAPI SearchByName(const char * pName, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SLAPI SearchBySymb(const char * pSymb, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SLAPI SearchByLongSymb(const char * pLongSymb, PPID * pID, WorkbookTbl::Rec * pRec = 0);
	int    SLAPI SearchAnalog(const WorkbookTbl::Rec * pSample, PPID * pID, WorkbookTbl::Rec * pRec);
	int    SLAPI Fetch(PPID id, WorkbookTbl::Rec * pRec);

	int    SLAPI MakeUniqueCode(SString & rBuf, int use_ta);

	int    SLAPI PutPacket(PPID * pID, PPWorkbookPacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPWorkbookPacket * pPack);
	StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI SetupParentCombo(TDialog *, uint ctlID, int itemType, PPID itemID, PPID parentID);
	int    SLAPI SetupCSSCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID, PPID cssID);
	int    SLAPI SetupLinkCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID, PPID linkID);
	int    SLAPI SetupItemCombo(TDialog * dlg, uint ctlID, int itemType, PPID itemID);

	struct AddBlock {
		SLAPI  AddBlock();

		long   Type;
		PPID   ParentID;
		long   Flags;
		SString FileName;
	};

	int    SLAPI AddItem(PPID * pID, PPID parentID);

	struct SelectLinkBlock {
		SelectLinkBlock();
		int    GetWbType(PPID * pType, PPID * pAddendumType) const;

		enum LinkType {
			ltImage = 1,
			ltRef,
			ltLink,
			ltAnnot
		};

		PPID   ID;
		PPID   AddendumID;
		int    Type;
	};
	int    SLAPI SelectLink(PPObjWorkbook::SelectLinkBlock * pData);
	//
	// Descr: Не интерактивная привязка файла pFileName к записи id
	//
	int    SLAPI AttachFile(PPID id, const char * pFileName, int use_ta);
	//
	// Descr: Интерактивный выбор и привязка файла к записи id
	//
	int    SLAPI AttachFile(PPID id);

	struct ImpExpParam {
		SLAPI  ImpExpParam();
		enum {
			fRecursive    = 0x0001,
			fDirAsFolder  = 0x0002,
			fUpdateByName = 0x0004,
			fMedia        = 0x0008,
			fCanonical    = 0x0010  // Специализированный формат, позволяющий переносить книгу между базами данных.
				// В этом случае Wildcard - имя файла, файлы же с содержанием сохраняются в том же каталоге.
		};
		PPID   RootID;
		long   Flags;
		SString RmvFileNamePrefix;
		SString RmvFileNameSuffix;
		SString Wildcard;
	};

	int    SLAPI SelectKeyword(SString & rKeyword);
	int    SLAPI SelectKeywordReverse(SString & rKeyword);
	int    SLAPI ImportFiles(PPID rootID, PPObjWorkbook::ImpExpParam * pParam);
	int    SLAPI Export(PPID rootID);
	int    SLAPI Transmit(PPID rootID);
	int    SLAPI RemoveAll();

	LDATETIME SLAPI GetLastModifTime(PPID id);
	LDATETIME SLAPI GetContentLastModifTime(PPID id);

	int    SLAPI InterchangeUhtt();
	int    SLAPI ExportToUhtt(PPID id);
	int    SLAPI TestImportFromUhtt();

	int    SLAPI SerializePacket(int dir, PPWorkbookPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
private:
	virtual const char * SLAPI GetNamePtr();
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack*);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);

	virtual int    SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual int    SLAPI Read(PPObjPack * pPack, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int    SLAPI Write(PPObjPack * pPack, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int    SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);

	int    SLAPI Helper_Edit(PPID * pID, AddBlock * pAb);
	int    SLAPI AddListItem(StrAssocArray * pList, const WorkbookTbl::Rec * pRec, PPIDArray * pRecurTrace);
	int    SLAPI CheckParent(PPID itemID, PPID parentID);
	int    SLAPI GetItemPath(PPID itemID, SString & rPath);
	int    SLAPI EditImportParam(PPObjWorkbook::ImpExpParam * pParam);
	int    SLAPI Helper_MakeStrAssocList(PPID parentID, StrAssocArray * pList, UintHashTable & rRecurTrace);
	int    SLAPI Helper_Import(PPID rootID, const PPObjWorkbook::ImpExpParam & rParam, const SString & rBasePath, const SString & rNakedWc); // @recursive
	int    SLAPI Helper_Export(PPID rootID, PPWorkbookExporter & rExporter, PPIDArray * pRecurTrace);
	int    SLAPI Helper_Transmit(PPID rootID, PPIDArray & rResultList, PPIDArray * pRecurTrace);
	int    SLAPI Helper_RemoveAll(PPID id, PPIDArray * pRecurTrace);

	struct ProcessUhttImportBlock {
		ProcessUhttImportBlock(PPUhttClient & rUc, const TSCollection <UhttWorkbookItemPacket> & rSrcList, LDATETIME sinceEvTm);

		PPUhttClient & R_Uc;
		const TSCollection <UhttWorkbookItemPacket> & R_SrcList;
		const LDATETIME SinceEvTime;
		LAssocArray ProcessedList;
	};

	int    SLAPI Helper_CreatePacketByUhttList(PPID * pID, ProcessUhttImportBlock & rBlk, uint srcListPos, int use_ta);
	int    SLAPI Helper_UhttToNativePacket(ProcessUhttImportBlock & rBlk, const UhttWorkbookItemPacket * pUhttPacket, const SString & rSymb, PPWorkbookPacket & rPack);
	int    SLAPI Helper_ExportToUhtt(PPUhttClient & rUc, PPID id, const TSCollection <UhttWorkbookItemPacket> * pForeignList, PPLogger * pLogger);
public:
	TLP_MEMB(WorkbookCore, P_Tbl);
	void * ExtraPtr;
};

class PPWorkbookImpExpParam : public PPImpExpParam {
public:
	PPWorkbookImpExpParam(uint recId = 0, long flags = 0);
};

class PPWorkbookExporter {
public:
	SLAPI  PPWorkbookExporter();
	SLAPI ~PPWorkbookExporter();
	int    SLAPI Init(const PPWorkbookImpExpParam * pParam);
	int    SLAPI ExportPacket(const PPWorkbookPacket * pPack);
private:
	PPWorkbookImpExpParam Param;
	PPImpExp * P_IEWorkbook;
	PPObjWorkbook WbObj;
	SString DestFilesPath; // @*PPWorkbookExporter::Init()
};
// } @v7.9.2 @Muxa
//
//
//
class PPObjBarCodeStruc : public PPObjReference {
public:
	SLAPI  PPObjBarCodeStruc(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Вызывает диалог просмотра списка структур штрихкодов.
	// ARG(extra IN): 0.
	//
	virtual int SLAPI Browse(void * extraPtr);
};
//
// @ModuleDecl(PPObjDBDiv)
// Раздел базы данных (PPOBJ_DBDIV)
//
// Флаги разделов БД
//
#define DBDIVF_DISPATCH              0x0001L // Раздел-диспетчер
#define DBDIVF_SCARDSONLY            0x0002L // Обмен с разделом идет только на уровне пластиковых карт
#define DBDIVF_RCVCSESSANDWROFFBILLS 0x0004L // Раздел принимает кассовые сессии вместе с документами списания //
	// Если этот флаг установлен, то функция PPObjectTransmit::PutObjectToIndex пропускает документы
	// списания кассовых сессий несмотря на флаг DBDXF_SENDCSESSION в конфигурации обмена данными.
#define DBDIVF_CONSOLID              0x0008L // Раздел, принимающий консолидирующую информацию из других
	// разделов (документы без товарных строк)
#define DBDIVF_PASSIVE               0x0010L // Пассивный раздел
#define DBDIVF_FOREIGN               0x0020L // @v8.0.12 "Чужой" раздел. Используется для маршрутизации передачи пакетов между разделами

struct PPDBDiv2 {          // @persistent @store(Reference2Tbl+)
	//
	// Descr: Следующие флаги полностью дублируют макросы DBDIVF_XXX.
	//   Использовать флаги PPDBDiv::fXXX НЕЛЬЗЯ. Сделано для будущих релизов.
	//
	enum {
		fDispatch              = 0x0001, // Раздел-диспетчер
		fSCardOnly             = 0x0002, // Обмен с разделом идет только на уровне пластиковых карт
		fRcvCSessAndWrOffBills = 0x0004, // Раздел принимает кассовые сессии вместе с документами списания //
			// Если этот флаг установлен, то функция PPObjectTransmit::PutObjectToIndex пропускает документы
			// списания кассовых сессий несмотря на флаг DBDXF_SENDCSESSION в конфигурации обмена данными.
		fConsolid              = 0x0008, // Раздел, принимающий консолидирующую информацию из других разделов (документы без товарных строк)
		fPassive               = 0x0010  // Пассивный раздел
	};
	long   Tag;           // Const=PPOBJ_DBDIV
	long   ID;            // @id
	char   Name[48];      // @name
	char   Symb[20];      // @symb
	char   Reserve[4];    // @reserve
	S_GUID Uuid;          // @v8.0.11 Уникальный идентификатор раздела
	char   Addr[40];      // Адрес узла e-mail или что-то в этом роде
	long   Flags;         // Флаги
	long   IntrRcptOpr;   // Операция межскладского прихода
	long   OutCounter;    // Счетчик исходящих пакетов
};

DECL_REF_REC(PPDBDiv);

#define DBDIVEXSTR_ACCLIST     1 // Список счетов, проводки по которым следует передавать //
#define DBDIVEXSTR_GATEWAYLIST 2 // Список адресов шлюзов, через которые следует отправлять данные
//
// Пакет данных по разделу БД
//
struct DBDivPack {
	SLAPI  DBDivPack();
	DBDivPack & FASTCALL operator = (const DBDivPack & rS);
	void   SLAPI Init();
	int    SLAPI ResponsibleForLoc(PPID loc, int forQuot) const;
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char * pBuf);

	PPDBDiv   Rec;
	PPIDArray LocList;
	// @v8.0.11 SString AccList_;
	SString ExtString; // @v8.0.11
};

class PPObjDBDiv : public PPObjReference {
public:
	enum {
		mklefShowPassive = 0x0001
	};

	static PPID SLAPI Select(int skipCurrent, int * single = 0);

	SLAPI  PPObjDBDiv(void * extraPtr = 0);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Get(PPID, DBDivPack *);
	int    SLAPI Put(PPID *, DBDivPack *, int use_ta);
	int    SLAPI GetCounter(PPID dbid, long * counter, int use_ta);
	int    SLAPI GetUuid(PPID dbid, S_GUID * pUuid, int use_ta);
	int    SLAPI AcceptUuid(PPID dbid, const S_GUID & rUuid, int use_ta);
	int    SLAPI CheckForConsolidDiv(PPID divID);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsType)
// Типы товаров (PPOBJ_GOODSTYPE)
//
// Флаги типов товаров
//
#define GTF_UNLIMITED      0x00000001L // Неограниченный ресурс
#define GTF_RPLC_COST      0x00000002L // Заменить станд сумму поступления //
#define GTF_RPLC_PRICE     0x00000004L // Заменить станд сумму реализации
#define GTF_RPLC_DSCNT     0x00000008L // Заменить станд сумму скидки
#define GTF_PRICEINCLDIS   0x00000010L // Сумма реализации включает скидку
#define GTF_EXCLAMOUNT     0x00000020L // Не включать в номинальную сумму документа
#define GTF_AUTOCOMPL      0x00000040L // Автокомплектация //
#define GTF_ALLOWZEROPRICE 0x00000080L // Допускается нулевая цена реализации
#define GTF_ASSETS         0x00000100L // Основные фонды
#define GTF_EXCLVAT        0x00000200L // Товары этого типа не включать в расчетную базу исходящего НДС
// @unused #define GTF_DISTRIBCOST    0x00000400L // Распределять сумму поступления этих товаров на все остальные
	// строки приходного документа.
#define GTF_REQBARCODE     0x00000800L // Обязательно требовать ввода штрихкода на товар этого типа
#define GTF_QUASIUNLIM     0x00001000L // @v8.5.1 Квази-нелимитированный ресурс. Ведет себя как обычный товар,
	// но при печати отчетов может интрепретироваться как нелимитированный.

struct PPGoodsType2 {      // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_GOODSTYPE
	long   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[32];    // @reserve
	double StockTolerance; // @v9.0.4 Величина толерантности к дефициту либо к излишку товара.
		// Если доступный остаток меньше требуемого на величину, не превышающую StockTolerance
		// то расходуется то, что есть.
	PPID   PriceRestrID;   // ->Ref(PPOBJ_GOODSVALRESTR) Ограничение на цену реализации
	PPID   AmtCVat;        // ->Ref(PPOBJ_AMOUNTTYPE) Сумма НДС в ценах поступления //
	PPID   AmtCost;        // ->Ref(PPOBJ_AMOUNTTYPE) Сумма поступления //
	PPID   AmtPrice;       // ->Ref(PPOBJ_AMOUNTTYPE) Сумма реализации  //
	PPID   AmtDscnt;       // ->Ref(PPOBJ_AMOUNTTYPE) Сумма скидки
	long   Flags;          //
	PPID   WrOffGrpID;     // Группа списания основных фондов (required GTF_ASSETS)
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPGoodsType);

class PPObjGoodsType : public PPObjReference {
public:
	SLAPI  PPObjGoodsType(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Вызывает диалог просмотра списка типов товаров.
	// ARG(extra IN): 0.
	//
	virtual int SLAPI Browse(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {Tag, ID, Name, WrOffGrpID, AmtCost, AmtPrice, AmtDscnt, AmtCVat, Flags}
	//
	int    SLAPI Fetch(PPID, PPGoodsType *);
	int    SLAPI IsUnlim(PPID);
private:
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsValRestr)
//
struct PPGoodsValRestr {
	long   Tag;            // Const=PPOBJ_GOODSVALRESTR
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[28];    // @reserve
	//
	// Параметры управления отгрузкой
	//
	PPID   ScpShipmOpID;   // Вид операции отгрузки, принимаемый во внимание при быстром анализе продаж/возвратов
	PPID   ScpRetOpID;     // Вид операции возврата, принимаемый во внимание при быстром анализе продаж/возвратов
	long   ScpDurationDays; // Количество дней обзора назад для анализа предыдущих продаж/возвратов
	long   ScpUpDev;       // Допустимая величина верхнего отклонения в промилле от рассчитанного баланса продаж/возвратов //
	long   ScpDnDev;       // Допустимая величина нижнего отклонения в промилле от рассчитанного баланса продаж/возвратов //
	PPID   ScpShipmLimitOpID; // @v9.2.2 Вид операции драфт-расхода (план продаж), ограничивающий отгрузку операцией ScpShipmOpID за период (по количеству)
	uint8  ScpReserve[8];  // @reserve Зарезервированное пространство для расширения параметров управления отгрузкой
	//
	long   Flags;
	long   Reserve2[2];    // @reserve
};

class PPGoodsValRestrPacket {
public:
	//
	// Descr: Опции ограничений по статьям документов
	//
	enum {
		barMainArOnly    = 1, // Только для выбранной основной статьи
		barMainArDisable,     // Запрет для выбранной основной статьи
		barExtArOnly,         // Только для выбранной дополнительной статьи
		barExtArDisable       // Запрет для выбранной дополнительной статьи
	};
	SLAPI  PPGoodsValRestrPacket();
	int    SLAPI SetBillArRestr(PPID arID, long option);
	int    SLAPI RemoveBillArRestr(PPID arID);
	const  ObjRestrictArray & GetBillArRestrictList() const;

	PPGoodsValRestr Rec;
	SString LowBoundFormula;
	SString UppBoundFormula;
private:
	ObjRestrictArray BillArRestr; // Ограничения по статьям документа на внесение товара в документ
};
//
// Descr: Объект, управляющий ограничениями на включение товаров в документы: пределы цены реализации и
//   ограничения по статьям (основной и дополнительной) документа.
// @dbd_exchange Сделать полную синхронизацию пакета PPGoodsValRestrPacket.
//
class PPObjGoodsValRestr : public PPObjReference {
public:
	static int SLAPI TestFormula(const char * pFormula);

	struct GvrItem {
		PPID   GvrID;
		PPID   ArID;
		int    GvrBarOption;
	};
	class GvrArray : public TSArray <PPObjGoodsValRestr::GvrItem> {
	public:
		GvrArray();
		int    TestGvrBillArPair(PPID gvrID, PPID arID) const;
		int    TestGvrBillExtArPair(PPID gvrID, PPID arID) const;
	private:
		//
		// ARG(what IN): 0 - основная статья документа, 1 - дополнительная статья документа
		//
		int    Helper_TestGvrBillArPair(PPID gvrID, PPID arID, int what) const;
	};

	SLAPI  PPObjGoodsValRestr(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI PutPacket(PPID * pID, const PPGoodsValRestrPacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPGoodsValRestrPacket * pPack);
	int    SLAPI ReadBarList(PPID id, ObjRestrictArray & rList);
	int    SLAPI Fetch(PPID id, PPGoodsValRestrPacket * pPack);
	//
	// Descr: Извлекает через кэш список ассоциаций идентификаторов ограничений с аналитическими статьями,
	//   для которых определены ограничивающие правила для внесения товаров в документы.
	//
	int    SLAPI FetchBarList(PPObjGoodsValRestr::GvrArray & rList);
private:
	int    SLAPI Helper_ReadBarList(PPID id, PPGoodsValRestrPacket & rPack);
};
//
// @ModuleDecl(PPObjPallet)
//
struct PPPallet {
	long   Tag;            // Const=PPOBJ_PALLET
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	PPDimention Dim;       // Габариты (мм).
	long   MaxLoad;        // Максимальная загрузка (кг)
	char   Reserve[48];    // @reserve
	long   Flags;
	long   Reserve2[2];    // @reserve
};

class PPObjPallet : public PPObjReference {
public:
	SLAPI  PPObjPallet(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
};
//
// @ModuleDecl(PPObjGoodsStruc)
//
#define GSF_COMPL          0x00000001L // Допускается комплектация     //
#define GSF_DECOMPL        0x00000002L // Допускается разукомплектация //
// @v6.7.5 @unused #define GSF_PCTCOREL       0x0004L // Количественные соотношения составляющих в процентах
#define GSF_PARTITIAL      0x00000008L // Частичная структура
#define GSF_NAMED          0x00000020L // Именованная структура.
	// Однажды будучи присвоен, флаг GSF_NAMED не может быть отобран и такая //
	// структура обязана иметь непустое уникальное имя.                      //
#define GSF_OUTPWOVAT      0x00000040L // Выход без НДС
#define GSF_FOLDER         0x00000080L // Структура верхнего уровня.
#define GSF_CHILD          0x00000100L // Дочерняя структура (не может быть именованной)
#define GSF_AUTOWROFF      0x00000200L // Автоматическое списание в техн сессиях (исключен ручной ввод)
#define GSF_SUBST          0x00000400L // Структура подстановки (позиции, которые можно использовать вместо той,
	// к которой относится структура). Исключает GSF_COMPL и GSF_DECOMPL
	// @#{GSF_SUBST ^ (GSF_COMPL|GSF_DECOMPL|GSF_PARTITIAL)}
#define GSF_DYNGEN         0x00000800L // @transient Структура принадлежит динамическому обобщению
#define GSF_PRESENT        0x00001000L // Подарок
#define GSF_GIFTPOTENTIAL  0x00002000L // Информировать кассира о близкой возможности предоставления подарка
#define GSF_COMPLEX        0x00004000L // Комплекс
#define GSF_POSMODIFIER    0x00008000L // POS-модификаторы (только в комбинации с GSF_PARTITIAL)
#define GSF_OVRLAPGIFT     0x00010000L // Подарок с "перекрытием": такой подарок назначается независимо от того,
	// что по некоторым позициям были выданы другие подарки. При этом два и более подарка с перекрытием взаимно исключаются.
//
// Descr: Дескрипторы, определяющие специальные правила установки цен на товарные позиции,
//   составляющие подарочную комбинацию.
//
#define GSGIFTQ_CHEAPESTITEMFREE    0x40000001 // Самая дешевая позиция из комбинации - бесплатно.
#define GSGIFTQ_LASTITEMBYGIFTQ     0x40000002 // Последняя (и только) штука одного наименования - по котировке PPQUOTK_GIFT
#define GSGIFTQ_CHEAPESTITEMBYGIFTQ 0x40000003 // @v7.5.9 Самая дешевая позиция из комбинации - по котировке PPQUOTK_GIFT
//
// Descr: Заголовок товарной структуры.
//
struct PPGoodsStrucHeader2 { // @persistent @store(Reference2Tbl+)
	long   Tag;              // Const=PPOBJ_GOODSSTRUC
	long   ID;               //
	char   Name[48];         // @name
	char   Symb[20];         //
	char   Reserve[24];      // @reserve
	float  GiftLimit;        // @v7.0.0 Предельное количество подарков, которое может быть выдано на чек по данной структуре
	PPID   GiftQuotKindID;   // @v6.5.12 Вид котировки, применяемый для установки цен на товары, к которым применяется подарок.
		// Если GiftQuotKindID & 0x40000000, то этот идентификатор представляет специальное правило установки скидки
		// на позиции, составляющие подарочную комбинацию (GSGIFTQ_XXX).
	double GiftAmtRestrict;  // @v6.4.4 Сумма, которой должна достичь комбинация компонентов для начисления подарка.
	PPID   VariedPropObjType; // Тип объекта изменяющейся характиристики заголовочного товара структуры и элементов структуры.
	DateRange Period;        // Период актуальности структуры
	double CommDenom;        // Общий делитель для компонентов структуры.
	long   Flags;            // GSF_XXX
	PPID   ParentID;         // Родительская структура
	long   Reserve2;         // @reserve
};

DECL_REF_REC(PPGoodsStrucHeader);
//
// Descr: Флаги компонентов товарной структуры
//
#define GSIF_PCTVAL      0x0001L // Оценочный интервал в %%
#define GSIF_ROUNDDOWN   0x0002L // При использовании отбрасывать дробную часть
#define GSIF_PHUVAL      0x0004L // Оценочный интервал в физических единицах
#define GSIF_UNCERTPRICE 0x8000L // Не удалось выяснить точную цену компонента
#define GSIF_AUTOTSWROFF 0x0008L // Автосписание в технологических сессиях в случае, если этот товар не присутствует в строках сессии.
#define GSIF_QTTYASPRICE 0x0010L // Только для нелимитированных ресурсов. Количество устанавливать в 1, а цену в процентах от суммы основного товара.
#define GSIF_MAINITEM    0x0020L // Основной компонент структуры (используется в производственных отчетах)
#define GSIF_FORMULA     0x0040L // Компонент содержит формулу для расчета количества
#define GSIF_SUBPARTSTR  0x0080L // Вычитать количество этого компонента из количества основного товара применяя частичную структуру.
#define GSIF_GOODSGROUP  0x0100L // @v7.3.0 Вместо товара в поле PPGoodsStrucItem::GoodsID установлена
	// товарная группа. Это необходимо для специальных подарков, распространяемых на целую товарную группу.
#define GSIF_IDENTICAL   0x0200L // @v7.4.10 Для подарочных структур: заданное количество применимо только для одинаковых позиций.
#define GSIF_QUERYEXPLOT 0x0400L // @v9.0.4 При автоматическом внесении компонента в документ как расходной строки запрашивать выбор лота

struct PPGoodsStrucItem {  // @persistent(DBX) @size=52
	SLAPI  PPGoodsStrucItem();
	int    FASTCALL operator == (const PPGoodsStrucItem & rS) const;
	int    FASTCALL operator != (const PPGoodsStrucItem & rS) const;
	int    FASTCALL IsEqual(const PPGoodsStrucItem & rS) const;
	int    SLAPI SetEstimationString(const char *);
	SString & SLAPI GetEstimationString(SString &, long format = 0);
	int    SLAPI SetFormula(const char * pStr, const PPGoodsStruc * pStruc);
	int    SLAPI GetQtty(double complQtty, double * pItemQtty) const;
	int    SLAPI GetQttyAsPrice(double complPriceSum, double * pItemPrice) const;

	PPID   GoodsID;
	long   Flags;          // GSIF_XXX Флаги
	double Median;         // Среднее значение оценочного интервала
	double Width;          // Ширина оценочного интервала
	double Denom;          // Знаменатель простой дроби, которая определяет количество компонента
		// Если Denom == 0, то это эквивалентно Denom = 1
	double Netto;          //
	// @construction PPID   PrefInnerGsID;  // @v8.6.5 Предпочтительная структура комплектации/декомплектации для внутреннего элемента
		// @dbd_exchange Требуется синхронизация //
	char   Symb[20];       // Символ элемента структуры (для ссылки из формул)
	char   Formula[64];    // @transient
};

class PPGoodsStruc {
public:
	struct Ident {
		SLAPI  Ident(PPID goodsID = 0, long andF = 0, long notF = 0, LDATE = ZERODATE);
		PPID   GoodsID;
		long   AndFlags;
		long   NotFlags;
		LDATE  Dt;
	};
	//
	// Descr: Виды структур.
	//
	enum {
		kUndef = 0, // Неопределенный
		kBOM   = 1, // Комплектация/декомплектация //  GSF_COMPL|GSF_DECOMPL
		kPart,      // Частичная структура             GSF_PARTITIAL
		kSubst,     // Подстановочная структура        GSF_SUBST
		kGift,      // Подарочная //                   GSF_PRESENT
		kComplex    // Комплекс                        GSF_COMPLEX
	};

	static int SLAPI IsSimpleQttyString(const char * pStr);

	SLAPI  PPGoodsStruc();
	void   SLAPI Init();
	PPGoodsStruc & FASTCALL operator = (const PPGoodsStruc &);
	int    FASTCALL IsEqual(const PPGoodsStruc &) const;
	int    SLAPI IsEmpty() const;
	int    SLAPI IsNamed() const;
	int    SLAPI CanExpand() const;
	int    SLAPI CanReduce() const;
	int    SLAPI GetTypeString(SString & rBuf);
	int    SLAPI SetKind(int kind);
	int    SLAPI GetKind() const;
	//
	// Descr: Возвращает общий делитель структуры. Если Rec.CommDenom == 0,
	//   то возвращается 1.
	//
	double SLAPI GetDenom() const;
	//
	// Descr: Возвращает указатель на основной компонент структуры (такой компонент
	//   имеет признак GSIF_MAINITEM). Если основной компонент найден, то
	//   по указателю pPos присваивается позиция основного компонента.
	//
	const  PPGoodsStrucItem * SLAPI GetMainItem(uint * pPos) const;
	//
	// Descr: Умножает количество *pQtty на соотношение физических/торговых единиц
	//   определенное для основного компонента структуры.
	// Returns:
	//   >0 - структура имеет основной компонент у которого определен коэфф PhUPerU.
	//       Функция умножила величину *pQtty на этот коэффициент.
	//  <0  - либо структура не имеет основного компонента, либо этот компонент не
	//       имеет определенного коэффициента PhUPerU.
	//
	int    SLAPI RecalcQttyByMainItemPh(double * pQtty) const;
	int    SLAPI GetEstimationPrice(uint itemIdx, double * pPrice, double * pTotalPrice, ReceiptTbl::Rec * pLotRec) const;
	int    SLAPI CalcEstimationPrice(double * pPrice, int * pUncertainty, int calcInner) const;
	int    FASTCALL HasGoods(PPID goodsID) const;
	int    SLAPI SearchSymb(const char * pSymb, uint * pPos) const;
	int    SLAPI CopyItemsFrom(const PPGoodsStruc * pS);
	int    SLAPI MoveItem(uint pos, int dir  /* 0 - down, 1 - up */, uint * pNewPos);
	//
	// Descr: Перечисляет элементы структуры с вычислением количества, необходимого
	//   для комплектации srcQtty единиц составного товара. Требуемое количество
	//   возвращается по указателю pQtty. Для получения первого элемента по уазателю pPos
	//   следует передать значение 0.
	//   Функция, после каждого успешного вызова, увеличивает значение *pPos на единицу.
	// Returns:
	//   >0 - Функция успешно вернула следующий элемент
	//   <0 - По индексу *pPos элемента нет
	//
	int    SLAPI EnumItemsExt(uint * pPos, PPGoodsStrucItem * pItem, PPID parentGoodsID, double srcQtty, double * pQtty) const;
	//
	// Descr: Преобразует структуру в родительскую, перенося при этом содержимое структуры
	//   в первую дочернюю. Функция применима, если !(Rec.Flags & (GSF_FOLDER | GSF_CHILD)).
	// Returns:
	//   >0 - Структура успешно переведена в родительскую
	//    0 - Ошибка
	//   <0 - Структура уже является родительской
	//
	int    SLAPI Expand();
	//
	// Descr: Преобразует родительскую структуру в одноуровневую. Функция применима только
	//   к родительским структурам, имеющим не более одной дочерней структуры.
	//   Все элементы дочерней структуры переходят в собственность родительской, дочерняя структура
	//   удаляется, а родительская теряет флаг GSF_FOLDER.
	// Returns:
	//  >0 - Структура успешно редуцирована
	//   0 - Ошибка
	//  <0 - Структура не является родительской
	//
	int    SLAPI Reduce();
	int    SLAPI Select(const Ident * pIdent, PPGoodsStruc * pGs) const;
	int    SLAPI Select(const Ident * pIdent, TSCollection <PPGoodsStruc> & rList) const;
	int    SLAPI GetItemQtty(PPID goodsID, double complQtty, double * pQtty) const;
	SString & SLAPI MakeChildDefaultName(SString & rBuf) const;

	int    SLAPI InitCompleteData(PPID goodsID, double needQty, const PPBillPacket * pBillPack, PPComplBlock & rData);
	int    SLAPI InitCompleteData2(/*const PPTransferItem & rTi,*/PPID goodsID, double needQty, PPComplBlock & rData);
	//
	// Поле GoodsID не является неотъемлемой частью структуры товара, поскольку одна структура
	// может принадлежать нескольким товарам. Это поле используется как справочное и может быть
	// равно нулю. Функции, загружающие или инициализирующие структуру должны сами
	// заботится об инициализации этого поля.
	//
	PPID   GoodsID; // @transient
	const  PPComplBlock * P_Cb; // @v9.3.3 @transient Предварительный массив товарных строк для вставки в документа.
		// Необходим для обсчета компонентов по формулам.

	PPGoodsStrucHeader Rec;
	TSArray <PPGoodsStrucItem> Items;
	TSCollection <PPGoodsStruc> Childs; // Используется только если (Flags & GSF_FOLDER)
private:
	int    SLAPI SubstVariedProp(PPID parentGoodsID, PPGoodsStrucItem * pItem) const;
		// @<<PPGoodsStruc::EnumItemsExt
	int    SLAPI Helper_Select(const Ident * pIdent, TSCollection <PPGoodsStruc> & rList) const;
};

struct GStrucRecurItem {
	PPGoodsStrucItem Item; //
	PPID   LastLotID;      //
	double Qtty;           //
	double Price;          //
	double Sum;            //
	int    Level;          //
	int    HasInner;       // Признак того, что элемент имеет вложенную структуру
};

class GStrucIterator {
public:
	SLAPI  GStrucIterator();
	const  PPGoodsStruc * SLAPI GetStruc() const;
	int    SLAPI Init(PPGoodsStruc * pStruc, int loadRecurItems);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GStrucRecurItem * pItem);
private:
	int    SLAPI LoadItems(PPGoodsStruc * pStruc, PPID parentGoodsID, double srcQtty, int level);

	int    LoadRecurItems;
	uint   Idx;
	PPGoodsStruc GStruc;
	TSArray <GStrucRecurItem> Items;
};
//
//
//
struct SaSaleItem {
	PPID   GoodsID;
	double Qtty;
	double Price;
};
//
// Descr: Структура комбинации, по которой может быть выдан подарок за покупку
//
class SaGiftItem {
public:
	enum {
		fCalcPotential = 0x0001,
		fOverlap       = 0x0002
	};
	//
	// Descr: Структура элемента комбинации, по которой выдается подарок
	//
	struct Entry {
		PPIDArray GoodsList;
		PPID   OrgGoodsID; // Идентификатор товара, указанный в компоненте структуры (может быть обобщенным).
			// Если OrgGoodsID - обобщенный, то список GoodsList содержит все элементы обобщения, в
			// противном случае GoodsList.get(0) == OrgGoodsID
		double MinQtty;
		long   GsiFlags;   // @v7.0.6 Копия поля PPGoodsStrucItem::Flags
	};
	//
	SLAPI  SaGiftItem();
	SLAPI  SaGiftItem(const SaGiftItem &);
	SaGiftItem & FASTCALL operator = (const SaGiftItem &);
	//
	// Descr: Копирует экземпляр класса pS в this. Если pS == 0, то очищает this.
	//
	int    FASTCALL Copy(const SaGiftItem * pS);
	int    SLAPI IsSaleListSuitable(const TSArray <SaSaleItem> & rSaleList, RAssocArray * pCheckList, LongArray * pMainPosList, double * pQtty) const;
	int    SLAPI CalcPotential(const TSArray <SaSaleItem> & rSaleList,
		PPID * pPotGoodsID, double * pPotAmount, double * pPotDeficit, SString & rPotName) const;

	PPID   StrucID;        // Ид товарной структуры (подарочной)
	PPID   OrgStrucID;     // Структура, родительская к StrucID самого верхнего уровня.
		// Если StrucID не имеет родительской структуры, то OrgStrucID == StrucID
	PPID   QuotKindID;     // @v6.5.12 Вид котировки, применяемый как подарочная цена на купленные товары
	long   Flags;          // @v6.6.2
	float  Limit;          // @v7.0.0 Предельное количество подарков, которое может быть выдано по одному чеку.
	double AmtRestrict;    // @v6.4.6 Минимальная сумма продажи, на которую начисляется подарок
	PPIDArray GiftList;    // Список идентификаторов товаров-подарков
	TSCollection <SaGiftItem::Entry> List; // Список проданных товаров, по которым полагается подарок
};
//
// Descr: Структура списка подарков, которые могут быть выданы при покупке одной из заданных комбинаций товаров
//
class SaGiftArray : public TSCollection <SaGiftItem> {
public:
	struct Potential {
		PPID   GoodsID;   // ИД товара, который осталось докупить до получения подарка
		double Amount;    // Общая сумма покупки оговоренных товаров для получения подарка
		double Deficit;   // Недостающая для получения подарка сумма покупки
		SString Name;     // Наименование потенциального подарка
	};
	//
	// Descr: Результирующая структура выбора подарка.
	//
	struct Gift {
		Gift();
		Gift & Init();
		int    FASTCALL PreservePotential(SaGiftArray::Potential & rS) const;
		int    FASTCALL RestorePotential(const SaGiftArray::Potential & rS);
		int    FASTCALL IsEqualForResult(const Gift & rS) const;

		PPID   ID;           // Идентификатор структуры подарка
		double Qtty;         // Количество торговых единиц товара, составляющего подарок
		PPID   QuotKindID;   // Вид котировки, применяемый в качестве подарка к проданным позициям.
		PPIDArray List;      // Список идентификаторов товаров-подарков (владельцев подарочных структур)
		RAssocArray CheckList; // Список идентификаторов товаров, продажа которых принята в качестве условия предоставления подарка.
			// Каждый идентификатор ассоциирован с минимальным количеством, которое, в соответствии со структурой, может быть принято для предоставления подарка.
		LongArray MainPosList; // Список индексов позиций в CheckList, помеченных в подарочной структуре флагом GSIF_MAINITEM
		SaGiftArray::Potential Pot; // Информация о возможности получения наиболее близкого к чеку подарка
	};

	SaGiftArray();
	SaGiftArray(const SaGiftArray &);
	SaGiftArray & FASTCALL operator = (const SaGiftArray &);
	int    FASTCALL Copy(const SaGiftArray * pS);
	int    CreateIndex();
	int    SelectGift(const TSArray <SaSaleItem> & rSaleList, const RAssocArray & rExGiftList, int overlap, SaGiftArray::Gift & rGift) const;
private:
	LAssocArray Index; // Key - StrucID, Val - GoodsID
};

class PPObjGoodsStruc : public PPObjReference {
public:
	static  int    SLAPI EditDialog(PPGoodsStruc *, int toCascade = 0);
	static  int    SLAPI CheckRecursion();
	//
	// @attention !!!
	// Если необходимо получить только заголовок структуры, то следует
	// использовать функцию Search в которой вторым параметром должен
	// быть указатель на PPGoodsStrucHeader, а не на PPGoodsStruc.
	//
	SLAPI  PPObjGoodsStruc(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr /*goodsID*/);
	int    SLAPI Fetch(PPID id, PPGoodsStrucHeader * pRec);
	int    SLAPI GetChildIDList(PPID id, PPIDArray * pList);
	int    SLAPI Get(PPID id, PPGoodsStruc * pGs);
	int    SLAPI Put(PPID * pID, PPGoodsStruc * pGs, int use_ta);
	int    SLAPI Print(PPGoodsStruc *);
	int    SLAPI CheckStruc(PPID strucID, PPLogger *);
	int    SLAPI LoadGiftList(SaGiftArray * pList);
	int    SLAPI FetchGiftList(SaGiftArray * pList);

	int    SLAPI SelectorDialog(const TSCollection <PPGoodsStruc> & rList, uint * pSelectionPos);
	int    SLAPI SelectorDialog(PPID * pNamedGsID);
private:
	static  int  SLAPI EditExtDialog(PPGoodsStruc *);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*goodsID*/);
	virtual void SLAPI Destroy(PPObjPack*);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI Helper_LoadItems(PPID id, PPGoodsStruc * pData);
	int    SLAPI CheckStructs();
	int    SLAPI CheckStruct(PPIDArray * pGoodsIDs, PPIDArray * pStructIDs, PPGoodsStruc * pStruct, PPLogger * pLog);
	int    SLAPI SerializePacket(int dir, PPGoodsStruc * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};

int SLAPI LoadGoodsStruc(const PPGoodsStruc::Ident * pIdent, PPGoodsStruc * pGs);
//
// @ModuleDecl(PPObjGoodsTax)
// Товарные налоговые группы
//
#define GTAXF_ABSEXCISE   0x0001L
#define GTAXF_USELIST     0x0002L // Налоговая группа состоит из списка
#define GTAXF_ENTRY       0x0004L //
#define GTAXF_ZEROEXCISE  0x0008L // @transient Группа (включая списочные элементы)
	// без акциза (инициализируется при загрузке пакета группы функцией PPObjGoodsTax::GetPacket())
#define GTAXF_NOLOTEXCISE 0x0010L // При расчете входящих налогов (на лот) акциз исключать

struct PPGoodsTaxEntry {
	double SLAPI GetVatRate() const;
	char * SLAPI FormatVAT(char *, size_t) const;
	char * SLAPI FormatExcise(char *, size_t) const;
	char * SLAPI FormatSTax(char *, size_t) const;

	PPID   TaxGrpID;       //
	DateRange Period;      //
	PPID   OpID;           //
	long   VAT;            // prec 0.01
	long   Excise;         // prec 0.01
	long   SalesTax;       // prec 0.01
	long   Flags;          // GTAXF_XXX
	long   Order;          // Порядок начисления налогов
	long   UnionVect;      //
};

struct PPGoodsTax2 {       // @persistent @store(Reference2Tbl+)
	int    FASTCALL ToEntry(PPGoodsTaxEntry *) const;
	int    FASTCALL FromEntry(const PPGoodsTaxEntry *);
	PPID   Tag;            // Const=PPOBJ_GOODSTAX
	PPID   ID;             //
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[36];    // @reserve
	double VAT;            //
	double Excise;         //
	double SalesTax;       //
	long   Flags;          //
	long   Order;          //
	long   UnionVect;      //
};

DECL_REF_REC(PPGoodsTax);

class PPGoodsTaxPacket : public SArray {
public:
	SLAPI  PPGoodsTaxPacket();
	PPGoodsTaxPacket & FASTCALL operator = (const PPGoodsTaxPacket &);
	int    SLAPI GetEntry(LDATE, PPID opID, PPGoodsTaxEntry *);
	int    SLAPI PutEntry(int pos, const PPGoodsTaxEntry *);
	void   SLAPI Sort();

	PPGoodsTax Rec;
};

class PPObjGoodsTax : public PPObjReference {
public:
	static long  SLAPI GetDefaultOrder();
	static int   SLAPI ReplaceGoodsTaxGrp();
	static int   SLAPI IsIdentical(const PPGoodsTax * pRec1, const PPGoodsTax * pRec2);
	static int   SLAPI Fetch(PPID, LDATE, PPID opID, PPGoodsTaxEntry *);
	static int   SLAPI FetchByID(PPID, PPGoodsTaxEntry *);

	SLAPI  PPObjGoodsTax(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Search(PPID id, PPGoodsTaxEntry * pEntry);
	int    SLAPI Search(PPID id, PPGoodsTax * pRec);
	int    SLAPI AddBySample(PPID *, long sampleID);
	int    SLAPI GetBySheme(PPID *, double vat, double excise, double stax, long flags);
	int    SLAPI GetDefaultName(PPGoodsTax *, char * buf, size_t buflen);
	//
	// Descr: Ищет налоговую группу, аналогичную по схеме налогообложения записи pPattern.
	//
	int    SLAPI SearchIdentical(const PPGoodsTax * pPattern, PPID * pID, PPGoodsTax * pRec);
	int    SLAPI SearchAnalog(const PPGoodsTax * pSample, PPID * pID, PPGoodsTax * pRec);
	int    SLAPI Test(PPID);
	int    SLAPI FormatOrder(long order, long unionVect, char * buf, size_t buflen);
	int    SLAPI StrToOrder(const char *, long * pOrder, long * pUnionVect);
	int    SLAPI GetPacket(PPID, PPGoodsTaxPacket *);
	int    SLAPI PutPacket(PPID *, PPGoodsTaxPacket *, int use_ta);
private:
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack * pPack);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI SerializePacket(int dir, PPGoodsTaxPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// GTaxVect
//
#define GTAX_NONE          0
#define GTAX_VAT           1
#define GTAX_EXCISE        2
#define GTAX_SALES         3

#define GTAXVF_AFTERTAXES  0x00000001L // Without any operational taxes
#define GTAXVF_VAT         0x00000002L
#define GTAXVF_EXCISE      0x00000004L
#define GTAXVF_SALESTAX    0x00000008L
#define GTAXVF_BEFORETAXES 0x80000000L // With all operational taxes
#define GTAXVF_NOMINAL     0x08000000L // @v6.5.6 Специальный флаг, применяемый для того,
	// чтобы рассчитать суммы налогов исходя из номинальных налоговых групп по товарам
	// (опиская признаки освобождения от НДС и входящие налоговые группы по лотам).
	// Может быть использован только в аргументе exclFlags функции GTaxVect::CalcTi().

class GTaxVect {
public:
	static int SLAPI Test(PPID gtaxID);

	SLAPI  GTaxVect(int roundPrec = 2);
	void   SLAPI Calc_(PPGoodsTaxEntry *, double amount, double qtty, long amtFlags, long excludeFlags = 0);
	int    SLAPI CalcTI(const PPTransferItem *, PPID opID, int tiamt /* TIAMT_XXX */, long exclFlags = 0L);
	double FASTCALL GetValue(long flags /* mask GTAXVF_XXX */) const;
	double SLAPI GetTaxRate(long taxID /* GTAX_XXX */, int * pIsAbs) const;
private:
	int    FASTCALL TaxToVect(int) const;
	int    FASTCALL VectToTax(int) const;
	int    SLAPI CalcForward(int n, double amount);
	int    SLAPI CalcBackward(int n, double amount);
	double SLAPI CalcTaxValByBase(int idx, double base) const;

	int    RoundPrec;
	long   N;
	long   AbsVect;
	long   UnionVect;
	long   OrderVect[8];
	double RateVect[8];
	double Vect[8];
	double Amount;
	double Qtty;
};
//
//
//
class PPObjFormula : public PPObjReference {
public:
	SLAPI  PPObjFormula(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Get(PPID id, SString & rName, SString & rExpr);
	int    SLAPI Put(PPID * pID, const char * pName, const char * pExpr, int use_ta);
	//
	// Descr: Вызывает диалог просмотра списка формул.
	// ARG(extra IN): 0.
	//
	virtual int SLAPI Browse(void * extraPtr);
	// Private: for conversion use only
	// @obsolete @v4.9.3 int    SLAPI GetBefore290(PPID id, char * pName, char * pBuf, size_t buflen);
};
//
// @ModuleDecl(PPObjRegisterType)
// Тип регистрационного документа (PPOBJ_REGISTERTYPE)
//
#define REGTF_UNIQUE      0x0001L // 'U' Персоналия не может содержать более одного документа такого типа
#define REGTF_PRIVATE     0x0002L // 'P' Разрешен для физ. лиц
#define REGTF_LEGAL       0x0004L // 'L' Разрешен для юр. лиц (REGTF_PRIVATE ^ REGTF_LEGAL)
#define REGTF_WARNEXPIRY  0x0008L // Предупреждать об истечении срока действия //
#define REGTF_INSERT      0x0010L // Вводить документ при вводе персоналии
#define REGTF_WARNABSENCE 0x0020L // Предупреждать об отсутствии регистра у персоналии //
#define REGTF_DUPNUMBER   0x0040L // 'D' Номер регистра может быть дублируемым
#define REGTF_ONLYNUMBER  0x0080L // 'N' Для регистра значим только номер
#define REGTF_LOCATION    0x0100L // 'A' @v8.3.6 Регистр может быть использован для привязки к локациям

struct PPRegisterType2 {   // @persistent @store(Reference2Tbl+)
	enum {
		ggrpaOnlyGroup = 0,
		ggrpaDenyGroup,
		ggrpaAllowByReg
	};
	PPID   Tag;            // Const=PPOBJ_REGISTERTYPE
	PPID   ID;             // @id
	char   Name[48];       // Наименование типа регистра
	char   Symb[20];       // Символ для ссылок из формул и т.д.
	int16  ExpiryPeriod;   // Период истечения срока годности в днях от даты ввода регистра
	//GoodsGrpAllow
	int16  RestrictGoodsKind; // Признак ограничения, накладываемого этим регистром
		// на применение товарной группы в документах:
		//   0 - продавать только эту группу,
		//   1 - запретить эту группу,
		//   2 - разрешить продавать эту группу при наличие регистра (ggrpaXXX)
	PPID   RestrictGoodsGrpID;     // @v6.4.3 Товарная группа
	char   Reserve[48];    // @reserve
	PPID   RegOrgKind;     // ->Ref(PPOBJ_PRSNKIND) Вид регистрирующей организации
	long   Flags;          // @flags
	PPID   CounterID;      // ->Ref(PPOBJ_OPCOUNTER)
	PPID   PersonKindID;   // Вид персоналии, к которой должен относиться этот регистр. Если 0, то к любому виду.
};

DECL_REF_REC(PPRegisterType);

struct PPRegisterTypePacket {
	SLAPI  PPRegisterTypePacket();
	PPRegisterTypePacket & FASTCALL operator = (const PPRegisterTypePacket &);

	PPRegisterType Rec;
	PPOpCounterPacket CntrPack;
	SString Format;
};

class PPObjRegisterType : public PPObjReference {
public:
	static int FASTCALL IsDupRegType(PPID regTypeID);
	//
	// Descr: Находит тип регистрационного документа с символом pRegTypeCode.
	// ARG(pRegTypeCode  IN): символ типа регистрационного документа
	// ARG(pRegTypeID   OUT): возвращаемый функцией идентификатор типа регистрационных документов.
	//   Если тип регистрационных документов с кодом pRegTypeCode не найден, то
	//   *pRegTypeID = 0.
	// Returns:
	//   >0 - заданный тип регистрационных документов найден.
	//   <0 - заданный тип регистрационных документов не найден.
	//   0  - ошибка
	//
	static int FASTCALL GetByCode(const char * pRegTypeCode, PPID * pRegTypeID);
		// @>>Refernce::SearchSymb

	SLAPI  PPObjRegisterType();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI GetPacket(PPID, PPRegisterTypePacket *);
	int    SLAPI PutPacket(PPID *, PPRegisterTypePacket *, int use_ta);
	int    SLAPI GetFormat(PPID, SString &);
	int    SLAPI PutFormat(PPID, const char *);
	int    SLAPI GetCode(PPID, long * pCounter, char * pBuf, size_t bufLen);
	int    SLAPI UngetCounter(PPID, long counter);
	//
	// Descr: извлекает через кэш редуцированную запись PPRegisterType,
	//   содержащую следующие актуальные поля: {ID, PersonKindID, RegOrgKind, Flags}
	//
	int    SLAPI Fetch(PPID, PPRegisterType *);
	int    SLAPI SearchSymb(PPID * pID, const char * pSymb);
private:
	virtual int  SLAPI ProcessReservedItem(TVRez &);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
};
//
// @ModuleDecl(PPObjQuotKind)
//
struct QuotKindFilt {
	SLAPI  QuotKindFilt();
	enum {
		fAddBase             = 0x0001, // Добавить в список базовую котировку
		fExclNotForBill      = 0x0002, // Исключить из списка виды котировок с признаком "Не использовать в документах"
		fSupplDeal           = 0x0004, // Список, содержащий контрактную цену поставщиков, верхнее и нижнее отклонения.
			// Этот флаг отменяет действия флагов fAddBase и fExclNotForBill
		fAll                 = 0x0008, // Показывать все явно существующие виды котировок
		fGoodsMatrix         = 0x0010, // Содержит котировку, которая определяет принадлежность товара к товарной матрице
		fGoodsMatrixRestrict = 0x0020, // Содержит котировку, которая определяет ограничение товарной матрицы
		fPredictCoeff        = 0x0040, // Корректировочный коэффициент для прогноза продаж
		fSortByRankName      = 0x0080, // Сортировать список по рангу, имени
		fIgnoreRights        = 0x0100  // @v8.9.4 Игнорировать список доступных видо котировок в правах доступа
	};
	PPID   AccSheetID; //
	//
	// Если поле OpID != 0, то выбираются виды котировок по следующим условиям:
	//   1. Вид котировки имеет ссылку на эту операцию
	//   2. Вид котировки имеет ссылку на обобщенную операцию, членом которой является OpID
	//   3. Если OpID является операцией межскладского расхода, то виды котировок, имеющие нулевую
	//      ссылку на вид операции пропускаются, но безусловно выбирается базовая котировка.
	//   4. Если вид котировки имеет признак QUOTKF_NOTFORBILL и Flags & fExclNotFroBill,
	//      то такой вид котировки пропускается.
	//   5. Если вид котировки имеет ненулевую ссылку на таблицу аналитических статей, и
	//      эта ссылка не равна GetSellAccSheet(), то такой вид котировки пропускается.
	//
	PPID   OpID;       //
	long   MaxItems;   // Максимальное количество видов в выборке. Если MaxItems <= 0, то не ограничено.
	long   Flags;      // QuotKindFilt::fXXX
};
//
// Виды котировок товаров (PPOBJ_QUOTKIND)
//
#define QUOTKF_ABSDIS         0x0001L // Скидка в абсолютном (денежном) выражении, иначе в %%
#define QUOTKF_NOTFORBILL     0x0002L // Котировка не используется при формировании цены в документе
#define QUOTKF_PCTDISONCOST   0x0004L // Скидка задана в процентах от цены поступления //
	// (исключает QUOTKF_ABSDIS). Задается, например, как '10P' : 10% от цены поступления     //
#define QUOTKF_DSCNTONGROUPS  0x0008L // @obsolete Привязать к данной котировке группы, по которым котировки рассчитываются отдельно
#define QUOTKF_EXTPRICEBYBASE 0x0010L // Если вид котировки используется как дополнительная цена по документу
	// то за базу при расчете принимать учетную цену реализации, если флаг не установлен, то за базу
	// принимается чистая цена реализации (Price-Discount)
#define QUOTKF_RETAILED       0x0020L // Розничная котировка
#define QUOTKF_SERIAL         0x0040L // (ограниченное использование) котировки храняться в
	// хронологической последовательности. То есть, каждое новое значение не стирает предыдущие, но
	// заносится в базу данных с меткой времени. При этом признак Actual остается действительным и
	// присваивается самому новому значению.
#define QUOTKF_SERIALTERMDAYS 0x0080L // @v7.1.12 Количество хранимых значений ограничивается разницей
	// в днях между актуальным значением и самым первым значением. Если флаг не установлен, то
	// ограничение (если есть) - максимальное количество хранимых значений.
#define QUOTKF_NODIS          0x0100L // @v7.4.0 Если применяется этот вид котировки, то скидки по картам не действуют.

struct PPQuotKind2 {       // @persistent @store(Reference2Tbl+)
	SLAPI  PPQuotKind2();
	int    SLAPI GetTimeRange(TimeRange & rRange) const;
	int    SLAPI SetTimeRange(const TimeRange & rRange);
	int    SLAPI GetAmtRange(RealRange * pRange) const;
	int    SLAPI SetAmtRange(const RealRange * pRange);
	int    SLAPI GetRestrText(SString & rBuf) const;
	int    SLAPI HasWeekDayRestriction() const;
	int    SLAPI CheckWeekDay(LDATE dt) const;

	PPID   Tag;            // Const=PPOBJ_QUOTKIND
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	int16  SerialTerm;     // @v7.1.12 Ограничение на количество хранимых значений
	int16  Reserve2;       // @alignment
	IntRange AmtRestr;     // @v6.8.6 Диапазон суммы покупки, при которой действует этот вид котировки
	double Discount;       // Скидка
	DateRange Period;      // Период действия розничной котировки
	int16  BeginTm;        // Время начала действия розничной котировки
	int16  EndTm;          // Время окончания действия розничной котировки
	int16  Rank;           // Уровень приоритета котировки при показе в диалоге
		// редактирования или в тех случаях, когда все котировки не могут быть использованы
		// в виду ограничения на количество видов (например, при загрузке в StyloPalm).
		// Чем выше значение, тем выше вероятность использования этого вида котировки
		// по сравнению с другими.
	uint8  DaysOfWeek;     // Дни недели действия розничной котировки (0x01 - Пн, ... , 0x40 - Вс)
	int8   UsingWSCard;    // Совместное использование с дисконтными картами (uwscXXX)
	long   Flags;          // Флаги (QUOTKF_XXX)
	enum {                 //
		uwscDefault = 0,   // - сначала котировка, затем скидка по карте
		uwscSCardNQuot,    // - сначала скидка по карте, затем котировка
		uwscOnlyQuot,      // - только котировка
		uwscOnlySCard      // - только скидка по карте
	};
	PPID   OpID;           // Вид операции, для которой определена котировка
	PPID   AccSheetID;     // Таблица статей, с которыми ассоциируются значения котировок.
		// Если AccSheetID == 0, то полагается, что таблица статей GetSellAccSheet() (покупатели)
};

DECL_REF_REC(PPQuotKind);

class PPQuotKindPacket {
public:
	SLAPI  PPQuotKindPacket();
	int    SLAPI Init();
	int    SLAPI GetCalculatedQuot(double cost, double basePrice, double * pQuot, long * pFlags) const;
	PPQuotKindPacket & FASTCALL operator = (const PPQuotKindPacket &);

	PPQuotKind Rec;
};

//
// Специфические флаги прав доступа по котировкам
//
#define QUOTRT_UPDQUOTS      0x0100 // Право на изменение котировок
#define QUOTRT_UPDSUPPLCOST  0x0200 // Право на изменение контрактных цен
#define QUOTRT_UPDMTX        0x0400 // Право на изменение товарной матрицы
#define QUOTRT_UPDMTXRESTR   0x0800 // Право на изменение ограничений по товарной матрице
//
// Категории котировок
//
#define PPQC_UNKN                 0 // Не определенная категория (вид котировки 0 или не найден) //
#define PPQC_PRICE                1 // Обыкновенная ценовая котировка
#define PPQC_SUPPLDEAL            2 // Контрактная цена (включает и ограничения для контрактных цен)
#define PPQC_MATRIX               3 // Товарная матрица
#define PPQC_MATRIXRESTR          4 // Ограничение по товарной матрице
#define PPQC_PREDICTCOEFF         5 // Поправочный коэффициент прогноза продаж

class PPObjQuotKind : public PPObjReference {
public:
	friend class QuotKindCache;

	struct ListEntry {
		PPID   ID;
		char   Name[48];
	};
	//
	// Descr: Специальные виды котировок
	//
	struct Special {
		Special();
		int    FASTCALL IsSupplDealKind(PPID qkID) const;
		//
		// Descr: Возвращает категорию вида котировки qkID.
		// Returns:
		//   Одно из значений PPQC_XXX. Если qkID == 0, то возвращает PPQC_UNKN.
		//
		int    FASTCALL GetCategory(PPID qkID) const;

		enum {
			fInited = 0x0001 // Запись инициализирована
		};
		long   Flags;
		PPID   MtxID;           // Вид котировки товарной матрицы
		PPID   MtxRestrID;      // Вид котировки ограничения товарной матрицы
		PPID   PredictCoeffID;  // Вид котировки поправочного коэффициента прогноза продаж
		PPID   SupplDealID;     // Вид котировки, управляющей контрактными ценами поставщиков
		PPID   SupplDevUpID;    // Вид котировки, ограничивающий верхнюю границу отклонения фактических цен от контрактных
		PPID   SupplDevDnID;    // Вид котировки, ограничивающий нижнюю границу отклонения фактических цен от контрактных
	};

	static int  FASTCALL GetSpecialKinds(Special *, int useCache);
	static PPID SLAPI GetDefaultAccSheetID(int cls);

	SLAPI  PPObjQuotKind(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI IsPacketEq(const PPQuotKindPacket & rS1, const PPQuotKindPacket & rS2, long flags);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {Tag, ID, Name, Discount, Period, BeginTm, EndTm, Rank, OpID, Flags, AccSheetID}
	//
	int    SLAPI Fetch(PPID id, PPQuotKind * pRec);
	int    SLAPI FetchBySymb(const char * pSymb, PPID * pID);
	//
	// Descr: Идентифицирует класс вида котировки (PPQuot::clsXXX).
	// Returns:
	//   >0 - вид котировки успешно классифицирован. По указателю pCls присвоено значение класса.
	//   <0 - вид котировки id не найден. По указателю pCls присваивается значение PPQuot::clsGeneral.
	//   0  - ошибка
	//
	int    SLAPI Classify(PPID id, int * pCls);
	int    SLAPI GetListByOp(PPID opID, LDATE dt, PPIDArray * pList);
	//
	// Descr: Возвращает список идентификаторов видов котировок, которые могут
	//   быть использованы для определения розничной цены товаров.
	//   Если dt != ZERODATE то виды котировок, которые не проходят по критериям
	//   периода использования и дня недели, не попадают в список.
	//   Особенности поведения функции в зависимости от флагов flags:
	//   RTLPF_PRICEBYQUOT если установлен, то базовая котировка автоматически попадает в список без
	//     проверки на критерии даты и времени.
	//   RTLPF_USEQUOTWTIME если установлен, то виды котировок проверяются на удовлетворение
	//     времени tm критерию диапазона времени.
	//
	//   Результирующий список отсортирован в порядке приоритета вида котировки и наименования.
	//
	int    SLAPI GetRetailQuotList(LDATETIME dtm, PPIDArray * pList, long flags /* RTLPF_XXX */);
	//
	// Descr: Сортирует список видов котировок rQkList по рангу и наименованию.
	//   Если присутствующий в списке идентификатор не может быть найдет в таблице видов котировок,
	//   то он изымается из списка.
	//
	int    SLAPI ArrangeList(const LDATETIME & rDtm, PPIDArray & rQkList, long flags);
	int    SLAPI GetPacket(PPID id, PPQuotKindPacket *);
	int    SLAPI PutPacket(PPID *, PPQuotKindPacket *, int use_ta);
	int    SLAPI GetCalculatedQuot(PPID, double cost, double basePrice, double * pQuot, long * pFlags);
	//
	// Descr: Создает список элементов типа PPObjQuotKind::ListEntry
	//   Если addBaseQuotKindID != 0, тогда в список добавляется искусственная //
	//   запись, соответствующая базовой котировке (если таковая отсутствует в БД)
	//   ID базовой котировки - PPQUOTK_BASE
	//
	int    SLAPI MakeList(const QuotKindFilt * pFilt, StrAssocArray * pList);
	SArray * SLAPI MakeListByIDList(const PPIDArray *);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	int    SLAPI SearchSymb(PPID * pID, const char * pSymb);
	int    SLAPI MakeCodeString(const PPQuot * pQuot, SString & rBuf);
private:
	virtual int  SLAPI Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int  SLAPI MakeReserved(long flags);
	int    SLAPI Helper_GetRtlList(const LDATETIME & rDtm, PPIDArray * pList, PPIDArray * pTmList, long flags);
	int    SLAPI FetchRtlList(PPIDArray & rList, PPIDArray & rTmList);
	int    SLAPI SerializePacket(int dir, PPQuotKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// @ModuleDecl(PPObjPsnOpKind)
// Виды персональных операций @v2.3.4
//
// Флаги персональных операций
//
#define POKF_UNIQUE    0x0001L // Уникальная операция   //
#define POKF_BINDING   0x0002L // Обязательная операция //
#define POKF_GROUP     0x0004L // Группа верхнего уровня //
//
// Типы парности персональных операций
//
#define POKPT_NONE          0  // Не парная (PPPsnOpKind::PairOp == 0)
#define POKPT_OPEN          1  // Открывающая      //
#define POKPT_CLOSE         2  // Закрывающая      //
#define POKPT_NULLCLOSE     3  // Нуль-закрывающая (открывающая операция не обязательна) //
//
// Группы дополнительных значений
//
#define POKEVG_NONE         0  // Нет
#define POKEVG_TAG          1  // Тег
#define POKEVG_POST         2  // Должность

struct PPPsnOpKind2 {      // @persistent @store(Reference2Tbl+)
	//
	// Descr: Сравнивает объект this с экземпляром rS. Если они равны (за исключением
	//   полей Tag и ID, то возвращает !0, в противном случае - 0.
	//
	int    FASTCALL IsEqual(const PPPsnOpKind2 & rS) const;

	PPID   Tag;            // Const=PPOBJ_PERSONOPKIND
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ
	PPID   ParentID;       // Родительская группа
	char   Reserve[32];    // @reserve
	PPID   RestrStaffCalID; // @v8.0.10 Ограничивающий штатный календарь (событие может произойти только в периоды календаря)
	int32  RscMaxTimes;    // @v8.0.10 Максимальное количество событий, которое может произойти в течении одного периода календаря RestrStaffCalID.
	long   RedoTimeout;    // Таймаут (секунды) в течении которого возможно повторение
		// операции с целью исполнения действий, помеченных флагом PoClause_::fOnRedo
	PPID   RegTypeID;      // ->Ref(PPOBJ_REGISTERTYPE).ID Тип регистрационного документа
	short  ExValGrp;       // Группа дополнительного значения (POPKEVG_XXX)
	short  PairType;       // Тип парности (POPKPT_XXX)
	PPID   ExValSrc;       // Источник дополнительного значения //
		// if(ExValGrp == POPKEVG_TAG) then ExValSrc ->Ref(PPOBJ_TAG).ID
	long   Flags;          // Флаги (POPKF_XXX)
	PPID   LinkBillOpID;   // ->Ref(PPOBJ_OPRKIND).ID
	PPID   PairOp;         // @#{PairOp != ID} ->self.ID   Парная операция //
};

DECL_REF_REC(PPPsnOpKind);
//
// Описание действий над персоналиями, осуществляемых посредством
// персональных операций
//
//
// Типы действий
// Наименования действий хранятся в ресурсах строк с типом PPSTR_POVERB
//
#define POVERB_ASSIGNKIND        1 // Присвоить персоналии ВИД. Вид задается дополнительным параметром действия //
#define POVERB_REVOKEKIND        2 // Отозвать у персоналии ВИД. Вид задается дополнительным параметром действия //
#define POVERB_SETTAG            3 // Установить тег. Тег задается дополнительным параметром операции.
	// Если доп параметр операции не тег, то (по крайней мере пока) это действие не допускается //
#define POVERB_REMOVETAG         4 // Снять тег. Тег задается дополнительным параметром действия //
#define POVERB_ASSIGNPOST        5 // Присвоить персоналии должность
	// Должность определяется дополнительным параметром операции. Если
	// доп параметр операции не должность, то это действие не допускается.
#define POVERB_REVOKEPOST        6 // Отозвать у персоналии должность
	// Отзывается последняя должность первичной персоналии, по отношению
	// ко вторичной. Это накладывает неприятное ограничение, предписывающее
	// человеку занимать не более одной должности у работодателя, либо
	// порождает двусмысленность, если это не так.
#define POVERB_ASSIGNREG         7 // Присвоить персоналии регистрационный документ
	// Персоналии присваивается копия регистрационного документа, оговоренного
	// в операции. Если регистр является уникальным и регистр такого типа
	// уже есть у персоналии, то он изменяется.
#define POVERB_REVOKEREG         8 // Отозвать регистрационный документ у персоналии
	// Тип отзываемого регистрационного документа задается доп параметром
	// действия. Если этот тип уникален, то все однозначно. Если же нет,
	// то придется отзывать все регистрационные документы такого типа.
#define POVERB_SETCALENDAR       9 // Установить значение в календаре
#define POVERB_COMPLETECAL      10 // Заполнение календаря по закрывающей парной операции
#define POVERB_INCTAG           11 // Увеличить значение тега на единицу
#define POVERB_DECTAG           12 // Уменьшить значение тега на единицу
#define POVERB_SETCALCONT       13 // Установить календарь в протяженное состояние с даты события //
#define POVERB_SETCALCONT_SKIP  14 // Установить календарь в протяженное состояние с даты события (пропуск) //
#define POVERB_RESETCALCONT     15 // Удалить запись календаря, переводяющую его в протяженное состояние.
#define POVERB_SETCALENDAR_SKIP 16 // Установить пропуск в календаре
#define POVERB_COMPLETECAL_SKIP 17 // Заполнение календаря пропусками по закрывающей парной операции
#define POVERB_ADDRELATION      18 // Установить отношение персоналии к другой персоналии
#define POVERB_REVOKERELATION   19 // Отозвать отношение персоналии к другой персоналии
#define POVERB_INCSCARDOP       20 // @v7.7.12 Провести операцию увеличения остатка по персональной карте
#define POVERB_DECSCARDOP       21 // @v7.7.12 Провести операцию списания остатка по персональной карте
#define POVERB_DEVICECMD        22 // @v7.8.0  Команда на устройство PoClause_::DirObj
#define POVERB_STYLODISPLAY     23 // @v7.9.6  Выдавать информацию на дисплей StyloDisplay PoClause_::DirObj
#define POVERB_BEEP             24 // @v8.0.10 Звуковой сигнал
#define POVERB_CHKSCARDBILLDEBT 25 // @v8.5.7  Проверка на отсутствие просроченного долга по документам, привязанным к карте

#define POCOBJ_PRIMARY           1
#define POCOBJ_SECONDARY         2
#define POCOBJ_REGORG            3
#define POCOBJ_DIVISION          4
#define POCOBJ_POST              5
#define POCOBJ_TAGVAL            6

class PoClause_ {
public:
	SLAPI  PoClause_();
	int    FASTCALL IsEqual(const PoClause_ & rS) const;
	PPID   SLAPI GetDirObjType() const;
	long   SLAPI GetDirFlags() const;
	//
	// Descr: Заносит содержимое записи в буфер rBuf для сохранения в таблице PropertyTbl.
	//   После успешного завершения rBuf.GetSize() точно равна длине данных, которые должны быть сохранены в БД.
	//
	int    SLAPI PutToPropBuf(STempBuffer & rBuf) const;
	//
	// Descr: Извлекает запись из буфера rBuf, полученного, в свою очередь, из записи таблицы PropertyTbl.
	//
	int    SLAPI GetFromPropBuf(STempBuffer & rBuf, long exValSrc);

	enum {
		fPassive = 0x0001, // Пассивное действие (не исполнять при проведении операции)
		fOnRedo  = 0x0002  // Действие должно исполняться при повторном выполнении операции
	};
	long   Num;     // Counter
	PPID   VerbID;  // POVERB_XXX
	PPID   Subj;    // POCOBJ_PRIMARY | POCOBJ_SECONDARY
	PPID   DirObj;  // Объект, связанный с действием. Тип объекта может быть определен с помощью функции PoClause::GetDirObjType()
	long   Flags;
	SString CmdText;
};

class PoClauseArray_ {
public:
	SLAPI  PoClauseArray_();
	PoClauseArray_ & FASTCALL operator = (const PoClauseArray_ & rS);
	PoClauseArray_ & SLAPI Clear();
	int    SLAPI IsEqual(const PoClauseArray_ & rS, int options = 0) const;
	uint   SLAPI GetCount() const;
	int    SLAPI Get(uint pos, PoClause_ & rItem) const;
	int    SLAPI Add(const PoClause_ & rItem);
	int    SLAPI Set(uint pos, const PoClause_ * pItem);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	struct Item {
		long   Num;
		PPID   VerbID;
		PPID   Subj;
		PPID   DirObj;
		long   Flags;
		uint   CmdTextP;
	};
	TSArray <Item> L;
	StringSet Pool;
};
//
// Ограничения на тип юридического статуса персоналии
//
#define PSNSTT_ANY          0
#define PSNSTT_PRIVATE      1
#define PSNSTT_LEGAL        2
//
// Descr: Пакет, управляющий всеми данными по персональной операции
// @done (@v8.2.3) @dbd_exchange Реализовать передачу PPPsnOpKindPacket::PCPrmr.RestrictScSerList и PPPsnOpKindPacket::PCScnd.RestrictScSerList
//
class PPPsnOpKindPacket { // @persistent
public:
	friend class PPObjPsnOpKind;
	//
	// Descr: Ограничение на персоналию в персональных операциях
	//
	struct PsnConstr {
		PsnConstr();
		PsnConstr & Clear();

		PPID   PersonKindID;   // ->Ref(PPOBJ_PRSNKIND) Вид персоналии
		short  StatusType;     // PSNSTT_XXX Категория статуса персоналии
		short  Reserve1;       // @reserve
		PPID   DefaultID;      // ->Person.ID (Default Person)
		PPID   RestrictTagID;  // @v6.2.0 Ограничивающий тег (если его значение <=0, то событие вводить нельзя)
		PPIDArray RestrictScSerList; // @v7.8.9 Список серий карт, которые можно использовать для идентификации персоналии
	};

	SLAPI  PPPsnOpKindPacket();
	PPPsnOpKindPacket & FASTCALL operator = (const PPPsnOpKindPacket &);
	int    FASTCALL IsEqual(const PPPsnOpKindPacket & rS) const;
	void   SLAPI destroy();
	int    SLAPI CheckExVal();
	PPPsnOpKind  Rec;
	PsnConstr    PCPrmr;     // Ограничения по первичной персоналии
	PsnConstr    PCScnd;     // Ограничения по вторичной персоналии
	PoClauseArray_ ClauseList;
	ObjIdListFilt AllowedTags;
private:
	void * SLAPI AllocExtraProp(size_t * pSz) const;
};

struct PsnOpKindFilt {
	enum {
		tShowAll    = 0,
		tShowItems  = 1,
		tShowGroups = 2
	};
	SLAPI  PsnOpKindFilt(PPID show = 0, PPID parentID = 0, int cantSelParent = 0)
	{
		Show          = show;
		ParentID      = parentID;
		CantSelParent = cantSelParent;
	}
	PPID   Show;          // Тип PsnOpKindFilt::tShowXXX
	PPID   ParentID;      // Группа видов персональных операций
	int    CantSelParent; // Не выбирать группы если установлен данный флаг,
};

class PPObjPsnOpKind : public PPObjReference {
public:
	static PPID SLAPI Select(long = 0);
	static int  SLAPI CheckRecursion(PPID id, PPID parentID);

	SLAPI  PPObjPsnOpKind(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, PPPsnOpKind * pRec);
	int    SLAPI GetPacket(PPID, PPPsnOpKindPacket *);
	int    SLAPI PutPacket(PPID *, PPPsnOpKindPacket *, int use_ta);
	long   SLAPI GetLevel(PPID id);
	StrAssocArray * SLAPI MakeList(const PsnOpKindFilt * pPsnOpKindFilt);
	int    SLAPI SerializePacket(int dir, PPPsnOpKindPacket * pPack, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	virtual int  SLAPI ValidateSelection(PPID, uint olwFlags, void * extraPtr);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack*);

	PsnOpKindFilt CurrFilt;
};
//
//
//
// @v8.6.4 extern const char * G_NativeCountry; // @defined(objcntry.cpp) Word "россия" в кодировке cpp866
//
// @ModuleDecl(PPObjWorldObjStatus)
//
struct PPWorldObjStatus2 { // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_CITYSTATUS
	long   ID;             // @id
	char   Name[48];       // @name
	char   Abbr[20];       // Сокращение
	char   Reserve[60];    // @reserve
	long   Flags;          // @reserve
	long   Kind;           // WORLDOBJ_XXX
	long   Code;           // Классификатор (возможно, связан с внешним классификатором). Если Code!=0, то значение уникально
};

DECL_REF_REC(PPWorldObjStatus);

class PPObjWorldObjStatus : public PPObjReference {
public:
	SLAPI  PPObjWorldObjStatus(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	//
	// Descr: Ищет запись с кодом code.
	// ARG(code     IN): Код статуса, по которому ущется запись. Если code == 0, то функция //
	//   немедленно возвращает -1.
	// ARG(kind     IN): Если kind != 0, то ищется запись только со значением Kind == kind
	// ARG(pID  IN/OUT): Если pID != 0 && *pID != 0, то запись с идентификатором равным *pID
	//   не принимается. Используется для нахождения дубликата по коду записи с ид *pID.
	// ARG(pRec    OUT): @#{vptr0} Указатель на буфер, в который копируется найденная запись.
	// Returns:
	//   >0 - найдена запись по заданным условиям
	//   <0 - запись не найдена
	//   0  - ошибка
	//
	int    SLAPI SearchByCode(long code, long kind, PPID * pID, PPWorldObjStatus * pRec);
	int    SLAPI AddSimple(PPID * pID, const char * pName, const char * pAbbr, long kind, long code, int use_ta);
};
//
// @ModuleDecl(PPObjWorld)
//
#define WORLDOBJ_SPECIAL    -100  // Специальная запись, являющаяся индикатором того, что таблица была
	// отконвертирована из старого набора объектов PPObjCountry, PPObjCity, PPObjRegion
#define WORLDOBJ_CONTINENT  1
#define WORLDOBJ_GENREGION  2
#define WORLDOBJ_COUNTRY    3
#define WORLDOBJ_REGION     4
#define WORLDOBJ_CITY       5
#define WORLDOBJ_STREET     6 // Улица (площадь, проспект и т.д.)
#define WORLDOBJ_CITYAREA   7 // Район города
#define WORLDOBJ_LOCALAREA  8 // Локальная область (район) (в базе данных не хранится)
#define WORLDOBJ_HOUSE      9 // Стоение, дом (в базе данных не хранится)
#define WORLDOBJ_APART     10 // Квартира, комната, офис (в базе данных не хранится)
#define WORLDOBJ_FLOOR     11 // Этаж (в базе данных не хранится)
#define WORLDOBJ_POSTBOX   12 // Абонентский ящик (в базе данных не хранится)

class PPWorldPacket {
public:
	SLAPI  PPWorldPacket();
	int    SLAPI Init();
	WorldTbl::Rec Rec;
};

class PPObjWorld : public PPObject {
public:
	struct SelFilt {
		SelFilt();
		PPID   GetSingleKind() const;

		uint    KindFlags;    // WORLDOBJ_XXX (0 - any kind)
		PPID    ParentID;
		PPID    CountryID;
		SString SubName;
	};
	static void * SLAPI MakeExtraParam(int kind, PPID parentID, PPID countryID);
	static void * SLAPI MakeExtraParam(const PPIDArray & rKindList, PPID parentID, PPID countryID);
	static int  SLAPI ConvertExtraParam(void * extraPtr, SelFilt * pFilt);
	static int  SLAPI UniteMaxLike();
	static SString & SLAPI GetNativeCountryName(SString & rBuf);

	SLAPI  PPObjWorld(void * extraPtr = 0);
	SLAPI ~PPObjWorld();
	virtual int    SLAPI Browse(void * extraPtr);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI Search(PPID id, void * b = 0);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec: {ID, Kind, ParentID, CountryID, Name, Status, Flags}
	//
	int    SLAPI Fetch(PPID id, WorldTbl::Rec * pRec);
	int    SLAPI GetListByName(int kind, const char * pName, SArray * pList);
	int    SLAPI SearchByName(int kind, const char * pName, WorldTbl::Rec * pRec);
		// @>>PPObjWorld::GetListByName
	int    SLAPI GetListByCode(int kind, const char * pCode, SArray * pList);
	int    SLAPI SearchByCode(const char * pCode, WorldTbl::Rec * pRec);
	int    SLAPI GetListByFilt(const SelFilt & rFilt, SArray * pList);
	//
	// Descr: Ищет государство (Kind == WORLDOBJ_COUNTRY) по следующему алгоритму:
	//   - Если !isempty(pName), тогда точное соответствие по наименованию.
	//     В случае, если существует более одной записи государства с именем равным pName,
	//     то список таких записей сверяется с параметрами pCode и pAlpha2. Первая запись,
	//     которая согласуется либо с pCode либо с pAlpha2, считается искомой. Если все
	//     записи не соотвествуют этим критериям, то берется первая из списка.
	//   - Если предыдущие шаги безуспешны, то
	//       если !isempty(pCode), тогда точное соответствие WorldTbl::Rec::Code - pCode
	//   - Если предыдущие шаги безуспешны, то
	//       если !isempty(pAlpha2), тогда точное соответствие WorldTbl::Rec::Abbr - pAlpha2
	// Returns:
	//   <0 - государство не найдено
	//   1 - государство найдено по наименованию
	//   2 - государство найдено по коду
	//   3 - государство найдено по аббревиатуре pAlpha2
	//
	int    SLAPI SearchCountry(const char * pName, const char * pCode, const char * pAlpha2, WorldTbl::Rec * pRec);
	//
	// Descr: Опции поиска аналога географического объекта
	//
	enum {
		smlDefault      = 0,             // smlCode|smlName|smlCheckCountry
		smlCode         = 0x0001,        // Поиск по коду
		smlName         = 0x0002,        // Поиск по наименованию
		smlCheckCountry = 0x0004,        // Если код или наименование дали совпадение,
			// то проверить эквивалентность государства
		smlCheckParent  = 0x0008,        // Если код или наименование дали совпадение,
			// то проверить эквивалентность родительского объекта
		smlCheckCountryOrParent = 0x0010 // Если код или наименование дали совпадение,
			// то проверить эквивалентность по правилу:
			// NZOR(ParentID, CountryID) == NZOR(candidate.ParentID, candidate.CountryID))
	};
	int    SLAPI SearchMaxLike(PPWorldPacket * pPack, long flags, PPID * pID);
	//
	// Descr: Определяет, является ли объект id потомком объекта parentID.
	//   Родство определяется либо по линии ParentID либо CountryID.
	// Returns:
	//   >0 - объект id является потомком объекта parentID
	//    0 - объект id не является потомком объекта parentID.
	//
	int    SLAPI IsChildOf(PPID id, PPID parentID); // @recursion
	int    SLAPI GetCountryByChild(PPID id, WorldTbl::Rec * pCountryRec);
	int    SLAPI GetPacket(PPID id, PPWorldPacket * pPack);
	//
	// Descr: Записывает пакет объекта в базу данных. Возможны следующие случаи:
	//   {*pID == 0 && pPack != 0}: ЗАПИСЫВАЕТ НОВЫЙ пакет в БД. По указателю pID присваивает ИД нового объекта.
	//   {*pID != 0 && pPack != 0}: ИЗМЕНЯЕТ СУЩЕСТВУЮЩИЙ пакет c идентификатором *pID в БД.
	//   {*pID != 0 && pPack == 0}: УДАЛЯЕТ СУЩЕСТВУЮЩИЙ пакет c идентификатором *pID из БД.
	// ARG(pID    IN/OUT): @#{vptr}  Указатель на идентификатор объекта
	// ARG(pPack      IN): @#{vptr0} Указатель на пакет объекта
	// ARG(use_ta     IN): Если !0, то функция реализует внутреннюю транзакцию
	// Returns:
	//   >0 - пакет успешно записан (удален) в (из) базу данных
	//   <0 - в случае {*pID != 0 && pPack != 0} функция обнаружила, что пакет не изменился по сравнению с БД
	//        и функция не стала выполнять обновление данных в БД
	//   0  - ошибка
	//
	int    SLAPI PutPacket(PPID * pID, PPWorldPacket * pPack, int use_ta);
	int    SLAPI AddSimple(PPID * pID, int kind, const char * pName, const char * pCountry, int use_ta);
	int    SLAPI GetParentCountry(PPID id, PPID * pParentCountryID);
	int    SLAPI GetNativeCountry(PPID * pID);
	int    SLAPI ImportCountry(int use_ta);
	// Возвращает PPObjListWindow
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
private:
	virtual int    SLAPI DeleteObj(PPID id);
	virtual int    SLAPI ValidateSelection(PPID id, uint olwFlags, void * extraPtr);
	virtual void   SLAPI Destroy(PPObjPack *);
	virtual int    SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int    SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int    SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual const char * SLAPI GetNamePtr();
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI Unite(PPID destID, PPID srcID);
	struct AislBlock {
		StrAssocArray * P_List;
		int    UseHierarchy;
		PPIDArray Stack;
		UintHashTable El; // Список идентификаторов, которые уже добавлены в P_List
	};
	int    SLAPI AddItemToSelectorList(const WorldTbl::Rec & rRec, AislBlock & rBlk); // @recursion
	int    SLAPI AddItemToSelectorList(PPID id, StrAssocArray * pList, int useHierarchy, PPIDArray * pStack); // @recursion
	int    SLAPI GetChildList(PPID id, PPIDArray * pChildList, PPIDArray * pStack); // @recursion
	int    SLAPI Helper_IsChildOf(PPID id, PPID parentID, PPIDArray * pRecurTrace); // @recursion

	int    SLAPI Recover(PPLogger * pLogger); // @todo Срочно!!!
public:
	static int SLAPI Convert();

	void * ExtraPtr;
	TLP_MEMB(WorldTbl, P_Tbl);
};
//
//
//
#define FIASADRF_ACTUAL       0x0001 // Признак актуальности адресного объекта

#define FIASHSEINTSTATUS_HOUSE     0 // запись отдельного дома
#define FIASHSEINTSTATUS_SOLID     1 // обычный интервал, включающий четные и нечетные номера домов
#define FIASHSEINTSTATUS_EVEN      2 // только четные значения
#define FIASHSEINTSTATUS_ODD       3 // только нечетные значения

#define FIASHSEESTSTATUS_INT       0 // для интервала
#define FIASHSEESTSTATUS_OWNRSH    1 // владение
#define FIASHSEESTSTATUS_HOUSE     2 // дом
#define FIASHSEESTSTATUS_HSEOWNRSH 3 // домовладение
#define FIASHSEESTSTATUS_LAND      4 // участок

#define FIASHSEBLDSTATUS_INT       0 // для интервала
#define FIASHSEBLDSTATUS_STRUC     1 // строение
#define FIASHSEBLDSTATUS_CONSTR    2 // сооружение
#define FIASHSEBLDSTATUS_LITER     3 // литер

class FiasObjCore {
public:
	struct HouseCode {
		static SString & NormalizeItem(SString & rBuf);
		SLAPI  HouseCode(const char * pCode);
		HouseCode & SLAPI Clear();
		SString & FASTCALL Encode(SString & rBuf) const;
		int    FASTCALL Decode(const char * pCode);

		SString HseNum; // Номер дома
		SString BldNum; // Номер корпуса
		SString StrNum; // Номер строения
	};

    SLAPI  FiasObjCore();
    //
    // Descr: Ищет адресный объект по идентификатору записи (не путать с идентификатором объекта).
    //
    int    SLAPI SearchAddr(long recID, FiasAddrObjTbl::Rec * pRec);
    //
    // Descr: Ищет здание по идентификатору
    //
    int    SLAPI SearchHouse(long hseID, FiasHouseObjTbl::Rec * pRec);
    //
    // Descr: Ищет адресный объект по идентификатору.
    //
    int    SLAPI SearchAddrByID(long addrID, FiasAddrObjTbl::Rec * pRec);
    //
    // Descr: Ищет адресный объект по глобальному идентификатору.
    //
    int    SLAPI SearchAddrByUUID(const S_GUID & rUuid, FiasAddrObjTbl::Rec * pRec);
    int    SLAPI SearchHouseByUUID(const S_GUID & rUuid, FiasHouseObjTbl::Rec * pRec);
    int    SLAPI GetAddrListByZIP(const char * pZip, PPIDArray & rList);
    int    SLAPI GetHouseListByZIP(const char * pZip, PPIDArray & rList);
    int    SLAPI GetChildList(PPID id, int level, PPIDArray & rList);

    FiasAddrObjTbl  AdrT;
    FiasHouseObjTbl HseT;
    UuidRefCore UrT;
private:
	int    SLAPI Helper_GetChildList(PPID parentID, int level, PPIDArray & rList);
};

class PPFiasReference {
public:
	static int IdentifyShortDescription(const char * pText, int * pLevel, SString * pFullText);

    SLAPI  PPFiasReference();
    SLAPI ~PPFiasReference();
    int    SLAPI SearchObjByID(PPID id, FiasAddrObjTbl::Rec * pRec, int useCache);
    int    SLAPI SearchObjByUUID(const S_GUID & rUuid, FiasAddrObjTbl::Rec * pRec);
    int    SLAPI SearchHouseByID(PPID id, FiasHouseObjTbl::Rec * pRec);
    int    SLAPI SearchHouseByUUID(const S_GUID & rUuid, FiasHouseObjTbl::Rec * pRec);
    //
    // Descr: Опции функции SearchObjByText
    //
    enum {
    	stfAnsiInput    = 0x0001, // Входящая строка - в ANSI кодировке
    	stfPrefix       = 0x0002, // Искать все, что начинается с pText
    	stfDontUseCache = 0x0004  // @internal Не использовать кэш
    };

    int    SLAPI SearchObjByText(const char * pText, long flags, PPID upperID, PPIDArray & rList);

    enum {
    	matfZipPrefix = 0x0001,
    	matfTryHouse  = 0x0002
    };
    int    SLAPI MakeAddressText(PPID terminalID, long flags, SString & rBuf);
    int    SLAPI GetText(PPID textRef, SString & rBuf);
	//
	// ARG(vec IN) :
	//    0 - предварительно не известно нахождение obj1ID и obj2ID друг относительно друга в иерархии
	//   <0 - obj1ID заведомо на уровне ниже obj2ID
	//   >0 - obj1ID заведомо на уровне выше obj2ID
	// Returns:
	//   0 - error
	//  -1 - not match
	//   1 - obj1ID belong to obj2ID
	//   2 - obj2ID belong to obj1ID
	//   3 - obj1ID equal obj2ID
	//
    int    SLAPI Match(PPID obj1ID, PPID obj2ID, int vect);
    int    SLAPI IdentifyHouse(PPID terminalObjID, const char * pHouseCode, PPID * pHouseID);

    int    SLAPI GetRandomHouse(long extValue, PPID terminalObjID, PPID * pHouseID);
    int    SLAPI GetRandomAddress(long extValue, PPID cityID, PPID * pStreetID, PPID * pHouseID);

    //TextRefCore TrT;
    FiasObjCore FT;
private:
	friend class FiasAddrCache;

	int    SLAPI Helper_GetHierarchy(PPID id, long flags, FiasHouseObjTbl::Rec * pHseRec, TSArray <FiasAddrObjTbl::Rec> & rList, long * pZip);
	uint   SLAPI IsObjInHierarchy(PPID objID, const TSArray <FiasAddrObjTbl::Rec> & rList) const;
	int    SLAPI SearchObjByTextRefList(const TSArray <TextRefIdent> & rTRefList, PPIDArray & rList);
};
//
//
//
class FiasImporter {
public:
	struct Param {
		SLAPI  Param();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fImportAddrObj    = 0x0001,
			fImportHouseObj   = 0x0002,
			fIgnoreSavedState = 0x0004,
			fDoDebugOutput    = 0x0008
		};
		long   Flags;
		SString Path;
	};
	enum {
		inpAddrObj = 1,
		inpHouse
	};
	static int EditParam(Param & rP);

	FiasImporter();
	~FiasImporter();
	int    Run(Param & rP);
private:
	int    Import(int inpObject);
	int    FASTCALL ToggleTransaction(ulong threshold);
	int    ReadRecordFromXmlAttrList(const char ** ppAttrList);
	int    ParseFiasFileName(const char * pFileName, SString & rObjName, LDATE & rDt, S_GUID & rUuid);
	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    SaxParseFile(xmlSAXHandlerPtr sax, const char * pFileName);
	void   SaxStop();
	int    ProcessString(const char * pRawText, long * pRefId, SString & rTempBuf, SStringU & rTempBufU);

	int    CollectUuid(const S_GUID & rUuid);
	int    FlashUuidChunk(uint maxCount, int use_ta);
	int    FlashAddrChunk(uint maxCount, int use_ta);
	int    FlashHouseChunk(uint maxCount, int use_ta);

	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);

	enum {
		phaseGeneric = 0,
		phaseCount = 1,
		phaseUUID,
		phaseText,
		phaseData
	};

	class ProcessState {
	public:
		SLAPI ProcessState();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    SLAPI Store(int use_ta);
		int    SLAPI Restore();
		int    SLAPI SearchItem(const char * pPath, int phase, uint * pPos, SString & rNormalizedName) const;
		int    SLAPI SetItem(const char * pPath, int phase, uint * pPos, SString & rNormalizedName);

        struct Item {
        	SLAPI  Item();
        	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

			char   InputFileName[128];
			int32  Phase;
        	uint32 LastProcessedRecN;
        	int64  TotalMks;
        	uint8  Reserve[64];
        };
        TSArray <Item> L;
	};
	enum {
		stError = 0x0001
	};
	long   State;
	enum {
		fDoDebugOutput = 0x0001
	};
	int    InputObject;
	Param  P;
	ProcessState Ps;
	int    CurPsPos; // Текущая позиция в Ps. <0 - не определена
	//
	xmlParserCtxt * P_SaxCtx;
	PPTransaction Tra;
	ulong  RawRecN;
	SdRecord * P_Sdr;
	SFile * P_DebugOutput;
	SymbHashTable TextCache;

	UuidArray PreprocessUuidChunk;
	TSArray <FiasAddrObjTbl::Rec> AddrRecChunk;
	TSArray <FiasHouseObjTbl::Rec> HouseRecChunk;

    //TextRefCore TrT;
    FiasObjCore FT;
};
//
// @ModuleDecl(PPObjRegister)
//
#define BACCTF_PREFERRED 0x0001L
//
// Descr: Объект данных, управляющий регистрами персоналий.
//   Этот объект существует в тесной зависимости от объектов PPOBJ_PERSON, PPOBJ_PERSONEVENT, PPOBJ_LOCATION.
//   Если запись RegisterTbl::Rec имеет ненулевую ссылку PsnEvent, то
//   она управляется объектом PPOBJ_PERSONEVENT, в противном случае - объектом PPOBJ_PERSON или PPOBJ_LOCATION.
//   @# RegisterTbl::Rec::Person != 0
//
class PPObjRegister : public PPObject {
public:
	static int SLAPI InitPacket(RegisterTbl::Rec * pRec, PPID regTypeID, PPID objType, PPID objID);
	static int SLAPI Format(const RegisterTbl::Rec & rRec, const char * pFormat, SString & rBuf);

	SLAPI  PPObjRegister(void * extraPtr = 0);
	SLAPI ~PPObjRegister();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID);
	virtual int  SLAPI Search(PPID id, void * b = 0);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /* (RegisterFilt*) */);
	int    SLAPI Fetch(PPID id, RegisterTbl::Rec * pRec);
	int    SLAPI SearchByNumber(PPID *, PPID regTypeID, const char * pSn, const char * pNmbr, RegisterTbl::Rec *);
	int    SLAPI SearchByFilt(const RegisterFilt *, PPIDArray * pResList, PPIDArray * pPsnList, PPIDArray * pRegTList);
	int    SLAPI Edit(PPID * pID, PPID objType, PPID objID, PPID regTypeID);
	int    SLAPI EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, const PPPersonPacket * pOuterPack);
	int    SLAPI EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, const PPLocationPacket * pOuterPack);
	int    SLAPI EditBankAccount(PPBankAccount * pRec, PPID psnKindID);
	int    SLAPI EditList(PPPersonPacket * pPsnPack, PPID psnEventID);
	int    SLAPI EditList(PPLocationPacket * pLocPack);
	int    SLAPI EditBankAccountList(PPPersonPacket * pPsnPack);
	int    SLAPI GetBankAccountList(PPID personID, TSArray <PPBankAccount> * pList);
	//
	// Descr: Проверяет массив регистров pRegs на отсутствие дублирования типа regTypeID
	//   если этот тип имеет признак REGTF_UNIQUE.
	//   То есть в массиве pRegs должно быть не более одного регистра с типом regTypeID,
	//   если он (тип) имеет признак REGTF_UNIQUE.
	// Returns:
	//   >0 - Дублирование отсутствует
	//   0  - Есть дублированные регистры (PPErrCode = PPERR_DUPREGISTER)
	//
	int    SLAPI CheckUnique(PPID regTypeID, const RegisterArray * pRegs) const;
	int    SLAPI CheckUniqueNumber(const RegisterTbl::Rec *, const RegisterArray *, PPID objType, PPID objID);
	//
	// Descr: Форматирует регистрационный документ согласно форматирующей строке,
	//   заданной параметром fmt. Если первый параметр <0, то форматируется запись,
	//   находящаяся в буфере, иначе запись ищется по идентификатору.
	//   Если форматирующая строка не задана (pFormat == 0), то она извлекается //
	//   из записи типа регистрационного документа.
	//
	int    SLAPI Format(PPID id, const char * pFormat, char *, size_t); // @obsolete
	int    SLAPI Format(PPID id, const char * pFormat, SString & rBuf);
	int    SLAPI GetTabNumber(PPID personID, SString & rTabNum);
	//
	// Descr: Специализированная функция, используемая при акцепте объектов,
	//   включающих записи регистров (PPOBJ_PERSON, например).
	//
	int    SLAPI PreventDup(RegisterTbl::Rec & rRec, PPID linkObjType, PPID linkObjID);
private:
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual const char * SLAPI GetNamePtr();
	int    SLAPI Helper_EditDialog(RegisterTbl::Rec * pRec, const RegisterArray * pRegList, PPID outerObjType, const void * pOuterPacket);
public:
	TLP_MEMB(RegisterCore, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPObjLocation)
//
enum {
	whzcDefault = 0,
	whzcAlpha,
	whzcDigit1,
	whzcDigit2,
	whzcDigit3,
	whzcDigit4,
	whzcOwnCode
};

struct PPLocationConfig {  // @transient @store(PropertyTbl)
	enum {
		fValid        = 0x0001, // @transient Используется при кэшировании. Означает, что
			// запись, хранящаяся в кэше была считана из базы данных.
		fUseFias      = 0x0002  // @v8.6.12 Применять справочник ФИАС
	};
	int16  WhZoneCoding;
	int16  WhColCoding;
	int16  WhRowCoding;
	int16  WhCellCoding;
	int16  WhCodingDiv;    // Разделитель кодов складских позиций  (0 - dot, 1 - defis, 2 - none)
	int16  Reserve;        // @alignment
	long   Flags;          // @flags
	PPID   DefPalletID;    // @v6.7.0
	PPID   StoreIdxTagID;  // @v8.9.11 Идентификатор тега, отвечающий за индекс магазина в сети (только для LOCTYP_WAREHOUSE)
	char   AddrCodeTempl[32]; // @v7.3.8 Шаблон кода нового адреса
};
//
// Descr: Специализированная структура для унифицированного обмена информацией о государстве.
//   Необходимость этой структуры обусловлена двоякой формой хранения данных о государствах:
//   -- В таблице World (нормальный метод)
//   -- В таблице Person (специальный метод, иногда используемый для обозначения страны происхождения товаров)
//
struct PPCountryBlock {
	PPCountryBlock & Clear();

	int    IsNative; // @v9.7.8 Если код страны совпадает с кодом страны фактического (или юридического,
		// если фактический пуст) адреса главной организации.
	SString Name;
	SString Code;
	SString Abbr;
};

class PPLocationPacket : public LocationTbl::Rec {
public:
	SLAPI  PPLocationPacket();
	SLAPI  PPLocationPacket(const PPLocationPacket & rS);
	void   SLAPI destroy();
	int    FASTCALL Copy(const PPLocationPacket & rS);
	PPLocationPacket & FASTCALL operator = (const PPLocationPacket & rS);
	PPLocationPacket & FASTCALL operator = (const LocationTbl::Rec & rS);
	int    SLAPI IsEmptyAddress() const;

	//LocationTbl::Rec Rec;
	RegisterArray Regs;
	ObjTagList TagL;
};

class PPObjLocation : public PPObject {
public:
	static int SLAPI ReadConfig(PPLocationConfig * pCfg);
	static int SLAPI WriteConfig(const PPLocationConfig * pCfg, int use_ta);
	static int SLAPI EditConfig();
	static int SLAPI FetchConfig(PPLocationConfig * pCfg);
	static int SLAPI DirtyConfig();

	static int  SLAPI SelectWarehouse(PPID owner = 0, PPID level = 0);
	static PPID SLAPI ObjToWarehouse(PPID);
	static PPID SLAPI WarehouseToObj(PPID);
	static int  SLAPI CheckWarehouseFlags(PPID locID, long);
	static int  SLAPI ViewWarehouse();
	static int  SLAPI ViewDivision();

	SLAPI  PPObjLocation(void * extraPtr = 0);
	SLAPI ~PPObjLocation();
	virtual int SLAPI Search(PPID id, void * b = 0);
	virtual int SLAPI Dirty(PPID id);
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
		// @>>PPObjLocation::MakeList(const LocationFilt, long)
	//
	// Descr: возвращает родительский склад для объекта locID.
	//   Если locID является складом, то по указателю pWarehouseID присваивается собственно locID,
	//   если locID является складской зоной, складской колонной либо складской ячейкой,
	//   то по указателю pWarehouseID присваивается идентификатор склада, которому принадлежит этот объект.
	//   В остальных случаях по указателю pWarehouseID присваивается ноль и
	//   возвращаемое значение равно -1.
	//
	int    SLAPI GetParentWarehouse(PPID locID, PPID * pWarehouseID);
	int    SLAPI SearchName(PPID locTyp, PPID parentID, const char * pName, PPID * pID);
	//
	// Descr: Опции формирования строки кода локации
	//
	enum {
		mcsWhCodePrefix = 0x0001 // Добавлять в качестве префикса код склада
	};
	SString & MakeCodeString(const LocationTbl::Rec * pRec, int options, SString & rBuf);
	int    SLAPI Validate(LocationTbl::Rec * pRec, int /*chkRefs*/);
	int    SLAPI Fetch(PPID id, LocationTbl::Rec * pRec);
	//
	// Descr: Возвращает !0 если элемент склада id требует автоматического
	//   назначения имени.
	// Returns:
	//   >0 - элемент склада id требует автоматического имени согласно его собственному свойству
	//   <0 - элемент склада id требует автоматического имени согласно по требованию родительского элемента.
	//   0  - элемент склада id не требует автоматического имени либо ошибка.
	//
	int    SLAPI ReqAutoName(PPID id);
	int    SLAPI GenerateWhCells(PPID whColumnID, const LocationTbl::Rec * pSampleRec, int use_ta);
	int    SLAPI InitCode(LocationTbl::Rec * pRec);
	int    SLAPI IsPacketEq(const PPLocationPacket & rS1, const PPLocationPacket & rS2, long flags);
	int    SLAPI GetPacket(PPID id, PPLocationPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPLocationPacket * pPack, int use_ta);
	int    SLAPI PutRecord(PPID * pID, LocationTbl::Rec * pPack, int use_ta);
	//
	// Descr: возвращает список складов, доступных текущему пользователю
	//   Функция не очищает список pList перед добавлением в него новых элементов,
	//   однако вставка новых элементов реализуется методом PPIDArray::addUnique
	//   что исключает дублирование.
	// ARG(pList OUT): @#{vptr0} указатель на массив, в который функция вставит
	//   идентификаторы складов
	// Returns:
	//   Количество складов, обработанных функцией. Если pList == 0, то возвращаемое значение
	//   будет все равно правильным.
	// Remark: использует кэш
	//
	uint   SLAPI GetWarehouseList(PPIDArray * pList);
	//
	// Descr: "Распрямляет" список складов pList, возможно, содержащий склады верхнего уровня.
	//   Результирующий список формируется по ссылке rDestList.
	//   В результирующий список не попадают склады, к которым у текущего пользователя нет
	//   прав доступа.
	//
	int    SLAPI ResolveWarehouseList(const PPIDArray * pList, PPIDArray & rDestList);
	int    SLAPI ResolveWhCellList(const PPIDArray * pList, long options, PPIDArray & rDestList);
	//
	// Descr: Определяет является ли локация locID дочерней по отношению к grpID.
	//   Для этого функция движется вверх по иерархии от locID до корневого узла.
	//   Если один из узлов в иерархии равен grpID, то результат положительный.
	// Note: Проверяет иерархию на циклические ссылки.
	// Returns:
	//   >0 - локация locID является дочерней по отношению к grpID
	//   <0 - локация locID не является дочерней по отношению к grpID
	//   0  - ошибка. В случае обнаружения цикла возвращается код ошибки PPERR_LOCATIONRECUR.
	//
	int    SLAPI IsMemberOfGroup(PPID locID, PPID grpID);
	int    SLAPI GetWarehouseTerminalList(PPID parentID, PPIDArray * pList);
	//
	// Descr: Определяет, наследуется ли locID от parentID по цепочке связей LocationTbl::Rec::ParentID
	// Note:
	//   Если parentID == 0, то функция считает, что locID не принадлежит parentID
	//   Если locID == parentID, то функция считает, что locID принадлежит parentID
	// Returns:
	//   1 - locID принадлежит parentID
	//   0 - locID не принадлежит parentID
	//
	int    SLAPI BelongTo(PPID locID, PPID parentID, SString * pPathText);
	//
	// Descr: Возвращает ID склада если он в справочнике один-одинешенек, иначе - 0.
	//   Учитываются только те склады, к которым пользователь имеет доступ.
	// Remark: использует кэш
	//
	PPID   SLAPI GetSingleWarehouse();
	//
	// Descr: Флаги функции PPObjLocation::EditDialog(PPID, PPLocationPacket *, long);
	//
	enum {
		edfMainRecOnly = 0x0001 // Редактировать только основную запись пакета (Regs, TagL не менять)
	};
	int    SLAPI EditDialog(PPID locTyp, PPLocationPacket * pPack, long flags);
	int    SLAPI EditDialog(PPID locTyp, LocationTbl::Rec * pRec);
	int    SLAPI EditAddrStruc(SString & rAddr);
	//
	// Descr: Формирует строку адреса локации locID.
	// Note: Функционально является полным аналогом LocationCore::GetAddress за исключением
	//   того, что запись по идентификатору locID извлекается через кэш.
	//
	int    SLAPI GetAddress(PPID locID, uint flags, SString & rBuf);
	int    SLAPI GetCountry(PPID locID, PPID * pCountryID, PPCountryBlock * pBlk);
	int    SLAPI GetCountry(const LocationTbl::Rec * pLocRec, PPID * pCountryID, PPCountryBlock * pBlk);
	int    SLAPI GetCity(PPID locID, PPID * pCityID, SString * pName, int useCache);
	int    SLAPI GetCityByName(const char * pName, PPID * pCityID);
	int    SLAPI FetchCity(PPID cityID, WorldTbl::Rec * pRec);
	int    SLAPI FetchCityByAddr(PPID locID, WorldTbl::Rec * pRec);
	StrAssocArray * SLAPI MakeList_(const LocationFilt * pLocFilt, long zeroParentId = 0);
	//
	struct CreateWhLocParam {
		PPID   Type;
		LocationTbl::Rec CellSample;
	};
	int    SLAPI EditCreateWhLocParam(CreateWhLocParam * pParam);
	//
	// Descr: Специализированная функция, используемая для идентификации
	//   набора объектов, которые должны быть помечены как dirty в кэше.
	//
	int    SLAPI GetDirtyCellParentsList(PPID locID, PPIDArray & rDestList);
	//
	// Descr: Индексирует телефонные номера, находящиеся в записях таблицы Location
	//
	int    SLAPI IndexPhones(int use_ta);
	int    SLAPI GetEaListBySubstring(const char * pSubstr, StrAssocArray * pList, int fromBegStr);
	const  StrAssocArray * SLAPI GetFullEaList();
	void   SLAPI ReleaseFullEaList(const StrAssocArray * pList);
	//
	// @attention: really private
	//
	int    SLAPI ResolveWhCell(PPID locID, PPIDArray & rDestList, PPIDArray * pRecurTrace, int useCache);
	int    SLAPI GetRegister(PPID locID, PPID regType, LDATE actualDate, int iheritFromOwner, RegisterTbl::Rec * pRec);
private:
	virtual int SLAPI DeleteObj(PPID id);
	virtual int SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int SLAPI MakeReserved(long flags);
	virtual const char * SLAPI GetNamePtr();
	int    AddListItem(StrAssocArray * pList, LocationTbl::Rec * pLocRec, long zeroParentId, PPIDArray * pRecurTrace);
		// @<<PPObjLocation::MakeList(const LocationFilt, long)
	int    SLAPI MakeListByType(PPID locType, PPID parentID, long zeroParentId, int flags, StrAssocArray * pList);
		// @<<PPObjLocation::MakeList(const LocationFilt, long)
	int    SLAPI ResolveWarehouse(PPID locID, PPIDArray & rDestList, PPIDArray * pRecurTrace);
		// @recursion @<<PPObjLocation::ResolveWarehouseList(const PPIDArray *, PPIDArray &)
	int    SLAPI InitCityCache();
	int    SLAPI GetCityID(PPID locID, PPID * pCityID, int useCache);
	int    SLAPI InitWhCode(LocationTbl::Rec * pRec);
	int    SLAPI AssignImages(ListBoxDef * pDef);
	int    SLAPI SerializePacket(int dir, PPLocationPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		clsfStrList = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		clsfFromBeg = 0x0002  // Только карты, начинающиеся с pSubstr
	};
	int    SLAPI Helper_GetEaListBySubstring(const char * pSubstr, void * pList, long flags);

	LAssocArray CityCache;
	int    IsCityCacheInited;
	PPObjWorld * P_WObj;
	PPObjRegister RegObj; // @v8.3.6
	LocationFilt * P_CurrFilt; // @v9.6.1
	SString NameBuf; // Returns by GetNamePtr
public:
	TLP_MEMB(LocationCore, P_Tbl);
	void * ExtraPtr;
};
//
//
//
class PPLocAddrStruc : public StrAssocArray {
public:
	struct _MatchEntry {
		SLAPI  _MatchEntry(uint p1 = 0, uint p2 = 0, int reverse = 0);
		SLAPI  _MatchEntry(const _MatchEntry & rS);

		uint   P1;
		uint   P2;
		int    Reverse;
		LAssocArray CityStreetList;
	};
	//
	// Descr: Специальный тип идентифицирующий необходимость создания экземпляра
	//   объекта с собственным экземпляром PPFiasReference
	//
	enum ConditionalConstructWithFias {
		conditionalConstructWithFias = 1
	};

	SLAPI  PPLocAddrStruc(const char * pText = 0, PPFiasReference * pFr = 0);
	SLAPI  PPLocAddrStruc(ConditionalConstructWithFias ccwf);
	SLAPI ~PPLocAddrStruc();
	int    SLAPI Recognize(const char * pText);
	int    SLAPI GetFiasTerminalID(PPID * pAddrID, PPID * pHouseID);
	int    SLAPI Output(SString & rBuf); // @debug

	int    SLAPI HasAmbiguity() const;
	const  TSCollection <_MatchEntry> * SLAPI GetAmbiguityMatchList() const;
	const  _MatchEntry * SLAPI GetAmbiguityMatchEntry() const;
	int    SLAPI MatchEntryToStr(const _MatchEntry *, SString & rBuf);

	enum {
		tAddress = 1,
		tCountry,
		tZip,
		tLocalArea,
		tCity,
		tStreet,
		tHouse,
		tHouseAddendum,
		tCorp,
		tApart,
		tFloor,
		tPostBox,
		tAddendum, // Дополнительная информация в строке адреса

		tCityKind,
		tLocalAreaKind,
		tStreetKind,
		tHouseKind,
		tHouseAddendumKind,
		tApartKind,

		tFiasCityID,
		tFiasStreetID,
		tFiasHouseID,
		tFiasTerminalID
	};
	enum {
		sRussian = 1
	};
	int    Style;        // Стиль представления строки адреса. Обычно зависит от страны.
	long   Flags;
	PPID   CountryID;
	PPID   CityID;
	PPID   StreetID;

	PPID   FiasTerminalID;
	PPID   FiasCityID;
	PPID   FiasStreetID;
	PPID   FiasHouseID;
private:
	struct AddrTok {
		enum {
			fDot  = 0x0001,
			fUsed = 0x0002
		};
		AddrTok();
		~AddrTok();
		AddrTok & Reset();

		enum {
			tFinish = 0,
			tDiv = 1,
			tText,
			tDescr,
			tZip,
			tNumber,
			tNum_Hyp_Num,
			tNum_Hyp_Num_Hyp_Num,
			tNum_Sl_Num,
			tNum_Al,
			tNum_Hyp_Al,
			tNum_Sl_Al
		};
		int    T;      // Токен
		uint   P;      // Начальная позиция в исходной строке
		long   Flags;  // @flags
		SString S;     // Текст
		LongArray Dl;  // Только для T == tDescr: список позиций (zero-based) в массиве AddrItemDescr Aidl[]
		TSCollection <AddrTok> * P_SplitL;
	};
	struct DescrSelector {
		DescrSelector();
		void   Init();
		int    T;
		int    Kt;
		SString Kind;
	};
	struct DetectBlock {
		DetectBlock & Init(int entityType, uint tokPos, const char * pOrgText, PPID fiasUpperID = 0);

		int    T;
		uint   P;
		PPID   FiasUpperID;
		SString OrgText;
		SString RecognizedText;
		LongArray FiasCandidList;
	};
	int    SLAPI Helper_Construct();
	int    SLAPI GetTok(AddrTok & rTok);
	int    SLAPI ProcessDescr(const AddrItemDescr & rDescr, DescrSelector & rSel);
	int    SLAPI DetectCityName(DetectBlock & rDb);
	int    SLAPI DetectStreetName(DetectBlock & rDb);
	int    SLAPI Recognize(const char * pText, TSCollection <AddrTok> & rTokList); // @debug
	int    SLAPI OutputTokList(const TSCollection <AddrTok> & rList, SString & rBuf); // @debug
	int    SLAPI GetFiasAddrObjKind(PPID adrObjID, SString & rKind);

	enum {
		stOwnFiasRef = 0x0001
	};
	long   State;
	long   ReZip;
	long   ReNum_Hyp_Num;
	long   ReNum_Hyp_Num_Hyp_Num;
	long   ReNum_Sl_Num;
	long   ReNumA_Hyp_Num;
	long   ReNumA_Sl_Num;
	SStrScan Scan;
	TSCollection <AddrTok> TokList;
	PPFiasReference * P_Fr; // @notowned unless State & stOwnFiasRef

	TSCollection <_MatchEntry> * P_AmbigMatchList;
	_MatchEntry * P_AmbigMatchEntry;
};
//
// @ModuleDecl(PPObjBnkAcct)
//
#if 0 // @v9.0.4 {

typedef TSArray <BankAccountTbl::Rec> BnkAcctArray;

class BankAccountCore : public BankAccountTbl {
public:
	SLAPI  BankAccountCore();
	int    SLAPI Search_(PPID id, BankAccountTbl::Rec * pRec = 0);
	int    SLAPI Enum_(PPID personID, PPID * pBankID, char * pAcct);
	int    SLAPI FetchList_(PPID personID, BnkAcctArray *);
	int    SLAPI UpdateList_(PPID personID, BnkAcctArray *, int use_ta);
	int    SLAPI RemoveList_(PPID personID, int use_ta);
};

class PPObjBnkAcct : public PPObject {
	//
	// В качестве дополнительного параметра методам PPObjBnkAcct
	// передается ID персоналии.
	//
public:
	static int SLAPI EditRecord(BankAccountTbl::Rec *, PPID psnKindID);
	static int SLAPI CheckDuplicateBnkAcct(const BankAccountTbl::Rec *, const BnkAcctArray *, long pos);

	SLAPI  PPObjBnkAcct(void * extraPtr = 0);
	SLAPI ~PPObjBnkAcct();
	int    SLAPI EditList(PPID personID, BnkAcctArray *);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI DeleteObj(PPID id);
	virtual int SLAPI Search(PPID id, void * b = 0);
	virtual int SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI Enum(PPID personID, PPID * pBankID, char * pAcct);
	int    SLAPI FetchList(PPID personID, BnkAcctArray *);
	int    SLAPI UpdateList(PPID personID, BnkAcctArray *, int use_ta);
private:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*personID*/);
public:
	TLP_MEMB(BankAccountTbl, P_Tbl); // BankAccountCore-->BankAccountTbl
	void * ExtraPtr;
};

#endif // 0 } @v9.0.4
//
// Структура прикладной информации о банке
//
// Директивные флаги инициализации некоторых полей BnkAcctData
//
#define BADIF_INITBNAME    0x0001 // Инициализировать имя банка
#define BADIF_INITBIC      0x0002 // Инициализировать БИК
#define BADIF_INITCACC     0x0004 // Инициализировать корр.счет
#define BADIF_INITCITY     0x0008 // Инициализировать город
#define BADIF_INITBEXTNAME 0x0010 // Инициализировать расширенное имя банка
#define BADIF_INITALLBR    (BADIF_INITBNAME|BADIF_INITBIC|BADIF_INITCACC|\
	BADIF_INITCITY|BADIF_INITBEXTNAME)

struct PPBank {
	PPID   ID;
	char   Name[128];     // @v6.3.14 [48]-->[128]
	char   BIC[24];
	char   CorrAcc[24];
	char   City[48];      // @v6.3.14 [30]-->[48]
	char   ExtName[128];
};

struct BnkAcctData {
	SLAPI  BnkAcctData(long initFlags = BADIF_INITALLBR);
	int    SLAPI Format(const char * pTitle, char * pBuf, size_t bufLen) const;

	long   InitFlags; // BADIF_XXX
	PPID   BnkAcctID;
	PPID   OwnerID;
	char   Acct[28];  // @v6.2.8 [24]-->[28]
	PPBank Bnk;
};
//
// @ModuleDecl(PPObjPersonRelType)
// Связи между персоналиями
//
// Тип связи между персоналиями
//
struct PPPersonRelType2 {  // @persistent @store(Reference2Tbl+)
	enum {
		cOneToOne = 1,
		cOneToMany,
		cManyToOne,
		cManyToMany
	};
	enum {
		ssUndef = 0,
		ssPrivateToPrivate,
		ssPrivateToLegal,
		ssLegalToPrivate,
		ssLegalToLegal
	};
	enum {
		fInhAddr  = 0x0001,
		fInhRAddr = 0x0002,
		fGrouping = 0x0004, // Группирующее отношение (только для Cardinality = cManyToOne)
		fInhMainOrgAgreement = 0x0008, // Наследует соглашение с клиентами из главной организации (только для филиалов)
		fInhAgreements       = 0x0010  // @v8.2.2 Наследует соглашение (хоть с клиентом, хоть с поставщиком) из родительской организации (PPPSNRELTYP_AFFIL)
	};
	long   Tag;            // Const=PPOBJ_PERSONRELTYPE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[56];   // @reserve
	int16  StatusRestriction; // Ограничение по статусу отношений (PPPersonRelType::ssXXX)
	int16  Cardinality;    // Ограничение по множественности отношений (PPPersonRelType::cXXX)
	long   Flags;          // Флаги (PPPersonRelType::fXXX)
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPPersonRelType);

struct PPPersonRelTypePacket {
	SLAPI  PPPersonRelTypePacket();
	void   SLAPI Init();
	PPPersonRelTypePacket & FASTCALL operator = (const PPPersonRelTypePacket &);
	PPPersonRelType Rec;
	PPIDArray InhRegTypeList;
};

class PPObjPersonRelType : public PPObjReference {
public:
	SLAPI  PPObjPersonRelType(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI PutPacket(PPID *, PPPersonRelTypePacket *, int use_ta);
	int    SLAPI GetPacket(PPID, PPPersonRelTypePacket *);
	int    SLAPI Fetch(PPID, PPPersonRelTypePacket *);
	//
	// Descr: Возвращает список типов отношений с признаком fGrouping
	// Return:
	//   >0 - найден по крайней мере один группирующий тип отношений
	//   <0 - не найдено ни одного группирующего типа
	//   0  - ошибка
	//
	int    SLAPI GetGroupingList(PPIDArray * pList);
	int    SLAPI SearchSymb(PPID *, const char * pSymb);
private:
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack * p, PPObjIDArray * ary, int replace, ObjTransmContext * pCtx);
	virtual void SLAPI Destroy(PPObjPack * pPack);
	virtual int  SLAPI ProcessReservedItem(TVRez &);
	int    SLAPI SerializePacket(int dir, PPPersonRelTypePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// @ModuleDecl(PPObjPerson)
// @todo DlvrAddrExtFldList перевести на StrAssocArray (понадобится конвертация хранящихся в Property данных)
//
struct PPPersonConfig { // @transient (для сохранения проецируется на PropertyTbl::Rec)
	PPPersonConfig();
	int    Init();

	struct NewClientDetectionItem {
		PPObjID Oi;
		long   Flags;
		uint8  Reserve[12];
	};

	enum {
		fSyncByName                = 0x0001, // Синхронизировать по имени
		fSyncBySrchReg             = 0x0002, // Синхронизировать по поисковому регистру
		fSyncDeclineUpdate         = 0x0004, // Не принимать изменения из других разделов
		fSyncMergeRegList          = 0x0008, // При синхронизации объединять регистры
		fValid                     = 0x1000, // Признак того, что запись является действительной (загруженной из базы данных)
		fShowPsnImageAfterCmdAssoc = 0x2000, // Показывать диалог с картинкой персоналии после ввода ассоциированной команды с рабочего стола (или из панели чеков)
		fSendAttachment            = 0x4000  // @v8.2.3 Передавать в другие разделы файлы, прикрепленные к персоналиям (обычно, изображения)
	};
	PPID   TradeLicRegTypeID;     // Тип регистрационного документа, используемого для торговой лицензии предприятия //
	PPID   RegStaffCalID;         // Регулярный штатный календарь
	long   Flags;
	long   SendSmsSamePersonTimeout; // @v8.0.6 Таймаут на отсылку SMS одной и той же персоналии (seconds).
	long   StaffCalQuant;         // Квант времени в сек. для временной диаграммы анализа штатных календарей.
	SString TopFolder;             // @anchor
	SString AddImageFolder;        // Папка из которой будут автоматически прикрепляться файлы к персоналиям. хранится в реестре
	TaggedStringArray DlvrAddrExtFldList; // Наименования дополнительных полей для адресов доставки
	TSArray <NewClientDetectionItem> NewClientDetectionList; // @v8.1.12
};

struct PersonReq {
	SLAPI  PersonReq();
	long   Flags;
	PPID   AddrID;       // @v7.6.2
	PPID   RAddrID;      // @v7.6.2
	char   Name[128];    //
	char   ExtName[128];
	char   Addr[128];    //
	char   RAddr[128];   //
	char   Phone1[64];   // Список телефонов через ';'
	char   TPID[32];     // @russia код ИНН
	char   KPP[12];      // @russia код КПП
	char   OKONF[32];    // @russia код ОКОНФ
	char   OKPO[32];     // @russia код ОКПО
	PPID   SrchRegTypeID; // Тип регистра для поиска. Если для персоналии не определено ни одного
		// поискового регистра, то SrchRegTypeID = 0 (даже если для какого-либо из видов, которому принадлежит
		// персоналии такой тип регистра определен).
	char   SrchCode[32];  // Номер поискового регистра (тип этого регистра прописан в виде персоналии).
		// Если персоналия относится к нескольким видам, то тип поискового регистра берется из первого
		// встреченного вида, которому принадлежит персоналия и для которого определен тип поискового регистра.
	BnkAcctData BnkAcct;
	char   Memo[128];
};
//
//
//
#define CIF_CASHIER    0x0001
#define CIF_MODIFIED   0x0002

struct CashierInfo {
	SLAPI  CashierInfo();
	int    FASTCALL IsEqual(const CashierInfo & rS) const;

	char   Password[20]; // Пароль кассира
	long   Rights;	     // Права  кассира
	long   Flags;		 // CIF_XXX
};

class PPPersonPacket : public PPPerson { // Managed by class PPObjPerson
public:
	SLAPI  PPPersonPacket();
	SLAPI ~PPPersonPacket();
	PPPersonPacket & FASTCALL operator = (const PPPersonPacket &);
	void   SLAPI destroy();
	int    SLAPI GetRegister(PPID regTyp, uint * pos) const;
	int    SLAPI GetRegNumber(PPID regTyp, SString & rBuf) const;
	int    SLAPI GetSrchRegNumber(PPID * pRegTypeID, SString & rBuf) const;
	int    SLAPI GetAddress(uint, SString & rBuf);
	int    SLAPI GetRAddress(uint, SString & rBuf);
	int    SLAPI GetPhones(uint maxCount, SString & rBuf);
	// @v9.0.4 int    SLAPI GetCurrBnkAcct(BankAccountTbl::Rec *) const; // @obsolete
	int    SLAPI GetCurrBnkAcct(PPBankAccount *) const;

	int    SLAPI SetExtName(const char * pName);
	int    SLAPI GetExtName(SString & rBuf) const;
	int    SLAPI AddRegister(PPID regTypeID, const char * pNumber, int checkUnique = 1);
	//
	// Descr: Возвращает информацию об адересе доставки из внутреннего списка по индексу *pPos
	//   и, в случае успеха, увеличивает значение индекса *pPos на единицу.
	//   !0 - адрес успешно присвоен по указателю pPack. Индекс по указателю pPos увеличен на 1.
	//    0 - позиция pos выходит за пределы [0..GetDlvrLocCount()]
	//
	int    SLAPI EnumDlvrLoc(uint * pPos, PPLocationPacket * pPack) const;
	//
	// Descr: Возвращает информацию об адересе доставки из внутреннего списка по индексу pos.
	// Returns:
	//   !0 - адрес успешно присвоен по указателю pPack
	//    0 - позиция pos выходит за пределы [0..GetDlvrLocCount()]
	//
	int    SLAPI GetDlvrLocByPos(uint pos, PPLocationPacket * pPack) const;
	uint   SLAPI GetDlvrLocCount() const;
	int    SLAPI AddDlvrLoc(const PPLocationPacket & rAddr);
	int    SLAPI PutDlvrLoc(uint pos, const PPLocationPacket * pAddr);
	int    SLAPI ClearDlvrLocList();      // @Muxa  @v7.3.7
	//
	// Descr: Замещает адрес доставки locID в пакете на адрес доставки с идентификатором replacementID.
	// Note: Фукнция проверяет идентификатор replacementID на существование и, кроме того, проверяет
	//   что бы соответствующая запись действительно была адресом (не складом и т.д.)
	// Returns:
	//   1 - адрес locID успешно замещен на replacementID
	//   2 - адрес replacementID был в пакете - просто удален адрес locID.
	//  -1 - адрес locID в пакете не найден
	//   0 - ошибка.
	//
	int    SLAPI ReplaceDlvrLoc(PPID locID, PPID replacementID);
	int    SLAPI SetSCard(const PPSCardPacket * pScPack, int autoCreate);
	const  PPSCardPacket * SLAPI GetSCard() const;

	RegisterArray    Regs;          // Список регистров
	PPLocationPacket Loc;           // Юридический адрес @v8.3.6 LocationTbl::Rec-->PPLocationPacket
	PPLocationPacket RLoc;          // Фактический адрес @v8.3.6 LocationTbl::Rec-->PPLocationPacket
	PPELinkArray     ELA;           // Список электронных адресов
	//BnkAcctArray     BAA;           // Список банковских счетов
	CashierInfo      CshrInfo;      // Специфическая информация о кассире (для загрузки в кассовые модули)
	ObjLinkFiles     LinkFiles;     // @transient
	ObjTagList       TagL;          // @transient
	StaffAmtList     Amounts;       // Список штатных сумм (только для работодателей)
	enum {
		ufDontChgImgFlag  = 0x0001, // Функция PPObjPerson::PutPacket не должна изменять флаг GF_HASIMAGES
		ufDontChgStaffAmt = 0x0002, // Функция PPObjPerson::PutPacket не должна изменять список штатных сумм
		ufDontRmvDlvrLoc  = 0x0004, // Функция PPObjPerson::PutPacket не должна удалять из БД адреса доставки, которых нет в пакете
		ufDontEditRelPsn  = 0x0008  // Не позволяет редактировать персоналию из диалога списка отношений персоналии, чтобы избежать рекурсии.
	};
	long   UpdFlags;                // @transient Флаги, определяющие правила изменения некоторых полей
	//
	// Descr: значение, идентифицирующее выбранный адрес в данном пакете.
	// Если SelectedLocPos > 0 && SelectedLocPos <= DlvrLocList.getCount(), то идентифицирует позицию (1..) в
	//   списке адресов доставки.
	// Если SelectedLocPos == -1, то - юридический адрес
	// Если SelectedLocPos == -2, то - реальный адрес
	// 0 - не определенное значение.
	//
	long   SelectedLocPos;          // @transient
private:
	SString ExtString;
	//SArray * P_DlvrLocList;         // Список адресов доставки
	TSCollection <PPLocationPacket> DlvrLocList;
	// @v9.4.0 SCardTbl::Rec  * P_SCard;       // @transient @v6.8.8 Используется при одновременном редактировании персоналии и карты
	PPSCardPacket * P_SCardPack; // @transient Используется при одновременном редактировании персоналии и карты
};
//
// Флаги дополнительных прав доступа персоналий
//
#define PSNRT_UNITE             0x0100 // Право на объединение персоналий
#define PSNRT_UPDIMAGE          0x0200 // Право на изменение присоединенной картинки
#define PSNRT_UNITEADDR         0x0400 // @v6.5.12 Право на объединение адресов доставки
#define PSNRT_MULTUPD           0x0800 // @v7.4.3  Право на массовое изменение или удаление
//
// Флаги функции PPObjPerson::GetPacket
//
#define PGETPCKF_USEINHERITENCE 0x0001 // При извлечении регистров использовать наследование
//
// Опции (параметр option) функции PPObjPerson::GetAddrID
//
#define PSNGETADDRO_DEFAULT   0 // Брать основной адрес персоналии
#define PSNGETADDRO_REALADDR  1 // Брать действительный адрес персоналии.
	// Если этот адрес для персоналии не определен, то брать основной адрес.
#define PSNGETADDRO_DLVRADDR  2 // Брать адрес доставки.
	// Если адрес доставки не определен, то работает как PSNGETADDRO_REALADDR.
//
// Флаги (параметр flags) функции PPObjPerson::Subst
//
#define PSNSUBSTF_LASTRELINHIERARH 0x00000001L

class PersonCache;
class PPObjArticle;

class PPObjPerson : public PPObject {
	//
	// В качестве дополнительного параметра методам PPObjPerson
	// передается вид персоналии.
	//
public:
	enum {
		sapfMatchWholeWord = 0x0001
	};
	struct SrchAnalogPattern {
		SrchAnalogPattern(const char * pNamePattern = 0, long flags = 0)
		{
			NamePattern = pNamePattern;
			Flags = flags;
		}
		SString NamePattern;
		long   Flags;             // Флаги (PPObjPerson::sapfXXX)
	};
	static int SLAPI ReadConfig(PPPersonConfig *);
	static int SLAPI WriteConfig(const PPPersonConfig *, int use_ta);
	static int SLAPI EditConfig();
	static int SLAPI ReplacePerson(PPID srcID = 0, PPID srcKindID = 0);
	static int SLAPI ReplaceDlvrAddr(PPID srcID);
	static int SLAPI TestSearchEmail();

	SLAPI  PPObjPerson(void * extraPtr = 0);
	SLAPI ~PPObjPerson();
	virtual int    SLAPI Browse(void * extraPtr);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI Search(PPID id, void * b = 0);
	int    SLAPI IsPacketEq(const PPPersonPacket & rS1, const PPPersonPacket & rS2, long flags);

	struct EditBlock {
		EditBlock();

		PPID   InitKindID;
		PPID   InitStatusID;
		int    ShortDialog;  // 0 - использовать обычный диалог, 1 - использовать сокращенный диалог,
			// другое - идентификатор диалога, который следует использовать.
		PPID   SCardSeriesID;
		SString Name;
		//
		PPID   RetSCardID;   // @out Ид дисконтной карты, созданной (выбранной) в сокращенном диалоге
		long   UpdFlags;     // -> PPPersonPacket::UpdFlags
	};
	int    SLAPI InitEditBlock(PPID kindID, EditBlock & rBlk);
	int    SLAPI Edit_(PPID * pID, EditBlock & rBlk);
	//
	// Descr: Извлекает частичную запись персоналии с идентификатором id из кэша.
	//   Поля инициализируемые в записи pRec: {ID, Name, MainLoc, RLoc, CatID, Flags}
	// Returns:
	//   >0 - Запись найдена. По указателю pRec присваивается запись с инициализированными
	//     полями, перечисленными в описании выше. Остальные поля инициализируются в 0.
	//   <0 - Запись с идентификатором id не найдена. Содержимое по указателю pRec
	//     имеет непредсказуемые значения.
	//   0  - Ошибка. Содержимое по указателю pRec имеет непредсказуемые значения.
	//
	int    SLAPI Fetch(PPID id, PersonTbl::Rec * pRec);
	int    SLAPI FetchConfig(PPPersonConfig * pCfg);
	int    SLAPI DirtyConfig();
	const PPPersonConfig & SLAPI GetConfig();
	int    SLAPI ExtEdit(PPID * pID, void * extraPtr);
	//
	// Descr: Извлекает из базы данных список персоналий, ссылающихся на адрес доставки dlvrLocID.
	// Returns:
	//   >0 - есть, по крайней мере, одна персоналия, ссылающаяся на адрес dlvrLocID как на адрес доставки
	//   <0 - нет ни одной персоналии, ссылающейся на адрес доставки dlvrLocID
	//   0  - ошибка
	//
	int    SLAPI GetPersonListByDlvrLoc(PPID dlvrLocID, PPIDArray * pList);
	int    SLAPI GetDlvrLocList(PPID personID, PPIDArray * pList);
	int    SLAPI EditDlvrLocList(PPID personID);
	int    SLAPI SetupDlvrLocCombo(TDialog *, uint ctlID, PPID personID, PPID locID);
	int    SLAPI AddRegisterToPacket(PPPersonPacket & rPack, PPID regTypeID, const char * pNumber, int checkUnique = 1);
	//
	// Descr: Вызывает диалог редактирования списка сумм, принадлежащих персоналии id,
	//   если эта персоналия относится к виду "Работодатели".
	// Returns:
	//   >0 - пользователь нажал OK в диалоге
	//   <0 - пользователь отказался от редактирования //
	//   0  - ошибка
	//
	int    SLAPI EditAmountList(PPID id);
	//
	// Descr: Редактирует список отношений персоналии id в обход общего диалога
	//   редактирования персоналии.
	// Returns:
	//   >0 - пользователь изменил список отношений и успешно провел его
	//   <0 - пользователь не менял список отношений
	//   0  - ошибка
	//
	int    SLAPI EditRelationList(PPID id);
	//
	// Descr: Вызывает диалог добавления отношения для персоналии id. Если relTypeID != 0
	//   то диалог инициализируется указанным видом отношения. Если успешно пользователь создал
	//   новое отношение, то информация об этом сохраняется в базе данных.
	// Returns:
	//   >0 - пользователь успешно сождал новое отношение и провел его
	//   <0 - пользователь отказался от создания нового отношения //
	//   0  - ошибка
	//
	int    SLAPI EditRelation(PPID * pPrmrID, PPID * pScndID, PPID * pRelTypeID);
	int    SLAPI AddRelationList(PPID * pPrmrID, PPIDArray * pScndList, PPID * pRelTypeID, int reverse);
	int    SLAPI RemoveRelation(PPID prmrID, PPID scndID, PPID relTypeID);
	int    SLAPI GetRelPersonList(PPID personID, PPID relTypeID, int reverse, PPIDArray * pList, int lastInHieararhy = 0, PPIDArray * pHierarhIDList = 0);
	int    SLAPI GetPacket(PPID, PPPersonPacket *, uint flags /* PGETPCKF_XXX */);
	int    SLAPI PutPacket(PPID * pID, PPPersonPacket *, int use_ta);
	int    SLAPI ValidatePacket(const PPPersonPacket * pPack, long flags);
	int    SLAPI GetBankData(PPID, PPBank *);
	//
	// Descr: Извлекает предпочтительный банковский счет для персоналии personID.
	//   Если pBnkAcctID != 0 && *pBnkAcctID != 0, то среди счетов персоналии
	//   ищется тот, который имеет заданный идентификатор. Если такой найден,
	//   то он и возвращается. В противном случае извлекается либо первый счет
	//   с признаком "предпочтительный" (BACCTF_PREFERRED) либо самый первый
	//   в списке.
	//   Если параметр bankID != 0 тогда ищется счет, банк которого точно равен
	//   bankID или же тот, который равен ненулевому значению *pBnkAcctID.
	// ARG(personID       IN): ИД персоналии, для которой ищется счет
	// ARG(pBnkAcctID IN/OUT): @#{vptr0} указатель, по которому присваивается ид
	//   найденного счета или 0, если ничего не найдено.
	//   Обратите внимание, что если не требуется проверка на принадлежность
	//   счета *pBnkAcctID персоналии personID, то значение по этому указатели
	//   при входе в функцию должно быть нулевым.
	// Returns:
	//   >0 - если для персоналии найден хотя бы один подходящий счет.
	//   <0 - у персоналии personID нет ни одного банковского счета.
	//    0 - ошибка
	//
	int    SLAPI GetSingleBnkAcct(PPID personID, PPID bankID, PPID * pBnkAcctID, /*BankAccountTbl::Rec*/PPBankAccount * pRec);
	int    SLAPI GetStaffAmtList(PPID id, StaffAmtList * pList);
	int    SLAPI PutStaffAmtList(PPID id, StaffAmtList * pList);
	int    SLAPI SearchFirstByName(const char * pName, const PPIDArray * pKindList, PPID exclID, PersonTbl::Rec * pRec);
	enum {
		smlRegisterOnly = 0x0001
	};
	int    SLAPI SearchMaxLike(const PPPersonPacket *, PPID * pID, long flags, PPID regTypeID/*= PPREGT_TPID*/);
	int    SLAPI SearchEmail(const char * pEmail, long flags, PPIDArray * pPsnList, PPIDArray * pLocList);
	int    SLAPI GetListByKind(PPID psnKindID, PPIDArray *, StrAssocArray * pNameList);
	//
	// Descr: Формирует список персоналий, чье имя подходит под правила образца pPattern.
	// Remark: Реализация опции sapfMatchWholeWord - отвратительна
	//
	int    SLAPI GetListByPattern(const SrchAnalogPattern * pPattern, PPIDArray * pList);
#if 0 // @construction {
	struct Idb {
		Idb();
		Idb(long flags, const char * pText);

		enum {
            fSrchReg    = 0x0001,
            fArSrchReg  = 0x0002,
            fName       = 0x0004,
            fSubName    = 0x0008,
            fSingleOnly = 0x0010
		};
		long   Flags;
		PPID   KindID;
		PPID   RegTypeID;
		PPID   AddendumRegTypeID;
		SString Text;
		SString Addendum;
	};
	int    SLAPI Identify(const Idb & rIdb, PPIDArray & rResultList);
#endif // } 0 @construction
	//
	// Descr: Выбирает список персоналий со значением регистра regTypeID pSerial:pNumber.
	//   Если kindID != 0, то из найденного списка вычленяет только те персоналии, которые
	//   относятся к виду kindID.
	// ARG(regTypeID IN): тип регистрационного документа, которому соответствуют заданные серия и номер
	// ARG(kindID    IN): вид, которому должны принадлежать найденные персоналии
	// ARG(pSerial   IN): @#vptr0 серия регистрационного документа. Если pSerial == 0 или pSerial[0] == 0,
	//   то просматриваются регистрационные документы независимо от серии
	// ARG(pNumber   IN): @#vptr0 номер регистрационного документа.
	// ARG(pIDList  OUT): @#vptr0 массив, в который заносятся идентификаторы найденных персоналий.
	//   Если до вызова функции массив был непустым, то это содержимое теряется.
	// Returns:
	//   >0 - найдена как минимум одна персоналия с заданными свойствами
	//   <0 - не найдено ни одной персоналии с заданными свойствами (инициализируется код ошибки)
	//   0  - ошибка
	//
	int    SLAPI GetListByRegNumber(PPID regTypeID, PPID kindID, const char * pSerial, const char * pNumber, PPIDArray & rIDList);
	//
	// Descr: То же, что и GetListByRegNumber(PPID, PPID, const char * pSerial, const char *, PPIDArray *),
	//   но с pSerial = 0
	//
	int    SLAPI GetListByRegNumber(PPID regTypeID, PPID kindID, const char * pNumber, PPIDArray & rIDList);
	int    SLAPI GetRegList(PPID, RegisterArray *, int useInheritence /* @v9.2.1 = 0*/);
	int    SLAPI GetRegister(PPID personID, PPID regType, RegisterTbl::Rec * pRec);
	int    SLAPI GetRegister(PPID personID, PPID regType, LDATE actualDate, RegisterTbl::Rec * pRec);
	int    SLAPI GetRegNumber(PPID personID, PPID regType, SString & rBuf);
	int    SLAPI GetRegNumber(PPID personID, PPID regType, LDATE actualDate, SString & rBuf);
	int    SLAPI GetStatus(PPID, PPID * pStatusID, int * pIsPrivate);
	int    SLAPI GetAddrID(PPID psnID, PPID dlvrAddrID, int option, PPID * pAddrID);
	//
	// Descr:
	//   if Person(id).Status == PPPRS_COUNTRY then
	//      *pCountryID = 0, pCountryName = Person(id).Name
	//      return 2
	//   else *pCountryID  = City(Location(Person(id).MainLoc).CityID).CountryID
	//      pCountryName = Country(City(Location(Person(id).MainLoc).CityID).CountryID).Name
	//      return 1
	//   in case of searching fault
	//      return -1
	//   otherwise
	//      return 0;
	//
	int    SLAPI GetCountry(PPID id, PPID * pCountryID, PPCountryBlock * pBlk);
	int    SLAPI GetCityByAddr(PPID addrID, PPID * pCityID, SString * pCityName, int useLocCityCache = 0);
	//
	// Descr: Так как юридические и физические адреса персоналий не имеют ссылки на
	//   персоналию-владельца, то эта функция находит персоналию, которая ссылается на адрес rLocRec.ID
	//   как на юридический или на физический, и заполняет поле OwnerID соответствующим идентификатором.
	// Note: Если rLocRec.OwnerID не равен 0 или rLocRec.ID == 0, то функция ничего не делает.
	// Returns:
	//   <0 - rLocRec.OwnerID != 0 || rLocRec.ID == 0 || не найдено ни одной персоналии, ссылающейся на rLocRec.ID
	//   1  - найдена единственная персоналия, ссылающаяся на rLocRec.ID как на юридический или физический адрес.
	//   2  - существует более одной персоналии, ссылающихся на rLocRec.ID как на юридический или физический адрес.
	//      В этом случае применяется первая найденная персоналия как владелец.
	//   0  - ошибка
	//
	int    SLAPI AdjustLocationOwner(LocationTbl::Rec & rLocRec);
	//
	// Descr: Извлекает адрес персоналии с идентификатором id.
	//   Если персоналия не найдена либо не имеет адреса, то rBuf = 0.
	//
	int    SLAPI GetAddress(PPID id, SString & rBuf);
	int    SLAPI GetExtName(PPID, SString & rBuf);
	int    SLAPI FormatRegister(PPID, PPID regTypeID, char * buf, size_t buflen);
	// @v9.0.4 int    SLAPI GetBnkAcctData(PPID bnkAcctID, BankAccountTbl::Rec *, BnkAcctData *); // @obsolete
	int    SLAPI GetBnkAcctData(PPID bnkAcctID, const PPBankAccount *, BnkAcctData *);
	int    SLAPI GetPersonReq(PPID, PersonReq *);
	int    SLAPI GetTradeLicList(PPID, RegisterArray *);
	int    SLAPI GetActualTradeLic(PPID, LDATE, RegisterTbl::Rec *);
	//
	// Функции для работы с адресной книгой.
	// Адресная книга - это таблица ассоцииаций {PPOBJ_USER, PPOBJ_PERSON},
	// хранящаяся в таблице ObjAssoc (PPASS_ADDRESSBOOK).
	// Таким образом, каждый пользователь системы имеет собственную адресную книгу.
	// В следующих функциях параметр userID идентифицирует пользователя. Если userID == -1,
	// то эти функции полагают userID == LConfig.User.
	//
	int    SLAPI AddToAddrBook(PPID personID, PPID userID, int use_ta);
	int    SLAPI RemoveFromAddrBook(PPID personID, PPID userID, int use_ta);
	int    SLAPI EnumAddrBookItems(PPID userID, PPID * pPersonID, ObjAssocTbl::Rec *);
	int    SLAPI GetAddrBookIDList(PPID userID, PPIDArray * pList);
	//
	// Descr: Создает запись персоналии по заданному имени и принадлежности к виду
	//
	int    SLAPI AddSimple(PPID *, const char * pName, PPID kindID, PPID statusID, int use_ta);
	//
	// Descr: Создает запись банка по параметрам, указанным в структуре pBnk.
	//
	int    SLAPI AddBankSimple(PPID *, const PPBank * pBnk, int use_ta);
	//
	// Descr: Импортирует данные о персоналиях из DBF-файла. Описание соответствия полей
	//   должно быть в файле BIN\import.ini.
	// ARG(specKind IN):
	//   0           - описание берется из зоны [person]
	//   PPPRK_SUPPL - описание берется из зоны [suppl]. При этом некоторые параметры импорта
	//     заимствуются из таблицы статей GetSupplAccSheet(), но имеют меньший приоритет, чем
	//     соответствующие значения в файле описания import.ini.
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	//
	int    SLAPI Import(int specKind, int use_ta);
	//
	// Descr: Новая унифицированная версия импорта персоналий
	//
	int    SLAPI Import();
	//
	// Функции подстановки
	//
	struct SubstParam {
		SLAPI  SubstParam();
		int    SLAPI Init(SubstGrpPerson sgp);
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
		enum {
			fSubstDlvrAddr    = 0x0001, // Подставлять адрес доставки
			fSubstPersonRAddr = 0x0002  // Подставлять фактический адрес
				// Priority: fSubstDlvrAddr, fSubstPersonRAddr
		};
		SubstGrpPerson Sgp;
		long   Flags;
		PPObjWorld WObj;
	};
	int    SLAPI Subst(PPID, PPID dlvrLocID, SubstParam *, long flags, PPID * pDestID);
	int    SLAPI GetSubstObjType(long id, const SubstParam * pParam, PPObjID * pObjId) const;
	int    SLAPI GetSubstText(PPID, PPID dlvrLocID, SubstParam *, SString & rBuf);
	//
	// Descr: Сравнивает записи и возвращает их похожесть в диапазоне [0..1]
	// pSwap = 1, значит что элемент 2 сравнивался с элементом 1, иначе элемент 1 с элементом 2
	//
	double SLAPI CalcLikeness(const PersonTbl::Rec * pRec1, const PersonTbl::Rec * pRec2, int * pSwap, long extra);
	int    SLAPI CheckDuplicateName(const char * pName, PPID * pID);
	int    SLAPI SelectAnalog(const char * pName, PPID * pID);
	//
	// Descr: Индексирует телефонные номера, связанные с персоналиями
	//
	int    SLAPI IndexPhones(int use_ta);
private:
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int    SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr);
	virtual int    SLAPI DeleteObj(PPID id);
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int    SLAPI EditRights(uint, ObjRights *, EmbedDialog * = 0);
	virtual void   SLAPI Destroy(PPObjPack*);
	virtual int    SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int    SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int    SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual const char * SLAPI GetNamePtr();
	virtual int    SLAPI MakeReserved(long flags);
	int    SLAPI ReplyPersonELinkDel(PPID);
	int    SLAPI ReplyPersonTagDel(PPID);
	int    SLAPI ReplyLocationReplace(PPID dest, PPID src);
	int    SLAPI UpdateAddress(PPID * pID, PPLocationPacket * pLocPack);
	int    SLAPI SerializePacket(int dir, PPPersonPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	ListBoxDef * SLAPI _Selector2(ListBoxDef * pDef, void * extraPtr);
	//
	// Descr: Находит дублирование регистров и вставляет
	//   в начало их серии код #number (number - число от 1 до MAXLONG)
	//
	int    SLAPI PreventDupRegister(PPID id, PPPersonPacket *); // @<<PPObjPerson::Write()
		// @<<PPObjPerson::Write
	int    SLAPI Helper_GetAddrID(const PersonTbl::Rec *, PPID psnID, PPID dlvrAddrID, int option, PPID * pAddrID);
	int    SLAPI Helper_PutSCard(PPID personID, PPPersonPacket * pPack, PPObjSCard * pScObj);

	PPObjArticle * P_ArObj;    //
	PPObjProcessor * P_PrcObj; // @v7.9.4 Скрытый 'кземпляр для быстрой обработки сообщений DBMSG_PERSONACQUIREKIND
	PPPersonConfig Cfg;        // Использовать только через PPObjPerson::GetConfig()
public:
	TLP_MEMB(PersonCore, P_Tbl);
	void * ExtraPtr;
	PPObjLocation LocObj;
	PPObjRegister RegObj;
	// @v9.0.4 PPObjBnkAcct  BaObj;
};
//
// Утилитные функции, проверяющие правильность кодов ОКПО, ИНН, корр счета банка и расчетного банковского счета.
//
int CheckOKPO(const char * pCode);
// @v8.7.4 (Замещено фунцией SCalcCheckDigit) int CheckINN(const char * pCode);
int CheckBnkAcc(const char * pCode, const char * pBic);
int CheckCorrAcc(const char * pCode, const char * pBic);
//
// @ModuleDecl(AsyncCashiersIterator)
//
struct AsyncCashierInfo {
	PPID  TabNum;
	char  Name[48];
	char  Password[24];
	char  Rights[32];
	int   IsWorked;
};

class AsyncCashiersIterator {
public:
	SLAPI  AsyncCashiersIterator();
	SLAPI ~AsyncCashiersIterator();
	int    SLAPI Init(PPID cashNodeID);
	int    SLAPI Next(AsyncCashierInfo *);
protected:
	PPObjPerson PsnObj;
	PPID   TabNumRegID;
	uint   ProsessUnworkedPos;
	PPIDArray   Iterated;
	PPIDArray   Unworked;
	LDATETIME   Since;
	BExtQuery * P_IterQuery;
};
//
// @ModuleDecl(PPObjStaffList)
// @todo Реализовать синхронизацию объекта между разделами
//
// @v9.0.3
//
struct PPStaffEntry {
	long   Tag;            // Const=PPOBJ_STAFFLIST
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       // Символьный код //
	uint8  Reserve[44];

	int16  VacancyCount;   // Общее количество ставок
	int16  VacancyBusy;    // Занятое количество вакансий
	long   FixedStaff;     // Зарезервированный ИД должности (PPFIXSTF_XXX)
	long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
	long   Rank;
	long   Flags;

	PPID   OrgID;          // ->Person.ID
	PPID   DivisionID;     // ->Location.ID
};
// } @construction

class PPStaffPacket  {
public:
	SLAPI  PPStaffPacket();
	void   SLAPI Init();
	PPStaffPacket & FASTCALL operator = (const PPStaffPacket &);

	// @v9.0.3 StaffListTbl::Rec Rec;
	PPStaffEntry Rec; // @v9.0.3
	StaffAmtList Amounts;
};

class PPPsnPostPacket {
public:
	SLAPI  PPPsnPostPacket();
	void   SLAPI Init();
	PPPsnPostPacket & FASTCALL operator = (const PPPsnPostPacket &);

	PersonPostTbl::Rec Rec;
	StaffAmtList Amounts;
};

class PersonPostArray : public TSArray <PersonPostTbl::Rec> {
public:
	SLAPI  PersonPostArray();
	void   SLAPI Sort();
	uint   SLAPI GetBusyCount() const;
};

class PPObjStaffList : public PPObjReference {
public:
	static int SLAPI SetupPostCombo(TDialog *, uint ctl, PPID id, uint /*olwFlags*/, PPID orgID, PPID divID, PPID staffID);
	//
	// Специфические флаги доступа (в дополнение к общим PPR_XXX)
	//
	enum {
		rtReadAmounts = 0x0100, // Просмотр сумм штатной должности либо назначения //
		rtModAmounts  = 0x0200  // Изменение сумм штатной должности либо назначения //
	};
	struct Filt {
		PPID   OrgID;
		PPID   DivID;
	};
	SLAPI  PPObjStaffList(void * extraPtr = 0);
	SLAPI ~PPObjStaffList();
	int    SLAPI GetPacket(PPID, PPStaffPacket *);
	int    SLAPI PutPacket(PPID *, PPStaffPacket *, int use_ta);
	//
	// Descr: Проверяет и, если необходимо, восстанавливает запись должности staffID.
	// Returns:
	//   1 - запись нормальная //
	//   2 - в записи была ошибка - восстановлена
	//   0 - ошибка проверки либо восстановления //
	//
	int    SLAPI Recover(PPID staffID, int use_ta);
	int    SLAPI SearchPost(PPID postID, PersonPostTbl::Rec *);
	int    SLAPI GetPostPacket(PPID postID, PPPsnPostPacket * pPack);
	int    SLAPI PutPostPacket(PPID * pPostID, PPPsnPostPacket * pPack, int use_ta);
	int    SLAPI MakeCodeString(const PersonPostTbl::Rec * pRec, SString & rBuf);
	int    SLAPI CreateFixedStaff(PPID *, PPID orgID, PPID divID, PPID fixID, int use_ta);
	int    SLAPI GetFixedStaffList(PPID orgID, PPID fixID, PPIDArray * pList);
	int    SLAPI GetFixedPostOnDate(PPID orgID, PPID fixID, LDATE dt, PersonPostTbl::Rec * pRec);
	int    SLAPI GetFixedPostList(PPID orgID, PPID fixID, PersonPostArray * pList);
	int    SLAPI AssignPersonToStaff(PPID personID, PPID staffID, LDATE dt, int useTa);
	//
	// Descr: Отзывает персоналию personID с должности staffID. Отзыв осуществляется //
	//   путем установки признака "Закрыт" и даты закрытия (dt) в записи должностного назначения //
	// Returns:
	//   >0 - персоналия успешно отозвана с должности
	//   <0 - персоналия не была назначена на долность staffID (нет открытого назначения)
	//   0  - ошибка
	//
	int    SLAPI RevokePersonPost(PPID personID, PPID staffID, LDATE dt, int use_ta);
	//
	// Descr: Отзывает персоналию personID со всех должностей организации orgID.
	//   Отзыв осуществляется установкой признака "Закрыт" и даты закрытия (dt) в записях
	//   найденных должностных назначений персоналии personID в организации orgID.
	// Returns:
	//   >0 - персоналия имела по крайней мере одно назначение в организации, которое (которые)
	//     было закрыто этой функцией.
	//   <0 - персоналия не имела ни одного назначения в организации orgID.
	//   0  - ошибка
	//
	int    SLAPI RevokeAllPersonPosts(PPID personID, PPID orgID, LDATE dt, int use_ta);
	//
	// Descr: Ищет назначение персоналии personID на должность staffID. Если closed == 0,
	//   то ищет действующее назначение (PersonPost::Closed == 0), в противном случае, если
	//   closed < 0, то ищет последнее закрытое назначение personID на staffID. Если closed > 0,
	//   то ищет закрытое назначение personID на staffID у которого значение Closed точно равно closed.
	// Returns:
	//   >0 - требуемое назначение найдено
	//   <0 - требуемое назначение не найдено
	//   0  - ошибка
	//
	int    SLAPI GetPersonPost(int closed, PPID staffID, PPID personID, PersonPostTbl::Rec * pRec);
	//
	// Descr: Извлекает список штатных должностей в соответствии с фильтром rFilt.
	//   Список функцией не очищается: те элементы, которые там были остаются не тронутыми.
	//   Должности добавляются в список методом addUnique.
	//   Если параметр pNameList не нулевой, то в него заносится список всех найденных
	//   должностей с соответствующими наименованиями.
	// Returns:
	//   >0 - найдена по меньшей мере одна должность.
	//   <0 - не нейдено ни одной должности, соответствующей фильтру rFilt
	//   0  - ошибка
	//
	int    SLAPI GetList(const Filt & rFilt, PPIDArray * pList, StrAssocArray * pNameList);
	//
	// Descr: Возвращает список назначений на должность staffID.
	//   Список заносится в массив pList. Функция проверяет размер элемента переданного
	//   массива на равенство записи PersonPostTbl::Rec.
	//   В список заносятся все назначения независимо от того, являются они открытыми или закрытыми.
	//   Список функцией не очищается: те элементы, которые там были остаются не тронутыми.
	// Returns:
	//   >0 - существует по крайней мере одно назначение на должность staffID
	//   <0 - не существует ни одного назначения на должность staffID
	//   0  - ошибка
	//
	int    SLAPI GetPostList(PPID staffID, PersonPostArray * pList);
	int    SLAPI GetPostByPersonList(PPID personID, PPID employerID, int openedOnly, PersonPostArray * pList);
	//
	// Descr: Формирует список наименований штатных назначений в соответствии с условием
	//   удовлетворения ограничениям {orgID, divID} или {staffID} (если задан staffID, то
	//   orgID и divID игнорируются.
	// ARG(orgID   IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатным должностям, привязанным к работодателю (PPObjPerson) orgID.
	// ARG(divID   IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатным должностям, привязанным к подразделению (PPObjLocation) divID.
	// ARG(staffID IN): Если этот параметр не нулевой, то формируемый список содержит назначения,
	//   соответствующие штатной должности (PPObjStaffList) staffID (orgID и divID в этом случае игнорируются).
	// ARG(pList  OUT): @#{vptr}
	// Returns:
	//   !0 - список (возможно пустой) сформирован
	//   0  - ошибка
	//
	int    SLAPI MakePostStrAssocList(PPID orgID, PPID divID, PPID staffID, StrAssocArray * pList);
	virtual int  SLAPI Browse(void * extraPtr /* (PPObjStaffList::Filt *) */);
	//
	// Descr: Редактирование объекта по идентификатору *pID.
	//   Если *pID != 0, то извлекает пакет элемента штатного расписания из базы данных
	//   и вызывает диалог редактирования для него.
	//   Если *pID == 0, то инициализирует новый пакет и вызывает диалог редактирования.
	//   При этом параметр extraParam интерпретируется как указатель на структуру PPObjStaffList::Filt.
	// ARG(pID    IN/OUT): Указатель на идентификатор элемента штатного расписания. Если *pID == 0
	//   и пользователь создал новый элемент, то по этому указателю присваивается идентификатор нового
	//   элемента.
	// ARG(extraParam IN): Используется только при *pID == 0. В этом случае значение параметра
	//   интерпретируется как указатель на структуру PPObjStaffList::Filt для инициализации нового
	//   пакета элемента штатного расписания.
	//
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID);
	// @v9.0.3 virtual int  SLAPI Search(PPID id, void * b = 0);
	// @v9.0.3 int    SLAPI SearchByName(const char * pName, PPID * pID, PPStaffEntry * pRec); // @unimplemented
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {ID, OrgID, DivisionID, Flags, Rank, FixedStaff, ChargeGrpID, Name}
	//
	int    SLAPI Fetch(PPID id, PPStaffEntry * pRec);
	//
	// Descr: осуществляет кэшированное извлечение записи штатного назначения по идентификатору id.
	//   Поля инициализируемые в записи pRec:
	//   {ID, StaffID, PersonID, ChargeGrpID, Flags, Closed}
	//
	int    SLAPI FetchPost(PPID id, PersonPostTbl::Rec * pRec);
	int    SLAPI EditDialog(PPStaffPacket *);

	enum {
		epdfFixedPost = 0x0001,
		epdfRecover   = 0x0002
	};
	int    SLAPI EditPostDialog(PPPsnPostPacket * pPack, long flags);
	int    SLAPI EditFixedStaffPost(PPID orgID);
	int    SLAPI EditAmounts(PPID staffID);
	int    SLAPI EditPostAmounts(PPID postID);
private:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint bufSize, ObjRights * rt, EmbedDialog * pDlg);
	virtual int  SLAPI Read(PPObjPack * p, PPID id, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack * p, PPID * pID, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket(int dir, PPStaffPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Извлекает список назначений персоналии personID на должность staffID.
	//   Все найденные назначения заносятся в массив pList. Массив предварительно очищается.
	//   Функция проверяет, чтобы размер записи pList был равен sizeof(PersonPostTbl::Rec).
	// Returns:
	//   >0 - найдена по крайней мере одна запись назначения personPost на staffID
	//   <0 - не найдено ни одной записи
	//   0  - ошибка.
	//
	int    SLAPI GetPersonPostList(PPID staffID, PPID personID, SArray * pList);
	int    SLAPI Dirty(PPID id);
	int    SLAPI DirtyPost(PPID id);
	int    SLAPI ReplyPersonReplace(PPID dest, PPID src);
	int    SLAPI IncrementStaffVacancy(PPID staffID, int decr, int use_ta);
public:
	// @v9.0.3 TLP_MEMB(StaffListTbl, P_Tbl);
	TLP_MEMB(PersonPostTbl, P_PostTbl);
	void * ExtraPtr;
	PPObjPerson PsnObj;
};
//
// @ModuleDecl(PPViewStaffList)
//
class StaffListFilt : public PPBaseFilt {
public:
	SLAPI  StaffListFilt();
	//
	// Descr: Если extraData != 0, то функция считает, что OrgID = GetMainEmployerID
	//   если extraData > 0, то DivID = extraData.
	//   Чтобы OrgID был равен GetMainEmployerID, а DivID == 0, необходимо установить extraData = -1
	//
	virtual int SLAPI Init(int fullyDestroy, long extraData);

	char   ReserveStart[32]; // @anchor
	PPID   OrgID;            // ->Person.ID
	PPID   DivID;            // ->Location.ID
	long   Flags;            // @flags
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct StaffListViewItem : public PPStaffEntry {
	double Salary;
	double RiseInWages1;
	double RiseInWages2;
	double RiseInWages3;
};

class PPViewStaffList : public PPView {
public:
	struct BrwEntry {
        PPID   ID;
		int16  VacancyCount;   // Общее количество ставок
		int16  VacancyBusy;    // Занятое количество вакансий
		long   FixedStaff;     // Зарезервированный ИД должности (PPFIXSTF_XXX)
		long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
		long   Rank;
		long   Flags;
		PPID   OrgID;
		PPID   DivisionID;
	};
	SLAPI  PPViewStaffList();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(StaffListViewItem *);
	int    FASTCALL CheckForFilt(const PPStaffEntry & rItem) const;
	PPID   SLAPI GetSalaryAmountType(int typeNo);
private:
	static void FASTCALL MakeListEntry(const PPStaffEntry & rSrc, PPViewStaffList::BrwEntry & rEntry);
	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	static int   GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI FetchData(PPID id);

	TSArray <BrwEntry> Data;

	StaffListFilt Filt;
	PPObjStaffList::Filt TempExtra;
	PPObjStaffList SlObj;
	PPID   SalaryAmountTypes[4];
};
//
// @ModuleDecl(PPViewPersonPost)
//
class StaffPostFilt : public PPBaseFilt {
public:
	SLAPI  StaffPostFilt();
	enum {
		fOpenedOnly = 0x0001, // Только "открытые" назначения //
		fClosedOnly = 0x0002  // Только "закрытые" назначения //
			// Если (Flags & fOpenedOnly) && (Flags & fClosedOnly), то - все
	};
	char   ReserveStart[32];
	PPID   OrgID;     // @anchor ->Person.ID Организация-работодатель
	PPID   DivID;     // ->Location.ID  Подразделение
	DateRange Period; // Период назначения на должность
	DateRange FnPeriod; // Период снятия с должности
	PPID   StaffID;   // ->StaffList.ID Штатная должность
	PPID   PersonID;  // ->Person.ID    Сотрудник
	long   Flags;     //
	int    InitOrder; // PPViewStaffPost::ordByXXX Порядок сортировки
	long   Reserve;   // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef PersonPostTbl::Rec StaffPostViewItem;

class PPViewStaffPost : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByPerson,
		ordByDate,
		ordByStaffPerson,
		ordByStaffDate
	};
	SLAPI  PPViewStaffPost();
	SLAPI ~PPViewStaffPost();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(StaffPostViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * SLAPI GetEditExtraParam();
	int    SLAPI CreateTempTable(int order);

	StaffPostFilt Filt;
	ObjIdListFilt StaffList; // Список должностей, соответствующий элементам фильтра Filt.OrgID, Filt.DivID
	PPObjStaffList SlObj;
	TempOrderTbl * P_TempTbl;
};
//
// @ModuleDecl(PPObjSalCharge)
// Начисления зарплаты
//
struct PPSalCharge2 {      // @persistent @store(Reference2Tbl+)
	enum {
		fGroup       = 0x0001, // Группа начислений (объединяет произвольный упорядоченный набор обыкновенных начислений)
		fWrOffSingle = 0x0002  // Начисления по всем контрагентам за один период списывать одним документом (суммы складываются)
	};
	PPID   Tag;            // Const=PPOBJ_SALCHARGE
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // Символ
	char   Reserve[48];    // @reserve @v6.3.3 [56]-->[48]
	PPID   EnumObjType;    // @v6.3.3 @#{0||PPOBJ_PERSONEVENT} Тип объекта для перечисления //
	PPID   EnumExtVal;     // @v6.3.3 Дополнительный параметр для перечисления по объектам EnumObjType
	PPID   AmtID;          // ->Ref(PPOBJ_AMOUNTTYPE) Тип учетной суммы для этого начисления //
	long   Flags;          //
	PPID   CalID;          // ->Ref(PPOBJ_STAFFCAL)   Календарь, используемый для этого начисления //
	PPID   WrOffOpID;      // ->Ref(PPOBJ_OPRKIND)    Вид операции списания //
};

DECL_REF_REC(PPSalCharge);

struct PPSalChargePacket {
	DECL_INVARIANT_C(); // @unimplemented
	SLAPI  PPSalChargePacket();
	int    SLAPI Init();
	PPSalCharge Rec;
	SString   Formula; // Формула расчета
	PPIDArray GrpList; // Список элементов группы
};

class PPObjSalCharge : public PPObjReference {
public:
	SLAPI  PPObjSalCharge(void * extraPtr = 0);
	//
	// Descr: Редактирует существующую либо новую запись.
	//   Если *pID == 0, то extraParam == -1000 означает, что необходимо
	//   создать и редактировать запись группы начислений, в противном случае - запись начисления.
	//
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI PutPacket(PPID * pID, PPSalChargePacket *, int use_ta);
	int    SLAPI GetPacket(PPID id, PPSalChargePacket *);
	//
	// Descr: осуществляет кэшированное извлечение пакета по идентификатору ID.
	//   В пакете инициализируются следующие поля: Rec {ID, Name, Symb, AmtID, CalID, Flags}, Formula
	//   !Список членов группы НЕ ИНИЦИАЛИЗИРУЕТСЯ //
	//
	int    SLAPI Fetch(PPID id, PPSalChargePacket *);
private:
	virtual int SLAPI Browse(void * extraPtr);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket(int dir, PPSalChargePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};
//
// @ModuleDecl(PPObjDateTimeRep)
//
struct PPDateTimeRep2 {    // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_DATETIMEREP
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	DateTimeRepeating Dtr; //
	long   Duration;       // Продолжительность (sec)
	long   Reserve2[2];    //
};

DECL_REF_REC(PPDateTimeRep);

class PPObjDateTimeRep : public PPObjReference {
public:
	SLAPI  PPObjDateTimeRep(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
};
//
// @ModuleDecl(PPObjDutySched)
//
struct PPDutyCountPoint {
	PPID   ObjID;
	LDATETIME Dtm;
};

struct PPDutySchedEntry {
	PPID   ObjID;
	PPID   DtrID; // Ид повторения. Если DtrID == 0,
		// то используется непосредсредственное значение Dtr.
	DateTimeRepeating Dtr;
	long   Duration; // Продолжительность (sec)
};

struct PPDutySched2 {      // @persistent @store(Reference2Tbl+)
	PPID   Tag;            // Const=PPOBJ_DUTYSHED
	PPID   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve1[60];   // @reserve
	long   Flags;          //
	PPID   ObjType;        //
	long   ObjGroup;       //
};

DECL_REF_REC(PPDutySched);

class PPDutySchedPacket {
public:
	struct EnumParam {
		uint   QueuePos; // @internal
		int    IsFirst;  // @internal Первая итерация //
		//
		PPID   ObjID;
		LDATETIME Dtm;
		long   Duration;
		STimeChunk Bounds; // Границы итераций.
	};
	SLAPI  PPDutySchedPacket();
	//
	// Descr: Сортирует список CpList, инициализирует CpFirst и CpLast.
	//   Функции InitIteration и NextIteration полагаются на то, что
	//   предварительно Normalyze была вызвана.
	//
	int    SLAPI Normalyze();
	int    SLAPI IsCountPoint(LDATETIME dtm) const;
	int    SLAPI AddCountPointDate(LDATE, uint * pPos);
	int    SLAPI RemoveCountPoint(uint pos);

	int    SLAPI WhoIsDuty(LDATETIME & rDtm, PPID * pObjID) const;
	//
	// @sample
	//   PPDutySchedPacket::EnumParam ep;
	//   for(ep.Init(); Enum(&ep) > 0; ep.Advance()) {
	//      // ep содержит информацию о текущей очереди
	//   }
	//
	int    SLAPI InitIteration(EnumParam * pEnum, const STimeChunk & rTmChunk) const;
	int    FASTCALL NextIteration(EnumParam * pEnum) const;

	int    SLAPI Test(const char * pOutFile) const;

	PPDutySched Rec;
	TSArray <PPDutySchedEntry> List;
	TSArray <PPDutyCountPoint> CpList;
private:
	int    SLAPI IsCountPoint(LDATETIME * pDtm) const;

	STimeChunk Cp;
};

class PPObjDutySched : public PPObjReference {
public:
	SLAPI  PPObjDutySched(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI SearchByObjType(PPID objType, long objGroup, PPID * pID);
	int    SLAPI PutPacket(PPID * pID, PPDutySchedPacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPDutySchedPacket * pPack);
};
//
// @ModuleDecl(PPObjStaffCal)
//
// Штатные календари могут быть связанными с каким-либо объектом данных либо не связанными.
// Связанные календари обязательно имеют родительский календарь (который, в свою очередь,
// не может быть связанным).
// Запись связанного календаря имеет пустые значения Name и Symb (они наследуют их от своего родителя).
//
// Принадлежность даты календарю какого-либо объекта определяется по следующей иерархии объектов:
// Персоналия (PPOBJ_PERSON) -
//    Штатное назначение (PPOBJ_PERSONPOST) -
//       Штатное расписание (PPOBJ_STAFFLIST) -
//          Главная организация (PPOBJ_PERSON) -
//             Заголовочные календари (0)
//
// Флаги записей штатных календарей (StaffCalendarTbl::Rec::Flags)
//
#define STCALEF_BYPEVENT    0x0001 // Запись сформирована персональной операцией
#define STCALEF_SKIP        0x0002 // Пропуск (выходной день).
#define STCALEF_BYDUTYSCHED 0x0004 // Запись сформирована графиком дежурств
#define STCALEF_CONTINUOUS  0x0008 // Начиная с этой записи календарь находится в состоянии "бесконечности".
	// То есть, все дни, следующие за датой этой записи включены в календарь.
	// Если установлен флаг STCALEF_SKIP, то и все дни, вслед за этой записью считаются пропущенными.
#define STCALEF_ALLFALGS    (STCALEF_BYPEVENT|STCALEF_SKIP|STCALEF_BYDUTYSCHED|STCALEF_CONTINUOUS)

struct PPStaffCal2 {       // @persistent @store(Reference2Tbl+)
	enum {
		fInherited       = 0x0001, // Календарь наследует элементы от родителя. То есть,
			// такой календарь не может содержать собственных элементов.
		fUseNominalPeriod = 0x0002, // При начислении зарплаты к календарю по умолчанию
			// применяется актуальный период начисления (не номинальный)
		fDayGap           = 0x0004  // @v7.7.12 Календарь допускает разрывы в течении дня (в один день может быть несколько записей) //
	};
	DECL_INVARIANT_C();

	PPID   Tag;            // Const=PPOBJ_STAFFCAL
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname Для порожденных календарей (LinkCalID != 0) - пусто
	char   Symb[20];       // Символ. Для порожденных календарей (LinkCalID != 0) - пусто
	long   Color;          // Цвет календаря (отображается в анализе штатных календарей)
	char   Reserve[44];    // @reserve
	PPID   PersonKind;     // Вид персоналий, с которыми связываются (устанавливается в родительском календаре)
	PPID   SubstCalID;     // Календарь, замещающий родительский. Используется в том случае,
		// если родительский календарь является смысловым, а StubCalID - фактическим.
		// Пример: регулярный календарь (смысловой) замещается графиком для женщин (фактический)
	PPID   LinkObjType;    // Тип связанного объекта
	long   Flags;          //
	PPID   LinkCalID;      // ИД родительского календаря //
	PPID   LinkObjID;      // ИД связанного объекта
};

DECL_REF_REC(PPStaffCal);
//
// Descr: Структура фильтра штатных календарей.
//
class StaffCalFilt : public PPBaseFilt {
public:
	enum {
		fInverseProj = 0x0001 // Если ProjCalID != 0, то приметь инверсивную проекцию
	};
	SLAPI  StaffCalFilt();

	char   ReserveStart[20];   // @anchor
	PPID   ProjCalID;          // Календарь, на который следует проецировать записи анализируемых календарей
	SubstGrpDate  Sgd;         // Подстановка даты
	PPID   LinkPersonKind;     // Вид связанной персоналии (по умолчанию - PPPRK_EMPL)
	DateRange Period;          // Период, за который показывать календари
	long   Flags;              // Флаги
	PPID   LinkObjType;        // Тип связанных объектов
	long   Order;              // Порядок сортировки
	ObjIdListFilt LinkObjList; // @anchor Список объектов, для которых показывать календари
	ObjIdListFilt CalList;     // Список календарей
};

typedef TSArray <StaffCalendarTbl::Rec> PPStaffCalendarArray;

class PPStaffCalPacket {
public:
	friend class PPObjStaffCal;

	//
	// Descr: Проверяет, и если требуется, исправляет некоторые поля элемента календаря pEntry.
	//   В основном эти проверки касаются полей TmVal, TmStart, TmEnd.
	// Returns:
	//   >0 - если функция изменила какие-либо параметры
	//   <0 - если функция не обнаружила каких-либо несоответствий, которые следует исправлять.
	//
	static int SLAPI SetupEntry(StaffCalendarTbl::Rec * pEntry);
	static int SLAPI InvariantEntry(const StaffCalendarTbl::Rec * pRec);

	SLAPI  PPStaffCalPacket();
	void   SLAPI Init(const StaffCalFilt *);
	PPStaffCalPacket & FASTCALL operator = (const PPStaffCalPacket &);
	int    SLAPI Get(LDATE dt, double * pHours, uint * pPos = 0) const;
	int    SLAPI GetTimeChunkList(const DateRange & rPeriod, STimeChunkArray * pList) const;
	const  PPStaffCalendarArray & GetList() const
	{
		return Items;
	}
	int    SLAPI AddItem(StaffCalendarTbl::Rec * pItem, uint * pPos);
	int    SLAPI RemoveItem(uint pos);

	PPStaffCal Rec;
	PPStaffCalendarArray Items;
private:
	int    SLAPI Helper_Get(LDATE dt, CALDATE * pCdt, uint * pPos) const;
	int    SLAPI SearchContinuousEntry(long dtVal, StaffCalendarTbl::Rec * pRec) const;
	int    SLAPI CheckContinuousEntry(const StaffCalendarTbl::Rec * pRec) const;
};
//
// Descr: Иерархия выборки календаря по штатному назначению.
//
struct ScObjAssoc {
	enum {
		scPerson = 0,
		scPost,
		scStaffList,
		scMainOrg,
		scHeader,
		scCount // Общее количество элементов
	};
	struct H {
		PPObjID Oi;
		PPID   CalID;
		PPID   ProjCalID;
	};
	H      List[scCount];
};
//
// Descr: Класс, управляющий штатными календарями.
//   В качестве дополнительного значения функциям этого класса может быть
//   передан указатель на StaffCalFilt. Функции копируют данные по этому указателю,
//   по этому, вызывающая функция может разрушать переданный указатель.
//
class PPObjStaffCal : public PPObjReference {
public:
	static int FASTCALL HasValidTimeRange(const StaffCalendarTbl::Rec & rRec);

	SLAPI  PPObjStaffCal(void * extraPtr = 0);
	SLAPI ~PPObjStaffCal();

	int    SLAPI CheckForFilt(const StaffCalFilt * pFilt, const PPStaffCal * pRec) const;
	int    SLAPI Fetch(PPID id, PPStaffCal *);
	//
	// Descr: Ищет дочерний по отношению к parentID календарь, принадлежащий объекту {linkObjType, linkObjID}.
	// ARG(parentID    IN): родительский календарь
	// ARG(linkObjType IN): связанный объект
	// ARG(pRec       OUT): @#{vptr0} указатель, по которому возвращается найденная запись.
	// Returns:
	//   >0 - календарь по заданным условиям найден
	//   <0 - календарь по заданным условиям не найден
	//    0 - ошибка
	//
	int    SLAPI SearchByObj(PPID parentID, PPObjID linkObj, PPStaffCal * pRec);
	//
	// Descr: Извлекает список календарей дочерних по отношению к calID.
	//   Идентификаторы найденных календарей заносятся в массив pList без дублирования.
	//   pList функцией не очищается.
	// Returns:
	//   >0 - найден по карйней мере один дочерний календарь
	//   <0 - не найдено ни одного дочернего календаря //
	//    0 - ошибка
	//
	int    SLAPI GetChildList(PPID calID, PPIDArray * pList);
	int    SLAPI SearchEntry(PPID calID, long dtVal, LTIME tmStart, StaffCalendarTbl::Rec * pRec);
	//
	// Descr: Ищет все записи календаря calID, соответствующие dtVal.
	// ARG(calID IN): Идент календаря //
	// ARG(dtVal IN): Значение даты (календарного дня) для которой ищутся записи
	// ARG(pList OUT): #{vptr0} Массив, в который заносятся найденные записи. Функция предварительно
	//   очищает содержимое списка pList.
	//   Если pList == 0, то функция все равно переберет все записи по критерию {calID, dtVal}, но, очевидно,
	//   не будет заносить их в список. Возвращаемое значение функции будет таким же, как если бы pList != 0.
	// Returns:
	//   >0 - найдена по крайней мере одна запись
	//   <0 - не найдено ни одной записи, соответствующей критерию
	//   0  - ошибка
	//
	int    SLAPI SearchEntriesByDtVal(PPID calID, long dtVal, TSArray <StaffCalendarTbl::Rec> & rList);
	int    SLAPI SearchContinuousEntry(PPID calID, long dtVal, StaffCalendarTbl::Rec * pRec);
	int    SLAPI CheckContinuousEntry(const StaffCalendarTbl::Rec * pRec);
	int    SLAPI SearchDate(PPID calID, LDATE dt, TSArray <StaffCalendarTbl::Rec> & rList);
	int    SLAPI SetEntry(StaffCalendarTbl::Rec & rEntry, int use_ta);
	//
	// Descr: Удаляет запись в календаре, по критериям {pEntry->CalID, pEntry->DtVal, pEntry->TmStart}
	//
	int    SLAPI RemoveEntry(const StaffCalendarTbl::Rec & rEntry, int use_ta);
	//
	// Descr: Удаляет все элементы всех календарей, связанные с персональной операцией psnEvID.
	//
	int    SLAPI RemoveEntriesByPsnEvent(PPID psnEvID, int use_ta);
	int    SLAPI SetEntriesByDutySched(PPID baseCalID, PPDutySchedPacket * pDsPack, const DateRange & rPeriod, int use_ta);
	//
	// Descr: Удаляет элементы календаря calID, сформированные по графику дежурств dutySchedID
	//   за период rPeriod.
	//
	int    SLAPI RemoveEntriesByDutySched(PPID calID, PPID dutySchedID, const DateRange & rPeriod, int use_ta);
	//
	// Descr: Вызывает диалог просмотра списка календарей.
	// ARG(extra IN): указатель на структуру StaffCalFilt или 0.
	//
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	int    SLAPI EditEntry(const PPStaffCalPacket * pPack, StaffCalendarTbl::Rec * pRec);
	int    SLAPI PutPacket(PPID * pID, PPStaffCalPacket * pPack, int useTa);
	int    SLAPI GetPacket(PPID id, PPStaffCalPacket * pPack);
	int    SLAPI CreateChild(PPID * pID, PPID parentID, PPObjID linkObj, int use_ta);
	//
	// Descr: Инициализирует структуру иерархии поиска календаря по записи штатного назначения.
	//
	int    SLAPI InitScObjAssoc(PPID calID, PPID prjCalID, const PersonPostTbl::Rec * pPostRec, ScObjAssoc * pAssc);
	//
	// Descr: Инициализирует структуру иерархии поиска календаря по идентификатору персоналии
	//
	int    SLAPI InitScObjAssoc(PPID calID, PPID prjCalID, PPID personID, ScObjAssoc * pAssc);
	//
	// Descr: Рассчитывает количество дней и часов по календарю и проекции, заданным в rAssc за
	//   период rPeriod.
	//   Если параметр inverse != 0 и в rAssc задан проекционный календарь, то
	//   вычисляется количество дней и часов, не попадающих в проекционный календарь.
	//
	int    SLAPI CalcPeriod(const ScObjAssoc & rAssc, const DateRange & rPeriod, int inverse,
		long * pDays, double * pHours, STimeChunkArray * = 0);
	int    SLAPI CalcPeriodByPersonEvent(const ScObjAssoc & rAssc, const PPIDArray & rEvList, int inverse,
		long * pDays, double * pHours, STimeChunkArray * pList = 0);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket(int dir, PPStaffCalPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI PutItems(PPID id, PPStaffCalPacket * pPack, int logAction);
	int    SLAPI Helper_CheckInEntry(LDATE dt, int proj_r, int inverse,
		const TSArray <StaffCalendarTbl::Rec> & rCalList, const TSArray <StaffCalendarTbl::Rec> & rProjCalList,
		STimeChunkArray * pList, long & rDays, double & rHour);

	StaffCalFilt CurrFilt;
public:
	TLP_MEMB(StaffCalendarTbl, P_ScT);
};
//
// @ModuleDecl(PPViewStaffCal)
//
struct StaffCalViewItem {
	PPID   CalID;
	LDATE  Dt;
	LTIME  TmStart;
	LTIME  TmEnd;
	long   Duration;
	long   Flags;
	PPObjID LinkObj;
	char   LinkObjName[64];
	char   DtText[32];
	long   Count;
};

class PPViewStaffCal : public PPView {
public:
	struct BrwHdr {
		PPID   ID__;
		PPID   CalID;
		PPID   ObjID;
		LDATETIME StartDtm;
		LTIME  TmEnd;
	};
	enum IterOrder {
		ordByDefault = 0,
		ordByDate,
		ordByObject
	};
	SLAPI  PPViewStaffCal();
	SLAPI ~PPViewStaffCal();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(StaffCalViewItem *);
	int    SLAPI GetTimeGridItemText(PPID taskID, SString & rBuf);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI Print(const void *);
	int    SLAPI CreateEntryByObj(PPID objType, PPID objID, StrAssocArray * pNameList, int refresh = 0);
	int    SLAPI AddItemToTimeGrid(const TempStaffCalTbl::Rec *, int rmv);
	int    SLAPI TimeChunkBrowser();
	int    SLAPI UpdateTimeBrowser(int destroy);
	int    SLAPI EditEntry(PPID calID, PPID objID, LDATETIME dtm, LTIME tmFinish);

	class StaffCalTimeChunkGrid : public STimeChunkGrid {
	public:
		SLAPI  StaffCalTimeChunkGrid();
		SLAPI ~StaffCalTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
		virtual int GetColor(long id, STimeChunkGrid::Color * pClr);
		//
		PPViewStaffCal * P_View; // @notowned
	};

	StaffCalTimeChunkGrid Grid;
	StaffCalFilt Filt;
	PPIDArray CalList;
	StrAssocArray ObjNameList;
	PPObjStaffCal Obj;
	PPObjStaffList SlObj;
	TempStaffCalTbl * P_TempTbl;
};
//
// @ModuleDecl(SalaryCore)
//
class SalaryCore : public SalaryTbl {
public:
	SLAPI  SalaryCore();
	int    SLAPI Validate(const SalaryTbl::Rec * pRec);
	int    SLAPI Search(PPID id, SalaryTbl::Rec * pRec);
	int    SLAPI Put(PPID * pID, SalaryTbl::Rec * pRec, int use_ta);
	int    SLAPI Get__(PPID postID, PPID salChargeID, const DateRange & rPeriod, SalaryTbl::Rec * pRec);
	//
	// Descr: Рассчитывает сумму начисления вида salChargeID по назначению postID за период rPeriod.
	//   Если параметр avg != 0, то рассчитывает среднее начисление за этот период (простое среднее по
	//   количеству начислений).
	//
	int    SLAPI Calc(PPID postID, PPID salChargeID, int avg, const DateRange & rPeriod, double * pAmount);
	int    SLAPI GetIntersection(PPID postID, PPID salChargeID, const DateRange & rPeriod, SalaryTbl::Rec * pRec);
	int    SLAPI GetObjectList(PPID objType, const DateRange & rPeriod, const UintHashTable * pIdList, PPIDArray * pList);
	int    SLAPI GetListByObject(PPID objType, PPID objID, const DateRange & rPeriod,
		const UintHashTable * pIdList, PPIDArray * pList, double * pAmount);
};
//
// @ModuleDecl(PPViewSalary)
//
class SalaryFilt : public PPBaseFilt {
public:
	enum {
		fCrosstab = 0x00000001
	};

	SLAPI  SalaryFilt();
	char   ReserveStart[32]; // @anchor
	DateRange Period;        // Период начисления //
	PPID   PostID;           // ->PersonPost.ID        Штатное назначение (может конфликтовать с PersonID)
	PPID   SalChargeID;      // ->Ref(PPOBJ_SALCHARGE) Вид штатного начисления //
	PPID   OrgID;            // ->Person.ID            Предприятие
	PPID   DivID;            // ->Location.ID
	PPID   StaffID;          // ->Ref(PPOBJ_STAFFLIST) Штатная должность
	PPID   PersonID;         // ->Person.ID            Персоналия (может конфликтовать с PostID)
	long   Flags;            // Флаги
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct SalaryViewItem : public SalaryTbl::Rec {
	PPID   StaffID;
	PPID   PersonID;
	PPID   OrgID;
	PPID   DivID;
};

class PPViewSalary : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByPostID  = 1
	};
	SLAPI  PPViewSalary();
	virtual SLAPI ~PPViewSalary();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(SalaryViewItem *);
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;
	int    SLAPI GetSalChargeName(PPID salChargeID, SString & rName);
	int    SLAPI Calc(PPID postID, PPID salChargeID, int avg, const DateRange & rPeriod, double * pAmount) {return Tbl.Calc(postID, salChargeID, avg, rPeriod, pAmount);}
	//
	// Descr: Пара функций, используемых для печати по структуре DL600 SalaryByPost
	//
	int    SLAPI InitPostDateList();
	int    SLAPI SetPostDateListItem(PPID postID, LDATE dt);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Print(const void *);
	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI MakeTempRec(int order, const SalaryTbl::Rec * pRec, TempSalaryTbl::Rec * pTempRec);
	int    SLAPI UpdateTempRec(PPID id);
	int    SLAPI TempRecToViewItem(TempSalaryTbl::Rec * pTempRec, SalaryViewItem * pItem);
	int    SLAPI EditItemDialog(SalaryTbl::Rec * pRec);
	int    SLAPI GetSalChargeGroupItems(PPID salChargeGrpID, PPIDArray * pItems) const;
	PPID   SLAPI GetEditId(PPID id, PPViewBrowser * pBrw);

	PPIDArray  SalChargeList;
	LAssocArray Post_Date_List;
	SalaryFilt Filt;
	SalaryCore Tbl;
	PPObjStaffList SlObj;
	TempSalaryTbl * P_TempTbl;
};
//
// @ModuleDecl(PPObjPersonEvent)
//
//
// Флаги дополнительных прав доступа персональных событий
//
#define PSNEVRT_SETFORCEPAIR   0x0100L // Право на изменение флага PSNEVF_FORCEPAIR
//
// Флаги персональных событий
//
#define PSNEVF_NOVERBS         0x0001L // Не проводить действия по событию
#define PSNEVF_HASIMAGES       0x0002L // Прикреплено изображение
#define PSNEVF_CLOSE           0x0004L // @v7.0.0 Признак закрывающего события. Устанавливается автоматически и
	// необходим для внутренних целей (правильная синхронизация).
#define PSNEVF_FORCEPAIR       0x0008L // @v8.0.3 Аварийный флаг, помечающий событие, фактически не имеющее пары, как имеющее таковую.

struct PPPsnEventPacket {
	SLAPI  PPPsnEventPacket();
	int    FASTCALL Init(PPID op);
	void   SLAPI Destroy();
	int    FASTCALL Copy(const PPPsnEventPacket &);
	PPPsnEventPacket & FASTCALL operator = (const PPPsnEventPacket &);

	PersonEventTbl::Rec Rec;
	RegisterTbl::Rec Reg;
	ObjTagList   TagL;
	ObjLinkFiles LinkFiles; // Связанные файлы
	//
	// Descr: Структура данных, формируемых во время проведения операции.
	//
	struct OnTurnBlock {
		OnTurnBlock();
		~OnTurnBlock();
		OnTurnBlock & Clear();

		PPID   SCardID;
		double SCardWrOffAmount;
		double SCardRest;
		PalmDisplayBlock * P_Pdb;
	};
	OnTurnBlock Otb; // @transient
};

class PersonEventCore : public PersonEventTbl {
public:
	SLAPI  PersonEventCore();
	int    SLAPI Search(PPID id, PersonEventTbl::Rec * pRec = 0);
	//
	// Descr: Блок, управляющий поиском парной или аналогичной операции PersonEventCore::SearchPair()
	//
	struct PairIdent {
		SLAPI  PairIdent();
		enum {
			fSignalNpError = 0x0001, // Сигнализировать о нарушении парности операции
				// Если ThisOpID встретилась раньше, чем PairOpID
			fSignalAnalog  = 0x0002, // Сигнализировать о том, что встречена аналогичная операция (возврат 2)
			fUseSCard      = 0x0004  // @v7.9.0 Ищет операцию в которой совпадает и PersonID и SCardID (даже нулевой)
		};
		PPID   PersonID;
		PPID   SCardID; // @v7.9.0
		LDATE  Dt;
		long   OprNo;
		PPID   ThisOpID;
		PPID   PairOpID;
		long   Flags;
	};
	int    SLAPI SearchPair(const PairIdent *, int forward, PersonEventTbl::Rec * pRec);
	int    SLAPI Add(PPID * pID, PersonEventTbl::Rec *, int use_ta);
	int    SLAPI Update(PPID id, PersonEventTbl::Rec *, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI CalcCountForPeriod(PPID opID, PPID personID, const STimeChunk & rTc, uint * pCount);
};
//
//
//
struct AddPersonEventFilt : public PPBaseFilt { // @persistent
	SLAPI  AddPersonEventFilt();
	AddPersonEventFilt & FASTCALL operator = (const AddPersonEventFilt & rSrc);
	//
	// Descr: Вызывает диалог редактирования фильтра.
	// Note: Так как для объекта AddPersonEventFilt не существует сопоставленного объекта PPView,
	//   то функцию редактирования включена сюда (обычно редактирование фильтра реализует метод PPView::EditBaseFilt).
	//
	int    SLAPI Edit();
	//
	// Если определена карта постредством PrmrSCardID или PrmrSCardCode, то владелец этой карты
	// имеет приоритет перед PrmrPsnID.
	// То же самое относится и ко вторичной персоналии, соответственно, ScndSCardID, ScndSCardCode, ScndPsnID.
	//
	char   ReserveStart[24];  // @anchor
	PPID   ReaderDvcID;       // Ид устройства считывания кода
	uint16 DvcReadCycle;      // Цикл опроса устройства ReaderDvcID (ms) default=1000 (1s)
	uint16 DvcReadPeriod;     // Общая продолжительность считывания (5s) 0 означает бесконечный процесс
	PPID   OpID;              // ИД вида операции (имеет приоритет перед OpCode)
	LDATE  Dt;
	PPID   PrmrPsnID;
	PPID   ScndPsnID;
	PPID   PrmrSCardID;       // ИД карты первичной персоналии (имеет приоритет перед PrmrSCardCode)
	PPID   ScndSCardID;       // ИД карты вторичной персоналии (имеет приоритет перед PrmrSCardCode)
	PPID   PrmrPsnRegTypeID;  // Тип регистра, используемый для идентификации первичной персоналии по коду
	PPID   ScndPsnRegTypeID;  // Тип регистра, используемый для идентификации вторичной персоналии по коду
	long   Flags;             // @flags
	int16  InteractiveLevel;  // Уровень интерактивности: 0 - полностью неинтерактивно, 1 - только показывать информацию, 2 - полностью интерактивно
	int16  Reserve;           //
	SString OpCode;           // @anchor Код вида операции (применяется, если OpID == 0)
	SString PrmrPsnCode;      // Код первичной персоналии (применяется, если PrmrPsnID == 0)
	SString ScndPsnCode;      // Код вторичной персоналии (применяется, если ScndPsnID == 0)
	SString PrmrSCardCode;    // Код карты первичной персоналии (применяется, если PrmrSCardID == 0)
	SString ScndSCardCode;    // Код карты вторичной персоналии (применяется, если ScndSCardID == 0)
private:
	virtual int SLAPI ReadText(const char * pText, long);
};

class PPObjPersonEvent : public PPObject {
public:
	static SString & SLAPI MakeCodeString(const PersonEventTbl::Rec * pRec, int options, SString & rBuf);

	SLAPI  PPObjPersonEvent(void * extraPtr = 0);
	SLAPI ~PPObjPersonEvent();
	virtual int  SLAPI Search(PPID, void * = 0);
	virtual int  SLAPI DeleteObj(PPID);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr /*prmrPersonID*/);
	virtual int  SLAPI EditRights(uint bufSize, ObjRights * rt, EmbedDialog * pDlg);
	SString & SLAPI MakeCodeString(const PersonEventTbl::Rec * pRec, SString & rBuf);
	int    SLAPI InitPacket(PPPsnEventPacket * pPack, PPID opID = 0, PPID prmrPersonID = 0);
	int    SLAPI InitPacket(PPPsnEventPacket * pPack, AddPersonEventFilt & rFilt, int interactive);
	int    SLAPI GetPacket(PPID, PPPsnEventPacket *);
	int    SLAPI PutPacket(PPID * pID, PPPsnEventPacket *, int use_ta);
	int    SLAPI Subst(SubstGrpPersonEvent sgpe, PPID opID, PPID prmrID, PPID scndID, PPID * pID);
	int    SLAPI GetSubstName(SubstGrpPersonEvent sgpe, PPID id, char * pBuf, size_t bufLen);
	//
	// Descr: Проверяет выполнение ограничений pConstr на персоналию personID и карту scardID
	//
	int    SLAPI CheckRestrictions(const PPPsnEventPacket * pPack, PPID personID, PPID scardID, const PPPsnOpKindPacket::PsnConstr * pConstr);
	//
	// Descr: Проверяет выполнение ограничений, заданных в види операции pPokPack, для персоналий,
	//   участвующих в операции, определенной пакетом pPack.
	//
	int    SLAPI CheckRestrictions(const PPPsnEventPacket * pPack, const PPPsnOpKindPacket * pPokPack);
	int    SLAPI SerializePacket(int dir, PPPsnEventPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	//
	// Descr: Высокоуровневая функция, обрабатывающая фильтры создания событий специального вида, содержащие
	//   идентификатор устройства ввода.
	//
	int    SLAPI ProcessDeviceInput(const AddPersonEventFilt & rFilt);
	int    SLAPI SearchPairEvent(PPID evID, int dirArg, PersonEventTbl::Rec * pRec, PersonEventTbl::Rec * pPairRec);
	int    SLAPI SetForcePairFlag(PPID evID, int set, int use_ta);

	PPObjRegister  RegObj;
	PPObjPerson    PsnObj;
	PPObjStaffList StLObj;

	class ProcessDeviceInputBlock {
	public:
		friend class PPObjPersonEvent;

		SLAPI  ProcessDeviceInputBlock();
		const  SString & SLAPI GetDeviceText() const;
		const  SString & SLAPI GetInfoText() const;
	private:
		enum {
			stInitialized = 0x0001,
			stError       = 0x0002
		};
		long   State;
		AddPersonEventFilt Filt;
		PPPsnOpKindPacket PokPack;
		PPAbstractDevice Ad;
		StrAssocArray Out;
		SString TempBuf; // @allocreuse

		SString DeviceText;
		SString InfoText;
	};

	int    SLAPI InitProcessDeviceInput(ProcessDeviceInputBlock & rBlk, const AddPersonEventFilt & rFilt);
	int    SLAPI FinalizeProcessDeviceInput(ProcessDeviceInputBlock & rBlk);
	int    SLAPI Helper_ProcessDeviceInput(ProcessDeviceInputBlock & rBlk);
private:
	virtual int SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual const char * SLAPI GetNamePtr();
	int    SLAPI TurnClause(PPPsnEventPacket * pPack, const PPPsnOpKind * pPok, const PoClause_ * pClause, int action, int use_ta);
	int    SLAPI TC_SetCalendar(PPID psnID, const PPPsnOpKind * pPok, PPPsnEventPacket * pPack, const PoClause_ * pClause);
	int    SLAPI GetFrwdList(PPID psnID, int isPrmr, LDATE dt, long oprno, SArray *);
	int    SLAPI GetFrwdList(PPID psnID, LDATE dt, long oprno, SArray *);
	int    SLAPI Helper_PutPacket(PPID evID, int action, PPPsnEventPacket *, PPPsnOpKindPacket *);

	void * ExtraPtr;
	SString NameBuf;
	PPObjStaffCal StcObj;
	PPObjSCard * P_ScObj;
public:
	TLP_MEMB(PersonEventCore, P_Tbl);
};
//
// @ModuleDecl(PPViewPersonEvent)
//
class AverageEventTimePrcssr {
public:
	struct Item {
		long   GetAverage() const;
		long   ID1;
		long   ID2;

		LDATETIME FirstEv;
		LDATETIME LastEv;
		long Count;
	};
	SLAPI  AverageEventTimePrcssr();
	int    SLAPI Add(long id1, long id2, LDATE dt, LTIME tm);
	int    SLAPI Enum(uint * pPos, Item ** pItem);
private:
	TSArray <Item> List;
};

struct PersonEventFilt : public PPBaseFilt {
	SLAPI  PersonEventFilt();

	enum {
		fWithoutPair = 0x0001
	};
	char   ReserveStart[28];  // @anchor
	long   Flags;             // @v7.9.12
	DateRange Period;         // Период обзора
	TimeRange TmPeriod;       // Период по времени
	int16  DayOfWeek;         // День недели
	int16  Reserve;
	PPID   PrmrID;            // Первичная персоналия //
	PPID   ScndID;            // Вторичная персоналия //
	SubstGrpPersonEvent Sgpe; // Параметр подстановки
	SubstGrpDate        Sgd;  // Параметр подстановки даты
	ObjIdListFilt PsnOpList;  // @anchor Список видов операций
};

struct PersonEventViewItem : public PersonEventTbl::Rec {
	void   Clear();
	SString GrpText1;
	SString GrpText2;
	SString AvgEvTime;
	long   GrpCount;
};

class PPViewPersonEvent : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
		long   Flags;
		LDATETIME Dtm;
	};
	SLAPI  PPViewPersonEvent();
	SLAPI ~PPViewPersonEvent();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PersonEventViewItem *);
	//
	int    SLAPI CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int    SLAPI Transmit(PPID /*id*/);
	int    SLAPI ChangeFlags(long action);

	PersonEventFilt  Filt;
	PPObjPersonEvent PsnEvObj;
	PPObjPsnOpKind   PokObj;
	TempPersonEventTbl * P_TempGrpTbl;
	PersonEventTbl * P_TempTbl;
};
//
// @ModuleDecl(PrcssrSalary)
//
class PPViewBill;
class PPViewPersonEvent;

class PrcssrSalary {
public:
	struct Param {
		enum {
			fSilent  = 0x0001, // Не выводить сообщения в журнал
			fVerbose = 0x0002  // Выводить максимально подробные сообщения в журнал
		};
		DateRange NominalPeriod;
		DateRange ActualPeriod;
		PPID   OrgID;
		PPID   DivID;
		PPID   StaffID;
		PPID   PostID;
		long   Flags;
	};
	//
	// Descr: Функции, использвемые в формулах (PPCalcExpression)
	//
	enum {
		funcCalDay        = EXRP_EVAL_FIRST_FUNC +  1, // cday(CalendarName[, ProjCalendarName[, period]])
		funcCalHour       = EXRP_EVAL_FIRST_FUNC +  2, // chour(CalendarName[, ProjCalendarName[, period]])
		funcCharge        = EXRP_EVAL_FIRST_FUNC +  3, // charge(SalChargeSymb[, Period])
		funcAvgCharge     = EXRP_EVAL_FIRST_FUNC +  4, // avgcharge(SalChargeSymb, Period)
		funcBill          = EXRP_EVAL_FIRST_FUNC +  5, // bill(OpID, Kind[, Period])
		funcPaym          = EXRP_EVAL_FIRST_FUNC +  6, // paym(OpID, Kind[, Period])
		funcEvCalDay      = EXRP_EVAL_FIRST_FUNC +  7, // evcday(EvKindSymb[, ProjCalendarName[, period]])
		funcEvCalHour     = EXRP_EVAL_FIRST_FUNC +  8, // evchour(EvKindSymb[, ProjCalendarName[, period]])
		funcEvCount       = EXRP_EVAL_FIRST_FUNC +  9, // evcount(EvKindSymb[, period])
		funcThisEvCalDay  = EXRP_EVAL_FIRST_FUNC + 10, // ThisEvCDay([ProjCalendarName])
		funcThisEvCalHour = EXRP_EVAL_FIRST_FUNC + 11, // ThisEvCHour([ProjCalendarName])
		funcLastMonth     = EXRP_EVAL_FIRST_FUNC + 12, // LastMonth([date])
		funcLastQuart     = EXRP_EVAL_FIRST_FUNC + 13, // LastQuart([date])
		funcLastYear      = EXRP_EVAL_FIRST_FUNC + 14, // LastYear([date])
		funcThisMonth     = EXRP_EVAL_FIRST_FUNC + 15, // ThisMonth([date])
		funcThisQuart     = EXRP_EVAL_FIRST_FUNC + 16, // ThisQuart([date])
		funcThisYear      = EXRP_EVAL_FIRST_FUNC + 17, // ThisYear([date])
		funcNextMonth     = EXRP_EVAL_FIRST_FUNC + 18, // NextMonth([date])
		funcNextQuart     = EXRP_EVAL_FIRST_FUNC + 19, // NextQuart([date])
		funcNextYear      = EXRP_EVAL_FIRST_FUNC + 20, // NextYear([date])
		funcDiffDays      = EXRP_EVAL_FIRST_FUNC + 21, // diffd(date[, date])
		funcDiffMonths    = EXRP_EVAL_FIRST_FUNC + 22, // diffm(date[, date])
		funcDiffYears     = EXRP_EVAL_FIRST_FUNC + 23, // diffy(date[, date])
	};
	struct CalcPeriodParam {
		PPID   PostID;
		SString CalSymb;
		SString ProjCalSymb;
		DateRange Period;
	};
	SLAPI  PrcssrSalary();
	SLAPI ~PrcssrSalary();
	int    SLAPI InitParam(Param *);
	int    SLAPI EditParam(Param *);
	int    SLAPI Init(const Param *);
	int    SLAPI Run();
	//
	int    SLAPI CalcPeriod(const CalcPeriodParam & rCpP, long * pDays, double * pHours);
	int    SLAPI TestCalcPeriod(PPID postID);
	int    SLAPI ProcessPost(PPID postID, UintHashTable * pIdList, int use_ta);
	int    SLAPI Expr_ResolveSymb(const char * pSymb, double * pVal);
	int    SLAPI IsFunc(const char * pSymb, int * pFuncId);
	int    SLAPI Expr_ResolveFunc(int funcId, uint argCount, double * pArgList, double * pResult);
private:
	struct FuncDescr {
		SLAPI  FuncDescr();
		int    FASTCALL IsEqHdr(const FuncDescr & rS) const;

		enum {
			fLink = 0x0001
		};
		int    Id;
		int    FuncId;
		PPID   AmtID;
		long   Flags;
	};

	int    SLAPI WriteOff(const UintHashTable * pIdList, int undoOnly, int use_ta);
	double SLAPI StorePeriod(const DateRange & rPeriod);
	int    SLAPI GetArgPeriod(double arg, DateRange & rPeriod);
	int    SLAPI Helper_CalcPayment(PPID opID, const DateRange & rPeriod, int kind,
		const PPIDArray & rArList, const PPIDArray * pExtBillList, const FuncDescr & rFc, double * pResult);
	int    SLAPI Helper_CalcShipment(PPID opID, const DateRange & rPeriod, int kind,
		const PPIDArray & rArList, const FuncDescr & rFc, double * pResult);
	int    SLAPI ParseFunc(const char * pText);
	int    SLAPI ParseAmtType(const char * pText, FuncDescr & rDescr);
	int    SLAPI GetFunc(int id, FuncDescr * pDescr) const;
	int    SLAPI Helper_GetPeriod(double arg, const DateRange & rInitPeriod, DateRange & rPeriod);

	Param P;
	StrAssocArray AmtTypeList;
	StrAssocArray CalList;
	SalaryCore Tbl;
	PPObjSalCharge ScObj;
	PPObjStaffCal  CalObj;
	PPObjStaffList SlObj;
	PPObjTag       TagObj;
	PPObjPersonEvent EvObj;
	PPViewBill * P_BillView;
	PPViewPersonEvent * P_EvView;
	StrAssocArray TagSymbList;
	StrAssocArray ScSymbList;     // Список символов видов начисления //
	StrAssocArray EvSymbList;     // Список символов видов персональных операций //
	PPPsnPostPacket CurPostPack;  // Пакет штатного назначения, обрабатываемого на текущей итерации
	PPStaffPacket   CurStaffPack; // Пакет штатной должности назначения, обрабатываемого на текущей итерации
	StaffAmtList    CurEmployerAmtList; // Список штатных сумм, соответствующих работодателю из CurPostPack
	PersonEventTbl::Rec * P_CurEv; // @notowned Если начисление осуществляется по персональным событиям, то
		// P_CurEv указатель на текущее событие, по которому ведется расчет. В противном случае - 0.
	PPLogger Logger;
	TSArray <FuncDescr> FuncList;
	TSRingStack <DateRange> PeriodStack;
	int    LastFuncId;
};
//
// @ModuleDecl(PPViewPerson)
//
// Фильтр по персоналиям
//
// EmptyAttrib
#define EA_ALL          0 // Все
#define EA_NOEMPTY      1 // С непустым атрибутом
#define EA_EMPTY        2 // С пустым атрибутом

#define TAGOFFSET 100000L

struct PersonFilt : public PPBaseFilt {
	enum {
		fExtEdit        = 0x0002, // @unused Отдельный диалог редактирования главной организации
		fVatFree        = 0x0004, // Свободен от НДС
		fTagsCrsstab    = 0x0008, // Показывать броузер персоналий, как кросстаб с тегами
		fHasImages      = 0x0010, // @v7.3.x Только с картинками
		fShowNewCli     = 0x0020, // @v8.3.0 Идентифицировать новых клиентов (требуется NewCliPeriod)
		fPrecName       = 0x0040, // @v8.3.5 SrchStr содержит точное имя персоналии (не чувствительно к регистру)
		fShowHangedAddr = 0x0080, // @v8.3.12 При использовании атрибута PPPSNATTR_ALLADDR отображать адреса, не
			// привязанные ни к одной из персоналий (но не являющиеся автономными)
		fLocTagF        = 0x0100, // @v8.6.2 Субфильтр P_TagF применяется к локациям, а не к персоналиям
		fShowFiasRcgn   = 0x0200, // @v8.6.12 Показывать результаты распознавания адресов и сопоставления с ФИАС
		fNewClientsOnly = 0x0400  // @v9.4.5 Только новые клиенты (действует при не пустом NewCliPeriod)
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке SrchStr_
	//
	enum { // @persistent
		extssNameText  = 1,
		extssEmailText = 2,
		extssPhoneText = 3
	};

	SLAPI  PersonFilt();
	int    SLAPI Setup();
	//
	// IsEmpty calls PersonFilt::Setup, than this is not const
	//
	virtual int SLAPI IsEmpty() const;
	PersonFilt & FASTCALL operator = (const PersonFilt &);
	int    SLAPI IsLocAttr() const
	{
		return oneof5(AttribType, PPPSNATTR_ALLADDR, PPPSNATTR_DLVRADDR, PPPSNATTR_HANGEDADDR, PPPSNATTR_DUPDLVRADDR, PPPSNATTR_STANDALONEADDR);
	}
	int    SLAPI GetExtssData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtssData(int fldID, const char * pBuf);

	uint8  ReserveStart[24];  // @anchor
	DateRange NewCliPeriod;   // @v8.3.0 Период иднетификации нового клиента
	PPID   Kind;              //
	PPID   Category;          //
	PPID   Status;            //
	PPID   CityID;            //
	int    AttribType;        //
	int    EmptyAttrib;       // EA_XXX
	PPID   RegTypeID;         //
	PPID   StaffOrgID;        //
	PPID   StaffDivID;        //
	PPID   PersonID;          // Отображает в броузере только данную персоналию
	long   Flags;             //
	RegisterFilt * P_RegF;    // @anchor для отмера "плоского" участка фильтра
	TagFilt * P_TagF;         //
	SysJournalFilt * P_SjF;   // @v8.0.1
	ObjIdListFilt List;       // @v8.0.1 Список идентификаторов персоналий, которые следует показать
	SString SrchStr_;         //
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};

typedef TempPersonTbl::Rec PsnAttrViewItem;

struct PersonViewItem : public PersonTbl::Rec {
	PsnAttrViewItem AttrItem;
};

class PPViewPerson : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	SLAPI  PPViewPerson();
	SLAPI ~PPViewPerson();
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt *);
	virtual int   SLAPI ViewTotal();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PersonViewItem *);
	int    SLAPI AddItem(PPID * pID);
	int    SLAPI EditItem(PPID);
	int    SLAPI DeleteItem(PPID);
	int	   SLAPI OpenClientDir(PPID PersonId);
	int    SLAPI EditRegs(PPID id, int oneReg);
	int    SLAPI EditDlvrAddrExtFlds(PPID id);
	int    SLAPI ViewRelations(PPID);
	int    SLAPI AddRelation(PPID);
	int    SLAPI ViewTasks(PPID);
	int    SLAPI ViewPersonEvents(PPID);
	int    SLAPI Export();
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    SLAPI Transmit(PPID id, int transmitKind);
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;
	int    SLAPI GetSmsLists(StrAssocArray & rPsnList, StrAssocArray & rPhoneList, uint what = 0); // @vmiller
	int    SLAPI CreateAuthFile(PPID psnId);

	int    FASTCALL IsNewCliPerson(PPID id) const;
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI Print(const void *);
	int    SLAPI InitPersonAttribIteration();
	int    SLAPI InitPersonIteration();
	int    SLAPI IsTempTblNeeded(); // non-const because calls PsnObj.GetConfig
	int    FASTCALL CheckForFilt(const PersonTbl::Rec * pRec);
	int    SLAPI CreateTempRec(PersonTbl::Rec * pPsnRec, PPID tabID, PsnAttrViewItem * pItem);
	int    SLAPI AddTempRec(PPID personID, UintHashTable * pUsedLocList, int use_ta);
	int    SLAPI EditTempRec(PPID, int use_ta);
	int    SLAPI CreateLikenessTable();
	int    SLAPI CreateAddrRec(PPID addrID, const LocationTbl::Rec * pLocRec, const char * pAddrKindText, PsnAttrViewItem * pItem);
	int    SLAPI UpdateHungedAddr(PPID addrID);
	int    SLAPI RemoveHangedAddr();
	int    SLAPI Recover();
	int    SLAPI Helper_InsertTempRec(TempPersonTbl::Rec & rRec);
	//
	// Рассылка сообщений по email
	//
	int    SLAPI SendMail(PPID mailAccId, StrAssocArray * pMailList, PPLogger * pLogger);
	int    SLAPI ExportUhtt();

	PPID   DefaultTagID;
	UintHashTable NewCliList;
	TempPersonTbl * P_TempPsn;
	PersonFilt  Filt;
	PPObjPerson PsnObj;
	PPObjStaffList StLObj;
	PPObjTag   ObjTag;
	PPObjWorld WObj;
	PPFiasReference * P_Fr;
};

int SLAPI ViewPersonInfoBySCard(const char * pCode);

class PPNewContragentDetectionBlock {
public:
	SLAPI  PPNewContragentDetectionBlock();
	SLAPI ~PPNewContragentDetectionBlock();
	int    SLAPI IsNewPerson(PPID psnID, const DateRange & rPeriod);
	int    SLAPI IsNewArticle(PPID arID, const DateRange & rPeriod);
private:
	int    SLAPI InitProcess();

	enum {
		stPrcInited = 0x0001,
		stEmpty     = 0x0002  // Не определено ни одного эффективного условия для идентификации
	};
	long   State;
	PPIDArray OpList;
	PPIDArray AcsList;
	PPIDArray PsnOpList;
	PPIDArray ScOpList;

	PPPersonConfig PsnCfg;
	PPObjPersonEvent * P_PeObj;
	PPObjArticle * P_ArObj;
	PPObjSCard * P_ScObj;
};
//
// @ModuleDecl(PPObjArticle)
//
class ArticleFilt : public PPBaseFilt {
public:
	SLAPI  ArticleFilt();
	ArticleFilt & FASTCALL operator = (const ArticleFilt &);

	enum {
		fShowAgreement   = 0x0001,
		fCheckObj        = 0x0002, // Проверять корректность объектов. Если установлен, то
			// в таблице добавляется колонка с сообщением о проблеме (если есть).
		fShowAddedLimit  = 0x0004, // @v8.2.4 Показывать дополнительный кредитный лимит, рассчитанный для специального периода
			// Опция действует только если fShowAgreement и в конфигурации рейтингов дебиторов установлены значения //
			// периода расчета кредитного лимита и периода дополнетельного кредитного лимита
		fWithIxParamOnly = 0x0008, // @v9.2.1 Только статьи с не пустыми параметрами обмена в соглашении
		fNonGenericOnly  = 0x0010  // @v9.5.9 Исключить группирующие статьи
	};
	char   ReserveStart[28]; // @anchor
	int32  LimitAddedTerm; // @v8.2.4 Период в днях для отображения дополнительного кредитного лимита
	PPID   AccSheetID;     //
	PPID   PersonID;       //
	int    Order;          //
	int16  Ft_Closed;      // (0) ignored, (< 0) off, (> 0) on
	int16  Ft_Stop;        // (0) ignored, (< 0) off, (> 0) on
	long   Flags;          // @flags
	long   Reserve;        // @anchor Заглушка для отмера "плоского" участка фильтра
};
//
// Специфические флаги доступа к аналитическим статьям
//
#define ARTRT_CLIAGT   0x0100 // Добавление и модификация соглашений с клиентами
#define ARTRT_MULTUPD  0x0200 // @v7.4.3 Право на массовое изменение или удаление

// ArticleTbl::Rec::Flags   ARTRF_XXX
#define ARTRF_GROUP    0x0001L // Группирующая статья аналитического учета
#define ARTRF_STOPBILL 0x0002L // По статье, имеющей такой флаг запрещено создавать новые документы
#define ARTRF_BUDG_INC 0x0004L // Доходная статья бюджета
#define ARTRF_CLOSED   0x0008L // @transient Дублирование поля Closed (используется в кэше)

struct PPArticlePacket {
	friend class PPObjArticle;

	SLAPI  PPArticlePacket();
	SLAPI ~PPArticlePacket();
	PPArticlePacket & FASTCALL operator = (const PPArticlePacket &);
	//int    SLAPI operator == (const PPArticlePacket &) const;

	void   SLAPI Init();
	//
	// Descr: Устанавливает параметры соглашения с клиентом в пакет записи.
	//   Если ignoreEmpty != 0 && pAgt->IsEmpty() то в соглашение обнуляется (или не устанавливается)
	//
	int    SLAPI SetClientAgreement(const PPClientAgreement * pAgt, int ignoreEmpty /*= 0*/);
	//
	// Descr: Устанавливает параметры соглашения с поставщиком в пакет записи.
	//   Если ignoreEmpty != 0 && pAgt->IsEmpty() то в соглашение обнуляется (или не устанавливается)
	//
	int    SLAPI SetSupplAgreement(const PPSupplAgreement * pAgt, int ignoreEmpty = 0);
	const  LAssocArray * SLAPI GetAliasSubst() const;
	int    SLAPI EnumAliasSubst(uint * pPos, PPID * pAliasID, PPID * pAccID) const;
	int    SLAPI AddAliasSubst(PPID accAliasID, PPID accID);
	int    SLAPI UpdateAliasSubst(PPID accAliasID, PPID accID);
	int    SLAPI RemoveAliasSubst(PPID accAliasID);

	ArticleTbl::Rec Rec;         // Заголовочная запись
	long   Assoc;                // @transient PPAccSheet(Rec.AccSheetID).Assoc
	PPClientAgreement * P_CliAgt;   // Соглашение с клиентом
	PPSupplAgreement  * P_SupplAgt; // Соглашение с поставщиком
	int    DontUpdateAliasSubst; // @transient Признак того, что функция PPObjArticle::PutPacket
		// не должна изменять таблицу соответствия алиасов счетов в базе данных.
private:
	LAssocArray * P_AliasSubst; // Таблица подстановок алиасов счетов
};

class PPObjArticle : public PPObject {
public:
	static int SLAPI DefaultClientAgreement();
	static int SLAPI DefaultSupplAgreement();
	//
	// Descr: Возвращает идентификатор типа регистрационного документа, используемого для //
	//   поиска персоналии, соответствующей статьям таблицы accSheetID.
	//   Если задан код типа регистрационного документа pRegTypeCode, то функция //
	//   ищет соответствующий име идентификатор. Если такой код не найден или
	//   pRegTypeCode == 0, то из записи таблицы accSheetID извлекается поле CodeRegTypeID.
	//   Если и в записи таблицы аналитического учета регистрационный документ для поиска не
	//   указан, и параметр useBillconfig != 0, то функция получает поле PPBillConfig::ClCodeRegTypeID.
	//   Если это поле больше нуля, то функция возвращает 2.
	// Returns:
	//   1  - ид типа регистрационного документа удачно обнаружен и присвоен по указателю pRegTypeID
	//   2  - ид типа регистрационного документа извлечен из конфигурации документов
	//   <0 - не удалось идентифицировать тип регистрационного документа для поиска персоналии.
	//   0  - ошибка
	//
	static int SLAPI GetSearchingRegTypeID(PPID accSheetID, const char * pRegTypeCode, int useBillConfig, PPID * pRegTypeID);
	//
	// Descr: Возвращает вид соглашения, используемого статьей pArRec.
	// Returns:
	//   -1 - статья не соотносится ни с одним видом соглашения //
	//   0  - ошибка
	//   1  - статья использует соглашение с клиентом
	//   2  - статья использует соглашение с поставщиком
	//
	static int SLAPI GetAgreementKind(const ArticleTbl::Rec * pArRec);

	SLAPI  PPObjArticle(void * extraPtr = 0);
	SLAPI ~PPObjArticle();
	//
	// В качестве дополнительного параметра методам PPObjArticle
	// передается идентификатор таблицы аналитических статей.
	//
	virtual int    SLAPI Browse(void * extraPtr);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual int    SLAPI DeleteObj(PPID id);
	//
	// Selector(extraParam)
	// If (extraParam >= 0), select only articles with (Closed == 0),
	// Else - without such constrain.
	//
	virtual int  SLAPI Search(PPID id, void * b = 0);
	virtual int  SLAPI Dirty(PPID id);
	const  ArticleFilt * SLAPI GetCurrFilt() const;
	void   SLAPI SetCurrFilt(const ArticleFilt * pFilt);
	SString & SLAPI MakeCodeString(const ArticleTbl::Rec * pRec, long options, SString &);
	//
	// Descr: Опции сравнения пакетов функцией IsPacketEq
	//
	enum {
		peoDontCmpAliasSubst = 0x0001 // Не сравнивать алиасы подстановки
	};

	int    SLAPI IsPacketEq(const PPArticlePacket & rS1, const PPArticlePacket & rS2, long options);
	int    SLAPI CheckObject(const ArticleTbl::Rec * pRec, SString * pMsgBuf);
	//
	// Descr: Проверяет согласуется ли изменяемый пакет персоналии с соотвествующими статьями
	//
	int    SLAPI CheckPersonPacket(const PPPersonPacket * pPack);
	int    SLAPI Fetch(PPID id, ArticleTbl::Rec * pRec);
	int    SLAPI GetPacket(PPID, PPArticlePacket *);
	int    SLAPI PutPacket(PPID *, PPArticlePacket *, int use_ta);
	int    SLAPI GetFreeArticle(long * pID, long accSheetID);
	int    SLAPI AutoFill(PPAccSheet *);
	int    SLAPI EditDialog(ArticleDlgData *);
	int    SLAPI EditGrpArticle(PPID * pID, PPID sheetID);
	int    SLAPI NewArticle(PPID * pID, long sheetID);
	int    SLAPI GetMainOrgAsSuppl(PPID * id, int processAbsense = 0, int use_ta = 0);
	int    SLAPI CreateObjRef(PPID *, PPID accSheetID, PPID objID, long ar, int use_ta);
	int    SLAPI AddSimple(PPID *, PPID accSheetID, const char * pName, long ar, int use_ta);
	//
	// Функции для работы с соглашениями с клиентами
	//
	int    SLAPI GetClientAgreement(PPID id, PPClientAgreement *, int use_default = 0);
	int    SLAPI PutClientAgreement(PPID id, PPClientAgreement *, int use_ta);
	int    SLAPI HasClientAgreement(PPID arID);
	int    SLAPI EditClientAgreement(PPClientAgreement *);
	static int   SLAPI PropToClientAgt(const PropertyTbl::Rec * pPropRec, PPClientAgreement * pAgt, int loadDebtLimList = 0);
	//
	// Функции для работы с соглашениями с поставщиками
	//
	static int   SLAPI GetSupplAgreement(PPID id, PPSupplAgreement * pAgt, int useInheritance = 0);
	static int   SLAPI EditSupplAgreement(PPSupplAgreement *);
	static int   SLAPI PropToSupplAgt(const PropertyTbl::Rec * pPropRec, PPSupplAgreement * pAgt);
	int    SLAPI PutSupplAgreement(PPID id, PPSupplAgreement *, int use_ta);
	static int   SLAPI HasSupplAgreement(PPID arID);
	//
	// Descr: Интерактивная функция редактирования соглашения с клиентом или поставщиком
	//   (в зависимости от таблицы, которой принадлежит статья arID).
	// Returns:
	//   >0 - пользователь успешно изменил соглашение
	//   <0 - либо статья arID не предполагает существования соглашения, либо пользователь
	//        отказался от изменения соглашения //
	//   0  - ошибка
	//
	int    SLAPI EditAgreement(PPID arID);

	static int   SLAPI GetAliasSubst(PPID id, LAssocArray *); // @>>Reference::GetPropArray()
	static int   SLAPI PutAliasSubst(PPID id, const LAssocArray *, int use_ta); // @>>Reference::PutPropArray()
	//
	// Descr: Ищет аналитическую статью, сопоставленную персоналии, имеющей номер
	//   регистрационного документа типа regTypeID равный pRegCode. Найденная персоналия должна
	//   быть сопоставленна статье по таблице accSheetID.
	//
	int    SLAPI SearchByRegCode(PPID accSheetID, PPID regTypeID, const char * pRegCode, PPID * pID, ArticleTbl::Rec *);
	int    SLAPI GetByPersonList(PPID accSheetID, const PPIDArray * pPsnList, PPIDArray * pArList);
	int    SLAPI GetByPerson(PPID accSheetID, PPID psnID, PPID * pArID);
	int    SLAPI GetRelPersonList(PPID arID, PPID relTypeID, int reverse, PPIDArray * pList);
	int    SLAPI GetRelPersonSingle(PPID arID, PPID relTypeID, int reverse, PPID * pRelID);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*(ArticleFilt *)*/); // @v9.2.1 accSheetID-->(ArticleFilt *)
private:
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual const char * SLAPI GetNamePtr();
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI SearchAssocObjRef(PPID objType, PPID objID, PPID * pAccSheetID, PPID kind, PPID * pID);
	int    SLAPI ReplyArticleReplace(PPID dest, PPID src);
	int    SLAPI ReplyPersonReplace(PPID dest, PPID src);
	// @v9.1.3 int    SLAPI ReplyWarehouseAdded(PPID locID);
	int    SLAPI ReplyObjectCreated(PPID objType, PPID objID); // @v9.1.3
	int    SLAPI _ProcessSearch(int, PPID id);
	int    SLAPI _UpdateName(const char * pNewName);
	int    SLAPI Helper_PutAgreement(PPID id, PPArticlePacket * pPack);
	int    SLAPI SerializePacket(int dir, PPArticlePacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	void * ExtraPtr;
	ArticleFilt CurrFilt;

	PPObjPersonRelType ObjRelTyp;
public:
	TLP_MEMB(ArticleCore, P_Tbl);
};
//
// @ModuleDecl(PPViewSysJournal)
//
struct SysJournalFilt : public PPBaseFilt {
	enum {
		fShowObjects  = 0x0001
	};

	SLAPI  SysJournalFilt();
	virtual int SLAPI IsEmpty() const;

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPID   UserID;
	PPID   ObjType;
	PPID   ObjID;
	long   Flags;
	int16  DayOfWeek;
	int16  Reserve;
	SubstGrpSysJournal Sgsj;
	SubstGrpDate       Sgd;  // Параметр подстановки даты
	PPIDArray ActionIDList;  // @anchor
};

struct SysJournalViewItem : public SysJournalTbl::Rec {
	void   Clear();

	long   ID;
	char   ObjName[64];
	SString GrpText1;
	SString AvgEvTime;
	long   GrpCount;
};

class PPViewSysJournal : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		double Extra;
		PPID   Action;
	};
	SLAPI  PPViewSysJournal();
	SLAPI ~PPViewSysJournal();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt * pFilt);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SysJournalViewItem *);
	int    FASTCALL CheckRecForFilt(const SysJournalTbl::Rec * pRec);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int SLAPI Print(const void *);
	virtual int SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	virtual int SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI RefreshTempTable(LDATETIME since);
	int    SLAPI EditObj(PPObjID * pObjID);
	int	   SLAPI ViewBillHistory(PPID histID);
	int    SLAPI Transmit();

	SysJournalFilt  Filt;
	SysJournal * P_Tbl;
	SysJournalTbl     * P_TmpTbl;
	TempSysJournalTbl * P_SubstTbl;
	TempDoubleIDTbl * P_NamesTbl;
	ObjCollection   * P_ObjColl;
	int    LockUpByNotify; // Семафор, блокирующий обновление данных по системному событию
	LDATETIME LastRefreshDtm; // Время последнего обновления выборки. Используется для определения времени,
		// начиная с которого следует извлекать события из журнала для последующего обновления.
};
//
//
//
struct GtaJournalFilt : public PPBaseFilt {
	enum {
		fShowObjects  = 0x0001
	};

	SLAPI  GtaJournalFilt();
	virtual int SLAPI IsEmpty() const;

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPID   GlobalUserID;
	PPObjID Oi;
	long   Flags;
	int16  DayOfWeek;
	int16  Reserve;
	PPIDArray ActionIDList;  // @anchor
};

struct GtaJournalViewItem : public GtaJournalTbl::Rec {
	void   Clear();

	long   ID;
	SString ObjName;
};

class PPViewGtaJournal : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		long   Op;
		LDATETIME Dtm;
	};
	SLAPI  PPViewGtaJournal();
	SLAPI ~PPViewGtaJournal();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt * pFilt);
	//virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GtaJournalViewItem *);
	int    FASTCALL CheckRecForFilt(const GtaJournalTbl::Rec * pRec);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	//virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Detail(const void *, PPViewBrowser * pBrw);
	//virtual int SLAPI Print(const void *);
	//virtual int SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	//virtual int SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI IsTempTblNeeded() const;

	GtaJournalFilt  Filt;
	GtaJournalCore  T;
	GtaJournalTbl  * P_TmpTbl;
	TempDoubleIDTbl * P_NamesTbl;
	ObjCollection  * P_ObjColl;
	int    LockUpByNotify; // Семафор, блокирующий обновление данных по системному событию
	LDATETIME LastRefreshDtm; // Время последнего обновления выборки. Используется для определения времени,
		// начиная с которого следует извлекать события из журнала для последующего обновления.
};
//
// @ModuleDecl(PPViewLogsMonitor)
//
struct LogFileEntry {
	PPID		ID;
	char		LogName[128];
	char		FileName[32];
};
typedef TSArray <LogFileEntry> LogsArray;
//
struct LogsMonitorFilt : public PPBaseFilt {
	SLAPI		LogsMonitorFilt();
	virtual int Describe(long flags, SString & rBuff) const;

	char		ReserveStart[32];	// @anchor
	long		Flags;
	long		Reserve;			// @anchor
	LogsArray	Selected;
};
//
struct LogsMonitorViewItem;
//
class PPViewLogsMonitor : public PPView {
public:
	struct BrwHdr {
		PPID   Obj;
		PPID   Id;
		double Extra;
		PPID   Action;
	};
	SLAPI  PPViewLogsMonitor();
	SLAPI ~PPViewLogsMonitor();
	//
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(LogsMonitorViewItem *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser *pBrw);
	//int SLAPI CheckRecForFilt(const TempLogFileMonTbl::Rec *pRec);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint *pBrwId, SString *pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int SLAPI UpdateTempTable(LogsArray *pExpiredLogs);
	//virtual int SLAPI Print(const void *);
	//
	LogsMonitorFilt		Filt;
	uint				CountLogs;
	LAssocArray			LogsOffsets;
	TempLogFileMonTbl	*P_TmpTbl;
	LDATETIME			LastUpdated;
	int					FirstTime;
};
//
void ViewLogsMonitor();
//
// @ModuleDecl(PPViewGeoTracking)
//
struct GeoTrackingFilt : public PPBaseFilt {
	SLAPI  GeoTrackingFilt();
	virtual int SLAPI IsEmpty() const;

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	LTIME  BegTm;
	PPObjID Oi;
	PPObjID ExtOi;
	long   Flags;
	uint32 Reserve;           // @anchor
};
//
// Descr: Итоги выборки гео-треков
//
struct GeoTrackingTotal {
	SLAPI  GeoTrackingTotal()
	{
		Count = 0;
		ObjCount = 0;
	}
	long   Count;     // Количество точек в выборке
	long   ObjCount;  // Количество объектов в выборке
};

typedef GeoTrackTbl::Rec GeoTrackingViewItem;

class PPViewGeoTracking : public PPView {
public:
	SLAPI   PPViewGeoTracking();
	SLAPI  ~PPViewGeoTracking();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GeoTrackingViewItem *);
	int    FASTCALL CheckRecForFilt(const GeoTrackTbl::Rec * pRec);
	int    SLAPI CalcTotal(GeoTrackingTotal * pTotal);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int SLAPI ViewTotal();
	int    SLAPI Export();

	GeoTrackingFilt Filt;
	GeoTrackCore T;
};
//
// Descr: Фильтр по классификаторам товаров
//
struct ClsdGoodsFilt {
	//
	// @note Порядок полей важен! Сначала идут плоские данные, и затем сложные (ObjIdListFilt)
	//
	SLAPI  ClsdGoodsFilt();
	ClsdGoodsFilt & SLAPI Clear();
	int    FASTCALL IsEqual(const ClsdGoodsFilt & rS) const;
	//
	// Descr: Возвращает !0 если фильтр содержит ограничение
	//   хотя бы по одному из классифицирующих атрибутов.
	//
	int    SLAPI HasAttrRestrictions() const;
	int    SLAPI SetDimRange(int dim, double low, double upp);
	enum {
		fFirstGenGoods = 0x0001 // Первый обобщенный товар, соответствующий фильтру
	};
	PPID   GdsClsID;
	long   Flags;
	RealRange DimX_Rng;
	RealRange DimY_Rng;
	RealRange DimZ_Rng;
	RealRange DimW_Rng;
	//
	// Ограничения по классифицирующим атрибутам {
	//
	ObjIdListFilt KindList;   // @anchor
	ObjIdListFilt GradeList;
	ObjIdListFilt AddObjList;
	ObjIdListFilt AddObj2List;
};
//
// Фильтр по товарам
//
class GoodsFilt : public PPBaseFilt { // @persistent
public:
	//
	// @todo Эту структуру следует объединить с ClsdGoodsFilt
	//  (данная структура @persistent по-этому действовать следует осторожно).
	//
	/*
	struct ExtParams {
		//
		// Descr: Возвращает !0 если фильтр содержит ограничение
		//   хотя бы по одному из классифицирующих атрибутов.
		//
		int    HasAttrRestrictions() const
		{
			return (KindID || GradeID || AddObjID || AddObj2ID ||
				!DimX.IsZero() || !DimY.IsZero() || !DimZ.IsZero() || !DimW.IsZero());
		}
		PPID   GdsClsID;
		PPID   KindID;
		PPID   AddObjID;
		PPID   GradeID;
		PPID   AddObj2ID;
		RealRange DimX;
		RealRange DimY;
		RealRange DimZ;
		RealRange DimW;
	};
	*/
	enum {
		fUseGrpList        = 0x00000001L,
		fUseUnitMask       = 0x00000004L,
		fIntUnitOnly       = 0x00000008L,
		fFloatUnitOnly     = 0x00000010L,
		fNegation          = 0x00000020L, // Отрицание фильтра
		fGenGoods          = 0x00000040L, // Если установлен, то поле GrpID используется как обобщенный товар.
		fGroupGenGoods     = 0x00000080L, // Группировать обобщенные товары
		fUndefType         = 0x00000100L,
		fNewLots           = 0x00000200L, // Только те товары, которых не было на дату (LotPeriod.low-1)
		fExcludeAsset      = 0x00000400L, // Исключить основные средства
		fIncludeIntr       = 0x00000800L, // Рассматривать порожденные лоты
			// Действует при (!LotPeriod.IsZero() || SupplID)
		fShowBarcode       = 0x00001000L, // Показывать штрихкоды в броузере
		fShowCargo         = 0x00002000L, // Показывать товары с грузовыми параметрами
		fHidePassive       = 0x00004000L, // Не показывать пассивные товары (отменяет fPassiveOnly)
		fPassiveOnly       = 0x00008000L, // Показывать только пассивные товары (отменяет fHidePassive)
		fGenGoodsOnly      = 0x00010000L, // Показывать только обобщенные товары
		fWOTaxGdsOnly      = 0x00020000L, // Показывать только товары с ценой без налогов
			// @#{fPassiveOnly^fGenGoodsOnly^fWOTaxGdsOnly}
		fNoZeroRestOnLotPeriod = 0x00040000L, // Если товар не удовлетворяет ограничению LotPeriod,
			// но есть на остатке, то попадает в выборку
		fNoDisOnly         = 0x00080000L, // Показывать только товары с признаком без скидки
		fShowStrucType     = 0x00100000L, // Показывать признак наличия структуры AHTOXA
		fNotUseViewOptions = 0x00200000L, // Не показывать в товарном фильтре кнопку опции просмотра
		fShowGoodsWOStruc  = 0x00400000L, // Показывать товары без структуры
		fWoTaxGrp          = 0x00800000L, // Показывать только товары без налоговой группы
		fRestrictByMatrix  = 0x01000000L, // Ограничивать выборку товарной матрицей. Если LocID == 0,
			// то ограничивается матрицей для всех складов
		fShowArCode        = 0x02000000L, // Показывать артикулы товаров
		fShowOwnArCode     = 0x04000000L, // Показывать собственные артикулы (ArID = 0)
		fShowWoArCode      = 0x08000000L, // Показывать товары без артикулов
		fOutOfMatrix       = 0x10000000L, // Показывать только те товары, которые НЕ принадлежат матрице.
			// Этот флаг имеет более низкий приоритет, чем fRestrictByMatrix. То есть, если установлены оба
			// флага (что программа не должна допускать), то применяется fRestrictByMatrix
		fActualOnly        = 0x20000000L, // Показывать только те товары, по которым есть не нулевые остатки по одному из складов LocList
		fHasImages         = 0x40000000L, // @v7.3.x Только с картинками
		fUseIndepWtOnly    = 0x80000000L  // @v8.3.9 Только с флагом GF_USEINDEPWT
	};
	enum { // @persistent
		bcrLength = 1,
		bcrPrefix
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке SrchStr_
	//
	enum { // @persistent
		extssNameText    = 1,
		extssBarcodeText = 2
	};
	SLAPI  GoodsFilt(PPID group = 0);
	SLAPI  GoodsFilt(const GoodsFilt &);
	GoodsFilt & FASTCALL operator = (const GoodsFilt & s);
	int    SLAPI Setup();
	virtual int SLAPI IsEmpty() const;
	//
	// Descr: Преобразует строку, в которой перечислены через запятую длины
	//   штрихкодов в список PPIDArray.
	//   Результирующий список отсортирован по возрастанию и в нем отсутствуют
	//   дублирования.
	// Returns:
	//   <0 - Строка BarcodeLen пустая.
	//   >0 - Спецификация фильтра предполагает фильтрацию по длинам штрихкодов
	//
	int    FASTCALL GetBarcodeLenList(PPIDArray & rList) const;
	int    FASTCALL GetBarcodePrefixList(StringSet & rSet) const;
	int    SLAPI GetExtssData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtssData(int fldID, const char * pBuf);
	//
	// Descr: Определяет результирующий список брендов по спискам BrandList и BrandOwnerList
	//
	int    SLAPI CalcResultBrandList(ObjIdListFilt & rResult) const;
	//
	// Descr: Возвращает результирующий списко брендов (по спискам BrandList и BrandOwnerList),
	//   сформированный функцией GoodsFilt::Setup
	//
	const  ObjIdListFilt & GetResultBrandList() const;
	//
	// Descr: Если фильтр ограничивает выборку только теми товарами,
	//   для которых есть коды по статье CodeArID, то функция возвращает !0,
	//   в противном случае - 0.
	//
	int    SLAPI IsRestrictedByAr() const;
	int    SLAPI ReadFromProp(PPID obj, PPID id, PPID prop, PPID propBefore8604);
	int    SLAPI WriteToProp(PPID obj, PPID id, PPID prop, PPID propBefore8604);

	char   ReserveStart[4];    // @anchor Проецируется на __GoodsFilt::Reserve @v6.0.7 [24]-->[20]
	PPID   UhttStoreID;        // Магазин Universe-HTT в контексте которого извлекаются товары.
	PPID   RestrictQuotKindID; // Вид ограничивающей котировки (извлекаются только те товары, которые имеют котировку этого вида)
	int32  InitOrder;          //
	PPID   MtxLocID;           // Если (Flags & (fRestrictByMatrix|fOutOfMatrix)), то данное поле
		// определяет склад, по которому проверяется принадлежность (не принадлежность) матрице.
		// Если (Flags & (fRestrictByMatrix|fOutOfMatrix)) и MtxLocID == 0, то принадлежность (не принадлежность) матрице
		// проверяется относительно склада LocID_.
	PPID   BrandOwnerID;       //
	PPID   CodeArID;           // Статья, по которой фильтровать коды, связанные со статьями
	PPID   GrpID;              //
	PPID   ManufID;            //
	PPID   ManufCountryID;     //
	PPID   UnitID;             //
	PPID   PhUnitID;           //
	PPID   SupplID;            //
	PPID   GoodsTypeID;        //
	PPID   TaxGrpID;           //
	PPID   LocID_;             //
	DateRange LotPeriod;       //
	long   Flags;              //
	long   VatRate;            // Ставка НДС, которой облагается товар. Ненулевое значение этого поля исключает фильтрацию по полю TaxGrpID.
	LDATE  VatDate;            // Дата, на которую следует брать ставку НДС. Используется только если VatRate != 0
	PPID   BrandID_;           // Товарный брэнд
	//ExtParams  Ep;           //
	ClsdGoodsFilt Ep;          // @anchor
	//
	// @v8.2.12
	//  Начиная с версии 8.2.12 внутри SrchStr_ могут содержаться одновременно строка для поиска по наименованию и
	//  строка для поиска по штрихкоду. Соответственно, прямо это поле использовать не следует - необходимо применять функции
	//  GetExtssData и PutExtssData с указанием типов полей, определенных через enum GoodsFilt::extssXXX
	//  Для обратной совместимости, если внутри строки нет спец т'гов <>, то вся строка трактуется как критерий поиска по наименованию.
	//
	SString SrchStr_;          // @anchor Строка, содержащаяся в имени.
	//
	SString BarcodeLen;        // Список длин штрихкодов (через запятую)
	ObjIdListFilt GrpIDList;   // Список групп
	ObjIdListFilt ManufList;   // Helper (not filter) field
	ObjIdListFilt LocList;     //
	ObjIdListFilt BrandList;   //
	ObjIdListFilt BrandOwnerList; //
	SysJournalFilt * P_SjF;    //
	TagFilt * P_TagF;          // Фильтр по тегам
private:
	int    SLAPI InitInstance();
	virtual int SLAPI Describe(long flags, SString & rBuf) const;
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
	char * SLAPI WriteObjIdListFilt(char * p, const ObjIdListFilt & rList) const;
	char * SLAPI ReadObjIdListFilt(char * p, ObjIdListFilt & rList);
	int    SLAPI ReadFromProp_Before8604(PPID obj, PPID id, PPID prop);

	ObjIdListFilt ResultBrandList; // @transient @*GoodsFilt::Setup @v7.7.9 Результирующий список бр'ндов, агрегирующий BrandList и BrandOwnerList
};
//
// Descr: Информация о товаре, специфичная для розничной торговли.
//   Используется также для печати этикеток на принтере штрихкодов.
//
struct RetailGoodsInfo {   // @transient
	RetailGoodsInfo();
	void   Init();

	enum {
		fDisabledQuot    = 0x0001, // Котировка QuotKindUsedForPrice является блокирующей - продажа товара запрещена.
		fDisabledExtQuot = 0x0002, // Котировка
		//
		fNoDiscount      = 0x0004  // @v8.6.8  OUT (устанавливается в результате вычислений) - на товар не распространяется скидка
	};
	PPID   ID;             // ->Goods.ID
	char   Name[128];      // =Goods(ID).Name
	char   BarCode[24];    // @v8.8.0 [16]-->[24]
	char   UnitName[48];   //
	char   Manuf[48];      //
	char   ManufCountry[48];
	PPID   LocID;          // Склад, для которого рассчитана цена
	PPID   QuotKindUsedForPrice; // Вид котировки, использованной для получения цены Price.
		// Данное поле гарантированно имеет смысл только после вызова PPObjGoods::GetRetailGoodsInfo
	PPID   QuotKindUsedForExtPrice; // Вид котировки из блока RetailPriceExtractor::ExtQuotBlock, примененный для формиования ExtPrice.
	LDATE  Expiry;         //
	double OuterPrice;     // @IN @v8.0.12 Цена, установленная вызывающей функцией дабы использовать ее (при установленном флаге rgifUseOuterPrice)
	double Cost;           // Цена поступления //
	double Price;          // Цена реализации
	double ExtPrice;       // Цена по дополнительной котировке
	double RevalPrice;     // Цена реализации до переоценки (RevalPrice != Price только если структура
		// сформирована по строке документа переоценки).
	double LineCost;       // Цена поступления из строки документа (по контексту)
	double LinePrice;      // Цена реализации из строки документа (по контексту)
	double PhUPerU;        // Соотношение физические единицы/торговые единицы
	//
	// Информация о партии
	//
	PPID   LotID;
	LDATE  BillDate;       // Дата прихода (для техн сессий - дата производства)
	char   BillCode[24];   // Номер документа прихода (для техн сессий - номер сессии)
	char   Serial[32];     // Серийный номер лота
	int16  LabelCount;     // Количество этикеток, которое требуется напечатать. [1..999], default=1
	int16  Reserve;        // @alignment
	LDATETIME ManufDtm;    // Дата/время производства
	long   Flags;          //
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double UnitPerPack;    // Емкость упаковки
	double Brutto;         // Масса брутто для количества Qtty
	//
	char   ArName[48];     // Наименование контрагента техн сессии, по которой сформирована структура
	char   Ar2Name[48];    // Наименование дополнительной статьи техн сессии, по которой сформирована структура
	char   PrcName[48];    // Наименование процессора техн сессии, по которой сформирована структура
};
//
// @ModuleDecl(RetailPriceExtractor)
//
#define RTLPF_PRICEBYQUOT     0x0001L // Соответствует PPEquipConfig::fUseQuotAsPrice
#define RTLPF_USEQUOTWTIME    0x0002L // Использовать котировки с установленным временем действия //
#define RTLPF_GETCURPRICE     0x0004L // Выдавать текущую цену товара (а не по розничным котировкам)
#define RTLPF_USEQKCACHE      0x0008L // Применять кэширование при извлечении списка розничных котировок
#define RTLPF_USEMINEXTQVAL   0x0010L // Если задан RetailPriceExtractor::ExtQuotBlock,
	// то из указанных там котировок применять минимально возможное значение.
#define RTLPF_USEOUTERPRICE   0x0020L // @v8.0.12 Использовать цену RetailExtrItem::OuterPrice, заданную извне

struct RetailExtrItem { // @transient
	SLAPI  RetailExtrItem();

	enum {
		fDisabledQuot    = 0x0001, // Заблокированная котировка. Этот флаг означает, что продажа товара запрещена
		fDisabledExtQuot = 0x0002, // @v7.8.1 Заблокированная дополнительная котировка. Этот флаг означает, что продажа товара запрещена
	};
	double Cost;                 // Цена поступления (по последнему лоту) Если товар нелимитируемый, то 0.
	double Price;                // Цена реализации (возможно, по котировке, обусловленной датой или временем)
	double BasePrice;            // @v7.1.0 Цена реализации без учета розничных котировок.
	double ExtPrice;             // Цена по котировки RetailPriceExtractor::ExtQuotKindID
	LDATE  CurLotDate;           //
	LDATE  Expiry;
	LDATETIME ManufDtm;          // @v7.5.1  Дата/время производства товара (извлекается из лота по зарезервированному т'гу PPTAG_LOT_MANUFTIME)
	PPID   QuotKindUsedForPrice; // @v7.0.10 Вид котировки, использованный для формирования значения Price.
		// Если цена сформирована по последнему лоту, либо вообще не определена, то 0.
	PPID   QuotKindUsedForExtPrice; // @v7.4.0 Вид котировки из блока RetailPriceExtractor::ExtQuotBlock,
		// примененный для формиования ExtPrice.
	long   Flags;
	double OuterPrice;    // IN @v8.0.12 Цена, заданная вызывающей функцией. Имеет силу если RetailPriceExtractor::GetPrice
		// вызывается с флагом RTLPF_USEOUTERPRICE
	RAssocArray QuotList; // IN Список дополнительных котировок.
		// Вызывающая функция заполняет поля Key идентификаторами видов котировок.
		// AsyncCashGoodsIterator инициализирует поля Val массива соответствующими
		// эффективными значениями котировок.
};

class RetailPriceExtractor {
public:
	struct ExtQuotBlock {
		ExtQuotBlock(PPID quotKindID);
		ExtQuotBlock(const PPSCardSerPacket & rScsPack);

		PPIDArray QkList;
	};
	SLAPI  RetailPriceExtractor();
	SLAPI  RetailPriceExtractor(PPID locID, const ExtQuotBlock * pEqBlk, PPID arID, LDATETIME actualDtm, long flags);
	SLAPI ~RetailPriceExtractor();
	int    SLAPI Init(PPID locID, const ExtQuotBlock * pEqBlk, PPID arID, LDATETIME actualDtm, long flags);
	//
	// Descr: Переопределяет склад объекта. Главная цель этой функции - избежать
	//   полной повторной инициализации (довольно дорогой) объекта если изменился только склад.
	//
	void   SLAPI SetLocation(PPID locID);
	//
	// Descr: возвращает цену товара по следующим правилам:
	//   1. Если есть приоритетная котировка (ExtQuotKindID), то цена возвращается //
	//      в RetailExtrItem::ExtPrice, для других случаев в RetailExtrItem::Price.
	//   2. Если есть розничные котировки (акции), действующие на указанную дату,
	//      выбирается котировка с наивысшим рангом. При одинаковых рангах - первая найденная.
	//      Базовая котировка является розничной, если установлен флаг PPEquipConfig::fUseQuotAsPrice.
	//   3. При отсутствии котировок цена определяется по текущему лоту.
	// ARG(goodsID     IN):
	// ARG(forceBaseLotID IN): Если !0, то для определения базовых учетных цен функция //
	//   пытается использовать лот, указанный этим идентификатором. Его значение передается //
	//   в функцию ::GetCurGoodsPrice.
	// ARG(pItem   IN/OUT): @{vptr}
	//
	int    SLAPI GetPrice(PPID goodsID, PPID forceBaseLotID, double qtty, RetailExtrItem * pItem);
private:
	PPID   LocID;
	PPID   ArID;          // Статья, в привязке к которой извлекаются котировки
	ExtQuotBlock EqBlk;
	long   Flags;
	PPIDArray  RetailQuotList;
	//
	PPObjGoods * P_GObj;
};
//
// Структуры, необходимые для агрегированной подстановки свойств товаров
// вместо самих товаров в отчетности
//
struct GoodsSubstItem {
	GoodsSubstItem();

	long   ID;
	long   ClsID;
	long   Par1;
	union {
		struct {
			long   Par2;
			long   Par3;
		} L;
		double RVal;         // @v7.5.4
	} U;
	union {
		uint   StrP;          // @v7.5.4 Позиция строки в GoodsSubstList::StrPool
		const  char * P_Text; // @v7.5.4 При добавлении элемента - указатель на текст, который сохраняется в
			// GoodsSubstList::StrPool в позиции StrP.
	};
};

class GoodsSubstList {
public:
	struct AssocItem {
		PPID   SrcGoodsID;
		PPID   LocID;
		PPID   LotID;
		LDATE  Dt;
	};
	SLAPI  GoodsSubstList(int saveAssoc = 0);
	SLAPI ~GoodsSubstList();
	//
	// Descr: Инициализирует объект:
	//   - очищает все списки,
	//   - устанавливает переменную SaveAssoc
	//   - если pSrc != 0, то копирует pSrc->P_List -> P_List
	//
	int    SLAPI Init(int saveAssoc, const GoodsSubstList * pSrc);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI AddItem(const GoodsSubstItem & rItem, const AssocItem & rAssocItem, PPID * pID);
	int    SLAPI GetItem(PPID id, GoodsSubstItem * pItem) const;
	void   SLAPI Clear();
	long   SLAPI GetAssocCount(PPID substID) const;
	//
	// Descr: Заполняет список идентификаторов подстановок.
	//   Не очищает массив pList до начала цикла заполнения.
	//   Все элементы добавляются методом addUnique, по-этому, дублирования не возникает.
	//
	int    SLAPI GetSubstList(PPIDArray & rList) const;
	//
	// Descr: Заполняет список идентификаторов товаров, соответствующих подстановке substID
	//
	int    SLAPI GetGoodsBySubstID(PPID substID, PPIDArray * pGoodsList) const;
	int    SLAPI GetGoodsBySubstID(PPID substID, ObjIdListFilt * pGoodsList) const;
	int    SLAPI GetSubstAssocList(PPID substID, TSArray <AssocItem> * pList) const;
	int    SLAPI AddToAssoc(PPID substID, const AssocItem & rAssocItem);

	PPID   SLAPI SubstAlcoCategory(PPID goodsID);
	int    SLAPI GetAlcoCategoryText(PPID substID, SString & rBuf) const;

	PPID   SLAPI SubstLocAssoc(PPID goodsID);
	int    SLAPI GetLocAssocText(PPID substID, SString & rBuf) const;

	int    SaveAssoc;
private:
	TSArray <GoodsSubstItem> List;
	struct InnerAssocItem {
		SLAPI  InnerAssocItem(PPID substID);
		uint   SLAPI SearchAssoc(const GoodsSubstList::AssocItem & rPattern) const;
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		PPID   SubstID;
		TSArray <AssocItem> List;
	};
	class AssocCollection : public TSCollection <InnerAssocItem> {
	public:
		SLAPI  AssocCollection();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	};
	AssocCollection AsscList;
	PrcssrAlcReport * P_Arp;
	GoodsToObjAssoc * P_Goa;
public:
	StringSet StrPool; // @really private
};
//
// Некоторые существенные признаки группы товаров, которые иногда
// полезны сами по себе (бывает эффективнее однажды извлечь и хранить
// только эти признаки, чем каждый раз доставать целую запись).
//
enum GoodsGroupTag {
	ggtagZero      = 0,
	ggtagUndefined = 0x8000, // Признаки не определены (необходимо извлечь)
	ggtagAlternate = 0x0001, // Альтернативная группа
	ggtagParent    = 0x0002, // Группа имеет подгруппы
	ggtagOdd       = 0x0004, // Группа имеет тип, отличный от стандартного
	ggtagTemp      = 0x0008  // Временная альтернативная группа
};
//
// Флаги товаров
//
#define GF_INTVAL       0x00000001L // @transient Целочисленная единица измерения //
#define GF_UNLIM        0x00000002L // @transient Неограниченный ресурс
#define GF_ODD          0x00000004L // @transient Нестандартный товар
#define GF_AUTOCOMPL    0x00000008L // @transient Автокомплект
#define GF_GENERIC      0x00000010L // Обобщенный товар
//
#define GF_ABSEXCISE    0x00000020L // Obsolete Акциз в денежных единицах (не процентах)
#define GF_ZEXCISE      0x00000040L // Obsolete Нулевой акциз (акциз не наследуется от группы)
#define GF_ZVAT         0x00000080L // Obsolete Нулевой НДС (НДС не наследуется от группы)
//
#define GF_TAXFACTOR    0x00000020L // ExtRec содержит ненулевой налоговый фактор
#define GF_PRICEWOTAXES 0x00000040L // UC Цена реализации товара указана без всех операционных налогов
#define GF_EXTPROP      0x00000080L // Товар имеет запись расширенных свойств (PPGoodsPacket::ExtString)
#define GF_ALTGROUP     0x00000100L // Альтернативная группа
#define GF_FOLDER       0x00000200L // Группа верхнего уровня //
#define GF_PASSIV       0x00000400L // Пассивный товар
#define GF_NODISCOUNT   0x00000800L // На товар не распространяется общая скидка
#define GF_EXCLALTFOLD  0x00001000L // Папка, объединяющая непересекающиеся альтернативные группы
#define GF_UNIQPCKGCODE 0x00002000L // Уникальный код пакета
#define GF_DFLTPCKGTYPE 0x00004000L // Тип пакета по умолчанию
#define GF_PCKG_AROWS   0x00008000L //
#define GF_PCKG_ANEWROW 0x00010000L //
#define GF_ASSETS       0x00020000L // @transient Основные фонды
	// Проекция флага GTF_ASSETS типа, которому принадлежит товар
#define GF_WROFFBYPRICE 0x00040000L // Списывать основное средство исходя из остаточной стоимости
#define GF_TRANSGLED    0x00080000L // @transient Признак передачи в пакете структуры GoodsLotExtData
#define GF_VOLUMEVAL    0x00100000L // Объем упаковки поставки задается одним значением
#define GF_TRANSQUOT    0x00200000L // @transient Пакет передачи предназначен для трансмиссии котировок
	// Сами товары не меняются. Не удаляются остутствующие в пакете, но присутствующие в базе котировки.
#define GF_TEMPALTGRP_  0x00400000L //
#define GF_USEINDEPWT   0x00800000L // Операции по товару ведуться параллельно в торговых и физических единицах
#define GF_DYNAMIC      0x01000000L // Динамическая альтернативная группа
#define GF_HASIMAGES    0x02000000L // К товару присоединены картинки
#define GF_ABBREQNAME   0x04000000L // @transient Используется у элементов кэша для информации о том, что
	// сокращенное наименование эквивалентно полному.
#define GF_EXCLVAT      0x08000000L // @transient Наследуется от типа товара (GTF_EXCLVAT) при извлечении через кэш
#define GF_AUTOCREATE   0x10000000L // @v8.8.0 Признак того, что товар (группа) создан автоматически (например, при импорте внешнего документа, содержащего этот товар)
#define GF_UNCLASSF     0x20000000L // @v9.2.8 Признак группы, бренда или иного контейнера, содержащего неклассифицированные товары.
	// Используется для автоматической классификации.

#define GF_TEMPALTGROUP      (GF_ALTGROUP|GF_TEMPALTGRP_) // Временная альтернативная группа
#define GF_DB_FLAGS_GROUP    (GF_ALTGROUP|GF_FOLDER|GF_EXCLALTFOLD)
#define GF_DB_FLAGS_GOODS    (GF_GENERIC|GF_TAXFACTOR|GF_PRICEWOTAXES|GF_EXTPROP|GF_PASSIV|GF_NODISCOUNT|\
	GF_WROFFBYPRICE|GF_VOLUMEVAL|GF_USEINDEPWT|GF_HASIMAGES)
#define GF_DB_FLAGS_PCKGTYPE (GF_UNIQPCKGCODE|GF_DFLTPCKGTYPE|GF_PCKG_AROWS|GF_PCKG_ANEWROW)
#define GF_DYNAMICALTGRP     (GF_ALTGROUP|GF_DYNAMIC) // Динамическая альтернативная группа
#define GF_DYNAMICTEMPALTGRP (GF_ALTGROUP|GF_DYNAMIC|GF_TEMPALTGRP_)
//
// Специфические флаги прав доступа по товарам
//
#define GOODSRT_UPDQUOTS  0x0100 // Право на массовое изменение котировок (cmUpdateQuots)
#define GOODSRT_UPDTAXGRP 0x0200 // Право на изменение налоговой группы товара
#define GOODSRT_UNITE     0x0400 // Право на объединение товаров
#define GOODSRT_MULTUPD   0x0800 // Право на массовое изменение (флагов, наименований)
#define GOODSRT_UPDIMAGE  0x1000 // Право на изменение картинки присоединенной к товару
#define GOODSRT_UPDGTYPE  0x2000 // Право на изменение принадлежности товара (группы) типу
#define GOODSRT_PRIORCODE 0x4000 // Право на изменение приоритетного штрихкода. Если этого
	// права нет, то пользователь не может изменить значение приоритетного кода равно как и установить/снять
	// признак приоритетности.
//
// Виды товарных пакетов
//
enum GoodsPacketKind {
	gpkndUndef         = 0, // Неопределенный (необходимо инициализировать)
	gpkndGoods         = 1, // @gpkind_goods         Товар
	gpkndOrdinaryGroup = 2, // @gpkind_ordinarygroup Обыкновенная группа
	gpkndFolderGroup   = 3, // @gpkind_foldergroup   Папка (содержит подгруппы)
	gpkndAltGroup      = 4, // @gpkind_altgroup      Альтернативная группа
	gpkndPckgType      = 5  // @v3.3.4 @UnderConstruction
};
//
// Коды дополнительных текстовых полей товара
//
#define GDSEXSTR_STORAGE   1 // (A) Условия хранения //
#define GDSEXSTR_STANDARD  2 // (B) Стандарт
#define GDSEXSTR_LABELNAME 3 // Наименование для печати ценников
#define GDSEXSTR_INGRED    4 // (C) Ингредиенты товара
#define GDSEXSTR_ENERGY    5 // (D) Энергетическая ценность
#define GDSEXSTR_USAGE     6 // (E) Способ использования (приготовления)
#define GDSEXSTR_A         1 // (A) Синоним
#define GDSEXSTR_B         2 // (B) Синоним
#define GDSEXSTR_C         4 // (C) Синоним
#define GDSEXSTR_D         5 // (D) Синоним
#define GDSEXSTR_E         6 // (E) Синоним
#define GDSEXSTR_OKOF     10 // Код ОКОФ основного средства
#define GDSEXSTR_INFOSYMB 11 // @v8.7.2 Специальный символ, идентифицирующий дополнительную информацию о товаре, отображаемую в диалоге товара
//
// Специализированная структура для переноса параметров лотов по товару из
// одного раздела БД в другой
//
struct GoodsLotExtData {
	PPID   QCertID;
	LDATE  Expiry;
	double UnitPerPack;
	char   Serial[32];
	char   CLB[32];
};

class PPGoodsPacket {
public:
	SLAPI  PPGoodsPacket();
	SLAPI ~PPGoodsPacket();
	void   SLAPI destroy();
	PPGoodsPacket & FASTCALL operator = (const PPGoodsPacket &);
	int    SLAPI AddCode(const char *, long codeType, double uPerP);
	int    FASTCALL GetGroupCode(SString & rBuf) const;
	int    SLAPI SetGroupCode(const char *);
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char * pBuf);
	int    SLAPI IsExtRecEmpty() const;
	GoodsPacketKind SLAPI GetPacketKind() const;
	int    SLAPI GetArCode(PPID arID, SString & rCode) const;

	static int SLAPI ValidateAddedMsgSign(const char * pSign, size_t signBufSize);
	//
	// Descr: Флаги функции PPGoodsPacket::PrepareAddedMsgStrings()
	//
	enum {
		pamsfStrictOrder = 0x0001 // Формировать список строк в строгом соответствии с
			// порядком, определенным pSign. Фактически, это означает, что пустые строки
			// так же включаются в список.
	};
	//
	// Descr: Формирует список дополнительных строк по товару в соответствии с правилом,
	//   определенным строкой pSign. Строка правила pSign может содержать буквы A..E, M (дата производства) и
	//   скобки (для объединения нескольких доп строк в одну). Например "ABC", "D(AB)E"
	//
	int    SLAPI PrepareAddedMsgStrings(const char * pSign, long flags, const LDATETIME * pManufDtm, StringSet & rSet);

	Goods2Tbl::Rec   Rec;     //
	GoodsExtTbl::Rec ExtRec;  //
	GoodsStockExt    Stock;   //
	BarcodeArray     Codes;   // Список штрихкодов товара
	ArGoodsCodeArray ArCodes; // Список кодов, сопоставленных с контрагентами
	PPGoodsStruc  GS;         // @TODO Если структура не собственная (GSF_NAMED), то при изменении требует блокировки.
	enum {
		ufDontChgTaxGrp  = 0x0001, // Функция PPObjGoods::PutPacket не должна изменять налоговую группу товара или группы товаров.
		ufChgNamedStruc  = 0x0002, // Функция PPObjGoods::PutPacket должна изменить именованную структуру товара
		ufDontChgImgFlag = 0x0004, // Функция PPObjGoods::PutPacket не должна изменять флаг GF_HASIMAGES
		ufDontChgArCodes = 0x0008, // Функция PPObjGoods::PutPacket не должна изменять список кодов по статьям
		ufDontChgPltList = 0x0010, // Функция PPObjGoods::PutPacket не должна изменять параметры размещения на паллете
	};
	long   UpdFlags;          // @transient Флаги, определяющие правила изменения некоторых полей
	long   ClsDimZeroFlags;   // @transient Флаги обнуляние числовых классификаторов товаров. Используется в
		// специальном случае массового изменения атрибутов товаров (функция PPViewGoods::RemoveAll())
	SString ExtString;        // Дополнительные текстовые поля товара
	SString ExTitles;         // Список наименований дополнительных
		// текстовых полей товара. Используется только для обыкновенных групп.
	PPQuotArray * P_Quots;    // Список котировок товара. Особенность этого поля в том, что функция //
		// PPObjGoods::GetPacket заполняет его, но функция PPObjGoods::PutPacket не сохраняет список в БД.
	GoodsLotExtData * P_Gled; // Только для переноса параметров лотов из одного раздела в другой
	GoodsFilt * P_Filt;       // Используется в пакете альтернативной группы
	ObjLinkFiles LinkFiles;   // @transient
	ObjTagList   TagL;        // @v7.0.11  Список тегов
	ObjIdListFilt GenericList; // @v7.7.12  Список товаров, ассоциированный с данным обобщенным товаром.
		// Используется только для передачи содержимого обобщенного товара между разделами БД.
		// Функция PPObjGoods::GetPacket не загружает данный список.
};
//
// Структура, передаваемая в качестве параметра (PPFilt::Ptr)
// при печати товарных этикеток (PPALDD_GoodsLabel).
//
struct GoodsLabelAlddParam {
	PPID   GoodsID;
	PPID   LocID;
	int    NumCopies;
};

struct PPGoodsReplaceNameParam {
	SLAPI  PPGoodsReplaceNameParam();

	enum {
		fAbbr                   = 0x0001,
		fNameAndAbbr            = 0x0002,
		fDoReplace              = 0x0004,
		fRestoreLastHistoryName = 0x0008
	};
	SString SrchPattern;
	SString RplcPattern;
	PPID   BrandID;        // Брэнд, который следует установить в найденных товарах
	PPID   GoodsGrpID;     // Товарная группа, в которую следует переместить найденные товары
	PPID   ManufID;        // @v8.8.12 Производитель, которого следует установить в найденных товарах
	long   Flags;
};

struct PPSupplDeal {
	int    SLAPI CheckCost(double c) const;
	SString & FASTCALL Format(SString &) const;

	double Cost;       // Контрактная цена
	double UpDev;      // Верхнее отклонение (%)
	double DnDev;      // Нижнее отклонение (%)
	int    IsDisabled; // Блокированная комбинация (ввод строки в документ невозможен) //
};
//
// Descr: Структура, используемая для поиска товара по коду функцией PPObjGoods::SearchByCodeExt()
//
struct GoodsCodeSrchBlock {
	SLAPI  GoodsCodeSrchBlock();
	SLAPI ~GoodsCodeSrchBlock();

	enum {
		fAdoptSearch = 0x0001, // IN
		fWeightCode  = 0x0002, // OUT Весовой код
		fArCode      = 0x0004, // OUT Артикул
		fOwnArCode   = 0x0008, // OUT Собственный артикул
		fGoodsId     = 0x0010, // OUT ИД товара
		fList        = 0x0020, // OUT Список штрихкодов по шаблону
		fUse2dTempl  = 0x0040, // IN  Искать по шаблону 2-мерного штрихкода
		fBc2d        = 0x0080  // OUT Товар найден по шаблону 2d-кода
	};
	char   Code[128];      // IN CONST
	char   RetCode[32];    // OUT
	PPID   ArID;           // IN CONST
	long   Flags;          // IN/OUT
	PPID   GoodsID;        // OUT
	PPID   ScaleID;        // OUT
	double Qtty;           // OUT
	BarcodeArray * P_List; // OUT
	Goods2Tbl::Rec Rec;    // OUT
};
//
// Флаги реализации функции PPObjGoods::CheckForFilt
//
#define GOCFIF_GROUP  0x0001 // Не проверять на принадлежность группам
#define GOCFIF_BCLEN  0x0002 // Не проверять длины штрихкодов
#define GOCFIF_ARCODE 0x0004 // Не проверять наличие кода по статье GoodsFilt::CodeArID
#define GOCFIF_SYSJ   0x0008 // Не проверять условия фильтра по системному журналу
#define GOCFIF_TAG    0x0010 // @v7.7.7 Не проверять на соответствие фильтру по т'гам
//
// Флаг подстановки товара. Если идент товара содержит этот флаг, то этот идент в действительности
// ссылается на какой-то иной объект данных, определенный типом подстановки.
//
#define GOODSSUBSTMASK  0x40000000L
//
// Флаг динамического обобщения товаров. Если согласно маске дин обобщения существует
// набор классицированных товаров, подходящих под это обобщение, но при этом не существует
// реального обобщенного товара, соотвествующего такой маске, то создается искусственный
// идентификатор равный одному из товаров обобщения с наложением маски DYNGENGOODSMASK.
//
#define DYNGENGOODSMASK 0x20000000L
//
// Descr: Специализированная структура для формирования данных DL600 UhttGoodsArCode
//
struct UhttGoodsArCodeIdent {
	PPID   GoodsID;
	PPID   ArID;
	char   Name[128];
	char   Code[32];
};

class PPObjGoods : public PPObject {
public:
	//
	// Descr; Результаты диагностики корректности рознчного штрихкода (EAN13, EAN8, UPCA, UPCE).
	//
	enum {
		cddOk = 0,                  //
		cddEmpty = 1,               // Пустой код
		cddNonDigit,                // Код содержит нецифровые символы
		cddInvCheckDigEan13,        // Неверная контрольная цифра EAN13
		cddInvCheckDigUpca,         // Неверная контрольная цифра UPCA
		cddInvCheckDigEan8,         // Неверная контрольная цифра EAN8
		cddInvCheckDigUpce,         // Неверная контрольная цифра UPCE
		cddExtraDigitEan13,         // Лишняя цифра в конце EAN13
		cddExtraDigitEan8,          // Лишняя цифра в конце EAN8
		cddEan14,                   // EAN14
		cddUnknownFormat,           // Не известный формат
		cddUpcaAsEan13,             // Код UPCA в формате EAN13
		cdd_ExtraDigitUpca,         // Возможно, лишняя цифра в конце UPCA
		cdd_UpcaWoCheckDig,         // Возможно, UPCA без контрольной цифры
		cdd_Ean13WoCheckDig,        // Возможно, EAN13 без контрольной цифры
		cdd_Ean8WoCheckDig,         // Возможно, EAN8 без контрольной цифры
		cdd_UpcaWoLead0,            // UPCA без лидирующего нуля //
		cdd_UpcaWoCheckDigAndLead0, // Возможно, UPCA без лидирующего нуля и без контрольной цифры
		cdd_UpceWoLead0,            // Возможно, UPCE без лидирующего нуля //
		cdd_UpceWoCheckDig,         // Возможно, UPCE без контрольной цифры
		cdd_UpceWoCheckDigAndLead0, // Возможно, UPCE без лидирующего нуля и без контрольной цифры
		cddEan8AsEan13,             // Код EAN8 в формате EAN13
		cddExtraZeroEan8,           // Код EAN8 с лишним ведущим нулем
		cddExtraZeroUpce,           // Код UPCE с лишним ведущим нулем
		cddFreePrefixEan13,         // Код EAN13 со свободным префиксом (2)
		cddGuaPrefix                // Код содержит один из допустимых префиксов, ассоциированных с текущей глобальной учетной записью
	};

	static GoodsPacketKind SLAPI GetRecKind(const Goods2Tbl::Rec * pRec);
	static int SLAPI ReadConfig(PPGoodsConfig *);
	static int SLAPI EditConfig();
	static int SLAPI ReadGoodsExTitles(PPID grpID, SString & rBuf);

	struct ExtUniteBlock {
		SLAPI  ExtUniteBlock();

		enum {
			fReverseOnStart  = 0x0001, // Идентификатор srcID переданный в функцию ReplaceGoods следует трактовать
				// как DestID (то есть, товар, который должен исчезнуть, будучи замененным на выбранный).
			fUseSpcFormEgais = 0x0002, // В качестве диалога объединения применять специальную форму,
				// позволяющую фильтровать товары по критериям ЕГАИС.
			fOnce            = 0x0004  // После завершения объединения одной пары товаров возвращать
				// управление вызывающей функции (в противном случае будет предложено повторить процедуру
				// для иной пары товаров).
		};
		long   Flags;
		PPID   DestID;   // Товар, все ссылки на который перенесены на ResultID (и, возможно, удаленный)
		PPID   ResultID; // Товар, который заместил собой все ссылки на DestID
	};

	static int SLAPI ReplaceGoods(PPID srcID, ExtUniteBlock * pEub);
	static int SLAPI GenerateOwnArCode(SString & rCode, int use_ta);
	static int SLAPI DiagBarcode(const char * pBarcode, int * pDiag, int * pStd, SString * pNormalizedCode);
	static int SLAPI GetBarcodeDiagText(int diag, SString & rBuf);
	static int FASTCALL HasUndupNameSuffix(const SString & rBuf, uint * pPos);
	//
	// Descr: Ищет в конце строки rBuf суффикс вида #99, испольуемый для обхода требования уникальности имени записи.
	//   Если находит, то убирает его (и предшествующий пробел).
	//
	static int FASTCALL RemoveUndupNameSuffix(SString & rBuf);
	// non-static
	int    SLAPI WriteConfig(const PPGoodsConfig * pCfg, const SString * pGoodsExTitles, int use_ta);

	SLAPI  PPObjGoods(void * extraPtr = 0);
	SLAPI ~PPObjGoods();
	virtual int  SLAPI Search(PPID id, void * b = 0);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);

	const  PPGoodsConfig & SLAPI GetConfig() const;
	//
	// Результирующие флаги функции IsPacketEq
	//
	enum {
		pefCodeEq       = 0x0001, // Список кодов не изменился //
		pefRecFlagsOnly = 0x0002  // Во всем пакете изменились только флаги
	};

	int    SLAPI IsPacketEq(const PPGoodsPacket & rS1, const PPGoodsPacket & rS2, long options, long * pResultFlags);
	int    SLAPI Edit(PPID *, GoodsPacketKind, long parentID, long clsID, const char * bcode);
	int    SLAPI EditClsdGoods(PPGoodsPacket *, int modifyOnlyExtRec);
	int    SLAPI EditVad(PPID goodsID);
	int    SLAPI EditArCode(PPID goodsID, PPID arID, int ownCode);
	//
	// Descr: Если в базе данных существует запись товара с именем, совпадающим с rBuf и
	//   идентификатором, отличным от id, то функция добавляет в конец rBuf символ # с последющим
	//   номером.
	//   При замене наименования функция сначала проверяет наличие аналогичного суффикса в конце
	//   rBuf и, если находит, то убирает его (PPObjGoods::RemoveUndupNameSuffix()).
	//   Кроме того, результируюая длина наименования проверяется на непревышение
	//   sizeof(Goods2Tbl::Rec::Name)-1 (если результат выходит за эту границу, то
	//   обрезаются избыточные символы.
	// Returns:
	//   >0 - функция осуществила замену наименования и поместила результат обратно в rBuf //
	//   <0 - заданное наименование не встречается в базе данных (или принадлежит записе с идентификатором id)
	//
	int    SLAPI ForceUndupName(PPID id, SString & rBuf);
	int    SLAPI SearchUhttInteractive(SString & rName, SString & rBarcode, UhttGoodsPacket * pResultItem);
	int    SLAPI ViewUhttGoodsRestList(PPID goodsID);
	//
	// Descr: Выводит диалог редактирования версии histID пакета товара.
	//
	int    SLAPI ViewVersion(PPID histID);
	//
	// Descr: Изменяет некоторые из флагов записи товара с идент goodsID.
	//   Устанавливаемые флаги указываются параметром setF, снимаемые - resetF.
	//   Список изменяемых флагов:
	//   GF_NODISCOUNT
	//   GF_PASSIV
	//   GF_PRICEWOTAXES
	//   GF_HASIMAGES
	//
	int    SLAPI UpdateFlags(PPID goodsID, long setF, long resetF, int use_ta);
	int    SLAPI AddBySample(PPID *, PPID sampleID);
	//
	// Методу PPObjGoods::Selector в качестве дополнительного
	// параметра передается ID родительской группы.
	// Если этот параметр меньше нуля, то выбираются только те
	// товары, которые есть в наличии на текущей позиции.
	//
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr);
	enum {
		selfByName       = 0x0001, // В списке показывать наименования //
		selfHidePassive  = 0x0002, // Не показывать пассивные товары
		selfForcePassive = 0x0004, // Показывать пассивные товары
			// Если !selfHidePassive && !selfForcePassive, то функция выясняет
			// показывать или нет пассивные товары по флагу GCF_DONTSELPASSIVE конфигурации товаров.
			// Если установлены оба флага, то работает так, как будто установлен только selfHidePassive.
		selfUseMatrix    = 0x0008, // Применять товарную матрицу
		selfExtLongAsBrand = 0x0010 // extLong - ид Бренда
	};
	//
	// Descr: Формирует ListBoxDef посредством выборки товаров (либо других объектов, управляемых
	//   классом PPObjGoods).
	// ARG(pDef     IN): @#{vptr0} Указатель на внешний (требующий изменения) экземпляр ListBoxDef.
	//   Если 0, то функция создает новый экземпляр, если !0, то использует pDef
	// ARG(parentID IN): Ид родительской группы
	// ARG(options  IN): Флаги (PPObjGoods::selfXXX)
	// ARG(extraPtr  IN): Дополнительный параметр конкретизирующй вид объекта данных.
	//   Фактически, применяется только для PPOBJ_TRANSPORT
	// ARG(locID    IN): Ид склада, используемый при выборке только тех товаров, которые
	//   (options & PPObjGoods::selfUseMatrix) или при выборке только тех товаров, которые
	//   есть на текущем остатке.
	//   Если locID == 0, но определнный склад необходим, то полагает locID == LConfig.Location.
	// ARG(mtxLocID IN): Ид склада, используемый для установки ограничения по матрице
	//   (options & PPObjGoods::selfUseMatrix). Если mtxLocID == 0 && (options & PPObjGoods::selfUseMatrix),
	//   то применяется матрица по складу locID.
	//   Если опция PPObjGoods::selfUseMatrix не установлена, то параметр игнорируется.
	//
	ListBoxDef * SLAPI _Selector2(ListBoxDef * pDef, long parentID, long options, void * extraPtr, PPID locID, PPID mtxLocID);
	StrAssocArray * SLAPI CreateListByPrice(PPID loc, double price);
	StrAssocArray * SLAPI CreateListByList(const PPIDArray * pIdList);
	//
	// Descr: Возвращает иерархию товара или группы с идентификатором goodsID.
	//   Иерархия возвращается в виде списка первый элемент которого соответствует самому верхнему уровню иерархии,
	//   которой подчинен элемент goodsID.
	//   Сам элемент goodsID является последним членом списка //
	//
	int    SLAPI GetHierarchy(PPID grpID, StrAssocArray * pList);
	//
	// Descr: вызывает диалог выбора товара вместо висячего идентификатора rmvdGoodsID.
	//   Перед выводом диалога, если не указан extGoodsID, функция пытается определить не
	//   был ли товар rmvdGoodsID объединен с каким-либо другим и, если да, то предлагает
	//   выбрать именно тот другой товар.
	//   Если указан extGoodsID, то функция сразу подставляет в комбо-бокс выбора товара
	//   extGoodsID (использование extGoodsID бывает оправданно в случае, если предыдущий
	//   выбор был, по мнению вызывающей функции, неудачным, но при этом не хочется терять
	//   выбранную до этого пользователем группу и позицию в списке товаров).
	// Returns:
	//   >0 - пользователь выбрал замещающий товар (его идентификатор возвращается по
	//        указателю pReplaceGoodsID)
	//   <0 - либо товар rmvdGoodsID существует в базе данных, либо пользователь
	//        отказался выбирать замещающий товар
	//    0 - ошибка
	//
	int    SLAPI SelectGoodsInPlaceOfRemoved(PPID rmvdGoodsID, PPID extGoodsID, PPID * pReplaceGoodsID);
	int    SLAPI SelectGoodsByBarcode(int initChar, PPID arID, Goods2Tbl::Rec *, double *, SString * pRetCode);
	int    SLAPI GetGoodsByBarcode(const char * pBarcode, PPID arID, Goods2Tbl::Rec * pRec, double * pQtty, SString * pRetCode);
	int    SLAPI GetParentID(PPID, PPID * pParentID);
	int    SLAPI SearchByName(const char * pName, PPID * pID, Goods2Tbl::Rec * pRec = 0);
	int    SLAPI SearchMaxLike(PPGoodsPacket *, PPID *);
	//
	// Descr: Ищет товар, имеющий штрихкод pCode. Если штрихкод найден, то по указателям
	//   pBcRec и pGoodsRec возвращается соответственно запись штрихкода и товара.
	//   Если adoptSearching != 0, то функция пытается искать по вариациям заданного
	//   штрихкода: если коды задаются без контрольной цифры и длина pCode == 13, 12 или 8,
	//   то отбрасывает последнюю цифру; если ведущие символы pCode нули, то поочередно
	//   отбрасывает каждый из нулей и пытается найти получившийся код.
	// Returns:
	//   > 0 - штрихкод найден
	//   < 0 - штрихкод не найден
	//     0 - ошибка
	//
	int    SLAPI SearchByBarcode(const char * pCode, BarcodeTbl::Rec * pBcRec, Goods2Tbl::Rec * pGoodsRec = 0, int adoptSearching = 0);
	int    SLAPI SearchBy2dBarcode(const char * pCodeLine, BarcodeTbl::Rec * pRec, Goods2Tbl::Rec * pGoodsRec);
	//
	// Descr: Определяет является ли код pCode весовым кодом какого-либо товара.
	//
	int    SLAPI IsScaleBarcode(const char * pCode, PPID * pScaleID, PPID * pGoodsID, double * pQtty);
	int    SLAPI GenerateScaleBarcode(PPID goodsID, PPID scaleID, SString & rCode);
	//
	// Descr: Расширенная функция поиска товара по коду.
	//   В перспективе должна заменить PPObjGoods::SearchByBarcode
	//
	int    SLAPI SearchByCodeExt(GoodsCodeSrchBlock * pBlk);
	int    SLAPI CheckBarcodeList(const PPGoodsPacket * pPack);
	int    SLAPI GenGroupCode(int numDigits, SString & rBuf);
	//
	// Descr: Утилитная функция, используемая в диалогах.
	//   Предлагает выбрать шаблон штрихкода для генерации кода.
	//
	int    SLAPI SelectBarcode(int kind, PPID parentID, SString & rBuf);
	//
	// Descr: Позволяет получить информацию о стране происхождения товара
	// Returns:
	//   manufacturer country name by pRec->ManufID in buf pCountryName
	//   if pRec == 0 then
	//       uses Search(goodsID)
	//   else
	//       parameter goodsID ignored
	//   if data obtained and Person(pRec->ManufID).Status == PPPRS_COUNTRY then
	//       *pCountryID = pRec->ManufID
	//       returns 2
	//   if data obtained and Person(pRec->ManufID).Status != PPPRS_COUNTRY then
	//       *pCountryID = City(Location(Person(pRec->ManufID).MainLoc).City).Country
	//       returns 1
	//   if data not obtained then
	//       returns -1
	//   in case of error
	//       returns 0
	//
	int    SLAPI GetManufCountry(PPID goodsID, const Goods2Tbl::Rec * pRec, PPID * pCountryID, PPCountryBlock * pBlk);
	int    SLAPI ReadBarcodes(PPID goodsID, BarcodeArray & rCodeList);
	//
	// Descr: возвращает один штрихкод для товара с ИД = id.
	//   Если для заданного товара существует только один штрих-код,
	//   то он и возвращается. Если существует несколько штрих-кодов,
	//   то возвращается тот, которому соответствует одна единица
	//   товара, или, если такого кода нет, то самый первый.
	//   Если для товара нет штрих-кода, то barcode[0] = 0.
	//
	int    SLAPI GetSingleBarcode(PPID id, char * barcode, size_t bufLen); // @obsolete
	int    SLAPI GetSingleBarcode(PPID id, SString & rBuf);
	//
	// Descr: Извлекает посредством кэша один штрихкод для товара с ИД = id.
	//   Правила извлечение то же, что и в функции GetSingleBarcode().
	//
	int    SLAPI FetchSingleBarcode(PPID id, SString & rBuf);
	//
	// Descr: возвращает артикул товара, полученный при импорте в Papyrus.
	//
	// @v9.1.4 int    SLAPI GetGoodsArticle(PPID id, PPID * pArticle);
	//
	// Descr: поиск товара по артикулу, полученному при импорте в Papyrus.
	//
	int    SLAPI SearchByArticle(PPID article, BarcodeTbl::Rec * pRec);
	//
	// Descr: Флаги функции PPObjGoods::GetRetailGoodsInfo
	//
	enum {
		rgifUseQuotWTimePeriod = 0x0001, // Использовать котировки с временным периодом действия //
		rgifUseBaseQuotAsPrice = 0x0002, // Если для товара есть базовая котировка, то для определения //
			// цены реализации использовать ее, в противном случае - учетную цену реализации.
			// Если этот флаг не установлен, то учетная цена реализации используется с приоритетом.
		rgifAllowUnlimWoQuot   = 0x0004, // Если нелимитированный товар не имеет котировки, то
			// не инициировать ошибку, а вернуть -2 (как для обычного товара, не имеющего цены).
		rgifConcatQttyToCode   = 0x0008, // Для весового штрихкода к этому штрихкоду добавляется в конец
			// количество, заданное в структуре pInfo.
		rgifUseInBarcode       = 0x0010, // Использовать штрихкод, заданный в структуре pInfo.
		rgifUseOuterPrice      = 0x0020, // @v8.0.12 Предписывает использовать OuterPrice в качестве цены.
		rgifPriceOnly          = 0x0040  // @v8.6.8  Функция рассчитывает только цену (для ускорения)
 	};
	//
	// Descr: Возвращает информацию о товаре, необходимую для продажи
	//   товара через кассу, печати этикетки и пр.
	// ARG(goodsID IN): ИД товара, по которому необходимо получить данные
	// ARG(locID   IN): ИД склада, в привязке к которому необходимы данные по ценам и сроку голности
	// ARG(pEqBlk  IN):
	// ARG(arID    IN): ИД статьи в привязке к которой необходимо извлекать котировку (если цена
	//   определяется по котировке).
	// ARG(pInfo  OUT): указатель на экземпляр структуры RetailGoodsInfo
	//   Перед вызовом функции никакие поля этой структуры заполнять не надо.
	//   Перед обработкой вся струкутра функцией обнуляется.
	// ARG(flags   IN): Опции функции. См. примечания к rgifXXX-флагам выше.
	// Returns:
	//   >0 - информация успешно извлечена
	//   0  - ошибка
	//   -1 - не найден товар с ИД goodsID
	//   -2 - не найдено ни одного лота для указанного товара (поля Expiry, Cost, Price,
	//        LotID, BillDate, BillCode, Serial, Qtty, PhQtty, UnitPerPack не заполнены)
	//
	int    SLAPI GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk, PPID arID, double qtty, RetailGoodsInfo * pInfo, long flags);
	int    SLAPI GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk, PPID arID, LDATETIME actualDtm, double qtty, RetailGoodsInfo * pInfo, long flags);
	//
	// Descr: Упрощенная версия GetRetailGoodsInfo с нулевыми значениями параметров: pEqBlk, arID, qtty, flags.
	//
	int    SLAPI GetRetailGoodsInfo(PPID goodsID, PPID locID, RetailGoodsInfo * pInfo);
	int    SLAPI GetBarcodeByTemplate(PPID grp, const char * pTempl, char * pBuf);
	//
	// Descr: Удаляет из пакета товара штрихкоды, для которых есть дубликаты в базе данных
	//
	int    SLAPI RemoveDupBarcodes(PPGoodsPacket * pPack, ObjTransmContext * pCtx);
		// @<<PPObjGoods::AcceptPacket, @<<PPDS_CrrBillItem::AcceptListItem
	//
	// Descr: Удаляет из пакета товара артикулы, для которых есть дубликаты в базе данных
	//
	int    SLAPI RemoveDupArCodes(PPGoodsPacket * pPack, ObjTransmContext * pCtx);
	int    SLAPI AssignGoodsToAltGrp(PPID goodsID, PPID grp, long innerNum, int use_ta);
	//
	// Descr: проверяет товар на соответствие фильтру.
	//   Если параметр id == 0, то проверяется запись, находящаяся //
	//   в рабочем буфере, в противном случае проверяется запись по
	//   заданному идентификатору.
	// ARG(pFilt IN): Фильтр, которому должен соответствовать товар
	// ARG(id    IN): Идентификтор проверяемого товара. Если id == 0, то
	//   проверяется запись, находящаяся в буфере обекта PPObjGoods::P_Tbl
	// ARG(implFlags IN): GOCFIF_XXX Флаги реализации. Установка определенных флагов
	//   позволяет избежать дорогостоящих проверок если по мнению вызывающей функции
	//   эти проверки избыточны
	// Returns:
	//   >0 - Если товар удовлетворяет всем критериям фильтра
	//   0  - в противном случае
	//
	int    SLAPI CheckForFilt(const GoodsFilt * pFilt, PPID id, long implFlags = 0);
	//
	// Descr: Проверяет валидность группы parentID, которой принадлежит товар.
	//   Товар может принадлежать только обыкновенной группе (Kind == PPGDSK_GROUP && !(Flags & GF_FOLDER|GF_ALTGROUP))
	// Returns:
	//   >0 - parentID является правильным идентификатором группы, которой может принадлежать товар.
	//   <0 - parentID не найден
	//   0  - parentID не является группой, которой может принадлежать товар.
	//
	int    SLAPI ValidateGoodsParent(PPID parentID);
	//
	// Descr: проверяет товар id на принадлежность группе grpID.
	//
	int    SLAPI BelongToGroup(PPID id, PPID grpID, PPID * pSubGrpID = 0);
	int    SLAPI GetPhUPerU(PPID goodsID, PPID * pPhUnitID, double * pPhUPerU);
		// @>>PPObjGoods::GetPhUPerU(const Goods2Tbl::Rec *, PPID *, double *)
	int    SLAPI GetPhUPerU(const Goods2Tbl::Rec * pRec, PPID * pPhUnitID, double * pPhUPerU);
	int    SLAPI IsAltGroup(PPID grpID); // @>>GoodsCore::IsAltGroup
	int    SLAPI IsTempAltGroup(PPID grpID); // @>>GoodsCore::IsTempAltGroup
	int    SLAPI IsDynamicAltGroup(PPID grpID); // @>>GoodsCore::IsDynamicAltGroup
	int    SLAPI SupplyAddingToAltGrp(PPID id, int use_ta = 1);
	//
	// Descr: Ищет структуру товара goodsID, относящуюся к динамическому обобщению
	//   которому (возможно) принадлежит заданный товар.
	// ARG(goodsID    IN): Товар, для которого ищется альтернативная структура
	// ARG(pDynGenID OUT): @#{vptr0} Указатель, по которому в случае успеха, присваивается //
	//   ИД обобщения.
	// ARG(pStrucID  OUT): @#{vptr0} Указатель, по которому в случае успеха, присваивается //
	//   ИД структуры.
	// Returns:
	//   >0 - найдена структура, относящаяся к динамическому обобщению, к которому относится goodsID
	//   <0 - искомая структура не обнаружена
	//   0  - ошибка
	//
	int    SLAPI GetAltGoodsStrucID(PPID goodsID, PPID * pDynGenID, PPID * pStrucID);
	int    SLAPI LoadGoodsStruc(const PPGoodsStruc::Ident * pIdent, PPGoodsStruc * pGs);
	int    SLAPI LoadGoodsStruc(const PPGoodsStruc::Ident * pIdent, TSCollection <PPGoodsStruc> & rGsList);
	int    SLAPI EditGoodsStruc(PPID);
	int    SLAPI GetValueAddedData(PPID, PPGoodsPacket *);
	int    SLAPI InitPacket(PPGoodsPacket *, GoodsPacketKind, PPID parentID, PPID clsID, const char * pBarCode);
	int    SLAPI ValidatePacket(const PPGoodsPacket * pPack);
	//
	// Descr: Опции функции PPObjGoods::GetPacket
	//
	enum {
		gpoSkipQuot = 0x0001 // Не загружать котировки.
	};

	int    SLAPI GetPacket(PPID id, PPGoodsPacket * pPack, long options);
	int    SLAPI PutPacket(PPID * pID, PPGoodsPacket * pPack, int use_ta);
	int    SLAPI SetupAttrByTextDescr(PPID id, const char * pLine, int use_ta);
	//
	// Descr: Специализированная функция, изменяющая наименование и сокращенние записи товара с идентификатором id
	//   на pNewName. При необходимости pNewName модифицируется вызовом PPObjGoods::ForceUndupName() во избежании
	//   ошибки дублирования имени.
	//
	int    SLAPI UpdateName(PPID id, const char * pNewName, int use_ta);
	//
	// Descr: ищет товар по параметрам записи расширения pExtRec (pExtRec->GoodsID игнорируется)
	//   Если товар найден, то возвращает значение больше нуля. Если товар не найден и параметр
	//   createIfNExists != 0 то пытается создать новый товар, полагаясь только на информацию
	//   в записи pExtRec.
	//
	int    SLAPI GetGoodsByExt(const GoodsExtTbl::Rec * pExtRec, PPID * pGoodsID, int createIfNExists, int use_ta);
	//
	// Descr: Извлекает через кэш запись товара goodsID и, если это удалось сделать, то
	//   проверяет, установлен ли в записи товара флаг flag. Если установлен, то возвращает значение >0.
	// Returns:
	//   >0 - запись для товара goodsID найдена и в поле Flags флаг flag установлен.
	//   0  - либо запись goodsID не найдена, либо в поле Flags флаг flag не установлен.
	//
	int    SLAPI CheckFlag(PPID goodsID, long flag);
	int    SLAPI IsGeneric(PPID goodsID); // @>>PPObjGoods::CheckFlag
	int    SLAPI IsAsset(PPID goodsID);   // @>>PPObjGoods::CheckFlag
	int    SLAPI IsAssetType(PPID goodsTypeID);
	//
	// Descr: Добавляет в список pList товары, принадлежащие обобщению genID.
	//   Список pList предварительно не очищается, а новые элементы добавляются в ного методом LongArray::addUnique.
	//
	int    SLAPI GetGenericList(PPID genID, PPIDArray * pList);
	int    SLAPI GetAltGenGoodsList(PPID goodsID, int kind, RAssocArray * pList);
	int    SLAPI GetStrucSubstList(PPID goodsID, RAssocArray * pList);
	//
	// Descr: Возвращает список допустимой подстановки вместо товара goodsID.
	//   В зависимости от параметра substStrucOnly и конфигурации документов (PPBillConfig::GoodsSubstMethod)
	//   используется либо подстановка по обобщенному товару либо по подстановочной структуре.
	//   Результирующий массив rList предварително очицается функцией.
	//   Результат заносится в массив в виде списка ассоциаций {GoodsID, Qtty}, где
	//     GoodsID - ид товара, который может быть использован вместо goodsID
	//     Qtty    - количество товара GoodsID которое необходимо использовать
	//               для компенсации дефицита одной единицы товара goodsID.
	// Returns:
	//   >0 - найден по крайней мере один товар, который может быть подставлен вместо goodsID
	//   <0 - не найдено ни одного варианта подстановки
	//   0  - ошибка
	//
	int    SLAPI GetSubstList(PPID goodsID, int substStrucOnly, RAssocArray & rList);
		// @>>PPObjGoods::GetAltGenGoodsList
		// @>>PPObjGoods::GetStrucSubstList
	int    SLAPI BelongToGen(PPID goodsID, PPID * pGenID, ObjAssocTbl::Rec * = 0);
	int    SLAPI AssignGoodsToGen(PPID goodsID, PPID genID, int abbr, int use_ta);
	int    SLAPI RemoveGoodsFromGen(PPID goodsID, PPID genID, int use_ta);
	//
	// Descr: извлекает запись о товаре с использованием кэша.
	//   В записи инициализированы следующие поля - ID, ParentID, UnitID,
	//   TaxGrpID, GoodsType, Flags (все флаги корректно установлены).
	//   Поля TaxGrpID, GoodsType содержат корректные значения с
	//   учетом наследования соответствующих характеристик из групп.
	//
	int    SLAPI Fetch(PPID, Goods2Tbl::Rec *);
	//
	// Descr: Извлекает через кэш наименование товара goodsID.
	// Returns:
	//   >0 - запись с идентификатором goodsID найдена - наименование скопировано в rBuf
	//   <0 - запись с идентификатором goodsID не найдена - в rBuf скопирована строка id={goodsID}.
	//        Если goodsID == 0, то буфер rBuf обрезается до нулевой длины.
	//    0 - ошибка
	//
	int    SLAPI FetchNameR(PPID goodsID, SString & rBuf);
	int    SLAPI FetchTax(PPID goodsID, LDATE, PPID opID, PPGoodsTaxEntry *);
	int    SLAPI FetchCls(PPID goodsID, Goods2Tbl::Rec * pRec, PPGdsClsPacket * pGcPack);
	int    SLAPI MultTaxFactor(PPID goodsID, double * pVal);
	//
	// Descr: Извлекает запись единицы измерения unitID из кэша.
	//
	int    SLAPI FetchUnit(PPID unitID, PPUnit * pUnitRec); // @>>PPObjUnit::Fetch
	int    SLAPI GetStockExt(PPID, GoodsStockExt * pExt, int useCache = 0);
	//
	// Descr: If(withOrWithout == 1 /with/): добавляет к цене поступления pCost
	//   величину НДС, Предполагается, что значение pCost не содержит НДС.
	//       If(withOrWithout == 0 /without/): снимает с цены поступления pCost
	//   величину налогов. Предполагается, что значение pCost содержит все налоги
	//   кроме налога с продаж.
	//       Parameter vatFreeSuppl: { @before @v4.2.11 используется только при withOrWithout == 0.}
	//   Если vatFreeSuppl > 0, то функция полагает, что НДС нулевой.
	//   Расчет налогов ведется исходя из налоговых групп lotTaxGrpID или
	//   goodsTaxGrpID (если lotTaxGrpID == 0, то используется goodsTaxGrpID).
	// @CAUTION
	//   Вызовы функции с противоположными значениями параметра withOrWithout
	//   в общем случае не являются взаимно обратимыми
	//
	int    SLAPI AdjCostToVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate,
		double qtty, double * pCost /* In, Out */, int withOrWithout, int vatFreeSuppl = -1);
	int    SLAPI CalcCostVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate,
		double qtty, double cost, double * pVatSum, int withOrWithout, int vatFreeSuppl = -1, int roundPrec = 2);
	int    SLAPI AdjPriceToTaxes(PPID taxGrpID, double taxFactor, double * pPrice, int exclSTax);
	//
	// Descr: определяет является ли товар id1 совместимым с товаром id2 по единицам измерения.
	//   Если да, то возвращается значение > 0, а по указателю pRatio (если pRatio != 0)
	//   возвращается количество торговых единиц товара id1, эквивалентное
	//   торговой единице товара id2.
	//   Если торговая единица товара id1 является целочисленной и
	//   *pRatio является нецелочисленной величиной, при совместимости
	//   товаров, возвращаемое значение < 0.
	//
	int    SLAPI IsGoodsCompatibleByUnit(PPID id1, PPID id2, double * pRatio);
	//
	// Функции для работы с котировками
	//
	int    SLAPI EditQuotations(PPID goodsID, PPID initLocID, PPID initCurID, PPID initArID, int quotCls, int toCascade = 0, PPID accSheetID = 0);
	int    SLAPI GetQuot(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache = 0);
		// @>>GoodsCore::GetQuot
	int    SLAPI GetQuotExt(PPID goodsID, const QuotIdent &, double cost, double price, double *, int useCache);
	int    SLAPI GetQuotExt(PPID goodsID, const QuotIdent &, double *, int useCache);
	int    SLAPI BelongToMatrix(PPID goodsID, PPID locID);
		// @>>GoodsCore::BelongToMatrix(PPID goodsID, PPID locID)
	//
	// Descr: @todo
	//
	int    SLAPI CheckMatrix(PPID goodsID, PPID locID, PPID opID, PPID billArID);
	int    SLAPI GetMatrixRestrict(PPID goodsID, PPID locID, int srchNearest, PPID * pGoodsGrpID, long * pResult);
	int    SLAPI CheckMatrixRestrict(PPID goodsID, PPID locID, long restrict);
	int    SLAPI GetSupplDeal(PPID goodsID, const QuotIdent & rIdent, PPSupplDeal * pResult, int useCache = 0);
	int    SLAPI SetSupplDeal(PPID goodsID, const QuotIdent & rIdent, const PPSupplDeal * pDeal, int useTa);
	int    SLAPI GetQuotExtByList(const PPQuotArray *, const QuotIdent &, double cost, double price, double *);
	int    SLAPI GetQuotList(PPID goodsID, PPID locID, PPQuotArray & rList); // @>>GoodsCore::GetQuotList
	//
	// Descr: Сохраняет список котировок, ассоциированных с товаром goodsID.
	//   Если pList == 0, то удаляет все котировки, ассоциированные с этим товаром.
	// Remark:
	//   Если pList != 0, то проверяет соответствие pList->GoodsID == goodsID и,
	//   если это равенство не выполняется возвращает 0 и PPErrCode = PPERR_INVQUOTLIST.
	//
	int    SLAPI PutQuotList(PPID goodsID, PPQuotArray * pList, int use_ta);
	int    SLAPI ImportOld(int use_ta); // @v6.1.12 Импорт по устаревшей технологии
	int    SLAPI Import(const char * pCfgName, int analyze, int use_ta);  // @v6.1.12 Импорт по новой технологии
	int    SLAPI ImportQuotOld(int use_ta);
	int    SLAPI ImportQuot(const char * pCfgName, int use_ta);
	//
	// Функции подстановки
	//
	struct SubstBlock {
		SubstBlock()
		{
			THISZERO();
		}
        PPID   ExclParentID;
        PPID   LocID;
        LDATE  Dt;           // @v8.3.3 Дата актуальности. Требуется в некоторых ситуациях
			// (например, подстановка по ставке НДС). Если Dt == 0, то полагается равной текущей системной дате.
		PPID   LotID;        // @v8.3.4 Ид лота. Если !0, то для подстановки характеристики лота
			// функция SubstGoods будет получать непосредственно из этого лота (без оглядки на SupplID, LotTaxGrpID и Dt)
		const  ReceiptTbl::Rec * P_LotRec; // @v8.3.4 Запись лота. Если !0, то используется с приоритетом
			// по сравнению с LotID
	};
	int    SLAPI SubstGoods(PPID srcID, PPID * pDestID, SubstGrpGoods sgg, SubstBlock * pBlk, GoodsSubstList *);
	//int    SLAPI SubstGoods(PPID srcID, PPID * pDestID, SubstGrpGoods, PPID exclParentID, PPID supplID, PPID locID, GoodsSubstList *);
	int    SLAPI GetSubstText(PPID id, SubstGrpGoods, const GoodsSubstList *, SString & rBuf);
	//
	int    SLAPI ReplaceName(PPGoodsPacket *, const PPGoodsReplaceNameParam *);
	int    SLAPI ShowGoodsAsscInfo(PPID goodsID);
	//
	// Descr: Блокирует товар goodsID. Блокировка предотвращает возможность редактирования //
	//   товара другим сеансом.
	//
	int    SLAPI Lock(PPID goodsID);
	//
	// Descr: Снимает блокировку с товара goodsID. После снятия блокировки товар доступен
	//   для редактирования другим сеансом
	//
	int    SLAPI Unlock(PPID goodsID);
	int    SLAPI Helper_Edit(PPID *, PPGoodsPacket *, GoodsPacketKind, int IsNew, int viewOnly = 0);
	int    SLAPI GetRandomIdsAry(int count, PPIDArray * pAry);
	//
	// Descr: Проверяет товар на принадлежность товарной матрице и контрактным ценам поставщика
	//
	int    SLAPI CheckSpecQuot(PPID supplID, PPID goodsID, PPID locID, PPID currID);
	//
	// Descr: Сравнивает записи и возвращает их похожесть в диапазоне [0..1]
	//
	double SLAPI CalcLikeness(const Goods2Tbl::Rec * pRec1, const Goods2Tbl::Rec * pRec2, int * pSwap, long extra);
	int    SLAPI GetOpenedList(PPID locID, const PPIDArray * pOverlapList, UintHashTable & rHash);
	//
	// Descr: Утилитная функция, автоматически расставляющая признак PREFERRED_BARCODE
	//   по всей выборке товаров.
	//
	int    SLAPI SetupPreferredBarcodeTags();
	int    SLAPI GetTagList(PPID goodsID, ObjTagList * pTagList);
	int    SLAPI SetTagList(PPID goodsID, const ObjTagList * pTagList, int use_ta);

	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);

	struct ProcessNameBlock {
		long   Flags;
		SString OrgName;
	};

	int    SLAPI ProcessName(ProcessNameBlock & rBlk, SString & rResult);

	PPObjGoodsStruc GSObj;
	PPObjGoodsTax   GTxObj;
protected:
	PPID   Kind; // PPGDSK_XXX (Initialized by constructor)

	SLAPI  PPObjGoods(PPID objType, void * extraPtr);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket_(int toBuf, PPGoodsPacket * pPack, SBuffer * pBuf);
	int    SLAPI SerializePacket(int dir, PPGoodsPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx, const DBDivPack * pDestDbDiv);
private:
	friend class GoodsCache;
	friend int FASTCALL GetGoodsNameR(PPID goodsID, SString & rBuf);

	SLAPI  PPObjGoods(SCtrLite);
	virtual const char * SLAPI GetNamePtr();
	void   SLAPI InitInstance(SCtrLite sctr, void * extraPtr);
	int    SLAPI MakeReplaceStr(const PPGoodsPacket *, const PPGoodsReplaceNameParam *, const char * pFragment, SString &);
	int    SLAPI Helper_ReplaceName(PPGoodsPacket *, const PPGoodsReplaceNameParam *, char *, size_t);
	int    SLAPI Helper_WriteConfig(const PPGoodsConfig * pCfg, const SString * pGoodsExTitles, PPOpCounterPacket * pOwnAcCntr, int rebuild, int use_ta);
	//
	// Descr: Записывает принятый из другого раздела пакет в БД.
	//
	int    SLAPI AcceptPacket(PPID * pID, PPGoodsPacket * pPack, ObjTransmContext * pCtx);
		// @<<PPObjGoods::Write
	int    SLAPI AcceptQuot(PPID * pID, PPGoodsPacket * pPack, ObjTransmContext * pCtx);
		// @<<PPObjGoods::AcceptPacket
	int    SLAPI Helper_ImportHier(PPIniFile *, DbfTable *, PPID defUnitID, HierArray * pHierList);
		// @<<PPObjGoods::Import
	int    SLAPI Helper_AdjCostToVat(PPID lotTaxGrpID, PPID goodsTaxGrpID, LDATE lotDate,
		double qtty, double * pCost /* In, Out */, double * pVatSum, int withOrWithout, int vatFreeSuppl, int roundPrec);
	int    SLAPI Unite(PPID destID, PPID srcID); // @<<PPObjGoods::HandleMsg
	int    SLAPI Helper_EditGoodsStruc(PPID goodsID, int isDynGen); // @<<PPObjGoods::EditGoodsStruc
	int    SLAPI AddDefaultBarcode(PPGoodsPacket * pPack);
	int    SLAPI Helper_SearchMaxLikeByBarcode(const char * pCode, PPID * pID);
	int    SLAPI Helper_GetQuotExt(PPID goodsID, const QuotIdent & rQi, double cost, double price, double * pResult, int useCache);
	int    SLAPI Helper_GetRetailGoodsInfo(PPID goodsID, PPID locID, const RetailPriceExtractor::ExtQuotBlock * pEqBlk,
		PPID arID, LDATETIME actualDtm, double qtty, RetailGoodsInfo * pInfo, long flags);
	PPGoodsConfig Cfg;
	SCtrLite Sctr;
	int16  EcoSel;         // if !0 && !__WIN32__ then 'exists only' selection uses DBQuery, not SArray
	int16  Reserve;        // @alignment
	PPObjPerson * P_PsnObj;
	PPObjGoodsType GtObj;  //
	PPIDArray Locks;
	TLP_MEMB(HistGoodsCore, HistGoods);
public:
	//TLP_MEMB(GoodsCore, tbl);
	TLP_MEMB(GoodsCore, P_Tbl);
	void * ExtraPtr; // @v8.9.10 long Extra --> void * ExtraPtr
};
//
// Descr: Контекст разрешения формул.
//
class GoodsContext : public ExprEvalContext {
public:
	struct Param {
		SLAPI  Param();

		double Par1;
		double Par2;
		double Par3;
		PPID   TSessID;
		PPID   GoodsID;
		PPID   PrevGoodsID;
		PPID   LocID;
		PPID   ArID;
		PPID   CurID;
		double Qtty; // @v8.8.6
		ReceiptCore::LotDimensions LotDim; // @v8.9.12
	};
	enum {
		funcVat       = EXRP_EVAL_FIRST_FUNC +  1, // vat(x)
		funcVatPlus   = EXRP_EVAL_FIRST_FUNC +  2, // vatplus(x)
		funcVatMinus  = EXRP_EVAL_FIRST_FUNC +  3, // vatminus(x)
		funcGetQuot   = EXRP_EVAL_FIRST_FUNC +  4, // getquot(qk_symb)
		funcGetQuotCP = EXRP_EVAL_FIRST_FUNC +  5  // getquotcp(qk_symb, cost, price)
	};

	SLAPI  GoodsContext(GdsClsCalcExprContext * pCtx);
	SLAPI  GoodsContext(Param & rParam);
	SLAPI  GoodsContext(const PPTransferItem * pTi, const PPBillPacket * pBillPack);
	SLAPI ~GoodsContext();
	int    SLAPI SetParam(const Param & rP);
	const  Param & GetParam() const;
	virtual int SLAPI Resolve(const char *, double *);
	virtual int SLAPI IsFunc(const char * pSymb, int * pFuncId);
	virtual int SLAPI ResolveFunc(int funcId, FC & rFc);
private:
	void   SLAPI Init();
	int    SLAPI IsRef(const char *, size_t * pPos, SString & rRef);
	int    SLAPI ResolveGoodsAttr(const SString & rSymb, PPID goodsID, double * pVal);
	int    SLAPI ResolveRefQtty(PPID goodsID, int cbItemRef, int isPhQtty, double * pVal);
	int    SLAPI AllocGoodsStruc();

	PPGoodsPacket  * P_Pack;
	PPGdsClsPacket * P_ClsPack;
	const  PPGoodsStruc * P_Gs;
	const  PPBillPacket * P_BillPack;
	const  PPTransferItem * P_Ti;
	PPObjGoods GObj;
	/*
	double Par1;
	double Par2;
	double Par3;
	PPID   TSessID;
	*/
	PPObjTSession * P_TSesObj;
	PPGoodsStruc ProperGs; // Внутренний экземпляр структуры товара на тот случай,
		// если из-вне структура передана не была, но может быть получена
		// из контекста.

	//PPID   GoodsID;
	//PPID   PrevGoodsID;
	Param  P;
};
//
//
// @ModuleDef(PPObjGoodsInfo)
//
#define GIF_SHOWLOTS 0x00000001L

struct PPGoodsInfo2 {      // @persistent @store(Reference2Tbl+)
	long   ObjType;
	long   ObjID;
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[48];    // @reserve
	long   LocID;
	long   TouchScreenID;
	long   LabelPrinterID;
	long   Flags;          //
	long   Reserve2[2];    // @reserve
};

DECL_REF_REC(PPGoodsInfo);
//
// Descr: Параметры запуска инфокиоска
//
class InfoKioskPaneFilt : public PPBaseFilt {
public:
	InfoKioskPaneFilt();

	uint8  ReserveStart[32]; // @anchor @reserve
	PPID   InfoKioskID;      // Идентификатор записи инфокиоска
	PPID   DefaultGrpID;     // Товарная группа по умолчанию (отображается при открытии панели)
	long   Flags;
	long   ReserveEnd;       // @anchor @reserve
};

class PPObjGoodsInfo : public PPObjReference {
public:
	SLAPI  PPObjGoodsInfo(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID id, PPGoodsInfo *);
	int    SLAPI PutPacket(PPID * pID, PPGoodsInfo *, int useTa);
	int    SLAPI EditInfoKioskPaneFilt(InfoKioskPaneFilt * pData);
};
//
// Descr: Класс, управляющий ассоциациями товар-объект. В качестве ассоциированного
//   объекта предполагается использовать PPOBJ_LOCATION и PPOBJ_ARTICLE (поставщики)
//   Ассоциации хранятся в таблице ObjAssoc с типом ассоциации, определяемом клиентом
//   класса, и указываемом в контрукторе GoodsToObjAssoc.
//
class GoodsToObjAssoc {
public:
	SLAPI  GoodsToObjAssoc(PPID asscTyp, PPID objType, int dupAllowing = 0);
	SLAPI  operator const LAssocArray & () const;
	int    SLAPI IsValid() const;
	uint   SLAPI GetCount() const;
	const  LAssoc & FASTCALL at(uint pos) const;
	int    SLAPI Get(PPID goodsID, PPID * pObjID);
	int    SLAPI Search(PPID goodsID, PPID * pObjID, uint * pPos) const;
	int    SLAPI SearchPair(PPID goodsID, PPID objID, uint * pPos) const;
	int    SLAPI GetListByGoods(PPID goodsID, PPIDArray & rObjList); // @recursion
	int    SLAPI GetListByObj(PPID objID, PPIDArray & rGoodsList) const;
	int    SLAPI Add(PPID goodsID, PPID objID, uint * pPos = 0);
	int    SLAPI UpdateByPos(uint pos, PPID goodsID, PPID objID);
	int    SLAPI Remove(PPID goodsID, PPID objID);
	int    SLAPI Load();
	int    SLAPI Save();
	SString & SLAPI GetKeyName(PPID id, SString & rBuf);
private:
	PPID   AsscType;
	PPID   ObjType;
	enum {
		fDup   = 0x0001, // Допускает дублирование товара
		fNamed = 0x0002, // Объект инициализирован именованной ассоциацией
		fError = 0x0004  // При инициализации объекта возникла ошибка
	};
	long   Flags;
	PPNamedObjAssoc NoaRec;
	PPObjGoods GObj;
	LAssocArray List;
};

class GoodsIterator {
public:
	enum {
		ordByDefault = 0,
		ordByName = 1,
		ordByAbbr = 2
	};
	//
	// Descr: Расширение информации о товаре, предоставляемое итератором при
	//   установке некоторых параметров фильтра.
	// Note: Данное расширение не может быть использовано для определения параметров
	//   непосредственной продажи. На первоначальном этапе расширение применяется для 'кспорта
	//   данных в интернет-магазин Universe-HTT
	//
	struct Ext {
		Ext  & SLAPI Clear();

		PPID   GoodsID;
		PPID   CurID;
		double Price;
		double Rest;
		LDATETIME PriceDtm;
		StrAssocArray SfList;
	};

	static int SLAPI GetListByGroup(PPID goodsGrpID, PPIDArray * pList);
	static int SLAPI GetListByFilt(GoodsFilt * pFilt, PPIDArray * pList, PPIDArray * pDupDynGrpList = 0);
	static int SLAPI GetListByFilt(GoodsFilt * pFilt, StrAssocArray * pList, int byName);

	SLAPI  GoodsIterator(const GoodsFilt *, int aOrder, PPIDArray * pDupDynGrpList = 0);
	SLAPI  GoodsIterator(PPID grp, int aOrder, PPIDArray * pDupDynGrpList = 0);
	SLAPI  GoodsIterator(int aOrder = 0, PPIDArray * pDupDynGrpList = 0);
	SLAPI ~GoodsIterator();
	int    SLAPI Init(const GoodsFilt *, int aOrder);
	int    SLAPI Init(PPID grp, int aOrder);
	int    SLAPI Init(int aOrder);
	int    SLAPI Next(Goods2Tbl::Rec * pRec, GoodsIterator::Ext * pExt = 0);
	int    SLAPI GetSelectorListInfo(PPID * pClsID, StrAssocArray & rList) const;
	const  IterCounter & SLAPI GetIterCounter() const;
	int    SLAPI GetSelectorListItem(long handler, PPUhttStoreSelDescr::Entry & rEntry) const;
private:
	int    SLAPI InitInstance(PPIDArray * pDupDynGrpList);
	int    SLAPI CreateIterQuery();
	int    SLAPI Helper_MakeListByGroup(const PPIDArray * pGrpList, PPID grpID, PPIDArray * pList, int doIntersect);
	int    FASTCALL CheckActual(const Goods2Tbl::Rec & rRec) const;
	//
	// Descr: Проверяет элементы списка pSrcList на соответствие фильтру this->Filt.
	//   Если pDestList != 0, то элементы, которые соответствуют фильтру, добавляются в pDestList.
	//   Если pDestList == 0, то элементы, которые не соответствуют фильтру, удаляются из pSrcList
	//
	int    SLAPI FilterList(PPIDArray * pSrcList, PPIDArray * pDestList, long implFlags);
	int    IterIdx;
	int    Order;
	PPIDArray * P_List;
	PPIDArray * P_MtxList;       // Список товаров, соответствующих матрице
	UintHashTable * P_ActualHash; // Набор товаров, которые есть на остатке
	BExtQuery * P_IterQuery;
	PPIDArray * P_DupDynGrpList;
	PPUhttStorePacket * P_UhttsPack;
	IterCounter Counter;
	PPObjGoods GObj;
	PPObjTag   TagObj;
	GoodsFilt  Filt;
	PPIDArray UnlimTypeList;

	struct InnerExt {
		PPID   GoodsID;
		PPID   CurID;
		double Price;
		double Rest;
		LDATETIME PriceDtm;
	};

	PPID   SfClsID; // Класс товара, по которому набираются селекторные атрибуты
	TSArray <InnerExt> ExtList;
	StrAssocArray ExtSfTitleList;
};
//
// @ModuleDecl(PPObjGoodsGroup)
//
// Bias for selecting goods groups. Used in PPObjGoodsGroup::Selector()
//
#define GGRTYP_SEL_NORMAL    0x02000000L // Исключить альтернативные группы
#define GGRTYP_SEL_ALT       0x01000000L // Только альтернативные группы и группы верхнего уровня //
#define GGRTYP_SEL_ASSET     0x04000000L // Только группы основных фондов (имеют тип товара с признаком GTF_ASSETS)
#define GGRTYP_SEL_EXCLASSET 0x08000000L // Исключить группы основных фондов
#define GGRTYP_SEL_FOLDER    0x10000000L // @v7.2.4 Показывать только группы-папки
//
// Descr: Параметр функции PPObjGoodsGroup::Recover
//
struct GoodsGroupRecoverParam {
	GoodsGroupRecoverParam()
	{
		EgaFolderID = 0;
		Ega = egaNone;
		Flags = 0;
	}
	enum {
		fCorrect       = 0x0001, // Исправлять ошибки
		fDelTempAltGrp = 0x0002  // Удалять временные альтернативные группы
	};
	//
	// Descr: Действие над пустыми группами
	//
	enum {
		egaNone = 0,     // Ничего не делать
		egaReport,       // Выводить сообщение в журнал
		egaMoveToFolder, // Переместить в выбранную папку
		egaRemove        // Удалить
	};
	SString LogFileName;  // Имя файла журнала, в который заносится информация об ошибках
	PPID   EgaFolderID;
	long   Ega;
	long   Flags;
};
//
// Descr: Итоговая информация по товарным группам
//
struct GoodsGroupTotal {
	long   MaxLevel;       // Максимальная вложенность групп
	long   Count;          // Общее количество элементов
	long   AltCount;       // Количество альтернативных групп
	long   FoldCount;      // Количество групп-папок
	long   GrpCount;       // Количество обыкновенных групп
};

class PPObjGoodsGroup : public PPObjGoods {
public:
	SLAPI  PPObjGoodsGroup(void * extraPtr = 0);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID id);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual StrAssocArray * MakeStrAssocList(void * extraPtr /*parent*/);
	//
	// Методу PPObjGoodsGroup::Selector в качестве дополнительного
	// параметра передается ид. родительской группы + биас типа группы
	// (GGRTYP_SEL_XXX). В случае успеха этот ид. присваивается полю
	// PPObjGoodsGroup::Extra.
	// Методы UpdateSelector, ChangeLevel использует поле
	// PPObjGoodsGroup::Extra как идентификатор родительской группы,
	// а параметр extraParam игнорируют. Метод ChangeLevel
	// модифицирует PPObjGoodsGroup::Extra.
	//
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int  SLAPI UpdateSelector(ListBoxDef * pDef, void * extraPtr);
	int    SLAPI SearchCode(const char * pCode, BarcodeTbl::Rec * = 0);
	//
	// Присваивает картинки каждому элементу списка для древовидных списков
	//
	int    SLAPI AssignImages(ListBoxDef *);
	//
	// Descr: Вычисляет уровень вложенности группы grpID.
	//   Для группы, не имеющей предков, уровень вложенности - 0.
	// Returns:
	//   >0 - уровень вложенности успешно определен
	//   <0 - идентификатор grpID не найден
	//   0  - ошибка
	//
	int    SLAPI GetLevel(PPID grpID, long * pLevel);
	int    SLAPI CalcTotal(GoodsGroupTotal * pTotal);
	int    SLAPI Transmit();
	//
	// Descr: Проверяет и, возможно, корректирует товарные группы.
	//   Проверяются следующие дефекты:
	//     1. существуют товары, ссылающиеся на альтернативную группу как на родительскую
	//     2. существуют товары, ссылающиеся на группу-папку как на родительскую
	//     3. циклические ссылки между группами
	//   Обнаруженные ошибки функция записывает в файл журнала, определенный параметром pParam->LogFileName.
	// ARG(pParam IN): @{vptr0} Параметры проверки и восстановления ошибок
	//   Если этот параметр нулевой, то функция выводит диалог редактирования параметров проверки
	//   и восстановления.
	// Returns:
	//   >0 - проведена проверка и, возможно, восстановление ошибок
	//   <0 - если pParam == 0 и пользователь отказался от проверки.
	//   0  - ошибка
	//
	int    SLAPI Recover(const GoodsGroupRecoverParam * pParam, PPLogger * pLogger);
	//
	// Descr: Считывает из базы данных товарных фильтр, ассоциированный с альтернативной
	//   группой с идентификатором id.
	//
	int    SLAPI ReadGoodsFilt(PPID id, GoodsFilt * pFilt);
	//
	// Descr: Утилитная функция. Определяет, является ли
	//   заданная параметром группа альтернативной. Если запись,
	//   соответствующая параметру не найдена, то возвращается -1.
	//   В противном случае, если группа альтернативная, то возвращается (>0),
	//   иначе - 0.
	//
	static int SLAPI IsAlt(PPID id);
	static int SLAPI IsTempAlt(PPID id);
	static int SLAPI IsDynamicAlt(PPID id);
	//
	// Descr: Создает группу по упрощенному набору параметров. Если группа, имеющая имя pName или
	//   код pCode уже существует, то функция возвращает ее идентификатор.
	// ARG(pID     OUT): Указатель на идентификатор созданной или обнаруженной группы
	// ARG(kind     IN): @#{0 || gpkndOrdinaryGroup || gpkndFolderGroup || gpkndAltGroup} Вид создаваемой группы.
	//   Если kind == 0, то функция считает, что kind = gpkndOrdinaryGroup.
	// ARG(parentID IN): Родительская группа.
	// ARG(pName    IN): Наименование группы. Функция пытается сначала найти группу с таким именем, прежде чем
	//   создавать новую.
	// ARG(pCode    IN): @#{vptr0} Код группы. Если pCode != 0 то функция сначала пытается найти группу с
	//   таким кодом, прежде чем создать новую.
	// ARG(unitID   IN): Ид единицы измерения торговых единиц создаваемой группы.
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 -
	//
	int    SLAPI AddSimple(PPID * pID, GoodsPacketKind kind, PPID parentID, const char * pName, const char * pCode, PPID unitID, int use_ta);
	int    SLAPI Import(int use_ta);
	static int SLAPI SetOwner(PPID id, long curOwner, long newOwner);
	static int SLAPI RemoveTempAlt(PPID id, long owner, int forceDel = 0, int useTa = 1);
	static int SLAPI AddDynamicAltGroupByFilt(GoodsFilt * pFilt, PPID * pDynamicAltGrpID, long owner, int useTa);
	static int SLAPI SetDynamicOwner(PPID id, long curOwner, long newOwner);
	static int SLAPI RemoveDynamicAlt(PPID id, long owner, int forceDel = 0, int useTa = 1);
private:
	virtual int    SLAPI MakeReserved(long flags);
};
//
//
//
class GoodsGroupIterator {
public:
	enum {
		fAddZeroGroup      = 0x0001,
		fSortByCode        = 0x0002,
		fEnumAltGroups     = 0x0004,
		fEnumAltGroupsOnly = 0x0008
	};
	SLAPI  GoodsGroupIterator(PPID parentID, long flags = 0);
	int    SLAPI Init(PPID parentID, long flags);
	int    SLAPI Next(PPID * pID, SString & rBuf);
	//int    SLAPI Next(PPID * pID, char * pBuf, size_t bufLen);
	int    SLAPI Get(PPID id, SString & rBuf) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
private:
	PPID   ParentID;
	long   Flags;
	PPObjGoods GObj;
	SCollection List;
	uint   IterIndex;
};
//
// Package
//
struct PPGdsPckgType {
	PPID   ID;
	char   Name[64];
	char   CodeTempl[20];
	long   Counter;
	PPID   GoodsGrpID;
	long   Flags;
};

class PPObjPckgType : public PPObjGoods {
public:
	static int SLAPI CodeByTemplate(const char * pTempl, long counter, char *, size_t bufLen);

	SLAPI  PPObjPckgType(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Get(PPID, PPGdsPckgType *);
	int    SLAPI Put(PPID *, PPGdsPckgType *, int use_ta);
	PPID   SLAPI GetSingle();
private:
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
};
//
// Transport
//
// Transport Types
//
#define PPTRTYP_CAR      1 // Car
#define PPTRTYP_SHIP     2 // Ship
//
//
//
struct PPTransportConfig {
	SLAPI  PPTransportConfig();
	int    FASTCALL operator == (const PPTransportConfig & rS) const;

	long   Flags;           // @reserve
	PPID   OwnerKindID;     // Вид персоналии - владельцы транспортных средств. По умолчанию - PPPRK_SHIPOWNER
	PPID   CaptainKindID;   // Вид персоналии - капитаны (водители). По умолчанию - PPPRK_CAPTAIN
	SString NameTemplate;   // Шаблон наименования записи. Если определен, то
		// имя новой записи формируется автоматически по этому шаблону.
};

struct PPTransport {       // @persistent @store(Goods2Tbl)
	PPTransport();
	int    FASTCALL IsEqual(const PPTransport & rS) const;

	PPID   ID;             // @id
	long   TrType;         // PPTRTYP_XXX (Stored as Goods2.GdsClsID)
	char   Name[64];       // @name
	char   Code[16];       // Номер транспортного средства         (Stored as Barcode.Code with prefix '^' and Qtty = 1.0)
	char   TrailerCode[16]; // Номер прицепа (для автотранспорта)  (Stored as Barcode.Code with prefix '^' and Qtty = 2.0)
	PPID   TrModelID;      // ->Ref(PPOBJ_TRANSPMODEL) ИД модели (Stored as Goods2.BrandID)
	PPID   OwnerID;        // ->Person.ID (PPPRK_SHIPOWNER) Владелец транспорта (Stored as Goods2.ManufID)
	PPID   CountryID;      // ->Country.ID (Stored as Goods2.DefBCodeStrucID)
	PPID   CaptainID;      // ->Person.ID (PPPRK_CAPTAIN) Командир транспорта (Stored as Goods2.RspnsPersonID)
	long   Capacity;       // @v7.2.7 Грузоподьемность (кг) (Stored as Goods2.PhUPerU)
};

class PPObjTransport : public PPObjGoods {
public:
	static int SLAPI ReadConfig(PPTransportConfig *);
	static int SLAPI WriteConfig(const PPTransportConfig *, int use_ta);
	static int SLAPI EditConfig();

	SLAPI  PPObjTransport(void * extraPtr = 0);
	int    SLAPI Get(PPID, PPTransport * pPack);
	int    SLAPI Put(PPID *, const PPTransport * pPack, int use_ta);
	int    SLAPI GetNameByTemplate(PPTransport * pPack, const char * pTemplate, SString & rBuf) const;

	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	// realy private
	static int SLAPI MakeStorage(PPID id, const PPTransport * pRec, Goods2Tbl::Rec * pRawRec, BarcodeArray * pBcList);
	LongArray * SLAPI MakeList(long trType);
private:
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
};
//
// PPObjBrand
// Объект, управляющий информацией о товарных брэндах
//
#define BRNDF_HASIMAGES 0x00000001L

class BrandFilt : public PPBaseFilt {
public:
	SLAPI  BrandFilt();
	BrandFilt & FASTCALL operator = (const BrandFilt & rS);
	virtual int SLAPI IsEmpty() const;

	enum {
		fSubName = 0x0001
	};
	uint8  ReserveStart[32];  // @anchor
	long   Flags;
	SString SrchStr;          // @anchor Строка, содержащаяся в имени
	ObjIdListFilt ParentList;
	ObjIdListFilt OwnerList;
};

struct PPBrand {           // @persistent @store(GoodsTbl)
	SLAPI  PPBrand();
	int    FASTCALL CheckForFilt(const BrandFilt * pFilt) const;

	PPID   ID;             // @id
	char   Name[64];       // Наименование на родном языке
	PPID   OwnerID;        // ->Person.ID (PPPRK_MANUF) Владелец брэнда
	PPID   ParentID;       // ->Goods2.ID Группа (PPGDSK_BRANDGROUP), которой принадлежит брэнд (может быть 0)
	long   Flags;
	char   Reserve[8];     // @reserve
};

class PPBrandPacket {
public:
	SLAPI  PPBrandPacket();
	SLAPI ~PPBrandPacket();
	void   SLAPI Init();
	PPBrandPacket & FASTCALL operator = (const PPBrandPacket &);

	PPBrand    Rec;
	ObjLinkFiles  LinkFiles;
};

class PPObjBrand : public PPObjGoods {
public:
	static int FASTCALL Helper_GetRec(const Goods2Tbl::Rec & rGoodsRec, PPBrand * pRec);

	SLAPI  PPObjBrand(void * extraPtr = 0);
	int    SLAPI Fetch(PPID id, PPBrand * pRec);
	int    SLAPI Get(PPID, PPBrandPacket *);
	int    SLAPI Put(PPID *, PPBrandPacket *, int use_ta);
	int    SLAPI AddSimple(PPID * pID, const char * pName, PPID ownerID, int use_ta);
	int    SLAPI GetListByFilt(const BrandFilt * pFilt, PPIDArray * pList);
	//
	// Возвращает PPObjListWindow
	//
	virtual void * SLAPI CreateObjListWin(uint aFlags, void * extraPtr);
private:
	virtual ListBoxDef * SLAPI Selector(void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack *);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
};
//
// @vmiller {
// Классы, к оторым относятся составные товары. Перечислены в строковом ресурсе PPTXT_COMPGDS_TYPES
#define SUPRWARECLASS_NUTRITION 1 // Продукты питани
#define SUPRWARECLASS_MEDICAL   2 // Лекарственные препараты
// Типы для составных товаров
#define SUPRWARETYPE_GOODS      1L // Товар
#define SUPRWARETYPE_COMPONENT  2L // Компонент
//
// PPObjSuprWare
// Объект для управления информацией о составе товаров
//
struct PPSuprWare {
	SLAPI  PPSuprWare();
	//
	// Descr: Сравнивает this с rS. Поля ID и Reserve[] в сравнении не участвуют.
	// Returns:
	//   !0 - *this == rS
	//   0  - *this != rS
	//
	int    FASTCALL IsEqual(const PPSuprWare & rS) const;

	PPID   ID;             // @id
	char   Name[128];      // Наименование на родном языке
	char   Code[24];       // Код (Stored as Barcode.Code with prefix '~' and Qtty = 1.0) @v8.8.0 [16]-->[24]
	PPID   SuprWareType;   // SUPRWARETYPE_XXX (Stored as Goods2Tbl::GoodsTypeID)
	PPID   SuprWareCat;    // SUPRWARECLASS_XX (Stored as Goods2Tbl::WrOffGrpID)
	PPID   ParentID;       //
	long   Flags;          //
	uint8  Reserve[32];    // @reserve
};

struct PPSuprWareAssoc {
	SLAPI  PPSuprWareAssoc();
	PPSuprWareAssoc & FASTCALL operator = (const PPSuprWareAssoc & rS);
	PPSuprWareAssoc & FASTCALL operator = (const ObjAssocTbl::Rec & rS);

	PPID   GoodsID;
	PPID   CompID;
	PPID   TypeID;
	long   Num;
	PPID   UnitID;   // ИД единицы измерения (используется для записи и извлечения из таблицы ассоциаций)
	double Qtty;
};

class PPSuprWarePacket {
public:
	PPSuprWarePacket();
	int    SLAPI Init();
	PPSuprWarePacket & FASTCALL PPSuprWarePacket::operator = (const PPSuprWarePacket & rSrc);

	PPSuprWare Rec;
	TSArray <PPSuprWareAssoc> Items;
};

class PPObjSuprWare : public PPObjGoods {
public:
	SLAPI  PPObjSuprWare(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI Get(PPID goodsID, PPSuprWarePacket * pPack);
	int    SLAPI Put(PPID * pID, const PPSuprWarePacket * pPack, int use_ta);
	int    SLAPI PutAssoc(PPSuprWareAssoc & rItem, int use_ta);
	//
	// Descr: Ищет товар или компонент по коду. Код базового товара хранится в таблице BarcodeTbl с префиксом '~'.
	//
	int    SLAPI SearchByBarcode(const char * pBarcode, BarcodeTbl::Rec * pBcRec);
	//
	// Descr: Не редактирует запись о товаре, а просто выводит таблицу с его содержанием
	//
	int    SLAPI EditList(PPID * pID);
	int    SLAPI GetListByComponent(PPID componentID, PPIDArray & rList);
private:
	static int SLAPI MakeStorage(PPID id, const PPSuprWare * pRec, Goods2Tbl::Rec * pRawRec, BarcodeArray * pBcList);
	virtual int SLAPI DeleteObj(PPID id);
};
//
//
//
#define ALBATROSEXSTR_UHTTURN     1
#define ALBATROSEXSTR_UHTTURLPFX  2
#define ALBATROSEXSTR_UHTTACC     3
#define ALBATROSEXSTR_UHTTPASSW   4
#define ALBATROSEXSTR_EGAISSRVURL 5 // @v8.8.0 URL сервера обмена данными с системой ЕГАИС

struct PPAlbatrosCfgHdr { // @persistent @store(PropertyTbl)
	enum {
		fSkipBillWithUnresolvedItems = 0x0001, // При акцепте документов пропускать те, которые имеют не разрешенные товарные позиции
			// Автоматическое создание товаров в этом случае не допускается.
		fRecadvEvalByCorrBill        = 0x0002, // Идентификация расхождения драфт-прихода и учетного документа списания
			// осуществляется не прямым сравнением этих документов, а извлченеием данных из корректирующих
			// накладных, привязанных к учетному документу прихода (если таких нет, то считается, что совпадение полное).
		fUncondAcceptEdiIntrMov      = 0x0004, // @v9.0.0 Безусловный акцепт внутренних перемещений, продублированных по каналу EDI
		fUseOwnEgaisObjects          = 0x0008, // @v9.0.2 Использовать собственную базу данных объектов ЕГАИС
		fUseDateInBillAnalog         = 0x0010  // @v9.1.9 Использовать критерий даты при поиске аналога документа
	};
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_ALBATROSCFG2
	uint32 Size;           // Полный размер записи. Если Size == 0, то запись представлена в формате pre7.2.7 и
		// имеет размер sizeof(PropertyTbl)
	char   Reserve[24];    // @reserve @v8.5.5 [56]-->[36] // @v8.8.0 [36]-->[32] // @v8.8.3 [32]-->[28] // @v8.8.6 [28]-->[24]
	PPID   EgaisRetOpID;   // @v8.9.6 Вид (драфт) операции возврата от покупателя, принятого с сервера ЕГАИС
	//
	long   Flags;          // @v8.8.3 @flags
	PPID   EgaisRcptOpID;  // @v8.8.0 ->Ref(PPOBJ_OPRKIND) Вид (драфт)операции прихода от поставщика, принятого с сервера ЕГАИС
    PPID   EdiOrderOpID;   // @v8.5.5 ->Ref(PPOBJ_OPRKIND)  // @v9.2.1 OrderOpID-->EdiOrderOpID
    PPID   EdiOrderSpOpID; // @v8.5.5 ->Ref(PPOBJ_OPRKIND)  // @v9.2.1 OrderSpOpID-->EdiOrderSpOpID
    PPID   EdiDesadvOpID;  // @v8.5.5 ->Ref(PPOBJ_OPRKIND)  // @v9.2.1 DesadvOpID-->EdiDesadvOpID
    PPID   RcptTagID;      // @v8.5.5 ->Ref(PPOBJ_TAG)
    PPID   TtnTagID;       // @v8.5.5 ->Ref(PPOBJ_TAG)
	//
	PPID   SmsAccID;	   // ->Ref(PPOBJ_SMSPRVACCOUNT) ИД учетной записи SMS-клиента
	PPID   OpID;           // ->Ref(PPOBJ_OPRKIND)     Вид операции приема заказов
	PPID   MailAccID;      // ->Ref(PPOBJ_MAILACCOUNT) ИД учетной записи электронной почты
};

class PPAlbatrosConfig {
public:
	SLAPI  PPAlbatrosConfig();
	PPAlbatrosConfig & SLAPI Clear();
	int    SLAPI SetPassword(int fld, const char * pPw);
	int    SLAPI GetPassword(int fld, SString & rPw);

	PPAlbatrosCfgHdr Hdr;
	SString UhttUrn;
	SString UhttUrlPrefix;
	SString UhttAccount;
	SString UhttPassword;
	SString EgaisServerURL; // @v8.8.0
};

class PPAlbatrosCfgMngr {
public:
	static int SLAPI Get(PPAlbatrosConfig * pCfg);
	static int SLAPI Fetch(PPAlbatrosConfig * pCfg);
	static int SLAPI Put(PPAlbatrosConfig * pCfg, int use_ta);
	static int SLAPI Edit();
	//
	static int SLAPI Helper_Get(Reference * pRef, PPAlbatrosConfig * pCfg);
	static int SLAPI Helper_Put(Reference * pRef, PPAlbatrosConfig * pCfg, int use_ta);
private:
	static int SLAPI Get(PPAlbatrosCfgHdr * pHdr);
	static int SLAPI Put(const PPAlbatrosCfgHdr * pHdr, int use_ta);
	static int SLAPI Helper_Get(Reference * pRef, PPAlbatrosCfgHdr * pHdr);
};
//
//
//
class EgaisPersonCore : public EgaisPersonTbl {
public:
	enum {
		txtprpAddressDescr = (PPTRPROP_USER+1)
	};
	enum {
		rolefManuf     = 0x0001,
		rolefImporter  = 0x0002,
		rolefSupplier  = 0x0004,
		rolefShipper   = 0x0008,
		rolefConsignee = 0x0010,
		rolefVerified  = 0x0200  // Признак верифицированной записи
	};
	struct Item {
		enum {
			cmpfExceptID    = 0x0001,
			cmpfExceptFlags = 0x0002
		};
		SLAPI  Item();
		void   SLAPI Clear();
		int    SLAPI IsEqual(const Item & rItem, long cmpFlags) const;

		PPID   ID;
		char   RarIdent[16];
		char   INN[16];
		char   KPP[16];
		char   UNP[16];
		char   RNN[16];
		int16  CountryCode;
		int16  RegionCode;
		long   Flags; // rolefXXX
		LDATE  ActualDate;
		SString Name;
		SString FullName;
		SString AddressDescr;
	};
	SLAPI  EgaisPersonCore();
    int    SLAPI Search(PPID id, EgaisPersonCore::Item &);
    int    SLAPI SearchByCode(const char * pRarCode, TSArray <EgaisPersonTbl::Rec> & rList);
    //int    SLAPI SearchByInn
    //
    // Descr: Если для контрагента с ФСРАР-кодом pRarCode существует запись и
    //   эта запись имеет флаг rolefVerified, то функция возвращает (>0).
    //   Если запись не существует или не верифицирована, то (<0).
    //   В случае ошибки - 0.
    //
    int    SLAPI IsVerifiedCode(const char * pRarCode);
    int    SLAPI Put(PPID * pID, EgaisPersonCore::Item * pItem, long * pConflictFlags, int use_ta);
    int    SLAPI RecToItem(const EgaisPersonTbl::Rec & rRec, EgaisPersonCore::Item & rItem);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    SLAPI Clear(int use_ta);
    int    SLAPI Export(long fmt, const char * pFileName);
};

class EgaisProductCore : public EgaisProductTbl {
public:
	enum {
		fVerified = 0x0001 // Признак верифицированной записи
	};

	struct Item {
		enum {
			cmpfExceptID = 0x0001
		};
		SLAPI  Item();
		void   SLAPI Clear();
		int    SLAPI IsEqual(const Item & rItem, long cmpflags) const;

		PPID   ID;
		char   AlcoCode[24];
		char   ManufRarIdent[16];
		char   ImporterRarIdent[16];
		char   CategoryCode[8];
		long   Flags;
		double Proof;
		double Volume;
		LDATE  ActualDate;
		SString Name;
		SString FullName;
	};
	SLAPI  EgaisProductCore();
	int    SLAPI RecToItem(const EgaisProductTbl::Rec & rRec, EgaisProductCore::Item & rItem);
    int    SLAPI Search(PPID id, EgaisProductCore::Item & rItem);
    int    SLAPI SearchByCode(const char * pAlcoCode, TSArray <EgaisProductTbl::Rec> & rList);
    //
    // Descr: Если для товара с ФСРАР-кодом pAlcoCode существует запись и
    //   эта запись имеет флаг fVerified, то функция возвращает (>0).
    //   Если запись не существует или не верифицирована, то (<0).
    //   В случае ошибки - 0.
    //
    int    SLAPI IsVerifiedCode(const char * pAlcoCode);
    int    SLAPI Put(PPID * pID, EgaisProductCore::Item * pItem, long * pConflictFlags, int use_ta);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    SLAPI Clear(int use_ta);

    int    SLAPI Export(long fmt, const char * pFileName);
};

class EgaisRefACore : public EgaisRefATbl {
public:
	//
	// Descr: Флаги записи таблицы EgaisRefA
	//
	enum { // @persistent
		fVerified = 0x0001 // Данные записи верифицированы запросом к ЕГАИС.
			// Поле EgaisRefA::ActualDate указывает на дату верификации.
	};
    SLAPI  EgaisRefACore();
    static int FASTCALL IsRecEq(const EgaisRefATbl::Rec & rR1, const EgaisRefATbl::Rec & rR2);
    int    SLAPI Search(PPID id, EgaisRefATbl::Rec * pRec);
    //
    // Descr: Возвращает список записей справок А с кодом pRefACode.
    // Returns:
    //   <0 - нет ни одной записи с кодом pRefACode
    //    0 - ошибка
    //   >0 - найдена одна или более записей с кодом pRefACode. Возвращенное значение
    //     равно индексу наиболее актуальной записи max(ActualDate), увеличенному на 1.
    //     То есть, rList[ret-1] соответствует наиболее актуальному элементу массива.
    //
    int    SLAPI SearchByCode(const char * pRefACode, TSArray <EgaisRefATbl::Rec> & rList);
    int    SLAPI SearchByProductCode(const char * pAlcoCode, TSArray <EgaisRefATbl::Rec> & rList);
    int    SLAPI Put(PPID * pID, EgaisRefATbl::Rec * pRec, long * pConflictFlags, int use_ta);
    //
    // Descr: Удаляет все записи из таблицы
    //
    int    SLAPI Clear(int use_ta);

    int    SLAPI Export(long fmt, const char * pFileName);
};

class PrcssrAlcReport {
public:
	friend class DL6ICLS_PrcssrAlcReport;

	class Config { // @persistent
	public:
		SLAPI  Config();
		SLAPI  Config(const Config & rS);
		SLAPI ~Config();
		Config & FASTCALL operator = (const Config & rS);
		Config & SLAPI Clear();
		int    FASTCALL Copy(const Config & rS);
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			fDetectAlcByClass = 0x0001, // Идентифицировать алкогольную продукцию по принадлежности классу ExtBlock::AlcGoodsClsID.
				// Если флаг не установлен или AlcGoodsClsID == 0, то - по принадлежности группе AlcGoodsGrpID
			fWhToReg2ByLacks  = 0x0002, // Передавать остатки ЕГАИС со склада на регистр 2 по отрицательным значениям в текущих остатках ЕГАИС
				// на регистре 2.
			fEgaisVer2Fmt     = 0x0004  // @v9.6.12 Применять 2-ю версию форматов ЕГАИС
		};
		//
		// Descr: Варианты списания остатков с регистра 2 ЕГАИС
		//
		enum {
			woswNone = 0,         // Не списывать
			woswBalanceWithLots,  // Приводить в соответствие с текущими остатками по лотам
			woswByCChecks,        // Списывать продажи по чекам
			woswByBills           // Списывать продажи по документам
		};

		SVerT  Ver;
		PPID   RcptOpID;             // Операция прихода от поставщика
		PPID   SaleRetOpID;          // Операция возврата от покупателя
		PPID   RcptEtcOpID;          // Операция прочего прихода
		PPID   ExpndOpID;            // Операция расхода
		PPID   SupplRetOpID;         // Операция возврата поставщику
		PPID   ExpndEtcOpID;         // Операция прочего расхода
		PPID   IntrExpndOpID;        // Операция внутреннего перемещения

		PPID   AlcGoodsGrpID;        // Товарная группа, ограничивающая алкогольную продукцию
		PPID   BeerGoodsGrpID;       // Товарная группа, ограничивающая пивную продукцию
		PPID   CategoryTagID;        // Тег, определяющий категорию вида продукции (имеет приоритет перед CategoryClsDim)
		int16  CategoryClsDim;       // PPGdsCls2::e... Размерность класса, определяющая категорию алкогольной продукции
		int16  VolumeClsDim;         // PPGdsCls2::e... Размерность класса, определяющая объем алкоголя в одной торговой единице

		PPID   AlcLicRegTypeID;      // Тип регистра алкогольной лицензии
		PPID   KppRegTypeID;         // Тип регистра КПП. Если 0, то используется зарезервированный тип регистра для КПП.
		int32  KppDlvrExt;           // Дополнительное поле адреса, содержащее КПП этого адреса (устарело - с приоритетом используется регистр адреса)
		PPID   WhsExpTagID;          // Тег персоналии Оптовый покупатель/Экспорт (1/2)
		PPID   ManufImpTagID;        // Тег персоналии Производитель/Импортер (1/2)
		char   SubstCategoryCode[8]; // Код алкогольной продукции, используемый в некоторых случаях вместо любого иного кода
		//
		// Блок для расширения структуры "плоскими" данными
		//
		struct ExtBlock {
			PPID   TransportLicRegTypeID;
			PPID   AlcGoodsClsID; // @v8.8.0 ИД класса алкогольной продукции
			int16  ProofClsDim;   // @v8.8.0 PPGdsCls2::e... Размерность класса, определяющая крепость алкоголя в одной торговой единице (в объемных %)
			uint16 Reserve2;
			PPID   ImporterPersonKindID; // @v8.9.0 Вид персоналии, идентифицирующий импортера
			long   Flags;         // @v9.0.10
			long   WrOffShopWay;  // @v9.3.10
			PPID   EgaisInvOpID;  // @v9.3.12 Вид операции инвентаризации - необходим для идентификации видов операций
				// списания излишков и недостач.
			uint8  Reserve[36];
		};
		ExtBlock  E;                 // @anchor
		PPIDArray StorageLocList;    // @anchor
		PPIDArray LotManufTagList;   // Список тегов лотов, хранящих производителя/импортера товара
		//
		CCheckFilt * P_CcFilt;       // @v9.4.0 Фильтр по кассовым чекам для списания с регистра 2
	};

	struct EgaisMarkBlock {
		int16  Ver; // Первые два символа марки
		SString EgaisCode; // Код продукции по ЕГАИС
	};

    static int SLAPI ReadConfig(Config * pCfg);
    static int SLAPI WriteConfig(Config * pCfg, int use_ta);
	static int SLAPI EditConfig();
	//
	// Descr: Функция определяет является ли строка pMark валидным номером алкогольной акцизной марки.
	//   Если параметр pProcessedMark != 0, то при правильной длине и нахождении в коде pMark недопустимого
	//   символа функция пытается спроецировать этот символ на латинский в соответствии с текущей
	//   раскладкой клавиатуры. Если все такие попытки оказались успешными, то преобразованный код
	//   марки заносится в буфер *pProcessedMark. Если все же pMark имеет не допустимый формат, то
	//   *pProcessedMark при выходе из функции содержит пустую строку.
	//
	static int FASTCALL IsEgaisMark(const char * pMark, SString * pProcessedMark);
	static int SLAPI ParseEgaisMark(const char * pMark, EgaisMarkBlock & rMb);

    SLAPI  PrcssrAlcReport();
    SLAPI ~PrcssrAlcReport();
    //
    // Descr: Устанавливает параметры конфигурации.
    //   Если pCfg != 0, то устанавливаются внешние параметры, в противном случае функция считывает
    //   конфигурацию из базы данных методом PrcssrAlcReport::ReadConfig
    //
    int    SLAPI SetConfig(const Config * pCfg);
    int    SLAPI ValidateConfig(const Config & rCfg, long flags);
	const  Config & GetConfig() const
	{
		return Cfg;
	}

    struct GoodsItem {
    	GoodsItem();
    	GoodsItem & Clear();

    	enum {
    		stClass                = 0x0001,  // Товар классифицирован
    		stCategoryCodeByLotTag = 0x0002,  // Код категории продукции извлечен из тега лота
    		stCategoryCodeByClsDim = 0x0004,  // Код категории продукции извлечен из классификатора-размерности
    		stCategoryName         = 0x0008,  // Наименование категории продукции успешно идентифицировано
    		stRefcUsedByGoodsCode  = 0x0010,  // Поля с префиксом Refc инициализированы исходя из GoodsItem::EgaisCode
    		stRefcUsedByRefA       = 0x0020,  // Поля с префиксом Refc инициализированы исходя из GoodsItem::InformA
    		stEgaisCodeByLotTag    = 0x0040,  // ЕГАИС-код товара получен из лота (более надежный вариант, нежели stEgaisCodeByGoods)
    		stEgaisCodeByGoods     = 0x0080,  // ЕГАИС-код товара получен как один из кодов товара (менее надежный вариант, нежели stEgaisCodeByLotTag)
    		stRefcInfAPrManufConfl = 0x0100,  // Конфликт в справочнике ЕГАИС между кодом производителя в справка А и записе товара
    		stRefcInfAPrImprtConfl = 0x0200,  // Конфликт в справочнике ЕГАИС между кодом импортера в справка А и записе товара
    		stRefcPrDbCategConfl   = 0x0400,  // Конфликт между видом продукции в базе данных и записе товара ЕГАИС
    		stMarkWanted           = 0x0800   // @v9.0.9 Товар маркированный (имеет акцизную марку)
    	};
    	long   StatusFlags;
    	PPID   GoodsID;
    	PPID   LotID;
    	PPID   MnfOrImpPsnID;   // @v8.8.0 ИД персоналии производителя или импортера (для импортного товара)
    	double Volume;
    	double Brutto;
    	double Proof;           // @v8.7.12 Крепость в объемных процентах
    	uint   CategoryCodePos; // @v8.4.4 Позиция (1..) кода категории в PrcssrAlcReport::CategoryNameList
    	double UnpackedVolume;  // @v8.9.0 Если товар имеет единицу измерения, производную от литра (PPUNIT_LITER),
			// то считается не неупакованным и измеряется в литрах. В этом случае это поле содержит
			// количество литров в одное торговой единице (PPUnit::BaseRatio). В противном случае это поле 0.0
		LDATE  BottlingDate;    // @v9.0.3 Дата розлива
		int    CountryCode;     // @v9.0.3 Код страны-производителя
		int    OuterUnpackedTag; // @v9.5.10 При извлечении данных о товаре из внешнего источника
			// был детектирован признак Unpacked (не упакованная алкогольная продукция)
    	SString CategoryCode;
    	SString CategoryName;
    	SString MsgPool;   // Список сообщений, разделенных символом '\t'
    	SString EgaisCode; // @v8.8.0 Код товара в системе ЕГАИС
    	SString InformA;   // @v8.8.0 Код справки А
    	SString InformB;   // @v8.8.0 Код справки Б
    	//
    	// Descr: Следующие поля извлекаются из внутренних таблиц базы данных,
    	//   отражающих значения, хранящиеся в ЕГАИС.
    	//   До тех пор, пока не получим высокого уровня надожности кода, использующего
    	//   такие данные, эти поля будут дублировать соответствующие, определенные выше.
    	// Note: Какие-либо действия по извлечению этих полей предпринимаются только
    	//   если установлен флаг PPAlbatrosConfig::Hdr::fUseOwnEgaisObjects
    	//
    	LDATE  RefcInfA_ActualDate;
    	LDATE  RefcPr_ActualDate;
    	PPID   RefcProductID;
    	PPID   RefcManufID;
    	PPID   RefcImporterID;
    	PPID   RefcInfAID;
        double RefcVolume;
        double RefcProof;
        SString RefcCategoryCode;
    	SString RefcEgaisCode;
    	SString RefcManufCode;
    	SString RefcImporterCode;
    };

	int    SLAPI Init();

	enum {
		pgifUseSubstCode      = 0x0001,
		pgifForceUsingInnerDb = 0x0002
	};

	int    SLAPI GetEgaisCodeList(PPID goodsID, BarcodeArray & rList);
    int    SLAPI PreprocessGoodsItem(PPID goodsID, PPID lotID, const ObjTagList * pTags, long flags, GoodsItem & rItem);
    int    FASTCALL IsStorageLoc(PPID locID) const;
    int    FASTCALL IsStorageBillLoc(PPID billID);
    //
    // Descr: Определяет является ли товар goodsID алкогольным
    //
    int    FASTCALL IsAlcGoods(PPID goodsID);
    //
    // Descr: Возвращает список алкогольных товаров из базы данных.
    //   Результирующий список отсортирован и не содержит дубликатов.
    //
    int    FASTCALL GetAlcGoodsList(PPIDArray & rList);
    //
    // Descr: Возвращает тип персоналии-источника происхождения алкоголя.
    // Returns:
    //   1 - производитель
    //   2 - импортер
    //  <0 - не возможно идентифицировать
    //   0 - ошибка
    // Note: Идентификация осуществляется по тегу Config::ManufImpTagID или
    //   по принадлежности виду
    //
    int    FASTCALL GetManufPersonType(PPID personID);
    int    SLAPI GetLotManufID(PPID lotID, PPID * pManufID, SString * pMsgBuf);
    int    SLAPI GetCategoryNameByCodePos(uint codePos, SString & rBuf);
    int    SLAPI GetCategoryNameByCode(const char * pCode, SString & rBuf);
    int    SLAPI SearchGoodsByRarCode(const char * pCode, PPID * pGoodsID);
    int    SLAPI SearchPersonByRarCode(const char * pCode, PPID * pPsnID, PPID * pLocID);

    enum {
    	wkrAlcLic       = 1,
    	wkrKPP          = 2,
    	wkrTransportLic = 3
    };
    PPID   FASTCALL GetWkrRegisterTypeID(int wkr) const;
    int    SLAPI GetWkrRegister(int wkr, PPID psnID, PPID locID, LDATE dt, RegisterTbl::Rec * pRec);
    int    SLAPI GetWkrRegisterList(int wkr, PPID psnID, PPID locID, LDATE dt, RegisterArray * pList);
    int    SLAPI GetWkrRegisterListByPeriod(int wkr, PPID psnID, PPID locID, const DateRange & rPeriod, RegisterArray * pList);
    //
    // Descr: Источники идентификации регистра алкогольной лицензии
    //
    enum {
    	licsrcObject  = 1, // Контрагент по документу
    	licsrcDlvrLoc = 2, // Адрес доставки
    	licsrcBillExt = 3  // Прямая ссылка на лицензию в атрибуте документа
    };

    int    SLAPI GetBillLic(PPID billID, PPID * pRegID, RegisterTbl::Rec * pRegRec);
    int    SLAPI FetchRegister(PPID regID, PPID psnID, PPID locID, RegisterTbl::Rec * pRegRec);
protected:
	class RefCollection {
	public:
		SLAPI  RefCollection();
		int    FASTCALL SetPerson(EgaisPersonCore::Item & rItem);
		int    FASTCALL SetProduct(EgaisProductCore::Item & rItem);
		int    FASTCALL SetRefA(EgaisRefATbl::Rec & rItem);
		int    SLAPI Store(int use_ta);

		TSCollection <EgaisPersonCore::Item> PersonList;
		TSCollection <EgaisProductCore::Item> ProductList;
		TSArray <EgaisRefATbl::Rec> RefAList;

		int    LastPersonP;
		int    LastProductP;
		int    LastRefAP;

		EgaisProductCore PrC;
		EgaisPersonCore  PsC;
		EgaisRefACore    RaC;
	};

	int    SLAPI ProcessRegisterRec(RegisterTbl::Rec * pRegRec, PPID psnID, PPID locID);

    StrStrAssocArray CategoryNameList;
	Config Cfg;
	PPAlbatrosConfig ACfg;
	PPObjPerson PsnObj;
	PPObjGoods GObj;
	PPObjGoodsClass GcObj;
	PPObjTag TagObj;
	PPObjAccSheet AcsObj;
	PPObjArticle ArObj;
	PPObjBill * P_BObj;
	RefCollection * P_RefC;
private:
	PPIDArray AlcGoodsList;
	PPIDArray BeerGoodsList;
};
//
// @ModuleDecl(PPViewGoods)
//
struct GoodsViewItem : public Goods2Tbl::Rec {
	char   Barcode[24];    // @v8.8.0 [16]-->[24]
	long   Brutto;
	PPDimention PckgDim;
	PPDimention RtlDim;    // @v7.2.7 Габаритные размеры торговой единицы, мм
	int16  ExpiryPeriod;   // @v7.4.5 Срок годности товара (дней).
	int16  GseFlags;       // @v7.4.5
	double MinStock;
	double Package;
	double MinShippmQtty;  // @v7.2.7 Минимальное количество, которое можно отгрузить в одном документе
	char   StrucType[16];
};

class PPGoodsImpExpParam;

class PPViewGoods : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0, // Внутренние сортировки, для отображения в списках
		OrdByName,
		OrdByAbbr,
		OrdByGrp_Name,
		OrdByGrp_Abbr,
		OrdByBarcode,     // Сортировка на выбор пользователем, включая OrdByName
		OrdByBrand_Name,
		OrdByBarcode_Name
	};
	SLAPI  PPViewGoods();
	SLAPI ~PPViewGoods();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual const IterCounter & SLAPI GetCounter() const;
	int    SLAPI InitIteration(int aOrder = OrdByName);
	int    FASTCALL NextIteration(GoodsViewItem *);
	int    SLAPI ChangeOrder(PPViewBrowser * pW);
	int    SLAPI PrintPLabel(PPID goodsID);
	PPObjGoods * SLAPI GetObj();
	int    SLAPI AddItem(GoodsListDialog ** ppDlgPtr, PPViewBrowser * pBrw, PPID * pID);
	int    SLAPI DeleteItem(PPID);
	int    SLAPI Transmit(PPID);
	int    SLAPI Repair(PPID);
	void   SLAPI PrintLabel(PPID);
	void   SLAPI ViewGenMembers(PPID);
	int    SLAPI RemoveAll();
	int    SLAPI IsAltFltGroup();
	int    SLAPI IsGenGoodsFlt();
	int    SLAPI ReplaceNames();
	int    SLAPI AddBarcodeCheckDigit();
	int    SLAPI AddGoodsFromBasket();
	//
	// Descr: Изменяет флаги выборки товаров,
	//   предварительно запросив изменяемые флаги у пользователя //
	//
	int    SLAPI UpdateFlags();
	int    SLAPI UpdateTempTable(PPID goodsID, PPViewBrowser * pBrw);
	//
	// Descr: экспортирует товары
	//
	int    SLAPI Export(PPGoodsImpExpParam * pExpCfg);
	int    SLAPI ExportUhtt();
	//
	int    SLAPI CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle, PPViewBrowser * pBrw);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI ViewTotal();
	virtual int  Detail(const void *, PPViewBrowser *);
	int    SLAPI CreateTempTable(IterOrder ord, TempOrderTbl ** ppTbl);
	PPViewGoods::IterOrder SLAPI GetIterOrder() const;
	int    SLAPI IsTempTblNeeded(); // not const function
	int    SLAPI MakeTempRec(const Goods2Tbl::Rec *, TempOrderTbl::Rec *);
	int    SLAPI InitGroupNamesList();
	int    SLAPI RemoveTempAltGroup();
	int    SLAPI NextInnerIteration(int initList, GoodsViewItem *);

	struct GoodsMoveParam {
		GoodsMoveParam();
		enum {
			aRemoveAll = 1,
			aMoveToGroup,
			aChgClssfr,
			aActionByFlags, // @v8.1.0
			aActionByRule,  // @v8.3.11
			aChgMinStock,   // @v8.6.4
			aSplitBarcodeItems, // @v8.6.9
			aMergeDiezNames,    // @v8.6.9
			aChgTaxGroup        // @v9.5.0
		};
		enum {
			fMassOpAllowed  = 0x0001,
			fAltGroup       = 0x0002,
			fRemoveExtTextA = 0x0004,
			fRemoveExtTextB = 0x0008,
			fRemoveExtTextC = 0x0010, // @v8.3.11
			fRemoveExtTextD = 0x0020, // @v8.3.11
			fRemoveExtTextE = 0x0040, // @v8.3.11
			fInit           = 0x0080  // @v8.6.4 Структура была иницализирована (может быть использована для редактирования)
		};
		long   Action;
		PPID   DestGrpID;
		long   Flags;
		long   ClsDimZeroFlags;
		double RValue;
		GoodsExtTbl::Rec Clssfr;
		SString Rule; // @v8.3.11
		ObjIdListFilt LocList; // @v8.6.4
	};
	PPObjGoods GObj;
	PPObjPerson PsnObj;    // Используется неявно для извлечения имени производителя в броузере
	GoodsFilt  Filt;
	TempOrderTbl  * P_TempTbl;
	GoodsIterator * P_Iter;
	BarcodeArray BarcodeAry;
	GoodsViewItem IterCurItem;
	uint   BrcIdx;
	SString IterGrpName;
	GoodsMoveParam GmParam;
	static int DynFuncStrucType;
};
//
// @ModuleDecl(PPViewGoodsStruc)
//
typedef TempGoodsStrucTbl::Rec GoodsStrucViewItem;

class PPViewGoodsStruc : public PPView {
public:
	struct BrwHdr {
		PPID   GoodsID;
		PPID   StrucID;
		PPID   ItemID;
	};
	SLAPI  PPViewGoodsStruc();
	SLAPI ~PPViewGoodsStruc();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI ViewTotal();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GoodsStrucViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(PPID goodsID, PPID parentStrucID, PPID strucID, int goodsIsItem, int use_ta);
	int    SLAPI AddItem(PPID goodsID, PPID strucID, BExtInsert * pBei);

	GoodsFilt Filt;
	PPObjGoodsStruc GSObj;
	PPObjGoods GObj;
	TempGoodsStrucTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewGoodsToObjAssoc)
//
struct GoodsToObjAssocFilt : public PPBaseFilt {
	SLAPI  GoodsToObjAssocFilt();

	enum {
		fDestroyExtraParam = 0x0001
	};
	char   ReserveStart[32]; // @anchor
	PPID   AsscType;         //
	PPID   ObjType;          //
	PPID   ObjID;            //
	long   ExtraParam;       //
	long   Flags;            //
	long   Reserve;          // @anchor
	LocationFilt * P_LocF;   // @v8.1.9
};

struct GoodsToObjAssocViewItem {
	PPID   GoodsID;
	PPID   ObjID;
	char   GoodsName[128];
	char   ObjName[128];
};

class PPViewGoodsToObjAssoc : public PPView {
public:
	SLAPI  PPViewGoodsToObjAssoc();
	SLAPI ~PPViewGoodsToObjAssoc();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GoodsToObjAssocViewItem *);
private:
	struct BrwHdr {
		PPID   GoodsID;
		PPID   ObjID;
	};
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	static int SLAPI GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI AddItem(PPViewBrowser * pBrw);
	int    SLAPI EditItem(PPViewBrowser * pBrw, const BrwHdr *);
	int    SLAPI DeleteItem(const BrwHdr *);
	int    SLAPI EditGoodsToObjAssoc(LAssoc * pData, PPID objType, long extraParam, int newItem);
	void   SLAPI UpdateOnEdit(PPViewBrowser * pBrw);

	GoodsToObjAssocFilt Filt;
	GoodsToObjAssoc * P_Assoc;
	uint   IterIdx;
	PPObject * P_AsscObj; // Ассоциированный с товаром объект (фоновый экземпляр для ускорения)
	//TempGoodsObjAsscTbl * P_TempTbl;
};
//
//
//
struct GoodsImportBillIdent {
	SLAPI  GoodsImportBillIdent(PPObjPerson * pPsnObj, PPID defSupplID);
	SLAPI ~GoodsImportBillIdent();
	void   SLAPI GetFldSet(PPIniFile *, uint sect, DbfTable * pTbl);
	int    SLAPI Get(DbfRecord * pRec);
	int    SLAPI Get(Sdr_Goods2 * pRec, PPID supplID);
	PPBillPacket * SLAPI GetPacket(PPID opID, PPID locID);
	int    SLAPI FinishPackets();

	PPID   SupplID;
	LDATE  BillDate;
	SString BillCode;
private:
	int    fldn_suppl;
	int    fldn_supplcode;
	int    fldn_billcode;
	int    fldn_billdate;
	//
	SString SupplCodeRegSymb;
	int    CvtCodeToHex;
	PPID   RegTypeID;
	PPID   AccSheetID;
	PPID   DefSupplID;
	//
	SArray * P_CodeToPersonTab;
	PPObjPerson * P_PsnObj; // Not owned by GoodsImportBillIdent
	PPObjArticle * P_ArObj;
	TSCollection <PPBillPacket> * P_PackList;
};

class HierArray : public SArray {
public:
	struct Item {
		char   Code[24];       // @v8.8.0 [16]-->[24]
		char   ParentCode[24]; // @v8.8.0 [16]-->[24]
	};
	SLAPI  HierArray();
	const  HierArray::Item & SLAPI at(uint i) const;
	int    SLAPI Add(const char * pCode, const char * pParentCode);
	int    SLAPI SearchParentOf(const char * pCode, char * pBuf, size_t bufLen) const;
	int    SLAPI IsThereChildOf(const char * pParentCode) const;
};

class PPGoodsImpExpParam : public PPImpExpParam {
public:
	enum {
		fSkipZeroQtty     = 0x0001,
		fAnalyzeBarcode   = 0x0002,
		fAnalyzeName      = 0x0004,
		fAnalyzeOnly      = 0x0008,
		fUHTT             = 0x0010,
		fForceSnglBarcode = 0x0020,
		fImportImages     = 0x0040,
		fForceUpdateManuf = 0x0080  // @v8.9.1
	};
	SLAPI  PPGoodsImpExpParam(uint recId = 0, long flags = 0);
	void   SLAPI Clear();
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);

	int32   AccSheetID;
	int32   SupplID;
	int32   DefUnitID;
	int32   PhUnitID;
	int32   DefParentID;
	int32   RcptOpID;
	int32   Flags;
	int32   LocID;
	int32   MatrixAction;
	SString SubCode;
};

class PPGoodsExporter {
public:
	SLAPI  PPGoodsExporter();
	SLAPI ~PPGoodsExporter();
	int    SLAPI Init(const PPGoodsImpExpParam * pParam);
	int    SLAPI ExportPacket(PPGoodsPacket * pPack, const char * pBarcode, PPID altGrpID = 0); // realy pPack - const
private:
	char   WeightPrefix[12];
	PPGoodsImpExpParam Param;
	PPImpExp * P_IEGoods;
	PPObjGoods * P_GObj;
	PPObjPerson * P_PsnObj;
	PPObjQCert * P_QcObj;
};
//
//
//
class PPQuotImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPQuotImpExpParam(uint recId = 0, long flags = 0);
	void   SLAPI Clear();
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	int32   QuotKindID;
	int32   CurrID;
	int32   ArID;
	int32   LocID;
	int32   Flags;
};
//
//
//
class PPPhoneListImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPPhoneListImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	SString DefCityPhonePrefix;
};

int SLAPI EditPhoneListParam(const char * pIniSection);
//
//
//
class PPPersonImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPPersonImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	enum {
		f2GIS      = 0x0001, // Данные извлечены из сервиса 2GIS (импорт реализуется с некоторыми спецификами)
		fCodeToHex = 0x0002  // Код персоналии преобразуется к строке, каждый символ кода преобразуется //
			// в свое беззнаковое шестнадцатиричное представление (два символа). Буквы в этой строке находятся в верхнем регистре.
	};
	PPID   DefKindID;
	PPID   DefCategoryID;
	PPID   DefCityID;
	PPID   SrchRegTypeID;
	long   Flags;
};
//
//
//
class PPSCardImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPSCardImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	SString DefSeriesSymb;
	SString OwnerRegTypeCode;
};
//
//
//
class PPCliBnkImpExpParam : public PPImpExpParam {
public:
	PPCliBnkImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	int    DefPayerByAmtSign; // Если !0, то плательщик определяется по знаку суммы операции.
	SString BnkCode;          // Код банка, с которым происходит взаимодействие.
	SString PaymMethodTransl; // Трансляция вида платежа из Papyrus в client bank
};
//
//
//
struct LotViewItem;

class PPLotImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPLotImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);

	long   Flags;
	PPID   UhttGoodsCodeArID;
};

class PPLotExporter {
public:
	SLAPI  PPLotExporter();
	SLAPI ~PPLotExporter();
	int    SLAPI Init(const PPLotImpExpParam * pParam);
	int    SLAPI Export(const LotViewItem * pItem);
private:
	PPLotImpExpParam Param;
	PPObjPerson PsnObj;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	PPUhttClient UhttCli;
	PPImpExp * P_IE;
};
//
//
//
// Descr: Класс, управляющий информацией о загрузке данных на кассы, весы и, возможно,
//   другие устройства.
//   Класс используется двумя способами:
//   1. Фиксация информации о загрузке устройства.
//      DeviceLoadingStat dls;
//      PPID stat_id = 0;
//      dls.StartLoading(&stat_id, 1 /* cash_node */, cashNodeID, 0);
//      for(;;) {
//        DeviceLoadingStat::GoodsInfo dls_item;
//        // заполняем dls_item
//        dls.RegisterGoods(stat_id, &dls_item);
//      }
//      dls.FinishLoading(stat_id, 1, 0);
//   2. Извлечение информации об объектах, загруженных на устройства
//
enum DvcTypes {
	dvctCashs = 1,
	dvctScales
};

class DeviceLoadingStat : public DvcLoadingStatTbl {
public:
	struct GoodsInfo {
		PPID   ID;
		char   Name[64];
		long   PLU;
		double Price;
	};
	struct SCardInfo {
		PPID   ID;
		char   Code[32];
		double Discount;
	};
	SLAPI  DeviceLoadingStat();
	SLAPI ~DeviceLoadingStat();
	int    SLAPI StartLoading(PPID * pStatID, int deviceType, PPID deviceID, int use_ta);
	int    SLAPI RegisterGoods(PPID statID, const GoodsInfo *);
	int    SLAPI RegisterSCard(PPID statID, const SCardInfo *);
	int    SLAPI FinishLoading(PPID statID, int status, int use_ta);

	int    SLAPI Search(PPID statID, DvcLoadingStatTbl::Rec *);
	PPID   SLAPI GetCurStatID() const;
	//
	// Descr: Ищет последнюю запись по устройству типа dvcType с идентификатором dvcID,
	//   имеющую статус !0.
	// ARG(dvcType  IN): Тип устройства (1 - касса, 2 - весы).
	// ARG(dvcID    IN): ИД устройства
	// ARG(rDtm     IN): Функция ищет запись по указанному устройству до момента, не превышающего
	//   этот параметр. Если rDtm.d == 0, то поиск ведется с конца таблицы без ограничения по дате и времени.
	// ARG(pStatID OUT): @#{vptr0} Указатель на идентификатор найденной записи.
	// ARG(pRec    OUT): @#{vptr0} Указатель на буфер, в котором функция сохранит найденную запись
	// Returns:
	//   >0 - Требуемая запись найдена
	//   <0 - Нет ни одной подходящей записи
	//   0  - Ошибка
	//
	int    SLAPI GetLast(int dvcType, PPID dvcID, const LDATETIME & rDtm, PPID * pStatID, DvcLoadingStatTbl::Rec * pRec);
	//
	// Descr: Ищет запись, предшествующую записи curStatID по тому же устройству.
	//   Если curStatID == 0, то функция ищет запись, предшествующую this->StatID
	//
	int    SLAPI GetPrev(PPID curStatID, PPID * pStatID, DvcLoadingStatTbl::Rec * pRec);
	int    SLAPI GetLastObjInfo(int dvcType, PPID dvcID, PPID objType, PPID objID, LDATE dt, DlsObjTbl::Rec * pRec);
	int    SLAPI GetLastObjInfo(PPID objType, PPID objID, LDATE dt, DlsObjTbl::Rec * pRec);
		// @>>GetLastObjInfo(int, PPID, PPID, PPID, LDATE, DlsObjTbl::Rec *)
	int    SLAPI GetUpdatedObjects(PPID objType, const LDATETIME & since, PPIDArray * pObjList);
	int    SLAPI GetExportedObjectsSince(PPID objType, PPID sinceDlsID, PPIDArray * pObjList);
	int    SLAPI DoMaintain(LDATE toDt);
		// @>>DoDBMaintain
	int    SLAPI Remove(PPID id, int useTa);
private:
	int    SLAPI Fetch(PPID statID, DvcLoadingStatTbl::Rec * pRec);
	int    SLAPI CutTables(short dvcType, int use_ta);

	DlsObjTbl DlsoT;
	PPID   StatID;         // Текущая обрабатываемая сессия //
	long   StartClock;
	RAssocArray SCardList;
	SArray * P_GoodsList;
	SArray * P_StatCache;
};
//
// Descr: Класс AsyncCashGoodsGroupIterator, испольуемый для экспорта товарных групп в асинхронный кассовый модуль.
//
struct AsyncCashGoodsGroupInfo {
	SLAPI  AsyncCashGoodsGroupInfo();
	int    SLAPI Init();

	PPID   ID;
	char   Name[128];   // @name
	PPID   ParentID;    // ИД родительской группы
	PPID   UnitID;      // ИД торговое единицы измерения
	long   DivN;        // Номер отдела
	double VatRate;     // Ставка НДС (%)
	char   Code[32];    // Код группы
	uint   Level;
	const  PPQuotArray * P_QuotByQttyList;
};

class AsyncCashGoodsGroupIterator {
public:
	SLAPI  AsyncCashGoodsGroupIterator(PPID cashNodeID, long flags, DeviceLoadingStat * pDls, const PPIDArray * pTermGrpList = 0);
	SLAPI ~AsyncCashGoodsGroupIterator();
	int    SLAPI Init(PPID cashNodeID, long flags, DeviceLoadingStat * pDls, const PPIDArray * pTermGrpList = 0);
	int    SLAPI Next(AsyncCashGoodsGroupInfo *);
private:
	int    SLAPI MakeGroupList(StrAssocArray * pTreeList, PPID parentID, uint level); // @recursion

	uint   Pos;
	long   Flags;
	PPID   CashNodeID;
	PPAsyncCashNode AcnPack;
	PPObjGoods GObj;
	SArray    * P_GrpList;
	PPQuotArray QuotByQttyList; // Список котировок, применяемых для скидки на кол-во товаров из группы
	DeviceLoadingStat * P_Dls;  // @notowned
};
//
// Descr: Служебный класс AsyncCashGoodsIterator предназначен для экспорта
//   данных в асинхронную кассовую сессию
//
struct AsyncCashGoodsInfo { // @transient
	DECL_INVARIANT_C();
	SLAPI  AsyncCashGoodsInfo();
	void   SLAPI Init();
	int    SLAPI AdjustBarcode(int chkDig);

	PPID   ID;
	char   Name[128];      //
	char   Abbr[128];      //
	PPID   ParentID;       // ->Goods2.ID Родительская товарная группа
	PPID   UnitID;         // ->Unit.ID Единица измерения //
	PPID   ManufID;        // @v7.0.0 ->Person.ID ИД производителя товара
	PPID   GdsClsID;       // @v7.0.0 ->Ref(PPOBJ_GOODSCLASS) ИД класса товара
	char   BarCode[24];    // Штрихкод @v8.8.0 [16]-->[24]
	char   PrefBarCode[24]; // Предпочтительный штрихкод @v8.8.0 [16]-->[24]
	double UnitPerPack;    // Емкость упаковки
	double Cost;           // Цена поступления //
	double Price;          // Цена реализации
	double ExtQuot;        // Специальная цена (соответствует котировке типа PPCashNode.ExtQuotID)
	double Rest;           // Остаток
	double Precision;      // Точность для дробного количества товара. Некоторые кассовые модули
		// позволяют загружать т.н. максимальную дробность представления количества товара.
		// Если в записе кассового узла установлен флаг CASHFX_APPLYUNITRND, то это поле
		// заполняется значением Rounding из записи торговой единицы измерения товара.
		// Если флаг CASHFX_APPLYUNITRND не задан или единица измерения имеет Rounding == 0,
		// то Precision = 0.001.
	long   GoodsFlags;     // @v7.4.12 Флаги записи товара
	short  Deleted_;       // Признак того, что товар был удален
	short  NoDis;          // Запрет скидки на товар (> 0 - без скидки, 0 - со скидкой,
		// -1 - со скидкой (признак "без скидки" был снят)
	long   DivN;           // Номер отдела
	PPID   LocPrnID;       // ->Ref(PPOBJ_LOCPRINTER)
	char   LocPrnSymb[20]; // Символ локального принтера LocPrnID
	PPID   AsscPosNodeID;       // @v7.9.7 Ассоциированный с товаром кассовый аппарат
	char   AsscPosNodeSymb[20]; // @v7.9.7 Символ ассоциированного с товаров кассового аппарата
	double VatRate;        // Ставка НДС
	RAssocArray QuotList;  // Список дополнительных котировок.
		// Вызывающая функция заполняет поля Key идентификаторами видов котировок.
		// AsyncCashGoodsIterator инициализирует поля Val массива соответствующими
		// эффективными значениями котировок.
	StringSet AddedMsgList; // @v7.0.0 Список дополнительных текстовых полей, составленный
		// по правилам, определенным полем PPAsyncCashNode::AddedMsgSign.
	SString LabelName;      // @v7.0.0 Наименование для ценника (этикетки и т.д.)
		// Извлекается вызовом PPGoodsPacket::GetExtStrData(GDSEXSTR_LABELNAME, SString &)
	const PPQuotArray  * P_QuotByQttyList; // @ownedby(AsyncCashGoodsIterator)
	const BarcodeArray * P_CodeList;       // @v9.0.6 @ownedby(AsyncCashGoodsIterator)
};

#define ACGIF_UPDATEDONLY       0x0001 // Только измененные товары
#define ACGIF_GETCURPRICE       0x0002 // Выдавать текущую цену товара (а не по розничным котировкам)
#define ACGIF_DONTUSEQUOTWTIME  0x0004 // Не включать в список видов котировок, используемых
	// для определения базовой цены, виды с определенным периодом временем.
#define ACGIF_INITLOCPRN        0x0008 // Инициализировать идентификатор и символ локального принтера,
	// ассоциированного со складом, с которым, в свою очередь, ассоциирован товар.
#define ACGIF_UNCONDBASEPRICE   0x0010 // @v7.1.3 Базовая цена - без учета розничных котировок
	// Инициализируется самим классом AsyncCashGoodsIterator как проекция флага PPEquipConfig::fUncondAsyncBasePrice
#define ACGIF_EXCLALTFOLD       0x0020 // @internal @v7.3.0 Товарная группа, заданная в кассовом узле является группой-папкой
	// эксклюзивных альтернат групп.
#define ACGIF_ALLCODESPERITER   0x0040 // @v9.0.6 Все коды товара передавать в одной итерации
#define ACGIF_REDOSINCEDLS      0x0080 // @v9.0.11 Повторная выгрузка данных, которые были начиная с заданного DLSID

class AsyncCashGoodsIterator {
public:
	SLAPI  AsyncCashGoodsIterator(PPID cashNodeID, long flags, PPID sinceDlsID, DeviceLoadingStat * pDls);
	SLAPI ~AsyncCashGoodsIterator();
	int    SLAPI Init(PPID cashNodeID, long flags, PPID sinceDlsID, DeviceLoadingStat * pDls);
	int    SLAPI Next(AsyncCashGoodsInfo *);
	const  IterCounter & SLAPI GetIterCounter() const;
	int    SLAPI UpdateCPrice(PPID goodsID, double price);
	AsyncCashGoodsGroupIterator * GetGroupIterator(); // @v7.3.0
	//
	// Descr: Находит список уникальных и отличающихся от basePrice цен по открытым лотам товара goodsID
	//   за период getcurdate_()-PricesLookBackPeriod..
	//   и возвращает их в массиве rList.
	//   Функция требуется в некоторых ситуациях, когда необходимо предоставлять ручной выбор
	//   цены из набора возможных.
	// Returns:
	//   >0 - PricesLookBackPeriod > 0 и найдена по крайней мере одна цена, отличающаяся от basePrice
	//   <0 - PricesLookBackPeriod < 0 или не найдено цен, отличающихся от basePrice
	//
	int    SLAPI GetDifferentPricesForLookBackPeriod(PPID goodsID, double basePrice, RealArray & rList);
	PPID   SLAPI GetAlcoGoodsCls(SString * pProofExpr, SString * pVolumeExpr) const;
	PPID   SLAPI GetTobaccoGoodsCls() const;
	PPID   SLAPI GetGiftCardGoodsCls() const;
	int    SLAPI GetAlcoGoodsExtension(PPID goodsID, PPID lotID, PrcssrAlcReport::GoodsItem & rExt);
private:
	int    SLAPI SearchCPrice(PPID goodsID, double * price);
	int    LotThreshold;   // Количество дней от последнего прихода,
		// после которого товар, по которому остаток нулевой, не следует загружать на кассовые аппараты
	long   Flags;                 // ACGIF_XXX
	PPID   CashNodeID;            // Кассовый узел для которого формируется список товаров
	PPID   LocID;
	PPID   UserOnlyGoodsGrpID;    // Товарная группа, которой ограничен пользователь при загрузке изменений.
	PPID   SinceDlsID;            // Ид записи статистики загрузки, начиная (включая) с которой следует выгрузить изменения //
	enum {
		algDefault = 0,
		algUpdBillsVerify,
		algUpdBills
	};
	int    Algorithm;             //
	SString VerMissMsg;           // Шаблон сообщения для вывода информации о том, что товар,
		// попавший в загрузку, не соответствует критерию нового алгоритма algUpdBills
	PPAsyncCashNode AcnPack;      //
	LAssocArray BcPrefixList;     // Список весов, ассоциированных с префиксами штрихкодов
	SysJournal SJ;                //
	CCurPriceTbl CCP;             //
	PPObjGoods GObj;              //
	PPObjGoodsClass GcObj;        // @v8.5.4
	PPObjLocPrinter LpObj;        //
	PPObjCashNode CnObj;          // @v7.9.7
	GoodsIterator Iter;           // Итератор по товарам
	BarcodeArray  Codes;          // Список кодов для текущего товара

	PPID   AlcoGoodsClsID;        // @v8.5.4
	PPID   TobaccoGoodsClsID;     // @v8.5.4
	PPID   GiftCardGoodsClsID;    // @v8.5.4
	int    PricesLookBackPeriod;  // @v8.5.4 Количество дней за которые необходимо просмотреть прошлые лоты для нахождения списка дополнительных цен
	SString AlcoProofExpr;        // @v8.5.4
	SString AlcoVolExpr;          // @v8.5.4

	uint   CodePos;               //
	uint   GoodsPos;              //
	LDATE  CurDate;               // @!Init()
	AsyncCashGoodsInfo Rec;       //
	PPIDArray   UpdGoods;         //
	PPIDArray   IterGoodsList;    //
	PPIDArray   NoDisToggleGoodsList; // @v8.1.0 Список товаров, по которым был снят признак "без скидки" (за заданный период)
	PPQuotArray QuotByQttyList;   // Список котировок, применяемых для скидки на кол-во товара
	RetailPriceExtractor  RetailExtr;
	DeviceLoadingStat * P_Dls;    // @notowned
	GoodsToObjAssoc * P_G2OAssoc; //
	GoodsToObjAssoc * P_G2DAssoc; // Ассоцииации {товар-кассовый узел} для загрузки номеров кассовый аппаратов, ассоциированных с товарами
	LAssocArray LocPrnAssoc;      // Список ассоциаций Склад-Локальный принтер
	LAssocArray GroupAssoc;       // Список товарных групп, ассоциированных с товарами.
	IterCounter InnerCounter;     // Используется если (Flags & ACGIF_UPDATEDONLY && Algorithm == algUpdBills)
	AsyncCashGoodsGroupIterator * P_AcggIter; //
	PrcssrAlcReport * P_AlcPrc;   // @v8.9.8
};
//
// @ModuleDecl(PPViewQuot)
//
// QuotFilt определен выше так как используется в классе Quot2Iterator
//
#define MAX_QUOTS_PER_TERM_REC 32

struct QuotViewItem {
	PPID   GoodsID;
	PPID   LocID;
	PPID   ArticleID;
	char   Quots[MAX_QUOTS_PER_TERM_REC][10];
};

class  VQuotCache;
class  ExtGoodsSelDialog;

class PPViewQuot : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoods,
		OrdByArGoods
	};
	struct BrwHdr {
		PPID   GoodsID;
		PPID   LocID;
		PPID   ArticleID;
		PPID   QuotKindID;
		int32  PeriodIdx;
	};
	//
	// Descr: Заголовок строки данных таблицы временного изменения котировки
	//
	struct BrwHdrSer {
		LDATETIME Dtm;
		double Val;
		long   ValF;
	};

	SLAPI  PPViewQuot();
	SLAPI ~PPViewQuot();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI GetTabTitle(long tabID, SString & rBuf);

	const  StrAssocArray & SLAPI GetQuotKindList() const;
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(QuotViewItem *);
	//
	// Descr: Предлагает пользователю редактировать котировки по товару, которого нет
	//   в выборке. Если pGoodsID == 0 || *pGoodsID == 0, то система предлагает выбрать товар.
	//
	int    SLAPI AddItem(PPID * pGoodsID);
	int    SLAPI EditItem(const BrwHdr *, int simple);
	int    SLAPI Transmit(const BrwHdr *);
	int    SLAPI Export();
	int    SLAPI Recover();
	int    SLAPI GetCtQuotVal(const void * pRow, long col, long aggrNum, double * pVal);
	int    SLAPI GetEditIds(const void * pRow, PPViewQuot::BrwHdr * pHdr, long col);
	const  PPQuotItemArray * SLAPI GetQList() const;
private:
	static  int CellStyleFunc(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, void * extraPtr);
	static  int DynFuncPeriod;

	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int SLAPI Print(const void * pHdr);
	virtual int SLAPI ViewTotal();
	int    SLAPI UpdateTempTable(PPID goodsID, int use_ta);
	int    SLAPI Helper_CreateTmpTblEntries(const QuotFilt *, PPQuotItemArray * pQList, int use_ta);
	int    SLAPI Helper_RemoveTempRecsByGoodsID(PPID goodsID, int use_ta);
	int    SLAPI CreateCrosstab(int useTa);
	int    SLAPI CheckDelFromMtx(PPID goodsID);
	int    SLAPI CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    SLAPI MakeOrderEntry(IterOrder ord, const TempQuotTbl::Rec & rSrcRec, TempOrderTbl::Rec & rDestRec);
	int    FASTCALL CheckGoodsKindDiffRestriction(PPID goodsID);

	QuotFilt Filt;
	QuotationCore * P_Qc;
	Quotation2Core * P_Qc2;
	PPObjQuotKind QkObj;
	PPObjGoods GObj;
	PPObjLocation LocObj;
	PPObjArticle ArObj;
	PPObjBill * P_BObj; // @notowned
	StrAssocArray QuotKindList;
	TempQuotTbl * P_TempTbl;
	TempQuotSerialTbl * P_TempSerTbl;
	TempOrderTbl * P_TempOrd; // @v8.1.1
	PPIDArray QkList;
	ExtGoodsSelDialog * P_GoodsSelDlg;
	PPQuotItemArray QList_;
	//
	// Это поле инициализируется функцией Browse()
	// и используется для вычисления вида котировки, соответствующего
	// текущей позиции броузера.
	//
	int    FirstQuotBrwColumn;
	int    HasPeriodVal;        // Временная таблица содержит по крайней мере одно значение, ограниченное периодом действия //
	PPObjQuotKind::Special Spc;
};
//
// @ModuleDecl(PPObjScale)
// Электронные весы
//
#define SCALF_STRIPWP    0x0001L // Игнорировать весовой префикс
#define SCALF_EXSGOODS   0x0002L // Загружать товары, которые есть на складе
#define SCALF_SYSPINITED 0x0004L // Системные параметры инициализированы (иначе default)
#define SCALF_TCPIP      0x0008L // Грузим данные используя TCP/IP соединение, адрес хранится в поле Port
#define SCALF_CHKINVPAR  0x0010L // Проверять при загрузке данные на ошибки (штрихкод, срок хранения)
#define SCALF_PASSIVE    0x0020L // Признак "Пассивный". Означает что данные на эти весы грузиться не будут.

struct PPScale2 {          // @persistent @store(Reference2Tbl+)
	PPScale2();
	int    SLAPI IsValidBcPrefix() const;

	long   Tag;              // Const=PPOBJ_SCALE
	long   ID;               // @id
	char   Name[48];         // @name @!refname
	char   Symb[20];         //
	PPID   ParentID;         // Ид. группы весов
	char   AddedMsgSign[8];  // Символы дополнительных полей, которые следует загружать на весы
	int16  MaxAddedLine;     // Максимальная длина строки дополнительного текста.
		// Если не указано, то система принимает значение на свое усмотрение.
	char   Reserve[10];      // @reserve
	//
	// Если Flags & SCALF_TCPIP, то IP-адрес устройства упаковывается в
	// поле Port в виде: Port[0].Port[1].Port[2].Port[3]
	//
	char   Port[8];        // Порт обмена
	//
	// System params {
	//
	uint16 Get_NumTries;   // @#{0..32000}
	uint16 Get_Delay;      // @#{0..1000}
	uint16 Put_NumTries;   // @#{0..32000}
	uint16 Put_Delay;      // @#{0..1000}
	// }
	int16  BcPrefix;       // Префикс искусственного штирхкода, загружаемого на весы
	uint16 Reserve2;       // @alignment
	PPID   QuotKindID;     // ->Ref(PPOBJ_QUOTKIND) Вид котировки, используемый для ценообразования //
	PPID   ScaleTypeID;    // Тип устройства
	long   ProtocolVer;    // Версия протокола обмена. Зависит от типа устройства
	long   LogNum;         // Логический номер устройства. Применяется для некоторых типов устройств.
	long   Flags;          // SCALF_XXX
	long   Location;       // ->Location.ID Склад, к которому относится устройство
	long   AltGoodsGrp;    // ->Goods2.ID   Альтернативная группа товаров, загружаемая на весы
};

DECL_REF_REC(PPScale);

class PPObjScale : public PPObjReference {
public:
	struct Stat {
		uint   NumSendPluColl;      // Количество коллизий в функции PPObjScale::SendPlu
		uint   MaxSendPluCollIters; // Максимальное количество итерациий, вызыванных при обработке
			// коллизий в функции PPObjScale::SendPlu
		uint   NumGetColl;          // Количество коллизий в функции PPScaleDevice::GetChr()
		uint   MaxGetCollIters;     // Максимальное количество итераций, вызванных при обработке
			// коллизий в функции PPScaleDevice::GetChr()
	};
	//
	// Флаги функции PPObjScale::TransmitData
	//
	enum {
		fTrUpdateOnly  = 0x0001, // Загружать только изменения //
		fTrSkipListing = 0x0002  // Не предлагать печать листинга и не печатать
	};
	static int SLAPI PrepareData(PPID scaleID);
	static int SLAPI TransmitData(PPID scaleID);
	static int SLAPI EncodeIP(const char * pIP, char * pEncodedIP, size_t ipSize);
	static int SLAPI DecodeIP(const char * pEncodedIP, char * pIP);
	static void * SLAPI MakeExtraParam(long scaleTypeID, long groupID);
	static int CheckForConnection(const char * pIPAddress, uint timeout, uint attemptCount);

	SLAPI  PPObjScale(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	//
	// Descr: Проверяет запись весов pRec на уникальность значения IP-адреса (если установлен флаг SCALF_TCPIP)
	//   и значения BcPrefix (если оно не нулевое).
	// ARG(objID IN): идентификатор проверяемой записи (0 - если запись новая)
	// ARG(pRec  IN): @#{vptr} проверяемая запись
	// Returns:
	//   >0 - запись pRec удовлетворяет требованиям уникальности полей Port и BcPrefix
	//   0  - в записи pRec дублируется либо Port либо BcPrefix (устанавливается соотвествующий код ошибки PPErrCode).
	//
	int    SLAPI CheckDup(PPID objID, const PPScale * pRec);
	int    SLAPI PrepareData(PPID, long flags, PPLogger * pLogger);
	int    SLAPI TransmitData(PPID, long flags, PPLogger * pLogger);
	int    SLAPI GetStat(Stat *) const;
	//
	// Descr: Возвращает список устройств, у которых определен префикс штрихкода.
	//   Результать заноситься в массив pList парами {ID устройства, префикс штрихкода}.
	//   Функция учитывает только те устройства, для которых префиксы попадают в один из двух
	//   диапазонов: [20..29] и [200..299].
	// Note: Если pList == 0, то функция не пытается ничего делать со списком, но возрващает
	//   тот же код, как буд-то указатель не нулевой.
	// ARG(pList OUT): @#{vptr0} указатель на список, в который заносятся искомые пары.
	//   Функция предварительно очищает список (если указатель не нулевой).
	// Returns:
	//   <0 - функция нашла по крайней мере одно устройство с заданным допустимым префиксом
	//   <0 - не определено ни одного утсройства с заданным допустимым префиксом
	//   0  - ошибка
	//
	int    SLAPI GetListWithBcPrefix(LAssocArray * pList);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//
	int    SLAPI Fetch(PPID id, PPScale * pRec);
	//
	// Descr: Проверяет, установлен-ли у весов или у группы к которой принадлежат весы признак SCALF_PASSIVE
	//
	int    SLAPI IsPassive(PPID id, PPScale * pScale);
protected:
	int    SLAPI SendPlu(PPScale *, const char * pFileName, int updateOnly, PPLogger * pLogger);
	int    SLAPI InitStat();

	Stat   StatBuf;
private:
	virtual int  SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
};
//
// @ModuleDecl(PPObjBHT)
//
#define RCPTPLACE_ALTGROUP  0
#define RCPTPLACE_GBASKET   1

struct PPBhtTerminal2 {    // @persistent @store(Reference2Tbl+)
	enum {
		fDelAfterImport = 0x00000001L
	};
	PPID   Tag;            // Const=PPOBJ_BHT
	PPID   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve[24];    // @reserve
	PPID   LocID;          // @v8.4.2 Привязка терминала к складу.
	char   Port[8];        // Output port name (default "COM1")
	//
	// Параметры com-порта
	//
	uint16 ComGet_NumTries; // @#{0..32000} not used
	uint16 ComGet_Delay;    // @#{0..1000}  for Win32 only
	uint16 ComPut_NumTries; // @#{0..32000} not used
	uint16 ComPut_Delay;    // @#{0..1000}  not used
	PPID   IntrExpndOpID;  // Операция внутреннего перемещения (PPOPT_GOODSEXPEND || PPOPT_DRAFTEXPEND)
	PPID   InventOpID;     // Inventory Operation Kind ID
	int16  Cbr;            // ComBaudRate (default 19200)
	uint16 BhtpTimeout;    // Bht protocol timeout, mc (default 3000)
	uint16 BhtpMaxTries;   // Bht protocol max attempts sending data (default 10)
	short  ReceiptPlace;   // Куда качать накладные  @todo > Flags
	long   Flags;          //
	long   BhtTypeID;      // Reserved (Denso only)
	PPID   ExpendOpID;     // Expend Operation Kind ID (PPOPT_GOODSEXPEND || PPOPT_DRAFTEXPEND)
};

DECL_REF_REC(PPBhtTerminal);

struct SBIIOpInfo { // @persistent @size=24
	long   OpID;
	long   ToBhtOpID;
	long   ToHostOpID;
	long   BhtOkCancelActions;
	long   BhtCfmActions;
	long   Flags;
};

typedef TSArray <SBIIOpInfo> SBIIOpInfoArray;

struct StyloBhtIIOnHostCfg {
	SLAPI  StyloBhtIIOnHostCfg();
	SLAPI ~StyloBhtIIOnHostCfg();
	void   SLAPI Init();
	StyloBhtIIOnHostCfg & FASTCALL operator = (const StyloBhtIIOnHostCfg & rSrc);
	int    SLAPI IsEmpty() const;
	PPID   SLAPI GetOpID(PPID opID) const;
	int    SLAPI IsCostAsPrice(PPID opID) const;
	int    SLAPI IsValid();

	SString DeviceName;
	SString WeightPrefix;
	SString QttyWeightPrefix;
	SString UserName;
	SString Password;
	ulong   ServerAddr;
	ulong   ServerPort;
	ulong   ServerMask;
	long    Flags;
	PPID    BcdPrinterID;
	double  DefQtty;
	DateRange ExportBillsPeriod;
	SBIIOpInfoArray * P_OpList;
};

struct StyloBhtIIConfig;

struct PPBhtTerminalPacket {
	SLAPI  PPBhtTerminalPacket();
	SLAPI ~PPBhtTerminalPacket();
	PPBhtTerminalPacket & FASTCALL operator = (const PPBhtTerminalPacket &);
	//
	// Descr: Конвертирует пакет в структуру конфигурации StyloBHTII.
	// ARG(expKind IN): Категория данных, для которой должно быть инициирована
	//   время последнего обмена:
	//  -1 - ничего (все поля XxxLastExch остаются нулевыми).
	//   0 - all (товары, контрагенты, документы)
	//   1 - только товары
	//   2 - только контрагенты
	//   4 - только документы
	// ARG(pCfg OUT): @#{vptr0} Указатель, по которому в случае успеха будут
	//   скопированы данные конфигурации.
	//
	// Return:
	//   >0 - конвертация осуществлена успешно
	//   <0 - (P_SBIICfg==0)
	//
	int    ConvertToConfig(int expKind, StyloBhtIIConfig * pCfg) const;

	PPBhtTerminal Rec;
	GoodsFilt * P_Filt;
	StyloBhtIIOnHostCfg * P_SBIICfg;
	//char   ImpExpPath_[256];
	SString ImpExpPath_;
};

class PPObjBHT : public PPObjReference {
public:
	enum {
		btDenso      = 0L,
		btSyntech    = 1L,
		btPalm       = 2L,
		btWinCe      = 3L,
		btCom        = 4L,
		btStyloBhtII = 5L // терминал на котором установлена программа StyloBhtII
	};
	struct BillRec {
		PPID   ID;
		PPID   SupplID;
		LDATE  Dt;
	};
	struct BillLineRec {
		PPID   BillID;
		PPID   GoodsID;
		double Price;
		double Quantity;
		LDATE  Expiry;
	};
	struct InventRec {
		PPID   ID;
		LDATE  Dt;
		S_GUID Uuid;
		char   Code[32];
	};
	struct InventLineRec {
		PPID   InventID;
		PPID   GoodsID;
		double Price;
		double Quantity;
	};

	static int SLAPI TransmitProgram(); // @TEMP
	static int SLAPI TransmitData();
	static int SLAPI ReceiveData();

	SLAPI  PPObjBHT(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI PutPacket(PPID * pID, PPBhtTerminalPacket *, int use_ta);
	int    SLAPI GetPacket(PPID, PPBhtTerminalPacket *);
	int    SLAPI InitProtocol(PPID, BhtProtocol *);
	int    SLAPI InitProtocol(PPID, CipherProtocol *);
	int    SLAPI TransmitSuppl(BhtProtocol *, int updateData);
	int    SLAPI TransmitGoods(PPID bhtID, BhtProtocol *, int updateData);
	int    SLAPI TransmitSuppl(CipherProtocol *, int updateData);
	int    SLAPI TransmitGoods(PPID bhtID, CipherProtocol *, int updateData);
	int    SLAPI ReceiveBills(PPID);
	int    SLAPI ReceiveInvent(PPID);
	int    SLAPI AcceptBill(PPObjBHT::BillRec * pRec, PPBasketPacket * pGBPack, PPID * pAltGrpID);
	int    SLAPI AcceptBillLine(PPID billID, PPObjBHT::BillLineRec * pRec, PPBasketPacket * pGBPack, PPID * pAltGrpID);
	int    SLAPI AcceptInvent(PPID opID, PPObjBHT::InventRec * pRec, BillTbl::Rec * pInvRec, PPLogger * pLogger);
	// @v9.4.9 int    SLAPI PrepareBillData(PPBhtTerminalPacket * pPack, int uniteGoods = 1);
	int    SLAPI PrepareBillData2(PPBhtTerminalPacket * pPack, PPIDArray * pGoodsList, int uniteGoods = 1);
	int    SLAPI PrepareBillRowCellData(PPBhtTerminalPacket * pPack, PPID billID);
	int    SLAPI PrepareLocCellData(PPBhtTerminalPacket * pPack);
	int    SLAPI PrepareConfigData(const PPBhtTerminalPacket * pPack, StyloBhtIIConfig * pCfg);
private:
	static int SLAPI AcceptBills(const char * pHName, const char * pLName, PPLogger *);
	static int SLAPI AcceptBillsToGBasket(const char * pHName, const char * pLName, PPLogger *);
	static int SLAPI AcceptInvent(const char * pHName, const char * pLName, PPID opID, PPLogger *);
	static int SLAPI AcceptExpendBills(const char * pHName, const char * pLName, const PPBhtTerminal *, PPLogger *);
	static int SLAPI AddEBLineToPacket(PPBillPacket *, const char * pBarcode, double qtty, double price, PPLogger *);
	static int SLAPI AcceptBillsPalm(const char * pHName, const char * pLName, PPLogger *);
	static int SLAPI AcceptBillsToGBasketPalm(const char * pHName, const char * pLName, PPLogger *);
	static int SLAPI AcceptInventPalm(const char * pHName, const char * pLName, PPID opID, PPLogger *);
	static int SLAPI AcceptExpendBillsPalm(const char * pHName, const char * pLName, const PPBhtTerminal *, PPLogger *);
	static int SLAPI AcceptTechSessPalm(const char * pLName, PPLogger *);
	static int SLAPI AcceptBillsSBII(const PPBhtTerminalPacket * pPack, PPID destIntrLocID, const char * pHName, const char * pLName, PPLogger *);

	int    SLAPI PrepareGoodsData(PPID bhtID, const char * pPath, const char * pPath2, PPID bhtTypeID, const PPIDArray * pAddendumGoodsIdList);
	int    SLAPI PrepareSupplData(const char * pPath, PPBhtTerminalPacket * pPack = 0);
	int    SLAPI PrepareLocData(const char * pPath, PPID bhtTypeID);
	int    SLAPI PrepareTechSessData(const char * pPath, PPID bhtTypeID);
	void   SLAPI InitGoodsBhtRec(BhtRecord *) const;
	void   SLAPI InitSupplBhtRec(BhtRecord *) const;

	PPObjGoods GObj;
	PPObjGoodsGroup GGObj;
	PPObjBill * P_BObj;
};
//
//
//
class StyloBhtIIExchanger {
public:
	SLAPI  StyloBhtIIExchanger(/*TcpSocket * pSo*/);
	SLAPI ~StyloBhtIIExchanger();
	//int    SLAPI Run();
	int    FASTCALL ProcessSocketInput(TcpSocket & rSo);
private:
	int    SLAPI GetTable(TcpSocket & rSo, int16 Cmd, uint fileNameCode, const char * pTblInfo, SBIIRec * pRec, long nextRecNo);
	int    SLAPI SetTable(TcpSocket & rSo, int16 cmd, uint fileNameCode, const char * pTblInfo, SBIIRec * pRec, long count);
	int    SLAPI PrepareBills(int uniteGoods);
	int    SLAPI GetConfig(StyloBhtIIConfig * pCfg);
	int    SLAPI GetGoodsList(TcpSocket & rSo, long cellID, int getGoods);
	int    SLAPI AcceptLocOp(SBIILocOp * pRec);
	int    SLAPI FindGoods(PPID goodsID, const char * pBarcode, SBIIGoodsRec * pRec);
	int    SLAPI FindLocCell(PPID locID, const char * pName, SBIILocCellRec * pRec);
	int    SLAPI PrintBarcode(const char * pBarcode);
	int    SLAPI SendCmd(TcpSocket & rSo, int16 cmd, int32 retcode, const void * pBuf, size_t bufSize);
	int    SLAPI RecvCommand(TcpSocket & rSo, void * pBuf, size_t bufSize, size_t * pRecvBytes = 0);
	int    SLAPI Log_(uint errCode, uint msgCode, const char * pAddInfo);
	int    SLAPI Log_(uint errCode, uint msgCode, const char * pAddInfo, long count, long total);

	SString DeviceDir;
	//TcpSocket * P_So;
	StyloBhtIIConfig Cfg;
	PPBhtTerminalPacket BhtPack;
	PPObjGoods GObj;
	PPObjLocation LocObj;
	LocTransfCore * P_LocTransf;
};
//
// @ModuleDecl(PPObjQCert)
//
class PPObjQCert : public PPObject {
	//
	// Дополнительный параметр содержит мин. дату закрытия сертификата.
	// Используется только функцией Selector
	//
public:
	SLAPI  PPObjQCert(void * extraPtr = 0);
	SLAPI ~PPObjQCert();
	virtual int    SLAPI Browse(void * extraPtr);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI DeleteObj(PPID id);
	virtual ListBoxDef * SLAPI Selector(void * extraPtr /* goodsID */);
	virtual int    SLAPI Search(PPID id, void * b = 0);
	virtual int    SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int    SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int    SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SearchByCode(const char * pCode, PPID * pID, QualityCertTbl::Rec * pRec);
	int    SLAPI PutPacket(PPID * pID, QualityCertTbl::Rec * pPack, int use_ta);
	//
	// DescrL Устанавливает (set != 0) или снимает (set == 0) признак Passive для //
	//   записи с идентификатором id.
	// Returns:
	//   >0 - признак установлен (снят)
	//   <0 - признак уже находится в заданном состоянии
	//   0  - ошибка
	//
	int    SLAPI SetPassiveTag(PPID id, int set, int use_ta);
private:
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual const char * SLAPI GetNamePtr();
public:
	TLP_MEMB(QualityCertTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewQCert)
//
class QCertFilt : public PPBaseFilt {
public:
	SLAPI  QCertFilt();
	enum {
		fHasRest     = 0x0001, // Ненулевой остаток товаров
		fShowPassive = 0x0002  // Показывать пассивные сертификаты
	};
	char   ReserveStart[32];   // @anchor
	DateRange ExpiryPeriod;    //
	DateRange InitPeriod;      //
	PPID   RegOrgan;           //
	char   CodeStr[32];        // Строка, содержащаяся в коде
	char   InnerCode[24];      // Внутренний код сертификата
	long   Flags;
	long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef QualityCertTbl::Rec QCertViewItem;

class PPViewQCert : public PPView {
public:
	SLAPI  PPViewQCert();
	SLAPI ~PPViewQCert();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(QCertViewItem *);
private:
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ViewTotal();
	int    SLAPI Transmit();
	int    SLAPI SetPassiveTag(int set);

	QCertFilt Filt;
	PPObjQCert QcObj;
	ReceiptCore * P_RcptT;        // PPViewQCert is not owned by P_RcptT
	QualityCertTbl * P_TempTbl;
};
//
// Флаги редактирования бух. проводки
//
#define ATDF_DSBLDOC      0x00000001L
#define ATDF_DSBLDATE     0x00000002L
#define ATDF_DSBLAMOUNT   0x00000004L
#define ATDF_DSBLDACC     0x00000008L
#define ATDF_DSBLDART     0x00000010L
#define ATDF_DSBLCACC     0x00000020L
#define ATDF_DSBLCART     0x00000040L
#define ATDF_DSBLALL      0x0000007fL
//
// Структуры для агрегированного расчета НДС
//
struct BVATAccm {
	SLAPI  BVATAccm();
	int    IsVatFree; // ставка по освобожденным от уплаты НДС поставщиков
	double CRate;
	double PRate;
	double Cost;
	double Price;
	double CVATSum;
	double PVATSum;
	double PTrnovr;
	double Discount;
};
//
// Флаги класса BVATAccmArray
//
#define BVATF_IGNORESUPPL 0x0001 // Игнорировать зависимость НДС от поставщика
#define BVATF_SUMZEROVAT  0x0002 // Суммировать строки с освобожденными значениями
#define BVATF_DIFFBYCRATE 0x0004 // @v3.5.0 Различать элементы по ставке входящего НДС

class BVATAccmArray : public TSArray <BVATAccm> {
public:
	SLAPI  BVATAccmArray(uint aFlags = 0);
	int    SLAPI CalcBill(PPID);
	int    SLAPI CalcBill(const PPBillPacket *);
	int    SLAPI Scale_(double part, int useRounding);
	int    SLAPI Add(const PPTransferItem *, PPID opID);
	int    SLAPI Add(const BVATAccm *, int dontRound = 0);
private:
	int    SLAPI IsVataxableSuppl(PPID);

	PPObjGoods GObj;
public:
	uint   Flags;
};
//
// Флаги поля PPObjBill::state
// Эти флаги работают только на уровне пользовательского интерфейса.
// Они сами по себе не влияют на работу исполнительных функций типа
// PPObjBill::TurnPacket, а лишь запрещают обработку событий от
// пользователя (мышь, клавиатура и пр.)
//
#define BILLST_NOADD         0x0001  // Запрет ввода документов
#define BILLST_NORMV         0x0002  // Запрет удаления документов
#define BILLST_NOUPD         0x0004  // Запрет изменения документов
#define BILLST_NOOPR         (BILLST_NOADD|BILLST_NORMV|BILLST_NOUPD)
#define BILLST_ORDERONLY     0x0008  // Показывать и добавлять только заказы
#define BILLST_ACCBONLY      0x0010  // Показывать только бухгалтерские документы
#define BILLST_INVONLY       0x0020  // Показывать только инвентаризацию
#define BILLST_POOLONLY      0x0040  // Показывать только пулы документов
//
// Специфические флаги доступа PPObjBill (в дополнение к общим PPR_XXX)
//
#define BILLRT_CASH          0x0100
#define BILLRT_CLOSECASH     0x0200
#define BILLRT_OPENCASH      0x0400
#define BILLRT_MODDATE       0x0800
#define BILLRT_SYSINFO       0x1000
#define BILLRT_MODGOODS      0x2000 // Модификация товара в приходе
#define BILLRT_USEWLABEL     0x4000 // Разрешение на использование WL
#define BILLRT_ACCSCOST      0x8000 // Доступ к ценам поступления //

#define BILLOPRT_MULTUPD     0x0001 // Массовое изменение документов
#define BILLOPRT_UNITEBILLS  0x0002 // Объединение документов
#define BILLOPRT_MODOBJ      0x0004 // Модификация контрагента
#define BILLOPRT_MODSTATUS   0x0008 // Модификация статуса
// @v6.3.0 #define BILLOPRT_NOTONLYOWNVIEW 0x0010 // @v6.2.8 Просмотр документов, не зависимо от того, каким пользователем созданы эти документы.
	// Негативный смысл опции связан с тем, что по умолчанию, это значение флагов прав доступа включено.
#define BILLOPRT_CANCELQUOT  0x0010 // Право на отмену установленной котировки в строке документа
#define BILLOPRT_TOTALDSCNT  0x0020 // Право на установку скидки на весь документ
#define BILLOPRT_MODFREIGHT  0x0040 // Право на модификацию фрахта. Опция действует независимо от права на модификацию
	// документа, но не переопределяет статусный запрет на модификацию.
#define BILLOPRT_MODTRANSM   0x0080 // Право на изменение компонентов товарных документов, которые уже были переданы
	// в другой раздел при том, что вносимые изменения не смогут быть изменены в разделе-получателе.
#define BILLOPRT_ACCSSUPPL   0x0100 // @v7.2.4 Доступ к информации о поставщике лота
#define BILLOPRT_REJECT      0x0200 // @v9.0.1 Право на установку признака 'Отклонен' на документе (если вид операции допускает такое действие)
#define BILLOPRT_EMPTY       0x0400 // @v9.3.1 Право на сохранение пустого документа
//
// Флаги функции PPObjBill::ConvertILTI
//
#define CILTIF_DEFAULT             0x0000 //
#define CILTIF_OPTMZLOTS           0x0001 // Оптимизировать лоты
#define CILTIF_USEGENGOODS         0x0002 // @obsolete Использовать лоты обобщенных товаров
#define CILTIF_USESUBST            0x0002 // Использовать подстановку
#define CILTIF_ABSQTTY             0x0004 // Устанавливать абсолютное значение PPTransferItem::Quantity
#define CILTIF_QUOT                0x0008 // Устанавливать флаг PPTFR_QUOT в строках
#define CILTIF_ZERODSCNT           0x0010 // Не выравнивать цену скидкой
#define CILTIF_USESUBST_STRUCONLY  0x0020 // При подстановке использовать только структуру (не обобщение)
#define CILTIF_SUBSTSERIAL         0x0040 // Если в функцию передан серийный номер лота, из которого
	// следует израсходовать товар, но этот лот уже использован, то данный флаг позволяет использовать
	// другие лоты по этому товару. При этом использование доступного лота с точным соответствием
	// серии приоритетно.
	// Если флаг не установлен и указан серийный номер, то расход идет строго по серийному номеру.
#define CILTIF_ALLOWZPRICE         0x0080 // Допускается нулевая чистая цена реализации. Если CILTIF_ZERODSCNT,
	// то этот флаг не действует, в противном случае нулевая чена НЕ воспринимается как исключение при котором следует
	// устанавливать чистую цену реализации равную учетной.
#define CILTIF_EXCLUDESERIAL       0x0100 // Опция, используемая при преобразовании расходной строки. Если установлена,
	// то параметр pSerial содержит список серийных номеров лотов, которые не следует использовать для расходования заданного количества.
	// Если необходимо задать более одного исключенного серийного номера, то номера разделяются символом ';'
	// Note: если этот флаг установлен, то параметр pSerial в любом случае (для приходных и прочих операций)
	//   не будет рассматриваться как собственно серийный номер.
#define CILTIF_INHLOTTAGS          0x0200 // @v7.4.10 Для приходного документа наследовать теги из предыдущего лота
#define CILTIF_USESYNCLOT          0x0400 // @v7.6.1  При конвертации пытаться использовать лоты, на которые
	// ссылаются поля ILTI::LotSyncID и ILTI::LotMirrID
#define CILTIF_SYNC                0x0800 // @v8.0.3  Признак того, что функция ConvertILTI используется для формирования образа
	// документа из другого раздела. В этом случае ее поведение немного отличается.
#define CILTIF_MOD                 0x1000 // @v8.0.3  Функция ConvertILTI должна изменить (удалить,добавить) строку в существующем документе
#define CILTIF_REPFULLSYNCPROBLEM  0x2000 // @v8.4.10 Выводить в журнал synclot.log информацию о проблемах подстановки синхронизированного лота
#define CILTIF_CAREFULLYALIGNPRICE 0x4000 // @9.2.7   Выравнивать цену реализации результирующих строк по исходной сумме в ценах реализации
//
// Опции выбора даты зачетной оплаты (PPObjBill::Reckon())
//
#define RECKON_DATE_CURR                1 // Зачитывать текущей датой
#define RECKON_DATE_PAYM                2 // Зачитывать датой платежного документа.
// Если дата платежного документа меньше даты долгового, то зачет
// проводится датой долгового документа.
#define RECKON_DATE_DEBT                3 // Зачитывать датой долгового документа
#define RECKON_DATE_USER                4 // Зачитывать указанной пользователем датой
//
// Options of method PPObjBill::RecalcTurns
//
#define BORTF_NORECALCAMOUNTS     0x0001L // Don't recalc bill's amounts
#define BORTF_RECALCTRFRS         0x0002L // Recalc transfer items (imply !BORTF_NORECALCAMOUNTS)
//
//
//
struct ReckonOpArItem {
	SLAPI  ReckonOpArItem();
	PPID   PaymentOpID;
	PPID   PaymentArID;
	PPID   PayableOpID;
	PPID   PayableArID;
	PPID   PayableAccSheetID; // @v7.0.1
	PPIDArray * P_BillIDList;
};

class ReckonOpArList : public TSArray <ReckonOpArItem> {
public:
	SLAPI  ReckonOpArList();
	SLAPI ~ReckonOpArList();
	int    SLAPI Destroy();
	PPID   SLAPI GetPaymOpIDByBillID(PPID billID) const;
	int    SLAPI IsBillListSortingNeeded() const;
};

struct CfmReckoningParam {
	CfmReckoningParam();
	int    SLAPI Init(int debtOrPaym, BillTbl::Rec *, double debt, double paym, PPIDArray *);

	int    DebtOrPaym;
	int    DateOption;
	PPID   ArticleID;
	PPID   CurID;
	double TotalDebt;
	double PaymAmount;
	LDATE  BillDt;
	LDATE  Dt;
	PPID   ForceBillID;       // Идент документа, который должен быть зачтен
	PPID   SelectedBillID;    // OUT
	PPIDArray ResultBillList; // OUT @v8.0.11
	PPIDArray * P_BillList;
};
//
//
//
#define BCF_CONFIRMWL              0x00000001L  // Спрашивать подтверждение на установки или снятие WL по документу
#define BCF_ALLOWZSUPPLINCOSTREVAL 0x00000002L  // Допускать переоценку цен поступления без выбора поставщика
#define BCF_WARNMATCLIDEBT         0x00000004L  // Предупреждать о просроченной
	// задолженности клиента при выборе этого клиента в долговом документе
#define BCF_SIGNDIFFLOTCOST        0x00000008L  // Выставлять признак отличия цены поступления последнего лота,
	// от введенной в диалоге строки прихода товара. Для магазинов самообслуживания, использующих BHT-терминалы.
#define BCF_WARNADDBILLNOFLT       0x00000010L  // Предупреждать о вводе документа, не соответствующего фильтру
#define BCF_ALLOWMULTIPRINT        0x00000020L  // Разрешить множественную печать для первичных документов
#define BCF_CHECKRESERVEDORDERS    0x00000040L  // Проверять остатки по уровню резерва при проводке документов
#define BCF_ADDAUTOQTTYBYBRCODE    0x00000080L  // При добавлении новой строки в документ по штрихкоду автоматически
	// устанавливать количество равное 1.
#define BCF_SHOWBARCODESINGBLINES  0x00000100L  // Показывать штрихкоды в строках товарных документов
#define BCF_SHOWSERIALSINGBLINES   0x00000200L  // Показывать серийные номера в строках товарных документов
#define BCF_DONTWARNDUPGOODS       0x00000400L  // Не выдавать предупреждение о том, что выбранный товар уже есть в документе
#define BCF_RETAILEDPRICEINLABEL   0x00000800L  // Печатать в ценниках цену из котировки по акции
#define BCF_AUTOSERIAL             0x00001000L  // При добавлении строки приходного товарного документа автоматически
	// генерировать серийный номер (если флаг не установлен, то требуется нажатие F2)
#define BCF_AUTOCOMPLOUTBYQUOT     0x00002000L  // При автокомплектации цену реализации исходящих позиций
	// устанавливать по базовой котировке (если таковой нет, то - по последнему лоту)
#define BCF_VALUATION_STRICT       0x00004000L  // Расценка приходных документов остуществляется строго по конфигурации документов
#define BCF_VALUATION_RNDVAT       0x00008000L  // При расценке округлять цены до величины, кратной НДС
#define BCF_WARNAGREEMENT          0x00010000L  // Предупреждать если у контаргента нет соглашения или соглашение просрочено
#define BCF_PAINTSHIPPEDBILLS      0x00020000L  // Отображать цветом документы, имеющие признак BILLF_SHIPPED (отгружен)
#define BCF_OVRRDAGTQUOT           0x00040000L  // Допускается в документах выбирать котировку, отличную от
	// заданной в соглашении с контрагентом.
#define BCF_VALUATION_BYCONTRACT   0x00080000L  // Расценку проводить по контрактной котировке поставщика,
	// если расценочная котировка задана отностиельно цены поступления.
#define BCF_ORDPRICELOWPRIORITY    0x00100000L  // Цена из заказа имеет меньший приоритет перед котировкой.
#define BCF_EXTOBJASMAINORG        0x00200000L  // @v7.0.0 Если дополнительная статья по документу относится к таблице
	// статей, ссылающейся на персоналии вида "Главная организация", то ненулевую доп статью документа трактовать как
	// главную организацию (вместо главной организации из текущего состояния сеанса).
#define BCF_ACCEPTGOODSBILLCHG     0x00400000L  // @v8.0.3 Принимать изменения товарных документов
#define BCF_SENDATTACHMENT         0x00800000L  // @v8.2.3 Передавать в другие разделы файлы, привязанные к документам
#define BCF_DONTINHQCERT           0x01000000L  // @v8.2.5 Не наследовать сертификаты качества для новых лотов
#define BCF_RETINHERITFREIGHT      0x02000000L  // @v8.3.8 Связанный документ возврата наследует фрахт от основного документа
#define BCF_PICKLOTS               0x04000000L  // @v8.4.11 В товарных документах на расход предпочтение - подбору лота, а не товара
#define BCF_INHSERIAL              0x08000000L  // @v8.4.12 Наследовать в приходах серийный номер от последнего лота

struct PPBillConfig {        // @persistent @store(cvt:PropertyTbl)
	SLAPI  PPBillConfig();
	PPBillConfig & Clear();

	PPID   SecurID;            // Const=PPCFG_MAIN
	char   OpCodePrfx[8];      // Префикс кода операции
	char   ClCodePrfx[8];      // Префикс кода клиента
	PPID   ClCodeRegTypeID;    // Тип регистра персоналии для ведения кодов клиентов
	long   Flags;              // BCF_XXX
	PPID   CashNodeID;         // ИД кассового узла, используемого для печати чека по документу
	char   SnTemplt[16];       // Шаблон генерации серийных номеров лотов                         @obsolete since @v5.0.0
	char   InvSnTemplt[16];    // Шаблон генерации инвентарных номеров основных средств
	long   SnrCounter;         // Счетчик для генерации серийных номеров лотов и драфт документов @obsolete since @v5.0.0
	PPID   InitStatusID;       // Статус, присваиваемый новым документам
	PPID   SnCntrID;           // ->Ref(PPOBJ_OPCOUNTER) Счетчик для генерации серийных номеров
		// (заменяет SnTempl и SnrCounter)
	PPID   ContractRegTypeID;  // @v8.4.0 Тип регистрационного документа договора с контрагентом
	PPID   MnfCountryLotTagID; // @v8.4.11 Тип тега лота, определяющего страну происхождения товара
	LDATE  LowDebtCalcDate;    // @v8.5.7
	//
	// Способы подстановки товаров вместо дефицитного
	//
	enum {
		gsmGeneric = 0,      // Обобщенные товары (по умолчанию)
		gsmSubstStruc,       // Подстановочная структура
		gsmNone              // Не использовать
	};
	int16  GoodsSubstMethod;   // Способ подстановки товаров вместо дефицитного.
	PPID   LnkFilesCntrID;     // ->Ref(PPOBJ_OPCOUNTER) Счетчик для генерации имен присоединенных файлов
	int16  ValuationRndDir;    // Направление округления при расценке
	//
	//
	//
	LDATE  SwitchedTDisCalcMethodDate;  // Дата, начиная с которой при расчете
		// скидки по документу следует пользоваться методом, определяемым переключателем TDisCalcMethod.
	enum {
		tdcmSimple,   // Простое равномерно-пропорциональное распределение скидки по строкам документа
		tdcmRegress,  // Регрессивный метод (общая скидка последовательно разносится по строкам таким образом,
			// что общая сумма скидки строго равна заявленной).
		tdcmRegress2  // Улучшенный регрессивный метод (строки документа ранжируются так, что ошибка
			// округления минимизируется, а на строки с одинаковыми товарами величина Price-Discount идентична.
	};
	uint8  TDisCalcMethod;     // Метод расчета скидки по документу
	uint8  TDisCalcPrec;       // @#[0..5] Точность округления при расчете скидки
	PPID   ValuationQuotKindID; // ->Ref(PPOBJ_QUOTKIND) Вид котировки для расценки приходных документов
	double ValuationRndPrec;   // Точность округления при расценке
	char   UniqSerialSfx[16];  // @v7.3.0 Сигнатура суффикса, присоединяемого к серийному номеру для обеспечения его уникальности.
	SVerT Ver;                // @anchor @v7.7.7 Версия, сформировавшая запись.
	TagFilt TagIndFilt;        // @anchor @v7.7.7 Фильтр тегов, определяющий окраску номеров документов в отчетах
	SString AddFilesFolder;    // Папка для автоматического присоединения файлов к документам. Строка хранится в реестре, а не в БД.
};
//
//
//
struct RentChrgFilt {
	DateRange Period;
	PPID   CntrgntID;
};

struct CvtAt2Ab_Param {
	enum {
		fNegAmount = 0x0001
	};
	PPID   LocID;
	PPID   OpID;
	PPID   ObjID;
	PPID   ExtObjID;
	long   Flags;
	const  PPIDArray * P_OpList;
};
//
// Карточка объекта основных средств
//
struct AssetCard {
	struct MovItem {
		PPID   BillID;
		PPID   LotID;
		PPID   DestLocID;
		double Price;
	};
	PPID   LotID;
	PPID   OrgLotID;
	double OrgCost;     // Начальная балансовая стоимость
	double OrgPrice;    // Начальная остаточная стоимость
	AcctID AssetAcctID;
	PPID   ExplBillID;
	SArray * P_MovList;
};
//
// @ModuleDecl(PPViewInventory)
//
struct InventoryFilt : public PPBaseFilt {
	SLAPI  InventoryFilt();
	int    SLAPI Setup(PPID billID = 0);
	InventoryFilt & FASTCALL operator = (const InventoryFilt & rS);
	void   FASTCALL SetSingleBillID(PPID billID);
	PPID   SLAPI GetSingleBillID() const;
	int    SLAPI HasSubst() const;
	enum {
		fLack               = 0x0001, // Показывать недостачи
		fSurplus            = 0x0002, // Показывать излишки
		fAmtVal             = 0x0004, // Величина разногласий в суммовом выражении
		fPctVal             = 0x0008, // Процентная величина разногласий
		fWrOff              = 0x0010, // Показывать списанные строки
		fUnwrOff            = 0x0020, // Показывать не списанные строки
		fShowAbsenseGoods   = 0x0040, // Показывать товары, которых нет в документе,
			// но учетный остаток которых не нулевой. Этот флаг используется для печати
			// документа инвентаризации с нулевым остатком по умолчанию.
		fSelExistsGoodsOnly = 0x0080, // При вводе строк в списке выбора товаров отображать
			// только товары, которые есть на текущем остатке.
		fMultipleTotal      = 0x0100  // @v8.1.12 Специализированный флаг, используемый функцией
			// InventoryCore::CalcTotal: если флаг установлен то InventoryCore::CalcTotal в начале
			// работы не очищает структуру InventoryTotal (необходимо для расчета итогов по нескольким документам
			// инвентаризации).
	};
	enum {
		ordByDefault = 0,
		ordByGoods   = 1,
		ordByDeficit = 2,
		ordByDiff    = 3
	};
	char   ReserveStart[4]; // @v8.8.6 [4]-->[8] // @v8.9.3 [8]-->[4]
	// @v8.8.6 PPID   BillID;
	PPID   GoodsID; // @v8.9.3
	PPID   GoodsGrpID;
	long   Flags;
	double MinVal;
	double MaxVal;
	double Amount;             // OUT Функция ViewInventory присваивает этой переменной сумму документа
		// при завершении работы таблицы (модальной)
	int16  SortOrder;
	int16  Pad_;               // @v7.0.0 @alignment
	SubstGrpBill Sgb;          // @v8.8.6 Подстановка документа.
	SubstGrpGoods Sgg;         // @v8.8.6 Подстановка товара
	PPID   StorageLocID;       // @v8.8.6 Место хранения
	char   Reserve[16];        // @v8.8.6 [32]-->[24]
	ObjIdListFilt BillList;
	ObjIdListFilt GoodsList;
};

struct AutoFillInvFilt {
	enum {
		fFillWithZeroQtty = 0x0001
	};
	PPID   BillID;
	PPID   GoodsGrpID;
	long   Method;
	long   Flags;
	LDATE  DueDate;
};

struct InventoryTotal {
	InventoryTotal();

	PPID   ID;
	long   BillCount;  // @v8.1.12
	long   ItemsCount; // @v8.1.12 Count-->ItemsCount
	long   GoodsCount; // @v8.1.12
	double Quantity;
	double Amount;
	double StockRest;
	double StockAmount;
	double Surplus;
	double Lack;
	double DfctQtty;
	double DfctAmount;
};

#define INVENTF_GENAUTOLINE  0x00000001L // Автоматически сгенерированная строка (не подтвержденная)
#define INVENTF_GENWROFFLINE 0x00000002L // Строка сгенерирована при списании (списан по умолчанию весь остаток)
#define INVENTF_WRITEDOFF    0x00000004L // Строка списана
#define INVENTF_SURPLUS      0x00000008L // Знак рассогласований 1
#define INVENTF_LACK         0x00000010L // Знак рассогласований -1
#define INVENTF_AUTOLINE     (INVENTF_GENAUTOLINE|INVENTF_GENWROFFLINE)

#define INVENT_DIFFSIGN(f)  ((f & INVENTF_SURPLUS) ? 1 : ((f & INVENTF_LACK) ? -1 : 0))
#define INVENT_SETDIFFSIGN(f, sign) {f &= ~(INVENTF_SURPLUS|INVENTF_LACK); f |= (sign < 0) ? INVENTF_LACK : ((sign > 0) ? INVENTF_SURPLUS : 0);}
#define INVENT_SETAUTOLINE(f, autoLine) {f &= ~INVENTF_AUTOLINE; f |= (autoLine == 1) ? INVENTF_GENAUTOLINE : ((autoLine == 2) ? INVENTF_GENWROFFLINE : 0);}

class InventoryCore : public InventoryTbl {
public:
	friend class PPTblEnum <InventoryCore>;

	SLAPI  InventoryCore(char * pFileName = 0);
	int    SLAPI Search(PPID billID, long oprNo, void * = 0);
	int    SLAPI SearchByGoods(PPID id, PPID goodsID, InventoryArray * pList);
	int    SLAPI SearchIdentical(PPID billID, PPID goodsID, const char * pSerial, InventoryTbl::Rec * pRec = 0);
	SEnumImp * SLAPI Enum(PPID billID);
	int    SLAPI Set(PPID id, long * oprNo, InventoryTbl::Rec * rec, int use_ta);
	int    SLAPI Remove(PPID id, int use_ta);
	int    SLAPI Move(PPID destBillID, PPID srcBillID, int sgoptions /* INVMOVSGO_XXX */, int use_ta);
	//
	// Descr: Рассчитывает итоги по строкам инвентаризации в соответствии с фильтром.
	// ARG(pFilt       IN): @#{vptr}  Фильтр, в соответствии с которым перебираются строки инвентаризации
	// ARG(pTotal     OUT): @#{vptr0} Указатель на структуру, в которую заносятся итоговые значения по выборке.
	//   Функция предварительно очищает содержимое по структуры pTotal (если указатель не нулевой)
	// ARG(pGoodsList OUT): @#{vptr0} Указатель на массив, в который заносятся идентификаторы товаров,
	//   соответствующих строкам инвентаризации, удовлетворяющим фильтру pFilt. Функция не выполняет
	//   предварительную очистку массива. Элементы добавляются вызовом PPIDArray::adUnique
	//
	int    SLAPI CalcTotal(const InventoryFilt * pFilt, InventoryTotal * pTotal, PPIDArray * pGoodsList = 0);
	int    SLAPI CheckFlags(const InventoryFilt * pFilt, const InventoryTbl::Rec * pRec);
private:
	int    SLAPI _Search(PPID, long *, int sp, void * = 0);
	int    SLAPI CalcDiff(InventoryTbl::Rec *);
	int    SLAPI InitEnum(PPID billID, long * pHandle);
	int    SLAPI NextEnum(long enumHandle, void * pRec);
	int    SLAPI DestroyIter(long enumHandle); // really private. Used by PPTblEnum <>

	PPTblEnumList EnumList;
};
//
// Descr: Структура, используемая для формирования строк документов, на основании товарных структур
//
struct ComplItem {
	SLAPI  ComplItem();

	PPID   GoodsID;
	long   GoodsFlags;
	uint   SrcGsPos;       // @v9.3.3 [1..] Позиция строки в исходной структуре (+1), к которой относится данных элемент
	long   GsiFlags;       // @v9.0.4 Флаги элемента структуры
	double PartQty;
	double NeedQty;
	double FreeQty;
	// @v9.4.0 double Cost;
};

//typedef TSArray <ComplItem> ComplArray;

class PPComplBlock : public TSArray <ComplItem> {
public:
	int    SLAPI Add(const PPComplBlock & rS);
	ComplItem Head;
};
//
// Descr: Структура, содержащая информацию о заменах дефицитного товара DestID
//   на товары, имеющиеся на остатках. Используется при списании кассовых сессий,
//   драфт-документов и технологических сессий, а также при формировании MRP-таблиц.
//
class GRI : public SArray {
public:
	SLAPI  GRI(PPID destID);
	int    SLAPI Add(PPID srcID, double qtty, double ratio);
	PPID   FASTCALL GetSrcID(uint i) const;
	double FASTCALL GetQtty(uint i) const;
	double FASTCALL GetRatio(uint i) const;
	int    SLAPI GetPosByGoods(PPID goodsID, uint * pPos) const;

	PPID   DestID;
};
//
// Descr: Коллекция структур экземпляров GRI.
//   Формируется функцией MrpTabCore::SetupRest
//
class GoodsReplacementArray : public TSCollection <GRI> {
public:
	SLAPI  GoodsReplacementArray();
	int    SLAPI Add(PPID destID, PPID srcID, double qtty, double ratio);
	const  GRI *  SLAPI Search(PPID destID) const;
private:
	GRI *  SLAPI SearchNC(PPID destID);
};
//
// Объект PPObjBill служит оболочкой для выполнения //
// всех операций. В том числе и таких, в которых явно
// форма документа не высвечивается (чистые бухгалтерские проводки).
//
int SLAPI PPObjBill_WriteConfig(PPBillConfig * pCfg, PPOpCounterPacket * pSnCntr, int use_ta);

class PPBillImpExpParam : public PPImpExpParam {
public:
	enum {
		fImpRowsFromSameFile = 0x0001,
		fImpRowsOnly         = 0x0002, // @v8.4.8
		//fSignBill = 0x0002
		fRestrictByMatrix    = 0x0004, // @v9.0.4
		fExpOneByOne         = 0x0008  // @v9.3.10 Экспортировать документы по-одному в каждом файле
	};
	//
	// Descr: Предопределенный форматы импорт/экспорта документов
	//
	enum { // @persistent
		pfUndef = 0,
		pfNalogR_Invoice = 1 //
	};
	PPBillImpExpParam(uint recId = 0, long flags = 0);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int MakeExportFileName(const void * extraPtr, SString & rResult) const;
	virtual int PreprocessImportFileSpec(const SString & rFileSpec, PPFileNameArray & rList);
	virtual int PreprocessImportFileName(const SString & rFileName, StrAssocArray & rResultList);

	long   Flags;             // @persistent
	PPID   ImpOpID;           // @persistent
	long   PredefFormat;      // @persistent @v9.7.8
	SString Object1SrchCode;  // @persistent
	SString Object2SrchCode;  // @persistent
};
//
// Экспорт/импорт инвентаризации
//
//
// Импорт инвентаризации
//
class PPInventoryImpExpParam : public PPImpExpParam {
public:
	PPInventoryImpExpParam(uint recId = 0, long flags = 0);
};
//
//
//
class PPBillImpExpBaseProcessBlock {
public:
	PPBillImpExpBaseProcessBlock();
	PPBillImpExpBaseProcessBlock & Reset();
	int    SLAPI Select(int import);
	int    SLAPI SerializeParam(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	enum {
		fUhttImport     = 0x0001,  // Импорт документов из Universe-HTT
		fSignExport     = 0x0002,  // Подписывать исходящие файлы 'лектронной подписью
		fEdiImpExp      = 0x0004,  // Импорт/экспорт документов через EDI
		fCreateCc       = 0x0008,  // @v8.3.2 При создании документа одновременно создавать чек заказа
		fDisableLogger  = 0x0010,  // @v8.3.2 Не выводить сообщения в окно журнала
		fEgaisImpExp    = 0x0020,  // @v8.8.0 Обмен данными с ЕГАИС
		fTestMode       = 0x0040,  // @v8.9.0
		fDontRemoveTags = 0x0080,  // @v8.9.9 Для EDI и ЕГАИС - не снимать теги при получении отрицательных тикетов
		fPaymOrdersExp  = 0x0100   // @v9.2.10 Экспорт платежных поручений
	};
	long   Flags;
	long   DisabledOptions; // @v9.2.10 @transient
	PPID   OpID;
	PPID   LocID;
	PPID   PosNodeID;    // @v8.3.2
	DateRange Period;    // @v7.6.3 Период за который следует импортировать документы
	PPBillImpExpParam BillParam;
	PPBillImpExpParam BRowParam;
	SString CfgNameBill; // @v7.6.3
	SString CfgNameBRow; // @v7.6.3

	struct TransmitParam {
		TransmitParam();
		void   Reset();

        PPID   InetAccID;
		StrAssocArray AddrList;
		SString Subject;
	};

	TransmitParam Tp; // @v8.9.11

	struct SearchBlock {
		SearchBlock();

		LDATE  Dt;
		int    SurveyDays; // Количество дней назад от текущей даты для поиска документа
		SString Code;
		SString DlvrLocCode;
	};
	int    SLAPI SearchEdiOrder(const SearchBlock & rBlk, BillTbl::Rec * pOrderRec);

	PPObjBill * P_BObj;
	PPObjLocation LocObj;
};

class PPBillExporter : public PPBillImpExpBaseProcessBlock {
public:
	SLAPI  PPBillExporter();
	SLAPI ~PPBillExporter();
	void   SLAPI Destroy();
	int    SLAPI Init(const PPBillImpExpParam * pBillParam, const PPBillImpExpParam * pBRowParam, const PPBillPacket * pFirstPack, StringSet * pResultFileList);
	int    SLAPI PutPacket(PPBillPacket * pPack, int sessId = 0, ImpExpDll * pImpExpDll = 0);
	int    SLAPI SignBill(); // @vmiller
	int    SLAPI CheckBillsWasExported(ImpExpDll * pExpDll); // @vmiller // Получает от dll список успешно экспортированных документов и ставит в них соответствующую пометку
	PPImpExp * SLAPI GetIEBill() const
	{
		return P_IEBill;
	}
	PPImpExp * SLAPI GetIEBRow() const
	{
		return P_IEBRow;
	}
private:
	int    SLAPI BillRecToBill(const PPBillPacket * pPack, Sdr_Bill * pBill);
	int    SLAPI GetInn(PPID arID, SString & rINN);
	int    SLAPI GetReg(PPID arID, PPID regTypeID, SString & rRegNum);

	PPImpExp * P_IEBill;
	PPImpExp * P_IEBRow;
	PPObjGoods  GObj;
	PPObjPerson PsnObj;
	PPObjQCert  QcObj;
	PPObjArticle ArObj;
	PPObjPersonKind PsnKObj;
};

typedef TSArray <Sdr_BRow> SdrBillRowArray;
typedef TSArray <Sdr_Bill> SdrBillArray;

class PPBillImporter : public PPBillImpExpBaseProcessBlock {
public:
	SLAPI  PPBillImporter();
	SLAPI ~PPBillImporter();
	int    SLAPI Init();
	int    SLAPI Init(PPBillImpExpParam * pBillParam, PPBillImpExpParam * pBRowParam, PPID opID, PPID locID);
	//
	// Descr: Функция не интерактивно инициализирует импорт с Universe-HTT
	//
	int    SLAPI InitUhttImport(PPID opID, PPID locID, PPID posNodeID);
	int    SLAPI LoadConfig(int import);
	int    SLAPI Run();
	// @vmiller {
	enum {
		statNoSuchDoc = 0,  // Такого документа нет
		statIsSuchDoc = 1 	// Есть такой документ
	};
	// } @vmiller
private:
	int    SLAPI ResolveINN(const char * pINN, PPID dlvrLocID, const char * pDlvrLocCode,
		const char * pBillId, PPID accSheetID, PPID * pArID, int logErr = 1);
	int	   SLAPI ResolveGLN(const char * pGLN, const char * pLocCode, const char * pBillId, PPID accSheetID, PPID * pArId, int logErr = 1); // @vmiller
	int    SLAPI ResolveUnitPerPack(PPID goodsID, PPID locID, LDATE dt, double * pUpp);
	int    SLAPI CheckBill(const Sdr_Bill * pBill);
	int    SLAPI AddBillToList(Sdr_Bill * pBill, long extraBillId);
	int    SLAPI BillToBillRec(const Sdr_Bill * pBill, PPBillPacket * pPack);
	int    SLAPI BillRowToBillRec(const Sdr_BRow * pRow, PPBillPacket * pPack);
	int    SLAPI AddBRow(Sdr_BRow & rRow, uint * pRowId);
	const  Sdr_Bill * SLAPI SearchBillForRow(const SString & rBillIdent, const Sdr_BRow & rRow) const;
	int    SLAPI SearchNextRowForBill(const Sdr_Bill & rBill, uint * pPos) const;
	//
	// Descr: Считывает из исходного файла строки документов.
	// ARG(pImpExp IN): Блок параметров импорта
	// ARG(mode    IN): режим считывания
	//   0 - обычный режим
	//   1 - привязка строк к последнему считанному из файла заголовков документу
	//   2 - режим считывания строк без предварителного считываения заголовков документов (вся информация о документах хранится в файле строк)
	//
	int    SLAPI ReadRows(PPImpExp * pImpExp, int mode/*linkByLastInsBill*/, const StrAssocArray * pFnFldList);
	int    SLAPI ReadSpecXmlData();
	int    SLAPI Helper_EnsurePersonArticle(PPID psnID, PPID accSheetID, PPID psnKindID, PPID * pArID); // @wota
	int    SLAPI ReadData();
	int    SLAPI ReadDataDll(const PPEdiProviderPacket * pEp);
	int    SLAPI Import(int useTa);
	int    SLAPI RunUhttImport();
	int    SLAPI RunEDIImport(); // @vmiller
	int    SLAPI RunEDIImport2();
	int	   SLAPI GetDocImpStatus(Sdr_Bill * pBill, Sdr_DllImpObjStatus & rStatus); // @vmiller
	int    SLAPI AssignFnFieldToRecord(const StrAssocArray & rFldList, Sdr_Bill * pRecHdr, Sdr_BRow * pRecRow);

	PPID   AccSheetID;
	long   LineIdSeq;
	PPLogger Logger;
	SdrBillArray Bills;
	SdrBillRowArray BillsRows;
	PPObjPerson  PsnObj;
	PPObjArticle ArObj;
	PPObjQCert   QcObj;
	CCheckCore * P_Cc;
	BillTransmDeficit * P_Btd;
	StringSet ToRemoveFiles; // @v8.4.7

	PPLotTagContainer TagC;
};

struct PayableBillListItem {
	double SLAPI MultExtCoef(double val, int zeroIfDivZero = 0) const;
	PPID   ID;
	PPID   CurID;
	LDATE  Dt;
	double Amount;
	double ExtAmt;         // Сумма документа в ценах поступления //
	double PaymAmt;        // @v8.5.8 Сумма оплаты из записи документа. Используется если (CConfig.Flags2 & CCFLG2_USEOMTPAYMAMT)
};

class PayableBillList : public TSArray <PayableBillListItem> {
public:
	SLAPI  PayableBillList(AmtList * pAmt = 0, AmtList * pPaym = 0);
	int    SLAPI GetIdList(LongArray & rList) const;
	int    FASTCALL AddBill(const BillTbl::Rec * pBillRec);
	int    SLAPI AddPayableItem(const PayableBillListItem * pItem, long tabID, double paym, int useExtCoef);
	AmtList * P_Amt;       // @notowned
	AmtList * P_Paym;      // @notowned
};
//
// Descr: Структура, необходимая для автоматического создания платежных
//   поручений по списку документов.
//   PPObjBill::CreateBankingOrders
//
struct PPGPaymentOrder : public PPBankingOrder {
	PPID   ArID;
	PPID   Ar2ID;
	long   Options;
	PPIDArray LinkBillList;
};
//
// Descr: Список платежных поручений, автоматически сформированных
//   по списку документов.
//   PPObjBill::CreateBankingOrders
//
typedef TSCollection <PPGPaymentOrder> PPGPaymentOrderList;
//
// Descr: Блок параметров для создания документа по образцу
//
struct SelAddBySampleParam {
	enum {
		fCopyBillCode = 0x0001
	};
	long   Action;
	PPID   OpID;
	PPID   LocID;
	long   Flags;
};
//
// Descr: Класс, управляющий объектом данных PPOBJ_BILL
//
class PPObjBill : public PPObject {
public:
	static int SLAPI ReadConfig(PPBillConfig *);
	static int SLAPI EditConfig();
	//
	// Descr: Опции формирования строки наименования документа
	//
	enum {
		mcsAddOpName  = 0x0001, // Добавлять наименование вида операции
		mcsAddLocName = 0x0002, // Добавлять наименование склада
		mcsAddObjName = 0x0004, // Добавлять наименование контрагента
		mcsAddSCard   = 0x0008  // Добавить код персональной карты, связанной с документом
	};
	static SString & SLAPI MakeCodeString(const BillTbl::Rec * pRec, int options, SString & rBuf);
	//
	// Descr: Возвращает !0, если владельцем пула документов с ассоциацией assocID (PPASS_XXX)
	//   является документ. Если тип ассоциации недействителен или владельцем пула является объект
	//   типа, отличного от PPOBJ_BILL, то возвращает 0.
	//
	static int SLAPI IsPoolOwnedByBill(PPID assocID);
	static int SLAPI VerifyUniqSerialSfx(const char * pSfx);
	static int SLAPI ParseText(const char * pText, const char * pTemplate, StrAssocArray & rResultList, SString * pFileTemplate);

	SLAPI  PPObjBill(void * extraPtr = 0);
	SLAPI ~PPObjBill();
	virtual int    SLAPI Search(PPID id, void * = 0);
	//
	// Descr: осуществляет кэшированное извлечение записи по идентификатору id.
	//   Заполняются следующие поля: ID, Code, Dt, OpID, LocID, Object, Flags, Amount
	//
	int    SLAPI Fetch(PPID id, BillTbl::Rec * pRec);
	int    SLAPI FetchExt(PPID id, PPBillExt * pExt);
	int    SLAPI FetchFreight(PPID id, PPFreight * pFreight);
	int    SLAPI GetCrBillEntry(long & rTempID, PPBillPacket * pPack);
	int    SLAPI SetCrBillEntry(long tempID, PPBillPacket * pPack);
	//
	// Descr: осуществляет кэшированное извлечение расширенных примечаний
	//   по документу id.
	// Returns:
	//   >0 - строка расширенных примечаний найдена
	//   <0 - для документа id расширенное примечание отсутствует
	//   0  - ошибка
	//
	int    SLAPI FetchExtMemo(PPID id, SString & rBuf);
	int    SLAPI Dirty(PPID id);

	const  StrAssocArray * SLAPI GetFullSerialList();
	void   SLAPI ReleaseFullSerialList(const StrAssocArray * pList);
	int    SLAPI ResetFullSerialList();
	//
	// Поиск документа по GUID. GUID хранится в PropertyTbl::Text
	//
	int    SLAPI SearchByGuid(const S_GUID & rUuid, BillTbl::Rec * pRec);
	int    SLAPI PutGuid(PPID id, const S_GUID * pUuid, int use_ta);
	int    SLAPI GetGuid(PPID id, S_GUID * pUuid);
	virtual int  SLAPI Browse(void * extraPtr);
	//
	// Descr: Флаги редактирования документов
	//
	enum {
		//efCreate      = 0x0001, // Использовать при редактировании нового документа
		efEdit        = 0x0002, // Использовать при редактировании существующего документа
		efForceModify = 0x0004, // Редактирование существующего документа с форсированным признаком modified (некоторые поля блокируются)
		efNoUpdNotif  = 0x0008, // Не выводить сообщение о том что документ был модифицирован
		efCascade     = 0x0010  // Связанный документ (каскадное позиционирование)
	};
	//
	// Descr: Параметры редактирования документов
	//
	struct EditParam {
		EditParam()
		{
			Flags = 0;
		}
		long   Flags; // PPObjBill::efXXX
	};

	virtual int  SLAPI Edit(PPID * pID, void * extraPtr /* (PPObjBill::EditParam *) */);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	int    SLAPI Lock(PPID);
	int    SLAPI Unlock(PPID);
	int    SLAPI CheckStatusFlag(PPID statusID, long flag);
	int    FASTCALL GetEdiUserStatus(const BillTbl::Rec & rRec);
	//
	// Descr: Флаги функции PPObjBill::ValidatePacket
	//
	enum {
		vpfFreightOnly = 0x0001 // Проверять только поля фрахта
	};
	//
	// Descr: Проверяет непротиворечивость и правильность пакета pPack.
	//   Флаги flags могут ограничивать область проверки.
	//
	int    SLAPI ValidatePacket(const PPBillPacket * pPack, long flags);
	int    SLAPI IsPacketEq(const PPBillPacket & rS1, const PPBillPacket & rS2, long flags);
	int    SLAPI IsPaymentBill(const BillTbl::Rec & rRec);
	int    SLAPI ViewHistory(PPID histID);
	int    SLAPI SetupModifPacket(PPBillPacket * pPack);
	int    SLAPI TurnPacket(PPBillPacket * pPack, int use_ta);
	int    SLAPI __TurnPacket(PPBillPacket * pPack, PPIDArray * pList, int skipEmpty, int use_ta);
	int    SLAPI UpdatePacket(PPBillPacket * pPack, int use_ta);
	int    SLAPI ExtractPacket(PPID id, PPBillPacket * pPack);
	int    SLAPI ExtractPacketWithFlags(PPID id, PPBillPacket * pPack, uint flags /* BPLD_XXX */);
	int    SLAPI ExtractPacketWithRestriction(PPID id, PPBillPacket * pPack, uint flags /* BPLD_XXX */, const PPIDArray * pGoodsList);
	int    SLAPI RemovePacket(PPID, int use_ta);
	int    SLAPI UpdatePool(PPID poolID, int use_ta);
	int    SLAPI RecalcTurns(PPID, long flags /* BORTF_XXX */, int use_ta);
	int    SLAPI RecalcPayment(PPID id, int use_ta);
	int    SLAPI LockFRR(LDATE, int * pFRRL_Tag, int use_ta);
	int    SLAPI UnlockFRR(int * pFRRL_Tag, int isCrash, int use_ta);
	int    SLAPI CheckAmounts(PPID, PPLogger &);
	//
	// Descr: Извлекает идентификатор лота заказа, к которому привязана строка отгрузки rTrfrRec.
	// Returns:
	//   >0 - строка rTrfrRec привязана к заказу и идентификатор заказа успешно извлечен
	//   <0 - строка rTrfrRec либо не привязана к заказу, либо не удалось найти соответствующий лот заказа
	//   0  - ошибка
	//
	int    GetOrderLotForTransfer(const TransferTbl::Rec & rTrfrRec, PPID * pOrdLotID);
	//
	// Descr: Вызывает диалог изменения статуса документ billID
	//   Если пользователь выбрал новый статус и подтвердил ввод, то
	//   изменяет статус документа billID
	// Returns:
	//   >0 - пользователь выбрал новый статус и операция изменения статуса прошла успешно
	//   <0 - пользователь отказался от изменения статуса документа
	//   0  - ошибка
	//
	int    SLAPI EditBillStatus(PPID billID);
	//
	// Descr: Вызывает диалог редактирования параметров фрахта документа pPack.
	// Returns:
	//   1 - пользователь подтвердил редактирование фрахта. При этом фрахт не пустой либо
	//     дата отгрузки не нулевая и отличается от даты документа.
	//     В пакете pPack устанавливаются новые параметры фрахта.
	//   100 - пользователь подтвердил редактирование фрахта. Однако, фрахт пуст и дата
	//     отгрузки не отличается от даты документа. В пакете pPack фрахт обнуляется.
	//   <0 - пользователь отклонил редактирование либо документ не требует параметров фрахта.
	//   0  - ошибка. Если пользователь не имеет прав на изменение фрахта, то также возвращается 0.
	//
	int    SLAPI EditFreightDialog(PPBillPacket * pPack);
	int    SLAPI CheckParentStatus(PPID billID);
	int    SLAPI EditGenericAccTurn(PPBillPacket *, long flags);
	int    SLAPI EditGoodsBill(PPID id, const EditParam * pExtraParam);

	struct SearchBlock {
		enum {
			fContext     = 0x0001,
            fCode        = 0x0002,
            fInvoiceCode = 0x0004,
            fOuterCode   = 0x0008,
            fMemo        = 0x0010,
            fExtMemo     = 0x0020,
            fMainDate    = 0x0040,
            fInvoiceDate = 0x0080,
            fOuterDate   = 0x0100
		};
		long   Flags;
		DateRange Period;
		SString Text;
	};
	//
	// Descr: Фреймовый блок, используемый в функция проведения документа.
	//
	class TBlock {
	public:
		friend class PPObjBill;

		TBlock();
		int16 & Rbb()
		{
			return CurRByBill;
		}
		int16 GetNewRbb()
		{
			return (++CurRByBill);
		}
	private:
		PPID   BillID;
		int16  OrgLastRByBill;
		int16  CurRByBill;
	};
	int    BeginTFrame(PPID billID, TBlock & rBlk);
	int    FinishTFrame(PPID billID, TBlock & rBlk);
	//
	struct AddBlock {
		SLAPI  AddBlock(const AddBlock * pBlk = 0);

		PPID   SampleBillID;
		PPID   OpID;
		PPID   LinkBillID;
		PPID   RegisterID; // если OpID == 0 и registerID != 0, тогда функция AddAccturn //
			// предложит пользователю выбрать операцию из тех, которые имеют подтип OPSUBT_REGISTER
		PPID   ObjectID;
		PPBillPacket::PoolKind Pk;
		PPID   PoolID;
		PPID   LocID;          // @v8.3.0
		PPID   FirstItemLotID; // @v8.3.0 Лот, который необходимо вставить в строки документов первым 'лементом.
		int    FirstItemSign;  // @v8.3.0
		double FirstItemQtty;  // @v8.3.0 Количество, соответствующее автоматичекой строке FirstLotID (по умолчанию - 1)
	};
	int    SLAPI AddGoodsBill(PPID * pBillID, const AddBlock * pBlk);
	//
	// Descr: создает документ по образцу указанного фильтра, и открывает диалог редактирования документа.
	//   Если sCardID != 0, функция подставляет в документ скидку по карте.
	//
	int    SLAPI AddGoodsBillByFilt(PPID * pBillID, const BillFilt *, PPID opID, PPID sCardID = 0, CCheckTbl::Rec * pChkRec = 0);
	int    SLAPI AddExpendByReceipt(PPID *, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    SLAPI AddExpendByOrder(PPID *, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    SLAPI AddDraftByOrder(PPID * pBillID, PPID sampleBillID, const SelAddBySampleParam * pParam);
	int    SLAPI AddRetBill(PPID opID, long link, PPID locID);
	int    SLAPI AddRetBillByLot(PPID lotID);
	void   SLAPI DiagGoodsTurnError(const PPBillPacket *);
	int    SLAPI GetCurRate(PPID curID, PPID rateTypeID, PPID relCurID, LDATE * pDt, double * pRate);
	int    SLAPI GetCurRate(PPID curID, LDATE * pDt, double * pRate);
		// @>>GetCurRate(curID, LConfig.BaseRateTypeID, LConfig.BaseCurID, pDt, pRate)
	//
	// Descr: Флаги функции SetupImportedPrice()
	//
	enum {
		sipfAllowZeroPrice = 0x0001
	};

	int    SLAPI SetupImportedPrice(const PPBillPacket * pPack, PPTransferItem * pTi, long flags);
	//
	// Descr: используется для загрузки списка строк расширения бух документа
	//   в PPBillPacke и в ILBillPacket. По-этой причине она абстрагирукется от конкретного
	//   типа пакета, а требует лишь те параметры, которые необходимы.
	//
	int    SLAPI LoadAdvList(PPID billID, PPID opID, PPAdvBillItemList *);
	int    SLAPI TurnAdvList(PPID billID, PPBillPacket * pPack, int use_ta);
	//
	// Descr: Ищет ссылку на billID среди строк расширения бухгалтерских документов.
	//   Если ссылка найдена, то по указателю pItemRec возвращается запись ссылающейся //
	//   строки, а по указателю pBillRec - запись документа, которому принадлежит эта строка.
	// Returns:
	//   >0 - запись найдена.
	//   <0 - запись не найдена
	//   0  - ошибка
	//
	int    SLAPI SearchAdvLinkToBill(PPID billID, AdvBillItemTbl::Rec * pItemRec, BillTbl::Rec * pBillRec);
	//
	// Descr: Определяет, является лот, заданный идентификатором lotID, лотом основных фондов
	// Returns:
	//   >0 - да является //
	//   <0 - нет не является или не найден
	//   0  - ошибка
	//
	int    SLAPI IsAssetLot(PPID lotID);
	int    SLAPI MakeAssetCard(PPID lotID, AssetCard *);

	int    SLAPI GetTagList(PPID billID, ObjTagList * pTagList);
	int    SLAPI SetTagList(PPID billID, const ObjTagList * pTagList, int use_ta);

	enum {
		ltfGoodsName = 0x0001,
		ltfLocName   = 0x0002
	};
	void   SLAPI MakeLotText(const ReceiptTbl::Rec * pLotRec, long fmt, SString & rBuf);
	//
	// Descr: загружает в пакет pack информацию о грузовых
	//   таможенных декларациях, ассоциированных с лотами. Если параметр
	//   pTagCore != 0, то для загрузки используется он, в противном случае
	//   метод самостоятельно создает объект ObjTagCore и использует его для загрузки.
	//   Если параметр force == 0, то информация о номерах ГТД загружается //
	//   только тогда, когда пакет pack имеет тип операции PPOPT_GOODSRECEIPT,
	//   то есть для редактирования номеров ГТД.
	//   Если же force != 0, то номера ГТД загружаются не зависимо от того,
	//   к какому типу операций относится пакет.
	//
	int    SLAPI LoadClbList(PPBillPacket * pPack, int force = 0);
	int    SLAPI GetClbNumberByLot(PPID lotID, int * isParentLot, SString & rBuf);
	int    SLAPI GetSerialNumberByLot(PPID lotID, SString & rBuf, int useCache);
	int    SLAPI GetTagListByLot(PPID lotID, int skipReserveTags, ObjTagList * pList);
	int    SLAPI SetClbNumberByLot(PPID lotID, const char *, int use_ta);
		// @>>PPObjBill::SetTagNumberByLot
	int    SLAPI SetSerialNumberByLot(PPID lotID, const char *, int use_ta);
		// @>>PPObjBill::SetTagNumberByLot
	int    SLAPI AdjustSerialForUniq(PPID goodsID, PPID lotID, int checkOnly, SString & rSerial);
	int    SLAPI ReleaseSerialFromUniqSuffix(SString & rSerial) const;
	//
	// Descr: Опции функции SelectLotFromSerial
	//
	enum {
		slbsIncClosed = 0x0001 // Включить в выбор и закрытые лоты
	};

	//
	// Descr: Находит список идентификаторов лотов, соответствующих серийному номеру pSerial.
	//   Указатель pList может быть нулевым.
	// Returns:
	//   >0 - Найден один или более лот, соответствующий pSerial
	//   <0 - Не найдено ни одного лота
	//   0  - Ошибка
	//
	int    SLAPI SearchLotsBySerial(const char * pSerial, PPIDArray * pList);
	int    SLAPI SearchLotsBySerialExactly(const char * pSerial, PPIDArray * pList);
	int    SLAPI SelectLotFromSerialList(const PPIDArray *, PPID locID, PPID * pLotID, ReceiptTbl::Rec * pRec = 0);
	int    SLAPI SelectLotBySerial(const char * pSerial, PPID goodsID, PPID locID, ReceiptTbl::Rec * pRec);

	struct SelectLotParam {
		SelectLotParam(PPID goodsID, PPID locID, PPID excludeLotID, long flags)
		{
			GoodsList.addnz(goodsID);
			LocID = locID;
			ExcludeLotID = excludeLotID;
			Period.SetZero();
			Flags = flags;
			//
			RetLotID = 0;
			MEMSZERO(RetLotRec);
		}
		enum {
			fFillLotRec     = 0x0001,
			fWithSerialOnly = 0x0002,
			fEnableZeroRest = 0x0004,
			fNotEmptySerial = 0x0080,
			fShowEgaisTags  = 0x0100
		};
		PPID   LocID;
		PPID   ExcludeLotID;
		DateRange Period;
		long   Flags;
		PPIDArray GoodsList;
		PPIDArray AddendumLotList; // Список идентификаторов лотов, которыми должен быть дополнен отображаемый список
		//
		PPID   RetLotID;
		SString RetLotSerial;
		ReceiptTbl::Rec RetLotRec;
	};
	//int     SLAPI SelectLot2(SelectLotParam & rParam);
	int    SLAPI SelectLot2(PPObjBill::SelectLotParam & rParam);
	int    SLAPI GetSnByTemplate(const char * pBillCode, PPID goodsID, const ClbNumberList * pExclList, const char * pTempl, SString & rBuf);
	int    SLAPI GetLabelLotInfo(PPID lotID, RetailGoodsInfo *);
	//
	// Descr: Флаги функции GetComplete()
	//
	enum {
		gcfGatherSources  = 0x0001, // Собирать информацию об источниках происхождения лота
        gcfGatherBranches = 0x0002  // Собирать информацию о порожденных комплектацией лотах
	};
	//
	//
	//
	int    SLAPI GetComplete(PPID lotID, long flags, CompleteArray * pList);
	//
	// Descr: Находит парный товарный документ для документа billID.
	//   Пары могут быть следующего вида:
	//     драфт - документ списания //
	//     документ списания - драфт
	//     товарный документ - подтверждение
	//     подтверждение - товарный документ
	//
	int    SLAPI GetComplementGoodsBillList(PPID billID, PPIDArray & rComplBillList);
	//
	// Descr: Находит цепочку документов, предшествующих документу коррекции billID.
	// Note: Первый документ в результирующем списке (если тот не пустой) - оригинальный корректируемый документ,
	//   все последующие - в хронологическом порядке документы коррекции, предшествующие billID.
	// Returns:
	//   <0 - не найдено ни одного документа, в том числе и оригинального корректируемого (это - плохо).
	//   0  - ошибка
	//   1  - найден только оригинальный корректируемый документ.
	//   2  - кроме оригинального корректируемого документа в цепочке есть один или более других документов коррекции.
	//
	int    SLAPI GetCorrectionBackChain(PPID billID, PPIDArray & rChainList);
	int    SLAPI GetCorrectionBackChain(const BillTbl::Rec & rBillRec, PPIDArray & rChainList);
	int    SLAPI GetAccturn(AccTurnTbl::Rec *, PPAccTurn *, int useCache);
	//
	// Descr: Интерактивная функция ввода нового бухгалтерского документа.
	// Parameters:
	//   pBillID - возвращаемый ид созданного документа
	//   ab.OpID - ид вида операции. Если opID == 0, тогда функция //
	//     предлагает пользователю выбрать операцию.
	//   ab.RegisterID - если opID == 0 и ab.RegisterID != 0, тогда функция //
	//     предложит пользователю выбрать операцию из тех,
	//     которые имеют подтип OPSUBT_REGISTER
	// Returns:
	//   >0 - документ успешно добавлен
	//   <0 - пользователь отказался от ввода документа
	//   0  - ошибка
	//
	int    SLAPI AddAccturn(PPID * pBillID, const AddBlock * pBlk);
		// @>>PPObjBill::AddGenAccturn, @>>PPObjBill::AddGoodsBill
		// @>>::SelectOprKind, @>>::SelectOpKind
	int    SLAPI AddGenAccturn(PPID * pBillID, PPID opID, PPID registerID);
	int    SLAPI AddAccturnBySample(PPID * pBillID, PPID sampleBillID);
	int    SLAPI EditAccTurn(PPID);
	int    SLAPI EditBillExtData(PPID billID);
	int    SLAPI EditBillFreight(PPID billID);
	int    SLAPI EditLotExtData(PPID lotID);
	//
	// Descr: Вызывает диалог редактирования системной информации по лоту
	//
	int    SLAPI EditLotSystemInfo(PPID lotID);
	int    SLAPI UpdateOpCounter(PPBillPacket * pPack);
	int    SLAPI SetWLabel(PPID, int mode);
	int    SLAPI SetStatus(PPID id, PPID statusID, int use_ta);
	//
	// Descr: Выводит на экран таблицу со списком оплат (или других связанных документов),
	//   привязанных к документу billID.
	//   Функция проверяет существование документа по billID и то, чтобы этот
	//   документ требовал оплаты.
	// ARG(billID IN): Идентификатор документа, к которому привязанны просматриваемые документы
	// ARG(kind   IN): Категория просматриваемых документов
	//   0 - оплаты
	//   1 - начисления ренты
	//   2 - зачитывающие оплаты
	// Returns:
	//   >0 - сумма долга в результате работы пользователя изменилась.
	//   <0 - сумма долга не изменилась
	//   0  - ошибка
	//
	int    SLAPI ViewPayments(PPID billID, int kind);
	//
	// Descr: вызывает модальный броузер просмотра бух проводок по документу billID.
	//   В этом броузере не допускаются какие-либо изменения.
	// Returns:
	//   0 - Error (called PPError())
	//  -1 - OK (no modifications)
	//
	int    SLAPI ViewAccturns(PPID billID);
	int    SLAPI FillTurnList(PPBillPacket *);
	int    SLAPI UniteGoodsBill(PPBillPacket *, PPID addBillID, int use_ta);
	int    SLAPI UniteReceiptBill(PPID destBillID, PPIDArray * srcArray, int use_ta);
	int    SLAPI PrintCheck(PPBillPacket *, int addSummator);
	int    SLAPI PosPrintByBill(PPID billID);
	SArray * SLAPI MakePaymentList(PPID, int charge);
	int    SLAPI ViewBillInfo(PPID billID);
	int    SLAPI SubstText(const PPBillPacket * pPack, const char * pTemplate, SString & rResult);
	int    SLAPI SubstMemo(PPBillPacket * pPack);
	//
	// Descr: Вставляет товарную строку (или строки), создаваемые по образцу
	//   типа ILTI в пакет документа PPBillPacket.
	// ARG(pItem IN):     структура, содержащая информацию о вставляемой
	//   в документ товарной строке
	// ARG(pPack IN/OUT): пакет товарного документа, в который вставляется строка
	// ARG(pRows OUT):    указатель на массив позиций товарных строк документа, в
	//   которые были добавлены новые элементы
	// ARG(flags IN):     флаги, определяющие особенности добавления новой строки (строк)
	//   см примечания к флагам CILTIF_XXX
	// Returns:
	//   > 0   - OK
	//     0   - Error
	// Remark:
	//   После вызова функции необходимо проверить поле pItem->Rest. Если его
	//   значение не равно 0, значит функции не удалось полностью вставить
	//   строку в документ (например, из-за недостатка товара pItem->GoodsID).
	//
	int    SLAPI ConvertILTI(ILTI *, PPBillPacket *, IntArray * pRows, uint, const char * pSerial, const GoodsReplacementArray * pGri = 0);
	int    SLAPI AdjustIntrPrice(const PPBillPacket * pPack, PPID goodsID, double * pAdjPrice);
	int    SLAPI CmpSnrWithLotSnr(PPID lotID, const char * pSerial);
	int    SLAPI ConvertBasket(const PPBasketPacket * pBasket, PPBillPacket * pPack);
	//
	// Descr: конвертирует докумет srcID общей (не расширенной)
	//   бух проводки в документ расширенной бух операции opID.
	//   Если negAmount != 0, то сумма конвертированного документа изменяет знак.
	//   В результате конвертации документ srcID удаляется, и создаетс
	//   документ с ид *pDestID.
	//
	int    SLAPI ConvertGenAccturnToExtAccBill(PPID srcID, PPID * pDestID, CvtAt2Ab_Param *, int use_ta);
	int    SLAPI GetShipmByOrder(PPID orderID, const DateRange *, PPIDArray *);
	int    SLAPI EnumMembersOfPool(PPID poolType, PPID poolOwnerID, PPID * pMemberID, BillTbl::Rec * pRec = 0);
	int    SLAPI IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID);
		// @>>P_Tbl->IsMemberOfPool(PPID billID, PPID poolType, PPID * pPullOwnerID)
	//
	// Descr: Возвращает период расчета долгов по контрагенту, определяемый нижней границей
	//   расчета, заданной в конфигурации (PPBillConfig::LowDebtCalcDate).
	// Если период пустой, то возвращает 0, в противном случае - указатель на rPeriod
	//
	DateRange * FASTCALL GetDefaultClientDebtPeriod(DateRange & rPeriod) const;

	struct DebtBlock {
		DebtBlock();
		DebtBlock & Reset();
		int    AddDimItem(PPID dimID, double debt, int expiry);
		int    GetDimList(RAssocArray & rList) const;

		double Amount;
		double Debt;
		int    HasMatured;
		int    MaxDelay;   // Максимальная задержка между текущей датой и датой документа
		int    MaxExpiry;  // Максимальная задержка между текущей датой и последним сроком оплаты по документу
		struct DimItem {
			PPID   DimID;
			int    MaxExpiry;
			double Debt;
		};
		TSArray <DimItem> DebtDimList; // @v7.0.2 Список сумм задолженности, ассоциированных с долговыми размерностями
	};
	//
	// (pPeriod == 0) -> (pPeriod->low == 0 && pPeriod->upp == 0)
	//
	int    SLAPI CalcClientDebt(PPID clientID, const DateRange * pPeriod, int diffByDebtDim, DebtBlock & rBlk);
	int    SLAPI CalcReturnPart(PPID arID, const DateRange & rPeriod, double * pShipment, double * pRet);
	int    SLAPI GetReceivableBillList(PPID arID, PPID curID, PayableBillList * pList);
	//
	// Descr: Флаги функции PPObjBill::CreateBankingOrders
	//
	enum {
		cboIn              = 0x0001, // Создавать входящие платежные ордера (получатель - главная организация)
		cboSkipUndefBnkAcc = 0x0002  // Если плательщик или получатель не имеют определенных банковских
			// счетов, то не формировать для таких контрагентов платежных ордеров.
	};
	//
	// Descr: Формирует список банковких платежных поручений на основе списка
	//   идентификаторов долговых документов rBillList.
	//   Документы в rBillList объединяются в группы по идентификатору
	//   контрагента.
	//
	int    SLAPI CreateBankingOrders(const PPIDArray & rBillList, long flags, PPGPaymentOrderList * pOrderList);
	//
	// Reckoning functions
	//
	int    SLAPI Reckon(PPID paymBillID, PPID debtBillID, PPID reckonOpKindID, PPID * pReckonBillID, int dateOption /* RECKON_DATE_XXX */, LDATE reckonDate, int use_ta);
	int    SLAPI GatherPayableBills(ReckonOpArItem * pItem, PPID curID, PPID locID, PPID obj2ID, const DateRange *, double * pDebt);
	struct ReckonParam {
		ReckonParam(int automat = 1, int dontConfirm = 0)
		{
			THISZERO();
			SETFLAG(Flags, fAutomat, automat);
			SETFLAG(Flags, fDontConfirm, dontConfirm);
		}
		enum {
			fAutomat     = 0x0001, // Зачитывать автоматически (по умолчанию TRUE)
			fDontConfirm = 0x0002, // Не запрашивать предупреждение (по умолчанию FALSE)
			fPopupInfo   = 0x0004  // @v8.0.11 Показывать всплывающее окно с информацией о зачете
		};
		long   Flags;
		PPID   ForceBillID;
		LDATE  ForceBillDate;
		char   ForceBillCode[24];
	};
	int    SLAPI ReckoningPaym(PPID billID, const ReckonParam & rParam, int use_ta);
	int    SLAPI ReckoningDebt(PPID billID, const ReckonParam & rParam, int use_ta);
	//
	// Descr: Корректирующая функция. Проверяет и, если надо, исправляет оплаты
	//   и признаки оплат по документам
	//
	int    SLAPI GatherPayments();
	int    SLAPI AutoCharge(PPID, PPID op, const PPRentCondition *, const DateRange *, PPLogger * pLogger);
	int    SLAPI AutoCharge(PPID);
	int    SLAPI AutoCharge();
	int    SLAPI AutoCalcPrices(PPBillPacket * pPack, int interactive, int * pIsModified);
	int    SLAPI SelectQuotKind(PPBillPacket * pPack, const PPTransferItem * pTi, int interactive, PPID * pQkID, double * pQuot);
	int    SLAPI SetupQuot(PPBillPacket * pPack, PPID forceArID);
	int    SLAPI ViewLotComplete(PPID lotID, PPID * pSelectedLotID);
	int    SLAPI SearchPaymWOLinkBill();
	//
	// Descr: Аварийная функция - восстанавливает ссылки на объединенные города,
	//   зависшие во фрахтах документов.
	//
	int    SLAPI RecoverUnitedFreightPorts();
	//
	// Descr: Рассчитываеть сальдо по товарным операциям по товару goodsID и контрагенту arID.
	//   Расчет ведется в рамках периода pPeriod, если pPeriod != 0. Если endOprNo != 0,
	//   то перечисляются только те операции, пара {Dt, OprNo} которых меньше пары {pPeriod->upp, endOprNo}.
	//   Если pPeriod == 0 или pPeriod->upp == ZERODATE, то параметр endOprNo игнорируется.
	// Note: Еще раз обратим внимание на то, что операция с парой {pPeriod->upp, endOprNo} не входит
	//   в рассмотрение при расчете.
	//
	int    SLAPI CalcGoodsSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, const DateRange * pPeriod, long endOprNo, double * pSaldoQtty, double * pSaldoAmt);
	int    SLAPI GetGoodsSaldo(PPID goodsID, PPID arID, PPID dlvrLocID, LDATE dt, long oprNo, double * pSaldoQtty, double * pSaldoAmt);
	int    SLAPI GetPriceRestrictions(PPBillPacket & rPack, const PPTransferItem & rTi, int itemPos, RealRange * pRange);
	//
	// Inventory
	//
	enum InvMovSgo {
		imsgoAdd = 0,
		imsgoSkip,
		imsgoFail
	};
	struct InvItem {
		void   Init(PPID goodsID, const char * pSerial);

		PPID   GoodsID;          // @in
		char   Serial[24];       // @in
		long   Flags;            // @in INVENTF_XXX
		LDATE  RestDt;           // @in @v7.6.2 Дата, на которую надо расчитывать учетный остаток (если 0, то на дату инвентаризации)
		long   RestOprNo;        // @in @v7.6.2 Номер операции за день, до которой следует брать в расчет учетный остаток (если 0, то на конец дня)
		double UnitPerPack;      // @in
		double Qtty;             // @in
		double Cost;             // @in
		double Price;            // @in
		const  InventoryArray * P_InvList;
		//
		// Исходящие состояния добавления строки
		//
		enum {
			stAddedToExistLine = 0x0001, // Количество добавлено к существующей строке
			stUpdatedAutoLine  = 0x0002, // Изменена авто-строка
			stFailOnDup        = 0x0004, // Вставка строки закончилась неудачно из-за
				// существовани аналогичной позиции в документе (InvBlock::Flags & InvBlock::fFailOnDup)
			stSkip             = 0x0008  // Строка не проведена по штатным причинам (returns -1)
		};
		double FinalQtty;        // @out
		double FinalPrice;       // @out
		double FinalRest;        // @out
		double StockPrice;       // @out Цена инвентаризации, вычисленная функцией GetInventoryStockRest
		long   State;            // @out
	};
	class InvBlock {
	public:
		enum {
			fPriceByLastLot    = 0x0001, // Цену брать из последнего лота
			fFailOnDup         = 0x0002, // При существовании аналогичной позиции сигнализировать об ошибке
				// (не складывать количества).
			fSkipZeroRest      = 0x0004, //
			fUseCurrent        = 0x0008, // Функция AcceptInventoryItem определяет учетные характеристики
				// по текущему состоянию, но не на дату документа инвентаризации
			fAutoLine          = 0x0010,
			fAutoLineAllowZero = 0x0020,
			fAutoLineZero      = 0x0040
		};
		InvBlock(long flags = 0);
	private:
		friend class PPObjBill;
		enum {
			stInited = 0x001
		};
		long   State;
		long   Flags;
		PPInventoryOpEx Ioe;
		BillTbl::Rec BillRec;
	};

	int    SLAPI InitInventoryBlock(PPID billID, InvBlock & rBlk);
	int    SLAPI AcceptInventoryItem(InvBlock & rBlk, InvItem * pItem, int use_ta);

	InventoryCore & SLAPI GetInvT();
	int    SLAPI TurnInventory(PPBillPacket * pPack, int use_ta);
	int    SLAPI EditInventory(PPBillPacket * pPack, long);
	int    SLAPI AutoFillInventory(const AutoFillInvFilt *);
	int    SLAPI UniteInventory(PPID destID, PPIDArray * pSrcList, InvMovSgo, int rmvSrc, int use_ta);
	int    SLAPI GetInventoryStockRest(InvBlock & rBlk, InvItem * pItem, GoodsRestParam * pRestParam);
	//
	// Descr: Флаги функции RecalcInventoryStockRests
	//
	enum {
		rifRest    = 0x0001, // Пересчитывать остатки
		rifPrice   = 0x0002, // Пересчитывать цены
		rifAverage = 0x0004  // Аварийный пересчет
	};

	int    SLAPI RecalcInventoryStockRests(PPID billID, /*int recalcPrices*/long flags, int use_ta);
	int    SLAPI RecalcInventoryDeficit(const BillTbl::Rec * pRec, int use_ta);
	int    SLAPI ConvertInventory(PPID billID);
	int    SLAPI RollbackInventoryWrOff(PPID billID);
	int    SLAPI WriteOffDebtInventory(PPID billID, int use_ta);
	int    SLAPI ViewInventoryTotal(const PPIDArray & rIdList, const InventoryFilt * pFilt);
	//
	// Draft operations
	//
	int    SLAPI WriteOffDraft(PPID billID, PPIDArray *, PUGL *, int use_ta); // @NIA
	int    SLAPI RollbackWrOffDraft(PPID billID, int use_ta);
	int    SLAPI GetDeficitList(DateRange *, const PPIDArray * pLocList, RAssocArray *);
	int    SLAPI GetDraftRcptList(DateRange *, const PPIDArray * pLocList, DraftRcptArray *);
	int    SLAPI ProcessDeficit(PPID compOpID, PPID compArID, const PUGL * pPugl, PPLogger * pLogger, int use_ta);
	int    SLAPI CalcDraftTransitRest(PPID restOpID, PPID orderOpID, PPID goodsID, PPID locID, long flags, double * pRest, LDATE * pDt);
	//
	// Packages
	//
	int    SLAPI GenPckgCode(PPID pckgTypeID, char * pBuf, size_t bufLen);
	int    SLAPI InitPckg(LPackage *);
	int    SLAPI AddPckgToBillPacket(PPID pckgID, PPBillPacket *);
	int    SLAPI SelectPckgByCode(const char * pCode, PPID locID, PPID * pPckgID);
	int    SLAPI SelectPckg(PckgFilt * pFilt, PPID * pPckgID);
	int    SLAPI ViewPckgDetail(PPID pckgID);
	int    SLAPI IsLotInPckg(PPID lotID);
	int    SLAPI CheckPckgCodeUnique(const LPackage *, PPBillPacket *);
	int    SLAPI CorrectPckgCloseTag();
	int    SLAPI InitMirrorPckg(PPID billID, const LPackage * pSrc, LPackage * pDest);
	//
	// Cutting functions
	//
	int    SLAPI Cutting(LDATE endDate, int use_ta);
	int    SLAPI CuttingUntiedCLB(int use_ta);
	int    SLAPI SaveBalance(LDATE endDate, const char * pFileName);
	int    SLAPI LoadBalance(LDATE endDate, const char * pFileName, int use_ta);
	//
	// Streaming functions
	//
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);

	// Realy private function. Accessed only from PPObject::ReceivePackets()
	static int   SLAPI TotalTransmitProblems(ObjTransmContext * pCtx, int * pNextPassNeeded);

	int    SLAPI GetAlternateArticle(PPID arID, PPID sheetID, PPID * pAltArID);
	int    SLAPI GetPayableOpListByReckonOp(const PPReckonOpEx *, PPID arID, ReckonOpArList *);
	int    SLAPI GetPaymentOpListByDebtOp(PPID debtOpID, PPID arID, ReckonOpArList * pList);

	struct PplBlock {
		enum {
			fUseOpList     = 0x0001,
			fUsePaymOpList = 0x0002,
			fGatherPaym    = 0x0004,
			fByShipment    = 0x0008  // Доля оплаченных поставщику расходов берется по отгрузкам покупателям, на не по их оплатам
		};
		PplBlock(DateRange & rPeriod, const PPIDArray * pOpList, const PPIDArray * pPaymOpList);
		int    AddOp(PPID opID);
		int    AddPaymOpList(const PPIDArray & rOpList);
		int    FASTCALL CheckOp(PPID opID) const;
		int    FASTCALL CheckPaymOp(PPID opID) const;
		//
		// Descr: Сбрасывает внутреннее состояние объекта до готовности обработки
		//   очередного лота.
		//   { Amount = 0.0; Payment = 0.0; Part = 1.0; PaymList.clear(); }
		//
		void   Reset();
		void   FASTCALL AddPaym(const BillTbl::Rec & rRec);
		void   FASTCALL FinishLot(PPID orgLotID);

		long   Flags;
		DateRange Period;
		DateRange GatherPaymPeriod;
		PPIDArray OpList;
		PPIDArray PaymOpList;
		RAssocArray OrgPartList; // Список оплаченных частей, ассоциированных с оригинальными лотами.
			// Используется для ускорения расчета.
		//
		RAssocArray PaymList;    // Если Flags & fGatherPaym, то в этот массив заносятся пары
			// {ID, Amount} документов оплаты, попадающих в период GatherPaymPeriod.
		double NominalAmount;    // Номинальная сумма документа прихода в ценах поступления //
		double Amount;           // Сумма документа прихода в ценах поступления без возвратов
		double Payment;          // Сумма оплат от даты лота до конца периода Period
		double PaymentBefore;    // Сумма оплат от даты лота до начала периода Period
		double Part;             // Оплаченная часть лота от даты лота до конца периода Period
		double PartBefore;       // Оплаченная часть лота от даты лота до начала периода Period
	};
	int    SLAPI GetPayoutPartOfLot(PPID lotID, PplBlock & rBlk, double * pPart);

	struct EprBlock {
		double Amount; // Сумма прихода в ценах поступления //
		double Expend; // Сумма израсходованных товаров в ценах поступления //
		double Payout; // Сумма оплат по расходам в ценах поступления //
	};
	int    SLAPI GetExpendedPartOfReceipt(PPID lotID, const DateRange * pPeriod, const PPIDArray * pOpList, EprBlock & rBlk);
	//
	int    SLAPI CreateModifByPUGL(PPID modifOpID, PPID *, PUGL *, PPID sessID = 0, const GoodsReplacementArray * = 0);
	int    SLAPI CreateMrpTab(const PPIDArray * pList, MrpTabPacket *, PPLogger *, int use_ta);
	//
	PPID   SLAPI GetSupplAgent(PPID lotID);
	int    SLAPI NeedTransmit(PPID id, const DBDivPack & rDestDbDivPack, ObjTransmContext * pCtx);
	//
	// Descr: Определяет, влияет ли документ billID на состояние склада locID.
	//   Если locID == 0, то определяет, влияет ли документ на состояние складских запасов
	//   по любому из складов.
	// Returns:
	//   >0 - документ billID влияет на состояние складских запасов склада locID
	//   <0 - документ billID не влияет на состояние склада locID
	//   0  - ошибка
	//
	int    SLAPI IsInfluenceToStock(PPID billID, PPID locID);
	//
	// Descr: Извлекает список товаров, соджержащихся в товарных документах, возданных или
	//   измененных с момента rDtm.
	// Note: список rGoodsList функция предварительно не чистит, а после добавления в него товаров
	//   сортирует и удаляет дубликаты.
	//
	int    SLAPI GetGoodsListByUpdatedBills(PPID locID, const LDATETIME & rDtm, PPIDArray & rGoodsList);

	const  PPBillConfig & GetConfig() const;
	//
	// Descr: Флаги функции GetShippedPartOfReceipt
	//
	enum {
		gsporPayment        = 0x0001, // Рассчитывать по оплатам для отгрузок, требующим оплаты
		gsporIntrAsShipment = 0x0002, // Внутреннюю передачу считать отгрузкой. В противном случае пребираются и
			// лоты, сформированные внутренними передачами
		gsporUnlimIsShipped = 0x0004  // Нелимитированные ресурсы считать полностью отгруженными. В противном
			// случае нелимитированные ресурсы считаются никогда не отгружаемыми.
	};
	int    SLAPI GetShippedPartOfReceipt(PPID rcptBillID, const DateRange * pPeriod, const ObjIdListFilt & rOpList, long flags, double * pPart);

	class SubstParam {
	public:
		friend class PPObjBill;
		//
		SLAPI  SubstParam();
		SLAPI ~SubstParam();
		void   FASTCALL Init(SubstGrpBill sgb);
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

		SubstGrpBill Sgb;
		PPObjPerson::SubstParam Psp;
		LAssocArray AsscList; // Массив ассоциаций, связывающий группирующее значение со списком
			// документов, которые подпадают под эту группировку.
	private:
		LAssocArray * P_DebtDimAgentList;
	};

	int    SLAPI Subst(const PPBill * pPack, PPID * pDestID, SubstParam * pParam);
	int    SLAPI GetSubstObjType(long id, const SubstParam * pParam, PPObjID * pObjID) const;
	int    SLAPI GetSubstText(PPID srcID, SubstParam * pParam, SString & rBuf);
	//
	// Descr: Специализированная функция, реализующая минимально необходимую частичную загрузку
	//   субпакета документа PPBill для подстановки по критериям SubstParam.
	//   Главное назначение функции - снизить издержки на извлечении данных при подготовке
	//   отчетов, обрабатывающих значительное количество записей документов.
	//
	int    SLAPI LoadForSubst(const SubstParam * pParam, PPBill * pPack);
	//
	// Descr: Реализует предварительные операции для начисления по тарифицируемым транзакциям.
	//
	int    SLAPI InitGtaBlock();
	int    SLAPI InitGta(PPGta & rGta);
	//
	// Descr: Специализированная высокоуровневая функция, реализующая начисление или списание
	//   стоимости тарифицируемой транзакции с кредитной карты, ассоциированной с глобальной учетной записью.
	//
	int    SLAPI CheckInGta(const PPGta & rGta, int use_ta);
	//
	// Descr: Конвертация UUID'ов документов из записей Property в ObjTag
	//
	int    ConvertUuid7601();
public:
	void * ExtraPtr; // @v8.9.10 long Extra --> void * ExtraPtr
	long   State;
	PPBillConfig Cfg;
	PPObjOprKind * P_OpObj;
	PPObjAccTurn * atobj;

	//TLP_MEMB(BillCore, tbl);
	TLP_MEMB(BillCore, P_Tbl);
	TLP_MEMB(Transfer, trfr);
	TLP_MEMB(CpTransfCore, P_CpTrfr);
	TLP_MEMB(AdvBillItemTbl, P_AdvBI);
private:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint, ObjRights *, EmbedDialog * pDlg = 0);
	virtual const char * SLAPI GetNamePtr();

	int    SLAPI PutPckgList(PPBillPacket *, int use_ta);
	int    SLAPI LoadPckgList(PPBillPacket *);
	int    SLAPI Helper_EditGoodsBill(PPID *, PPBillPacket *);

	struct WrOffDraftBlock {
		SLAPI  WrOffDraftBlock(const PPDraftOpEx * pWrOffParam, PUGL * pDfctList);

		PPBillPacket SrcDraftPack;
		const PPDraftOpEx * P_WrOffParam;
		TSCollection <PPBillPacket> ResultList;
		PUGL * P_DfctList;
	};

	int    SLAPI Helper_WriteOffTurnResultItem(WrOffDraftBlock & rBlk, uint pos, PPIDArray * pWrOffBills); // @notransaction
	int    SLAPI Helper_WriteOffDraft(PPID billID, const PPDraftOpEx *, PPIDArray * pWrOffBills, PUGL * pDfctList, int use_ta);
		// @<<PPObjBill::WriteOffDraft
	int    SLAPI Helper_WrOffDrft_ExpExp(/*const PPBillPacket & rSrcDraftPack, const PPDraftOpEx * pWrOffParam, PPBillPacket * pPack, PUGL * pDfctList*/WrOffDraftBlock & rBlk, int use_ta);
		// @<<PPObjBill::Helper_WriteOffDraft
	int    SLAPI Helper_WrOffDrft_ExpModif(WrOffDraftBlock & rBlk, int use_ta);
	int    SLAPI Helper_WrOffDrft_ExpDrftRcp(/*const PPBillPacket & rSrcDraftPack, const PPDraftOpEx * pWrOffParam, PPBillPacket * pPack*/WrOffDraftBlock & rBlk, int use_ta);
	int    SLAPI Helper_WrOffDrft_DrftRcptModif(WrOffDraftBlock & rBlk, PPIDArray * pWrOffBills);
	int    SLAPI Helper_WrOffDrft_Acct(WrOffDraftBlock & rBlk, int use_ta);
	int    SLAPI Helper_PutBillToMrpTab(PPID billID, MrpTabPacket *, const PPDraftOpEx *, int use_ta);
	int    SLAPI InitDraftWrOffPacket(const PPDraftOpEx *, const BillTbl::Rec *, PPBillPacket *, int use_ta);
	int    SLAPI RemoveTransferItem(PPID billID, int rByBill, int force = 0);
	int    SLAPI ProcessLink(BillTbl::Rec *, PPID paymLinkID, const BillTbl::Rec * pOrgRec);
	int    SLAPI ProcessShadowPacket(PPBillPacket *, int update);
	int    SLAPI ProcessACPacket(PPBillPacket *);
	//
	// Descr: Находит доступные на дату dt по складу locID лоты, относящиеся к товарам,
	//   которые являются "членами обобщения goodsID". Под членством в обобщении goodsID
	//   подразумеваеся два возможных случая:
	//     1. goodsID является обобщенным товаром. При этом все товары, относящиеся к этому
	//        обобщению, само собой, являются "членами обобщения goodsID"
	//     2. Товар goodsID не является обобщенным, но относится к некоторому обобщению G.
	//        В этом случае, все остальные товары, относящиеся к обобщению G также являются //
	//        "членами обобщения goodsID"
	//   Лоты, относящиеся к товару goodsID не перебираются.
	//   Ко всем членам обобщения перед перебором по ним лотов применяется функция //
	//   PPObjGoods::IsGoodsCompatibleByUnit. Перебор лотов по члену обобщения ведется только
	//   в том случае, если этот вызов возвращает значение >0.
	// ARG(goodsID          IN): Ведующий товар обобщения, по которому ведется перебор лотов
	// ARG(locID            IN): Склад, относительно которого перебираются лоты. Если lotID == 0,
	//   то ни одного лота найдено не будет.
	// ARG(dt               IN): Перебор ведется по лотам, дата которых не превышает dt.
	// ARG(pLotList        OUT): @#{vptr0} Массив, в который функция добавляет найденные лоты.
	//
	// @v4.8.6 int    SLAPI EnumAltGenGoodsLots(PPID goodsID, PPID locID, LDATE dt, PPIDArray * pLotList);
	int    SLAPI ReplyGoodsDel(PPID);
	int    SLAPI ReplyGoodsReplace(PPID destID, PPID srcID);
	int    SLAPI ReplyInventGoodsReplace(PPID dest, PPID src);
	int    SLAPI ReplyArticleDel(PPID);
	int    SLAPI ReplyArticleReplace(PPID destID, PPID srcID);
	int    SLAPI OrderLots(const PPBillPacket *, PPIDArray *, PPID, double, double, double);
	int    SLAPI RegisterTransmitProblems(PPBillPacket *, ILBillPacket *, int skipped, ObjTransmContext * pCtx);
	int    SLAPI Helper_Reckon(PPID, ReckonOpArList *, CfmReckoningParam *, int dontConfirm, int use_ta);
	void   SLAPI Helper_PopupReckonInfo(PPIDArray & rResultBillList);
	int    SLAPI GetPoolsMembership(PPID id, PPBillPacket *);
		// @<<PPObjBill::ExtractPacket
	int    SLAPI SetTagNumberByLot(PPID lotID, PPID tagID, const char * pNumber, int use_ta);
	int    SLAPI Helper_GetPoolMembership(PPID id, PPBillPacket *, long flag, PPID poolType, PPID * pPoolID);
		// @<<PPObjBill::GetPoolsMembership
	int    SLAPI Helper_ConvertILTI_Subst(ILTI *, PPBillPacket *, IntArray * pRows,
		double * pQtty, long flags, const GoodsReplacementArray *, char * pSerial);
		// @<<PPObjBill::ConvertILTI
	int    SLAPI CheckPoolStatus(PPID billID, int poolType);
	int    SLAPI Debug_TrfrError(const PPBillPacket * pPack);
	int    SLAPI GetPayableBillList_(const PPIDArray * pOpList, PPID arID, PPID curID, PayableBillList * pList);
	//
	// Descr:
	//   1. Устанавливает зарезервированную сумму PPAMT_POOLAMOUNT по системному пулу
	//   которому принадлежит документ (учитываются следующие пулы: TSESSBILLPOOL TSDBILLPOOL).
	//   2. Устанавливает суммы документа, рассчитываемые по формулам
	// @attention Если документ является членом пула, то функция может создать (и разрушить)
	//   экземпляр объекта PPObjTSession. В связи с этим не следует вызывать
	//   функцию внутри транзакции (но это не повлечет ошибок в работе).
	// Returns:
	//   >0 - Сумма PPAMT_POOLAMOUNT установлена и (или) найдена и рассчитана по крайней
	//        мере одна формульная сумма.
	//   <0 - Документ не является членом ни одного из указанных пулов либо сам пул не существует
	//        и для вида операции не определено ни одной формульной суммы.
	//   0  - Ошибка
	//
	int    SLAPI SetupSpecialAmounts(PPBillPacket * pPack);
	int    SLAPI Helper_GetShipmentByLot(PPID lotID, const DateRange * pPeriod,
		const ObjIdListFilt & rOpList, long flags, double * pShipment, PPIDArray * pRecurTrace);
		// @>>PPObjBill::GetShippedPartOfReceipt
	int    SLAPI SerializePacket(int dir, ILBillPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI Helper_GetExpendedPartOfReceipt(PPID lotID, const DateIter & rDi, const DateRange * pPaymPeriod,
		const PPIDArray * pOpList, EprBlock & rBlk, PPIDArray & rRecurList);
	int    SLAPI Helper_GetPayoutPartOfLot(PPID lotID, PplBlock & rBlk, double * pPart, int recur);
	int    SLAPI PutSCardOp(PPBillPacket * pPack, int use_ta);
	int    SLAPI Helper_StoreClbList(PPBillPacket * pPack);
	PPID   FASTCALL GetGtaGoodsID(const PPGta & rGta);
	int    SLAPI AcceptLotSync(const PPBillPacket & rBp, const ILBillPacket & rIBp, ObjTransmContext * pCtx, int use_ta);
	int    SLAPI CheckModificationAfterLoading(const PPBillPacket & rPack);
	int    SLAPI Helper_CreateDeficitTi(PPBillPacket & rPack, const PUGL * pPugl, const PUGI * pItem, PUGL::SupplSubstItem * pSupplSubstItem, PPID & rComplArID);
		// @<<PPObjBill::ProcessDeficit
	int    SLAPI Helper_ExtractPacket(PPID id, PPBillPacket * pPack, uint fl, const PPIDArray * pGoodsList);

	struct GtaBlock {
		//
		// Ключевой компонент ассоциации (Key) является парой: { int16 GtaOp, ObjType; }
		// Значение ассоциации (Val) - GoodsID
		//
		LAssocArray OpGoodsAssoc;

		struct GuaAssocItem {
			PPID   GuaID;    // #key
			PPID   SCardID;
			PPID   PersonID;
			PPID   ArID;
		};
		TSArray <GuaAssocItem> GuaAssoc;
	};

	int    SLAPI GetGtaGuaAssoc(const PPGta & rGta, PPObjBill::GtaBlock::GuaAssocItem & rAssoc);

	struct LockSet {
		PPID   id;
		PPID   link;
	};
	TSArray <LockSet> locks;
	GtaBlock GtaB;
	const  long CcFlags;     // Копия CConfig.Flags ради небольшого увеличения эффективности кода по размеру и скорости работы
 	int    DemoRestrict;
	SString NameBuf;         // Returned by GetNamePtr
	PackageCore * P_PckgT;   //
	CurRateCore * P_Cr;      //
	InventoryCore * P_InvT;  //
	GoodsSaldoCore * P_GsT;  //
	PPObjSCard  * P_ScObj;   //
	PPObjLocation LocObj;    //
	PPObjGoods GObj;         //
	PPObjArticle ArObj;      //
	TLP_MEMB(HistBillCore, HistBill);
};

class PPObjAccTurn : public PPObject {
public:
	SLAPI  PPObjAccTurn(void * extraPtr = 0);
	SLAPI ~PPObjAccTurn();
	int    SLAPI CreateBlankAccTurn(PPID opID, PPBillPacket *, long * pFlags, int use_ta);
	int    SLAPI CreateBlankAccTurnBySample(PPBillPacket * pPack, PPBillPacket * pSamplePack, long * pFlags);
	int    SLAPI CorrectBalance();
	int    SLAPI EditTurn(LDATE, PPID billID, PPID oprKind, int showOnly);
	//
	// В функции ConvertStr параметры pAcctId и pAccSheetID могут быть нулевыми
	//
	int    SLAPI ConvertStr(const char *, PPID curID, Acct *, AcctID * pAcctId, PPID * pAccSheetID);
	//
	// В функции ConvertAcct параметр pAccSheetID может быть нулевым
	//
	int    SLAPI ConvertAcct(const Acct *, PPID curID, AcctID *, PPID * pAccSheetID);
	int    SLAPI ConvertAcctID(const AcctID *, Acct *, PPID * pCurID, int useCache);
	int    SLAPI CorrectRelsArRefs();
	int    SLAPI VerifyRevokingCurFromAccount(PPID accID, PPID curID);
	int    SLAPI VerifyChangingAccsheetOfAccount(PPID accID);
	//
	// Ищет среди проводок по документу pPack первую, которая имеет на стороне,
	// определяемой параметром side (PPDEBIT || PPCREDIT) счет первого порядка ac.
	// По указателю pCorrAcc возвращает счет, корреспондирующий со счетом ac
	// в найденной проводке. По указателю pPos возвращается индекс найденной проводки
	// в массиве записей PPBillPacket::Turns.
	// Returns:
	//    > 0 - заданная проводка найдена
	//      0 - заданная проводка не найдена (значения по указателям pCorrAcc и pPos
	//          не определены).
	//
	int    SLAPI SearchAccturnInPacketByCorrAcc(const PPBillPacket * pPack, int side, int ac, Acct * pCorrAcc, uint * pPos);
protected:
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);

	int    SLAPI ReplyAccDel(PPID);
	int    SLAPI ReplyArticleDel(PPID);
	int    SLAPI EditRecoverBalanceParam(RecoverBalanceParam *);
public:
	//TLP_MEMB(AccTurnCore, tbl);
	TLP_MEMB(AccTurnCore, P_Tbl);
private:
	void * ExtraPtr;
};
//
// Descr: Кэш символов сумм документов и формул. Используется при
//   разборе и вычислении формул (PPExprParser, DL200).
//
class BillSymbCache : public ObjCache {
public:
	struct Data : public ObjCacheEntry {
		int    F; // 0 - Dirty, 0x0001 - Amount, 0x0002 - Formula, 0x0004 - errOnDefault, 0x0008 - AdvLineAmount
	};
	SLAPI  BillSymbCache();
	//
	// Returns:
	//   1 - pSymb - сумма
	//   2 - pSymb - формула
	//   3 - pSymb - символ AdvLnAmt
	//   0 - символ не распознан
	//
	int    SLAPI Fetch(const char * pSymb, PPID * pID, SString & rBuf); // @sync_rw
	int    SLAPI DirtySymb(const char * pSymb); // @sync_rw
private:
	virtual int  SLAPI FetchEntry(PPID id, ObjCacheEntry * pEntry, long extraData = 0)
	{
		return 0;
	}
	virtual void SLAPI EntryToData(const ObjCacheEntry * pEntry, void * pDataRec) const
	{
	}
	int    SLAPI Search(const char * pSymb, PPID * pID, SString & rBuf) const;
	int    SLAPI Add(int F, PPID id, const char * symb, const char * buf);

	long   sDELIM;
	StringSet SymbSet;
	StringSet FormSet;
};
//
// @ModuleDecl(LocTransfCore)
//

//
// Descr: Идентификаторы типов складских операций
//   Наименования операций хранятся в строке PPTXT_LOCTRANSF_OPTEXT в формате: "1,text;2,text;3,text"
//
#define LOCTRFROP_PUT                  1 // Положить товар в ячейку
#define LOCTRFROP_GET                  2 // Извлечь товар из ячейки
#define LOCTRFROP_INVENT               3 // Инвентаризация ячейки
//
// Descr: Флаги ограничений размещения в складских ячейках
//
#define LOCDISPRESTR_SINGLEWARE   0x0001 // Ограничение единственным наименованием товара
#define LOCDISPRESTR_VOLUME       0x0002 // Оганичение по суммарному объему
#define LOCDISPRESTR_BRUTTO       0x0004 // Ограничение по суммарной массе брутто
#define LOCDISPRESTR_PALLETCOUNT  0x0008 // Ограничение по количеств паллет
#define LOCDISPRESTR_PALLETONLY   0x0010 // Загрузка только паллетами
#define LOCDISPRESTR_PALLETSIZE   0x0020 // Ограничение по размеру паллет

struct LocTransfOpBlock {
	LocTransfOpBlock(int op, PPID locID);
	LocTransfOpBlock & FASTCALL operator = (const LocTransfTbl::Rec * pRec);
	LocTransfOpBlock & SLAPI Init(int op, PPID locID);
	int    FASTCALL IsEqual(const LocTransfTbl::Rec & rRec) const;

	int    Op;             // LOCTRFROP_XXX
	PPID   BillID;         //
	int    RByBill;        // Номер операции по документу. Для новой записи 0.
	PPID   GoodsID;        //
	PPID   LotID;          //
	PPID   LocID;          // Ячейка размещения //
	long   RByLoc;         // Номер операции по ячейке. Для новой записи 0.
	PPID   PalletTypeID;   //
	uint   PalletCount;    //
	double Qtty;           //
};

class LocTransfCore : public LocTransfTbl {
public:
	SLAPI  LocTransfCore();
	SLAPI ~LocTransfCore();
	int    SLAPI Search(PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    SLAPI SearchRestByGoods(PPID goodsID, PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    SLAPI SearchRestByLot(PPID lotID, PPID locID, long rByLoc, LocTransfTbl::Rec * pRec);
	int    SLAPI EnumByBill(PPID billID, int16 * pRByBill, LocTransfTbl::Rec * pRec);
	int    SLAPI GetTransByBill(PPID billID, int16 rByBill, TSArray <LocTransfTbl::Rec> * pList);
	int    SLAPI PutOp(const LocTransfOpBlock & rBlk, int * pRByLoc, int use_ta);
	int    SLAPI RemoveOp(PPID locID, long rByLoc, int use_ta);
	int    SLAPI ValidateOpBlock(const LocTransfOpBlock & rBlk);
	int    SLAPI GetLocCellList(PPID goodsID, PPID parentLocID, RAssocArray * pList);
	int    SLAPI GetGoodsList(PPID locCellID, RAssocArray * pList);
	int    SLAPI GetCellListForGoods(PPID goodsID, const PPIDArray * pDomain, RAssocArray * pList);
	//
	// Descr: Находит список ячеек, в которых ничего нет. Если pDomain != 0,
	//   то в расчет принимаются только те ячейки, которые перечислены в этом списке.
	//
	int    SLAPI GetEmptyCellList(const PPIDArray * pDomain, PPIDArray * pList);
	//
	// Descr: Определяет список ячеек, в которых есть хоть что-то.
	//   Если pDomain != 0, то в расчет принимаются только ячейки из этого списка.
	//
	int    SLAPI GetNonEmptyCellList(const PPIDArray * pDomain, PPIDArray * pList);
	//
	// Descr: Определяет размещение по ячейкам строки rByBill товарного документа billID.
	//   Резудьтат возвращается в массиве rDispositionList.
	//
	int    SLAPI GetDisposition(PPID billID, int rByBill, TSArray <LocTransfTbl::Rec> & rDispositionList);
	//
	// Descr: Определяет размещение по ячейкам строк товарного документа billID.
	//   Резудьтат возвращается в массиве rDispositionList.
	//
	int    SLAPI GetDisposition(PPID billID, TSArray <LocTransfTbl::Rec> & rDispositionList);
private:
	int    SLAPI PrepareRec(PPID locID, PPID billID, LocTransfTbl::Rec * pRec);
	int    SLAPI GetLastOpByLoc(PPID locID, long * pRByLoc, LocTransfTbl::Rec * pRec);
	int    SLAPI GetLastOpByBill(PPID billID, int16 * pRByBill, LocTransfTbl::Rec * pRec);
	int    SLAPI GetLastOpByLot(PPID locID, PPID lotID, LocTransfTbl::Rec * pRec);
	int    SLAPI GetLastOpByGoods(PPID locID, PPID goodsID, LocTransfTbl::Rec * pRec);
	int    SLAPI UpdateForward(PPID locID, long rByLoc, PPID goodsID, PPID lotID, int check, double * pAddendum);
	int    SLAPI UpdateCurrent(PPID locID, PPID goodsID, PPID lotID, double addendum);

	PPObjLocation LocObj;
};
//
//
//
struct LocTransfDisposeItem {
	//
	// Descr: Теговые флаги результата размещения.
	//
	enum {
		ctUndef      = 0,
		ctEmpty      = 0x0001, // Ячейка пустая //
		ctInAssoc    = 0x0002, // Ячейка ассоциирована с заданным товаром (предпочтительна)
		ctOutOfAssoc = 0x0004, // Ячейка не ассоциирована с заданным товаром при том, что ассоциации заданы.
			// Если ассоциаций товар-ячейка не существует вообще, этот флаг не устанавливается.
		ctUpper      = 0x0008  // Ячейка находится на верхнем ярусе
	};
	LocTransfDisposeItem();

	int    Op;             // INOUT
	PPID   GoodsID;        // IN
	PPID   WhLocID;        // IN Склад, в пределах которого следует размещать товар.
	PPID   BillID;         // IN
	int    BillTiIdx;      // IN
	PPID   LotID;          // IN
	long   Tag;            // OUT Флаги результата размещения //
	PPID   LocID;          // OUT
	PPID   Loc2ID;         // OUT
	PPID   PalletTypeID;   // OUT
	int    PalletCount;    // OUT
	double Qtty;           // INOUT
};

typedef TSArray <LocTransfDisposeItem> LocTransfDisposeArray;

class LocTransfDisposer {
public:
	SLAPI  LocTransfDisposer();
	SLAPI ~LocTransfDisposer();
	int    SLAPI Dispose(const LocTransfDisposeItem & rItem, LocTransfDisposeArray & rOutList, int use_ta);
	int    SLAPI Dispose(const LocTransfDisposeArray & rInList, LocTransfDisposeArray & rOutList, int use_ta);
	//
	// Descr: Размещает документы из списка rBillList по складским ячейкам.
	// ARG(rBillList IN): Список идентификаторов документов, которые необходимо разместить по ячейкам
	// ARG(pLogger   INOUT): @#{vptr0} Если не ноль, то в этот логгер будет записан отчет о размещении.
	// ARG(use_ta    IN): Если !0, то размещение осуществляется в рамках собственной транзакции.
	//
	int    SLAPI Dispose(const PPIDArray & rBillList, PPLogger * pLogger, int use_ta);
	int    SLAPI ArrangeCellList(const LocTransfDisposeItem & rItem, PPIDArray & rLocList);
	int    SLAPI GetDistance(PPID loc1ID, PPID loc2ID, double * pDistance);
	int    SLAPI CheckLocRestictions(const LocTransfDisposeItem & rItem);
private:
	int    SLAPI SetupOpBlock(LocTransfDisposeItem & rItem, PPID whCellID, double * pQtty, LocTransfOpBlock & rBlk);
	int    SLAPI ArrangeColumnList(PPIDArray & rColumnList);

	enum {
		stGtoaLoaded = 0x0001
	};
	LocTransfCore LtT;
	PPObjLocation LocObj;
	PPObjGoods GObj;
	GoodsToObjAssoc GtoAssc;
	long   State;
};
//
// @ModuleDecl(PPViewLocTransf)
//
struct LocTransfFilt : public PPBaseFilt {
	SLAPI  LocTransfFilt();

	enum {
		fZeroLot    = 0x0002,
		fZeroBill   = 0x0004
	};
	//
	// Descr: Режимы отображения данных
	//
	enum {
		modeGeneral = 0, // Общий (операции)
		modeCurrent,     // Текущее состояние остатков ячеек.
		modeEmpty,       // Пустые ячейки
		modeDisposition  // Размещение документов по ячейкам.
			// В этом режиме отображаются все строки документа, даже те, которые не рзмещены.
	};
	enum {
		moAnyMove = 0,
		moCurRest,
		moPut,
		moGet
	};
	enum {
		grpNone = 0,
		grpByColumn,
		grpByZone,
		grpByWarehouse
	};
	char   ReserveStart[32];   // @anchor
	PPID   GoodsGrpID;
	PPID   GoodsID;
	PPID   LotID;
	long   Mode;               // modeXXX
	long   MoveOp;             // moXXX
	long   Grp;
	SubstGrpGoods Sgg;         //
	long   Flags;
	ObjIdListFilt LocList;     // @anchor
	ObjIdListFilt BillList;    // Список размещаемых документов
};

struct LocTransfViewItem : public LocTransfTbl::Rec {
	PPID   TempID__;
	double BillQtty;
};

class PPViewLocTransf : public PPView {
public:
	struct Hdr {
		PPID   ID__;
		PPID   LocID;
		long   RByLoc;
	};
	SLAPI  PPViewLocTransf();
	SLAPI ~PPViewLocTransf();

	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(LocTransfViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI AddItem(PPID curLocID, long curRByLoc);
	int    SLAPI EditItem(PPID tempRecID, PPID curLocID, long curRByLoc);
	int    SLAPI DeleteItem(PPID tempRecID, PPID curLocID, long curRByLoc);
	int    SLAPI Helper_BuildDispTable(int clearBefore, int use_ta);
	int    SLAPI ProcessDispBill(PPID billID, BExtInsert * pBei, int use_ta);
	int    SLAPI UpdateTempRec(PPID tempRecID, PPID locID, int rByLoc, int use_ta);
	int    SLAPI Dispose();
	TempLocTransfTbl::Rec & SLAPI MakeTempRec(const LocTransfTbl::Rec & rRec, TempLocTransfTbl::Rec & rTempRec);

	static int DynCheckCellParent;

	LocTransfFilt Filt;
	LocTransfCore Tbl;
	ObjIdListFilt Domain; // Список LocTransfFilt::LocList разворачивается по
		// складским ячейкам в данный список
	PPObjLocation LocObj;
	TempLocTransfTbl * P_TempTbl;
	PPIDArray DispBillList; // Список размещаемых документов.
	PPIDArray CellList;     // Список ячеек, принадлежащих фильтрующим локациям
};
//
// Флаги GCTFilt::Flags
//
#define OPG_BYZERODLVRADDR    0x00000010L // @v7.1.5 Перебирать только документы с пустым адресом доставки
#define OPG_IGNOREZERO        0x00000020L // Игнорировать нулевые записи
//
// Два следующих флага используются со структурой GoodsGrpngEntry
//
#define OPG_CALCINREST        0x00000080L // Считать входящий остаток
#define OPG_CALCOUTREST       0x00000100L // Считать исходящий остаток
//
// Descr: Следующий флаг передается процедуре GCTFilterDialog, заставляя //
//   проверять обязательный ввод товара
//
#define OPG_FORCEGOODS        0x00000200L //
#define OPG_ADJPAYM           0x00000400L // For internal use
#define OPG_STOREDAYLYRESTS   0x00000800L // @v9.1.3 При переборе строк Transfer GCTIterator сохраняет
	// информацию о ежедневных остатках товаров с детализацией по складам.
#define OPG_LABELONLY         0x00002000L //
#define OPG_NOZEROEXCISE      0x00004000L // Перебирать только подакцизные товары
#define OPG_COMPAREWROFF      0x00008000L // @v9.4.10 Если перебор ведется по драфт-документам, то сравнивать с документами списания //
#define OPG_GRPBYGENGOODS     0x00010000L // Группировать по обобщенным товарам (анализ товарных операций)
//
// Descr: Флаг OPG_SETTAXES предписывает процедуре
//   ProcessGoodsGrpng заносить в массив GoodsGrpngArray записи
//   с установленными значениями ставок НДС и (или) акциза
//   соответственно. При этом в массиве для одной операции может
//   присутствовать более одной записи (одна запись на каждую комбинацию
//   { вид операции; ставка НДС; ставка акциза; }).
//
#define OPG_SETTAXES          0x00020000L
#define OPG_DIFFBYTAX         0x00040000L // Разбивать группировку по налогам
#define OPG_SETCOSTWOTAXES    0x00080000L // Устанавливать цены поступления без налогов
#define OPG_DONTSHOWPRGRSBAR  0x00100000L // Не показывать индикатор завершенности процесса во время расчета
#define OPG_PROCESSRECKONING  0x00200000L // Обрабатывать зачитывающие оплаты
//
// Descr: Обрабатывать элементы обобщенной операции в завершении вызова функции
//   GoodsGrpngArray::EndGoodsGroupingProcess. Эта обработка включает удаление строк, соответствующих
//   операциям не входящим в список обобщение, а так же инверсию знаков элементов для тех членов обобщенной
//   операции, которые имеют признак "Отрицательная операция"
//
#define OPG_PROCESSGENOP      0x00400000L //
// Флаг используются со структурой GoodsGrpngEntry
#define OPG_PROCESSBYLOTS     0x00800000L //
#define OPG_CALCBILLROWS      0x01000000L // Обрабатывать статистику по строкам каждого документа
#define OPG_BYZEROAGENT       0x02000000L // Ограничивать документами, в которых не указан агент
	// Ограничение по этому флагу имеет приоритет перед полем GCTFilt::AgentID
#define OPG_FORCEBILLCACHE    0x04000000L // Использовать классом GCTIterator кэш документов
#define OPG_OPTIMIZEFORPSALES 0x08000000L // Оптимизировать выборку для построения таблицы продаж
#define OPG_COSTBYPAYM        0x10000000L // Себестоимость элементов рассчитывать пропорционально
	// оплаченной части документа оригинального лота (см. GGEF_COSTBYPAYM)
#define OPG_INCLACCOPS        0x20000000L // @v8.6.1 Включать в отчет бухгалтерские документы
#define OPG_SKIPNOUPDLOTREST  0x40000000L // @v8.9.0 Пропускать операции, не изменяющие товарные остатки (OPKF_NOUPDLOTREST)
//
// Descr: Фильтр для построения перекрестной отчетности
//
enum GCTSoftRestrict {
	srNone    = 0,
	srArticle = 1,
	srAgent   = 2,
	srGoods   = 3
};

struct GCTFilt : public PPBaseFilt {
	SLAPI  GCTFilt();
	int    FASTCALL CheckWL(long billFlags) const;
	int    FASTCALL AcceptIntr3(const BillTbl::Rec & rRec) const;

	enum Order {
		ordByDate = 1,
		ordByGoods,
		ordByArticle
	};
	uint8  ReserveStart[32];      // @anchor @v9.3.6
	DateRange Period;             // Период обзора операций
	DateRange LotsPeriod;         // Период приходов
	DateRange ShipmentPeriod;     // Период отгрузки
	PPID   OpID;                  //
	PPID   SupplID;               //
	PPID   ArID_;                 //
	PPID   DlvrAddrID;            // Адрес доставки. Если ArID == 0, то не используется //
	PPID   AgentID_;              // Агент по документам
	PPID   GoodsGrpID;            //
	PPID   GoodsID;               //
	PPID   ExtGoodsTypeID;        // Used only if (!GoodsGrpID && !GoodsID && !SupplID)
	PPID   BrandID;               // Торговая марка
	PPID   SupplAgentID;          //
	GCTSoftRestrict SoftRestrict; //
	long   Flags;                 // OPG_XXX
	long   Order;                 // GCTFilt::ordByXXX
	int16  GrpPeriod;             // PRD_XXX
	int16  Reserve2;              // @alignment
	ObjIdListFilt BillList;       // @anchor
	ObjIdListFilt LocList;        //
	ObjIdListFilt GoodsList;      // Список товаров (если GoodsList.getCount(), то поля GoodsID и GoodsGrpID не используются //
	ObjIdListFilt ArList;         // @v7.9.11
	ObjIdListFilt AgentList;      // @v7.9.11
};

#define GGEF_VATFREE         0x0001L
#define GGEF_TOGGLESTAX      0x0002L
#define GGEF_CALCBYPRICE     0x0004L // for internal use
#define GGEF_COSTWOVAT       0x0008L // for internal use
#define GGEF_DIFFBYTAX       0x0010L //
#define GGEF_SETCOSTWOTAXES  0x0020L // for internal use
#define GGEF_PRICEWOTAXES    0x0040L // for internal use
#define GGEF_COSTWSTAX       0x0080L //
#define GGEF_RECKONING       0x0100L // Зачитывающая оплата.
	// GoodsGrpngEntry::Link указывает на вид операции зачетного (не оплачиваемого) документа.
#define GGEF_LOCVATFREE      0x0200L // Склад освобожден от НДС
#define GGEF_INTERNAL        (GGEF_CALCBYPRICE|GGEF_COSTWOVAT|GGEF_SETCOSTWOTAXES)
#define GGEF_BYLOT           0x0400L // Обработка по лотам
#define GGEF_COSTBYPAYM      0x0800L // Себестоимость элемента умножать на оплаченную долю документа
	// оригинального лота. Оплата учитывается за период, открытый слева и ограниченный справа верхней датой
	// расчетного периода.
#define GGEF_PAYMBYPAYOUTLOT 0x1000L // Оплата по полностью оплаченному лоту
	// Этот флаг устанавливается для элемента GoodsGrpngEntry если фильтр имеет флаг
	// OPG_COSTBYPAYM и элемент сформирован по оплате приходного документа при условии,
	// что весь товар этого документа израсходован и оплачен покупателями.
#define GGEF_INTRREVERSE     0x2000L // Зеркальная по отношению к внутренней
	// передаче запись (межскладской приход)
#define GGEF_SUPPRDISCOUNT   0x4000L // @internal

struct GoodsGrpngEntry {
	SLAPI  GoodsGrpngEntry();
	PPID   FASTCALL IsProfitable(int incomeCalcMethod = -1) const;
	double FASTCALL Income(int incomeCalcMethod = -1) const;
	void   FASTCALL SetOp(const PPOprKind *);

	PPID   OpID;           // -1 input rest, 10000 - output rest
	PPID   LotID;          //
	PPID   LotTaxGrpID;    //
	PPID   GoodsTaxGrpID;  //
	PPID   OpTypeID;       //
	PPID   Link;           //
	long   Count;          //
	long   LnCount;        // Суммарное количество товарных строк в документах
	long   AvgLn;          // Среднее количество товарных строк в документах
	char   OpName[48];     // Наименование вида операции
	int16  Sign;           // Знак операции
	int16  Reserve;        // @alignment
	double Quantity;       //
	double Volume;         //
	double TaxFactor;      //
	double Cost;           //
	double Price;          //
	double Discount;       //
	double Amount;         //
	double ExtCost;        //
	double ExtPrice;       //
	double ExtDis;         //
	double CostPaymPart;   // Оплаченная часть документа оригинального лота операции
		// Рассчитывается только если GGEF_COSTBYPAYM. В противном случае 1.0.
	long   Flags;          //
	LDATE  LotDate;        // Дата поступления товара. Необходима для расчета налогов в ценах поступления.
private:
	double FASTCALL IncomeByOpr(PPID) const;
};
//
//
//
class AdjGdsGrpng {
public:
	SLAPI  AdjGdsGrpng();
	int    SLAPI BeginGoodsGroupingProcess(const GCTFilt * pFilt);
	int    SLAPI EndGoodsGroupingProcess();

	DateRange Period;
	PPIDArray BillList;
	PPIDArray SupplAgentBillList;
private:
	int    SLAPI PrevPaymentList(const GCTFilt *);
	int    SLAPI MakeBillIDList(const GCTFilt * pF, const PPIDArray * pOpList, int byReckon);
};

class GoodsGrpngArray : public SArray {
public:
	SLAPI  GoodsGrpngArray(PPLogger * pLogger = 0);
	SLAPI ~GoodsGrpngArray();
	void   SLAPI Reset();
	GoodsGrpngEntry & FASTCALL at(uint);
	int    SLAPI Search(GoodsGrpngEntry *, uint *);
	int    SLAPI Insert(GoodsGrpngEntry *, uint * p);
	//
	// Descr: просматривает все товарные операции по таблице Transfer в соответствии с фильтром,
	//   заданным первым параметром. Результатом является массив, группирующий операции по виду.
	//
	int    SLAPI ProcessGoodsGrouping(const GCTFilt *, const AdjGdsGrpng * pAgg);
	void   SLAPI InitOpNames();
	int    SLAPI WasErrDetected() const;
protected:
	struct AddEntryBlock {
		TransferTbl::Rec TrfrRec;
		ReceiptTbl::Rec LotRec;
		PPOprKind OpRec;
		double Part;
		long   Flags;
	};
	int    FASTCALL AddEntry(GoodsGrpngEntry *);
	int    SLAPI Calc(GCTFilt *, TransferTbl::Rec *, PPID, double, double);
	int    SLAPI CalcRest(GoodsRestParam *, const PPOprKind *, double);
	int    SLAPI _ProcessBillGrpng(GCTFilt *);
	int    FASTCALL IsLockPaymStatus(PPID statusID) const;
private:
	PPObjBill * P_BObj;
	PPObjGoods GObj;
	PPID   ExtCostAmtID;
	PPID   ExtPriceAmtID;
	PPID   ExtDisAmtID;
	int    ErrDetected;
	ObjIdListFilt LockPaymStatusList; // Список идентификаторов статусов докумена,
		// которые имеют признак "не учитывать как оплату" (BILSTF_LOCK_PAYMENT)
	PPObjBill::PplBlock * P_PplBlk;
	PPLogger * P_Logger; // @notowned
};
//
//
//
class PPDistribCCheck {
public:
	struct Header {
		Header();

		PPID   PosNodeID;
		PPID   LocID;
		LDATETIME Dtm;
		PPID   SCardID;
		long   Flags;
		double Amount;
		double Discount;
	};
	struct Line {
		Line();

		PPID   GoodsID;
		double Qtty;
		double Price;
		double Discount;
	};
	SLAPI  PPDistribCCheck();
	SLAPI ~PPDistribCCheck();
	int    SLAPI Begin(PPID * pID, const Header & rHdr);
	int    SLAPI AddLine(PPID ccID, const Line & rLn);
	int    SLAPI Finish(PPID ccID, PPID * pNewCcID);
private:
	CCheckCore Cc;
	PPObjCSession * P_CsObj;
	PPObjCashNode CnObj;
	PPObjLocation LocObj;
};
//
class Backend_SelectObjectBlock;
//
// Descr: Фронтальный класс, обеспечивающий интерфейс к механизму обработки серверных запросов
//   с унифицированным синтаксисом.
//
class SelectObjectBlock {
public:
	SelectObjectBlock();
	~SelectObjectBlock();
	//
	// Descr: Разбирает текстовую команду pStr.
	// ARG(pStr     IN): Командная строка
	// Returns:
	//  >0 - команда разобрана успешно.
	//  0  - ошибка
	//
	int    FASTCALL Parse(const char * pStr);
	//
	// Descr: Выполняет предварительно разобранную функцией Parse команду.
	//
	int    FASTCALL Execute(PPJobSrvReply & rReply);
private:
	Backend_SelectObjectBlock * P_BSob;
};
//
// Книги продаж/покупок
//

//
// Типы записей книги продаж/покупок
//
#define PPVTB_SELL               1L // Продажа
#define PPVTB_BUY                2L // Покупка
#define PPVTB_INVOICELISTSELL    3L // Реестр исходящих счетов-фактур
#define PPVTB_INVOICELISTBUY     4L // Реестр входящих счетов-фактур
#define PPVTB_SIMPLELEDGER       5L // Книга доходов/расходов для упрощенной схемы налогообложения //

class VATBCfg {
public:
	//
	// Флаги элементов списка
	//
	enum {
		fExclude       = 0x0001, // Исключить операцию при формировании книги
		fNegative      = 0x0002, // Операция заносится в книгу с инвертированным знаком
		fByExtObj      = 0x0004, // Контрагентом в записи книги является дополнительный объект
		fVATFromReckon = 0x0008, // Налоги из зачетного документа
		fVATFree       = 0x0010, // Операция освобождена от налогов
		fAsPayment     = 0x0020, // Только для типов операции PPOPT_PAYMENT.
			// Запись по операции формируется так: в книгу заносится запись датой документа
			// с суммой равной номинальной сумме этого документа и суммами НДС, рассчитываемыми
			// по связанному документу. Для связанного документа его датой формируется сторнирующая запись.
		fExpendByFact  = 0x0040, // Учитывать расходы по операции по факту. То есть,
			// если документ является приходом товаров, то перечисляются все лоты, сформированные
			// документом и суммируются все отгрузки (возможно по оплатам) по этим лотам за
			// заданный период.
		fFactByShipment = 0x0080  // Переопределяет учет по данной операции таким образом,
			// что документы этой операции будут учитываться по отгрузке (если общее правило книги - по оплате).
			// Если общее правило книги "по отгрузке", то данный флаг игнорируется.
	};
	//
	// Флаги конфигурации
	//
	enum {
		hfIterateClb      = 0x0001, // Translated to VatBookFilt::fIterateClb
		hfDontStornReckon = 0x0002, // Не сторнировать зачитывающие оплаты
		hfWoTax           = 0x0004, // Книга доходов/расходов без НДС
		hfD_InvcDate      = 0x0008, // В качестве даты записи использовать дату счета-фактуры
		hfD_MaxInvcBill   = 0x0010  // В качестве даты записи использовать более позднюю из дат
		//hfExpendByFactShipm
	};

	SLAPI  VATBCfg();
	VATBCfg & FASTCALL operator = (const VATBCfg &);
	int    SLAPI AddOp(PPID);
	int    SLAPI SetAccSheet(PPID);
	int    SLAPI CheckOp(PPID opID, PPID * pAccSheetID = 0);
	int    SLAPI CheckFlag(PPID opID, long f) const;
	int    SLAPI CheckAccSheet(PPID accSheetID);
	int    SLAPI CheckList(PPID * pAccSheetID = 0);
	int    SLAPI Setup();

	struct Item { // @persistent
		PPID   OpID;
		long   Flags;
		PPID   MainAmtTypeID;
		uint8  Reserve[12];
	};

	PPID   Kind;       // PPVTB_XXX
	PPID   AccSheetID; // ->Reference(PPOBJ_ACCSHEET) Таблица аналитических статей
	long   Flags;      // VATBCfg::hfXXX Флаги
	int16  AcctgBasis; // Форма учета доходности (INCM_XXX (PP.H))
	int16  AcctgBasisAtPeriod; // Форма учета доходности на определенный период
	DateRange Period;
	TSArray <Item> List;
};
//
// Флаги записи книги продаж/покупок
//
#define VATBF_FIX      0x0001L // Запись нельзя модифицировать
#define VATBF_EXCLUDED 0x0002L // Исключенная из реестра запись
	// Такая запись предотвращает попадание связанного документа в книгу
#define VATBF_VATFREE  0x0004L // Запись книги покупок, освобожденная от НДС
#define VATBF_PARTPAYM 0x0008L // Признак частичной оплаты

class PPObjVATBook : public PPObject {
public:
	static int SLAPI EditConfig(PPID kind, VATBCfg * cfg);
	static double FASTCALL GetVatRate(int);
	//
	// Descr: Извлекает базовое значение типа строки записи из (возможно) комбинированной
	//   величины, хранящейся в записи VATBookTbl::Rec.
	//
	static int FASTCALL IsValidKind(int kind)
	{
		return oneof3(kind, PPVTB_SELL, PPVTB_BUY, PPVTB_SIMPLELEDGER) ? 1 : PPSetError(PPERR_INVVATBOOKKIND);
	}
	SLAPI  PPObjVATBook(void * extraPtr = 0);
	SLAPI ~PPObjVATBook();
	virtual int  SLAPI DeleteObj(PPID);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Search(PPID id, void * b = 0);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI EditObj(PPID * pID, void * pData, int use_ta);
	int    SLAPI ValidateData(void * data, long);
	int    SLAPI ReadConfig();
private:
	//
	// Конфигурация книг продаж/покупок
	// sizeof(PPVATBConfig) == PROPRECFIXSIZE
	//
	struct PPVATBConfig {
		PPID  Tag;            // Const=PPOBJ_CONFIG
		PPID  ID;             // Const=PPCFG_MAIN
		PPID  Prop;           // PPPRP_VATBSCFG || PPPRP_VATBBCFG || PPPRP_SMPLLEDGCFG
		char  Reserve1[44];
		SVerT Ver;           // @v7.6.1 Версия формата (совпадает с версией системы, начиная с которой действует формат).
		LDATE BegDt;          //
		LDATE EndDt;          //
		long  Flags;          //
		PPID  AccSheetID;
		int16 AcctgBasis;
		int16 AcctgBasisAtPeriod;
		long  ListCount;
		// ... Далее следует список элементов VATBL
	};

	static int SLAPI ReadCfgList(PPID what, VATBCfg *);
	static int SLAPI WriteCfgList(PPID what, const VATBCfg *, int use_ta);

	virtual const char * SLAPI GetNamePtr();
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	PPID   SLAPI SelectLineType(uint * rezID, PPID what);
	VATBCfg VATBCSell;
	VATBCfg VATBCBuy;
	VATBCfg VATBSmplLedg;
public:
	TLP_MEMB(VATBookTbl, P_Tbl);
	void * ExtraPtr;

	const  VATBCfg & FASTCALL GetConfig(PPID kind) const;
};
//
// @ModuleDecl(PPObjCSession)
// Кассовые сессии
//
// Специфические флаги доступа к кассовым сессиям
//
//abcdefghijklmnopqrstuvwxyz
//ABCDEFGHIJKLMNOP RST   XYZ12

#define CSESSRT_OPEN               0x00000100 // O Открытие сессии
#define CSESSRT_CLOSE              0x00000200 // Z Закрытие сессии
#define CSESSRT_ADDCHECK           0x00000400 // A Добавление чека
#define CSESSRT_RMVCHECK           0x00000800 // D Удаление чека
#define CSESSRT_CHECKINFO          0x00001000 // E Редактирование специальной информации по чекам
#define CSESSRT_ESCCHECK           0x00002000 // C Отмена чека
#define CSESSRT_SYSINFO            0x00004000 // N Редактирование специальной информации по сессиям
#define CSESSRT_CORRECT            0x00008000 // Y Корректировки сессий
// Операционные флаги доступа в кассовых сессиях
#define CSESSOPRT_RETCHECK         0x00000001 // R Чеки возврата
#define CSESSOPRT_BANKING          0x00000002 // B Безналичный расчет
#define CSESSOPRT_ESCCLINE         0x00000004 // L Удаление строк в чеках
#define CSESSOPRT_PREPRT           0x00000008 // P Право на печать пре-чека
#define CSESSOPRT_SUSPCHECK        0x00000010 // S Право откладывать чеки
#define CSESSOPRT_COPYCHECK        0x00000020 // 1 Право на печать копии чека
#define CSESSOPRT_COPYZREPT        0x00000040 // 2 Право на печать копии Z-отчета
#define CSESSOPRT_SELNOTOWNSUSPCHK 0x00000080 // T Право на восстановление отложенного чека, привязанного к другому агенту
#define CSESSOPRT_ROWDISCOUNT      0x00000100 // I Право на установку скидки на строку чека
#define CSESSOPRT_XREP             0x00000200 // X Право на снятие X-отчета
#define CSESSOPRT_CTBLORD          0x00000400 // K Право на администрирование заказов столов (создание, изменение, отмена)
#define CSESSOPRT_SPLITCHK         0x00000800 // F @v7.0.5  Право на разделение чека
#define CSESSOPRT_CHGPRINTEDCHK    0x00001000 // G @v7.0.5  Право на изменение чека, по которому отпечат счет
#define CSESSOPRT_RESTORESUSPWOA   0x00002000 // H @v7.5.11 Право на извлечение отложенного чека без указания агента
#define CSESSOPRT_CHGCCAGENT       0x00004000 // J @v8.2.1  Право на смену агента в чеке
#define CSESSOPRT_MERGECHK         0x00010000 // M @v8.5.4  Право на объединение чеков
#define CSESSOPRT_ESCCLINEBORD     0x00020000 // Q @v8.7.3  Удаление строк в чеках до отправки заказа на изготовление

int SLAPI GetOperRightsByKeyPos(int keyPos, PPIDArray * pOperRightsAry);
int SLAPI EditDueToKeyboardRights();
//
// @todo @dbd_exchange Пакет чека передается не полностью
//
class PPObjCSession : public PPObject {
public:
	static SString & SLAPI MakeCodeString(const CSessionTbl::Rec * pRec, SString & rBuf);
	static int RightsToString(long rt, long opRt, SString & rBuf);
	static int StringToRights(const char * pBuf, long * pRt, long * pOpRt);

	SLAPI  PPObjCSession(void * extraPtr = 0);
	SLAPI ~PPObjCSession();
	virtual int  SLAPI Search(PPID id, void * b = 0);
	virtual int  SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Dirty(PPID id);
	//
	// Descr: Кэшированное извлечение записи CSession. Инициализируются следующие поля записи:
	//   ID, SuperSessID, CashNodeID, CashNumber, SessNumber, Dt, Tm, Incomplete, Temporary
	//
	int    SLAPI Fetch(PPID id, CSessionTbl::Rec * pRec);
	int    SLAPI Recalc(PPID sessID, int use_ta);
	int    SLAPI UndoWritingOff(PPID sessID, int use_ta);
	int    SLAPI ReWriteOff(PPID sessID, int level /* @#[0,5,10] */, int use_ta);
	int    SLAPI Recover(const PPIDArray & rSessList);
	int    SLAPI NeedTransmit(PPID id, const DBDivPack & rDestDbDivPack, ObjTransmContext * pCtx);
	const  PPEquipConfig & SLAPI GetEqCfg();
private:
	virtual const char * SLAPI GetNamePtr();
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int  SLAPI EditRights(uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI RemoveWrOffBills(PPID sessID, int use_ta);
	int    SLAPI VerifyAmounts(PPID sessID, const CSessTotal & rTotal, PPLogger & rLogger);

	SString NameBuf; // Returns by GetNamePtr
	PPEquipConfig * P_EqCfg; // @!GetEqCfg()
public:
	TLP_MEMB(CSessionCore, P_Tbl);
	void * ExtraPtr;
};
//
//
//
#if 0 // @v9.1.3 {
class PPCSessComplexImpExpParam : public PPImpExpParam {
public:
	SLAPI  PPCSessComplexImpExpParam(uint recId = 0, long flags = 0);
	int    SLAPI Clear();
	virtual int WriteIni(PPIniFile * pFile, const char * pSect) const;
	virtual int ReadIni(PPIniFile * pFile, const char * pSect, const StringSet * pExclParamList);
	virtual int SerializeConfig(int dir, PPConfigDatabase::CObjHeader & rHdr, SBuffer & rTail, SSerializeContext * pSCtx);

	enum {
		fSkinCSess  = 0x0001,
		fSkipCCheck = 0x0002,
		fSkipCCLine = 0x0004,
		fSkipCCPaym = 0x0008
	};
	long   Flags;
	SString CSessTag;
	SString CCheckTag;
	SString CCLineTag;
	SString CCPaymTag;
};
#endif // } 0 @v9.1.3
//
// @ModuleDecl(PPObjSCardSeries)
//
#define SCRDSF_CREDIT          0x0001L // Кредитные карты (иначе дисконтные)
#define SCRDSF_USEDSCNTIFNQUOT 0x0002L // Если с серией связан вид котировки и значение котировки для товара
	// не определено, то использовать скидку, заданную в карте.
#define SCRDSF_BONUS           0x0004L // @v7.3.7 Бонусные кредитные карты (предполагает установленный флаг SCRDSF_CREDIT)
#define SCRDSF_UHTTSYNC        0x0008L // @v7.3.7 Карты серии синхронизированы с сервисом Universe-HTT
#define SCRDSF_USEQUOTKINDLIST 0x0010L // @v7.4.0 @internal С серией связан список серий дисконтных карт.
	// Флаг необходим для игнорирования поля PPSCardSeries2::QuotKindID
#define SCRDSF_MINQUOTVAL      0x0020L // @v7.4.0 Если с серией карт ассоциирован список видов котировок (более одной),
	// то применять минимальную цену из котировок, полученных по списку.
#define SCRDSF_DISABLEADDPAYM  0x0040L // @v7.6.9 Запрет на доплату в кассовой панели (только для кредитных карт)
#define SCRDSF_BONUSER_ONBNK   0x0080L // @v8.2.10 SCardSeries::BonusChrgExtRule трактуется как изменение суммы оборота (для расчета начисления) в промилле.
#define SCRDSF_NEWSCINHF       0x0100L // @v8.8.0
#define SCRDSF_TRANSFDISCOUNT  0x0200L // @v9.2.8 Карты серии с таким флагом могут передавать значение скидки в новые карты выдельца любой серии (при создании)
//
// Descr: Типы серий карт
//
enum {
	scstUnkn = 0,     // Неопределенный тип
	scstDiscount = 1, // Простые дисконтные карты
	scstCredit,       // Кредитные карты
	scstBonus         // Бонусные карты
};

struct PPSCardSeries2 {    // @persistent @store(Reference2Tbl+)
	SLAPI  PPSCardSeries2();
	int    FASTCALL IsEqual(const PPSCardSeries2 & rS) const;
	int    SLAPI GetType() const;
	int    SLAPI SetType(int type);
	int    SLAPI Verify();

	long   Tag;                // Const=PPOBJ_SCARDSERIES
	long   ID;                 // @id
	char   Name[48];           // @name @!refname
	char   Symb[20];           // @symb
	PPID   ChargeGoodsID;      // Товар, использующийся для начисления на карту
		// (имеет приоритет перед PPSCardConfig::ChargeGoodsID)
	PPID   BonusChrgGrpID;     // Товарная группа, ограничивающая начисления на бонусные карты
	int16  BonusChrgExtRule;   // @v8.2.10 Дополнительная величина правила изменения начисления бонуса по карте
	uint8  Reserve2;           // @reserve
	int8   VerifTag;           // Если 1, то запись верифицирована версией 7.3.7 на предмет правильности установки флагов
	PPID   BonusGrpID;         // Товарная группа, по которой зачитываются бонусы на карты
	PPID   CrdGoodsGrpID;      // Товарная группа, продажа товаров которой зачитывается как
		// списание по кредитной карте в количественном выражении.
	char   CodeTempl[20];      // Шаблон номеров карт
	LDATE  Issue;              // Дата выпуска
	LDATE  Expiry;             // Дата окончания действия //
	long   PDis;               // Скидка (.01%)
	double MaxCredit;          // Максимальный кредит (для кредитных карт)
	long   Flags;              // @flags
	long   QuotKindID_s;       // Вид котировки
	long   PersonKindID;       // Вид персоналии, используемый для владельцев карт (по умолчанию - PPPRK_CLIENT)
};

DECL_REF_REC(PPSCardSeries);

struct TrnovrRngDis {      // @persistent
	SLAPI  TrnovrRngDis();
	int    SLAPI GetResult(double currentValue, double * pResult) const;
	enum {
		fBonusAbsoluteValue = 0x0001, // Величина Value применяется как абсолютное значение, начисляемое на бонусную карту
		fDiscountAddValue   = 0x0002, // Величина Value применяется как инкремент для величины скидки [-100..+100]
		fDiscountMultValue  = 0x0004  // Величина Value применяется как мультипликатор для величины скидки [0..10]
	};
	RealRange R;
	double Value;          // @v7.9.5 PDis-->Value
	PPID   SeriesID;       // ->Ref(PPOBJ_SCARDSERIES) Серия, в которую следует переместить карту, если
		// обороты по ней попадают в интервал [Beg..End]
	PPID   LocID;          // @v7.5.0 Локация, для которой применяется данный элемент правила.
	long   Flags;          // @v7.9.5 Reserve-->Flags
};

#define SCARDSER_AUTODIS_PREVPRD 1L
#define SCARDSER_AUTODIS_THISPRD 2L

class PPSCardSerRule : public TSArray <TrnovrRngDis> { // @persistent @store(PropertyTbl)
public:
	PPSCardSerRule();
	PPSCardSerRule & FASTCALL operator = (const PPSCardSerRule & s);
	void   SLAPI Init();
	int    FASTCALL IsEqual(const PPSCardSerRule & rS) const;
	int    SLAPI ValidateItem(int ruleType, const TrnovrRngDis & rItem, long pos) const;
	int    SLAPI IsList() const;
	int    SLAPI CheckTrnovrRng(const RealRange & rR, long pos) const;
	//int    SLAPI GetPDisValue(double amt, double * pValue) const;
	const TrnovrRngDis * SLAPI SearchItem(double amount) const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	enum {
		rultDisc = 1,
		rultCcAmountDisc,
		rultBonus
	};
	int32  Ver;            //
	//
	// Следующий блок выделен в структуру для того, чтобы сериализоваться общим отрезком.
	// При вводе вместо зарезервированного пространства новых полей следует сохранять общий
	// размер блока.
	//
	struct FlatBlock {
		uint8  Reserve[52];    // @reserve
		uint32 Internal[2];    // @internal
		long   Flags;          // @v7.3.9
	} Fb;
	int32  TrnovrPeriod;   // SCARDSER_AUTODIS_XXX
};

struct PPSCardSerPacket {
	SLAPI  PPSCardSerPacket();
	void   SLAPI Init();
	//
	// Descr: Реализует операции по нормализации внутреннего состояния пакета.
	//   В частности, согласовывает поле Rec.QuotKindID_s со списком QuotKindList и флагом SCRDSF_USEQUOTKINDLIST.
	//
	int    SLAPI Normalize();
	int    FASTCALL IsEqual(const PPSCardSerPacket & rS) const;
	int    SLAPI GetDisByRule(double trnovr, TrnovrRngDis & rEntry) const;

	enum {
		ufDontChgBonusRule    = 0x0001, // Функция PPObjSCardSeries::PutPacket не должна изменять правило расчета бонусов.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация BonusRule
		ufDontChgQkList       = 0x0002, // Функция PPObjSCardSeries::PutPacket не должна изменять список видов котировок.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация QuotKindList_
		ufDontChgExt          = 0x0004  // Функция PPObjSCardSeries::PutPacket не должна изменять запись расширения данных о серии.
			// Этот флаг будет использоваться до тех пор, пока не будет сделана синхронизация Ext
	};
	long   UpdFlags;          // @transient Флаги, определяющие правила изменения некоторых полей
	PPSCardSeries2 Rec;
	PPSCardSerRule Rule;
	PPSCardSerRule CcAmtDisRule;
	PPSCardSerRule BonusRule;    // @v7.3.9
	PPIDArray QuotKindList_;     // @v7.4.0 Список видов котировок, применимых для карт этой серии.
		// Конкретный вид котировки выбирается в соответствии с рангом и ограничениями.
	struct Ext {
		SLAPI  Ext();
		void   SLAPI Init();
		int    SLAPI IsEmpty() const;
		int    FASTCALL IsEqual(const Ext & rS) const;
		uint8  Reserve[52];
		LTIME  UsageTmStart;
		LTIME  UsageTmEnd;
		long   Reserve2[2];
	};
	Ext    Eb; // @v8.7.12
};

struct SCardChargeRule {
	SLAPI  SCardChargeRule();

	PPID   SerID;
	long   Period;
};

struct PPSCardConfig {         // @persistent @store(PropertyTbl)
	enum {
		fValid                = 0x0001, // Признак того, что запись является действительной (загруженной из базы данных)
		fSyncWoChecks         = 0x0002, // Заменяет DBDXF_SYNCSCARDWOCHECKS
		fAcceptOwnerInDispDiv = 0x0004, // Принимать изменения владельца карты в диспетчерском разделе
		fDontUseBonusCards    = 0x0008, // @v7.5.12 Использовать бонусные карты только как дисконтные.
			// Флаг следует установить в разделе базы данных, обслуживающем магазин, в котором бонусные карты не
			// должны использоваться, в противоположность другим синхронизированным магазинам.
		fCheckBillDebt        = 0x0010  // @v8.6.9 При операциях по карте проверять наличие простроченной задолженности по документам, привязанным к карте
	};
	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_SCARDCFG
	long   Flags;              //
	PPID   PersonKindID;       // ->Ref(PPOBJ_PRSNKIND) Вид персоналии, используемый для владельцев карт.
		// Этот параметр может быть переопределен серией карт.
	PPID   DefPersonID;        // ->Person.ID Персоналия, используемая как владелец карты по умолчанию
	PPID   ChargeGoodsID;      // ->Goods2.ID Товар, используемый для начисления на кредитную карту
	PPID   ChargeAmtID;        // ->Ref(PPOBJ_AMOUNTTYPE) Тип суммы, применяемый для начисления на кредитную карту из документа.
	PPID   DefSerID;           // Серия дисконтных карт по умолчанию //
	PPID   DefCreditSerID;     // Серия кредитных карт по умолчанию //
	long   WarnExpiryBefore;   // @v8.6.4 Период в днях, в течении которого владельца карты следует предупредить об истечении срока действия //
	char   Reserve1[40];       //
	long   Reserve2[2];        //
};

class PPObjSCardSeries : public PPObjReference {
public:
	static int SLAPI SetSCardsByRule(SCardChargeRule * pSelRule);
	static int SLAPI SelectRule(SCardChargeRule * pSelRule);
	static int SLAPI FetchConfig(PPSCardConfig * pCfg);

	SLAPI  PPObjSCardSeries(void * extraPtr = 0);
	SLAPI ~PPObjSCardSeries();
	virtual int    SLAPI Search(PPID id, void * b);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, PPSCardSeries * pRec);
	int    SLAPI GetPacket(PPID id, PPSCardSerPacket * pPack);
	int    SLAPI PutPacket(PPID * pID, PPSCardSerPacket * pPack, int use_ta);

	int    SLAPI GetCodeRange(PPID serID, SString & rLow, SString & rUpp);
		// @>>SCardCore::GetCodeRange
private:
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext * pCtx);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext * pCtx);
	virtual int SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	int    SLAPI SerializePacket(int dir, PPSCardSerPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);

	PPObjSCard * P_ScObj;
};
//
// @ModuleDecl(PPObjSCard)
//
//
// Специфические флаги доступа PPObjSCard (в дополнение к общим RT_XXX)
//
#define SCRDRT_VIEWOPS         0x0100      // Право просмотра операций по карте
#define SCRDRT_ADDOPS          0x0200      // Право добавления операций по карте
#define SCRDRT_RMVOPS          0x0400      // Право удаления операций по карте
#define SCRDRT_BINDING         0x0800      // Право на изменение привязки карты к чеку или документу
#define SCRDRT_MASSCHANGE      0x1000      // Право на массовое изменение дисконтных карт

#define SCRDF_INHERITED        0x00000001L // Карта наследует некоторые параметры от серии
#define SCRDF_CLOSED           0x00000002L // Карта закрыта (блокирована)
#define SCRDF_CLOSEDSRV        0x00000004L // Карта блокирована для службы доставки
#define SCRDF_NOGIFT           0x00000008L // При продаже по этой карте блокируется выдача подарка
#define SCRDF_AUTOCREATE       0x10000000L // @transient Специальный флаг, предписывающий функции, получившей запись
	// с таким флагом создать новую карту с некоторыми атрибутами записи.
#define SCRDF_NEEDACTIVATION   0x00000010L // Карта требует активации
#define SCRDF_AUTOACTIVATION   0x00000020L // Активаровать карту после первой операции
#define SCRDF_NOTIFYDISCOUNT   0x00000040L // @v9.6.1 Извещать владельца карты об изменении скидки
#define SCRDF_NOTIFYDRAW       0x00000080L // @v9.6.1 Извещать владельца карты о списании средств с карты
#define SCRDF_NOTIFYWITHDRAW   0x00000100L // @v9.6.1 Извещать владельца карты о начислении средств на карту

#define PPTRPROP_SCARDEXT      (PPTRPROP_USER+1)

class PPSCardPacket : public PPExtStrContainer {
public:
	SLAPI  PPSCardPacket();
	void   SLAPI Clear();
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке ExtString
	//
	enum { // @persistent
		extssMemo     = 1,
		extssPassword = 2,
		extssPhone    = 3  // @v9.4.6
	};
	SCardTbl::Rec Rec;
};

class PPObjSCard : public PPObject {
public:
	struct AddParam {
		AddParam(PPID serID = 0, PPID ownerID = 0);

		PPID   SerID;
		PPID   OwnerID;
		PPID   LocID;
		SString Code;
	};

	static const uint32 FiltSignature; // = 0xfbefffffU;
	//
	// Descr: Фильтр селектора (MakeStrAssocList)
	//
	struct Filt {
		SLAPI  Filt() : Signature(FiltSignature)
		{
			SeriesID = 0;
			OwnerID = 0;
		}
		const  uint32 Signature;
		PPID   SeriesID;
		PPID   OwnerID;
	};

	static int SLAPI WriteConfig(const PPSCardConfig * pCfg, int use_ta);
	static int SLAPI ReadConfig(PPSCardConfig * pCfg);
	static int SLAPI FetchConfig(PPSCardConfig * pCfg);
	static int SLAPI EditConfig();
	static int SLAPI PreprocessSCardCode(SString & rCode);
	static SString & SLAPI CalcSCardHash(const char * pNumber, SString & rHash);
	static long GetValidFlags()
	{
		return (SCRDF_INHERITED|SCRDF_CLOSED|SCRDF_CLOSEDSRV|SCRDF_NOGIFT|SCRDF_NEEDACTIVATION|
			SCRDF_AUTOACTIVATION|SCRDF_NOTIFYDISCOUNT|SCRDF_NOTIFYDRAW|SCRDF_NOTIFYWITHDRAW);
	}

	SLAPI  PPObjSCard(void * extraPtr = 0);
	SLAPI ~PPObjSCard();
	//
	// В качестве дополнительного параметра методам PPObjSCard
	// передается идентификатор серии карточек.
	//
	virtual int    SLAPI Browse(void * extraPtr);
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int    SLAPI DeleteObj(PPID id);
	virtual int    SLAPI Search(PPID id, void * = 0);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*(PPObjSCard::Filt*)*/); // @v9.1.3 cardSerID-->PPObjSCard::Filt
	int    SLAPI IsPacketEq(const PPSCardPacket & rS1, const PPSCardPacket & rS2, long flags);
	//int    SLAPI PutPacket(PPID * pID, SCardTbl::Rec * pPack, int use_ta);
	int    SLAPI PutPacket(PPID * pID, PPSCardPacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPSCardPacket * pPack);
	//
	// Descr: Извлекает запись карты через кэш. Инициируются следующие поля:
	//   SeriesID, PersonID, Flags, Dt, Expiry, PDis, AutoGoodsID, MaxCredit, UsageTmStart, UsageTmEnd
	//
	int    SLAPI Fetch(PPID id, SCardTbl::Rec * pRec);
	//
	// Descr: Извлекает через кэш строку расширения fldId пакета с идентификатором id.
	//
	int    SLAPI FetchExtText(PPID id, int fldId, SString & rBuf);
	int    SLAPI Dirty(PPID id);
	//
	//
	//
	struct UhttEntry {
		char   Code[24];
		LDATETIME ActualDtm;
		char   UhttCode[24];
		char   UhttHash[24];
		double Rest;
	};
	int    SLAPI FetchUhttEntry(const char * pCode, PPObjSCard::UhttEntry * pEntry);

	const PPSCardConfig & SLAPI GetConfig();
	PPID   FASTCALL GetChargeGoodsID(PPID scardID);
	int    SLAPI Edit(PPID * pID, const AddParam & pParam);
	//
	//
	//
	enum {
		edfDisableCode = 0x0001
	};
	//
	// Descr: Вызывает диалог редактирования записи персональной карты.
	//   Никаких изменений в базе данных функция не делает.
	//   Используется как вспомогательный инструмент редактирования параметров карты.
	// Returns:
	//   >0 - пользователь подтвердил изменения в записи.
	//   <0 - пользователь отклонил изменения. Запись pRec точно осталась не изменной.
	//   0  - ошибка. Запись pRec точно осталась не изменной.
	//
	int    SLAPI EditDialog(PPSCardPacket * pPack, long flags);
	//
	// Descr: Открывает диалог ввода номер карты и ищет карту по этому
	//   номеру. Если карта найдена, то открывает диалог редактирования //
	//   найденной карты, в противном случае запрашивает подтверждение на
	//   создание новой карты. Если пользователь отвечает утвердительно,
	//   тогда открывает диалог создания новой карты с предустановленным
	//   введенным номером и параметрами, определяемые аргументом pParam.
	// Returns:
	//   -1 - пользователь отказался от ввода либо от создания карты.
	//   +1 - карта была найдена и пользователь подтвердил редактирование.
	//   +2 - карта не была найдена и пользователь создал новую (ее идентификатор
	//      присваивается по адресу pID).
	//    0 - ошибка.
	//
	int    SLAPI FindAndEdit(PPID * pID, const AddParam * pParam);

	enum {
		cdfCreditCard = 0x0001
	};
	//
	// Descr: Создает новую запись карты.
	// ARG(pID OUT): Указатель, по которому в случае успешного исполнения присваивается идентификаторв
	//   созданной записи.
	// ARG(seriesID IN): Идентификатор серии карты. Если этот параметр нулевой, то новая присваивается //
	//   либо серии PPSCardConfig::DefSerID либо PPSCardConfig::DefCreditSerID в зависимости от
	//   наличия в параметре flags флага PPObjSCard::cdfCreditCard.
	//   При этом, если в конфигурации не определена требуемая серия, то функция завершается ошибкой.
	// ARG(rNumber IN/OUT): Номер новой карты. Если эта строка при вызове функции пуста (либо содержит только
	//   пробелы), то номер новой карты формируется автоматически в соответствии с шаблоном, определенным
	//   в серии, которой будет принадлежать карта. При отсутствии валидного шаблона
	//   функция завершается с ошибкой.
	// ARG(flags IN): Опции создания новой записи (PPObjSCard::cdfXXX).
	// ARG(use_ta IN): Если !0, то фукнция выполняется в собственной транзакции.
	// Returns:
	//   >0 - функция завершилась успешно.
	//   0  - ошибка.
	//
	int    SLAPI Create_(PPID * pID, PPID seriesID, PPID ownerID, const SCardTbl::Rec * pPatternRec, SString & rNumber, long flags, int use_ta);
	int    SLAPI GetListBySubstring(const char * pSubstr, PPID seriesID, StrAssocArray * pList, int fromBegStr);
	//
	// Descr: Возвращает 1 если серия scSerID является серией кредитных карт.
	//   Если объект scSerID не найден или scSerID не является серией кредитных карт,
	//   то возвращает 0.
	//
	int    SLAPI  IsCreditSeries(PPID scSerID);
	static int SLAPI GetSeriesType(PPID scSerID);
	//
	// Возвращает 1 если карта cardID относится к серии кредитных карт.
	// Если объект cardID не найден или карта cardID не относится к серии
	// кредитных карт, то возвращает 0.
	//
	int    SLAPI  IsCreditCard(PPID cardID);
	int    SLAPI  GetCardType(PPID cardID);
	int    SLAPI  GetTransmitPacket(PPID, const LDATETIME *, SCardTransmitPacket *, ObjTransmContext * pCtx);
	int    SLAPI  PutTransmitPacket(PPID *, SCardTransmitPacket *, int update, ObjTransmContext * pCtx, int use_ta);
	int    SLAPI  SearchCode(PPID seriesID, const char * pCode, SCardTbl::Rec *);
	//
	// Descr: Если поле Flags структуры pRec имеет флаг SCRDF_INHERITED, то устанавливает в этой структуре
	//   значения наследуемых полей из записи серии карт. Если указатель на запись серии pSerRec != 0, то наследуемые
	//   поля извлекаются из нее (без оглядки на идентификатор pSerRec->ID), если же pSerRec == 0, то
	//   запись серии извлекается из базы данных (без кэширования).
	//   Запись *pRec изменится после вызова функции только если возращаемое значение >0.
	// Returns:
	//   <0 - либо запись pRec не наследуемая, либо pRec == 0, либо ни одно из наследуемых полей не изменилось.
	//   >0 - запись pRec наследуемая и изменилось по крайней мере одно из наследуемых полей.
	//   0  - ошибка. Если pSerRec == 0 и серия с идентификатором pRec->SeriesID не найдена, то результат также 0.
	//
	//int    SLAPI  SetInheritance(const PPSCardSeries * pSerRec, SCardTbl::Rec * pRec);
	int    SLAPI  SetInheritance(const PPSCardSerPacket * pSerRec, SCardTbl::Rec * pRec);
	int    SLAPI  AutoFill(PPID seriesID, int use_ta);
	int    SLAPI  UpdateBySeries(PPID seriesID, int use_ta);
	// @v9.5.4 int    SLAPI  UpdateBySeriesRule(PPID seriesID, int prevTrnovrPrd, PPLogger * pLog, int use_ta);
	int    SLAPI  UpdateBySeriesRule2(PPID seriesID, int prevTrnovrPrd, PPLogger * pLog, int use_ta);
	int    SLAPI  PutUhttOp(PPID cardID, double amount);
	//
	// Descr: Устанавливает параметры карты в состояние активности: Flags &= ~(SCRDF_CLOSED|SCRDF_NEEDACTIVATION),
	//   Expiry рассчитывает исходя из параметров PeriodTerm и PeriodCount.
	// Returns:
	//   >0 - карта успешно активирована
	//   <0 - карта не требует активации
	//   0  - ошибка
	//
	int    SLAPI  ActivateRec(SCardTbl::Rec * pRec);

	enum {
		gtalgDefault = 0,
		gtalgByCheck,
		gtalgByBill,
		gtalgForBonus,  // Алгоритм для расчета бонусов по картам
		gtalgByOp
	};

	int    SLAPI  GetTurnover(const SCardTbl::Rec & rRec, int alg, const DateRange & rPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	int    SLAPI  GetTurnover(PPID cardID, int alg, const DateRange & rPeriod, PPID restrGoodsGrpID, double * pDebit, double * pCredit);
	//
	// Descr: Ищет карту по владельцу ownerID из которой можно унаследовать величину процентной скидки.
	//
	int    SLAPI  FindDiscountBorrowingCard(PPID ownerID, SCardTbl::Rec * pRec);
	//
	// Descr: Быстро рассчитывает обороты по всем картам, которые использовались
	//   в заданном периоде и заполняет найденными значениями переданный массив.
	//
	int    SLAPI  CreateTurnoverList(const DateRange *, RAssocArray *);
		// @>>CCheckCore::CreateSCardsTurnoverList()
	int    SLAPI Import(int use_ta);
	int    SLAPI SetFlags(PPID id, long flags, int use_ta);
	int    SLAPI CheckUniq();
	//
	// Descr: Флаги функции CheckRestrictions
	//
	enum {
        chkrfIgnoreUsageTime = 0x0001 // Игнорировать допустимое время применения //
	};
	//
	// Descr: Проверяет возможность использования карты для обслуживания.
	// Returns:
	//   0 - карта не может быть применена
	//   1 - карта может быть применена
	//   2 - специальный случай: карта закрыта и требует активации, но в ней установлен признак автоактивации,
	//      то есть, после первой операции по ней она должна быть автоматически активирована.
	//
	int    SLAPI CheckRestrictions(const SCardTbl::Rec * pRec, long flags, LDATETIME dtm);
	int    SLAPI CheckExpiredBillDebt(PPID scardID);
	int    SLAPI FinishSCardUpdNotifyList(const TSArray <SCardCore::UpdateRestNotifyEntry> & rList);
	//
	int    SLAPI IndexPhones(int use_ta);
protected:
	virtual const char * SLAPI GetNamePtr();
	virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	virtual int    SLAPI EditRights(uint bufSize, ObjRights *, EmbedDialog * pDlg = 0);
private:
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int    SLAPI SerializePacket(int dir, SCardTransmitPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI Helper_Edit(PPID * pID, const AddParam * pParam);
	enum {
		clsfStrList = 0x0001, // Возвращает по указателю pList StrAssocArray, иначе - PPIDArray
		clsfFromBeg = 0x0002  // Только карты, начинающиеся с pSubstr
	};
	int    SLAPI Helper_GetListBySubstring(const char * pSubstr, PPID seriesID, void * pList, long flags);
	const  StrAssocArray * SLAPI GetFullList();
	void   SLAPI ReleaseFullList(const StrAssocArray * pList);

	PPObjCSession * P_CsObj;  // Uses for transmission data to another db division
	PPObjLocation LocObj; // @v9.4.7 Из-за внесения собственного номера телефона в атрибуты карты,
		// PPObjLocation понадобится при сохранении пакета для индексации телефонов.
	PPSCardConfig Cfg;
public:
	TLP_MEMB(CCheckCore, P_CcTbl);
public:
	SCardCore * P_Tbl; // Не использует TLP_MEMB поскольку получает этот указатель от P_CcTbl
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewDvcLoadingStat)
//
struct DvcLoadingStatFilt : public PPBaseFilt {
	SLAPI  DvcLoadingStatFilt();

	uint8  ReserveStart[32]; // @anchor
	short  DvcType;          // Тип устройства
	uint16 Reserve2;         // @alignment
	long   DvcID;            // ИД устройства
	DateRange Period;        // Период, за который следует отображать данные
	long   Flags;            // @flags
	PPID   GoodsGrpID;       // Товарная группа
	PPID   GoodsID;          // ИД товара
	long   Reserve;          // @anchor @reserve
};

typedef DvcLoadingStatTbl::Rec DvcLoadingStatViewItem;

class PPViewDvcLoadingStat : public PPView {
public:
	struct BrwHdr {
		long   DlsID;
		short  DvcType;
		long   DvcID;
	};

	SLAPI  PPViewDvcLoadingStat();
	SLAPI ~PPViewDvcLoadingStat();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(DvcLoadingStatViewItem *);
private:
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);

	DvcLoadingStatFilt Filt;
	PPIDArray GGrpList;
	DeviceLoadingStat DlsT;
};
//
// @ModuleDecl(PPViewDLSDetail)
//
struct DLSDetailFilt {
	SLAPI  DLSDetailFilt();
	long   DlsID;
	short  DvcType;
	long   DvcID;
	long   ObjType;
};

class PPViewDLSDetail : public PPView {
public:
	struct BrwHdr {
		long   DlsID;
		short  ObjType;
		long   ObjID;
	};

	SLAPI  PPViewDLSDetail();
	SLAPI ~PPViewDLSDetail();
	int    SLAPI Init(const DLSDetailFilt * pFilt);
private:
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);

	DLSDetailFilt  Filt;
	DlsObjTbl * P_DlsObjTbl;
	PPObjGoods  GObj;
	PPObjSCard  SCObj;
};
//
// @ModuleDecl(AsyncCashSCardsIterator)
//
struct AsyncCashSCardInfo {
	SCardTbl::Rec  Rec;
	int    IsClosed;
	double Rest;         // @v7.4.0 Остаток по кредитной карте
	char   PsnName[128]; // Наименование персоналии-владельца
};

class AsyncCashSCardsIterator {
public:
	SLAPI  AsyncCashSCardsIterator(PPID cashNodeID, int updOnly, DeviceLoadingStat * pDLS, PPID statID);
	SLAPI ~AsyncCashSCardsIterator();
	int    SLAPI Init(PPSCardSerPacket *);
	int    SLAPI Next(AsyncCashSCardInfo *);
	int    SLAPI SetStat();
	const  IterCounter & SLAPI GetCounter() const
	{
		return Counter;
	}
protected:
	PPCashNode NodeRec;
	PPSCardSerPacket ScsPack;
	SCardTbl::Rec Rec;
	PPObjSCard  SCObj;
	PPObjPerson PsnObj;
	int         UpdatedOnly;
	LDATETIME   Since;
	BExtQuery * P_IterQuery;
	DeviceLoadingStat * P_DLS;
	PPIDArray UpdSCardList;    // Список карт, измененых с момента Since
	PPID   StatID;
private:
	PPID   DefSCardPersonID;   // Персоналия, которая по умолчанию является владельцем карт,
		// у которых нет явно заданного владельца. Необходимо для некоторых кассовых модулей, которые
		// требуют владельца для каждой карты либо работают не корректно с картами, не имеющими владельца.
	IterCounter Counter;
	SString DefPersonName;     //
};
//
// @ModuleDecl(PPObjDraftWrOff)
// @prefix=dwo
//
#define DWOF_DFCTARISLOC 0x0001L
#define DWOF_USEMRPTAB   0x0002L // При списании использовать MRP-таблицы

struct PPDraftWrOff2 {     // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_DRAFTWROFF
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[56];    // @reserve
	PPID   PoolOpID;       // Операция формирования пула документов списания //
	long   Flags;          // Флаги DWOF_XXX
	PPID   DfctCompensOpID; // Операция компенсации дефицита
	PPID   DfctCompensArID; // Контрагент в документах компенсации дефицита
};

DECL_REF_REC(PPDraftWrOff);

struct PPDraftWrOffEntry {
	PPID   OpID;
	PPID   LocID;
	long   Reserve[2];
	long   Flags;
};

struct PPDraftWrOffPacket {
	SLAPI  PPDraftWrOffPacket();
	SLAPI ~PPDraftWrOffPacket();
	void   SLAPI Init();
	PPDraftWrOffPacket & FASTCALL operator = (const PPDraftWrOffPacket &);

	PPDraftWrOff Rec;
	SArray * P_List; // <PPDraftWrOffEntry>
};

class PPObjDraftWrOff : public PPObjReference {
public:
	SLAPI  PPObjDraftWrOff(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI Browse(void * extraPtr);

	int    SLAPI PutPacket(PPID * pID, PPDraftWrOffPacket *, int use_ta);
	int    SLAPI GetPacket(PPID id, PPDraftWrOffPacket *);
};
//
// @ModuleDecl(PPObjAdvBillKind)
// @prefix=abk
//
struct PPAdvBillKind2 {    // @persistent @store(Reference2Tbl+)
	enum {
		fSkipAccturn = 0x0001 // Для строки расширенного бух документа с таким видом не проводит бух проводку
	};
	long   Tag;            // Const=PPOBJ_ADVBILLKIND
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	char   Reserve[60];    // @reserve
	long   Flags;          // Флаги PPAdvBillKind::fXXX
	PPID   LinkOpID;       // Операция связанного документа //
	long   Reserve2;       // @reserve
};

DECL_REF_REC(PPAdvBillKind);

class PPObjAdvBillKind : public PPObjReference {
public:
	SLAPI  PPObjAdvBillKind(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
private:
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
};
//
// @ModuleDecl(PPObjProcessor)
//
// Виды записей процессоров
//
#define PPPRCK_GROUP      1 // Группа процессоров
#define PPPRCK_PROCESSOR  2 // Собственно процессор
//
//
//
#define PRCF_INDUCTSUPERSESSTATUS  0x00000001L // Проецировать статусы суперсессий на подчиненные сессии
#define PRCF_STOREGOODSREST        0x00000002L // При закрытии сессий по этому процессору
	// фиксировать остатки товаров на момент закрытия сессии.
	// Остатки фиксируются в таблице TSessLine с признаками Sign=0, Flags|=TSESLF_OUTREST
#define PRCF_PRINTNEWLINE_PANE     0x00000004L // Печатать этикетку для каждой новой строки в панели
#define PRCF_ALTGROUP              0x00000008L // Альтернативная группа процессоров
#define PRCF_DEFSIGN_MINUS         0x00000010L // Знак операции по умолчанию - расход
#define PRCF_DEFSIGN_PLUS          0x00000020L // Знак операции по умолчанию - приход
	// @#{PRCF_DEFSIGN_MINUS^PRCF_DEFSIGN_PLUS}
#define PRCF_ENABLEDUPSERIAL       0x00000040L // Разрешение на ввод в строку сессии строк с одинаковым серийным номером
#define PRCF_ONECLICKTURN_PANE     0x00000080L // Проводить строку сессии в панели процессора сразу после выбора товара
	// (по штрихкоду или серийному номеру). Используется для быстрого ввода в случае, когда не надо явно задавать количество
	// и другие атрибуты строки кроме собственно товара (лота)
#define PRCF_LOCKWROFF             0x00000100L // Сессии по этому процессору не списываются //
#define PRCF_WROFFDT_START         0x00000200L // Дата документа списания - дата начала сессии
	// Если флаг не установлен, то дата конца сессии.
#define PRCF_WROFFDT_BYSUPER       0x00000400L // Дата документа списания определяется датой суперсессии
	// по правилу флага PRCF_WROFFDT_START. Если суперсессии нет, то PRCF_WROFFDT_BYSUPER игнорируется.
#define PRCF_CANSWITCHPAN          0x00000800L // Флаг группы, означающий, что в панели процессора
	// допускается переключение между процессорами этой группы. Область действия этого флага распростаняется //
	// только на процессоры, непосредственно привязанными к этой группе.
#define PRCF_ACCDUPSERIALINSESS    0x00001000L // Принимать две строки сессии с одним серийным номером
#define PRCF_TURNINCOMPLBILL       0x00002000L // Проводить документы по сессиям, даже если есть дефицит
#define PRCF_PASSIVE               0x00004000L // Пассивный процессор (флаг не наследуется от группы)
#define PRCF_ADDEDOBJASAGENT       0x00008000L // Доп объект сессии списывается как агент (только в случае, если
	// доп объект по виду операции не определен).
#define PRCF_CLOSEBYJOBSRV         0x00010000L // Сессия процессора может быть закрыта JobServer'ом
#define PRCF_USETSESSSIMPLEDLG     0x00020000L // Использовать упрощенный диалог редактирования технологической сессии
#define PRCF_NEEDCCHECK            0x00040000L // Тех сессии по процессору требуют кассовый чек (запрет на проведение
	// сессии без чека регламентируется правом доступа по тех сессиям TSESRT_CLOSEWOCC)
#define PRCF_ALLOWCIP              0x00080000L // Тех сессии по процессору позволяют ассоциировать регистрацию персоналий
#define PRCF_AUTOCREATE            0x00100000L // Для групп процессоров. Если процессоры группы ассоциированы с объектами,
	// то при создании нового объекта автоматически создавать и процессор в этой группе, соответствующий новому объекту.
#define PRCF_HASEXT                0x00200000L // @v8.1.6 С процессором связана запись расширения в PropertyTbl
#define PRCF_ALLOWCANCELAFTERCLOSE 0x00400000L // @v8.2.9 Разрешение на перевод сессии в состояние 'ОТМЕНЕНА' из 'ЗАКРЫТА'
//
// Флаг передаваемый с дополнительным параметром, и сигнализирующий о том, что
// речь идет о группе процессоров
//
#define PRCEXDF_GROUP  0x80000000L

struct PPProcessorConfig { // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PRCCFG
	long   TecCounter;     // Счетчик для автоматической нумерации технологий
	long   Flags;          //
	char   Reserve[64];    //
};
//
// Descr: Идентификаторы строк расширения блока PPProcessorPacket::Ext
//
#define PRCEXSTR_DETAILDESCR 1 // Подробное описание процессора (технологической сессии)

class PPProcessorPacket { // @persistent
public:
	PPProcessorPacket();
	PPProcessorPacket & destroy();

	struct PlaceDescription {
		PlaceDescription();
		PlaceDescription & Clear();

		PPID   GoodsID;    // Товар, ассоциированный с диапазоном мест
		SString Range;
		SString Descr;
	};

	class ExtBlock : private SStrGroup { // @persistent
	public:
		ExtBlock();
		ExtBlock & destroy();
		int    IsEmpty() const;
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
		int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
		int    SLAPI PutExtStrData(int fldID, const char * pBuf);
		int    SLAPI Pack();

		uint   SLAPI GetPlaceDescriptionCount() const;
		int    SLAPI GetPlaceDescription(uint pos, PPProcessorPacket::PlaceDescription & rItem) const;
		int    SLAPI GetPlaceDescriptionByCode(const char * pCode, PPProcessorPacket::PlaceDescription & rItem) const;
		int    SLAPI PutPlaceDescription(uint pos, const PPProcessorPacket::PlaceDescription * pItem);

		PPID   SLAPI GetOwnerGuaID() const;
		int    SLAPI SetOwnerGuaID(PPID id);
		long   SLAPI GetCipCancelTimeout() const;
		int    SLAPI SetCipCancelTimeout(long t);
		long   SLAPI GetCipLockTimeout() const;
		int    SLAPI SetCipLockTimeout(long t);

		enum {
			tfCheckInRoundForward   = 0x0001,
			tfCheckOutRoundBackward = 0x0002,
			tfPlusOneDay            = 0x0004
		};
		SVerT Ver;            // Номер версии для обратной совместимости
		LTIME  CheckInTime;
		LTIME  CheckOutTime;
		long   TimeFlags;
		long   InitSessStatus; // @v8.2.9 Статус, с которым создаются новые сессии процессора. 0 - по умолчанию или наследуется от группы.
	private:
		uint   ExtStrP; // Позиция строки расширения в пуле SStrGroup
		struct FlatBlock {
			PPID   OwnerGuaID;       // Глобальная учетная запись, владеющая процессором
			long   CipCancelTimeout; // @v8.8.0 @#{>=0} Таймаут снятия резерва (секунд).
			long   CipLockTimeout;   // @v8.8.1 @#{>=0} Таймаут блокировки резерва за заданное количество секунд до начала сессии
			uint8  FbReserve[20];    // @reserve
		} Fb;                    // @anchor
		struct InnerPlaceDescription {
			PPID   GoodsID;  // Товар, ассоциированный с диапазоном мест
			uint   RangeP;   // Идент строки расширения, определяющий диапазон посадочных мест
			uint   DescrP;   // Идент строки расширения, определяющий описание диапазона мест
		};
		TSArray <InnerPlaceDescription> Places; // @v8.7.0
	};
	ProcessorTbl::Rec Rec;
	ExtBlock Ext;
};
//
//
//
class ProcessorPlaceCodeTemplate {
public:
	static SString & FASTCALL NormalizeCode(SString & rCode);

	ProcessorPlaceCodeTemplate();
	void   Reset();
	int    Parse(const char * pPattern);
	void   Helper_GenerateLevel(int s, const uint32 pCounters[], SString & rBuf) const;
	int    Helper_Generate(int s, int fullRow, uint32 pCounters[], SString & rBuf) const;
	int    Generate(StringSet & rSs) const;
	int    HasCode(const char * pCode) const;
private:
	//
	// D%3[1..90]L%1[A..D]
	// %3[101..500]
	// %1[А..Я]
	//
    // ^.*\%[0-9]+\[.+\.\..+\]
	//
    struct Seq {
    	char   Prefix[8];
    	uint8  Type; // 0 - none, 1 - digit range, 2 - alpha range
    	uint8  Len;  // Длина результата
    	uint16 Reserve;
    	uint32 Start;
    	uint32 End;
    };
    TSArray <Seq> SeqList;
};
//
// @done(@v8.2.3) @dbd_exchange Сделать передачу полного пакета PPProcessorPacket
//
class PPObjProcessor : public PPObject {
public:
	static int SLAPI ReadConfig(PPProcessorConfig *);
	static int SLAPI EditPrcPlaceItem(PPProcessorPacket::PlaceDescription * pItem);

	SLAPI  PPObjProcessor(void * extraPtr = 0);
	SLAPI ~PPObjProcessor();
	virtual int SLAPI Search(PPID, void *);
	//
	// Если *pID == 0 && parentID & PRCEXDF_GROUP, то функция создает новую группу
	//
	virtual int SLAPI Edit(PPID * pID, void * extraPtr /*parentID*/);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI Fetch(PPID id, ProcessorTbl::Rec * pRec);
	//
	// Descr: Ищет запись процессора вида kind с именем pName. Если kind == 0,
	//   то сначала ищет процессор (PPPRCK_PROCESSOR), а затем, если не находит, группу (PPPRCK_GROUP).
	//   Поиск нечувствителен к регистру символов.
	// ARG(kind   IN): Вид записи, которую надо найти. Если kind == 0, то функция будет искать
	//   сначала собственно процессоры с указанным именем, а затем группы процессоров.
	// ARG(pName  IN): Имя записи, которую необходимо найти
	// ARG(pID   OUT): @#{vptr0} По этому указателю функция возвращает ИД записи, если такая найдена.
	//   В противном случае по указателю присваивается 0.
	// ARG(pRec  OUT): @#{vptr0} По этому указателю функция возвращает найденную запись, если такая найдена.
	//   В противном случае содержимое памяти по этому указателю не меняется.
	// Returns:
	//   >0 - искомая запись найдена
	//   <0 - запись с указанным видом и наименованием не найдена
	//   0  - ошибка
	//
	int    SLAPI SearchByName(int kind, const char * pName, PPID * pID, ProcessorTbl::Rec * pRec);
	int    SLAPI SearchByCode(const char * pCode, PPID * pID, ProcessorTbl::Rec * pRec);
	int    SLAPI SearchByLinkObj(PPID objType, PPID objID, PPID * pID, ProcessorTbl::Rec * pRec);
	int    SLAPI SearchAnyRef(PPID objType, PPID objID, PPID * pID);
	// @v8.1.6 int    SLAPI PutPacket(PPID *, ProcessorTbl::Rec *, int use_ta);
	int    SLAPI PutPacket(PPID * pID, PPProcessorPacket * pPack, int use_ta); // @v8.1.6
	int    SLAPI GetPacket(PPID id, PPProcessorPacket * pPack); // @v8.1.6

	int    SLAPI PutExtention(PPID id, PPProcessorPacket::ExtBlock * pExt, int use_ta);
	int    SLAPI GetExtention(PPID id, PPProcessorPacket::ExtBlock * pExt);
	//
	// Descr: Извлекает запись процессора prcID и заполняет
	//   унаследованные от группы поля и флаги.
	// ARG(prcID    IN): ИД процессора
	// ARG(pRec    OUT): @#{vptr0} указатель на буфер, в который будет скопирвана запись процессора
	// ARG(useCache IN): если !0, то запись извлекается из кэша.
	// Returns:
	//   >0 - запись с идентификатором prcID найдена и скопирована в буфер pRec
	//   <0 - запись с идентификатором prcID не найдена
	//   0  - ошибка
	//
	int    SLAPI GetRecWithInheritance(PPID prcID, ProcessorTbl::Rec * pRec, int useCache = 0);
	int    SLAPI GetExtWithInheritance(PPID prcID, PPProcessorPacket::ExtBlock * pExt);
	int    SLAPI GetParentsList(PPID prcID, PPIDArray * pList);
	//
	// Descr: Возвращает список процессоров, дочерних по отношению к prcID.
	//   Идентификатор prcID в список не заносится.
	//   Если recur != 0, то функция рекурсивная: рекурсивный вызов осуществляется //
	//   для каждого дочернего процессора, имеющего вид PPPRCK_GROUP.
	//   Идентификаторы дочерних процессоров добавляются в список pList
	//   методом addUnique, что исключает попадание в него двух одинаковых
	//   идентификаторов в пределах действия этой фукнкции.
	// ARG(prcID  IN): Идентификатор процессора, для которого необходимо найти список
	//   дочерних процессоров
	// ARG(recur  IN): Если recur != 0, то функция рекурсивно вызывает себя для каждого
	//   потомка группы prcID, который сам является группой. В противном случае функци
	//   возвращает только список прямых потомков группы prcID.
	// ARG(pList OUT): @#{vptr0} Указатель на список, в котороый заносятся идентификаторы
	//   дочерних процессоров
	// Returns:
	//   >0 - процессор prcID имеет непустое множество дочерних процессоров
	//   <0 - процессор prcID не имеет дочерних процессоров
	//   0  - ошибка
	//
	int    SLAPI GetChildIDList(PPID prcID, int recur, PPIDArray * pList); // @recursion
	int    SLAPI GetListByOwnerGuaID(PPID guaID, PPIDArray & rList);
	//
	// Descr: Выясняет, принадлежит ли процессор prcID переключаемой группе.
	//   Если да, то возвращает >0 и заполняет список pSwitchPrcList идентификаторами
	//   процессоров на которые может быть сделано переключение. В этот список попадет
	//   и prcID.
	// ARG(prcID           IN): Идентификатор процессора, для которого необходимо выяснить
	//   возможность переключения на другие процессоры.
	// ARG(pSwitchPrcList OUT): @#{vptr0} Указатель на массив, в который, в случае утвердительного
	//   ответа будут занесены идентификаторы процессоров между которыми может быть осуществлено
	//   переключение.
	// Returns:
	//   >0 - процессор prcID допускает переключение
	//   <0 - процессор prcID не допускает переключения //
	//   0  - ошибка
	//
	int    SLAPI IsSwitchable(PPID prcID, PPIDArray * pSwitchPrcList);
private:
	virtual const char * SLAPI GetNamePtr();
	virtual int SLAPI DeleteObj(PPID);
	virtual int SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*parentID*/);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);

	int    SLAPI SerializePacket(int dir, PPProcessorPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    AddListItem(StrAssocArray * pList, ProcessorTbl::Rec * pRec, PPIDArray * pRecurTrace);
		// @recursion @<<PPObjProcessor::MakeStrAssocList(PPID)
public:
	TLP_MEMB(ProcessorTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewProcessor)
//
struct ProcessorFilt : public PPBaseFilt {
	SLAPI  ProcessorFilt();
	virtual int SLAPI Init(int fullyDestroy, long extraData);

	char   ReserveStart[24]; // @anchor
	long   Flags;
	PPID   OwnerGuaID;       // Глобальная учетная запись - владелец процессора
	long   Kind;             // PPPRCK_XXX
	PPID   ParentID;
	PPID   LocID;            //
	long   Reserve;          // @anchor Заглулшка для отмера "плоского" участка фильтра
};

typedef ProcessorTbl::Rec ProcessorViewItem;

class PPViewProcessor : public PPView {
public:
	SLAPI  PPViewProcessor();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ProcessorViewItem *);
	int    SLAPI Transmit(PPID /*id*/);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * SLAPI GetEditExtraParam();
	virtual int  SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI ExportUhtt();

	ProcessorFilt Filt;
	PPObjProcessor PrcObj;
};
//
// @ModuleDecl(PPObjTech)
//

//
// Descr: Класс, управляющий списком товаров, которые могут быть обработаны технологической
//   сессией, использующей заданную технологию.
//
class TGSArray : private SArray { // @defined(Tech.cpp)
public:
	SLAPI  TGSArray();
	uint   SLAPI GetItemsCount() const;
	int    SLAPI SearchGoods(PPID goodsID, int * pSign) const;
	int    SLAPI GetGoodsList(PPIDArray * pList) const;
	int    SLAPI AddItem(PPID goodsID, int sign);
	void   SLAPI Destroy();
private:
	struct Item {
		PPID   GoodsID;
		int16  Sign;
	};
};
// Флаги, передаваемые с дополнительным параметром
//
#define TECEXDF_GOODS   0x80000000L // Остальная часть параметра - ИД товара
#define TECEXDF_GSTRUC  0x40000000L // Остальная часть параметра - ИД структуры
	// Если ни один из вышеперечисленных флагов не выставлен, то параметр - ИД процессора
#define TECEXDF_TOOLING 0x20000000L // Речь идет о записи технологии перенастройки
#define TECEXDF_AUTO    0x10000000L // Речь идет о записи автотехнологии
#define TECEXDF_PARENT  0x08000000L // @v7.5.6 Остальная часть параметра - ИД родительской технологии
#define TECEXDF_MASK    0x07ffffffL
//
// Флаги технологий
//
#define TECF_RECOMPLMAINGOODS 0x0001 // Рекомплектация основного товара.
	// Этот флаг работает если операция списания по процессору, к которому относится //
	// технология, является модификацией, и выход основного товара задан по серийному номеру.
	// В этом случае система следит за тем, чтобы в одну сессию не попало более одного
	// серийного номера основного товара со знаком +.
#define TECF_EXTSTRING        0x0002 // Технология содержит строку расширения //
#define TECF_CALCTIMEBYROWS   0x0004 // Для каждой строки сессии извлекается доступная технология //
	// для процессора и время выполнения количества, заданного по строке прибавляется к планируемому времени
	// сессии
#define TECF_AUTOMAIN         0x0008 // Основной товар автоматически вставляется в строки сессии
#define TECF_ABSCAPACITYTIME  0x0010 // Производительность определяет абсолютное время работы процессора
	// (не зависимо от количества обоабатываемой позиции).
//
//
//
#define TECEXSTR_TLNGCOND   1 // Формула условия использования технологии перенастройки //
#define TECEXSTR_CAPACITY   2 // Формула производительности для автотехнологий

struct PPTechPacket {
	SLAPI  PPTechPacket();
	TechTbl::Rec Rec;
	SString ExtString;
};

class PPObjTech : public PPObject {
public:
	static int   SLAPI GenerateCode(int kind, SString & rBuf, int use_ta = 1);
	static int   SLAPI SetupCombo(TDialog *, uint ctlID, PPID id, long flags, PPID prcID, PPID goodsID);

	SLAPI  PPObjTech(void * extraPtr = 0);
	SLAPI ~PPObjTech();
	virtual int SLAPI Search(PPID, void *);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr /*parentID*/);
	virtual int SLAPI Browse(void * extraPtr);
	int    SLAPI InitPacket(PPTechPacket *, long extraData, int use_ta);
	int    SLAPI Fetch(PPID id, TechTbl::Rec * pRec);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI SearchByCode(const char * pCode, TechTbl::Rec * pRec);
	int    SLAPI SearchAnalog(const TechTbl::Rec & rKey, PPID * pID, TechTbl::Rec * pRec);
	int    SLAPI GetPacket(PPID, PPTechPacket *);
	int    SLAPI PutPacket(PPID *, PPTechPacket *, int use_ta);
	int    SLAPI EditDialog(PPTechPacket * pPack);
	int    SLAPI GetGoodsStruc(PPID id, PPGoodsStruc * pGs); // @>>PPObjGoodsStruc::Get
	int    SLAPI GetGoodsStrucList(PPID id, int useSubst, TGSArray * pList); // @<<PPObjTech::GetGoodsStruc
	int    SLAPI GetGoodsListByPrc(PPID prcID, PPIDArray * pList);
		// @>>PPObjTech::AddItemsToList
	int    SLAPI GetListByPrcGoods(PPID prcID, PPID goodsID, PPIDArray * pList);
	int    SLAPI GetToolingCondition(PPID id, SString & rFormula);
	int    SLAPI SelectTooling(PPID prcID, PPID goodsID, PPID prevGoodsID, TSArray <TechTbl::Rec> * pList);
	int    SLAPI CreateAutoTech(PPID prcID, PPID goodsID, PPID * pTechID, int use_ta);
	int    SLAPI SearchAutoForGoodsCreation(PPID prcID, PPID * pGoodsGrpID);
	int    SLAPI ChangeOrderN(PPID techID, int sow, int use_ta);
	//
	// Descr: Возвращает список технологий, прямым родителем для которых является технология techID.
	//
	int    SLAPI GetChildList(PPID techID, PPIDArray & rList);
	int    SLAPI GetNextSibling(PPID parentID, PPID siblingID, TechTbl::Rec * pNextRec);
private:
	virtual const char * SLAPI GetNamePtr();
	virtual int SLAPI DeleteObj(PPID);
	virtual int SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	int     SLAPI SerializePacket(int dir, PPTechPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int     SLAPI Helper_AddItemToList(StrAssocArray * pList, PPID techID, PPID parentID, const char * pCode);
	int     SLAPI AddItemsToList(StrAssocArray *, PPIDArray * pIdList, PPIDArray * pGoodsIdList, long extraParam, PPID goodsID = 0);
		// @<<PPObjTech::MakeList_
	int    SLAPI SearchAuto(PPID prcID, PPID goodsID, PPID * pTechID);
public:
	TLP_MEMB(TechTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewTech)
//
struct TechFilt : public PPBaseFilt {
	enum {
		signAll = 0,
		signMinusOnly,
		signPlusOnly,
		signUsageOnly
	};
	SLAPI  TechFilt();

	char   ReserveStart[32]; // @anchor
	PPID   ParentID;
	PPID   PrcID;
	PPID   GoodsID;
	PPID   GStrucID;
	long   Kind;
	long   Sign;             // TechFilt::signXXX
	long   Flags;            // TechFilt::fXXX
	long   Reserve;          // @anchor
};

typedef TechTbl::Rec TechViewItem;

class PPViewTech : public PPView {
public:
	SLAPI  PPViewTech();
	const  TechFilt * SLAPI GetFilt() const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(TechViewItem *);
	//int    SLAPI ChangeFilt(int refreshOnly, BrowserWindow * pW);
	int    SLAPI Transmit(PPID /*id*/);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * SLAPI GetEditExtraParam();

	TechFilt Filt;
	PPObjTech TecObj;
	PPObjProcessor PrcObj;
	PPObjGoods GObj;
};
//
// @ModuleDecl(PPObjTSession)
//
class  BhtTSess;
//
// Descr: Список процессоров (групп процессоров) ранжированных в том порядке, в котором должно
//   быть реализовано списание технологических сессий по этим процессорам.
// Storage: DB/Property(PPOBJ_TSESSION, 0, TSESPRP_WROFFORDER)
//
class TSessWrOffOrder : public ObjRestrictArray { // @persistent
public:
	SLAPI  TSessWrOffOrder();
	TSessWrOffOrder & FASTCALL operator = (const TSessWrOffOrder &);
	//
	// Descr: Упорядочивает список сессий pSrcList в соответствии с порядком списания //
	// Returns:
	//   >0 - список pDestList явялется упорядоченной версией списка pSrcList. Причем
	//      pDestList отличается от pSrcList
	//   <0 - список pDestList не отличается от списка pSrcList
	//   0  - ошибка
	//
	int    SLAPI ArrangeTSessList(const PPIDArray * pSrcList, PPIDArray * pDestList) const;

	int    IsLoaded;
private:
	struct ArrngItem {
		PPID   SessID;
		PPID   PrcID;
		LDATE  Dt;
	};
	int    SLAPI GetPos(PPObjProcessor * pPrcObj, PPID prcID, uint * pPos) const;
	int    SLAPI CompareProcessors(PPObjProcessor * pPrcObj, PPID prc1ID, PPID prc2ID) const;
	void   SLAPI ShortSort(SArray * pPrcList) const;
};

struct PPTSessConfig {     // @persistent @store(PropertyTbl)
	SLAPI  PPTSessConfig();
	DECL_INVARIANT_C();

	enum {
		fUpdateTimeOnStatus = 0x0001, // При изменении статуса сессии на TSESST_INPROCESS или TSESST_CLOSED
			// изменять дату и время, соответственно, начала и конца сессии на текущую
		fUsePricing                  = 0x0002, // Использовать цены в техн сессиях
		fAllowLinesInPendingSessions = 0x0004, // Разрешать ввод строк в ожидающих сесси
			// (TSESST_PLANNED, TSESST_PENDING)
		fAllowLinesInWrOffSessions   = 0x0008, // Разрешать ввод строк в списанных сессиях
		fSnapInTimeChunkBrowser      = 0x0010, // Во временной диаграмме при щелчке мышью время //
			// отмерять с округлением до ближайшего кванта
		fUpdLinesByAutocompl         = 0x0020, // @v8.8.6 При автозаполнении строк сессии по структуре
			// изменять количество в строках, которые были введены в ручную
		fFreeGoodsSelection          = 0x0040  // @v9.3.4 Свободный выбор товаров в строках сессии
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_TSESSCFG
	long   Flags;           // PPTSessConfig::fXXX
	PPID   IdleAccSheetID;  // ->Ref(PPOBJ_ACCSHEET) Таблица статей видов простоев процессоров
	long   MinIdleCont;     // Минимальная продолжительность простоя (sec). Если простой меньше,
		// этой величины, то он не регистрируется (сессия простоя удаляется).
	LTIME  InitTime;        // Время, задаваемое в новых техн сессиях по умолчанию. Используется //
		// также как расчетное время для сессий, учитывающих товар по времени (гостиницы)
	long   RoundPeriod;     // Период округления (в большую сторону) для сессий, учитывающих
		// товар по времени
	long   ViewRefreshPeriod;     // Период обновления таблиц техн сессий и строк техн сессий (sec)
	long   TimeChunkBrowserQuant; // Квант времени (сек) во временной диаграмме
	long   ColorPlannedStatus;
	long   ColorPendingStatus;
	long   ColorInProgressStatus;
	long   ColorClosedStatus;
	long   ColorCanceledStatus;
	SVerT Ver;
	PPID   DefTimeTechID;      // @v8.7.6 Технология по умолчанию для повременных сессий
	char   Reserve[16];        // @vmiller [24] --> [20]
	PPAutoSmsConfig SmsConfig; // @vmiller
};

//
// Виды технологических сессий
//
#define TSESK_SESSION   0 // Обыкновенная техн сессия  //
#define TSESK_SUPERSESS 1 // Суперсессия               //
#define TSESK_PLAN      2 // Производственный план     //
#define TSESK_IDLE      3 // Сессия простоя процессора //
#define TSESK_SUBSESS   4 // Сессия, являющаяся дочерней по отношению к обыкновенной сессии A по причине,
	// принадлежности к технологии, дочерней, по отношению к технологии, с которой связана сессия A.
//
// Статусы технологических сессий
//
#define TSESST_PLANNED         1  // Планируемая //
#define TSESST_PENDING         2  // В ожидании  //
#define TSESST_INPROCESS       3  // В работе    //
#define TSESST_CLOSED          4  // Закрытая    //
#define TSESST_CANCELED        5  // Отмененная  //
//
// Флаги технологических сессий
//
#define TSESF_WRITEDOFF    0x0001L // Сессия списана
#define TSESF_SUPERSESS    0x0002L // Суперсессия (объединяет несколько обыкновенных сессий)
#define TSESF_IDLE         0x0004L // Простой процессора
#define TSESF_PLAN         0x0008L // Произодственный план
	// 		Система следит за недопущением пересечений сессий производственных планов для одного
	// процессора (группы процессоров), однако пересечения производственных планов с обычными
	// сессиями и сессиями простоев естественны.
	// 		Производственный план не обязан быть привязан к технологии. С другой стороны, привязка к
	// виртуальной технологии, обеспечивающей список позиций, допустима и, вероятно, полезна.
	// 		Производственные планы задаются с точностью до дня, по этому, поля времени начала и
	// окончания в диалоге плана опускаются.
#define TSESF_PLAN_PHUNIT  0x0010L // Производственный план в физических единицах
	// Если этот флаг установлен, то новая строка по умолчанию получает признак TSESLF_PLAN_PHUNIT.
	// Пользоватлеь может переопределить этот признак для строки.
#define TSESF_SUBSESS      0x0020L // @v7.5.7
#define TSESF_HASIMAGES    0x0040L // @v8.7.6 Сессия имеет по крайней мере одно прикрепленное изображение
#define TSESF_CIPREGLOCKED 0x0080L // @v8.8.2 Резервирование персональных регистраций блокировано
//
// Флаги строк технологических сессий
//
#define TSESLF_AUTOCOMPL   0x0001L // Строка сформирована автоматически процедурой PPObjTSession::Complete
#define TSESLF_OUTREST     0x0002L // Строка исходящих остатков по сессии
#define TSESLF_FIXEDREST   0x0004L // Пользователь зафиксировал значение остатка по товару
	// (автоматическое изменение недопустимо)
#define TSESLF_AUTOMAIN    0x0008L // Строка сформирована автоматически по основному товару сессии,
	// единица измерения которого является производной от секунды.
	// @v6.4.4 Либо по основному товару, если технология предусматривает его автоматическую вставку в строки.
#define TSESLF_EXPANDSESS  0x0010L // @transient Функция PPObjTSession::PutLine должна изменить время //
	// окончания сессии, если оно меньше времени, которым помечена строка. При этом время строки становится   //
	// временем окончания сессии.
#define TSESLF_REST        0x0020L // Строка остатка серийного номера по сессии. Используется в том случае,
	// если в процессе производства удобнее посчитать остаток некоторой позиции, чем фактически израсходованное
	// количество. При вводе строки остатка система проверяет, чтобы в течении сессии был расход указанного
	// серийного номера. Если так, то одновременно с вводом этой строки, из строки, с указанным серийным номером
	// вычитается количество остатка. При этом возможность модификации основной строки блокируется.
#define TSESLF_INDEPPHQTTY 0x0040L // Строка учитывает физическое количество товара независимо от
	// торгового. Этот флаг устанавливается функцией PPObjTSession::SetupLineGoods в соответствии с флагом GF_USEINDEPWT
#define TSESLF_RECOMPL     0x0080L // Строка с основным товаром технологии, подлежащая рекомплектации
	// при списании. Этот флаг предполагает, что в строке установлен серийный номер, товар является основным
	// товаром технологии и знак операции +.
#define TSESLF_PLAN_PHUNIT 0x0100L // Производственный план в физических единицах
#define TSESLF_TOOLING     0x0200L // Флаг используется в комбинации с TSESLF_AUTOCOMPL. Если установлен, то
	// строка сформирована автоматически как издержки на перенастройку.
//
// Допустимые переходы состояний сессий:
// Проверку допустимости переходов реализует функция PPObjTSession::SetSessionState()
//
// 0 -> TSESST_PLANNED
// 0 -> TSESST_PENDING
// 0 -> TSESST_INPROCESS
//
// TSESST_PLANNED -> TSESST_PENDING
// TSESST_PLANNED -> TSESST_INPROCESS   Устанавливается время начала сессии
// TSESST_PLANNED -> TSESST_CANCELED
//
// TSESST_PENDING -> TSESST_INPROCESS   Устанавливается время начала сессии
// TSESST_PENDING -> TSESST_CANCELED
//
// TSESST_INPROCESS -> TSESST_CLOSED    Устанавливается время окончания сессии и уровень завершенности в 10
//
// TSESST_CLOSED   переходы недопустимы
// TSESST_CANCELED переходы недопустимы
//
//
// Специфические флаги доступа PPObjTSession (в дополнение к общим PPR_XXX)
//
#define TSESRT_ADDLINE       0x0100 // Добавление строк сессий (в панели процессора не действует)
#define TSESRT_MODLINE       0x0200 // Изменение строк сессий
#define TSESRT_DELLINE       0x0400 // Удаление строк сессий
#define TSESRT_MODPRICE      0x0800 // Изменение цены (скидки) в строке сессии
#define TSESRT_CLOSEWOCC     0x1000 // @v7.6.2 Закрытие тех сессии без кассового чека
//
// Descr: Запись BHT-терминала, для учета операций по техн сессиям
//   Используется функцией PPObjTSession::ProcessBhtRec
//
struct BhtTSessRec {
	char   BillCode[16];
	char   PrcCode[16];
	char   ArCode[16];
	char   Barcode[32];
	double Qtty;
	LDATETIME Dtm;
};
//
//
//
class TSessionPacket {
public:
	SLAPI  TSessionPacket();
	void   SLAPI destroy();

	enum {
		fLinesInited = 0x0001 // Пакет содержит валидный список строк Lines. Как правило, управление строками
			// отделено от управления заголовочной записью. Но при сериализации для обмена между разделами
			// пакет содержит полный список строк.
	};
	long   Flags;
	TSessionTbl::Rec Rec;
	PPCheckInPersonArray CiList;
	TSArray <TSessLineTbl::Rec> Lines;
	ObjTagList TagL;        // @v8.7.4  Список тегов
	ObjLinkFiles LinkFiles; // @v8.7.6
	PPProcessorPacket::ExtBlock Ext; // @v8.8.0 Некоторые параметры процессора могут быть переопределены в этом блоке.
		// Кроме того, здесь же хранится подробное описание сессии.
};
//
//
//
class PPObjTSession : public PPObject {
public:
	struct SelFilt {
		PPID   SuperSessID;
		PPID   PrcID;
		int    Kind; // TSESK_XXX (0 - any sessions, 1 - super sessions only, 2 - plans, 3 - idle)
	};
	static int  SLAPI ReadConfig(PPTSessConfig *);
	static int  SLAPI WriteConfig(PPTSessConfig *, int use_ta); // @vmiller
	static int  SLAPI EditConfig();
	static int  FASTCALL ValidateStatus(int status);
	static int  FASTCALL ResolveStatusSymbol(const char *);
	static int  FASTCALL GetStatusSymbol(int status, SString & rBuf);
	//
	// Descr: Возвращает вид сессии pRec.
	//   Возвращаемое значение - одно из TSESK_XXX.
	//   Если superSessAsSimple, то для суперсессий возвращет TSESK_SESSION
	//
	static int     FASTCALL GetSessionKind(const TSessionTbl::Rec & rRec, int superSessAsSimple = 1);
	static void  * SLAPI MakeExtraParam(PPID superSessID, PPID prcID, int kind);
	static int     SLAPI ConvertExtraParam(void * extraPtr, SelFilt * pFilt);
	//
	// Descr: Возвращает продолжительность сессии pRec в секундах.
	//   Если дата начала или конца сессии являются нулевыми, то возвращает 0.
	//
	static long SLAPI GetContinuation(const TSessionTbl::Rec * pRec);
	//
	// Descr: Определяет, является сессия pRec незначительным простоем. Если сессия //
	//   является сессией простоя, ее длительнось определена и меньше или равна минимальной
	//   продолжительности простоя, определенной в конфигурации, то возвращает >0.
	//   В противном случае, возвращает 0.
	//
	static int  SLAPI IsIdleInsignificant(const TSessionTbl::Rec * pRec, int prevStatus);
	//
	// Descr: Реализует полный цикл редактирования порядка списания технологических сессий.
	//   То есть, 1. создает объект TSessWrOffOrder; 2. извлекает его из базы данных;
	//   3. вызывает диалог редактирования; 4. если пользователь подтвердил редактирование,
	//   то сохраняет объект TSessWrOffOrder в базе данных.
	// Returns:
	//   >0 - пользователь подтвердил редактирование порядка списания техн сессий
	//   <0 - пользователь отказался от редактирования //
	//   0  - ошибка
	//
	static int  SLAPI EditWrOffOrder(); // @<<(cmd)cmTSessWrOffOrder

	SLAPI  PPObjTSession(void * extraPtr = 0);
	SLAPI ~PPObjTSession();
	virtual int SLAPI Search(PPID id, void *);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI RemoveObjV(PPID id, ObjCollection * pObjColl, uint options, void * pExtraParam);
	virtual int SLAPI Browse(void * extraPtr);
	virtual int SLAPI EditRights(uint bufSize, ObjRights * pRt, EmbedDialog * pDlg);
	const  PPTSessConfig & SLAPI GetConfig();
	int    SLAPI SearchAnalog(const TSessionTbl::Rec & rKey, PPID * pID, TSessionTbl::Rec * pRec);
	int    SLAPI SearchByGuid(const S_GUID & rUuid, TSessionTbl::Rec * pRec);
	//
	// Descr: Ищет сессию, закончившуюся непосредственно перед rSessRec.ID
	//
	int    SLAPI GetPrevSession(const TSessionTbl::Rec & rSessRec, TSessionTbl::Rec * pPrevRec);
	int    SLAPI SearchByLinkBillID(PPID linkBillID, TSessionTbl::Rec * pRec);
	int    SLAPI CheckForFilt(const TSessionFilt * pFilt, PPID id, const TSessionTbl::Rec * pRec);
	int    SLAPI GetTech(PPID tecID, TechTbl::Rec *, int useCache = 0); // @>>PPObjTech::Search
	int    SLAPI GetTechByGoods(PPID goodsID, PPID prcID, TechTbl::Rec * pTechRec);
	//
	// Descr: Возвращает !0 если технология pTechRec является повременной, то есть
	//   единица измерения товара, соответствующего сессии имеет базой секунду.
	//   Если технология повременная, то по указателю pBaseRatio возвращается //
	//   значение коэффициента пересчета секунд в единицу измерения товара (напр. 60 для минут).
	// Returns:
	//   >0 - технология повременная.
	//   <0 - технология не является повременной.
	//   0  - ошибка (если не найден товар, соответствующий технологии либо не найдена единица
	//     измерения, соответствующая товару).
	//
	int    SLAPI IsTimingTech(const TechTbl::Rec * pTechRec, double * pBaseRatio);
	int    SLAPI AdjustTiming(const TSessionTbl::Rec & rSessRec, const STimeChunk & rChunk, STimeChunk & rResult, long * pTiming);
	int    SLAPI GetPrc(PPID prcID, ProcessorTbl::Rec *, int withInheritance, int useCache = 0);
	int    SLAPI GetPrcByCode(const char * pPrcCode, ProcessorTbl::Rec *);
	int    SLAPI IsPrcSwitchable(PPID prcID, PPIDArray * pSwitchPrcList);
	int    SLAPI GetStatusText(int statusId, SString & rBuf) const;
	int    SLAPI MakeName(const TSessionTbl::Rec * pRec, SString & rName);
	SString & SLAPI MakeListName(const PPIDArray * pList, SString & rBuf);
	int    SLAPI SetSessionState(TSessionTbl::Rec *, int newState, int checkOnly);
		// @>>PPObjTSession::Helper_SetSessionState
	//
	// Descr: Рассчитывает плановое время выполнения сессии исходя из значения //
	//   pRec->PlannedQtty и технологии (pRec->TechID). Рассчитанное время заносится в
	//   поле pRec->PlannedTiming.
	//   Если технология предполагает аддитивность планового времени строк сессии (TECF_CALCTIMEBYROWS),
	//   то для каждой строки сессии функция пытается вычислить ожидаемое время выполнения //
	//   (исходя из первой найденной технологии, соответствующей процессору pRec->PrcID и товару,
	//   к которому привязана строка).
	//
	int    SLAPI SetPlannedTiming(TSessionTbl::Rec * pRec);
	int    SLAPI CalcPlannedTiming(PPID techID, double qtty, int useRounding, long * pTiming);
	int    SLAPI CalcToolingTiming(const TSessionTbl::Rec * pRec, long * pTiming);
	// @v8.1.6 int    SLAPI CalcPlannedQtty(PPID techID, long timing, double * pQtty);
	int    SLAPI CalcPlannedQtty(const TSessionTbl::Rec * pPack, long forceTiming, double * pQtty); // @v8.1.6
	int    SLAPI RoundTiming(PPID techID, long * pTiming);
	int    SLAPI SetSCardID(TSessionTbl::Rec * pRec, const SCardTbl::Rec * pSCardRec);
	int    SLAPI InitRec(TSessionTbl::Rec *, int kind /* TSESK_XXX */, PPID prcID, PPID superSessID, int status = -1);
	int    SLAPI InitPacket(TSessionPacket *, int kind /* TSESK_XXX */, PPID prcID, PPID superSessID, int status = -1);
	//
	// Descr: Опции функции PPObjTSession::NormalizePacket
	//
	enum {
		npoDBX = 0x0001 // Нормализация для передачи между резделами.
	};
	//
	// Descr: Гарантированно нормализует некоторые избыточные компоненты пакета.
	//
	int    SLAPI NormalizePacket(TSessionPacket * pPack, long options);
	int    SLAPI Add(PPID * pID, PPID superSessID, PPID prcID, int kind, int status = 0);
	//
	// Descr: Инициализирует строку техн сессии
	//   Прежде всего, находит техн сессию sessID. Если сессия найдена, то
	//   устанавливает следующие поля: TSessID, UserID, Dt, Tm.
	//   Если сессия не найдена, то возвращает полностью обнуленную запись.
	// Returns:
	//   >0 - сессия sessID найдена, поля - инициализированы
	//   <0 - сессия sessID не найдена. Запись полностью состоит из нулей.
	//
	int    SLAPI InitLinePacket(TSessLineTbl::Rec *, PPID sessID);
	int    SLAPI PutLine(PPID sessID, long * pOprNo, TSessLineTbl::Rec * pLineRec, int use_ta);
	int    SLAPI Correct(PPID sessID, int use_ta);
	//
	// Descr: добавляет в сессию sessID строки, соответствующие товарам, для которых в структуре
	//   основного товара сессии установлен признак GSF_AUTOWROFF. Строка добавляется только в том случае,
	//   если в сессии не обнаружено ни одной строки, содержащей этот товар
	//   (не применяется учет этого товара по факту и не была применена эта функция ранее).
	//   Строки, добавленные этой функцией получают признак TSESLF_AUTOCOMPL.
	//   Количество рассчитывается исходя из общего количества овновного товара, использованного в сессии.
	//   Перед вставкой новых строк удаляются все строки, имеющие флаг TSESLF_AUTOCOMPL.
	//   Если sessID является суперсессией, то рекурсивно вызывает себя для каждой дочерней сессии.
	// Returns:
	//   <0 - не было добавлено ни одной новой строки
	//   >0 - была добавлена по крайней мере одна строка
	//   0  - ошибка
	// @nointeract
	//
	int    SLAPI Complete(PPID sessID, int use_ta);
	//
	// Descr: Заменяет товар replacedGoodsID в приходных строках сессии sessID на товар substGoodsID.
	//   Замещаются только строки, имеющие знак +1 (Sign == 1)
	// ARG(sessID          IN): Идентификатор сессии, в строках которой необходимо заменить товар
	// ARG(replacedGoodsID IN): ИД товара, который будет замещаться функцией
	// ARG(substGoodsID    IN): ИД товара, который встанет на место replacedGoodsID в соответствующих строках сессии
	// ARG(flags           IN):
	//   0x0001 - ничего не менять, но лишь вернуть значение, соответствующее спецификации. Этот флаг
	//     используется для того, чтобы определить необходимость вызова этой функции с целью настоящей замены.
	// ARG(use_ta          IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 - функция изменила как минимум одну строку сессии sessID. Если flags & 0x0001, то ничего не изменилось,
	//        однако, есть строки, которые следует изменить.
	//   <0 - функция отработала без ошибок, но ни одной приходной строки с товаром replacedGoodsID не обнаружила.
	//      Соответственно ничего не изменилось.
	//   0  - ошибка
	//
	int    SLAPI ReplaceGoodsInLines(PPID sessID, PPID replacedGoodsID, PPID substGoodsID, long flags, int use_ta);
	int    SLAPI IsProcessorBusy(PPID prcID, PPID tsesID, int kind, const LDATETIME & dtm, long cont, PPID * pTSessID);
	//
	// Descr: Проверяет возможность переноса сессии с процессора pRec->PrcID на newPrcID.
	//   Проверяет только совместимость технологии. Не проверяет доступность процессора newPrcID
	//   по времени (для этого следует использовать функцию PPObjTSession::CheckSessionTime()
	// Returns:
	//   >0 - сессию можно перенести на процессор newPrcID
	//   <0 - сессия не межет быть перенесена на процессор newPrcID
	//   0  - ошибка
	//
	int    SLAPI CheckNewPrc(const TSessionTbl::Rec * pRec, PPID newPrcID);
	int    FASTCALL CheckSessionTime(const TSessionTbl::Rec & rRec);
	//
	// Descr: проверяет, нет ли работающих сессий на процессоре prcID. Если да,
	//   то инициализирует код ошибки PPERR_PRCISBUSY.
	// ARG(prcID     IN): ИД процессора, для которого необходимо выяснить факт занятости
	// ARG(kind      IN): @#{TSESK_SESSION | TSESK_PLAN | TSESK_IDLE}
	//   Параметр, определяющий вид работающей сессии, которую надо проверить.
	//   Обычные сессии могут пересекаться с простоями и сессиями плана.
	// ARG(pSessRec OUT): @#{vptr0} Если для процессора существует сессия со статусом TSESST_INPROCESS
	//   то по этому указателю копируется запись этой сессии. В противном случае состояние памяти по
	//   этому указателю остается неизменным.
	// Returns:
	//   >0 - на процессоре выполняется сессия //
	//   <0 - на процессоре нет выполняемых сессий
	//    0 - ошибка
	//
	int    SLAPI IsProcessorInProcess(PPID prcID, int kind, TSessionTbl::Rec * pSessRec);
	int    SLAPI GetCode(const TSessionTbl::Rec *, long flags, char * pBuf, size_t bufLen);
	int    SLAPI GetCode(PPID sessID, long flags, char * pBuf, size_t bufLen);
		// @>>PPObjTSession::GetCode(const TSessionTbl::Rec *, long, char*, bufLen)
	//
	// Descr: Проверяет запись pRec на возможность присваивания ее суперсесси superSessID
	//   Проверяются следующие условия:
	//   1. Суперсессию нельзя делать дочерней сессей (присваивать ей ссылку на суперсессию)
	//      PPERR_CHILDCANTBESUPERSESS
	//   2. Нельзя переприсваивать закрытую или отмененную сессию другой суперсессии
	//      PPERR_INVCHILDTSESSSTATUS
	//   3. Запись по идентификатору superSessID должна существовать
	//   4. Запись суперсессии должна иметь признак TSESF_SUPERSESS
	//      PPERR_PARENTISNTSUPERSESS
	//   5. Закрытой или отмененной суперсессии нельзя присваивать дочернюю сессию
	//      PPERR_INVSUPERSESSSTATUS
	//   6. Суперсессия должна быть привязана либо к тому же процессору, что и
	//      проверяемая сессия, либо процессор суперсессии должен быть группой, к которой
	//      принадлежит процессор проверяемой сессии.
	//      PPERR_INCOMPSUPERSESSPRC
	//   7. Время начала дочерней сессии должно быть больше или равно времени начала суперсессии
	//      PPERR_CHILDOLDERSUPERSESS
	// ARG(pRec           IN): указатель на проверяемую запись
	// ARG(superSessID    IN): ИД суперсессии, которой предполагается присвоить запись pRec
	// ARG(pSuperSessRec OUT): @#{vptr0} указатель на буфер, в который будет скопирована запись суперсессии
	//   Копирование осуществляется сразу после успешного нахождения записи
	//   по идентификатору superSessID независимо от дальнейших проверок.
	// Returns:
	//   !0 - все проверки завершились успешно или superSessID == 0
	//   0  - ошибка
	//
	int    SLAPI CheckSuperSessLink(const TSessionTbl::Rec * pRec, PPID superSessID, TSessionTbl::Rec * pSuperSessRec);
	//
	// Descr: проецирует некоторые параметры суперсессии на запись сессии pRec,
	//   если поле pRec->ParentID != 0. Проецируются следующие параметры: StDt, StTm, ArID
	// Returns:
	//   >0 - запись pRec была изменена (спроецировался один или более параметров)
	//   -1 - запись pRec относится к суперсессии, но ни один из параметров спроецирован не был
	//   -2 - запись pRec не содержит ссылки на суперсессию
	//
	int    SLAPI InductSuperSess(TSessionTbl::Rec * pRec);
	//
	// Descr: инициализирует поле GoodsID строки техн сессии.
	//   Пытается определить знак операции и, если операция выхода, то
	//   присваивает строке уникальный серийный номер.
	//
	int    SLAPI SetupLineGoods(TSessLineTbl::Rec *, PPID goodsID, const char * pSerial, long);
	int    SLAPI GenerateSerial(TSessLineTbl::Rec *);
	int    SLAPI GetGoodsStruc(PPID id, PPGoodsStruc * pGs);
		// @>>PPObjTech::GetGoodsStruc
	int    SLAPI GetGoodsStrucList(PPID id, int useSubst, TGSArray * pList);
		// @>>PPObjTech::GetGoodsStrucList(TSession(id).TechID, useSubst, pList)
	struct SelectBySerialParam {
		SLAPI  SelectBySerialParam(PPID sessID, const char * pSerial);

		char   Serial[32]; // IN
		PPID   InTSesID;   // IN  Сессия, для которой запрашивается выбор по коду
		PPID   LocID;      // IN  Склад, для которого запрашивается выбор по коду. Это поле используется //
			// только в том случае, если InTSesID == 0.
		int16  CodeType;   // OUT {1 - goods code, 2 - serial code by lot, 3 - serial code by TSessLine}
		PPID   OutTSesID;  // OUT Сессия, создавшая код Serial (CodeType == 3)
		PPID   GoodsID;    // OUT Товар, соответствующий коду Serial
		PPID   LotID;      // OUT Лот, соответствующий коду Serial (CodeType == 2)
		double Qtty;       // OUT Количество, доступное по коду Serial (CodeType == 2 || CodeType == 3)
	};
	//
	// Descr: Идентифицирует товарную позицию по серийному номеру. В качестве параметра
	//   получает указатель на структуру PPObjTSession::SelectBySerialParam.
	//   Если серийный номер идентифицирован, то проверяет, чтобы сессия pParam->InTSessID
	//   еще не расходовала указанный серийный номер. Если сессия расходовала этот серийный
	//   номер, то возвращает 2.
	// Returns:
	//   <0 - серийный номер не идентифицирован
	//   1  - серийный номер идентифицирован
	//   2  - серийный номер идентифицирован, но сессия pParam->InTSessID уже содержит строку,
	//        расходующую этот серийный номер.
	//   0  - ошибка
	//
	int    SLAPI SelectBySerial(SelectBySerialParam * pParam);
	struct SerialByGoodsListItem {
		PPID   LotID;
		PPID   TSessID;
		double Qtty;
		char   Serial[32];
		char   Text[48];
	};
	int    SLAPI GetSerialListByGoodsID(PPID goodsID, PPID locID, SArray * pList);
	int    SLAPI SelectSerialByGoods(PPID goodsID, PPID locID, SerialByGoodsListItem * pItem);
	int    SLAPI GetTagList(PPID id, ObjTagList * pTagList);
	int    SLAPI SetTagList(PPID id, const ObjTagList * pTagList, int use_ta);
	int    SLAPI PutExtention(PPID id, PPProcessorPacket::ExtBlock * pExt, int use_ta);
	int    SLAPI GetExtention(PPID id, PPProcessorPacket::ExtBlock * pExt);
	//
	// Descr: Опции функции PPObjTSession::GetPacket
	//
	enum {
		gpoLoadLines = 0x0001 // Загружать строки сессии в пакет
	};
	int    SLAPI GetPacket(PPID id, TSessionPacket * pPack, long options);
	int    SLAPI PutPacket(PPID * pID, TSessionPacket * pPack, int use_ta);
	int    SLAPI PutRec(PPID * pID, TSessionTbl::Rec *, int use_ta);
	int    SLAPI EditLine(PPID tsesID, long * pOprNo, PPID goodsID, const char * pSerial, double initQtty);
	//
	// Descr: Открывает диалог редактирования записи pRec.
	//   Редактирование записи может сопряжено со специальным случаем, когда
	//   во время редактирования запись обновляется (сохраняется) в базе данных.
	//   Такой случай наступает при следующих обстоятельствах:
	//   1. Пользователь открыл таблицу редактирования строк сессии
	//   2. Пользователь выбрал из диалога режим редактирования кассового чека
	//   При этом, если пользователь в конце концев нажал [Отмена], запись
	//   осталась сохраненной. Функция в этом случае возвращает 2.
	// Returns:
	//   <0 - пользователь отменил редактирование записи
	//   1  - пользователь подтвердил редактирование записи
	//   2  - пользователь отменил редактирование записи, но она была сохранена в базе
	//        данных во время сеанса редакрирования.
	//        Поле pRec->ID содержит идентификатор сохраненной записи.
	//
	int    SLAPI EditDialog(TSessionPacket * pRec);
	int    SLAPI EditNewIdleSession(PPID prcID, PPID curSessID, PPID * pSessID);
	int    SLAPI EditLineDialog(TSessLineTbl::Rec *, int asPlanLine);
	//
	// Descr: Интерфейсная функция, обеспечивающая обработку записей с BHT-терминала.
	// ARG(signal IN):
	//   1 - начало процесса обработки данных. pRec инициализирована первой записью потока.
	//   0 - продолжение процесса обработки данных. pRec инициализирована очередной записью потока.
	//   2 - штатное завершение процесса обработки данных.  pRec не инициализирована.
	//  -1 - нештатное (по ошибке) завершение процесса обработки данных. pRec не инициализирована.
	//
	int    SLAPI ProcessBhtRec(int signal, const BhtTSessRec * pRec, PPLogger * pLogger, int use_ta);

	int    SLAPI GetLabelInfo(PPID tsesID, long oprNo, PPID * pPrnID, RetailGoodsInfo *);
	//
	// Descr: Печатает этикетку по строке {tsesID, oprNo}. Если silent == 0, то перед
	//   печатью выдает на экран диалог, в котором можно указать параметры печати.
	//   Если numCopies > 0, то печатает numCopies экземпляров этикеток, в противном
	//   случае берет количество копий из записи процессора (если silent == 0, то
	//   количество экземпляров определяется пользователем).
	//
	int    SLAPI PrintBarLabel(PPID tsesID, long oprNo, int numCopies, int silent = 0);
		// @>>PPObjTSession::GetLabelInfo, BarcodeLabelPrinter::PrintGoodsLabel
	//
	// Descr: Списывает сессии, список которых представлен в параметре pSessList.
	//   Если в список входят суперсессии, то списываются обычные сессии, являющиеся членами
	//   этих суперсессий.
	//   Перед списанием окночательный список сессий упорядочевается по дате и по приоритету,
	//   определяемому порядком списания сессий.
	//
	int    SLAPI WriteOff(const PPIDArray * pSessList, PUGL * pDfctList, int use_ta);
	int    SLAPI UndoWritingOff(PPID sessID, int use_ta);
	//
	// Descr: Создает рабочую сессию по процессору pPrcRec и привязанную к документу pBillRec.
	//
	int    SLAPI CreateOnlineByLinkBill(PPID * pSessID, const ProcessorTbl::Rec * pPrcRec, const BillTbl::Rec * pBillRec);
	//
	// Descr: Разносит скидку discount по строкам сессии с одновременным изменением результирующей
	//   суммы в записи сессии.
	// ARG(sessID   IN): идентификатор сессии, по строкам которой необходимо разнести скидку
	// ARG(pct      IN): если !0, то скидка discount задана в процентах
	// ARG(discount IN): величина скидки (см. ARG(pct))
	// ARG(use_ta   IN): Если !0, то функция создает фрейм транзакции
	// Returns:
	//   >0 - скидка была изменена
	//   <0 - по каким-либо причинам (не ошибка) ничего менять не пришлось
	//   0  - ошибка
	//
	int    SLAPI SetupDiscount(PPID sessID, int pct, double discount, int use_ta);

	struct WrOffAttrib {
		PPID   ArID;
		PPID   Ar2ID;
		PPID   AgentID;
		PPID   SCardID;
	};
	int    SLAPI GetWrOffAttrib(const TSessionTbl::Rec * pRec, WrOffAttrib * pAttr);
	//
	// Descr: Вызывает кассовую панель, которая автоматически создаст пакет
	//   кассового чека, соответствующего техн сессии sessID.
	//   Если сессия sessID не существует, либо не закрыта, либо для склада,
	//   которому принадлежит процессор сессии нет ни одного кассового узла,
	//   либо по сессии уже был проведен чек функция ничего не делает и возвращает <0.
	//   Если же все условия выполняются и кассовая панель была вызвана, то
	//   функция возвращает >0 (не зависимо от того был пользователем проведен чек по
	//   сессии или нет).
	// ARG(sessID     IN): ИД сессии, по которой необходимо сформировать чек.
	// ARG(verifyOnly IN): Если !0, то функция не вызывает кассовую панель, но
	//   лишь проверяет возможность создания чека по сессии sessID.
	// Returns:
	//   <0 - по идентификатору sessID кассовой сессии невозможно создать чек.
	//   >0 - если verifyOnly, то по сессии sessID можно создать чек, в противном
	//        случае этот код возврата означает, что чековая панель была вызвана.
	//
	int    SLAPI CallCheckPaneBySess(PPID sessID, int verifyOnly = 0);
	int    SLAPI CalcBalance(PPID sessID, double * pDebt, double * pBillPaym, double * pCcPaym);
	//
	// Descr: Структура, возращаемая в ответ на запрос о статусе процессорного места с заданным кодом
	//
	struct PlaceStatus {
		void   SLAPI Init();
		PPID   TSessID;
		int    Status;      // 0 - место не идентифицировано, 1 - место свободно, -1 - место занято
		PPID   GoodsID;     // Товар, ассоциированный с местом
		PPID   RegPersonID; // @v8.8.0 ИД персоналии, загеристрированной на этом месте
		PPID   CipID;       // @v8.8.2 ИД позиции в таблице персональных регистраций сессии
			// (может понадобиться для осуществления дополнительных операций по регистрации: подстверждение, отмена и т.д.)
		double Price;       // Цена (по товарной котировке)
		SString PlaceCode;  // Собственно, код места
		SString Descr;      // Текстовое описание места
		SString PinCode;    // @v8.8.0 PIN-код. Если на месте никто не зарегистрирован, то - пусто.
	};
	//
	// Descr: Возвращает информацию о статусе процессорного места в контексте сессии tsessID
	// ARG(tsessID IN): Идентификатор технологической сессии
	// ARG(pPlaceCode IN): Код места
	// ARG(quotKindID IN): Вид котировки, испольуемый для получения цены
	// ARG(quotLocID IN): Склад, по которому извлекается котировка. Если 0, то применяется склад, к которому привязан процессор сессии
	// ARG(rStatus OUT): Структура, в которую заносятся параметры статуса процессорного места.
	//
	int    SLAPI GetPlaceStatus(PPID tsessID, const char * pPlaceCode, PPID quotKindID, PPID quotLocID, PlaceStatus & rStatus);
	//
	int    SLAPI ImportUHTT();
	int    SLAPI ConvertPacket(const UhttTSessionPacket * pSrc, long flags, TSessionPacket & rDest);
private:
	static int  SLAPI PutWrOffOrder(TSessWrOffOrder *, int use_ta);
	static int  SLAPI GetWrOffOrder(TSessWrOffOrder *);

	virtual int SLAPI DeleteObj(PPID id);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual const char * SLAPI GetNamePtr();
	virtual int SLAPI HandleMsg(int msg, PPID _obj, PPID _id, void * extraPtr);
	virtual void SLAPI Destroy(PPObjPack * p);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);

	int    SLAPI SerializePacket(int dir, TSessionPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI Helper_SetSessionState(TSessionTbl::Rec *, int newState, int checkOnly, int updateChilds);
	int    SLAPI Helper_WriteOff(PPID sessID, PUGL * pDfctList, PPLogger &, int use_ta);
	int    SLAPI SnapshotRest(PPID sessID, PPLogger &, int use_ta);
	int    SLAPI LoadExistedDeficitBills(PPID sessID, TSCollection <PPBillPacket> * pList, PPLogger & rLogger);
	int    SLAPI ConvertWrOffDeficit(PPID sessID, PPID locID, const PUGL * pDfctList, PPLogger & rLogger);
	//
	// Descr: Заносит в сессию строку, соответствующую расходу основного товара, если он
	//   учитывается по времени (торговая единица основного товара приводится к секунде).
	//
	int    SLAPI PutTimingLine(const TSessionTbl::Rec * pPack); // @<<PPObjTSession::PutPacket
	int    SLAPI CompleteStruc(PPID sessID, PPID tecGoodsID, PPID tecStrucID,
		double tecQtty, const PPIDArray * pGoodsIdList, int tooling); // @<<PPObjTSession::Complete
	void   SLAPI Helper_SetupDiscount(SArray & rList, int pct, double discount);
		// @<<PPObjTSession::SetupDiscount
	SString NameBuf;
	PPTSessConfig Cfg;
	//
	struct BhtCurSessData {
		SLAPI  BhtCurSessData();
		int    SLAPI Set(PPID sessID, PPID prcID, PPID arID, const LDATETIME & rDtm);
		void   SLAPI Reset();
		BhtCurSessData & FASTCALL operator = (const BhtCurSessData &);
		PPID   TSessID;
		PPID   PrcID;
		PPID   ArID;
		LDATETIME Dtm;
		int    Ta;
		int    IsProperSess; // Сессия создана самой функцией ProcessBhtRec.
			// Эта сессия закрывается при появлении новой сессии.
			// Сессии, которые не были созданы этой функцией - не закрываются.
		PPObjGoods GObj;
	};
	BhtTSess * P_BhtCurSess;
public:
	PPObjTech TecObj;
	PPObjProcessor PrcObj;
	PPObjSCard ScObj;
	PPObjGoods GObj;

	TLP_MEMB(TSessionCore, P_Tbl);
	void * ExtraPtr;
};
//
// Descr: Автоматическая обработка технологических сессий
//
class PrcssrTSessMaintenance {
public:
	struct Param { // @persistent
	public:
		SLAPI  Param();
		void   SLAPI Init();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
            fCancelCip = 0x0001
		};
		SVerT Ver; // Версия системы, создавшей запись
		uint8  Reserve[32]; // @reserve
		DateRange Period;   // Период обзора сессий (по StDt)
		long   Flags;
		long   Reserve2;    // @reserve
	};
	SLAPI  PrcssrTSessMaintenance();
	int    SLAPI InitParam(Param *);
	int    SLAPI EditParam(Param *);
	int    SLAPI Init(const Param *);
	int    SLAPI Run();
private:
	Param P;
	PPObjTSession TSesObj;
};
//
// @ModuleDecl(PPViewTSession)
//
struct TSessAnlzFilt;

struct TSessionFilt : public PPBaseFilt {
	enum {
		ordByDefault = 0,
		ordByStTime,
		ordByFnTime,
		ordByPrc,
		ordByMainGoods,
		ordByAr,
		ordByAmount
	};

	SLAPI  TSessionFilt();
	TSessionFilt & FASTCALL operator = (const TSessionFilt & s);
	int    SLAPI CheckIdle(long flags) const;
	int    SLAPI CheckStatus(int status) const;
	int    SLAPI GetStatusList(PPIDArray *) const;

	enum {
		fSuperSessOnly = 0x0001,
		fCurrent       = 0x0002, // Показать текущую по времени сессию по процессору PrcID. Если такая сессия //
			// является суперсессией, то показываются все подчиненные ей сессии, в противном случае показывается //
			// только эта сессия //
		fManufPlan     = 0x0004, // Показывать сессии производственных планов @#{fManufPlan^(fSuperSessOnly|fCurrent)}
		fSubSess       = 0x0008  // @v7.5.8 Если флаг установлен и SuperSessID != 0, то показываются субсессии
			// для сессии SuperSessID.
	};
	char   ReserveStart[20]; // @anchor
	PPID   QuotKindID;   // @v8.7.6 Вид котировки, испольуземый для извлечения цен
	PPID   UhttStoreID;  // @v8.7.5 ->Ref(PPOBJ_UHTTSTORE) Специальный критерий для передачи на онлайновый ресурс списка сессий
	int32  Order;        // Порядок сортировки
	PPID   SuperSessID;  // ->TSession.ID  ИД суперсессии. Если это поле ненулевое,
		// то отменяются все остальные критерии
	PPID   PrcID;        // ->Processor.ID ИД процессора
	PPID   TechID;       // ->Tech.ID      ИД технологии
	PPID   ArID;         // ->Article.ID
	PPID   Ar2ID;        // ->Article.ID
	DateRange StPeriod;  // Период начала сессии
	LTIME  StTime;       // Время начала сессий. Ограничением является пара {StPeriod.low, StTime}
	DateRange FnPeriod;  // Период завершения сессии
	LTIME  FnTime;       // Время окончания сессий. Ограничением является пара {FnPeriod.upp, FnTime}
	long   StatusFlags;  // Флаги статусов, по которым нужна выборка
	long   Flags;        // Флаги (TSessionFilt::fXXX)
	int16  Ft_Idle;      // (0) ignored, (<0) не показывать простои, (>0) показывать простои
	uint16 Reserve;      // @alignment
};

struct TSessionTotal {
	long   Count;
	long   Duration; // Общая продолжительность сессий (сек)
};

class TSessionViewItem : public TSessionTbl::Rec {
public:
	SLAPI  TSessionViewItem();
	TSessionViewItem & SLAPI Init();

	PPCheckInPersonItem CipItem;
	PPID   WrOffBillID;
};

class PPViewTSession : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByStartTime,
		ordByFinishTime,
		ordByPrc,
		ordByAr,

		ordfWithCip  = 0x10000000, // Специальный флаг, предписывающий перебирать сессии с записями персональных регистраций
		ordfWithBill = 0x20000000  // Специальный флаг, предписывающий перебирать сессии с документами списания //
	};
	//
	// Descr: Расширение результатов перечисления для передачи в интернет-магазин
	//
	struct UhttStoreExt {
		UhttStoreExt & Clear();
		PPID   ID;
		StrAssocArray SfList;
	};

	SLAPI  PPViewTSession();
	SLAPI ~PPViewTSession();
	//
	// ARG(extraParam IN): Если этим параметром передается значение TSESK_PLAN,
	//   то в созданном фильтре устанавливается флаг fManufPlan.
	//
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(TSessionViewItem *);
	int    SLAPI GetUhttStoreExtension(const TSessionTbl::Rec & rItem, PPViewTSession::UhttStoreExt & rExt);
	int    SLAPI CalcTotal(TSessionTotal *);
	int    SLAPI Transmit(PPID /*id*/);
	int    SLAPI GetSmsLists(StrAssocArray & rPsnList, StrAssocArray & rPhoneList, StrAssocArray & rTSessIdArr); // @vmiller
	int    SLAPI SendAutoSms(); // @vmiller

	int    SLAPI GetSelectorListInfo(StrAssocArray & rList) const;
	int    SLAPI GetSelectorListItem(long handler, PPUhttStoreSelDescr::Entry & rEntry) const;
private:
	virtual void * SLAPI GetEditExtraParam();
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	int    SLAPI IsTempTblNeeded();
	int    SLAPI MakeTempRec(const TSessionTbl::Rec * pSrcRec, TempOrderTbl::Rec * pDestRec);
	int    SLAPI WriteOff(PPID sessID);
	int    SLAPI Recover();
	int    SLAPI PrintList(const void * pHdr);
	int    SLAPI ExportUhtt();

	struct IterBlock {
		IterBlock();
		IterBlock & FASTCALL Init(int order);

		int    Order;
		PPCheckInPersonArray CipList;
		PPIDArray WrOffBillList;
		TSessionViewItem CurItem;
	};

	enum {
		stEmpty             = 0x0001, // Фильтр дает пустую выборку
		stSuperSessIsSimple = 0x0002  // Признак того, что Filt.SuperSessID не является в действительности
			// суперсессией. В этом случае показывается только простая сессия с ид Filt.SuperSessID
	};
	long   State;
	TSessionFilt Filt;
	PPObjTSession TSesObj;
	TempOrderTbl * P_TempTbl;
	TSessAnlzFilt * P_LastAnlzFilt; // Последний использованный фильтр по анализу сессий.
		// Применяется для того, чтобы пользователю не приходилось заново вводить парараметры
		// фильтрации при повторном анализе той же выборки сессий.
	PPUhttStorePacket * P_UhttsPack;
	IterBlock  Ib;
	ObjIdListFilt PrcList;

	StrAssocArray ExtSfTitleList;
};
//
// @ModuleDecl(PPViewTSessAnlz)
//
class TSessAnlzList;

struct TSessAnlzFilt : public PPBaseFilt {
	SLAPI  TSessAnlzFilt();
	TSessAnlzFilt & FASTCALL operator = (const TSessAnlzFilt &);
	void   SLAPI SetOuterTSessFilt(const TSessionFilt *);
	const  TSessionFilt * SLAPI GetOuterTSessFilt() const;
	int    SLAPI IsDiffFlag() const;

	enum {
		fAll                  = 0x0004, // Отчет по всей выборке сессий. Иначе - по одной
		fPrmrGoodsOnly        = 0x0008, // Только по основным товарам (исключает DiffMg)
		fShowRest             = 0x0010, // Показывать строки фиксированных остатков
		fExtrapolToPeriod     = 0x0080, // Экстраполировать итоги анализа по плану на неполный период.
			// Эта опция используется при расчете анализа по производственному плану, работа по которому еще не закончилась.
		fAddTotalRows         = 0x0100, // Показывать итоги по каждой из позиций без группировки
			// Актуальна только если DiffPrc || DiffMg || DiffDt.
		fNmgRestrictOnly      = 0x0200, // NmGoodsGrpID (если !0) только ограничивает выборку, но не замещает позиции
		fInterpolPlanToAr     = 0x0400, // Интерполировать план на статьи. Эта опция работает только в том
			// случае, когда DiffPrc == difprcAr и для статей процессора определен график дежурств.
		fNmgAllRestrict       = 0x0800, // NmGoodsGrpID (если !0) ограничивает все товары (основные и неосновные) выбранной группой
		fCalcCompParts        = 0x1000  // Рассчитывать итоговые части компонентов в производимой продукции (в физических единицах).
	};
	//
	// Варианты дифференциации отчета по процессорам
	//
	enum {
		difprcNone = 0, // Нет дифференциации
		difprcPrc,      // Дифференцировать собственно по процессорам
		difprcPrcGroup, // Дифференцировать по группам процессоров (самый близкий к процессорам уровень)
		difprcAr        // Дифференцировать по статьям сессий
	};
	//
	// Варианты дифференциации отчета по основным товарам
	//
	enum {
		difmgNone = 0, // Нет
		difmgGoods,    // Дифференцировать собственно по основным товарам
		difmgGroup     // Дифференцировать по группам основных товаров
	};
	//
	// Варианты дифференциации отчета по дате
	//
	enum {
		difdtNone = 0, // Нет
		difdtDate,     // Дифференцировать собственно по дате начала сессий
		difdtSupersess // Дифференцировать по суперсессиям
	};
	char   ReserveStart[32];  // @anchor
	DateRange Period;         // reserved
	PPID   PrcID;             // reserved
	PPID   GoodsGrpID;        // reserved
	PPID   ArID;              // reserved
	PPID   Ar2ID;             // reserved
	PPID   PlanSessID;        // ->TSession.ID Ид сессии производственного плана
	PPID   NmGoodsGrpID;      // Группа неосновных товаров, по которой ограничивается и обобщаяетс
		// либо только ограничивается отчет.
		// Остальные неосновные товары в отчет не попадают, а товары, входящие в эту группу сливаются //
		// в одну строку.
	SubstGrpGoods Sgg;        //
	long   Flags;             //
	int16  DiffPrc;           // Дифференциация по процессору
	int16  DiffMg;            // Дифференциация по основному товару
	int16  DiffDt;            // Дифференциация по дате
	int16  Reserve;           //
	ObjIdListFilt SessIdList; // @anchor
private:
	TSessionFilt * P_TSesFilt; // Используется как источник полей для отчетов. На формирование анализа не влияет.
};

struct TSessAnlzViewItem {
	PPID   __ID;
	long   DtVal;         //
	PPID   PrcID;
	PPID   PrmrGoodsID;
	int16  NotPrmrLine;   // Строка не принадлежит основному товару (GoodsID != PrmrGoodsID)
	int16  PlanPhUnit;    // План и факт представлены в физических единицах
	PPID   GoodsID;
	char   PrmrGoodsName[64];
	char   GoodsName[64];
	char   PrcName[48];
	char   DtText[48];
	double InQtty;
	double OutQtty;
	double InQttyPh;
	double OutQttyPh;
	double PlanInQtty;
	double PlanOutQtty;
	double PlanDev;
	double OutRest;
	double InCompPart;    // Часть компонента в общем входе  (в физ единицах)
	double OutCompPart;   // Часть компонента в общем выходе (в физ единицах)
};

class PPViewTSessAnlz : public PPView {
public:
	SLAPI  PPViewTSessAnlz();
	SLAPI ~PPViewTSessAnlz();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(TSessAnlzViewItem *);
	int    SLAPI GetItem(PPID __id, TSessAnlzViewItem *);
	int    SLAPI GetPhQtty(const TSessAnlzViewItem * pItem, PPID * pPhUnitID, double * pIn, double * pOut);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Print(const void *);
	int    SLAPI CreateTSessFiltByPlan(const TSessionTbl::Rec * pPlanRec, TSessionFilt * pFilt) const;
	int    SLAPI CreateBySess(PPID sessID, TSessAnlzList * pResult, PPIDArray * pProcessedList);
	void   SLAPI RecToViewItem(const TempTSessRepTbl::Rec * pRec, TSessAnlzViewItem * pItem);
	int    SLAPI IsGoodsBelongToGen(PPID goodsID, PPID * pGenID);
	int    SLAPI GetPlanWithSubst(PPID arID, PPID * pGoodsID, double * pPlan, int * pSign);
	int    SLAPI NmGoodsSubst(PPID prmrGoodsID, PPID * pGoodsID); // @<<ProcessSession
	int    SLAPI ProcessSession(const TSessionTbl::Rec * pRec, TSessAnlzList * pResult);
	int    SLAPI EditGoods(PPID goodsID);
	int    SLAPI CalcArTimes(const PPDutySchedPacket * pDsPack, const STimeChunk & rBounds, RAssocArray * pDurationList);
	int    SLAPI GetDutySchedPacket(PPID prcID, PPDutySchedPacket *);

	TSessAnlzFilt Filt;
	TempTSessRepTbl * P_TempTbl;
	PPObjTSession TSesObj;
	PPObjGoods  GObj;
	LAssocArray GenList;
	RAssocArray PlanList;      //
	PPIDArray   PhTagPlanList; // SORTED Список идентификаторов товаров, план по которым задан в физических единицах
	RAssocArray ArTimesList;   // Используется для интерполяции общего плана на статьи (TSessAnlzFilt::fInterpolPlanToAr)
	GoodsSubstList Gsl;
};
//
// @ModuleDecl(PPViewTSessLine)
//
struct TSessLineFilt {
	SLAPI  TSessLineFilt(PPID sessID = 0, PPID goodsID = 0, int showRest = 0);
	int    SLAPI Init();
	enum {
		fOutRest = 0x0001   // Показывать строки, соответствующие исходящим остаткам по сессии
	};
	long   Tag;             // @#0 reserved
	uint8  Reserve[32];     // @#0 !Использовать начиная со старших адресов
	PPID   GoodsID;
	long   Flags;
	DateRange StPeriod;     // Период начала сессии. Действует только если GoodsID != 0
	ObjIdListFilt TSesList; // Если список не пустой, то все остальные критерии,
		// относящиеся к отбору сессий игнорируются.
};

typedef TSessLineTbl::Rec TSessLineViewItem;

class PPViewTSessLine : public PPView {
public:
	SLAPI  PPViewTSessLine();
	SLAPI ~PPViewTSessLine();
	const  TSessLineFilt * SLAPI GetFilt() const;
	int    SLAPI Init(const TSessLineFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(TSessLineViewItem *);
private:
	struct BrwHdr {
		PPID   TSesID;
		long   OprNo;
	};
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser *);
	virtual int SLAPI Print(const void *);
	virtual int SLAPI ViewTotal();
	int    SLAPI IsTempTblNeeded();
	int    SLAPI CreateIterQuery();
	int    SLAPI TranslateBrwHdr(const void *, BrwHdr *);
	int    SLAPI AddItemExt(PPID tsesID, PPViewBrowser *);
	int    SLAPI AddItemByCode(const char * pInitStr);

	TSessLineFilt Filt;
	PPObjTSession TSesObj;
	PPObjGoods GObj;
	PPID   NewGoodsGrpID;
	long   GoodsListIter;  // -1 - не используется //
	long   SessListIter;   // -1 - не используется //
	PPIDArray GoodsIdList; // @*PPViewTSessLine::Init() SORTED
	TSessLineTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewPrcBusy)
//
struct PrcBusyFilt : public PPBaseFilt {
	SLAPI  PrcBusyFilt();

	enum {
		fFree          = 0x0001, // Показывать доступные периоды (в течении которых процессоры свободны)
		fShowTimeGraph = 0x0002  // При открытии таблицы сразу открывать временную диаграмму.
	};
	char   ReserveStart[32]; // @anchor
	PPID   PrcID;            // Процессор или группа процессоров
	STimeChunk Period;       // Период, для которого показывать занятые (свободные) процессоры
	LTIME  MinDuration;      // Минимальная продолжительность. Если период занятости (свободы)
		// процессора ниже этой величины, то не показывать такой период
	long   Flags;
	long   Reserve;          // @anchor
};

struct PrcBusyViewItem {
	PPID   PrcID;
	STimeChunk Period;
	PPID   TSessID;
	long   Duration;
	char   TxtPeriod[48];
	char   TxtDuration[16];
};

class PPViewPrcBusy : public PPView {
public:
	SLAPI  PPViewPrcBusy();
	SLAPI ~PPViewPrcBusy();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PrcBusyViewItem *);
	int    SLAPI GetItem(PPID id, PrcBusyViewItem * pItem);
	int    SLAPI EditTimeGridItem(PPID * pID, PPID rowID, const LDATETIME & rDtm);
	int    SLAPI UpdateTimeGridItem(PPID sessID, PPID prcID, const STimeChunk & rNewChunk);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int   SLAPI Print(const void *);
	virtual int   SLAPI OnExecBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	int    SLAPI ProcessPrc(PPID prcID, BExtInsert * pBei);
	int    SLAPI Update(const PPIDArray & rPrcList);
	void   SLAPI RecToViewItem(const TempPrcBusyTbl::Rec * pRec, PrcBusyViewItem * pItem) const;
	int    SLAPI AddSession(PrcBusyViewItem * pItem);
	int    SLAPI ViewTSessLines(PPID);
	int    SLAPI TimeChunkBrowser();
	int    SLAPI UpdateTimeBrowser(int destroy);

	PrcBusyFilt Filt;
	TempPrcBusyTbl * P_TempTbl;
	PPObjTSession TSesObj;
	PPObjStaffCal ScObj;
	PPObjStaffList SlObj;
	PPIDArray PrcList;
	PPIDArray UpdatePrcList;
	//
	class PrcBusyTimeChunkGrid : public STimeChunkGrid {
	public:
		SLAPI  PrcBusyTimeChunkGrid();
		SLAPI ~PrcBusyTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
		virtual int GetColor(long id, STimeChunkGrid::Color * pClr);
		//
		PPViewPrcBusy * P_View; // @notowned
		PPObjGoods GObj;
	};
	PrcBusyTimeChunkGrid Grid;

	friend class PPViewPrcBusy::PrcBusyTimeChunkGrid;
};
//
// Конфигурация обмена данными между разделами БД
//
#define DBDXF_SKIPINCOMPLBILL      0x00000001L // Не принимать неполные документы
#define DBDXF_CALCTOTALDEFICITE    0x00000002L // Расчитывать итоговый дефицит товаров
#define DBDXF_TURNTOTALDEFICITE    0x00000004L // Приходовать дефицит
#define DBDXF_LINKRETBILLS         0x00000008L // Связывать возвратные документы
#define DBDXF_IGNOREACK            0x00000010L // Не принимать пакеты подтверджений
#define DBDXF_TWOPASSRCV           0x00000020L // Автоматический двухпроходной прием с приходованием дефицита
#define DBDXF_SENDINVWROFFBILLS    0x00000040L // Передавать документы списания ревизии
#define DBDXF_NOUPDGOODS           0x00000080L // Не принимать изменения товаров
#define DBDXF_IMPOPSYNC            0x00000100L // Контекстная синхронизация видов
	// операций по наименованию, типу операции и таблице статей
#define DBDXF_SYNCSCARDWOCHECKS    0x00000200L // Синхронизировать пластиковые карты без чеков
#define DBDXF_DONTCVTTOTALDIS      0x00000400L // Не конвертировать общую скидку на документы. Если этот флаг
	// не установлен, то система преобразует общую скидку, установленную по документу, в общую абсолютную скидку
	// (PPObjBill::ConvertILTI [ILTICVT.CPP]). В этом случае могут возникнуть затруднения при модификации
	// документа, на который в разделе-отправителе выставлена скидка в процентах, одновременно в обоих разделах -
	// суммы не совпадут, по-скольку в разделе получателе скидка будет выражена в сумме.
#define DBDXF_SENDCSESSION         0x00000800L // Передавать кассовые сессии.
	// Если этот флаг установлен, то при передаче изменений будут передаваться //
	// сессии, зафиксированные событием PPACN_CSESSCLOSED. Насильственная передача
	// сессий (PPViewCSess::Transmit) возможна независимо от этого флага.
	//
	// Если этот флаг установлен, то документы списания кассовых сессий не передаются.
	// @v4.6.4 Исключением является случай, когда в разделе-приемнике установлен флаг
	// DBDIVF_RCVCSESSANDWROFFBILLS. [см. функцию PPObjectTransmit::PutObjectToIndex()]
#define DBDXF_CHARRY_PRICEQCOST    0x00001000L // При приеме документов Charry цена реализации
	// равна цене поступления. В противном случае - если лоты такого товара уже существуют, то
	// цена берется из последнего из этих лотов, если же таких лотов нет, то цена реализации
	// опять же равна цене поступления.
#define DBDXF_PACKFILES            0x00002000L // Упаковывать файлы перед отправкой
#define DBDXF_IGNOBJUNIFY          0x00004000L // Игнорировать объединение объектов при разрешении идентификаторов
	// В функции PPObjectTransmit::NeedRestoreObj() не будет проверяться факт объединения объекта, если
	// в БД такой объект не найден (в некоторых случаях такая проверка приводит к неверному разрешению
	// синхронизации объектов).
#define DBDXF_UNITEINVDUPREC       0x00008000L // Объединять дублирующиеся строки инвентаризации
#define DBDXF_NOCOMMITBYDEF        0x00010000L // По умолчанию, при приеме данных не устанавливается //
	// признак "Непосредственная фиксация транзакции"
#define DBDXF_DESTROYQUEUEBYDEF    0x00020000L // По умолчанию, при приеме данных устанавливать
	// признак "Разрушать очередь после акцепта"
#define DBDXF_DONTLOGOBJUPD        0x00040000L // Не показывать в журнале информацию об изменении объектов
#define DBDXF_SUBSTDEFICITGOODS    0x00100000L // подставлять дефицитные товары
#define DBDXF_CHARRY_GIDASARCODE   0x00200000L // При приеме документов по CHARRY идентификатор товара
	// трактовать как код товара по контрагенту.
#define DBDXF_SENDTAGATTCHM        0x00400000L // @9.2.6 Передавать файлы, прикрепленные к тегам

struct PPDBXchgConfig { // @transient (Для сохранения транслируется в __PPDBXchgConfig)
	PPID   OneRcvLocID;      // Единственная локация, на которую должны приниматься все документы,
		// независимо от того, какой локации они принадлежали в разделе-отправителе
		//
	long   PctAdd;           // Процент наценки при доприходовании дефицита
		// В сотых долях процента (250 = 2.5%)
		//
	int16  RealizeOrder;     // RLZORD_XXX Порядок использования лотов при приеме документов
		// (переопределяет PPConfig::RealizeOrder на приеме документов из другого раздела)
		//
	uint16 PadRo; // @alignment
	long   CharryOutCounter; // Счетчик исходящих файлов Charry
	long   Flags;
	PPID   DfctRcptOpID;     // @v7.7.0 Вид операции приходования дефицита.
};
//
// --- Before v3.2.10 ---

// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             32
//    Количество элементов массива list                     2
//    Массив list           list.getCount() * sizeof(PPObjID)
//    Количество элементов массива addr                     2
//    Массив addr              addr.getCount() * sizeof(long)
//    Количество элементов массива commIDs                  2
//    Массив commIDs        commIDs.getCount() * sizeof(PPID)
//    Объекты                                             var
// Примечание: list.count == add.count == commIDs.count
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             32
//    PPObjectTransmit::Ack[]                          n * 32
//
// --- Since v3.2.10 ---
//
// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             64
//    Объекты                                             var
//    PPObjectTransmit::IndexItem [PPObjectTransmit::Header::IndexCount]
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             64
//    PPObjectTransmit::Ack[]                          n * 32
//
// --- Since v5.6.8 ---
//
// Формат файла передачи объектов:
//    PPObjectTransmit::Header                             64
//    Объекты                                             var
//    PPObjectTransmit::IndexItem [PPObjectTransmit::Header::IndexCount]
//    Наименования объектов (StringSet)                   var
//      Формат списка наименований: {{uint32 size}, {char buf[size]}}
//
// Формат файла передачи подтверждения о приеме объектов
//    PPObjectTransmit::Header                             64
//    PPObjectTransmit::Ack[]                          n * 32
//

//
// Приоритеты приема объектов данных:
//
// DEFAULT:           1000
// PPOBJ_DYNAMICOBJS:  100
// PPOBJ_TAG:          120
// PPOBJ_BILL (приоритеты различаются в зависимости от характера операции):
//   Тип операции PPOPT_GOODSRECEIPT:                                           200
//   Любая другая приходная операция или заказ от покупателя (IsExpendOp()==0): 220
//   Тип операции PPOPT_GOODSMODIF:                                             240
//   Расходная операция (IsExpendOp()>0):                                       280
//   Все остальные документы:                                                   300
//
//

//
// Типы пакетов для передачи между разделами БД
//
#define PPOT_OBJ         1 // Пакет, содержащий объекты
#define PPOT_ACK         2 // Пакет, содержащий подтверждение о приеме объектов
#define PPOT_SYNCCMP     3 // Пакет, содержащий информацию о синхронизации объектов
//
// Флаги PPObjectTransmit::Header::Flags
//
#define PPOTF_ACK        0x0001L // Подтверждение обработки файла адресатом
#define PPOTF_ARC        0x0002L // Файл упакован
#define PPOTF_IGNACK     0x0004L // Отправитель этого пакета объектов игнорирует пакеты подтверждений
	// (в ответ на этот флаг раздел-получатель не станет создавать пакет подтверждений)
#define PPOTF_CONSOLID   0x0008L // Отправитель этого пакета считает, что отсылает данные в
	// консолидирующий раздел (при этом некоторые данные не передаются)
#define PPOTF_RECOVER    0x0010L // @v8.2.3 Специальный флаг, указывающий на то, что пакет передачи содержит
	// восстановительные данные для раздела-получателя //
//
// Object update mode in destination database devision
//
#define PPOTUP_DEFAULT  -1 //
#define PPOTUP_NONE      0 // Don't update
#define PPOTUP_BYTIME    1 // Update by modif date/time
#define PPOTUP_FORCE     2 // Force update

#define TRNSMF_DELINFILES  0x00000001L
#define TRNSMF_DELOUTFILES 0x00000002L

struct ObjTransmitParam {
	SLAPI  ObjTransmitParam();
	void   SLAPI Init();
	int    SLAPI Read(SBuffer & rBuf, long);
	int    SLAPI Write(SBuffer & rBuf, long) const;

	enum {
		fSyncCmp                 = 0x0001,
		fRecoverTransmission     = 0x0002, // @v8.2.3 Специальный флаг, указывающий на то, что пакет передачи содержит
			// восстановительные данные для раздела-получателя //
		//
		// @v9.7.2
		// В подавляющем большинстве случаев объекты передаются выборкой. Однако, иногда,
		// по-умолчанию передача осуществляется только для выбранного объекта (например, в кассовых сессиях).
		// Для ручного переопределения такого поведения применяются следущие 2 флага.
		// 1. !fQueryInmassTransmission && !fInmassTransmission) вызывающая функция ведет себя по умолчанию
		// 2. fQueryInmassTransmission && !fInmassTransmission вызывающая функция ведет себя по умолчанию (в диалоге была возможность выбрать массовую передачу)
		// 3. fQueryInmassTransmission && fInmassTransmission вызывающая функция передает всю выборку объектов
		// 4. !fQueryInmassTransmission && fInmassTransmission инвалидная комбинация: вызывающая функция ведет себя по умолчанию
		//
		fQueryInmassTransmission = 0x0004, // Запрос на необходимость передачи всей выборки объектов
		fInmassTransmission      = 0x0008  // От пользователя получено требование передачи всей выборки объектов.
	};
	ObjIdListFilt DestDBDivList;
	ObjIdListFilt ObjList;       // PPACN_XXX
	LDATETIME Since_;
	int    UpdProtocol; // PPOTUP_XXX
	long   Flags;
	long   TrnsmFlags;   // TRNSMF_XXX
};

struct ObjReceiveParam {
	SLAPI  ObjReceiveParam();
	int    SLAPI Init();
	int    SLAPI CheckDbDivID(PPID id) const;
	int    SLAPI Write(SBuffer &, long) const;
	int    SLAPI Read(SBuffer &, long);

	enum {
		fNonInteractive    = 0x0001,  // Не вызывать диалог редактирования параметров
		fGetFromOutSrcr    = 0x0002,  // Забирать данные из внешнего источника
		fClearInpBefore    = 0x0004,  // Очищать каталог-приемник перед приемом файлов
		fClearInpAfter     = 0x0008,  // Очищать каталог-приемник после обработки данных
		fSyncCmp           = 0x0010,  // Обрабатывать только пакеты сравнения синхронизации
		fCommitQueue       = 0x0020,  // Акцептировать очередь приема данных
		fForceDestroyQueue = 0x0040   // Насильно разрушать очередь после акцепта (даже если не все объекты приняты)
	};
	PPIDArray SenderDbDivList;
	long   Flags;
	TempSyncCmpTbl * P_SyncCmpTbl; // Временная таблица сравнения синхронизации объектов
		// @#{((Flags & fSyncCmp) && P_SyncCmpTbl != 0) || (!(Flags & fSyncCmp) && P_SyncCmpTbl == 0)}
};

struct BillTransmitParam : public PPBaseFilt {
	SLAPI  BillTransmitParam();
	int    SLAPI Edit();

	enum {
		fLabelOnly = 0x0001
	};
	uint8  ReserveStart[28];     // @anchor // @v9.0.8 [32]-->[28]
	PPID   ArID;                 // @v9.0.8 Контрагент по документам
	DateRange Period;            //
	PPID   OpID;                 //
	PPID   ToOpID;               // Преобразовывать OpID в ToOpID
	PPID   Ar2ID;                // @v8.3.2 Дополнительный объект, по которому следует отбирать документы
	uint   Flags;                //
	long   TrnsmFlags;           // TRNSMF_XXX
	long   Reserve;              // @anchor
	ObjIdListFilt DestDBDivList; // @anchor
	BillFilt * P_BillF;          //
};

class BillTransmDeficit {
public:
	struct LocPeriod {
		PPID   LocID;
		DateRange P;
	};

	SLAPI  BillTransmDeficit();
	SLAPI ~BillTransmDeficit();
	int    SLAPI ProcessDeficit(ObjTransmContext * pCtx, int * pNextPassNeeded);
	int    SLAPI AddItem(ILTI * ilti, const char * pClbNumber, BillTbl::Rec *, int skipped);
	PPIDArray LookedBills;
private:
	int    SLAPI TurnDeficitDialog(double * pPctAddition);
	int    SLAPI TurnDeficit(PPID locID, LDATE dt, double pctAddition, ObjTransmContext * pCtx);
	int    SLAPI PrintTotalDeficit(ObjTransmContext * pCtx);
	int    SLAPI Search(PPID locID, PPID goodsID, PPID supplID, TempDeficitTbl::Rec *);
	int    SLAPI CalcReqSalesTax(ILTI *, LDATE, PPID opID, double * pSalesTax);
	int    SLAPI AddRec(ILTI *, const char * pClbNumber, BillTbl::Rec *, PPID supplID, double qtty);
	int    SLAPI UpdateRec(TempDeficitTbl::Rec *, ILTI *, const char * pClbNumber, BillTbl::Rec *, double qtty);
	int    SLAPI CompleteGoodsRest();
	int    SLAPI _CompleteGoodsRest(PPID locID, PPID goodsID, SArray * pRecList, uint startPos, double supplQtty);
	int    SLAPI InitDeficitBill(PPBillPacket *, PPID oprKind, LDATE, PPID locID, PPID supplID);
	int    SLAPI GetGoodsDeficitList(PPIDArray * pList);
	LocPeriod * GetLocPeriod(PPID locID);

	int    DiffGoodsBySuppl;
	TSArray <LocPeriod> LocPeriodList_;
	TempDeficitTbl * Tbl;
	PPObjBill  * BObj;
	PPObjGoods   GObj;
};
//
// Descr: Контекст обмена данными. Передается в виртуальные методы
//   PPObject::Write, PPObject::Read.
//
struct ObjTransmContext {

	friend class PPObjectTransmit;
	//
	// Descr: Конструктор.
	// ARG(pLogger IN): @#{vptr0} Если указатель !0, то объект получает в качестве логгера внешний экземпляр,
	//   жизненный цикл которого управляется вызывающим кодом. В противном случае объект создает
	//   собственный экземпляр PPLogger, который будет разрушен деструктором.
	// Note: Для освобождения ссылки на внешний логгер и создания собственного экземпляра следует
	//   использовать метод ResetOuterLogger()
	//
	SLAPI  ObjTransmContext(PPLogger * pLogger = 0);
	SLAPI ~ObjTransmContext();
	int    SLAPI ResetOuterLogger();
	int    SLAPI Output(const char * pText);
	int    SLAPI OutputLastError();
	int    SLAPI OutReceivingMsg(const char * pMsg);
	int    SLAPI OutputAcceptErrMsg(uint msgID, PPID objID, const char * pObjName);
	int    SLAPI OutputAcceptObjErrMsg(PPID objType, PPID objID, const char * pObjName);
	int    SLAPI OutputAcceptMsg(PPID objType, PPID objID, int upd);
	int    SLAPI OutputString(uint strId, const char * pAddedInfo);
	operator SSerializeContext & ()
	{
		return SCtx;
	}
	int    SLAPI GetPrevRestoredObj(PPObjID * pOi) const;
	int    SLAPI ForceRestore(PPObjID);
	int    SLAPI IsForced(PPObjID) const;
	int    SLAPI GetPrimaryObjID(PPID objType, PPID foreignID, PPID * pPrimID);
	int    SLAPI RegisterDependedNonObject(PPObjID objid, PPCommSyncID * pCommID, int use_ta);
	int    SLAPI ResolveDependedNonObject(PPID objType, PPID foreignID, PPID * pPrimID);
	int    SLAPI AcceptDependedNonObject(PPObjID foreignObjId, PPID primaryID, const LDATETIME * pModDtm, int use_ta);

	LDATETIME TransmitSince;            // Момент, начиная с которого должны передаваться изменения //
	PPDBXchgConfig Cfg;                 // Конфигурация обмена
	BillTransmDeficit * P_Btd;          //
	enum {
		fNotTrnsmLots = 0x0001,         // Не передавать товарные строки
		fConsolid     = 0x0002,         // Принимающий раздел является консолидирующим
		fRecover      = 0x0004          // @v8.2.3 Восстанавливающая передача
	};
	long   Flags;                       // ObjTransmContext::fXXX
	const  DBDivPack * P_ThisDbDivPack; // Пакет текущего раздела БД
	const  DBDivPack * P_SrcDbDivPack;  // Пакет раздела БД, из которого принимаются данные (в режиме передачи - 0)
	const  DBDivPack * P_DestDbDivPack; // Пакет раздела-получателя данных (в режиме приема - 0)
	PPID   Extra;                       // Дополнительный параметр
		// в случае передачи документов, содержит id операции в которую требуется преобразовать текущую операцию
	long   LastStreamId;                // @v6.2.3 Идентификатор последнего потока, из которого извлекались данные.
		// Необходим для правильного переключения состояний контекстов сериализации данных (SCtx)
	SSerializeContext  SCtx;            // @v6.2.2 Контекст сериализации данных
private:
	const void * P_Rb;                  // @v6.4.5 @*PPObjectTransmit::CommitQueue Указатель на блок восстановления.
	enum {
		stOuterLogger = 0x0001
	};
	long   State;
	PPObjIDArray * P_ForceRestoreObj;   // @v6.4.5 Список объектов, которые должны быть изменены обязательно.
		// Список формируется в процессе приема данных. Некоторые объекты при приеме могут потребовать
		// обязательной модификации объекта, от которого они зависят.
		// Идентификаторы объектов здесь храняться в терминах раздела-отправителя (ссылки неразрешенные).
	PPObjectTransmit * P_Ot;            // @v7.6.1 @notowned
	PPLogger * P_Logger;                // Журнал, в который записывается информация о процессе
};

class PPObjectTransmit {
public:
	enum TransmitMode {
		tmUndef = 0,
		tmWriting,
		tmReading
	};
	struct Header {        // @persistent(DBX) @size=128
		int32  Magic;           // 0x534F5050L ("PPOS")
		uint16 PacketType;      // Тип пакета (PPOT_XXX)
		int32  DBID;            // Раздел БД, создавший пакет для передачи
		int32  DestDBID;        // Раздел БД - адресат пакета для передачи
		int32  Flags;           // PPOTF_XXX
		SVerT SwVer;           // Source software version
		uint32 IndexOffs;       // Offset from beginning of file to index list
		uint32 IndexCount;      // Count of index items
		uint32 ExtraData;       //
		SVerT MinDestVer;      // Минимальная версия, которая может принять этот пакет данных
			// Если версия системы ниже указанной версии, то система отклоняет этот пакет.
		uint8  PackMethod;      // Метод сжатия пакета.  Устанавливается и проверяется в PackTransmitFile()
		uint8  CryptMethod;     // Метод шифровки пакета. Устанавливается и проверяется в PackTransmitFile()
		uint32 NameListOffs;    // Смещение до списка наименований объектов (StrAssocArray)
		uint32 CRC_;            // Контрольная сумма
		uint32 SCtxStOffs;      // Смещение до сохраненного состояния контекста сериализации
		int32  UserID;          // ИД пользователя, создавшего пакет
		uint8  Reserve[8];      //
		S_GUID SrcDivUuid;      // GUID раздела-отправителя //
		S_GUID DestDivUuid;     // GUID раздела-получателя  //
		uint8  Reserve2[32];    // @reserve
	};
	struct IndexItem {     // @persistent @size=48 (before v5.6.8 - 32)
		int32  ObjType;
		union {
			int32  ObjID;       // Ид объекта в разделе-отправителе
			int32  SrcID;       // Для пакета сравнения синхронизации. Ид объекта в разделе-отправителе
		};
		PPCommSyncID CommID;
		uint16 Flags;           // PPObjPack::fXXX
		uint32 ObjNamePos;      // Позиция наименования объекта в массиве имен
		union {
			int32  ObjOffs;     // Адрес данных пакета объекта (смещение в файле)
			int32  DestID;      // Для пакета сравнения синхронизации. Ид объекта в разделе-получателе (по таблице отправителя)
		};
		LDATETIME Mod;          //
		int32  Priority;        //
		uint8  Reserve[12];     // @reserve
	};
	//
	//
	//
	struct PacketStat {
		PacketStat();

		PPObjectTransmit::Header Hdr;
		SArray Items;
		StringSet NameList;
	};

	static long DefaultPriority;
	static long DependedPriority;
	static int SLAPI ReadConfig(PPDBXchgConfig *);
	static int SLAPI EditConfig();
	static int SLAPI IncrementCharryOutCounter();
	static int SLAPI TransmitModifications(PPID destDBDiv, const ObjTransmitParam *);
	static int SLAPI TransmitModificationsByDBDivList(ObjTransmitParam *);
	static int SLAPI TransmitBills(PPID destDBDiv, const BillTransmitParam * pParam);
	static int SLAPI TransmitBillsByDBDivList(BillTransmitParam * pParam);
	static int SLAPI ReceivePackets(const ObjReceiveParam *);
	static int SLAPI Transmit(PPID dbDivID, const PPObjIDArray * pObjAry, const ObjTransmitParam * pParam);
	static int SLAPI Transmit(const PPIDArray * pDBDivAry, const PPObjIDArray * pObjAry, const ObjTransmitParam * pParam);
	static int SLAPI GetHeader(const char * pFileName, PPObjectTransmit::Header *);
	static int SLAPI ReadFileStat(const char * pFileName, PacketStat & rStat);
	static SString & SLAPI GetQueueFilePath(SString & rBuf);
	//
	//	Вероятные ошибки синхронизации объектов:
	//	-(1) В приемнике отсутствует синхронизация объекта, соответствующая //
	//	  синхронизации в источнике
	//	-(2) Наименования синхронизированных объектов значительно различаются //
	//	-(3) Не эквивалентны триплеты {CommID, SrcID, DestID} в источнике и приемнике
	//	-(4) В приемнике отсутствует объект, для которого, тем не менее,
	//	  существует синхронизация в источнике и в приемнике
	//
	//static int SLAPI ReceiveCmpPackets(TempSyncCmpTbl * pTbl);

	SLAPI  PPObjectTransmit(TransmitMode, int syncCmp, int recoverTransmission);
	SLAPI ~PPObjectTransmit();

	int    SLAPI SetDestDbDivID(PPID);
	int    SLAPI CreateTransmitPacket(long extra = 0);
	int    SLAPI PostObject(PPID objType, PPID id, int otup /* PPOTUP_XXX */, int syncCmp);
	int    SLAPI CommitQueue(const PPIDArray & rSrcDivList, int forceDestroyQueue);
	int    SLAPI CommitAck();
	int    SLAPI UpdateSyncCmpItem(TempSyncCmpTbl *, PPID objType, PPCommSyncID commID);
	int    SLAPI RegisterDependedNonObject(PPObjID objid, PPCommSyncID * pCommID, int use_ta);
	int    SLAPI AcceptDependedNonObject(PPObjID foreignObjId, PPID primaryID, const LDATETIME * pModDtm, int use_ta);
	int    SLAPI SearchQueueItem(PPID objType, PPID objID, PPID dbID, ObjSyncQueueTbl::Rec * pRec);
	ObjSyncCore SyncTbl;
private:
	struct OtFilePoolItem {
		long   FileId;        // ->ObjSyncQueue.ID Идентификатор файла
		SVerT InVer;         // Версия входящего файла
		long   AckCount;      //
		SString OrgFileName;  // Имя оригинального файла (только имя и расширение)
		SFile  F;             // Input stream
		SFile  A;             // Acknowledge stream
		SBuffer SCtxState;    // С каждым входным файлом ассоциируется собственный буфер состояния контекста сериализации
	};
	struct RestoreObjItem {
		PPID   QueueID;       // Идентификатор записи в таблице ObjSyncQueue
		PPObjID Oi;           // Идентификатор "чужого" объекта
		PPCommSyncID CommID;  // Общий идентификатор объекта
		int16  Flags;         // PPObjPack::fXXX
		PPID   DBID;          // Раздел базы данных, из которого получен объект
		PPID   PrimID;        // Идентификатор объекта в собственном разделе (заполняется после акцепта объекта)
		LDATETIME Mod;        // Вреия модифификации объекта в разделе DBID
		long   FileId;        // Идентификатор файла, в котором хранится пакет объекта
		SVerT InVer;         // Версия, создавшая входящий файл
		uint32 ObjOffs;       // Смещение пакета объекта в файле
		char   ObjName[128];  // Наименование объекта
	};
public:
	struct RestoreObjBlock {
		SLAPI  RestoreObjBlock(ObjSyncQueueCore * pQueue, PPObjectTransmit * pOt);
		OtFilePoolItem * SLAPI SearchFile(long fileId);
		int    SLAPI SetQueueItem(const ObjSyncQueueTbl::Rec &, RestoreObjItem * pItem);
		int    SLAPI PushRestoredObj(PPID dbID, PPObjID oi);
		int    SLAPI PopRestoredObj(PPID dbID, PPObjID oi);
		int    SLAPI DetectRecur(PPID dbID, PPObjID oi) const;

		ObjSyncQueueCore * P_Queue;
		TSCollection <OtFilePoolItem> Fp;
		PPIDArray ProcessedList;
		SStack S;
		PPObjectTransmit * P_Ot; // @notowned
	};
private:
	static int SLAPI WriteConfig(PPDBXchgConfig *, int use_ta);
	static int SLAPI LockReceiving(int unlock); // @<<PPObjectTransmit::ReceivePackets
	static int SLAPI CheckInHeader(const PPObjectTransmit::Header * pHdr, int checkVer);

	PPObject * FASTCALL _GetObjectPtr(PPID objType);
	int    SLAPI OpenInPacket(const char * pFileName, PPObjectTransmit::Header * = 0);
	int    SLAPI CloseInPacket();
	int    SLAPI CloseOutPacket();
	int    SLAPI MakeTransmitFileName(SString & rFileName, S_GUID * pDbDivUuid);
	void   SLAPI SetupHeader(uint type, PPID dest, PPObjectTransmit::Header *);
	int    SLAPI Write(FILE * stream, void *, size_t);
	int    SLAPI Read(FILE * stream, void *, size_t);
	PPObject * SLAPI GetObjectPtr(PPID obj);
	int    SLAPI UpdateInHeader(FILE * stream, const PPObjectTransmit::Header *);
	int    SLAPI MakeCommIDList(int use_ta);
	int    SLAPI RestoreObj(RestoreObjBlock & rBlk, RestoreObjItem & rItem, PPID * pPrimID);
	int    SLAPI PopRestoredObj(SStack *,  PPObjID oi);
	PPObjectTransmit::IndexItem * SLAPI TmpTblRecToIdxItem(const ObjSyncQueueTbl::Rec * pRec, IndexItem * pItem);
	int    SLAPI EnumObjectsByIndex(PPObjID * pObjId, ObjSyncQueueTbl::Rec * pRec);
	int    SLAPI NeedRestoreObj(PPID objType, const PPObjectTransmit::RestoreObjItem & rItem, PPID * pPrimID);
	//
	// Descr: Возвращает информацию о синхронизации объекта из другого раздела БД.
	//   По указателю pPrimID присваивает первичный ид объекта, в буфер по указателю pObjName
	//   копируется наименование объекта.
	// Returns:
	//   1  - информация о синхронизации найдена и найден объект.
	//   -1 - не найдена информация о синхронизации объекта
	//   -2 - информация о синхронизации найдена, но первичный ид = 0
	//   -3 - информация о синхронизации найдена, но не найден объект с ид *pPrimID
	//   0  - ошибка
	//
	int    SLAPI GetPrivateObjSyncData(PPID objType, PPCommSyncID commID, PPID * pPrimID, LDATETIME * pModDtm, char * pObjName, size_t bufLen);
	int    SLAPI PutObjectToIndex(PPID obj, PPID id, int otup /* PPOTUP_XXX */, int innerUpdProtocol = PPOTUP_DEFAULT, long extra = 0);
	//
	// Descr: Заносит в поток передачи данных информацию о синхронизации объекта
	//   типа objType с идентификатором id.
	//
	int    SLAPI PutSyncCmpToIndex(PPID objType, PPID id);
	int    SLAPI SetupSyncCmpRec(const ObjSyncQueueTbl::Rec * pQueueRec, TempSyncCmpTbl::Rec * pRec);
	int    SLAPI RestoreFromStream(const char * pInFileName, FILE * stream, TempSyncCmpTbl * pTbl);
	int    SLAPI PushObjectsToQueue(PPObjectTransmit::Header & rHdr, const char * pInFileName, FILE * pInStream, int use_ta);
	//
	// Descr:
	// Returns:
	//   >0 - инициализация прошла успешно
	//   <0 - пакет данных отклоняется поскольку требует более позднюю версию системы
	//
	int    SLAPI StartReceivingPacket(const char * pFileName, const void * /*PPObjectTransmit::Header*/);
	int    SLAPI InitContextSrcDiv(PPID dbDivID);
	int    SLAPI LogRcvObj(int msgId, const PPObjectTransmit::RestoreObjItem & rItem);

	struct Ack { // @persistent(DBX) @size=48
		PPID   Obj;            // If Obj == -1 then FileName contains name of received file
		PPID   Id;             //
		PPCommSyncID CommId;   //
		int16  Reserve;        // @alignment
		uint8  Reserve2[12];
		union {
			LDATETIME DT;
			char   FileName[20];
		};
	};
	TransmitMode Mode;
	int    CtrError;           // @*PPObjectTransmit::PPObjectTransmit Признак ошибки создания //
	int    SyncCmpTransmit;    // Признак передачи сравнения синхронизации объектов
	int    IamDispatcher;      // Признак того, что наш раздел является диспетчерским
	int    RecoverTransmission; // @v8.2.3 Признак восстановительной передачи
	SString InFileName;        //
	Header InHead;             //
	PPID   DestDbDivID;        //
	DBDivPack DestDbDivPack;   // @*PPObjectTransmit::SetDestDbDivID
	DBDivPack SrcDbDivPack;    // @*PPObjectTransmit::StartReceivingPacket
	DBDivPack ThisDbDivPack;   // @*PPObjectTransmit::PPObjectTransmit
	StringSet ObjNameList;     // Список имен объектов
	ObjCollection * P_ObjColl; //
	ObjTransmContext Ctx;      // Контекст обмена данными, передаваемый методам Read и Write обрабатываемых объектов
	ObjSyncQueueTbl * P_TmpIdxTbl;
	ObjSyncQueueCore * P_Queue;
	FILE * P_OutStream;
	FILE * P_InStream;

	PPObjDBDiv DObj;
	TSCollection <DBDivPack> SrcDivPool;
};
//
// Бюджеты
//
struct PPBudget {
	int32  ObjType;
	int32  ID;
	char   Name[48];
	char   Code[20];
	int32  ParentID;
	LDATE  LowDt;
	LDATE  UppDt;
	long   Flags;
	int16  Cycle;
	char   Reserve[54];
};

typedef TSArray <BudgetItemTbl::Rec> BudgetItemsList;

class BudgetItemCore : public BudgetItemTbl {
public:
	SLAPI  BudgetItemCore();
	int    SLAPI Search(PPID id, void * = 0);
	int    SLAPI Search(PPID budgetID, PPID acc, PPID kind, LDATE dt, void * pRec);
	int    SLAPI PutItem(PPID * pID, BudgetItemTbl::Rec *, int useTa);
	int    SLAPI GetItemsByBudget(PPID budgetID, PPID accID, long kind, BudgetItemsList * pItems);
	int    SLAPI PutItems(BudgetItemsList * pItems, int useTa);
	int    SLAPI PutItem_(PPID * pID, BudgetItemTbl::Rec * pRec, int useTa);
private:
};

class PPBudgetPacket {
public:
	SLAPI PPBudgetPacket();
	PPBudgetPacket & FASTCALL operator = (const PPBudgetPacket &);
	void   SLAPI Init();
	int    SLAPI EnumItems(uint * pIdx, BudgetItemTbl::Rec * pRec);
	int    SLAPI PutItems(BudgetItemsList * pList);
	int    SLAPI AddItem(BudgetItemTbl::Rec * pRec);
	int    SLAPI UpdateItem(uint pos, BudgetItemTbl::Rec * pRec);
	int    SLAPI DelItem(uint pos, PPID id);

	PPBudget Rec;
	TSArray <PPBudget> ScenList;
private:
	BudgetItemsList Items;
};

#define SEL_ALL_BUDGETS -1000000000L

class PPObjBudget : public PPObjReference {
public:
	SLAPI  PPObjBudget(void * extraPtr = 0);
	SLAPI ~PPObjBudget();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);

	int    SLAPI EditLine(PPID * pID, PPIDArray * pIdList, PPID budgetID, LDATE dt);
	int    SLAPI GetPacket(PPID id, PPBudgetPacket *);
	int    SLAPI PutPacket(PPID * pID, PPBudgetPacket *, int use_ta);
	int    SLAPI PutRec(PPID * pID, PPBudget *, int use_ta);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI AddLineBySample(PPID * pID, PPID sampleID);
	int    SLAPI GetChildBudgets(PPID parentID, PPIDArray * pChildList);
	int    SLAPI ValidateItem(BudgetItemTbl::Rec * pRec);
	int    SLAPI InitItemsCycleList(const BudgetItemTbl::Rec * pRec, BudgetItemsList * pList);
	int    SLAPI FormatDate(PPID budgetID, int16 cycle, LDATE dt, SString & rText);

	BudgetItemCore ItemsTbl;
private:
	int SLAPI Helper_Edit(PPBudgetPacket * pPack);
	int SLAPI Helper_EditLine(BudgetItemTbl::Rec * pRec);
	int SLAPI Helper_EditLines(PPID initID, BudgetItemsList * pList);

	SString StrWeeks;
	SString StrMonthes;
	SString StrQuarts;
	SString StrSemiYear;
};
//
// Шаблоны бизнес-показателей
//
struct PPBizScTempl {
	long   Tag;            // Const=PPOBJ_BIZSCTEMPL
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       //
	long   Flags;          //
	char   Reserve[68];    // @reserve
};

struct PPBizScTemplCol {
	enum {
		tDate         = 0,
		tPeriod       = 1,
		tPeriodChange = 2
	};
	enum {
		fInvisible = 0x00000001L
	};
	long   Id;
	long   Flags;
	LDATE  DtLow;
	LDATE  DtUp;
	int16  Type;
	int16  Reserve1;
	char   Symb[24];
	char   Name[20];
	char   Reserve2[80];
};

struct PPBizScTemplRow {
	long   Id;
	PPID   BizScId;
	char   Name[20];
	char   Symb[24];
	char   Formula[128];
};

struct PPBizScTemplCell {
	long   Id;
	long   ColId;
	long   RowId;
	PPID   BizScId;
	char   Formula[128];
};

class PPBizScTemplPacket {
public:
	SLAPI  PPBizScTemplPacket();
	SLAPI ~PPBizScTemplPacket();
	PPBizScTemplPacket & FASTCALL operator = (const PPBizScTemplPacket &);

	void   SLAPI Init();
	int    SLAPI AddCol(uint * pPos, PPBizScTemplCol * pCol);
	int    SLAPI GetCol(PPID colId, uint * pPos, PPBizScTemplCol * pCol);
	int    SLAPI RemoveCol(uint pos);
	int    SLAPI GetCellListInclEmpty(long colId, long rowId, TSArray <PPBizScTemplCell> * pCells);
	int    SLAPI GetCellList(long colId, long rowId, TSArray <PPBizScTemplCell> * pCells);
	int    SLAPI GetRow(PPID rowId, uint * pPos, PPBizScTemplRow * pRow);
	int    SLAPI AddRow(uint * pPos, PPBizScTemplRow * pRow);
	int    SLAPI RemoveRow(PPID rowId);
	int    SLAPI AddCell(uint * pPos, PPBizScTemplCell * pCell);
	int    SLAPI UpdateCell(uint * pPos, PPBizScTemplCell * pCell);
	int    SLAPI CalcValues(long colId, long rowId, BizScoreCore * pBizScTbl, RealArray & rValList);

	PPBizScTempl Rec;
	TSArray <PPBizScTemplCol>  Cols;
	TSArray <PPBizScTemplRow>  Rows;
	TSArray <PPBizScTemplCell> Cells;
};

class PPObjBizScTempl : public PPObjReference {
public:
	SLAPI  PPObjBizScTempl(void * extraPtr = 0);
	SLAPI ~PPObjBizScTempl();
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID, PPBizScTemplPacket *);
	int    SLAPI PutPacket(PPID *, PPBizScTemplPacket *, int use_ta);
private:
};
//
//
//
struct ObjCollectionEntry {
	SLAPI  ObjCollectionEntry();
	PPID   ObjType;
	PPObject * ObjPtr;
};

class ObjCollection : private TSArray <ObjCollectionEntry> {
public:
	SLAPI  ObjCollection();
	SLAPI ~ObjCollection();
	PPObject * SLAPI GetObjectPtr(PPID objType);

	int    SLAPI CreateFullList(long flags /* gotlfXXX */);
private:
	virtual void FASTCALL freeItem(void * pItem);
};
//
//
//
class GCTIterator {
public:
	struct GoodsRestEntry {
        PPID   GoodsID;
        PPID   LocID;
        LDATE  Dt;
        double Rest;
	};

	class GoodsRestArray : public TSArray <GoodsRestEntry> {
	public:
		SLAPI  GoodsRestArray();
		void   SLAPI Init();
		int    SLAPI SetAccumItem(PPID goodsID, PPID locID, LDATE dt, double qtty);
		int    SLAPI SetInitRest(PPID goodsID, PPID locID, double rest);
		void   SLAPI Finish();
		//
		double SLAPI GetRest(PPID goodsID, PPID locID, LDATE dt) const;
		double SLAPI GetRest(PPID goodsID, LDATE dt) const;
		double SLAPI GetAverageRest(PPID goodsID, PPID locID, const DateRange & rPeriod) const;
		double SLAPI GetAverageRest(PPID goodsID, const DateRange & rPeriod) const;

		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	private:
		enum {
			stAccumulation = 0x0001
		};
		long   State;
		DateRange AccumPeriod;
		PPIDArray LocList; // @!Sort()
	};
	struct ItemExtension {
		PPID   LinkBillID; // @v9.6.8
		double LinkQtty;
		double LinkCost;
		double LinkPrice;
	};

	enum {
		aorfGeneric        = 0x0001,
		aorfThereAreDrafts = 0x0002,
		aorfThereAreOrders = 0x0004,
		aorfOnlyDrafts     = 0x0008,
		aorfOnlyOrders     = 0x0010,
		aorfIntrRcpt       = 0x0020
	};
	static long  SLAPI AnalyzeOp(PPID opID, PPIDArray * pResultOpList);

	SLAPI  GCTIterator(const GCTFilt * pFilt, const DateRange * pPeriod);
	SLAPI ~GCTIterator();
	int    SLAPI First(TransferTbl::Rec *, BillTbl::Rec *);
	int    SLAPI Next(TransferTbl::Rec *, BillTbl::Rec *);
	int    SLAPI First(TransferTbl::Rec *, BillTbl::Rec *, ItemExtension * pExt);
	int    SLAPI Next(TransferTbl::Rec *, BillTbl::Rec *, ItemExtension * pExt);
	const  GCTIterator::GoodsRestArray * GetGoodsRestList() const;
private:
	int    SLAPI Iterate(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, ItemExtension * pExt);
	int    SLAPI InitQuery(int cpMode);
	int    SLAPI NextOuter();
	int    SLAPI TrfrQuery(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    SLAPI CpTrfrQuery(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    SLAPI NextTrfr(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    SLAPI NextCpTrfr(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    SLAPI AcceptTrfrRec(TransferTbl::Rec *, BillTbl::Rec *, GCTIterator::ItemExtension * pExt);
	int    SLAPI AcceptCpTrfrRec(TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    FASTCALL CheckBillForFilt(const BillTbl::Rec & rBillRec) const;
	int    FASTCALL SetupGoodsRest(TransferTbl::Rec * pRec);
	GCTFilt Filt;
	DateRange Period; //

	enum {
		stUseGoodsList   = 0x0001,
		stThereAreDrafts = 0x0002, // @v9.4.1 Среди видов операций для анализа присутствуют драфт-операции
		stThereAreOrders = 0x0004,
		stOnlyDrafts     = 0x0008,
		stOnlyOrders     = 0x0010
	};
	enum {
		bwNone  = 0,
		bwLot   = 1,
		bwBill  = 2,
		bwGoods = 3
	};
	enum {
		iterphaseInit   = 0,
		iterphaseTrfr   = 1,
		iterphaseCpInit = 2,
		iterphaseCpTrfr = 3
	};

	class GCT_BillCache {
	public:
		SLAPI  GCT_BillCache();
		int    SLAPI SetupFilt(const GCTFilt * pFilt, const ObjIdListFilt & rArList, int disableCaching);
		int    FASTCALL Get(PPID billID, BillTbl::Rec * pRec);
		int    FASTCALL CheckBillForAgent(PPID billID) const;
	private:
		int    FASTCALL CheckBillRec(const BillTbl::Rec *);
		int    DisableCaching;
		PPObjBill * P_BObj;
		GCTFilt   Filt;
		ObjIdListFilt OpList;
		PPIDArray ExtIdList;   // Список идентификаторов документов, соответствующих Filt.AgentID (если это поле ненулевое).
		ObjIdListFilt ArList;  // Список контрагентов, выбранных по группирующему отношению к Person(Filt.ArID)
	};

	GCTIterator::GoodsRestArray * P_GoodsRestList;
	PPID   CurrID;
	int    ByWhat_;      // bwXXX
	int    IterPhase;    // iterphaseXXX
	long   SurrOprNo;    // Так как CpTransf не содержит поля OprNo эта переменная обеспечивает
		// суррогатный счетчик для обеспечения уникальности результирующих элементов итераций.
	long   State;
	Transfer   * Trfr;
	CpTransfCore * CpTrfr;
	BillCore   * BT;
	BExtQuery  * trfr_q;
	BExtQuery  * rcpt_q;
	BExtQuery  * cptrfr_q;
	//BillTbl::Rec   CurBillRec;
    struct CurrentBillBlock {
    	SLAPI  CurrentBillBlock()
    	{
    		P_Pack = 0;
    		P_WrOffPack = 0;
    	}
    	SLAPI ~CurrentBillBlock()
    	{
    		Clear();
    	}
    	void   SLAPI Clear()
    	{
    		ZDELETE(P_Pack);
    		ZDELETE(P_WrOffPack);
    	}
        PPBillPacket * P_Pack;
		PPBillPacket * P_WrOffPack; // Агрегированный пакет документов списания
    };
    CurrentBillBlock Cbb;
	GCT_BillCache * BCache;
	PPIDArray BillList;
	PPIDArray SupplAgentBillList; // @v7.0.11 Список документов, сопоставленных с агентом поставщика (Filt.SupplAgentID)
	PPIDArray GoodsArray;
	ObjIdListFilt OpList;  // @!GCTIterator::GCTIterator
	ObjIdListFilt ArList;  // Список контрагентов, выбранных по группирующему отношению к Person(Filt.ArID)
};
//
//
//
struct PrcssrUnifyPriceFilt : public PPBaseFilt { // @persistent
	PrcssrUnifyPriceFilt();
	int    SLAPI Setup(int _costReval, PPID _loc, PPID _suppl);
	double SLAPI CalcPrice(double cost, double price) const;
	int    SLAPI IsCostBase() const;

	enum {
		//fUnify    = 0x0001,
		fConfirm  = 0x0002,
		fCostBase = 0x0004, // При изменении цены по коэффициенту за
		//                     базу принимать цену поступления //
		// Этот флаг может быть установлен только тогда, когда pctVal != 0.
		// Если это не так, то возможны проблемы.
		fAverageCost     = 0x0008, // Усреднение цен поступления //
		fExcludeGoodsGrp = 0x0010, // Исключить указанную группу
		fAbsVal          = 0x0020, // При изменении цены, AbsVal - сумма наценки, иначе процент наценки
		//fLastLotOnly     = 0x0040  // @v8.4.8 Переоценивать только последний лот (если fUnify, то данный флаг не действует)
	};
	//
	// Descr: Режимы унификации цен и переоценки
	//
	enum {
		mLastLot = 1, // Переоценить только последний лот
		mUnify   = 2, // Унифицировать цены по всем лота, опираясь на цену последнего
		mEachLot = 3  // Переоценить каждый лот
	};
	uint8  ReserveStart[28]; // @anchor @reserve
	long   Mode;       // Режим унификации PrcssrUnifyPriceFilt::mXXX
	int    CostReval;  // Изменение цен поступления по поставщику
	PPID   OpKindID;
	PPID   LocID;
	PPID   GoodsGrpID;
	PPID   SupplID;
	PPID   QuotKindID; // Котировка, по которой следует высчитывать цены. if QuotKindID != 0 then PctVal ignored
	long   Flags;
	double PctVal;     // Процент изменения цен
	double OldPrice;   // старая цена
	short  RoundDir;   // Направление округления //
	uint16 Reserve;    // @alignment
	double RoundPrec;  // Точность округления    //
	long   ReserveEnd; // @anchor @reserve
};

class PrcssrUnifyPrice {
public:
	SLAPI  PrcssrUnifyPrice();
	int    SLAPI Process(const PrcssrUnifyPriceFilt *);
	int    SLAPI EditParam(PrcssrUnifyPriceFilt *);
private:
	int    SLAPI ProcessGoods(const Goods2Tbl::Rec * pGoodsRec, PPID * pTurnedBillID);
	int    SLAPI ProcessGoods2(const Goods2Tbl::Rec * pGoodsRec, PPID * pTurnedBillID);
	int    SLAPI InitBillPack();
	int    SLAPI TurnBillPack();
	int    SLAPI CalcNewPrice(const ReceiptTbl::Rec & rLotRec, double * pPrice);

	PrcssrUnifyPriceFilt P;
	PPObjBill * P_BObj;
	PPObjGoods  GObj;
	PPObjQuotKind QkObj;
	PPBillPacket BPack;
};
//
// @ModuleDecl(PPViewBill)
//
enum BrowseBillsType {
	bbtUndef          =  BBT_UNDEF,          //
	bbtGoodsBills     =  BBT_GOODSBILLS,     //
	bbtOrderBills     =  BBT_ORDERBILLS,     //
	bbtAccturnBills   =  BBT_ACCTURNBILLS,   //
	bbtInventoryBills =  BBT_INVENTORYBILLS, //
	bbtPoolBills      =  BBT_POOLBILLS,      //
	bbtClientDebt     =  BBT_CLIENTDEBT,     //
	bbtClientRPayment =  BBT_CLIENTRPAYMENT, //
	bbtDraftBills     =  BBT_DRAFTBILLS,     //
	bbtRealTypes      =  BBT_REALTYPES,      // Товарные, бухгалтерские документы и оплаты
	bbtWmsBills       =  BBT_WMSBILLS        // Документы складских операций
};
//
// Descr: Фильтр выборки документов.
// @todo Заменить OpID на OpList дабы можно было отбирать документы по списку видов операций.
//
class BillFilt : public PPBaseFilt {
public:
	struct FiltExtraParam {
		SLAPI  FiltExtraParam(long setupValues, BrowseBillsType bbt);
		long   SetupValues; // Если !0 то функция PPViewBill::CreateFilt установит в создаваемом
			// фильтре разумные параметры, основываясь не текущем состоянии.
		BrowseBillsType Bbt;
	};

	SLAPI  BillFilt();
	BillFilt & FASTCALL operator = (const BillFilt &);
	virtual int SLAPI Describe(long flags, SString & rBuf) const;
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
	//
	// Descr: Инициализирует поля фильтра.
	// ARG(setupVal   IN): Если этот параметр не нулевой, то устанавливает значения некоторых
	//   полей таким, образом, чтобы максимально соответствовать потребностям
	//   больщинства пользователей.
	// ARG(extraParam IN): Этот параметр должен иметь одно из значений BrowseBillsType.
	// Returns:
	//   >0 - инициализация завершилась успешно
	//   0  - ошибка
	//
	// int    SLAPI Init(int setupValues, long extraParam);
	void   FASTCALL SetupBrowseBillsType(BrowseBillsType);
	enum bff_tag {
		fShowDebt       = 0x00000001, // Показывать долг
		fDebtOnly       = 0x00000002, // Выводить только неоплаченные документы
		// if(fOrderOnly) then выводить только не закрытые заказы
		fPaymNeeded     = 0x00000004, // Выводить документы, требующие оплаты (независимо от операции)
		fFreightedOnly  = 0x00000008, // Только зафрахтованные документы (BillTbl::Rec.Flags & BILLF_FREIGHT)
		fCashOnly       = 0x00000010, // Документы розницы через кассовый узел
		fOrderOnly      = 0x00000020, // Заказы
		fInvOnly        = 0x00000040, // Инвентаризация //
		//
		// Если флаг fAsSelector установлен, то броузер работает как
		// селектор. При этом, если был выбран какой-то документ,
		// то поле sel содержит его идентификатор.
		//
		fAsSelector     = 0x00000080,
		fLabelOnly      = 0x00000100, // Показывать только меченые документы
		fAllCurrencies  = 0x00000200, // Показывать все валюты
		fAccturnOnly    = 0x00000400, // Только бухгалтерские документы
		fSetupNewBill   = 0x00000800, // Формировать поля нового док в соответствии с фильтром
		fDraftOnly      = 0x00001000, // Драфт-документы
		fDebtsWithPayments = 0x00002000, // Долговые документы с оплатами
		fPoolOnly       = 0x00004000, // Только пулы документов
		fShowAck        = 0x00008000, // Показывать с номерами подтверждений
		fEditPoolByType = 0x00010000, // Изменения пула производить с помощью AssocID
		fIgnoreRtPeriod = 0x00020000, // @internal Функция PPViewBill::Init не
			// должна устанавливать пересечение this->Period с периодом доступа на чтение.
		fShowWoAgent    = 0x00040000, // Показывать только документы без агента
		fBillListOnly   = 0x00080000, // Если задан список документов List, то не проверять остальные
			// критерии фильтра. Если List.IsEmpty, то это флаг игнорируется.
		fWmsOnly        = 0x00100000, // Только документы складских операций
		fUnshippedOnly  = 0x00200000, // Только не отгруженные документы !(BillTbl::Rec::Flags & BILLF_SHIPPED)
		fShippedOnly    = 0x00400000, // Только отгруженные документы (BillTbl::Rec::Flags & BILLF_SHIPPED)
		fDiscountOnly   = 0x00800000, // Только со скидкой на весь документ
		fDescOrder      = 0x01000000, // @v7.5.5  Сортировка в обратном порядке

		fAddZeroLoc     = 0x02000000, // @v7.5.8  При построении выборки добавлять нулевую локацию к списку
			// складов, по которому фильтруется отчет.
		fExportEDI      = 0x04000000  // @v8.0.5 Специальный флаг, используемый при 'кспорте
	};
	enum {
		fDenyAdd    = 0x0001,
		fDenyUpdate = 0x0002,
		fDenyRemove = 0x0004
	};
	enum cc_mode {
		ccmDebts    = 1,   // Долговые документы контрагента
		ccmRPayments       // Зачетные документы контрагента
	};
	enum {
		ordByDate    = 0,
		ordByCode    = 1,
		ordByObject  = 2
	};
	//
	// Идентификаторы (дополнительных) полей для отображения в таблице //
	//
	enum {
		dliFreightIssueDate   = 1001, // Дата отправления (из фрахта)
		dliFreightArrivalDate,        // Дата доставки (из фрахта)
		dliDueDate,                   // Дата исполнения документа
		dliAgentName,                 // Наименование агента по документу
		dliAlcoLic,                   // Регистр алкогольной лицензии, ассоциированный (прямо или косвенно) с документом
		dliDlvrAddr                   // @v8.7.9 Адрес доставки
	};
	char   ReserveStart[32]; // @anchor
	long   Tag;            // @#0 reserved
	DateRange DuePeriod;   // Период исполнения //
	uint32 Count;          // Максимальное количество документов в выборке
	int16  Ft_Declined;    // @v8.3.3 Признак BILLF2_DECLINED: (0) ignored, (< 0) off, (> 0) on
	int16  Ft_Reserve;     // @v8.8.6 @reserved
	PPID   StorageLocID;   // @v8.8.6 Место хранение, ассоциированное с фрахтом документа
	int16  EdiRecadvStatus;     // @v9.1.6 Статус RECADV по каналу EDI. -1 - с нулевым статусом
	int16  EdiRecadvConfStatus; // @v9.1.6 Статус подтверждения на RECADV по каналу EDI. -1 - с нулевым статусом
	uint8  Reserve[8];     // @#0 !Использовать начиная со старших адресов // @v8.8.6 [18]-->[12] // @v9.1.6 [12]-->[8]
	BrowseBillsType Bbt;   // @#1f
	DateRange Period;      //
	DateRange PaymPeriod;  // Период поступления платежей (Flags & fShowDebt)
	PPID   MainOrgID;      // Главная организация //
	PPID   PoolOpID;       // Ид операции пула (ограничивает выбор вида операции)
	PPID   OpID;           //
	PPID   CurID;          // Ид валюты
	PPID   AccSheetID;     // Если из операции нельзя определить таблицу статей,
	//                то эта таблица может быть взята из поля sheet
	PPID   ObjectID;       // ->Article.ID
	PPID   Object2ID;      // ->Article.ID
	PPID   PayerID;        // ->Article.ID Плательщик
	PPID   AgentID;        // ->Article.ID Агент
	PPID   CreatorID;      // ->Ref(PPOBJ_USR) Пользователь, создавший документ
	PPID   StatusID;       // ->Ref(PPOBJ_BILLSTATUS) Статус документа
	PPID   AssocID;        //
	PPID   PoolBillID;     // Обобщающий документ
	long   Flags;          //
	uint   DenyFlags;      //
	int16  ClientCardMode; // enum cc_mode (ccmXXX)
	int16  Ft_STax;        // (0) ignored, (< 0) off, (> 0) on
	int16  Ft_ClosedOrder; // (0) ignored, (< 0) off, (> 0) on
	int16  SortOrder;      // Сортировка
	PPID   Sel;            //
	RealRange AmtRange;    // Диапазон номинальной суммы
	long   ReserveEnd;     // @anchor
	SysJournalFilt * P_SjF; //
	ObjIdListFilt List;    // Список идентификаторов документов, которые следует показать
	ObjIdListFilt LocList; // Список складов, по которым следует показывать документы
	TagFilt * P_TagF;      // Теги документов
	PPViewDisplayExtList Dl; // @v8.2.9 Список дополнительных полей для отображения //
};

struct BillViewItem : public BillTbl::Rec {
	double Debit;
	double Credit;
	double Saldo;
	LDATE  LastPaymDate; // Дата последнего платежа по документу
};

typedef int (*BillViewEnumProc)(BillViewItem *, long);

struct BillTotal {
	SLAPI  BillTotal();
	BillTotal & Reset();

	long   Count;
	double Sum;
	double Debt;
	AmtList Amounts;
	//
	// Fields for debt card
	//
	double InSaldo;
	double Debit;
	double Credit;
	double OutSaldo;
};

class ClientBankExportDef {
public:
	//
	// Descr: @constructor
	// ARG(pPeriod IN): Период, которому принадлежат 'кспортируемые платежные поручения.
	//
	SLAPI  ClientBankExportDef(const DateRange * pPeriod);
	SLAPI ~ClientBankExportDef();
	PPImpExpParam & SLAPI GetParam() const;
	int    SLAPI ReadDefinition(const char * pIniSection);
	int    SLAPI CreateOutputFile();
	int    SLAPI CloseOutputFile();
	int    SLAPI PutRecord(const PPBillPacket *, PPID debtBillID, PPLogger * pLogger);
	int    SLAPI GetStat(long * pAcceptedCount, long * pRejectedCount, double * pAmount);

	int    SLAPI PutHeader();
	int    SLAPI PutEnd();
private:
	//int    UseImpSection; // (testing purpose) Использовать описание импорта
	void * P_Helper;
};

class ClientBankImportDef {
public:
	static int SLAPI WriteAssocList(const SArray * pList, int use_ta);
	static int SLAPI ReadAssocList(SArray * pList);

	SLAPI  ClientBankImportDef();
	SLAPI ~ClientBankImportDef();
	PPImpExpParam & SLAPI GetParam() const;
	int    SLAPI ReadDefinition(const char * pIniSection);
	int    SLAPI ImportAll();
private:
	void * P_Helper;
};

class PPViewBill : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByDate,
		OrdByCode,
		OrdByObjectName,
		OrdByOpName
	};

	SLAPI  PPViewBill();
	SLAPI ~PPViewBill();

	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	virtual int   SLAPI ViewTotal();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;

	int    SLAPI EditFilt(BillFilt *, long) const;
	int    SLAPI Browse(int modeless);
	int    SLAPI AddItem(PPID * pID, PPID opID = 0);
	int    SLAPI AddItemBySample(PPID * pID, PPID sampleBillID);
	int    SLAPI AddBySCard(PPID * pID);
	int    SLAPI EditItem(PPID);
	int    SLAPI DeleteItem(PPID);
	int    SLAPI Print();
	int    SLAPI PrintTotal(const BillTotal *);
	int    SLAPI PrintBillInfoList();
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(BillViewItem *);
	int    SLAPI GetBillIDList(PPIDArray *);
	int    SLAPI CalcTotal(BillTotal *);
	int    SLAPI CalcItemTotal(PPID billID, BillTotalData * pTotal);
	int    SLAPI ExportBnkOrder();

	int    SLAPI ViewPayments(PPID, int kind);
	int    SLAPI ViewBillsByOrder(PPID);
	int    SLAPI WriteOffDraft(PPID);

	int    SLAPI DeleteBillFromPool(PPID billID);
	int    SLAPI AddBillToPool();

	int    SLAPI AttachBillToOrder(PPID billID);
	int    SLAPI AttachBillToDraft(PPID billID, BrowserWindow * pBrw);
	int    SLAPI CalcBillVATax(BVATAccmArray *);
	int    SLAPI ViewVATaxList();
	int    SLAPI ShowDetails(PPID billID);
	int    SLAPI ShowPoolDetail(PPBillPacket *);
	int    SLAPI ChangeFlags();
	int    SLAPI PrintBill(PPID billID, int addCashSummator);
	int    SLAPI PrintAllBills();
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    SLAPI Transmit(PPID billID, int transmitKind);
	int    SLAPI UpdateAttributes();
	//int    SLAPI ExportToAtlas(); // @v5.2.0 VADIM Obsolete
	// @v8.9.11 int    SLAPI ExportToEGAIS();
	int    SLAPI ExportGoodsBill(const PPBillImpExpParam * pBillParam, const PPBillImpExpParam * pBRowParam);
	int    SLAPI CreateMrpTab(PPID billID);
	int    SLAPI GetPacket(PPID billID, PPBillPacket * pPack) const; // <<PPALDD_BillInfoList::NextIteration
	int    SLAPI CheckIDForFilt(PPID, const BillTbl::Rec *);

	int    SLAPI SetIterState(const void *, size_t sz);
	const void * SLAPI GetIterState() const;
	static int TransmitByFilt(const BillFilt * pFilt, const ObjTransmitParam * pParam);

	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);

	struct PoolInsertionParam {
		PoolInsertionParam()
		{
			Verb = 2;
			AddedBillKind = bbtGoodsBills;
		}
		long   Verb;   // 1 - Insert New, 2 - Insert By Filt
		BrowseBillsType AddedBillKind;
		BillFilt Filt;
	};
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);

	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI CreateTempTable(IterOrder ord, int * pIsOrdTbl);
	int    SLAPI UpdateTempTable(PPID id);
	int    SLAPI Helper_EnumProc(PPID billID, const BillTbl::Rec *, int checkForFilt, BillViewEnumProc proc, long param);
		// @<<PPViewBill::Enumerator
	int    SLAPI Enumerator(BillViewEnumProc, long);
	int    SLAPI EnumerateDebtCard(BillViewEnumProc, long);
	int    SLAPI CalcDebtCardInSaldo(double *);
	int    SLAPI GetOpList(const BillFilt *, PPIDArray *, PPID * pSingleOpID) const;
	int    FASTCALL CheckFlagsForFilt(const BillTbl::Rec * pRec) const;
	int    SLAPI InitOrderRec(IterOrder ord, const BillTbl::Rec *, TempOrderTbl::Rec *);
	void   SLAPI InitTempRec(BillTbl::Rec *, TempBillTbl::Rec *);
	int    SLAPI SelectBillListForm(uint * form, int * ext, IterOrder * order);
	int    SLAPI InsertIntoPool(PPID billID, int use_ta);
	int    SLAPI RemoveFromPool(PPID, int use_ta);
	int    SLAPI UpdateInPool(PPID);
	int    SLAPI IsMemberOfPool(PPID);
	int    SLAPI EnumMembersOfPool(PPID * pBillID);
	int    SLAPI SetupPoolInsertionFilt(BillFilt *);
	int    SLAPI CreateTempPoolPacket(PPBillPacket *);
	int    SLAPI GetCommonPoolAttribs(LDATE *, PPID * pLocID, PPID * pOpID, PPID * pObjID);
	int    SLAPI SendAddBillMessage(PPID);
	int    SLAPI UniteReceiptBills(); // @<<PPViewBill::UniteBills
	int    SLAPI UniteSellBills();    // @<<PPViewBill::UniteBills
	int    SLAPI UniteInventory();    // @<<PPViewBill::UniteBills
	int    SLAPI Helper_ExportBnkOrder(const char * pSection, PPLogger & rLogger);

	BillFilt Filt;
	PPIDArray UpdateBillList; // для обновления измененнных документов в броузере
	int    CtrlX;             //
	int    UseOrderTblForIteration; // 0 - use TempBillTbl, else use TempOrderTbl
	uint   _IterC;            // Количество выполненных (успешных) итераций NextIteration
	PPID   SingleOpID;        //
	PPID   SingleLocID;       //
	PPID   LastSelID;         // Последний выбранный документ. Используется функцией AttachBillToOrder()
		// для последующего позиционирования курсора в таблице заказов.
	double InSaldo;           // For debt card
	void * P_IterState;       // Сохраняемое состояние итератора
	IterOrder TempOrder;      //
	PPObjLocation LocObj;     //
	PPObjArticle  ArObj;      //
	PPObjGoods    GObj;       //
	PPObjBill    * P_BObj;    //
	TempBillTbl  * P_TempTbl; //
	TempOrderTbl * P_TempOrd; //
	PPIDArray OpList;         //
	PPIDArray LocList_;       //
	ObjIdListFilt IdList;     // Список идентификаторов документов, которые должны быть в выборке
	PPBillPoolOpEx * P_BPOX;  // @# {(!Filt.PoolBillID && !Filt.PoolOpID) => P_BPOX==0}
	PoolInsertionParam Pip;   //
	PrcssrAlcReport * P_Arp;  // @v8.4.4

	friend int IterProc_CrTmpTbl(BillViewItem *, long p);
};
//
// @ModuleDecl(PPViewLinkedBill)
//
class LinkedBillFilt : public PPBaseFilt {
public:
	SLAPI  LinkedBillFilt();
	enum {
		lkPayments   =   0,  // Оплаты по документу
		lkCharge     =   1,  // Начисления ренты по документу
		lkReckon     =   2,  // Зачеты по документу
		lkByReckon   =   3,  //
		lkWrOffDraft =   5,  // Документы списания драфт-документа
		lkSelection  = 100   // Режим выбора просмотра связанных документов при котором программа
			// самостоятельно пытается выбрать существующие связанные документы и при неоднозначности
			// предоставляет выбор пользователю
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   BillID;
	int32  Kind;
	long   Flags;
	long   ReserveEnd;       // @anchor
};

struct LinkedBillViewItem : public BillTbl::Rec {
	double Payment;
	double Rest;
	int16  LinkKind;
	int16  Pad;
	PPID   LinkBillID; //
	PPID   RcknBillID; //
};

class PPViewLinkedBill : public PPView {
public:
	SLAPI  PPViewLinkedBill();
	SLAPI ~PPViewLinkedBill();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(LinkedBillViewItem * pItem);
private:
	static int    GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	struct Entry {
		PPID   ID;
		double Payment;
		double Rest;
		int16  LinkKind;
		int16  Pad;
		PPID   LinkBillID; //
		PPID   RcknBillID; //
	};
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	int    SLAPI MakeList();
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	LinkedBillFilt Filt;
	TSArray <Entry> List;
	PPObjBill * P_BObj;
	BillTbl::Rec Rec; // Запись документа Filt.BillID.
	double PrevPaym;  // Сумма платежей по документу Filt.BillID до вызова Init_
	int    PrevKind;
	StrAssocArray MemoList;
};
//
// @ModuleDecl(PPViewGoodsBillCmp)
//
class GoodsBillCmpFilt : public PPBaseFilt {
public:
	SLAPI  GoodsBillCmpFilt();
	GoodsBillCmpFilt & FASTCALL operator = (const GoodsBillCmpFilt & s);

	enum {
		fDiffQttyOnly = 0x0001
	};
	enum Ord {
		ordByGoodsName = 1,
		ordByDiffQtty,
		ordByDiffPrice
	};

	uint8  ReserveStart[36]; // @anchor
	long   Flags;
	long   Order;
	int    WhatBillIsHistory;
	long   Reserve;          // @anchor
	PPIDArray LhBillList;
	PPIDArray RhBillList;
};

typedef TempGoodsBillCmpTbl::Rec GoodsBillCmpViewItem;

class PPViewGoodsBillCmp : public PPView {
public:
	SLAPI  PPViewGoodsBillCmp();
	SLAPI ~PPViewGoodsBillCmp();

	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	//
	// Перед вызовом этой функции в фильтре должны быть инициализированы поля //
	// LhBillID и RhBillID.
	//
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GoodsBillCmpViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int SLAPI ViewTotal();
	virtual int SLAPI Print(const void * pHdr);
	int    SLAPI PutBillToTempTable(PPID billID, int side /* 1 - lh, 2 - rh */, int isHistory);
	int    SLAPI GetBillCodes(const GoodsBillCmpFilt *, SString & rLhCode, SString & rRhCode);
	int    SLAPI AddToBasketAll(int diffSign);

	GoodsBillCmpFilt Filt;
	TempGoodsBillCmpTbl * P_TempTbl;
	int    IterIdx;
	PPObjGoods GObj;
	PPObjBill * P_BObj;
	HistBillCore Hb;
};
//
//
//
struct InventoryViewItem : public InventoryTbl::Rec {
	SString FullGrpName;
};

class PPViewInventory : public PPView {
public:
	SLAPI  PPViewInventory();
	SLAPI ~PPViewInventory();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt * pFilt);
	virtual int  SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(InventoryViewItem *);
	int    SLAPI GetZeroByDefaultStatus() const;
	int    SLAPI GetUpdateStatus() const;
	//
	// Descr: Рассчитывает сумму инвентаризации и сохраняет документ.
	// Returns:
	//   >0 - документ был успешно сожранен
	//   <0 - документ не был сохранен по-скольку billID == 0
	//   0  - ошибка
	//
	int    SLAPI UpdatePacket(PPID billID);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Print(const void *);
	//
	int    CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	struct BrwHdr {
		PPID   BillID;
		long   OprNo;
		long   GoodsID;  // @v9.7.9
		long   Flags;    // @v9.7.9
	};
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI CheckLineForFilt(const InventoryTbl::Rec * pRec) const;
	int    SLAPI EditLine(PPID billID, long * pOprNo, PPID goodsID, const char * pSerial, double initQtty, int accelMode);
	int    SLAPI AddItem(TIDlgInitData * pInitData);
	int    SLAPI SelectByBarcode(int initChar, PPViewBrowser * pBrw);
	int    SLAPI SelectGoodsByBarcode(int initChar, PPID arID, Goods2Tbl::Rec * pRec, double * pQtty, SString * pRetCode);
	int    SLAPI UpdateTempTable(PPID billID, long oprno);
	int    SLAPI Build();
	int    SLAPI Correct();
	int    SLAPI ConvertBillToBasket();
	int    SLAPI ConvertBasketToBill();
	int    SLAPI ConvertBasket(PPBasketPacket * pPack, int sgoption, int priceByLastLot, int use_ta);
	int    SLAPI MakeTempOrdRec(const InventoryTbl::Rec * pRec, TempDoubleIDTbl::Rec * pOutRec);
	InventoryFilt Filt;
	enum {
		fIsZeroByDefault = 0x0001, // Операция документа инвентаризации подразумевает нулевой остаток по умолчанию.
		fSelGoodsByName  = 0x0002,
		fWasUpdated      = 0x0004
	};
	long   Flags;
	InventoryArray IterByGoods;
	//PPInventoryOpEx Ioe; // @*PPViewInventory::Init
	InventoryCore InvTbl;
	PPObjGoods GObj;
	GoodsIterator * P_GIter;
	GoodsGroupIterator * P_GgIter;
	PPObjBill * P_BObj;
	InventoryTbl * P_TempTbl;
	TempDoubleIDTbl * P_TempOrd;
	TempInventorySubstTbl * P_TempSubstTbl;
	//
	// Descr: Структура, ассоциирующая пару {BillID, OprNo} с суррогатным ключом SurrID.
	//   Кроме того, структура хранит StorageLocID, ассоциированный с BillID (пока в таблицу Inventory
	//   не будет введено это поле).
	//
	struct ExtraEntry {
		PPID   SurrID;
		PPID   BillID;
        long   OprNo;
        PPID   GoodsID;
        PPID   StorageLocID;
	};
	TSArray <ExtraEntry> ExtraList;
	PPID   CommonLocID; // Если для всех документов из фильтра склад одинаков, то его значение присваивается CommonLocID.
		// В противном случае CommonLocID = 0.
	LDATE  CommonDate; // Если для всех документов из фильтра дата одинакова, то она присваивается CommonDate.
		// В противном случае CommonDate = ZERODATE;
	long   CommonIoeFlags; // Флаги, которые установлены в видах операций всех документов фильтра
	PPID   LastSurrID;
	StrAssocArray TextPool;
	GoodsSubstList    Gsl;
	PPObjBill::SubstParam Bsp; // Параметр подстановки по документам
};
//
// @ModuleDecl(PPViewAccturn)
//
struct AccturnFilt : public PPBaseFilt {
	enum {
		fLastOnly      = 0x0001,
		fLabelOnly     = 0x0002,
		fAllCurrencies = 0x0004
	};
	AccturnFilt();
	AccturnFilt & FASTCALL operator = (const AccturnFilt &);

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   OpID;
	PPID   CurID;
	PPID   BillID;         // Показать проводки только по одному документу
		// одновременно должен быть установлен флаг fLastOnly. Остальные поля фильтра при этом не используются.
	uint   Flags;
	RealRange AmtR;
	int    GrpAco;         // Порядок счета, по которому следует группировать отчет. Если GrpAco == 0, то не группировать.
	//
	// Параметры отбора проводок по счетам
	// (для деталировки сгруппированного отчета)
	//
	int    Aco;
	Acct   DbtAcct;
	Acct   CrdAcct;
	//
	// Параметр для получения циклического отчета по периодам
	// If (GrpAco == 0 || (Flags & fLastOnly)), then ignored.
	//
	PPCycleFilt Cycl;
	long   Reserve; // @anchor
};

struct AccturnViewItem : public PPAccTurn {
	long   OprNo;
	PPID   DbtAccRelID;
	PPID   CrdAccRelID;
};

struct AccturnTotal {
	long   Count;
	AmtList Amounts;
};

class PPViewAccturn : public PPView {
public:
	struct Hdr {
		PPID Id;
	};
	SLAPI  PPViewAccturn();
	SLAPI ~PPViewAccturn();

	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;

	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(AccturnViewItem *);
	int    SLAPI PrintItem(PPID billID);
	int    SLAPI EditItem(PPID billID);
	int    SLAPI DeleteItem(PPID billID);
	int    SLAPI CalcTotal(AccturnTotal *);
	void   SLAPI FormatCycle(LDATE dt, char * pBuf, size_t bufLen);
	int    SLAPI ConvertGenAccturnToExtAccBill();
private:
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int SLAPI Browse(int modeless);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI Print(const void *);
	int    SLAPI CreateGrouping();
	int    SLAPI AddBillToList(PPID billID);
	int    SLAPI RemoveBillFromList(PPID billID);
	int    SLAPI InitViewItem(AccTurnTbl::Rec *, AccturnViewItem *);
	int    SLAPI InitViewItem(TempAccturnGrpngTbl::Rec *, AccturnViewItem *);

	static int DynFuncCheckRelRestrictions;
	static int DynFuncCurSymbByAccRelID;

	TempAssocTbl * P_TmpBillTbl;
	AccturnFilt Filt;
	TempAccturnGrpngTbl * P_TmpAGTbl;
	PPObjBill  * P_BObj;
	AccTurnCore * P_ATC;
	PPObjAccount AccObj;
	uint   IterBillPos;
	int    IterRByBill;
	PPIDArray    OpList;
	PPCycleArray CycleList;
};
//
// @ModuleDecl(PPViewLotOp)
// Операции по лоту
//
class LotOpFilt : public PPBaseFilt {
public:
	SLAPI LotOpFilt();
	enum {
		fZeroLotOps = 0x0001
	};
	uint8  ReserveStart[24]; // @anchor
	PPID   LotID;
	long   Flags;
	long   Reserve;
};

typedef TransferTbl::Rec LotOpViewItem;

class PPViewLotOp : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		long   OprNo;
	};
	SLAPI  PPViewLotOp();
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(LotOpViewItem *);
	int    SLAPI GetLotRec(ReceiptTbl::Rec *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pW);
	int    SLAPI SearchOp(const BrwHdr * pHdr, TransferTbl::Rec * pRec);
	int    SLAPI MoveOp(const BrwHdr * pHdr);
	int    SLAPI Recover(const BrwHdr * pHdr);

	LotOpFilt Filt;
	PPObjBill * P_BObj;   // not owned by this
	//Transfer  * P_Trfr; // not owned by this
	//int    AccsCost;    // Текущему пользователю разрешен доступ к ценам поступления //
	//int    CtrlX;       // Была нажата комбинация Ctrl-X (для вызова специальной функции).
	enum {
		stAccsCost = 0x0001, // Текущему пользователю разрешен доступ к ценам поступления //
		stCtrlX    = 0x0002  // Была нажата комбинация Ctrl-X (для вызова специальной функции).
	};
	long   State;
	PPObjGoods GObj;
	PPObjArticle ArObj;
	static int DynFuncLadingBill;
};
//
// @ModuleDecl(PPViewLot)
//   Анализ лотов
//
struct LotFilt : public PPBaseFilt {
	SLAPI  LotFilt();
	SLAPI  LotFilt(const LotFilt & rS);
	LotFilt & FASTCALL operator = (const LotFilt & rS);
	virtual int SLAPI Describe(long flags, SString & rBuf) const;
	int    SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
	int    SLAPI GetExtssData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtssData(int fldID, const char * pBuf);
	enum {
		fEmptyPeriod        = 0x00000004,
		fWithoutQCert       = 0x00000008, // Показывать только лоты, у которых нет серитфиката
		fOrders             = 0x00000010, // Лоты заказов
		fCostAbovePrice     = 0x00000020, // Только лоты, у которых цена поступления больше цены реализации
		fWithoutClb         = 0x00000040, // Лоты без ГТД
		fDeadLots           = 0x00000080, // Только те лоты, по которым не было движения //
		fWithoutExpiry      = 0x00000100, // Лоты, для которых не указан срок годности
		fOnlySpoilage       = 0x00000200, // Только лоты с бракованными сериями
		fShowSerialN        = 0x00000400, // Показывать серийные номера лотов
		fSkipNoOp           = 0x00000800, // Не показывать лоты, по которым не было операций за операционный период
			// Имеет смысл только если !Operation.IsZero()
		fCheckOriginLotDate = 0x00001000, // Учитывать дату оригинального лота в соответствии с заданным периодом
		fSkipClosedBeforeOp = 0x00002000, // Пропускать лоты, закрытые до операционного периода
		fNoTempTable        = 0x00004000, // Только для внутреннего использования.
		fShowBillStatus     = 0x00008000, // Показывать статус документа соответствующего лоту заказа
		fShowPriceDev       = 0x00010000, // Показывать признак отклонения цены от предыдущего лота
			// этого товара по этому же складу
		fRestByPaym         = 0x00020000, // Спец опция: остаток рассчитывается как количество
			// товара, не оплаченного поставщику.
		fInitOrgLot         = 0x00040000, // @v8.3.7 @construction Если установлен, то итератор инициализируте поле LotViewItem::OrgLotID
		fLotfPrWoTaxes      = 0x00080000  // @v8.9.0 Показывать только лоты, у которых установлен флаг LOTF_PRICEWOTAXES
	};
	//
	// Descr: Идентификаторы текстовых субполей, содержащихся в строке ExtString
	//
	enum { // @persistent
		extssSerialText    = 1,
		extssGoodsNameText = 2,
		extssGoodsCodeText = 3
	};
	//
	// Варианты ограничения выборки по изменению цены
	//
	enum {
		drNone = 0, // Не ограничивать
		drBelow,    // Только уменьшение
		drAbove,    // Только увеличение
		drAny       // Только изменения (лоты с неизмененными ценами не показывать) //
	};
	uint8  ReserveStart[24]; // @#0 @anchor !Использовать начиная со старших адресов
	int16  CostDevRestr;     // LotFilt::drXXX
	int16  PriceDevRestr;    // LotFilt::drXXX
	PPID   ParentLotID;      // Ид лота, дочерние лоты которого следует выбрать. Если это поле
		// не нулевое, то все остальные критерии не работают.
	DateRange Period;        // Период поступления лотов
	DateRange Operation;     // Операционный период
		// (показывает остаток на начало, приход, расход, остаток на конец этого периода)
	DateRange ExpiryPrd;     // Период истечения срока годности по лотам
	DateRange QcExpiryPrd;   // Период истечения срока действия сертификатов
	PPID   LocID;            // ->Location.ID
	PPID   SupplID;          // ->Article.ID
	PPID   GoodsGrpID;       // ->Goods2.ID
	PPID   GoodsID;          // ->Goods2.ID
	PPID   QCertID;          // ->QCert.ID  Только лоты, к которым привязан этот сертификат
	PPID   InTaxGrpID;       // Налоговая группа, ассоциированная с лотом
	long   Flags;            // Флаги (LotFilt::fXXX)
	uint   ClosedTag;        // 0 - all, 1 - opened, 2 - closed
	// @v8.4.11 char   Serial[32];       // Серийный номер, по которому следует найти лот
	uint8  Reserve2[32];     // @v8.4.12
	RealRange CostRange;     // Диапазон цен поступления //
	RealRange PriceRange;    // Диапазон цен реализации  //
	long   Reserve;          // @anchor
	TagFilt * P_TagF;        // @v7.4.5 Фильтр по тегам
	SString ExtString;       // @v8.4.11 Дополнительные текстовые поля фильтра
private:
	int    SLAPI InitInstance();
};

struct LotTotal {
	enum Status {
		Undef = 0,
		Base,
		Extended
	} Stat;
	//
	// Base fields
	//
	long   Count;            // Количество лотов
	double Qtty;             // Общее пришедшее по лотам количество товара (в торговых единицах)
	double Rest;             // Общий текущий остаток по лотам (в торговых единицах)
	double Cost;             // Сумма остатка в ценах поступления //
	double Price;            // Сумма остатка в ценах реализации  //
	double OpRestBeg;        // Остаток на начало операционного периода
	double OpRestEnd;        // Остаток на конец операционного периода
	//
	// Extended fields
	//
	PPID   LocID;            //
	long   Progress;         //
	long   DCount;           // Количество порожденных лотов
	double InCost;           // Начальная сумма поступивших по лотам товаров в ценах поступления //
	double InPrice;          // Начальная сумма поступивших по лотам товаров в ценах реализации  //
	double DRest;            // Остаток порожденных лотов в тороговых единицах
	double DCost;            // Остаток порожденных лотов в ценах поступления //
	double DPrice;           // Остаток порожденных лотов в ценах реализации  //
};

struct LotViewItem : public ReceiptTbl::Rec {
	double BegRest;    // Остаток на начало операционного периода
	double EndRest;    // Остаток на конец операционного периода
	double QttyPlus;   // Приход за операционный период (количество)
	double QttyMinus;  // Расход за операционный период (количество)
	PPID   OrgLotID;   // @v8.3.7 Ид оригинального лота. Инициализируется только если
	LDATE  OrgLotDt;   // Дата поступления оригинального лота
	char   Serial[32]; // Серийный номер по лоту
};

class PPViewLot : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByDate,
		OrdByGoodsName
	};
	struct BrwHdr {
		PPID   ID;
		LDATE  Dt;
		long   SFlags;
	};
	SLAPI  PPViewLot();
	SLAPI ~PPViewLot();
	//
	// Descr: Создает и инициализирует фильтр.
	//   Если extraParam == 1, то в фильтре устанавливается флаг LotFilt::fOrders.
	//
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(LotViewItem *);
	int    SLAPI GetItem(PPID, LotViewItem *);
	int    SLAPI CalcTotal(LotTotal::Status, LotTotal * pTotal);
	int    SLAPI ViewBillInfo(PPID billID);

	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
private:
	static int   CalcChildLots(ReceiptTbl::Rec *, void * extraPtr);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);

	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI CreateTempTable();
	int    SLAPI PutAllToBasket();
	int    SLAPI MovLotOps(PPID lotID);
	int    SLAPI Export();
	int    SLAPI ExportGoodsLabelData();
	int    SLAPI RecoverLots();
	int    SLAPI RevalCostByLots();
	int    SLAPI EditLot(PPID);
	int    SLAPI Debug();
	int    SLAPI Init(int noTempTbl);
	int    FASTCALL AddDerivedLotToTotal(ReceiptTbl::Rec * pRec);
	int    SLAPI InsertTempRecsByIter(BExtInsert * pBei, long * pCounter, UintHashTable * pHt, int showPercentage = 0);
	int    SLAPI AcceptViewItem(const ReceiptTbl::Rec & rLotRec, LotViewItem * pItem);
	int    SLAPI UpdateTempTable(PPID lotID);
	int    SLAPI MakeLotListForEgaisRetReg2ToWh(PPEgaisProcessor & rEp, PPID opID, PPID locID, RAssocArray & rList);

	LotFilt     Filt;
	PPIDArray   LocList;
	struct IterData {
		IterData();
		~IterData();
		void   Reset();

		PPIDArray PsnNativeCntryList;
		PPIDArray NativeCntryList;
		PPIDArray IdBySerialList;  // Список лотов, соответствующих серийному номеру LotFilt::Serial
		PPIDArray IdList;          // Список лотов, по которым осуществляется выборка
			// Этот список имеет приоритет над всеми критериями фильтрации. Более того, при переборе
			// по этому списку критерии фильтрации не проверяются.
		UintHashTable * P_ByTagList;       // @v7.7.8 Список лотов, удовлетворяющих фильтрации по т'гам
		UintHashTable * P_ByTagExclList;   // @v7.7.8 Список лотов, не удовлетворяющих фильтрации по т'гам
	};
	IterData Itd;
	PPObjGoods  GObj;
	PPObjQCert  QcObj;
	PPObjArticle ArObj;
	PPObjPerson PsnObj;
	PPObjBill * P_BObj;
	SpecSeriesCore * P_SpoilTbl;
	ReceiptCore * P_Tbl;
	TempLotTbl  * P_TempTbl;
	PPObjBill::PplBlock * P_PplBlkBeg; // Блок расчета неоплаченных поставщикам остатков по лотам на начало оп периода
	PPObjBill::PplBlock * P_PplBlkEnd; // Блок расчета неоплаченных поставщикам остатков по лотам на конец оп периода
	LotTotal Total;                    //
	ObjIdListFilt SupplList;           // Список поставщиков, выбранных по группирующему отношению к Person(Filt.ArID)
	enum {
		stAccsCost   = 0x00001, // Текущему пользователю разрешен доступ к ценам поступления //
		stNoTempTbl  = 0x00002, // Экземпляр не будет создавать временную таблицу, даже если условия фильтрации этого требуют.
		stFiltSerial = 0x00004  // Текущий фильтр имеет не пустой критерий серийного номера (для экономии времени)
	};
	long   State;
	//int    AccsCost;
	//int    NoTempTbl;
};
//
// @ModuleDecl(PPViewLotExtCode)
//
class LotExtCodeFilt : public PPBaseFilt {
public:
	SLAPI  LotExtCodeFilt();

	char   ReserveStart[32]; // @anchor
	PPID   LotID;
	long   Flags;            //
	long   Reserve;          // @anchor
	SString SrchStr;
};

struct LotExtCodeViewItem {
	PPID   LotID;
	char   Code[128];
};

class PPViewLotExtCode : public PPView {
public:
	SLAPI  PPViewLotExtCode();
	SLAPI ~PPViewLotExtCode();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(LotExtCodeViewItem *);
private:
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ViewTotal();
	int    SLAPI GetRec(const void * pHdr, LotExtCodeTbl::Rec & rRec);
	int    SLAPI CheckDupCode(const LotExtCodeTbl::Rec & rRec);

	LotExtCodeTbl Tbl;
	LotExtCodeFilt Filt;
	PPObjBill * P_BObj;
};
//
// @ModuleDecl(PPViewAsset)
// Анализ основных средств
//
struct AssetFilt : public PPBaseFilt {
	SLAPI  AssetFilt();
	AssetFilt & FASTCALL operator = (const AssetFilt & s);

	enum {
		fUnwritedOffOnly = 0x0001, // Только несписанные
		fWritedOffOnly   = 0x0002, // Только списанные
		// если !(Flags & (fUnwritedOffOnly | fWritedOffOnly)) - то показывать и те и другие
		fShowClosed      = 0x0004  // Показывать закрытые (остаток == 0)
	};
	uint8  ReserveStart[32]; // @anchor @reserved
	DateRange Period;      //
	DateRange OperPeriod;  //
	PPID   GoodsGrpID;     //
	PPID   LocID;          //
	long   Flags;          // @flags
	int16  Ft_InExpl;      // (0) ignored, (<0) только не введенные в эксплуатацию, (>0) только введенные в эксплуатацию.
	int16  Reserve;        // @anchor @alignment
};

struct AssetViewItem {
	PPID   LotID;
	PPID   GoodsID;
	char   GoodsName[64];
	char   Serial[32];
	LDATE  Dt;
	LDATE  ExplDt;
	int16  WrOffTerm;
	double Cost;
	double Price;
	double Deprec;
	double Cost2;
	double Price2;
	double Deprec2;
	double DiffCost;
	double DiffDeprec;
	const  char * P_GoodsGrpName;
};

struct AssetTotal {
	long   Count;
	double Cost;
	double Price;
	double Deprec;
	double Cost2;
	double Price2;
	double Deprec2;
};

class PPViewAsset : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};

	SLAPI  PPViewAsset();
	SLAPI ~PPViewAsset();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(AssetViewItem *);
	int    SLAPI GetItem(PPID lotID, AssetViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);

	int    SLAPI MakeItem(PPID lotID, BExtInsert * pBei, int use_ta);
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();
	int    SLAPI PrintList();

	AssetFilt Filt;
	PPObjGoods  GObj;
	PPObjBill * P_BObj;
	TempAssetTbl * P_TempTbl;
	int    IterIdx;
	GoodsGroupIterator * P_GGIter;
	SString IterGrpName;
};
//
// @ModuleDecl(PPViewFreight)
//
class FreightFilt : public PPBaseFilt {
public:
	SLAPI  FreightFilt();
	enum {
		fUnshippedOnly     = 0x0001, // Только неотгруженные
		fFillLaggageFields = 0x0002, // Заполнять багажные поля (Brutto, PckgCount, Volume)
			// Расчет этих полей требует дополнительного времени вычисления.
		fUseCargoParam     = 0x0004, // Документы с установленным флагом "Грузовые параметры" // AHTOXA
		fStrictPort        = 0x0008, // Фильтрация по PortID и PortOfLoading - строго по
			// пункту назначения (не принимать во внимание адрес доставки и дочерние географические объекты)
		fShippedOnly       = 0x0010  // Только отгруженные
	};
	char   ReserveStart[24]; // @anchor // @v8.8.5 [28]-->[24]
	PPID   StorageLocID;     // @v8.8.5 Место хранения
	PPID   PortOfLoading;    // Пункт погрузки
	DateRange BillPeriod;
	DateRange ShipmPeriod;
	DateRange ArrvlPeriod;
	PPID   LocID;
	PPID   OpID;
	PPID   ObjectID;
	PPID   ShipID;
	PPID   PortID;           // Пункт разгрузки
	PPID   CaptainID;
	long   Flags;
	long   Order;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct FreightViewItem {
	PPID   BillID;        // -> Bill.ID
	LDATE  BillDate;      // = Bill.ID.Dt
	char   Code[24];      // = Bill.ID.Code
	PPID   ObjectID;      // = Bill.ID.ObjectID
	PPID   AgentID;       // Ид агента по документу
	double Amount;        // = Bill.ID.Amount
	double Brutto;        // Масса брутто
	double PackCount;     // Количество упаковок
	double Volume;        // Объем (m*m*m)
	int16  IsShipped;     // Признак отгруженного документа
	int16  Reserve;       // @alignment
	LDATE  ShipmDate;     // Дата отправления //
	LDATE  ArrvlDate;     // Дата прибытия    //
	PPID   ShipID;        // ->Goods2.ID ИД транспортного средства
	char   ShipName[64];  // Наименование транспортного средства
	long   PortID;        // ->World.ID Порт назначения //
	char   PortName[48];  // Наименование порта назначения //
	long   DlvrAddrID;    // ->Location.ID ИД адреса доставки
	char   DlvrAddr[64];  // Наименование адреса доставки
};

class PPViewFreight : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByBillID,
		OrdByBillDate,
		OrdByArrivalDate,
		OrdByPortName,
		OrdByDlvrAddr
	};
	SLAPI  PPViewFreight();
	SLAPI ~PPViewFreight();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(FreightViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int SLAPI Print(const void *);
	virtual int SLAPI ViewTotal();
	int    SLAPI GetBillList(ObjIdListFilt * pList);
	int    SLAPI PrintBill(PPID billID, int addCashSummator);
	int    SLAPI PrintBillList();
	int    SLAPI PrintAllBills();
	int    SLAPI PrintBillInfoList();
	int    SLAPI Export();
	int    SLAPI FillTempTableRec(const BillTbl::Rec *, TempFreightTbl::Rec *);
	int    SLAPI UpdateTempTableRec(PPID billID);
	int    SLAPI UpdateFeatures();

	FreightFilt Filt;
	TempFreightTbl * P_TmpTbl;
	PPObjBill * P_BObj;
	PPObjTransport TrObj;
	PPObjWorld WObj;
	PPObjLocation LocObj;
};
//
// Predict
//
//
// Методы прогнозирования //
//
#define PRMTHD_SIMPLEAVERAGE 1 // Простое среднее
#define PRMTHD_LSLIN         2 // Линейая аппроксимация по методу наименьших квадратов

struct PPPredictConfig {   // @persistent @store(PropertyTbl)
	enum {
		fAddMinStockToOrder = 0x0001, // @obsolete[@v6.2.4] При расчете рекомендуемого заказа прибавлять минимальный запас
		fRoundPckgUp        = 0x0002, // Округлять до емкости упаковки вниз
		fRoundPckgDn        = 0x0004, // Округлять до емкости упаковки вверх
			// Если (fRoundPckgUp^fRoundPckgDn)==0, то округлять до ближайшего
		fZeroPckgUp         = 0x0008, // Если при округлении до емкости упаковки получили 0, то округлять до 1-й упаковки
		fPrefStockPckg      = 0x0010, // Предпочтение отдавать емкости упаковки поставки в записи товара
		fPrefLotPckg        = 0x0020, // Предпочтение отдавать емкости упаковки из последнего лота
		fUseInsurStock      = 0x0040, // При расчете заказа поставщику учитывать минимальный запас
			// (то есть, расчет ведется из предположения, что к следующей поставке должен оставаться //
			// страховочный размер запаса товара).
		fContinueBuilding   = 0x0080, // Процесс построения таблицы был прерван.
			// При следующем запуске следует продолжить.
		fMinStockAsMinOrder = 0x0100  // Минимальный остаток по товару трактовать как минимальный заказ.
			// В этом случае формула расчета заказа выглядит так: Order = (Predict > MinStock) ? (Predict-MinStock) : (MinStock-Predict)
	};
	enum {
		pckgDontUse = 0,
		pckgPrefStock,
		pckgPrefLot
	};
	enum {
		pckgRoundUp = 0,
		pckgRoundDn,
		pckgRoundNear
	};
	//
	// Эти 4 метода определены как статические ради того, что бы
	// их можно было использовать для класса SStatFilt для поля SStatFilt::_CFlags
	//
	static int  FASTCALL _GetPckgUse(long f);
	static int  FASTCALL _GetPckgRounding(long f);
	static long FASTCALL _SetPckgUse(long f, int t);
	static long FASTCALL _SetPckgRounding(long f, int t);

	SLAPI  PPPredictConfig();
	int    SLAPI GetPckgUse() const { return _GetPckgUse(Flags); }
	int    SLAPI GetPckgRounding() const { return _GetPckgRounding(Flags); }
	void   SLAPI SetPckgUse(int t) { Flags = _SetPckgUse(Flags, t); }
	void   SLAPI SetPckgRounding(int t) { Flags = _SetPckgRounding(Flags, t); }

	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PREDICTCFG
	PPID   OpID;           // Вид операции продаж (допустима обобщенная операция)
	PPID   PurchaseOpID;   // Вид операции закупки
	int16  FixArCodes;     //
	char   Reserve[4];     // @reserve
	int16  Method;         // PredictionMethod (PRMTHD_XXX)
	LDATE  StartDate;      // Дата начала учета продаж
	int16  P;              // Количество последних точек, по которым строится прогноз
	int16  Q;              //
	int16  TrustCriterion; // Критерий надежности прогноза
	int16  ImposingDays;   // Кол-во дней наложения (перекрытия)
	long   Flags;          //
	LDATE  EndCalcDate;    // Дата окончания рассчета прогноза, поддерживается ввод через @
	int16  DefInsurStock;  // Страховочный запас в днях по умолчанию (страховочный запас,
		// установленный для товара переопределяет это значение).
	int16  MinP;           // Минимальное число точек, при которых прогноз еще считается надежным
	//
	// Следующие параметры сохраняются после формирования очередного кванта
	// заполнения таблицы одновременно с установкой флага fContinueBuilding.
	// Если процесс был прерван, то продолжение пойдет с этими параметрами,
	// начиная с товара CbLastGoodsID+1
	//
	DateRange CbPeriod;
	PPID   CbLastGoodsID;
	long   CbProcess;
	long   CbFlags;
	PPID   CorrectKoeff;
	char   Reserve3[12];   // @reserve
};

class Predictor {
public:
	static int SLAPI GetPredictCfg(PPPredictConfig *);
	static int SLAPI PutPredictCfg(const PPPredictConfig *, int use_ta);

	SLAPI  Predictor();
	int    SLAPI GetStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);

	struct EvalParam {
		EvalParam(SStatFilt * pFilt = 0);
		EvalParam & Set(const ObjIdListFilt * pLocList, PPID goodsID, const DateRange &);

		const ObjIdListFilt * P_LocList;
		PPID   GoodsID;
		LDATE  LoadUpDate; // Если LoadUpDate != 0 && LoadUpDate < ModelPeriod.upp
			// тогда статистика продаж для прогноза извлекается до этой даты.
		DateRange Period;

		int    Method;
		int    P;
		int    MinP;
		int    TrustCriterion;
	};
	int    SLAPI Predict_(const EvalParam & rParam, double * pResult, PredictSalesStat *, int * pCanTrust = 0);
	int    SLAPI IsWorkDay(const ObjIdListFilt * pLocList, LDATE);
protected:
	PPPredictConfig Cfg;
	PredictSalesCore T;
};

class PrcssrPrediction : public Predictor /*, public PPProcessor*/ {
public:
	struct Param { // @transient
		enum {
			rsUpdateOnly          = 1,
			rsReplaceExistance    = 2,
			rsRemoveAndReplaceAll = 3
		};
		enum {
			prcsFillSales  = 0x0001,
			prcsFillHoles  = 0x0002,
			prcsFillModel  = 0x0004,
			prcsTest       = 0x0008  // @v7.5.1 Режим тестирования //
		};
		enum {
			fRecalcByPeriod     = 0x0001,
			fRemoveContinueMode = 0x0002, // При запуске снять режим продолжения прерванного процесса
			fTestUpdatedItems   = 0x0004, // Тестировать только те товары, которые входят в измененные и созданные
				// за период this->Period документы.
			fUsePPViewGoodsRest = 0x0008  // @v8.0.10 Для расчета начальных остатков использовать PPViewGoodsRest
				// (вместо расчета для каждого отдельного товара)
		};
		//
		// Descr: Устанавливает период заполнения.
		// ARG(period IN): Может быть задан как абсолютной, так и в относительной форме.
		//
		int    SetPeriod(DateRange period);
		//
		// Descr: Возвращает период в том виде, как он задан
		//
		DateRange GetPeriod() const;
		//
		// Descr: Возвращает период в абсолютной форме (относительную форму пересчитывает по
		//   текущей системной дате)
		//
		DateRange GetNormPeriod() const;
	private:
		//
		// Descr: Период заполнения таблицы.
		//   Этот член приватный по причине того, что значения границ периода могут быть заданы
		//   как в абсолютной, так и в относительной форме (@-x).
		//   Для доступа к полю следует использовать методы SetPeriod, GetPeriod, GetNormPeriod
		//
		DateRange Period;
	public:
		PPID   LocID;
		PPID   GoodsGrpID;
		PPID   GoodsID;
		long   Replace;    // Param::rsXXX
		long   Process;    // Param::prcsXXX
		long   Flags;      // @flags Param::fXXX
		uint   GoodsQuant; // Квант товарных идентификаторов, по которому ведется заполнение
	};
	static int SLAPI EditPredictCfg();
	static int SLAPI IsLocked();
	SLAPI  PrcssrPrediction();
	SLAPI ~PrcssrPrediction();
	int    SLAPI GetLastUpdate(PPID goodsID, const ObjIdListFilt & rLocList, LDATE *);
	const  IterCounter & SLAPI GetIterCounter() const { return Counter; }

	int	   SLAPI InitParam(Param *);
	int	   SLAPI EditParam(Param *);
	int	   SLAPI Init(const Param *);
	int	   SLAPI Run();
	int    SLAPI RecalcStat(LDATE commonLastDate, PredictSalesCore::StatStoreErr * pErr, int use_ta);
	//
	// Descr: Структура статистики по построению таблицы продаж
	//
	struct BuildStat {
		PredictSalesCore::StatStoreErr Sse;
		long   Time;       // Время построения в (sec)
		long   GoodsCount; // Количество товаров, по которым строилась таблица
		long   LocCount;   // Количество складов, по которым строилась таблица
		long   DayCount;   // Количество дней, за которые строилась таблица
		long   GoodsQuant; // Количество товаров в одном кванте построения //
		double AvgTimeG;   // Среднее время построения на одну товарную позицию (sec)
		double AvgTimeGD;  // Среднее время построения на одну товарную позицию в день (sec)
		double AvgTimeGL;  // Среднее время построения на одну товарную позицию по одному складу (sec)
		double AvgTimeGDL; // Среднее время построения на одну товарную позицию в день по одному складу (sec)
	};
	struct _GoodsLocRestItem {
		PPID   GoodsID;
		PPID   LocID;
		double Rest;
	};

	const BuildStat & SLAPI GetBuildStat() const;
private:
	static int    SLAPI Lock(int unlock);

	struct _MassGoodsRestBlock {
		DateRange Period;
		TSArray <PrcssrPrediction::_GoodsLocRestItem> List;
	};

	int    SLAPI ProcessGoodsList(PPIDArray & rGoodsList, const PrcssrPrediction::_MassGoodsRestBlock * pRestBlk, int calcStat, int use_ta);
	int    SLAPI StoreStatByGoodsList(const PPIDArray & rGoodsList, LDATE commonLastDate, PredictSalesCore::StatStoreErr * pErr, int use_ta);
	int    SLAPI SetupGoodsSaleByLoc(LocValEntry & rLvEntry, PPID goodsID, LDATE date, __HolidayArray & rHa, SArray * pVect);
	int    SLAPI DeleteAllItems();
	int    SLAPI DeleteItemsByPeriod(DateRange, PPID gGrpID, int use_ta);
	int    SLAPI GetContinueMode(int checkOnly, PPID * pLastGoodsID);
	int    SLAPI SetContinueMode(int reset, PPID lastGoodsID, int use_ta);
	int    SLAPI CheckInterruption();
	int    SLAPI FlashStat(PredictSalesStat * pList, uint count, PredictSalesCore::StatStoreErr * pErr, int use_ta);

	PPObjBill  * P_BObj;
	PPIDArray OpList;
	Param P;
	IterCounter Counter;
	BExtQuery * P_IterQuery;
	//
	LDATETIME TimerStart;
	ulong  MainIterCount;
	int    MaxTime;
	SString StopFileName;
	BuildStat Stat;
};
//
//
//
int SLAPI GetEstimatedSales(const ObjIdListFilt * pLocList, PPID goodsID, const DateRange *, double * pQtty);
//
// @ModuleDecl(PPViewSales)
//
struct PredictSalesFilt : public PPBaseFilt {
	SLAPI  PredictSalesFilt();
	void   SLAPI SetGoodsList(const PPIDArray *, const char * pSubstName);
	enum {
		fShowNoData = 0x0001 // Показывать дни, в которых не было остатка
	};
	uint8  ReserveStart[32];   // @anchor
	PPID   GoodsGrpID;         //
	PPID   GoodsID;            //
	DateRange Period;          //
	int16  Cycle;              // Длина группирующих циклов
	int16  Reserve;            // @alignment
	LDATE  Watershed;          // Дата отсчета циклов назад и вперед.
	long   Flags;              //
	SString SubstName;         // @anchor
	ObjIdListFilt LocList;     //
	ObjIdListFilt GoodsIdList; //
};

struct PredictSalesViewItem  {
	LDATE  Dt;
	double Qtty;
	double Amt;
	double QttyPredict;
	double QttyAbsErr;
	double QttyPctErr;
	double AmtPredict;
	double AmtAbsErr;
	double AmtPctErr;
};

#define FILLMETHOD_ARMA      1
#define FILLMETHOD_AVERAGE   2

struct PredictSalesTotal {
	long   Count;
	double QttySum;
	double QttyAverage;
	double QttySigma;
	double QttyStdDev;
	double AmtSum;
	double AmtAverage;
	double AmtSigma;
	double AmtStdDev;
};

class PPViewPredictSales : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		PPID   LocID;
		PPID   GoodsID;
	};
	enum IterOrder {
		OrdByDefault = 0
	};
	SLAPI  PPViewPredictSales();
	SLAPI ~PPViewPredictSales();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int aOrder = 0);
	int    FASTCALL NextIteration(PredictSalesViewItem *);
	int    SLAPI CalcTotal(PredictSalesTotal *);
	void   SLAPI FormatCycle(LDATE dt, char * pBuf, size_t bufLen) const;
private:
	struct TestParam {
		enum {
			fForceArma = 0x0001
		};
		int16  P;
		int16  Q;
		long   Flags;
	};
	static int EnumProc_CrTmpTbl(PredictSalesItem *, long);

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI ViewTotal();
	int    SLAPI InitCycleList(const PPIDArray * pGoodsList);
	int    SLAPI ConvertHdr(const void * pHdr, BrwHdr * pOut) const;
	int    SLAPI TestPrediction(const BrwHdr *);
	int    SLAPI RecalcGoods(const BrwHdr *);
	int    SLAPI ViewGraph(PPViewBrowser * pBrw);

	PredictSalesCore Tbl;
	PredictSalesFilt Filt;
	TempPredictSalesTbl * P_TempTbl;
	PPCycleArray CycleList;
	uint   CurIterOrd;
	double ErrAvg;    // Средняя ошибка прогнозирования (тест)
	TestParam TP;
};
//
// @todo (Исправить структуру (порядок полей, выравнивание, метод Init - THISZERO плохо из-за SString))
//   Заменить на SupplInterchangeFilt
//
struct SupplExpFilt {
	enum {
		expBills          = 0x0001,
		expRest           = 0x0002,
		expPrice          = 0x0004,
		expDelRecentBills = 0x0008,
		expFlatStruc      = 0x0010,
		expSaldo          = 0x0020
	};
	SupplExpFilt();
	void   Init();
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long) const;
	int    OpListFromCfg(const PPSupplAgreement::ExchangeParam * pCfg);
	int    OpListToCfg(PPSupplAgreement::ExchangeParam * pCfg);

	PPID   SupplID;
	PPID   GoodsGrpID;
	PPID   ExpendOp;
	DateRange Period;
	uint32 MaxFileSizeKB;
	long   Flags;
	PPID   TechID;
	ulong  IP;
	int16  Port;
	uint16 ProtVer;
	char   AddScheme[32];
	uint   AddRecType;
	double PctDis1;
	PPID   RcptOp;
	PPID   SupplRetOp;
	PPID   RetOp;
	PPID   MovInOp;
	PPID   MovOutOp;
	double PctDis2;
	PPID   PriceQuotID;
	char   ClientCode[16];
	SString EncodeStr;       // @anchor
	ObjIdListFilt LocList;
};

class SupplInterchangeFilt : public PPBaseFilt, public PPExtStrContainer { // @v9.4.2 PPExtStrContainer
public:
    SLAPI  SupplInterchangeFilt();
	SupplInterchangeFilt & FASTCALL operator = (const SupplInterchangeFilt & rS);
	SupplInterchangeFilt & FASTCALL operator = (const SupplExpFilt & rS);

	enum { // @persistent
		extssOpSymbol   = 1,
		extssParam      = 2,

		extssAddScheme  = 3, // compatibility with SupplExpFilt::AddScheme
		extssEncodeStr  = 4, // compatibility with SupplExpFilt::EncodeStr
		extssClientCode = 5, // compatibility with SupplExpFilt::ClientCode

	};
	enum { // @persistent
		opNone = 0,
		opExportStocks     = 0x0001,     // EXPSTOCK
		opExportBills      = 0x0002,     // EXPBILL
		opExportDebts      = 0x0004,     // EXPDEBT
		opExportGoodsDebts = 0x0008,     // EXPGOODSDEBT
		opExportClients    = 0x0010,     // EXPCLI
		opExportPrices     = 0x0020,     // EXPPRICE
		opImportGoods      = 0x0040,     // IMPGOODS
		opImportRouts      = 0x0080,     // IMPROUT
		opImportOrders     = 0x0100,     // IMPORDER
		opImportDesadv     = 0x0200,     //
		opExportSales      = 0x0400      // EXPSALES
	};
	enum {
		fDeleteRecentBills = 0x0001, // BALTIKA only
		fFlatStruc         = 0x0002,
		fRepeatProcessing  = 0x0004, // @v9.5.7 Флаг повторного процессинга уже обработанных данных (применение зависит от операции и провайдера)
		fTestMode          = 0x0008  // @v9.6.0 Тестовый режим
	};
    uint8  ReserveStart[24]; // @anchor
    float  SpcDisPct1; // Специальная скидка 1, %
    float  SpcDisPct2; // Специальная скидка 2, %
    PPID   SupplID;    // ->Article.ID
	long   Actions;
    long   Flags;
    DateRange ExpPeriod;
    DateRange ImpPeriod;
    uint   MaxTransmitSize;  // Максимальный размер передаваемых данных (KByte). 0 - не ограничено
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};

class PrcssrSupplInterchange {
public:
	class ExecuteBlock {
	public:
		SLAPI  ExecuteBlock();
		SLAPI  ExecuteBlock(const ExecuteBlock & rS);
		int    SLAPI GetSequence(long * pSeq, int use_ta);

		PPSupplAgreement::ExchangeParam Ep;
		SupplInterchangeFilt P;
		SString ArName;    // Наименование поставщика
	protected:
		enum {
			iglfWithArCodesOnly = 0x0001
		};
        int    SLAPI InitGoodsList(long flags);
        int    FASTCALL IsGoodsUsed(PPID goodsID) const;
        const  PPIDArray * GetGoodsList() const;
        // @v9.6.2 int    SLAPI Debug_TestUtfText(const SString & rText, const char * pAddendum, PPLogger & rLogger);

		enum {
			bstGoodsListInited = 0x0001, // Список товаров GoodsList инициализирован
			bstAnyGoods        = 0x0002  // Нет ограничений на товары, по которым ведется обмен с поставщиком
		};
		PPObjGoods GObj;
		PPObjArticle ArObj;
		PPObjLocation LocObj;
		PPObjPerson   PsnObj;
		PPObjBill * P_BObj;
	private:
		PPID   SeqID;
		long   BaseState;
		PPIDArray GoodsList;
	};
	SLAPI  PrcssrSupplInterchange();
	SLAPI ~PrcssrSupplInterchange();
	int    SLAPI InitParam(PPBaseFilt * pBaseFilt);
	int    SLAPI EditParam(PPBaseFilt * pBaseFilt);
	int    SLAPI Init(const PPBaseFilt * pBaseFilt);
	int    SLAPI Run();
	//
	// Descr: Временная функция для переноса существующего кода
	//
    int    SLAPI InitExecuteBlock(const SupplInterchangeFilt * pParam, ExecuteBlock & rBlk);
private:
	enum {
		stInited = 0x0001 // Был успешно вызван метод Init()
	};
	long   State;
	ExecuteBlock * P_Eb;
    PPObjArticle ArObj;
};
//
// @ModuleDecl(PPViewGoodsRest)
//
class GoodsRestFilt : public PPBaseFilt {
public:
	SLAPI  GoodsRestFilt();
	enum {
		eqxExhaustTerm = 0x0001
	};
	int    SLAPI IsEqualExcept(const GoodsRestFilt & rS, long flags) const;
	virtual int SLAPI Describe(long flags, SString & rBuf) const;
	//
	// Descr: Устанавливает признак использования котировки QuotKindID.
	// ARG(v IN):
	//   0 - не использовать (!(Flags & fPriceByQuot) && !(Flags2 & f2CostByQuot))
	//   1 - использовать как дополнение к цене реализации (Flags & fPriceByQuot)
	//   2 - использовать в качестве замещения цены поступления (!(Flags & fPriceByQuot) && (Flags2 & f2CostByQuot))
	//   все остальные значения трактуются как ошибочные и не изменяют состояния фильтра.
	// Returns:
	//   >0 - состояние трактовки котировок установлено
	//   <0 - состояние трактовки котировок не изменилось
	//   0 -  ошибочный параметр (состояние трактовки котировок не изменилось)
	//
	int    SLAPI SetQuotUsage(int v);
	//
	// Descr: Возвращает статус трактовки котировки QuotKindID
	// Returns:
	//   0 - котировка не используется (!(Flags & fPriceByQuot) && !(Flags2 & f2CostByQuot))
	//   1 - котировка используется как дополнение к цене реализации (Flags & fPriceByQuot)
	//   2 - котировка используется в качестве замещения цены поступления (!(Flags & fPriceByQuot) && (Flags2 & f2CostByQuot))
	//
	int    SLAPI GetQuotUsage() const;

	enum {
		fBarCode                = 0x00000001, // Остатки со штрих-кодами
		fNullRest               = 0x00000002, // Выводить нулевые остатки
		fCalcOrder              = 0x00000004, // Расчитывать заказанное количество
		//                      0x0008  // Occupied by GoodsRestParam
		//                      0x0010  // Occupied by GoodsRestParam
		//                      0x0020  // Occupied by GoodsRestParam
		fPriceByQuot            = 0x00000040, // Формировать цены по котировкам
		fUnderMinStock          = 0x00000080, // Показывать только те позиции, остаток по которым ниже установленного минимума
		fDisplayWoPacks         = 0x00000100, // Показывать остатки без упаковок
		fNullRestsOnly          = 0x00000200, // Только нулевые остатки
		fLabelOnly              = 0x00000400, // WL-only
		fNoZeroOrderOnly        = 0x00000800, // Только с ненулевыми заказами
		fCalcTotalOnly          = 0x00001000, // Расчитать только итоги
		fEachLocation           = 0x00002000, // Рассчитывать остатки по каждому из складов
		fComplPackQtty          = 0x00004000, // Показывать количество в упаковках
		fCWoVat                 = 0x00008000, // Показывать цены без НДС
		fCalcDeficit            = 0x00010000, // Рассчитывать дефицит
		fWoSupplier             = 0x00020000, // Рассчитывать остатки без учета поставщика
		fShowMinStock           = 0x00040000, // Показывать минимальные остатки
		fShowDraftReceipt       = 0x00080000, // Показывать остатки учитывая будущие драфт приходы
		fCalcSStatSales         = 0x00100000, // Заполнять поле среднедневных продаж из статистики продаж
		fOuterGsl               = 0x00200000, // PPViewGoodsRest::Gsl инициализирован вне функции PPViewGoodsRest::Init_
		fUseGoodsMatrix         = 0x00400000, // Применять товарную матрицу при выборе товаров для отчета

		fExtByArCode            = 0x00800000, // Выборка товаров, по которым строится отчет ДОПОЛНЯЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
		fRestrictByArCode       = 0x01000000, // Выборка товаров, по которым строится отчет ОГРАНИЧИВАЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
			// Если SupplID == 0, то перебираются только те товары, которые имеют собственные коды.
		// @#{fExtByArCode^fRestrictByArCode}
		fCrosstab               = 0x02000000, // Кросстаб, если включена опция fEachLocation
		fShowGoodsMatrixBelongs = 0x04000000, // Отображать принадлежность товарной матрице
		fCalcUncompleteSess     = 0x08000000,    // Рассчитывать с учетом незавершенных сессий
		fZeroSupplAgent         = 0x10000000,    // @v7.5.11 Только с нулевым агентом поставщика
		fCalcCVat               = 0x20000000,    // @v8.3.4 Рассчитывать валовую сумму НДС в ценах поступления //
		fCalcPVat               = 0x40000000,    // @v8.3.4 Рассчитывать валовую сумму НДС в ценах реализации //
		fForceNullRest          = 0x80000000     // @v8.6.6 Предписывает показывать товар с нулевым остатком даже если не было ни одного лота
	};
	//
	// Descr: Значения флагов, хранящихся в поле Flags2
	//
	enum {
		f2CalcPrognosis         = 0x00000001, // Рассчитывать прогноз продаж (специальная форма диалога фильтра и отчета)
		f2CostByQuot            = 0x00000002  // Котировку трактовать как цены поступления
	};
	//
	// Descr: Опции экспорта Universe-HTT
	//
	enum {
		uefRest          = 0x0001, // Экспортировать значения остатков
		uefPrice         = 0x0002, // Экспортировать цены
		uefZeroAbsPrices = 0x0004  // @v8.4.0 Обнулять цены для позиций, которые есть на сервере, но отсутствуют в отчете
	};
	enum {
		evfShowLastSaleDate = 0x0001 // Показывать дату последней продажи
	};
	char   ReserveStart[4];  // @anchor
	uint32 DiffParam;        // @v8.1.0 Параметр дифференциации записей отчета
	PPID   UhttExpLocID;     // @v7.7.9 Склад, по которому синхронизируется загрузка данных на сервер Universe-HTT
		// Если UhttExpLocID == 0, то синхронизируется по LocList.GetSingle()
	int16  UhttExpFlags;     // @v7.6.3 Опции 'кспорта в Universe-HTT
	uint16 ExtViewFlags;     // Допольнительные опции просмотра
	PPID   DiffLotTagID;     // @v7.2.8 Тип тега лотов, по значениям которого следует дифференцировать отчет
	DateRange DraftRcptPrd;  // Период расчета будущих драфт приходов
	int16  PrgnTerm;         // @v7.2.2 Количество дней, на которые необходимо спрогнозировать продажи.
		// По смыслу, это поле конфликтует с PrgnPeriod, однако имеет несколько отличное применение:
		// используется для расчета дополнительного поля прогноза продаж без признака CalcPrognosis.
	int16  ExhaustTerm;      // Срок истощения остатков (<0 - количество дней, прошедшее после истощения остатка)
	uint   CalcMethod;       // GoodsRestParam::pcmXXX
	long   Flags;            //
	int    AmtType;          // 0 - в обеих ценах, 1 - поступления, 2 - реализации
	// @v9.5.8 (заменено на Flags2 с соблюдением бинарной совместимости) int    CalcPrognosis;    // если 1, то вычисляем прогноз иначе - нет
	long   Flags2;           // @v9.5.8 GoodsRestFilt::f2XXX
	DateRange PrgnPeriod;    // период прогноза
	LDATE  Date;             //
	PPID   SupplID;          //
	PPID   GoodsGrpID;       //
	PPID   QuotKindID;       //
	PPID   AgentID;          // Агент поставщика
	PPID   BrandID;          //
	SubstGrpGoods Sgg;       //
	LDATE  DeficitDt;        //
	uint   WaitMsgID;        //
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;   //
	ObjIdListFilt GoodsList; // Для вывода детализации по ид подстановки
};

class GoodsRestTotal {
public:
	SLAPI  GoodsRestTotal();
	int    SLAPI Init();
	GoodsRestTotal & FASTCALL operator = (GoodsRestTotal &);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	long   Count;
	double Quantity;
	double PhQtty;
	double Order;
	double SumCost;
	double SumPrice;
	double SumCVat;
	double SumPVat;
	double PctAddedVal;
	double DraftRcpt;        //
	double SumDraftCost;     //
	double SumDraftPrice;    //
	AmtList Amounts;
};

struct GoodsRestViewItem { // @transient
	PPID   GoodsID;
	PPID   GoodsGrpID;
	PPID   LocID;
	PPID   LotID;          // @v8.1.1
	// @v8.1.3 const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsRest instance
	char   GoodsName[128]; // @v6.3.8 [64]-->[128]
	char   GoodsGrpName[128]; // @v8.1.3
	char   UnitName[48];   // Наименование единицы измерения // @v7.2.6 [32]-->[48]
	char   Serial[24];     // @v8.1.0
	int16  IsPredictTrust; // Прогноз продаж удовлетворяет требованиям надежности
	int16  Reserve;        // @alignment
	double Rest;           //
	double Deficit;        //
	double PhRest;         //
	double Order;          //
	double UnitPerPack;    //
	double Cost;           //
	double Price;          //
	double SumCost;        //
	double SumPrice;       //
	double SumCVat;        // @v8.3.4 Сумма НДС в ценах поступления
	double SumPVat;        // @v8.3.4 Сумма НДС в ценах реализации
	double PctAddedVal;    // Средняя наценка на позицию
	double Predict;        // Прогноз продаж
	double RestInDays;     // Остаток товаров в днях
	double MinStock;       //
	double SupplOrder;     // Предлагаемый заказ поставщику
	double SStatSales;     // Среднедневные продажи из статистики продаж
	double DraftRcpt;      //
	long   SubstAsscCount; //
	LDATE  LastSellDate;   // @v8.7.3
};
//
// Структура, передаваемая объекту PPALDD_GoodsRestTotal для печати
// Used: V_GREST2.CPP
//
struct GoodsRestTotalPrintData {
	const GoodsRestTotal * P_Total;
	const GoodsRestFilt * P_Filt;
};

DECL_CMPFUNC(ReceiptTbl_DtOprNo);

class PPViewGoodsRest : public PPView {
public:
	struct BrwHdr {
		PPID __ID;
		PPID GoodsID;
		PPID LocID;
	};

	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsID,
		OrdByGoodsName,
		OrdByGrp_GoodsName,
		OrdByPrice,
		OrdByGrp_Price,
		OrdByBarCode,
		OrdByGrp_BarCode
	};
	SLAPI  PPViewGoodsRest();
	SLAPI ~PPViewGoodsRest();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	//
	// Descr: Инициализирует выборку остатков товаров в соответствии с фильтром.
	// ARG(pFilt     IN): Фильтр, определяющий расчет товарных остатков
	//
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	//
	// ARG(pOuterGsl IN): Если этот параметр не нулевой и фильтр pFilt предполагает
	//   подстановку товара, то использование этого параметра позволит передать
	//   объекту список подстановок. Благодаря этому подстановки созданные этим
	//   объектом будут соответствовать переданному списку подстановок.
	//   Например: объект PPViewGoodsOpAnalyze строит отчет с остатками, вызывая //
	//   этот метод. Если он не передаст сюда свой список подстановок, то
	//   остатки по подстановкам могут не соответствовать основной часть отчета.
	//   Вызывать перед вызовом функции Init_
	//
	int    SLAPI SetGsl(const GoodsSubstList * pOuterGsl);
	int    SLAPI InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(GoodsRestViewItem *);
	int    SLAPI GetItem(PPID goodsID, PPID locID, GoodsRestViewItem *);
	int    SLAPI GetItem(PPID goodsID, const ObjIdListFilt * pLocList, GoodsRestViewItem * pItem);
	int    SLAPI GetItem(PPID __id, GoodsRestViewItem *);
	int    SLAPI GetGoodsStat(PPID goodsID, const ObjIdListFilt & rLocList, PredictSalesStat * pStat);
	//
	// Descr: Рассчитывает заказы на товар goodsID в соответствии с условиями внутреннего фильтра
	//
	int    SLAPI CalcOrder(PPID goodsID, GoodsRestParam * pOutData);
	int    SLAPI SetSupplOrderValues(PPID goodsID, PPID locID, double predict, double minStock, double order, int canTrust);
	int    SLAPI GetTableName(SString & rBuf) const;
	int    SLAPI GetGoodsBarcode(PPID goodsID, char * code, size_t buflen);
	// @v9.2.2 (replaced by GoodsCore::GetGoodsCodeInAltGrp) int    SLAPI GetGoodsNumByAlterGroup(PPID goodsID, PPID grpID, long * num);
	int    SLAPI GetTotal(GoodsRestTotal *);
	virtual int SLAPI Print(const void *);
	int    SLAPI GetTabTitle(long tabID, SString & rBuf);
	int    SLAPI GetEditIds(const void * pRow, PPID * pLocID, PPID * pGoodsID, long col);
	int    SLAPI ExportUhtt(int silent);
	int    SLAPI CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle);
private:
	struct LotQueryBlock {
		LotQueryBlock();
		~LotQueryBlock();

		int   Idx;
		int   SpMode;
		int   Reverse;
		BExtQuery * P_Q;
		uint8 Key[ALIGNSIZE(MAXKEYLEN, 2)];
	};
	class ProcessLotBlock {
	public:
		ProcessLotBlock(int forceUseLotRest);
		~ProcessLotBlock();

		int    ForceUseLotRest; // Остаток брать из лота (ReceiptTbl::Rec::Rest) даже если в фильтре установлена дата
		const PPIDArray * P_GrpGoodsList;
		PPIDArray ExtBillList;
		Transfer::GetLotPricesCache * P_LpCache;
		IterCounter Cntr;
		//
		PPIDArray GrpGoodsList;
	};
public:
	struct CacheItem {
		CacheItem();

		PPID   GoodsID;       // @anchor По этому и следующему элементам
		PPID   LocID;         // @anchor осуществляется поиск
		PPID   LotID;         // @v8.1.0
		double UnitPerPack;
		double Order;
		double Rest;
		double PhRest;
		double Cost;
		double Price;
		double SumCVat;       // @v8.3.4 Сумма НДС в ценах поступления //
		double SumPVat;       // @v8.3.4 Сумма НДС в ценах реализации //
		double Deficit;       //
		double DraftRcpt;     //
		uint32 Counter;
		uint   SerialP;       // @v8.1.0 Позиция серийного номера в пуле строк
		uint   LotTagP;       // @v9.7.11 Позиция строки тега лота в пуле строк
		DBRowId  DBPos;
	};
private:
	class Cache : public TSArray <CacheItem>, public SStrGroup {
	public:
		SLAPI  Cache();
		Cache & SLAPI Clear();
		int    SLAPI SetupCacheItemSerial(PPViewGoodsRest::CacheItem & rItem, const char * pSerial);
		int    SLAPI GetCacheItemSerial(const PPViewGoodsRest::CacheItem & rItem, SString & rBuf) const;
		int    SLAPI SetupCacheItemLotTag(PPViewGoodsRest::CacheItem & rItem, const char * pTagVal);
		int    SLAPI GetCacheItemLotTag(const PPViewGoodsRest::CacheItem & rItem, SString & rBuf) const;
	};

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI OnExecBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI ViewLots(PPID __id, const BrwHdr * pHdr, int orderLots);
	int    SLAPI ViewPrediction(PPID goodsID, PPID /*locID*/);
	int    SLAPI ConvertLinesToBasket();
	int    SLAPI PrintTotal(const GoodsRestTotal *);
	int    SLAPI CreateTempTable(int use_ta, double * pPrfMeasure);
	int    SLAPI CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    SLAPI ProcessLots2(const PPIDArray * pGrpGoodsList);
	int    SLAPI ProcessGroup(const PPIDArray * pGroupGoodsList);
	int    SLAPI AddGoodsThruCache(PPID goodsID, PPID locID, int isGenGoods,
		double order, double phUPerU, const GoodsRestVal *, BExtInsert *);
		// @<<PPViewGoodsRest::CreateTempTable
		// @<<PPViewGoodsRest::ProcessGoods
	int    SLAPI AddTotal(const PPViewGoodsRest::CacheItem & rItem);
	int    SLAPI ProcessGoods(PPID goodsID, BExtInsert *, PPIDArray * pAgentBillList);
	int    SLAPI CalcTotal(GoodsRestTotal *);
	int    SLAPI InitGroupNamesList();
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();
	int    SLAPI InitAppBuff(const TempGoodsRestTbl::Rec *, GoodsRestViewItem *);

	void   SLAPI InitCache();
	int    FASTCALL AddCacheItem(PPViewGoodsRest::CacheItem & rItem);
	int    SLAPI CompareNthCacheItem(uint n, const PPViewGoodsRest::CacheItem *) const;
	int    SLAPI FlashCacheItem(BExtInsert *, const PPViewGoodsRest::CacheItem & rItem);
		// @<<PPViewGoodsRest::FlashCacheItems
		// @<<PPViewGoodsRest::AddGoodsThruCache
	int    SLAPI FlashCacheItems(uint);
	int    SLAPI GetLastLot_p(PPID goodsID, PPID locID, PPID supplID, LDATE dt, ReceiptTbl::Rec *);
	int    SLAPI GetLastLot_(PPID goodsID, PPID locID, ReceiptTbl::Rec & rRec);
	double SLAPI GetDeficit(PPID goodsID);
	double SLAPI GetDraftRcptByLocList(PPID goodsID, PPIDArray * pLocList, int addToExclList = 1);
	double SLAPI GetDraftReceipt(PPID goodsID, PPID locID, int addToExclList = 1);
	double SLAPI EnumDraftRcpt(PPID goodsID, uint * pIdx, DraftRcptItem * pItem);
	double SLAPI GetUncompleteSessQttyByLocList(PPID goodsID, PPIDArray * pLocList, int addToExclList =1);
	double SLAPI GetUncompleteSessQtty(PPID goodsID, PPID locID, int addToExclList =1);
	double SLAPI EnumUncompleteSessQtty(PPID goodsID, uint * pIdx, DraftRcptItem * pItem);
	int    SLAPI InitProcessLotBlock(ProcessLotBlock & rBlk, const PPIDArray * pGrpGoodsList);
	int    SLAPI Helper_ProcessLot(ProcessLotBlock & rBlk, ReceiptTbl::Rec & rRec);
	int    SLAPI MakeLotQuery(LotQueryBlock & rBlk, int lcr, ulong lowId, ulong uppId);
	BExtQuery & SLAPI MakeLotSelectFldList(BExtQuery & rQ, const ReceiptTbl & rT) const;
	int    SLAPI SelectLcrLots(const PPIDArray & rIdList, const UintHashTable & rLcrList, SArray & rList);
	int    SLAPI UpdateGoods(PPID goodsID);
	int    SLAPI SetContractPrices();

	GoodsRestFilt  Filt;
	OpGroupingFilt * P_OpGrpngFilt; // Фильтр для просмотра отчета "Группировка операций"
	PPObjBill   * P_BObj;
	PPObjGoods    GObj;
	PPObjUnit     UObj;
	PPObjLocation LocObj;
	TempGoodsRestTbl * P_Tbl;
	TempOrderTbl     * P_TempOrd;
	CCheckCore    CCheckTbl;
	GoodsSubstList Gsl;
	Predictor * P_Predictor;
	enum {
		fAccsCost      = 0x0001,
		fExclAltFold   = 0x0002,
		fTotalInited   = 0x0004,
		fScalePrefixAltGroup = 0x0008, // Товарная группа, установленная в фильтре требует генерации дианмических
			// весовых штрихкодов. При этом инициализируется ScalePrefixID
		fExhaustTermInited   = 0x0010, // Сроки истощения запасов инициализированы.
			// Это означает, что можно фильтровать строки отчета по сроку истощения без
			// перестройки всего отчета
		fOnceInited          = 0x0020  // Экземпляр уже был инициализирован вызовом Init_
			// (этот флаг устанавливается безусловно при успешном вызове Init_())
	};
	long   Flags;
	PPID   ScalePrefixID;
	PPID   SellOpID; // Вид операции продажи для идентификации даты последней продажи товаров
	SString WaitMsg;
	//
	// Отношение количества товаров в группе к общему числу товаров (промилле),
	// ниже которого расчет ведется перебором товаров, а не перебором лотов.
	// По умолчанию DEFAULT_GROUPRESTCALCTHRESHOLD (V_GREST.CPP)
	//
	long   GroupCalcThreshold;
	//
	int    IterIdx;
	GoodsGroupIterator * P_GGIter;
	SString IterGrpName;
	UintHashTable GoodsIDs;
	GoodsRestTotal Total;
	PPViewGoodsRest::Cache CacheBuf;
	uint32 MaxCacheItems;
	uint32 CacheDelta;
	uint32 LastCacheCounter;

	struct {
		long   SearchCount;
		long   CacheMissesCount;
		long   DbMissesCount;
		long   InsertCount;
		long   UpdateCount;
		long   NotChangedUpdateCount;
	} CacheStat;
	RAssocArray    DeficitList;       //
	PPIDArray      ExclDeficitList;   //
	DraftRcptArray DraftRcptList;     //
	LAssocArray    ExclDraftRcptList; //
	DraftRcptArray UncompleteSessQttyList;
	LAssocArray    ExclUncompleteSessQttyList;
	ObjIdListFilt  LocList;           // @!PPViewGoodsRest::Init_
		// Проекция Filt.LocList (LocList = PPObjLocation::ResolveWarehouseList(&Filt.LocList.Get()))
};
//
//
//
class PPStockOpt {
public:
	enum {
		pgEstimateInRest = 1,
		pgOptimize,
		pgDecrement
	};
	//
	// Descr: типы величин, вычисляемых для товара функциями Evaluate()
	//
	enum {
		evvAll = 0,
		evvTarget = 1,       // evvIncome, evvExpend
		evvOptRestDiscr,     // Оптимальный остаток (с дискретностью, заданной емкостью упаковки)
		evvOptRest,          // Абсолютный оптимальный остаток (без дискретности)
		evvMinValAdd,        // Минимальная цена продажи при заданных средних ежедн продажах
		evvMinDemand,        // Минимальные средние ежедн продажи при заданных себестоимости и цене реализации
		evvIncome,           // Сумма ожидаемого дохода от продажи запаса. param - значение остатка
		evvExpend,           // Сумма расходов на закупку, содержание и продажу запаса. param - значение остатка
		evvProfit,           // Разница между evvIncome и evvExpend. param - значение остатка
		evvMinStock,         // Минимальный допустимый запас. param - текущий остаток
		evvMaxStock,         // Максимальный допустимый запас. param - текущий остаток
		evvStockBounds       // evvMinStock, evvMaxStock
	};
	struct Config { // @persistent
		Config();

		double RateOfRet;          // Требуемая норма прибыли (годовая в долях от единицы)
		double ExpirySafetyFactor; // Коэффициент запаса при учете срока годности товара.
			// Нормально, должен быть >0.0 && <=1.0
		uint   MaxItems;           // Максимально количество товаров
		double MaxCost;            // Максимальная сумма остатков (в ценах поступления)
		double MaxSales;           // Максимальная сумма продаж за день (в ценах реализации)
		uint8  Reserve[128];       // @reserve
	};
	struct Item {
		Item(PPID goodsID = 0);
		int    CanProcess() const;

		enum {
			fUndefDemand = 0x0001, // Не определен спрос
			fUndefCost   = 0x0002, // Не определена себестоимость
			fUndefPrice  = 0x0004, // Не определена цена реализации
			fPckgSynth   = 0x0008, // Размер упаковки синтезирован
			fPreproc     = 0x8000  // Структура обработана функцией PPStockOpt::PreporcessGoods
		};
		PPID   GoodsID;        // Ид товара
		double Cost;           // Себестоимость единицы товара
		double Price;          // Цена продажи единицы товара
		double AvgD;           // Средний ежедневный спрос на товар (в торговых единицах)
		double StdDev;         // Стандартное отклонение ежедневного спроса на товар.
		//
		double InRest;         // Входящий остаток на начало анализируемого периода.
		//
		// Ограничения //
		//
		double MinRest;        // Минимальный остаток
		double Pckg;           // Размер упаковки
		int16  ExpiryPeriod;   // Срок годности в днях
		int16  Reserve;        // @alignment
		long   Flags;          //
	};
	//
	// Descr: Результаты расчетов по товару. Структура отделена от GoodsItem с целью оставить GoodsItem
	//   константной величиной на время расчета.
	//
	struct GoodsResult {
		enum {
			stMinMaxBoundError = 0x0001, // Минимальная граница превышает максимальную.
			stMinBound         = 0x0002, // Значение R находится на нижней допустимой границе
			stMaxBound         = 0x0004  // Значение R находится на верхней допустимой границе
		};
		GoodsResult();

		PPID   GoodsID;        //
		long   State;
		RealRange Bounds;      // Допустимые границы изменения остатка.
		double R0;             // Абсолютный оптимум запаса
		double R0p;            // Оптимум запаса с учетом кратности упаковки
		double R;              // Текущее расчетное значение оптимального запаса в объемной оптимизации
		double Period;         // Количество дней, в течении которых ожидается ликвидация остатка R.
		double Income;         // Ожидаемый доход от остатка R
		double Expend;         // Ожидаемые издержки по закупке и хранению количества R
		double LastDelta;      // Разность в критерии оптимальности, полученная в результате последней
			// итерации. Нобходима для быстрого поиска позиции, которая может быть частично выведена из
			// ассортимента для увеличения доли иной позиции.
	};
	struct TotalResult {
		TotalResult();
		void   Init();
		TotalResult & Add(const PPStockOpt::Item & rGi, const GoodsResult & rGr);
		TotalResult & Sub(const PPStockOpt::Item & rGi, const GoodsResult & rGr);

		uint32 Count;
		double Income;
		double Expend;
		double SumCost;
		double SalesPerDay;
	};

	static int WriteConfig(const PPStockOpt::Config * pCfg);
	static int ReadConfig(PPStockOpt::Config * pCfg);
	static int EditConfig();

	PPStockOpt();
	~PPStockOpt();
	int    SetConfig(const PPStockOpt::Config * pCfg);
	const  PPStockOpt::Config & GetConfig() const;
	int    AddGoodsItem(const PPStockOpt::Item & rItem);
	int    UpdateGoodsItem(uint pos, const PPStockOpt::Item & rItem);
	const  TSArray <PPStockOpt::Item> & GetItems() const;
	const  TSArray <PPStockOpt::GoodsResult> & GetResult() const;
	const  PPStockOpt::TotalResult & GetTotal() const;
	int    Run();
	int    Test();
private:
	int    PreprocessGoods(PPStockOpt::Item & rItem);
	int    ProcessGoods(const PPStockOpt::Item & rItem, long mode, GoodsResult & rResult) const;
	double FASTCALL Evaluate(const PPStockOpt::Item & rItem, int evv, double param) const;
	int    Evaluate(const PPStockOpt::Item & rItem, int evv, double param, GoodsResult & rResult) const;
	double GetRate() const;
	int    CheckTotalRestrictions(const TotalResult & rTotal);

	PPStockOpt::Config Cfg;
	TSArray <PPStockOpt::Item> Items;
	TSArray <PPStockOpt::GoodsResult> Result;
	TotalResult Total;
	RAssocArray DecrIndex;
};
//
// @ModuleDecl(PPViewStockOpt)
//
struct StockOptFilt : public PPBaseFilt {
	StockOptFilt();
	enum {
		modeGoods = 1,
		modePreproc,
		modeOptimum
	};
	uint8  ReserveStart[32]; // @anchor
	int32  Mode;
	int32  InitOrder;
	long   Flags;
	PPStockOpt::Config SoCfg;
	uint8  Reserve[64];      // @anchor
};
//
//
//
struct StockOptViewItem {
	PPID   GoodsID;        // Ид товара
	double Cost;           // Себестоимость единицы товара
	double Price;          // Цена продажи единицы товара
	double AvgD;           // Средний ежедневный спрос на товар (в торговых единицах)
	double StdDev;         // Стандартное отклонение ежедневного спроса на товар.
	//
	// Ограничения //
	//
	double MinRest;        // Минимальный остаток
	double Pckg;           // Размер упаковки
	int16  ExpiryPeriod;   // Срок годности в днях
	int16  Reserve;        // @alignment
	long   Flags;          //
	//
	// Результаты препроцессинга и (или) оптимизации
	//
	long   State;          // Состояние результата оптимизации //
	double InRest;         // Входящий остаток на начало анализируемого периода.
	RealRange Bounds;      // Допустимые границы изменения остатка.
	double R0;             // Абсолютный оптимум запаса
	double R0p;            // Оптимум запаса с учетом кратности упаковки
	double R;              // Текущее расчетное значение оптимального запаса в объемной оптимизации
	double Period;         // Количество дней, в течении которых ожидается ликвидация остатка R.
	double Income;         // Ожидаемый доход от остатка R
	double Expend;         // Ожидаемые издержки по закупке и хранению количества R
	double LastDelta;      // Разность в критерии оптимальности, полученная в результате последней
		// итерации. Нобходима для быстрого поиска позиции, которая может быть частично выведена из
		// ассортимента для увеличения доли иной позиции.
};

class PPViewStockOpt : public PPView {
public:
	PPViewStockOpt();
	~PPViewStockOpt();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(StockOptViewItem *);
private:
	static int GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI EditItem(PPStockOpt::Item * pItem);
	SArray * SLAPI Helper_CreateBrowserArray();

	PPStockOpt So;
	StockOptFilt Filt;
};
//
// @ModuleDecl(PPViewGoodsTaxAnalyze)
//
struct GoodsTaxAnalyzeFilt : public PPBaseFilt {
	SLAPI  GoodsTaxAnalyzeFilt();
	int    SLAPI HasCycleFlags() const;

	enum {
		fNozeroExciseOnly = 0x0001,
		fLabelOnly        = 0x0002,
		fVATByTrnovr      = 0x0004,
		fIgnoreVatFreeTag = 0x0008,
		fDayly            = 0x0010, // Книга учета частного предпринимателя (по дням)
		fMonthly          = 0x0020, // Книга учета частного предпринимателя (по месяцам)
		fByPayment        = 0x0040, // Рассчитывать операции по оплатам
		fDiffAll          = 0x0080, //
		fDiffByInVAT      = 0x0100, //
		fDiffByOutVAT     = 0x0200, //
		fOldStyleLedger   = 0x0400, // Книга учета частного предпринимателя без
			// масштабирования отгрузок по оплатам поставщику.
		fLedgerByLots     = 0x0800  // Книга учета частного предпринимателя по приходам
	};
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	DateRange LotsPeriod;
	PPID   LocID;
	PPID   GoodsGrpID;
	PPID   SupplID;
	PPID   SupplAgentID;
	PPID   OpID;
	PPID   ObjectID;
	PPCycleFilt Cycl;
	long   Flags;           // GoodsTaxAnalyzeFilt::fXXX
	SubstGrpGoods Sgg;      // Подстановка товара
	ObjIdListFilt BillList; // @anchor
};

struct GoodsTaxAnalyzeViewItem {
	LDATE  Dt;
	char   BillNo[24];     // Номер документа
	PPID   GoodsID;
	PPID   GoodsGrpID;
	char   Name[128];      // @v6.6.2 [64]-->[128]
	char   TaxStr[48];     //
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsTaxAnalyze instance

	double Qtty;
	double PhQtty;
	double TrnovrCost;
	double TrnovrPrice;
	double Income;
	PPID   LotTaxGrpID;
	PPID   GoodsTaxGrpID;
	long   TaxFlags;
	double ExciseSum;
	double C_VATSum;
	double C_STaxSum;
	double VATSum;
	double IncVATSum;
	double STaxSum;
	double ExpQtty;
	double Rest;
};

struct GoodsTaxAnalyzeTotal {
	long   Count;          // Количество строк в отчете
	double TrnovrCost;     // Оборот в ценах поступления //
	double TrnovrPrice;    // Оборот в ценах реализации  //
	double Income;         // Доходность
	double ExciseSum;      // Сумма акциза
	double C_VATSum;       // Сумма НДС в ценах поступления //
	double VATSum;         // Сумма НДС в ценах реализации  //
	double IncVATSum;      // Сумма НДС с дохода
	double STaxSum;        // Сумма налога с продаж
	//
	// Три поля итогов для тетради частного предпринимателя по приходам
	//
	double PilRcptSum;     // Сумма оплаченных приходов
	double PilExpSum;      // Сумма оплаченных расходов
	double PilRestSum;     // Сумма неоплаченного остатка
};

//
// Структура, передаваемая объекту PPALDD_GoodsTaxAnlz для печати
// Used: V_GTANLZ.CPP
//
struct GTaxAnlzTotalPrintData {
	const GoodsTaxAnalyzeTotal * P_Total;
	const GoodsTaxAnalyzeFilt  * P_Filt;
	const BVATAccmArray        * P_VATList;
};

class PPViewGoodsTaxAnalyze : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByID,
		OrdByName,
		OrdByGrp_Name
	};
	SLAPI  PPViewGoodsTaxAnalyze();
	SLAPI ~PPViewGoodsTaxAnalyze();
	const  BVATAccmArray * GetInOutVATList() const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder = OrdByDefault);
	int    FASTCALL NextIteration(GoodsTaxAnalyzeViewItem *);
	void   SLAPI FormatCycle(LDATE, char * pBuf, size_t bufLen);
	int    SLAPI PrintTotal(const GoodsTaxAnalyzeTotal * pTotal);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI CalcTotal(GoodsTaxAnalyzeTotal *);
	int    SLAPI MakeTaxStr(GoodsGrpngEntry *, char * pBuf, size_t bufLen);
		// @<<PPViewGoodsTaxAnalyze::AddEntry
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();

	GoodsTaxAnalyzeFilt Filt;

	TempGoodsTaxAnlzTbl * P_TempTbl;
	GoodsGroupIterator  * P_GGIter;
	PPCycleArray CycleList;
	PPIDArray    OpList;
	int    IterIdx;
	BVATAccmArray * P_InOutVATList;
	// @v9.6.6 char   IterGrpName[256];
	SString  IterGrpName; // @v9.6.6
	PPObjGoods GObj;
	GoodsSubstList Gsl;
};
//
// @ModuleDecl(PPViewPriceList)
//
struct PriceListConfig {       // @persistent @store(PropertyTbl)
	PPID   Tag;                // Const=PPOBJ_CONFIG
	PPID   ID;                 // Const=PPCFG_MAIN
	PPID   Prop;               // Const=PPPRP_PLISTCFG
	long   Flags;              // PLISTF_XXX
	PPID   AddPriceQuot[6];    // Used only first 3
	PPID   ExtFldMemoSubst;    // Дополнительное поле товара,
		// которое следует подставлять вместо примечания к строке (GDSEXSTR_XXX)
	long   Reserve1[8];        // @reserve
	PPID   GoodsGrpID;         //
	PPID   LocID;              //
	char   OrgName[48];        //
	char   Business[48];       //
	char   PublisherMail[48];  //
	char   Reserve[32];        //
	char   ExportSpec[256];    //
};

int SLAPI ReadPriceListConfig(PriceListConfig *);

#define PLISTF_PRESENTONLY  0x0001L  // Отфильтровывает только те строки,
	// товар по которым присутствует на складе
#define PLISTF_BYQUOT       0x0002L  // Позволяет формировать прайс-лист по
	// котировкам, в противном случае - только по базовым ценам
#define PLISTF_FILLQCERT    0x0004L  // Заполнять поле PriceListViewItem::QCertID
	// Этот флаг влияет только на инициализацию функцией
	// PPViewPriceList::NextIteration() поля PriceListViewItem::QCertID,
	// по этому может быть установлен после вызова PPViewPriceList::Init,
	// но до вызова PPViewPriceList::InitIteration().
#define PLISTF_EXCLGGRP     0x0008L  // Исключить из прайс-листа группу PriceListFilt::GoodsGrpID
#define PLISTF_NEWP         0x0010L  // Только те товары, которых не было на дату (LotPeriod.low-1)
#define PLISTF_SENDINXML    0x0020L
#define PLISTF_NOTCFMDEL    0x0040L  // Не запрашивать подтверждение перед удалением строки
#define PLISTF_USECOMMON    0x0080L  // Использовать общий прайс-лист
#define PLISTF_CALCREST     0x0100L  // Рассчитывать остатки
#define PLISTF_IGNZEROQUOT  0x0200L  // Если QuotKindID >= 0, то будут показаны те товары, которые
	// не имеют подходящей котировки

class PriceListFilt : public PPBaseFilt {
public:
	SLAPI  PriceListFilt();
	PriceListFilt & FASTCALL operator = (const PriceListFilt &);
	int    SLAPI Setup();

	char   ReserveStart[24];   // @anchor
	RealRange PriceRange;
	LDATE  Dt;
	PPID   ArticleID;
	PPID   LocID;
	PPID   QuotKindID;
	PPID   PListID;
	PPID   GoodsGrpID;
	PPID   ManufID;
	PPID   LotSupplID;         // Поставщик, товары которого должны быть включены в прайс-лист
	PPID   UserID;             // разделение прайса по пользователям (для каждого пользователя свой прайс-лист)
	long   Flags;              // PLISTF_XXX
	DateRange  LotPeriod;      // Период прихода товаров, которые должны быть включены в прайс-лист
	SubstGrpGoods Sgg;         // Подстановка товара
	double PctAdd;
	SString Memo;              // @anchor
	ObjIdListFilt GrpIDList;   // Список групп, которые должны быть включены в прайс-лист
	ObjIdListFilt GoodsIDList; // Список товаров, которые должны быть включены в прайс-лист
		// для печати ценников из броузера товаров, используется в функциях InitIteration(), NextIteration().
};

struct PriceListViewItem {
	PriceListViewItem()
	{
		Clear();
	}
	void   Clear()
	{
		memzero(this, offsetof(PriceListViewItem, GoodsName_));
		GoodsName_ = 0;
		GoodsGrpName_ = 0;
		Memo_ = 0;
	}
	PPID   PListID;        //
	int16  LineNo;         //
	int16  Reserve;        // @alignment
	long   LN;             // Номер строки по итератору
	PPID   GoodsGrpID;     //
	PPID   GoodsID;        //
	PPID   QuotKindID;     //
	PPID   ManufID;        //
	PPID   UnitID;         //
	PPID   QCertID;        // if(!(PriceListFilt::Flags & PLISTF_FILLQCERT)) then 0
	long   GoodsCode;      //
	LDATE  Expiry;         //
	double UnitsPerPack;   //
	double Price;          //
	double AddPrice1;      //
	double AddPrice2;      //
	double AddPrice3;      //
	double Rest;           //
	SString GoodsName_;    // @anchor
	SString GoodsGrpName_;
	SString Memo_;
};

class PPPriceListImpExpParam : public PPImpExpParam {
public:
	PPPriceListImpExpParam(uint recId = 0, long flags = 0);
};

typedef TSArray <Sdr_PriceList> Sdr_PriceListArray;

class PPViewPriceList : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrpName_GoodsName,
		OrdByGrpCode_GoodsName
	};

	SLAPI  PPViewPriceList();
	SLAPI ~PPViewPriceList();
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(PriceListViewItem *);
	virtual int  SLAPI Print(const void * pHdr);
	int    SLAPI SearchListByFilt(PriceListFilt *, PPID * pID, PriceListTbl::Rec *);
	int    SLAPI UpdatePriceList(LDATE date, int rmvOld, int use_ta); // @>>PriceListCore::Add
	int    SLAPI AddPriceList(PPID * pListID, PriceListTbl::Rec * pRec, int useTa);
	int    SLAPI SearchLine(PriceLineIdent *, PriceLineTbl::Rec *);
	int    SLAPI AddLine(PriceLineIdent *);
	int    SLAPI EditLine(PriceLineIdent *);
	//
	// Descr: Remove line by pIdent. If !pIdent then removed all lines by Filt.PListID
	//
	int    SLAPI RemoveLine(PriceLineIdent * pIdent);
	int    SLAPI GetLastQCertID(PPID goodsID, LDATE dt, PPID * pQCertID);
	int    SLAPI SendPList();
	int    SLAPI Export();
	int    SLAPI Export_Pre9302();
	int    SLAPI ExportUhtt();
	int    SLAPI ConvertLinesToBasket();
	int    SLAPI ConvertBasketToLines();

	struct RecalcParamBlock {
		PPObjQuotKind QkObj;
		int    GoodsPriceWoTaxes;
		int    LotPriceWoTaxes;
		LDATE  Dt;         // @v9.0.9
		PPID   GoodsID;
		PPID   GoodsGrpID; // = Goods(GoodsID).ParentID
		PPID   TaxGrpID;
		double TaxFactor;
		double Cost;
		double BasePrice;
		double AddPrices[6];
		LDATE  Expiry;
		double Rest;
	};
	int    SLAPI InitRPB(RecalcParamBlock *, Goods2Tbl::Rec *, int lotPriceWoTaxes, double cost, double price, LDATE);
	int    SLAPI SetByQuot(RecalcParamBlock *, double price, int isPresent, int use_ta);
	int    SLAPI GetPriceByQuot(RecalcParamBlock *, PPID, double *);
	int    SLAPI UpdatePriceList(LDATE date, Sdr_PriceListArray * pList, int useTa);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI UpdateTempTbl(PriceLineIdent *);
	int    SLAPI SetGoodsPrice(RecalcParamBlock * pRPB, PPID quotKindID, double unitsPerPack, double price, int isPresent, int use_ta);
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();
	int    SLAPI NextIterationByList(PriceListViewItem * pItem); // используется для печати ценника по списку товаров
	int    SLAPI SendPListInXmlFormat();
	double SLAPI GetRest(PPID goodsID);
	int    SLAPI SubstGoods(PPID goodsID, PPID * pSubstID, char * pBuf, size_t bufSize);

	PriceListFilt Filt;
	PriceListCore Tbl;
	PPObjBill * P_BObj;
	PPObjGoods  GObj;
	PPObjGoodsClass GCObj;
	PriceLineTbl * P_TempTbl;
	GoodsGroupIterator * P_GGIter;
	int    IterIdx;
	SString IterGrpName_;
	GoodsSubstList Gsl;

	enum {
		stFiltArIsSupple = 0x0001 // Статья Filt.ArticleID является поставщиком
	};
	long   State;         // @v9.3.4
	PPID   NewGoodsGrpID; // Идентификатор последней группы, из которой добавляли новую строку
public:
	PriceListConfig Cfg; // Realy private. Used only from PPALDD_PriceListData
};

//
// @ModuleDecl(PPViewDebtTrnovr)
//
class DebtTrnovrFilt : public PPBaseFilt {
public:
	SLAPI  DebtTrnovrFilt();

	enum {
		fDebtOnly       = 0x0001, // Только по документам с ненулевым долгом
		fPrintExt       = 0x0002, // Печатать долговые документы с каждым клиентом
			// Учитывать только те оплаты, которые сделаны за период Period
		fNoForwardPaym  = 0x0004, //
		fLabelOnly      = 0x0008, // Только по WL-документам
		fByReckoning    = 0x0010, //
		fAllCurrencies  = 0x0020, //
		fByCost         = 0x0040, // В ценах поступления (COST)
		fExtended       = 0x0080, // Расширенный отчет с зачетными операциями
		fInclZeroDebt   = 0x0100, // Включать контрагентов с нулевыми долгами
		fDeliveryAddr   = 0x0200, // Использовать адрес доставки
		fCalcTotalDebt  = 0x0400, // Рассчитывать значение общего долга до конца
			// периода оплаты (независимо от периода отгрузки и периода срока оплаты)
			// Этот флаг несколько увеличивает время обработки
		fSkipPassive    = 0x0800, // @v7.0.1 Пропускать пассивные аналитические статьи
		fShowExpiryDebt = 0x1000  // @v9.2.3 Показывать сумму просроченного долга
	};
	//
	// Виды цикличности отчета
	//
	enum {
		ckNone   = 0,
		ckExpiry = 1, // Долги по количеству дней, прошедших с установленного срока оплаты
		ckDelay,      // Долги по количеству дней, прошедших с дня отгрузки (даты документа)
		ckShipments,  // Отгрузки по циклам
		ckPayments    // Оплаты по циклам
	};
	enum {
		ekNone = 0,
		ekExpiryPart, // Отчет по доле просроченных долгов
			// Максимальный срок оплаты определяется полем ExpiryTerm.
			// Если ExpiryTerm == 0, то из даты оплаты по документу
			// При использовании этого вида отчета
			//   сумма отгрузки подменяется общей суммой долга,
			//   сумма долга - просроченной суммой долга,
			//   сумма оплаты - разницей между общей суммой долга и просроченной суммой долга.
		ekTurnover,   // Оборачиваемость дебиторской задолженности
	};

	char   ReserveStart[20]; // @anchor
	PPID   GoodsGrpID;       // @v9.5.1 Товарная группа, ограничивающая расчет
	SubstGrpBill Sgb;        // Подстановка документа.
	DateRange Period;        // Период отгрузки
	DateRange PaymPeriod;    // Период оплаты
	DateRange ExpiryPeriod;  // Период срока оплаты
	PPID   AccSheetID;       //
	PPID   CurID;            //
	PPID   AgentID;          //
	PPID   PayerID;          //
	long   InitOrder;        // PPViewDebtTrnovr::OrdByXXX
	long   Flags;            // @flags
	PPID   OpID;             // Вид операции
	int32  Reserve;          // @reserve
	PPID   CityID;           // Город
	PPID   CategoryID;       // Категория персоналии
	long   CycleKind;        // DebtTrnovrFilt::ckXXX
	PPCycleFilt Cf;          //
	long   ExtKind;          // ekXXX
	long   ExtExpiryTerm;    // ExtKind == ekExpiryPart
		// Максимальный срок оплаты для расширения отчета
		// ExtKind == ekExpiryPart. Если ExtExpiryTerm == 0, то срок оплаты берется из документа.
	double ExtExpiryMinPart; // ExtKind == ekExpiryPart
		// Минимальный процент просроченной задолженности, меньше
		// которого не следует добавлять данные в отчет
	PPID   Article2ID;       // Дополнительный объект
	PPID   AccSheet2ID;      // Таблица статей дополнительного объекта
	PPIDArray LocIDList;     // @anchor Список складов, по которым следует рассчитывать долги
	PPIDArray CliIDList;     // Список контрагентов, по которым необходимо поднять отчет
	//
	// Следующие два списка, если не пустые, то имеют приоритет над остальными условиями
	// фильтрации. Фактически, они применяются для детализации отчета.
	//
	ObjIdListFilt BillList;     // @v7.0.2 Список документов, по которым следует построить отчет
	ObjIdListFilt RcknBillList; // @v7.0.2 Список зачетных документов, по которым следует построить отчет
	ObjIdListFilt DebtDimList;  // @v9.1.4 Список долговых размерностей, которыми следут ограничить построение отчета
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver); // @v9.1.4
};

struct DebtTrnovrViewItem { // @transient
	long   ID_;            // Ведущий идентификатор элемента. Это может быть как ид статьи, так и ид иного
		// типа объекта. Для выяснения к какому типу отностися данный идентификатор необъодимо
		// воспользоваться функцией PPObjBill::GetSubstObjType().
	PPID   ObjType;        // Тип объекта, которым представляется поле ID_
	long   Ar;             //
	PPID   PersonID;       //
	char   ArName[128];    // @v7.1.1 [80]-->[128]
	PPID   BillID;         //
	PPID   CurID;          //
	long   TabID;          //
	char   TabText[32];    //
	LDATE  PayDate;        // if BillID == 0 then PayDate == 0
	LDATE  LastPaymDate;   // Дата последнего платежа по документу (if BillID == 0 then LastPAymDate == 0)
	double Debit;          // Shipment
	double Credit;         // Payment
	double Debt;           // Shipment - Payment
	double RPaym;          // Платежи по зачету
	double Reckon;         // Зачтенные платежи
	double RDebt;          // Долг по зачету
	double TDebt;          // Общий долг (Debt-RDebt)
	double ExpiryDebt;     // @v9.1.8 Просроченный долг
	long   DebitCount;     //
	long   CreditCount;    //
	double _AvgPaym;       // Средняя оплата по табуляторам без учета нулевых значений
	int8   IsStop;         // По статье установлен признак "Стоп"
	int8   Reserve;        // @reserve
	int16  MaxDelay;       // Максимальная задержка платежа
};

struct DebtTrnovrTotal {
	SLAPI  DebtTrnovrTotal();
	void   SLAPI Init();
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	long    Count;         //
	AmtList Debit;         //
	AmtList Credit;        //
	AmtList Debt;          //
	AmtList RPaym;         // Платежи по зачету
	AmtList Reckon;        // Зачтенные платежи
	AmtList RDebt;         // Долг по зачету
	AmtList TDebt;         // Общий долг
	AmtList ExpiryDebt;    // @v9.1.8 Просроченный долг
};

class PPViewDebtTrnovr : public PPView {
public:
	struct BrwHdr {
		PPID   ArID;
		PPID   CurID;
		long   TabID;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByArticleID,
		OrdByArticleName,
		OrdByDebit,
		OrdByDebt,
		OrdByStop
	};

	SLAPI  PPViewDebtTrnovr();
	SLAPI ~PPViewDebtTrnovr();
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(DebtTrnovrViewItem *);
	int    SLAPI GetItem(PPID arID, PPID curID, long tabID, DebtTrnovrViewItem *);
	//
	// Descr: Режимы детализации
	//
	enum {
		dmDebt = 0,    // Показать долговые документы (а также, детализация по умолчанию - например детализация группировки).
		dmDebtCard,    // Показать долговую карточку контрагента (хронологическое перечисление документов долгов и оплат).
		dmReckon,      // Показать зачетные документы
		dmDebtOnline,  // Показать долговые документы с обновлением
		dmReckonOnline // Показать зачетные документы с обновлением
	};
	int    SLAPI Detail(const BrwHdr *, int mode);
	//
	// ARG(what IN):
	//   0 - show article
	//   1 - show person
	//
	int    SLAPI ViewArticleInfo(const BrwHdr * pHdr, int what);
	int    SLAPI GetPayableBillList(PPID arID, PPID curID, PayableBillList * pList);
		// @>>PPViewDebtTrnovr::GetPayableBillList_
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;
	int    SLAPI GetTotal(DebtTrnovrTotal * pTotal);
	const  PPObjBill::SubstParam & GetBillSubstBlock() const
	{
		return Bsp;
	}

	LDATE  ExpiryDate;
private:
	struct DebtEntry {
		SLAPI  DebtEntry(PPID ident = 0)
		{
			ID = ident;
			_AvgPaym = 0.0;
		}
		PPID   ID;             // @anchor Идентификатор блока. Фактический смысл этого идентификатора
			// определяется параметром Filt.Sgb (подставновкой по долговому документу)
		double _AvgPaym;       // Средняя оплата по табуляторам без учета нулевых значений
		AmtList DbtList;
		AmtList PaymList;
		AmtList ExpiryDebtList; // @v9.1.8 Компонент для учета общей суммы просроченного долга
		AmtList RDbtList;
		AmtList RcknList;
		// Следующие два поля используются если (Filt.Flags & DebtTrnovrFilt::fCalcTotalDebt)
		AmtList TotalDbtList;  // Отгрузки для расчета общего долга
		AmtList TotalPaymList; // Оплаты для расчета общего долга
	};
	struct ProcessBlock : public TSCollection <DebtEntry> {
		ProcessBlock(const DebtTrnovrFilt & rF);
		~ProcessBlock();
		ProcessBlock & ResetIter();
		ProcessBlock & ResetStep();
		int    AddStepItem(PPID tabID, double paym, double expiryDebt);
		double MultCostCoef(double val, int zeroIfDivZero) const;
		//
		// Общие параметры расчета
		//
		const  DebtTrnovrFilt & R_F;    //
		const  LDATE CurrentDate;       // = NZOR(Filt.PaymPeriod.upp, LConfig.OperDate)
		const  int   DoCheckAddr;       // = BIN(Filt.CityID)
		const  int   ByLinks;           // = BIN(Filt.Flags & DebtTrnovrFilt::fNoForwardPaym || !Filt.PaymPeriod.IsZero())
		const  int   ByCost;            // = BIN(Filt.Flags & DebtTrnovrFilt::fByCost)
		const  DateRange * P_PaymPeriod; // = (Filt.Flags & DebtTrnovrFilt::fNoForwardPaym && Filt.PaymPeriod.IsZero()) ? &Filt.Period : &Filt.PaymPeriod
		//
		uint   FullArListCount;         // Общее количество статей в аналитической таблице Filt.AccSheetID.
			// Значение необходимо для правильного выбора алгоритма расчета.
		PPIDArray ArList;
		PPIDArray ExtBillList;   // Список документов, связанных с Filt.AgentID || Filt.PayerID

		enum Itp {
			ipUndef          = 0,
			ipOp             = 1,
			ipArticle        = 2,
			ipReckonOp       = 3,
			ipByAgentList    = 4,  // Перебор по списку документов, связанных с заданным агентом
			ipBillList       = 10,
			ipReckonBillList = 13
		};
		Itp    IterPath; // 0 - undef, 1 - by oprkind, 2 - by article, 3 - by reckon op
		uint   IterN;    // Номер итерации
		IterCounter Cntr; // Счетчик для вывода хода выполнения процесса
		SString IterMsgPrefix; // Префекс текста сообщения о ходе выполнения процесса
		//
		PPID   ReckonOpID;
		PPID   ReckonAccSheetID; // == PPOprKind(ReckonOpID).AccSheetID
		//
		//
		//
		BExtQuery * P_Q;
		//
		// Step specific data {
		//
		long   Flags;
		LDATE  Date;
		LDATE  PayDate;
		PPID   CurID;
		double Amount;
		double Paym;
		double Debt;
		double ExpiryDebt; // @v9.1.8
		double Cost;
		PPBillExt Ext;
		RAssocArray PaymList;
		DebtEntry * P_Entry;
		// }
	};

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	int    SLAPI GetPayableBillList_(const PPIDArray *, PPID arID, PPID curID, PayableBillList * pList);
	int    SLAPI CheckBillRec(const BillTbl::Rec * pRec, const PPIDArray * pOpList);
	int    SLAPI GetReceivableBillList(PPID arID, PayableBillList * pList);
	int    SLAPI NextInnerIteration(int initList, DebtTrnovrViewItem * pItem);
	int    SLAPI SetupRecVals(PPID curID, long tabID, const DebtEntry *, TempSellTrnovrTbl::Rec *);
	void   SLAPI InitViewItem(const TempSellTrnovrTbl::Rec *, DebtTrnovrViewItem *);
	int    FASTCALL CheckAddress(PPID locID); // AHTOXA @<<PPViewDebtTrnovr::GetPayableBillList_
	int    SLAPI GetDlvrAddrList();
	int    SLAPI GetDlvrAddr(PPID billID, PPID * pAddrID);
	int    SLAPI NextProcessIteration(PPID reckonOpID, ProcessBlock & rBlk);
	int    SLAPI NextProcessStep(BillTbl::Rec & rRec, ProcessBlock & rBlk);
	int    SLAPI PreprocessBill(const BillTbl::Rec & rRec, const ProcessBlock & rBlk, PPID * pArID, PPBillExt * pBillExt, double * pPart);
	int    SLAPI ProcessBill(const BillTbl::Rec & rRec, ProcessBlock & rBlk);
	int    SLAPI ProcessBillPaymPlanEntry(const BillTbl::Rec & rRec, const PayPlanTbl::Rec & rPayPlanEntry, PPID arID, ProcessBlock & rBlk);

	const int UseOmtPaymAmt;        // @v8.5.8 = BIN(CConfig.Flags2 & CCFLG2_USEOMTPAYMAMT)
	DebtTrnovrFilt  Filt;           // @viewstatefilt
	PPIDArray PayableOpList;        // @!Init_() Список операций, требующих оплаты для таблицы Filt.AccSheetID. // @viewstate
	PPIDArray GoodsList;            // @v9.5.1 @!Init_() Список товаров, ограничивающих отчет
	DebtTrnovrTotal Total;          // @viewstate
	PPObjBill * P_BObj;             //
	PPObjPerson PsnObj;             //
	PPObjArticle ArObj;             //
	PPObjWorld WObj;                //
	int    IterBillCounter;         //
	DebtTrnovrViewItem IterCurItem; //
	// PayableBillList * IterBillList; // @viewstate
	PPIDArray * P_IterBillList;     //
	LAssocArray * P_DebtDimAgentList; // @v9.1.4 Блок, реализующий быструю идентификацию принадлежности документа долговой размерности
	TempSellTrnovrTbl * P_TempTbl;  // @viewstatetable
	LAssocArray DlvrAddrList;       // @viewstate
	int    IsDlvrAddrListInited;    // @viewstate
	PPObjBill::SubstParam Bsp;      // @viewstate @v7.0.1 Параметр подстановки по документам
	PPObjBill::SubstParam RcknBsp;  // @viewstate @v7.0.1 Параметр подстановки по зачетным документам
		// RcknBsp отличается от Bsp только внутренним списком ассоциаций Подстановка-Документ
	PPIDArray DaySieve;             // Решето, фильтрующее документы по периоду (дней) задолженности
	PPCycleArray CycleSieve;        // Решето, фильтрующее документы по дате оплаты (отгрузки и т.д.)
};
//
//
//
struct PaymDelayEntry {
	PPID   ArID;
	int16  Term;
	int16  Delay;
	int16  Expiry;
	int16  Reserve;
};

struct PPDebtorStat {
	enum {
		fAgent   = 0x0001, // Запись относится к агенту (агрегат)
		fHolding = 0x0002  // Запись относится к холдингу (агрегат)
	};
	SLAPI  PPDebtorStat(PPID arID);
	int    SLAPI AddPayment(PPID debtDimID, LDATE dt, double amount);
	int    SLAPI Finish();
	int    SLAPI IsAggregate() const
	{
		return BIN(ArID == 0 || (Flags & (fAgent|fHolding)));
	}
	//
	// Descr: Возвращает коэффициент вариации задержки платежа.
	//   Если мат ожидание нулевое, то возвращает SMathConst::Max
	//
	double SLAPI GetDelayVarRate() const;

	PPID   ArID;
	PPID   RelArID;
	double DelayMean;
	double DelayVar;
	double DelayGammaAlpha;
	double DelayGammaBeta;
	double DelayGammaTest;
	double ExpiryMean;
	double PaymAmount;
	double PaymDensity;
	double Limit;
	double DebtCost;
	double SigmFactor;
	LDATE  FirstPaymDate;  // Дата первого платежа от контрагента
	LDATE  LastPaymDate;   // Дата последнего платежа от контрагента
	long   PaymPeriod;     // = (LastPaymDate - FirstPaymDate + 1)
	long   LimitTerm;      // Срок (в днях), на который рассчитан кредитный лимит
	long   Flags;
	char   Rating[12];

	LongArray DelayList;
	LongArray ExpiryList;
	//
	// Descr: Элемент статистики, дифференцированный по долговой размерности
	//
	struct DebtDimItem {
		long   GetPaymPeriod() const
		{
			return (FirstPaymDate && LastPaymDate) ? diffdate(LastPaymDate, FirstPaymDate) + 1 : 0;
		}
		double CalcPaymDensity() const
		{
			long   paym_period = GetPaymPeriod();
			return (paym_period > 0) ? (PaymAmount / paym_period) : 0.0;
		}
		PPID   DebtDimID;
		LDATE  FirstPaymDate;  // Дата первого платежа от контрагента
		LDATE  LastPaymDate;   // Дата последнего платежа от контрагента
		double PaymAmount;
		double Limit;
	};
	TSArray <DebtDimItem> DdList; // @v7.04
};

class PPDebtorStatArray : public TSCollection <PPDebtorStat> {
public:
	struct Total {
		double PaymPeriodMean;   // Средний период платежей по всей выборке (без учета общей строки)
		double ExpiryMean;       // Средняя просрочка платежей по всей выборке (без учета общей строки)
		double DelayVarRateMean; // Средний коэф вариации задержки платежей по всей выборке (без учета общей строки)
		double PaymRatingMean;   // Среднее значение меры рейтинга по плотности платежей
		double PaymRatingBar;    // Шарина полосы рейтинга по плотности платежей
		double DelayRatingMean;  // Среднее значение меры рейтинга по задержкам платежей
		double DelayRatingBar;   // Ширина полосы рейтинга по задержкам платежей
		double SigmFactor;       // =PPDebtorStatConfig::PaymSigmFactor
	};
	SLAPI  PPDebtorStatArray();
	PPDebtorStat * FASTCALL Get(PPID arID);

	enum {
		omUndef = 0,
		omLimitByPaymDensity = 1, // Комбинация точек: {PaymDensity, PaymPeriod, Limit}
		omDelayExpiryDots,        // Комбинация точек: {DelayMean, DelayVar, ExpiryMean}
		omRatingData,             // Комбинация точек: {PaymRatingVariable, DelayRatingVariable, RatingRgbColor}
		omSigmFactor              // Комбинация точек: {PaymPeriod, SigmFactor, 0.0}
	};
	int    SLAPI CalcRating(Total * pTotal, int outMatrixStyle = 0, TSArray <RPoint3> * pOutMatrix = 0);
	double SLAPI GetSigmFactor(double sigmA, long paymPeriod, double paymPeriodMean) const;
	int    SLAPI CalcDelayIndex(const PPDebtorStat * pItem, const Total * pTotal, double expWeight, double * pResult) const;
private:
	double SLAPI PreprocessRatingVal(double val) const;
	int    LogRating; // Для расчета рейтингов используется логарифмическая шкала
};

struct PPDebtorStatConfig { // @persistent @store(PropertyTbl)
	static int SLAPI Read(PPDebtorStatConfig *);
	static int SLAPI Edit();

	SLAPI PPDebtorStatConfig()
	{
		THISZERO();
	}

	enum {
		fLimitTermFromAgreement = 0x0001, // Если у контрагента есть соглашение, то
			// расчетный срок для кредитного лимита брать из поля PPClientAgreement::DefPayPeriod //
		fProcessAgents          = 0x0002, // Собирать статистику так же и по агентам, к которым относятся документы
		fLogRatingVal           = 0x0004, // Логарифмировать индексы для выстраивания рейтингов
		fSimpleLimitAlg         = 0x0008  // Упрощенный метод расчета кредитного лимита.
			// Заключается в делении суммарных платежей за период на длительность периода в днях.
			// При этом сигма-фактор не учитывается.
			// Работает только в случае, если определен период расчета.
	};
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_DEBTORSTATCFG
	double PaymSigmFactor;  // Параметр сигмоидальной функции коэффициента плотности платежей
	double FinRate;         // Процентная ставка финансирования для расчета стоимости дебиторской задолженности
	uint32 LimitTerm;       // Срок, на который рассчитывается кредитный лимит
	long   LimitRoundPrec;  // .01 @#{0..50000} Точность округления кредитного лимита //
	int16  LimitRoundDir;   // Направление округления кредитного лимита
	int16  LimitAddedTerm;  // @v8.2.4 Дополнительный период для которого рассчитывается производное значение кредитного лимита для отображения //
	float  DelayBar;        // @def{0.5f} Ширина градации разбивки дебиторов на сегменты по задержкам платежей (в долях от StdDev)
	float  PaymBar;         // @def{1.0f} Ширина градации разбивки дебиторов на сегменты по плотности платежей (в долях от StdDev)
	float  ExpiryWeight;    // @def{0.5f} Весовой коэффициент средней величины просрочки платежей в общем рейтинге.
	long   Flags;           //
	PPID   HoldingRelTypeID; // ->PPRef(PPOBJ_PERSONRELTYPE) Тип персонального отношения для подстановки холдинга
		// вместо статьи
	float  LimitFactor;     // @#[0..10] @def{1.0} Поправочный коэффициент для кредитного лимита
	DateRange Period;       // Период сбора статистики платежей
	LDATETIME LastDtm;      // Время последнего сбора статистики
	int32  Reserve2;
};
//
//
//
class DebtStatCore : public DebtStatTbl {
public:
	SLAPI  DebtStatCore(const char * pFileName = 0);
	int    SLAPI GetLastDate(PPID accSheetID, LDATE * pDt);
	int    SLAPI SetList(PPID accSheetID, LDATE date, const PPDebtorStatArray &, int use_ta);
	int    SLAPI GetList(PPID accSheetID, PPDebtorStatArray &);
};
//
//
//
class DebtorStatFilt : public PPBaseFilt {
public:
	enum {
		ordByDefault = 0,
		ordByArName,
		ordByDelayMean,
		ordByDelaySd,
		ordByDelayGammaTest,
		ordByPaymPeriod,
		ordByPaymDensity,
		ordByRating,
		ordByExpiryMean
	};
	enum {
		fTimeLine     = 0x0001, // Показывать динамику показателей по статье ArID
		fIncludeTotal = 0x0002, // Включать в выборку итоговую строку
		fIncludeRel   = 0x0004, // Включать в выборку агрегации по отношению
		fIncludeAgent = 0x0008, // Включать в выборку агрегации по агентам
		fIncludeTerm  = 0x0010  // Включать в выборку терминальные статьи
	};
	SLAPI  DebtorStatFilt();

	uint8  ReserveStart[28]; // @anchor @reserve
	PPID   ArID;             // ->Article.ID
	PPID   AccSheetID;       // ->Ref(PPOBJ_ACCSHEET)
	DateRange Period;
	long   Flags;
	long   Order;
	ObjIdListFilt ArList;    // @anchor
};

struct DebtorStatViewItem {
	PPID   ArID;
	PPID   RelArID;
	LDATETIME Dtm;
	long   Flags;
	double DelayMean;
	double DelaySd;
	double DelayTestGamma;
	double DelayTestChSq;
	double ExpiryMean;
	long   PaymPeriod;     // Период платежей (в днях, начиная с первого платежа до последнего платежа включительно)
	double PaymDensity;    // Плотность платежей (сумма / день)
	double SigmFactor;
	long   LimitTerm;      // Срок (в днях), на который рассчитан кредитный лимит
	double Limit;          // Рассчитанный кредитный лимит
	double DebtCost;       // Стоимость кредитов
	SString Rating;
	SString ArName;
};

struct DebtorStatTotal {
	long   ArCount;
};

class PPViewDebtorStat : public PPView {
public:
	SLAPI  PPViewDebtorStat();
	SLAPI ~PPViewDebtorStat();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(long ord);
	int    FASTCALL NextIteration(DebtorStatViewItem * pItem);
	int    SLAPI CheckForFilt(const DebtStatTbl::Rec & rRec) const;
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI UpdateTempTable();
	int    SLAPI MakeTempRec(long order, const DebtorStatViewItem * pItem, TempOrderTbl::Rec * pRec);
	int    SLAPI MakeViewItem(const DebtStatTbl::Rec * pRec, DebtorStatViewItem * pItem);
	int    SLAPI ViewGraph(PPViewBrowser *);

	DebtorStatFilt Filt;
	DebtStatCore Tbl;
	TempOrderTbl * P_TempTbl;
	LDATE  LastDate;
};
//
// Descr: Процессор обработки должников
//
class PrcssrDebtRate {
public:
	struct Param {         // @persistent
		SLAPI  Param();
		int    SLAPI Read(SBuffer & rBuf, long);
		int    SLAPI Write(SBuffer & rBuf, long);

		enum {
			fReportOnly            = 0x0001, // Не изменять признак СТОП, а лишь выдать сообщение о том,
				// что это следует сделать
			fReportAgtAbsence      = 0x0002, // Информировать об отсутствии клиентского соглашения //
			fAllowForMaxCredit     = 0x0004, // Учитывать максимальную сумму кредита по соглашению
			fGatherPaymDelayStat   = 0x0008, // Собирать статистику по дебиторам
			fProcessAgents         = 0x0010, // Собирать статистику по агентам
			fSetupLimit            = 0x0020, // Устанавливать кредитный лимит в соглашения //
			fUpdateLimitDebtDim    = 0x0040, // @v7.0.4 Изменять кредитный лимит дифференцированный по долговым размерностям
			fCreateLimitDebtDim    = 0x0080, // @v7.0.4 Создавать кредитный лимит дифференцированный по долговым размерностям
			fUpdateStopDebtDim     = 0x0100, // @v7.1.2 Изменять признаки STOP по долговым размерностям
			fProjCommStopToDebtDim = 0x0200  // @v7.1.2 Проецировать общий STOP на размерность, если по ней частный STOP не зафиксирован
		};
		/*
			Матрица перехода для частного STOP'а
			COMM   (_cs) - рассчитанное значение общего STOP'а
			DIM    (_ds) - рассчитанное значение частного STOP'а
			DIMEXT (_dx) - признак наличия размерности в соглашении
			DIMEFF       - эффективное (устанавливаемое) значение частного STOP'а
			---------------------------------------
			_cs    _ds     _dx | DIMEFF
				0    0       0 |      x    // Ничего не делать
				0    0       1 |      0    // Следует отключить частный STOP в соглашении
				0    1       0 |      .    // Невозможный случай: нельзя вычислить частный STOP не имея параметров размерности
				0    1       1 |      1    // Следует включить частный STOP в соглашении
				1    0       0 |     ?1+   // Если fCreateLimitDebtDim && fProjCommStopToDebtDim, то следует создать размерность с признаком STOP, в противном случае - ничего не делать
				1    0       1 |     ?1    // Если fProjCommStopToDebtDim, то включить частный STOP в соглашении
				1    1       0 |      .    // Невозможный случай: нельзя вычислить частный STOP не имея параметров размерности
				1    1       1 |      1    // Следует включить частный STOP в соглашении
		*/
		uint32 Ver;
		uint8  Reserve[32]; // @reserve
		PPID   AccSheetID;  // ->Ref(PPOBJ_ACCSHEET)
		long   Gandicap;    // Дополнительный допуск к сроку оплаты (в днях)
		long   Flags;       //
		long   Reserve2;    // @reserve
	};
	SLAPI  PrcssrDebtRate();
	SLAPI ~PrcssrDebtRate();
	int    SLAPI InitParam(Param * pParam);
	int    SLAPI EditParam(Param * pParam);
	int    SLAPI Init(const Param * pParam);
	int    SLAPI Run();
private:
	int    SLAPI GatherPaymDelayStat(PPLogger * pLogger, int use_ta);
	int    IsThereDebtRateLic;
	PPObjArticle ArObj;
	Param P;
	PPDebtorStatConfig Cfg;
};
//
// PLineFilt
//
struct PLineFilt {
	PPID   list;
	PPID   goodsGrp;
	PPID   manuf;
	double pctadd;
	int    present;
};
//
//
//
class ShipmAnalyzeFilt : public PPBaseFilt {
public:
	SLAPI  ShipmAnalyzeFilt();
	int    SLAPI TranslateToBillFilt(BillFilt *);
	virtual int SLAPI Init(int fullyDestroy, long extraData);

	enum shaknd_tag {
		shakndByOrder = 1,
		shakndByShipment,
		shakndByAck
	};
	enum shaflg_tag {
		fDebtOnly     = 0x0001, // Только по неоплаченным документам
		fLabelOnly    = 0x0002, // Только по меченым документам
		fDiffByBill   = 0x0004
	};
	char      ReserveStart[16]; // @anchor
	DateRange Period;
	PPID      LocID;
	PPID      OpID;
	PPID      AccSheetID;
	PPID      ObjectID;
	long      Flags;
	char      ReserveEnd[16];   // @anchor
};

typedef TempShipmentAnlzTbl::Rec ShipmAnalyzeViewItem;

class PPViewShipmAnalyze : public PPView {
public:
	struct BrwHdr {
		PPID   BillID;
		PPID   GoodsID;
	};
	SLAPI  PPViewShipmAnalyze();
	SLAPI ~PPViewShipmAnalyze();
	const ShipmAnalyzeFilt * SLAPI GetFilt() const { return &Filt; }
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI Init_(const PPBaseFilt *);

	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ShipmAnalyzeViewItem *);
protected:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI Print(const void * pHdr);

	ShipmAnalyzeFilt Filt;
	PPObjBill   * BObj;
	PPObjGoods    GObj;
	TempShipmentAnlzTbl * Tbl;
	LAssocArray GbList;  // Ассоциации товар-документы для детализации списка документов по товару
};
//
// @ModuleDecl(PPViewAccount)
//
struct AccountFilt : public PPBaseFilt {
	SLAPI AccountFilt();
	AccountFilt & FASTCALL operator = (const AccountFilt &);

	char   ReserveStart[32];  // @anchor
	long   Type;   // ACY_XXX
	long   Flags;
	long   Reserve;           // @anchor
};

class AccountViewItem : public PPAccount {
public:
	char   CurList[48];
};

class PPViewAccount : public PPView {
public:
	struct Hdr {
		PPID Id;
	};
	struct BrwEntry {
        PPID   ID;
        int16  Type;
        int16  Kind;
        PPAccount::_A_ A;
        PPID   CurID;
        PPID   MainOrgID;
        PPID   ParentID;
        PPID   AccSheetID;
		long   Flags;
		LDATE  OpenDate;
		LDATE  Frrl_Date;
		double Limit;
		double Overdraft;
		char   Code[20];
	};

	SLAPI  PPViewAccount();
	SLAPI ~PPViewAccount();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(AccountViewItem *);
	int    FASTCALL CheckForFilt(const PPAccount & rItem) const;
	int    SLAPI ViewArticles(PPID);
	int    SLAPI ViewAccAnalyze(PPID);
	//
	// transmitKind:
	//     0 - передать в другой раздел БД
	//     1 - сформировать структуру Charry
	//
	int    SLAPI Transmit(PPID id, int transmitKind);
private:
	static  int GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	static  void FASTCALL MakeListEntry(const PPAccount & rSrc, PPViewAccount::BrwEntry & rEntry);

	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual void * SLAPI GetEditExtraParam();
	virtual int    SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI FetchData(long id);

	static int DynFuncCheckRights;

	TSArray <BrwEntry> Data;

	AccountFilt Filt;
	PPObjAccount AccObj;
	AccAnlzFilt * P_AnlzFilt;
};
//
// @ModuleDecl(PPViewCurRate)
//
struct CurRateFilt : public PPBaseFilt {
	SLAPI  CurRateFilt();

	enum {
		fActualOnly = 0x0001   // Показывать актуальные курсы
	};
	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   CurID;
	PPID   RateTypeID;
	PPID   BaseCurID;
	long   Flags;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef CurrencyRateTbl::Rec CurRateViewItem;

class PPViewCurRate : public PPView {
public:
	SLAPI  PPViewCurRate();
	//
	// ARG(extraParam IN): Ид валюты
	//
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(CurRateViewItem *);
	int    SLAPI EditRecord(CurrencyRateTbl::Rec *, int isNew);
	int    SLAPI AddItem(CurRateIdent *);
	int    SLAPI EditItem(const CurRateIdent *);
	int    SLAPI DeleteItem(const CurRateIdent *);
	int    SLAPI GetRate(const CurRateIdent *, double * pRate);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI Print(const void *);

	CurRateFilt Filt;
	CurRateCore Tbl;
};
//
// @ModuleDecl(PPViewBalance)
//
#define BALFORM_IGNOREZEROTURNOVER 0x00000200L //
#define BALFORM_IGNOREZEROREST     0x00000400L //
#define BALFORM_THOUSAND           0x00000800L // Баланс в тысячах
#define BALFORM_ACO1GROUPING       0x00001000L // Группировать по счетам 1-го порядка
#define BALFORM_IGNOREZERO         0x00002000L //
#define BALFORM_ALLCUR             0x00004000L // Все валюты
#define BALFORM_SPREADBYSUBACC     0x00008000L // Разворачивать сальдо по субсчетам
#define BALFORM_SPREADBYARTICLE    0x00010000L // Разворачивать сальдо по субконто
#define BALFORM_SPREAD             (BALFORM_SPREADBYSUBACC|BALFORM_SPREADBYARTICLE)

struct BalanceFilt : public PPBaseFilt {
	SLAPI  BalanceFilt();

	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   AccID;
	PPID   CurID;
	uint   AccType;          // Тип счетов (ACY_BAL || ACY_OBAL || ACY_REGISTER)
	long   Flags;
	uint32 ReserveEnd;       // @anchor
};

struct BalanceViewItem {
	LDATE  Dt;
	PPID   AccID;
	PPID   CurID;
	int16  Ac;
	int16  Sb;
	char   CurSymb[8];
	double InDbtRest;
	double InCrdRest;
	double DbtTrnovr;
	double CrdTrnovr;
	double OutDbtRest;
	double OutCrdRest;
};

class PPViewBalance : public PPView {
public:
	SLAPI  PPViewBalance();
	SLAPI ~PPViewBalance();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pBaseFilt);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BalanceViewItem *);
private:
	static int GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    FASTCALL _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI ViewTotal();

	BalanceFilt Filt;
	PPObjCurrency CurObj;
	PPObjAccount  AccObj;
	uint   IterPos;
	AccTurnCore * P_ATC;
	TSArray <BalanceViewItem> List;
	BalanceViewItem Total;
};
//
// @ModuleDecl(PPViewAccAnlz)
//
enum AccAnlzKind {
	aakndGeneric     = AAKND_GENERIC,     // Общая форма анализа счета
	aakndCashBook    = AAKND_CASHBOOK,    // Кассовая книга
	aakndAccTrnovr   = AAKND_ACCTRNOVR,   // Обороты по аналитическим статьям счета
	aakndSupplTrnovr = AAKND_SUPPLTRNOVR  // Обороты по поставщикам
};

class AccAnlzFilt : public PPBaseFilt {
public:
	enum {
		aafgByAco1        = ACO_1,
		aafgByAco2        = ACO_2,
		aafgByAco3        = ACO_3,
		aafgByOp          = 101,     // Группировка по операции
		aafgByLoc         = 102,     // Группировка по складу
		aafgByExtObj      = 103,     // Группировка по дополнительному объекту документа
		aafgByAgent       = 104,     // Группировка по агенту документа
		aafgFirstRelation = 10000
	};
	enum {
		fAsCashBook      = 0x0001, // Кассовая книга
		fLabelOnly       = 0x0002, // Анализ только по проводкам, принадлежащим WL-документам
		//
		// Если флаг fAllCurrencies установлен, то анализ счета поднимаетс
		// по всем валютам, в которых номинировались проводки подпадающие
		// под остальные критерии фильтра.
		// В противном случае анализ осуществляется только по валюте,
		// заданной параметром CurID.
		//
		fAllCurrencies   = 0x0004,
		//
		// Флаг fGroupByCorAcc предусматривает группировку анализа счета по
		// корреспондирующим к AccID счетам. В зависимости от CorAco это:
		//    CorAco = aafgByAco1 - по счетам первого порядка
		//    CorAco = aafgByAco2 - по счетам второго порядка
		//    CorAco = aafgByAco3 - по терминальным счетам
		//
		//    CorAco = aafgByOp (=101) - по виду операции @v3.7.1
		//
		fGroupByCorAcc   = 0x0008,
		//
		// Если флаг fTrnovrBySheet установлен, то формируетс
		// оборотная ведомость по всем статьям балансового счета AccID.
		// При этом флаге автоматически полагается Aco = ACO_2, CorAco = 0,
		// !fGroupByCorAcc.
		//
		fTrnovrBySheet   = 0x0010,
		//
		// Следующий флаг имеет смысл только если установлен fTrnovrBySheet
		// При этом кроме бухгалтерской оборотки расчитываются остатки
		// товаров по каждому из поставщиков в ценах поступления на конец
		// заданного фильтром периода.
		//
		fTrnovrBySuppl   = 0x0020,
		//
		// Следующие два флага существенны только для оборотных ведомостей
		// по статьям (fTrnovrBySheet, fTrnovrBySuppl)
		//
		fSpprZTrnovr     = 0x0040, // Не показывать строки с нулевыми оборотами
		fSpprZSaldo      = 0x0080, // Не показывать строки с нулевым исходящим остатком
		fTotalOnly       = 0x0100, // Если флаг fTotalOnly установлен, то PPViewAccAnlz::Init
			// подсчитывает только итоги по фильтру, но не готовит данные для просмотра и печати
		fExclInnerTrnovr = 0x0200  // Исключать обороты, сделанные между подсчетами выбранного счета
	};
	SLAPI  AccAnlzFilt();
	AccAnlzFilt & FASTCALL operator = (const AccAnlzFilt & s);
	char * SLAPI GetAccText(char * pBuf, size_t bufLen) const;

	char   ReserveStart[12]; // @anchor
	PPID   Object2ID;      // Дополнительный объект по документу
	PPID   SubstRelTypeID; // Подстановка статьи по персональному отношению
	PPID   AgentID;        // ->Article.ID Агент по документу
	DateRange Period;      //
	long   Aco;            // Порядок ведущего счета ACO_XXX
	PPID   AccID;          // Ведущий счет (aco == ACO_3 ? AcctRel.ID : Account.ID)
	PPID   SingleArID;     // (fTrnovrBySheet only) Оборотка только по одной статье
	long   CorAco;         // Группировка (AccAnlzFilt::aafgXXX)
	Acct   CorAcc;         // Корр счет
	PPCycleFilt Cycl;      // Цикл анализа (If CorAco == 0 then ignored)
	long   InitOrder;      // PPViewAccAnlz::IterOrder
	long   Flags;          // Опции (AccAnlzFilt::fXXX)
	AcctID AcctId;         //
	PPID   AccSheetID;     //
	//
	// If (Flags & AccAnlzFilt::fAllCurrencies) then CurID = -1.
	// В применении к PPViewAccAnlz это делает функция PPViewAccAnlz::Init.
	// Все функции PPViewAccAnlz, которым логически должна предшествовать
	// Init полагаются на это.
	//
	PPID   CurID;          //
	PPID   LocID;          // Склад
	int    LeafNo;         // Для кассовой книги
	long   ReserveEnd;     // @anchor
};

struct AccAnlzViewItem {
	LDATE  Dt;
	long   OprNo;
	char   OrderText[32];
	PPID   BillID;
	short  RByBill;
	short  Reverse;
	PPID   ThisAccRelID;      // @v6.2.3
	PPID   AccID;
	PPID   AccRelID;          // If grouping by ACO_1 or ACO_2 then AccRelID = 0
	PPID   RelPersonID;       // Связанная со статьей счета персоналия //
		// Для оборотки по статьям счета, то это - персоналия, связанная со статьей
		// Для анализа - это персоналия, связанная с корр счетом.
	PPID   CurID;             // Валюта
	char   AccName[128];      // Наименование счета @v6.2.3 [48]-->[128]
	long   Count;             // In case of grouping Count > 1
	double InRest;            // Входящий остаток
	double DbtAmt;            // Оборот по кредиту
	double CrdAmt;            // Оборот по кредиту
	double OutRest;           // Исходящий остаток
	double SupplGoodsRestAmt; // Остаток товара по поставщику в ценах поступления //
};

struct AccAnlzTotal {
	struct Cut {
		long   CDbtCount;
		long   CCrdCount;
		double CInRest;
		double CDbtTrnovr;
		double CCrdTrnovr;
		double COutRest;
	};
	SLAPI  AccAnlzTotal();
	void   SLAPI Init();
	int    SLAPI GetCurList(PPIDArray *) const;
	int    SLAPI GetCut(PPID curID, AccAnlzTotal::Cut *) const;
	void   SLAPI AddTrnovr(int dbt, PPID curID, double amt);

	long    Count;
	long    DbtCount;
	long    CrdCount;
	//
	// В следующих списках разложены суммы и счетчики по валютам.
	// Суммы храняться по идентификаторам 0L, счетчики храняться в
	// списках DbtTrnovr и CrdTrnovr с идентификаторами 1L.
	//
	AmtList InRest;
	AmtList DbtTrnovr;
	AmtList CrdTrnovr;
	AmtList OutRest;
	AmtList InRestDbt;
	AmtList InRestCrd;
	AmtList OutRestDbt;
	AmtList OutRestCrd;
};

typedef int (*AccAnlzViewEnumProc)(AccTurnTbl::Rec *, long);

class PPViewAccAnlz : public PPView {
public:
	enum IterOrder {
		OrdByDefault,
		OrdByBillCode_Date, // for simple analyze only
		OrdByCorrAcc_Date   // for simple analyze only
	};
	enum {
		fIterNegRest = 0x0001 // В итераторе менять
		// знак входящего и исходящего сальдо
	};
	struct BrwHdr {
		LDATE  Dt;
		long   OprNo;
		PPID   BillID;
		PPID   AccRelID;
		PPID   CorAccID;
		PPID   CurID;
		Acct   A;
	};
	SLAPI  PPViewAccAnlz();
	SLAPI ~PPViewAccAnlz();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Browse(int modeless);

	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(AccAnlzViewItem *);
	int    SLAPI GetTotal(AccAnlzTotal *) const;

	void   SLAPI FormatCycle(LDATE, char * pBuf, size_t bufLen);
	int    SLAPI GetBrwHdr(const void * pRow, BrwHdr * pHdr) const;

	LDATE  ExpiryDate; //
	uint   IterFlags;  // PPViewAccAnlz::fIterXXX
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI ViewTotal();

	int    SLAPI EditSupplTrnovrFilt(AccAnlzFilt *);
	int    SLAPI EnumerateByIdentifiedAcc(long aco, PPID accID, AccAnlzViewEnumProc, long);
	int    SLAPI GetAcctRel(PPID accID, PPID arID, AcctRelTbl::Rec * pRec, int use_ta);
	int    SLAPI CalcTotalAccTrnovr(AccAnlzTotal *);
	int    SLAPI ViewGraph(PPViewBrowser * pBrw);

	AccAnlzFilt Filt;
	int    IsGenAcc;                // @*Init_()
	int    IsRegister;              // @*Init_()
	int    IsGenAr;                 // @*Init_()
	ObjRestrictArray ExtGenAccList; // @*Init_()
	PPCycleArray  CycleList;        // @*Init_()
	AccAnlzTotal  Total;
	PPObjAccount  AccObj;
	PPObjArticle  ArObj;
	PPObjBill   * P_BObj;
	AccTurnCore * P_ATC;
	TempAccAnlzTbl   * P_TmpAATbl;
	TempAccTrnovrTbl * P_TmpATTbl;
	struct BillEntry {
		PPID   ID;
		PPID   LocID;
		PPID   OpID;
		PPID   Object2ID; // @v7.4.2
		PPID   AgentID;
		long   Flags;
	};
	int    SLAPI FetchBill(PPID billID, BillEntry * pEntry);
};
//
// @ModuleDecl(PPViewVatBook)
//
class VatBookFilt : public PPBaseFilt {
public:
	SLAPI  VatBookFilt();
	VatBookFilt & FASTCALL operator = (const VatBookFilt & s);

	enum {
		fShowLink     = 0x0001,
		fShowFree     = 0x0002,
		fPaymPeriod   = 0x0004,   // Период указан по дате оплаты
		fShowExcluded = 0x0008,   // Показывать исключенные записи
		fIterateClb   = 0x0010,   // Итератор книги покупок должен на каждую
		                          // запись книги перебрать все номера ГТД
		fOnlyEmptyExtAr = 0x0020  // Только с пустой дополнительной статьей
	};
	char   ReserveStart[28]; // @anchor
	PPID   LocID;          // ->Location.ID
	PPID   Kind;           // PPVTB_XXX
	DateRange Period;      //
	PPID   ArticleID;      //
	PPID   Article2ID;     // Дополнительная статья
	PPID   AccSheet2ID;    // Таблица статей дополнительного объекта
	long   Flags;          //
	int    Page;           //
	long   Reserve;        // @anchor Заглушка для отмера "плоского" участка фильтра
};

struct VatBookTotal {      // @transient
	long   Count;
	double Amount;
	double Export;
	double Excise;
	double Vat0Amount;
	double Vat1Amount;
	double Vat2Amount;
	double Vat3Amount;
	double Vat1Sum;
	double Vat2Sum;
	double Vat3Sum;
};

#define VBV_CLB_ITEM_SIZE 64

struct VatBookViewItem : VATBookTbl::Rec { // @transient
	char   ManufCountry[30];
	char   CLB[28];
};

class PPViewVatBook : public PPView {
public:
	enum AutoBuildFlags {
		abfWL             = 0x0001, // Только по документам, отмеченным WL
		abfByPayment      = 0x0002, // Формирование книги строго по оплатам
		abfByPaymAtPrd    = 0x0004, // Формирование книги по оплатам документов, попадающим в период ExtPeriod.
		abfOnlyEmptyExtAr = 0x0008  // Только с пустой дополнительной статьей
	};
	struct AutoBuildFilt {
		DateRange Period;
		DateRange ShipmPeriod;
		DateRange ExtPeriod;
		PPID   AccSheetID;
		PPID   ObjectID;
		PPID   AccSheet2ID;
		PPID   Object2ID;
		PPID   LocID;
		long   Flags; // AutoBuildFlags
	};

	SLAPI  PPViewVatBook();
	SLAPI ~PPViewVatBook();
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI Print(const void *);
	virtual int SLAPI ViewTotal();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(VatBookViewItem *);
	int    SLAPI CalcTotal(VatBookTotal *);
	int    SLAPI DeleteItem(PPID);
	int    SLAPI AutoBuild();
	int    SLAPI Export();
	int    SLAPI GetNalogRuOpIdent(const VatBookViewItem & rItem, SString & rBuf);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI EditAutoBuildFilt(AutoBuildFilt *);
	int    SLAPI ProcessOp(uint, const PPIDArray *, const PPIDArray * pNegOpList,
		const AutoBuildFilt *, int byPayment, PPObjBill::PplBlock * pEbfBlk, PPID mainAmtTypeID);
	int    SLAPI _SetVATParams(VATBookTbl::Rec *, const BVATAccmArray *, double scale, int selling, int slUseCostVatAddendum);
	int    SLAPI CheckBillRec(const AutoBuildFilt *, const BillTbl::Rec *);
	int    SLAPI RemoveZeroBillLinks(int use_ta);
	int    SLAPI ConvertOpList(const VATBCfg *, PPIDArray *);
	int    SLAPI MRBB(PPID, BillTbl::Rec * pPaymRec, const TaxAmountIDs *, long mrbbf, PPObjBill::PplBlock * pEbfBlk, PPID mainAmtTypeID);
	int    SLAPI NextInnerIteration(VatBookViewItem *);
	int    SLAPI LoadClbList(PPID billID);
	PPObjVATBook VBObj;
	PPObjBill  * P_BObj;
	VatBookFilt  Filt;
	VatBookTotal Total;
	int    IsMainOrgVatFree;
	UintHashTable AbBillList; // Список идентификаторов документов, которые уже были просмотрены при
		// автоматическом построении книги. Необходим для того, чтобы избежать удаления записей, принадлежащих
		// одному документу, но сформированных за один цикл.
	//
	PPObjGoods * P_GObj;
	PPObjPerson PsnObj;
	VatBookViewItem InnerItem;
	SArray * P_ClbList;       // items char[VBV_CLB_ITEM_SIZE]
	uint   ClbListIterPos;
	LAssocArray TaxOpSymbAssoc; // Список ассоциаций {вид операции - экспортный символ} Используется при экспорте
};
//
// @ModuleDecl(PPViewOpGrouping)
//
#define OPGRPNG_TOTAL_ID  1000000L
#define OPGRPNG_INREST    -1
#define OPGRPNG_OUTREST   10000

#define CYCLESTAT_NONE      0
#define CYCLESTAT_AVERAGE   1
#define CYCLESTAT_MIN       2
#define CYCLESTAT_MAX       3
#define CYCLESTAT_TREND     4 // Коэффициент наклона линейного тренда
#define CYCLESTAT_TRENDBASE 5 // Независимое слагаемое линейного тренда
#define CYCLESTAT_TRENDREL  6 // Отношение TREND / TRENDBASE

struct OpGroupingFilt : public PPBaseFilt {
	SLAPI  OpGroupingFilt();
	OpGroupingFilt & FASTCALL operator = (const OpGroupingFilt & s);
	enum {
		eqxCycleStat = 0x0001
	};
	int    SLAPI IsEqualExcept(const OpGroupingFilt & rS, long flags) const;

	enum {
		fLabelOnly          = 0x0001,  // Только по WL-документам
		fCalcRest           = 0x0002,  // Рассчитывать входящие и исходящие остатки
		fPrnBillList        = 0x0004,  // Печать с реестром документов
		fAllCurrencies      = 0x0008,  // Все валюты
		fCalcAvgLn          = 0x0010,  // Рассчитывать среднее кол-во строк в док-тах
		fCostByPaym         = 0x0020,  //
		fSkipNUpdLotRestOps = 0x0040,  // Не включать в отчет операции, не изменяющие остатки по лотам (OPKF_NOUPDLOTREST)
		fInclAccOps         = 0x0080   // @v8.6.1 Включать в отчет бухгалтерские операции (OPG_INCLACCOPS)
	};
	char   ReserveStart[28];  // @anchor
	long   CycleStat;         // @v6.2.4
	DateRange Period;         //
	DateRange LotsPeriod;     //
	DateRange ShipmentPeriod; // Период отгрузки
	PPID   OpID;              //
	PPID   CurID;             // Валюта
	PPID   SupplID;           //
	PPID   ArID;              //
	PPID   GoodsGrpID;        //
	PPID   GoodsID;           //
	PPID   ExtGoodsTypeID;    // Тип товара по которому дополнительно показывать суммы.
		// только для группировки по документам (GoodsGrpID == 0 && GoodsID == 0)
	PPID   SupplAgentID;      //
	long   Flags;             //
	PPCycleFilt Cycl;         //
	ObjIdListFilt LocList;    // @anchor Список складов
};

struct OpGroupingViewItem {
	LDATE  Dt;
	PPID   ObjectID;
	PPID   OpID;
	char   OpName[48];    // @v6.2.4 [42]-->[48]
	// @v6.2.4 uint16 Reserve1;      // @alignment
	PPID   GoodsTaxGrpID;
	PPID   LotTaxGrpID;
	short  fVatFreeSuppl;
	short  fToggleSTax;
	short  Sign;
	uint16 Reserve2;      // @alignment
	long   Flags;         //
	long   Count;         //
	long   LnCount;       // Суммарное количество строк  turistti
	long   AvgLn;         // Среднее количество строк в документах turistti
	double Qtty;
	double PhQtty;
	double Amount;
	double Cost;
	double Price;
	double Discount;
	double Income;
	double ExtCost;       // Сумма в ценах поступления дополнительного типа товара
	double ExtPrice;      // Сумма в ценах реализации дополнительного типа товара
	double VatSum;
	double ExciseSum;
	double STaxSum;
};
//
// Descr: Структура, в которой собираются сведения товарных док-тов
//
struct BillStatFunc {
	PPID   OpID;      // Тип операции
	long   Count;     // Количество документов с этим типом операции
	long   LnCount;   // Суммарное количество товарных строк в этих документах
	long   AvgLines;  // Среднее количество строк в док-тах с таким типом операции
};

typedef TSArray <BillStatFunc> BillStatArray;

class PPViewOpGrouping : public PPView {
public:
	SLAPI  PPViewOpGrouping();
	SLAPI ~PPViewOpGrouping();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(OpGroupingViewItem *);
	void   SLAPI FormatCycle(LDATE dt, char * pBuf, size_t bufLen);
	int    SLAPI GetGdsOpTotal(OpGroupingViewItem *);
	int    SLAPI InitBillList(PPID opID);
	int    SLAPI EnumBillList(uint * pos, OpGroupingViewItem * pItem);
	int    SLAPI CalcStat(BillStatArray * pList);
private:
	struct OpGroupingStatEntry {
		PPID   OpID;
		int    Sign;
		StatBase S;
	};
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int    SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int    SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int    SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);
	virtual int    SLAPI Print(const void * pHdr);
	int    SLAPI ViewGraph(const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI CreateStatList(LAssocArray * pOpList, TSArray <OpGroupingViewItem> * pItemList, TSCollection <OpGroupingStatEntry> * pStatList);
	int    SLAPI AddStatItem(PPID opID, int sign, double val, uint si, TSCollection <OpGroupingStatEntry> * pList);
	double SLAPI GetStatItem(int stat, PPID opID, int sign, uint si, TSCollection <OpGroupingStatEntry> * pList);
	int    SLAPI RecalcGdsOpTotal(TempOpGrpngTbl::Rec * pRec);
	int    SLAPI GetRecSign(const TempOpGrpngTbl::Rec *, int * pSign) const;

	OpGroupingFilt Filt;
	PPCycleArray CycleList;
	TempOpGrpngTbl * P_TempTbl;
	TempOpGrpngTbl * P_TempStatTbl;
	TempOpGrpngTbl::Rec  GdsOpTotal;
	TempOpGrpngTbl::Rec  LastOutRest;
	PPViewTrfrAnlz * P_ViewTrfrAnlz;
	PPViewBill     * P_ViewBill;
	PPLogger Logger;
};
//
// @ModuleDecl(PPViewGoodsMov)
//
class GoodsMovFilt : public PPBaseFilt {
public:
	enum {
		fCostWoVat      = 0x0001,
		fLabelOnly      = 0x0002,
		fUseOldAlg      = 0x0004,
		fInited         = 0x0008 // for inthernal use
	};
	enum {
		prkBasePrice = 0,
		prkCost      = 1,
		prkPrice     = 2
	};

	SLAPI  GoodsMovFilt();
	GoodsMovFilt & FASTCALL operator = (const GoodsMovFilt & s);

	char   ReserveStart[14];  // @anchor
	int16  PriceKind; // prk...
	PPID   OpID;
	DateRange Period;
	PPID   SupplID;
	PPID   SupplAgentID;
	PPID   GoodsGrpID;
	PPID   BrandID;
	long   Flags;
	ObjIdListFilt LocList;    //
};

struct GoodsMovViewItem {
	PPID   GoodsID;
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsMov instance
	double PhPerU;
	double UnitsPerPack;

	double InRest_Qtty;
	double InRest_Cost;
	double InRest_Price;

	double Rcpt_Qtty;
	double Rcpt_Cost;
	double Rcpt_Price;

	double _Rcpt_Qtty;
	double _Rcpt_Cost;
	double _Rcpt_Price;

	double Rlz_Qtty;
	double Rlz_Cost;
	double Rlz_Price;

	double SRlz_Qtty;
	double SRlz_Cost;
	double SRlz_Price;

	double Expnd_Qtty;
	double Expnd_Cost;
	double Expnd_Price;

	double TRcpt_Qtty;
	double TRcpt_Cost;
	double TRcpt_Price;

	double TExpnd_Qtty;
	double TExpnd_Cost;
	double TExpnd_Price;

	double OutRest_Qtty;
	double OutRest_Cost;
	double OutRest_Price;
};

struct GoodsMovTotal {
	SLAPI  GoodsMovTotal();
	void   SLAPI Init();
	int    SLAPI IsEmpty() const;
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	double InRestQtty;
	double InRestPhQtty;
	double InRestCost;
	double InRestPrice;
	double OutRestQtty;
	double OutRestPhQtty;
	double OutRestCost;
	double OutRestPrice;
};

class PPViewGoodsMov : public PPView {
public:
	enum IterOrder {
		OrdByDefault,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};
	SLAPI  PPViewGoodsMov();
	SLAPI ~PPViewGoodsMov();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsMovViewItem *);
	int    SLAPI GetIterationCount(long * pNumIterations, long * pLastCount);
	int    SLAPI EditGoods(PPID goodsID);
	// Realy private. Used from PPALDD_GoodsMov::NextItaration()
	int    PrintWoPacks;
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx); // @v6.4.10
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);

	int    SLAPI InitGroupNamesList();
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();
	double SLAPI GetUnitsPerPack(PPID goodsID);

	GoodsMovFilt Filt;
	PPObjBill         * P_BObj;
	TempGoodsMovTbl   * P_TempTbl;
	GoodsMovTotal     Total;

	long    IterCount;
	long    NumIters;
	int     IterIdx;
	GoodsGroupIterator * P_GGIter;
	// @v9.6.6 char    IterGrpName[256];
	SString IterGrpName; // @v9.6.6
};
//
// @ModuleDecl(PPViewGoodsMov2)
//
struct GoodsMov2ViewItem : TempGoodsMov2Tbl::Rec {
	double UnitsPerPack;
};

class PPViewGoodsMov2 : public PPView {
public:
	struct BrwHdr {
		PPID OpID;
		PPID GoodsID;
	};
	enum IterOrder {
		OrdByDefault,
		OrdByGoodsName,
		OrdByGrp_GoodsName
	};
	SLAPI  PPViewGoodsMov2();
	SLAPI ~PPViewGoodsMov2();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsMov2ViewItem *);
	int    SLAPI GetIterationCount(long * pNumIterations, long * pLastCount);
	int    SLAPI EditGoods(PPID goodsID);
	int    SLAPI GetTabTitle(long opID, SString & rBuf);
	// Realy private. Used from PPALDD_GoodsMov::NextItaration()
	int    PrintWoPacks;
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx); // @v6.4.10
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);

	double SLAPI GetUnitsPerPack(PPID goodsID);
	int    SLAPI GetEditIds(const void * pRow, PPViewGoodsMov2::BrwHdr * pHdr, long col);

	GoodsMovFilt Filt;
	PPObjBill         * P_BObj;
	TempGoodsMov2Tbl  * P_TempTbl;
	GoodsMovTotal     Total;

	SString InRestText;
	SString OutRestText;
};
//
// @ModuleDecl(PPViewCSess)
//
class CSessFilt : public PPBaseFilt { // @persistent
public:
	enum {
		fExtBill       = 0x0001,
		fOnlySuperSess = 0x0002
	};
	SLAPI  CSessFilt();
	CSessFilt & FASTCALL operator = (const CSessFilt &);

	char   ReserveStart[28]; // @anchor
	long   InitOrder;        // @v6.6.8 PPViewCSess::ordByXXX Порядок сортировки
	DateRange Period;
	long   CashNumber;
	PPID   SuperSessID;
	long   Flags;
	ObjIdListFilt NodeList_;  // Список кассовых узлов, к котороым привязаны сессии
};

struct CSessViewItem : public CSessionTbl::Rec {
	long   ChkCount;
	double WORetAmount;
	double WORetBnkAmount;
	double BnkDiscount;
};
//
// Descr: Структура параметров создания драфт-документов по кассовым сессиям на основе правил.
//   Используется как при ручном вызове функции, так и для определения задания Job-сервера.
//
class CSessCrDraftParam { // @persistent(JobServer)
public:
	SLAPI  CSessCrDraftParam();
	int    SLAPI Read(SBuffer & rBuf, long);
	int    SLAPI Write(SBuffer & rBuf, long);

	enum {
		fAllSessions   = 0x0001,
		fSuperSessOnly = 0x0002
	};
	uint32 Ver;
	uint8  Reserve[32];
	DateRange Period;
	int32  RuleGrpID;      //
	int32  RuleID;         //
	int32  Flags;          //
	ObjIdListFilt NodeList;
};

class PPCSessExporter {
public:
	SLAPI  PPCSessExporter();
	SLAPI ~PPCSessExporter();
	int    SLAPI Init(const PPImpExpParam *, const PPImpExpParam *, const PPImpExpParam *);
	int    SLAPI PutSess(PPID csessID, DateRange * pPeriod);
	int    SLAPI PutSess(const PPIDArray * pSessArr, DateRange * pPeriod); // @vmiller
private:
	int SLAPI FillCSess(PPID csessID, Sdr_CSess * pCSessRec);
	int SLAPI FillCheck(PPID checkID, Sdr_CSess * pCSessRec, Sdr_CChecks * pCCheckRec);

	PPImpExpParam  CSessParam;
	PPImpExpParam  CCheckParam;
	PPImpExpParam  CCLineParam;
	CCheckCore     CCTbl;
	SCardCore      SCardTbl;
	PPObjGoods     GObj;
	PPObjCSession  CSObj;
	PPImpExp * P_IECSess;
	PPImpExp * P_IECCheck;
	PPImpExp * P_IECCLine;
};

class PPViewCSess : public PPView {
public:
	//
	// Descr: Порядок сортировки
	//
	enum {
		ordByDefault = 0,
		ordByID,
		ordByDtm_CashNode,
		ordByDtm_CashNumber,
		ordByDtm_SessNumber,
		ordByCashNode_Dtm,
		ordByCashNumber_Dtm,
		ordBySessNumber,
		ordByAmount
	};
	static int SLAPI EditCreateDraftParam(CSessCrDraftParam * pParam);
	// @v9.7.10 static int SLAPI CreateDraft(const CSessCrDraftParam * pParam);

	SLAPI  PPViewCSess();
	SLAPI ~PPViewCSess();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI InitIteration(long ord);
	int    FASTCALL NextIteration(CSessViewItem *);
	int    SLAPI CalcTotal(CSessTotal *);
	int    SLAPI CloseSession();
	int    SLAPI CompleteSession(PPID);
	int    SLAPI PosPrint(PPID curID);
	int    SLAPI PrintSession(PPID sessID);
	int    SLAPI ImportSessions();
	int    SLAPI AddItem();
	int    SLAPI EditItem(PPID);
	int    SLAPI DeleteItem(PPID);
	int    SLAPI DetachSessFromSuperSess(PPID);
	int    SLAPI RecalcSession(PPID);
	int    SLAPI ViewExcesses(PPID);
	int    SLAPI ViewChecks(PPID);
	int    SLAPI ViewGoodsTaxAnlz(PPID);
	int    SLAPI ViewGoodsOpAnlz(PPID);
	int    SLAPI Transmit(PPID, int transmitKind);
	int    SLAPI CreateDrafts(PPID ruleGrpID, PPID ruleID, PPID sessID); // AHTOXA
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI IsNotDefaultOrder(int ord) const
	{
		return oneof8(ord, ordByID, ordByDtm_CashNode, ordByDtm_CashNumber, ordByDtm_SessNumber,
			ordByCashNode_Dtm, ordByCashNumber_Dtm, ordBySessNumber, ordByAmount);
	}
	int    SLAPI CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	int    SLAPI InitCSessIteration();
	int    SLAPI NextCSessIteration(CSessionTbl::Rec *);
	int    SLAPI Add(BExtInsert *, CSessionTbl::Rec *);
	int    SLAPI CalcCheckAmounts(TempCSessChecksTbl::Rec *);
	//
	// Если pFlags == 0, вызывается диалог DLG_SELCSESS (Товарный отчет по операции),
	// иначе DLG_SELCSESSEXC (Излишки по кассовым сессиям)
	//
	int    SLAPI SelectOneOrAll(uint * pResult, long * pFlags);
	int    SLAPI GetBillList(PPID sessID, ObjIdListFilt &);
	int    SLAPI GetSessList(PPIDArray * pList);
	int    SLAPI CreateDraft(PPID ruleID, PPID sessID, const SString &, const SString &, int use_ta);
	int    SLAPI ViewAllChecks();

	BExtQuery * P_CSessIterQuery;
	CSessFilt Filt;
	ObjIdListFilt NodeList;
	int    CurrentViewOrder;
	TempCSessChecksTbl * P_TempTbl;
	TempOrderTbl * P_TempOrd; // @v6.6.8
	SArray * P_SessAmtAry;
	PPObjCSession CsObj;
	CCheckCore CC;
};
//
// PPViewCSessExc
//
class CSessExcFilt : public PPBaseFilt {
public:
	enum {
		fNoZeroAltGoods = 0x0001 // Если этот флаг установлен то выбираются все       //
			// строки, содержащие альтернативный товар, при этом игнорируется наличия //
			// излишков по этим строкам.                                              //
	};
	SLAPI  CSessExcFilt();

	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   CashNodeID;
	PPID   GoodsGrpID;
	PPID   GoodsID;
	long   Flags;
	PPIDArray SessIDList;    // @anchor
};

typedef TempCSessExcTbl::Rec CSessExcViewItem;

class PPViewCSessExc : public PPView {
public:
	SLAPI  PPViewCSessExc();
	SLAPI ~PPViewCSessExc();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(CSessExcViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Print(const void *);
	virtual int SLAPI ViewTotal();
	int    SLAPI MakeTempTable(PPID sessID);
	int    SLAPI _MakeTempTable(int clearBefore);
	int    SLAPI AddItemToTempTable(const PPID, CGoodsLineTbl::Rec *, LAssocArray * pRgAssoc);
	int    SLAPI GatherGoodsLines(int sign, PPID goodsID, CSessDfctList *);
		// @<<PPViewCSessExc::SetAltGoods
	PPID   SLAPI GetCommonLoc();
	int    SLAPI GetAltGoodsPrice(PPID goodsID, double * pPrice);
	int    SLAPI SetRecValues(TempCSessExcTbl::Rec &, const CGoodsLineTbl::Rec *, int add);
	int    SLAPI SetAltGoods(int sign, PPID goodsID);
	int    SLAPI ConvertDeficitToBasket();

	CGoodsLine Tbl;
	PPObjGoods GObj;
	PPObjCSession CsObj;
	TempCSessExcTbl * P_TempTbl;
	PPID   CommonLocID; // Склад, соответствующий фильтру. Если нельзя однозначно
	// определить склад по условиям фильтра, то CommonLocID = 0.
	// В Init() устанавливается -1. При необходимости определения следует вызвать
	// GetCommonLoc().
	CSessExcFilt Filt;
};
//
// @ModuleDecl(PPViewCCheck)
//   Анализ кассовых чеков
//
class CCheckFilt : public PPBaseFilt { // @persistent
public:
	static int FASTCALL HasGoodsGrouping(int grp)
	{
		return BIN(oneof7(grp, gGoods, gGoodsDate, gAgentsNGoods, gCashiersNGoods, gGoodsSCSer, gAmountNGoods, gAgentGoodsSCSer));
	}

	SLAPI  CCheckFilt();
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
	CCheckFilt & FASTCALL operator = (const CCheckFilt & src);
	//
	// Descr: Устанавливает список кассовых узлов (NodeList) в соотвествии
	//   со списком идентификаторов складов pLocList. Для каждого идентификатора
	//   склада из списка извлекается список кассовых узлов, принадлежащих ему
	//   и вставляется в список NodeList.
	//
	int    SLAPI SetLocList(const PPIDArray * pLocList);
	int    SLAPI HasGoodsGrouping() const
	{
		return CCheckFilt::HasGoodsGrouping(Grp);
	}
	int    SLAPI HasExtFiltering() const
	{
		return BIN(AgentID || TableCode || GuestCount > 0 || (Flags & fStartOrderPeriod && !Period.IsZero()) || (DlvrAddrID || Flags & fZeroDlvrAddr));
	}

	enum Grouping {
		gNone = 0,       //
		gTime,           //
		gDate,           //
		gDayOfWeek,      // Группировать по дням недели.
		gDowNTime,       // Группировать по дням недели и часам.
		gCash,           //
		gCard,           //
		gDscntPct,       // Группировать по проценту скидки
		gAmount,         // Группировать по диапазону сумм. Дробность группировки определяется полем AmountQuant.
		gQtty,           // Группировать по диапазону количества. Дробность группировки определяется полем AmountQuant.
		gGoods,          // Группировать по товарам.
		gGoodsDate,      // Группировать по товару/дате
		gCashiers,       // Группировать по кассирам.
		gAgents,         // Группировать по агентам.
		gLinesCount,     // Группировать по количеству строк в чеке
		gDiv,            // Группировать по номеру отдела (по строкам)
		gGuestCount,     // Группировать по количеству гостей
		gTableNo,        // Группировать по номеру стола
		gAgentsNHour,    // Группировать по агентам и часам
		gCashNode,       // Группировать по кассовым узлам
		gAgentsNGoods,   // Группировать по агентам и товарам
		gCashiersNGoods, // Группировать по кассирам и товарам
		gDlvrAddr,       // Группировать по адресу доставки
		gGoodsSCSer,     // Группировка по товару и серии карт
		gAmountNGoods,   // @v8.4.8
		gAgentGoodsSCSer // @v9.6.6 Группировать по агентам, товарам и сериям карт
	};
	enum {
		fZeroSess         = 0x00000001, // Чеки по неопределенным кассовым сессиям
		fActiveSess       = 0x00000002, // Чеки активной синхронной кассовой сессии
			// Допускается добавление и удаление чеков через кассовую панель.
		fCheckLines       = 0x00000004, // Просматривать строки чеков (для группировки по товарам)
		fImmOpenPanel     = 0x00000008, // Если этот флаг установлен и группировки выключены и
			// SessIDList содержит одну сессию и Flags & CCheckFilt::fActiveSess, то
			// сразу открывается панель ввода чеков
		fShowSuspended    = 0x00000010, // Показывать отложенные
		fSuspendedOnly    = 0x00000020, // Только отложенные
		fRetOnly          = 0x00000040, // Показывать только возвраты
		fJunkOnly         = 0x00000080, // Только отложенные чеки, которые были загружены в панель чеков.
			// Если панель аварийно завершила работу, то этот чек зависнет.
		fFillCashNodeID   = 0x00000100, // заполнять поле CashNodeID
		fNotPrintedOnly   = 0x00000200, // Показывать только ненапечатанные чеки
		fCashOnly         = 0x00000400, // Только чеки, проведенные за наличные
		fBankingOnly      = 0x00000800, // Только чеки, проведенные по безналичной оплате
		fDontCount        = 0x00001000, // Функция InitIteration не должна рассчитывать общее количество итераций (ради экономии времени)
		fGoodsCorr        = 0x00002000, // Просмотр корреляции товаров
		fFiltByCheck      = 0x00004000, // Фильтрация по AmtR, QttyR, PcntR на весь чек, а не по строкам
		fInitLinesCount   = 0x00008000, // Инициализировать в CCheckViewItem количество строк в чеке
		fGiftOnly         = 0x00010000, // CCHKF_HASGIFT Только по чекам, имеющим признак CCHKF_HASGIFT
		fOrderOnly        = 0x00020000, // CCHKF_ORDER   Только чеки заказов
		fCTableStatus     = 0x00040000, // Специальный флаг, необходимый для извлечения чеков, которые определяют статус занятости столов
		fCalcSkuStat      = 0x00080000, // Подсчитывать статистику по строкам чеков
		fWithoutSkipTag   = 0x00100000, // Пропускать чеки, имеющие признак CCHKF_SKIP
		fDlvrOnly         = 0x00200000, // @v7.0.8 Только чеки с доставкой
		fDlvrOutstandOnly = 0x00400000, // @v7.1.0 Только отложенные неисполенные
		fStartOrderPeriod = 0x00800000, // @v7.3.0 Поле Period трактуется как период времени начала обслуживания по чеку
		fShowSrvcDuration = 0x01000000, // @v7.3.0 Отображать продолжительность обслуживания по чеку
		fZeroDlvrAddr     = 0x02000000, // @v7.5.3 Только с пустым адресом доставки
		fInner            = 0x04000000, // @v7.8.9 @internal
		fLostJunkAsSusp   = 0x08000000, // @v8.2.12 Специальный флаг, предписывающий отбирать чеки, имеющие признак CCHKF_JUNK,
			// получившие такой признак аварийно завершенной сессией. UUID'ы незавершенных сессий извлекаются из реестра по ключу
			// HKEY_CURRENT_USER\\Software\\Papyrus\\Sessions
			// UUID сессии, присвоившей чеки признак CCHKF_JUNK извлекается из зарезервированного т'га чека PPTAG_CCHECK_JS_UUID
		fPrintDetail      = 0x10000000, // @v8.3.7 По умолчанию печатать детализированный отчет по структуре CCheckViewDetail
		fNotSpFinished    = 0x20000000  // @v9.7.5 На чеке не установлен флаг CCHKF_SPFINISHED
	};
	enum {
		ctNone = 0,
		ctDate = 1
	};
	enum {
		ctvChecksSum = 1,
		ctvChecksCount,
		ctvSKUCount
	};
	uint8  ReserveStart[12]; // @#0 !Использовать начиная со старших адресов
	S_GUID LostJunkUUID;     // @v8.7.7 GUID по которому следует распознавать потерянные чеки (fLostJunkAsSusp)
	PPID   GcoExcludeGrpID;  // @v8.4.9 Группа товаров, исключаемая из рассмотрения для попарных включений товаров
	PPID   DlvrAddrID;       // @v7.5.3 Адрес доставки
	DateRange Period;
	TimeRange TimePeriod;    // Временной промежуток, за который выбирать чеки.
	uint16 LowLinesCount;    // Нижнаяя граница количества строк в чеке
	uint16 UppLinesCount;    // Верхняя граница количества строк в чеке
	int8   HourBefore;       // Use for function PPViewCCheck::ViewDetail if CCheckFilt::Grp = gTime
	uint8  WeekDays;         // Маска дней недели, по которым выбирать чеки. Если WeekDays == 0, то все.
		// Пнд (WeekDays & (1 << 1)), Вт (WeekDays & (1 << 2)), ..., Вскр (WeekDays & (1 << 0))
	int16  GuestCount;       // Количество гостей за столом
	int16  Div;              // Номер отдела (по строкам)
	uint16 Reserve;          // @alignment
	long   CashNumber;       //
	long   Flags;            //
	PPID   GoodsGrpID;       //
	PPID   GoodsID;          // ->Goods2.ID
	PPID   SCardSerID;       //
	PPID   SCardID;          // ->SCard.ID
	PPID   CashierID;        //
	PPID   AgentID;          // ->Article.ID Агент
	long   TableCode;        // Номер стола (для ресторанов)
	IntRange  CodeR;         // Диапазон номеров чеков
	RealRange AmtR;          //
	RealRange QttyR;         //
	RealRange PcntR;         // Диапазон процента скидки
	double    AmountQuant;   // Дробность группировки чеков по сумме или по количеству
	enum {
		ordIterLines = 0x8000000, // Специальный флаг, предписывающий функциям
			// PPViewCCheck::InitIteration, PPViewCCheck::NextIteration перебирать строки чеков
		ordByDef   = 0,
		ordByCount = 1,
		ordByName  = 2,
		ordByQtty  = 3,
		ordByAmt   = 4
	};
	long   SortOrder;        // Сортировка
	Grouping Grp;            //
	long   CtKind;           // CCheckFilt::ctXXX  Вид кросстабулированного отчета
	long   GcoMinCount;      // Параметры расчета попарных включений товаров в один чек
	SubstGrpGoods Sgg;       // Подстановка товара для попарных товаров
	PPIDArray SessIDList;    // @anchor
	ObjIdListFilt NodeList;  // Список узлов.
	ObjIdListFilt CorrGoodsList; // Список кореллирующих товаров
	ObjIdListFilt CtValList;     // CCheckFilt::ctvXXX Показатель, вычисляемый в кросстаб-отчете
	ObjIdListFilt ScsList;       // @v7.9.11 Список серий карт, по которым следует извлекать выборку чеков
};

struct CCheckTotal {
	long   Count;
	double Amount;
	double Discount;
	double AmtCash;  // @v6.5.12 Сумма, оплаченная наличными
	double AmtBank;  // @v6.5.12 Сумма, оплаченная банковскими картами
	double AmtSCard; // @v6.5.12 Сумма, оплаченная по корпоративным кредитным картам
	double AmtReturn; // @7.x.x  Сумма возвратов
	double Qtty;
	//
	// Статистики по суммам чеков
	//
	double MinCheckSum;
	double AvrgCheckSum;
	double MaxCheckSum;
	//
	long   GuestCount; // @v8.3.11
};

struct CCheckViewItem : public CCheckTbl::Rec { // @transient // @flat
	long   TableCode;      // Номер стола
	int16  Div;            // Номер отдела (по строкам)
	int16  GuestCount;     // Количество гостей за столом
	PPID   AgentID;        // ->Article.ID ИД агента (официаната)
	PPID   AddrID;         // @7.5.3 ->Location.ID ИЛ адреса доставки для чека с доставкой
	double BnkAmt;         // @v8.3.0 Сумма, уплаченная банковской картой
	double CrdCardAmt;     // @v8.3.0 Сумма, уплаченная корпоративной кредитной картой
	long   G_GoodsID;      //
	long   G_Goods2ID;     //
	long   G_Count;        // Коичество чеков в группировке
	double G_Amount;       // Итоговая сумма чеков в группировке
	double G_Price;        // @v8.3.7 Цена по строке (строкам) чеков (с учетом скидки)
	double G_Discount;     // Итоговая скидка по чека в группировке
	double G_PctPart;      // Процентаня доля группировке в общей выборке по сумме чеков
	double G_Qtty;         // Суммарное количество торговых единиц товаров в группировке
	long   G_SkuCount;     // Суммарное количество (различных) товаров в группировке
	double G_LinesCount;   // Суммарное количество чековых строк в группировке
	long   CashNodeID;     //
	long   LinesCount;     // Количество строк в чеке (инициализируется только если
		// в фильтре установлен флаг fInitLinesCount
	long   LinkCheckID;    // @v6.7.11 Связанный чек (обычно, чек заказа)
	long   RByCheck;       // @v8.3.7  Номер строки по чеку
	long   LineFlags;      // @v8.3.7  Флаги строки чека
	long   LineQueue;      // @v8.3.7  Очередь подачи (для ресторанов)
	STimeChunk OrderTime;  // @v6.8.1 Отрезок времени, на который заказан стол
	LDATETIME CreationDtm; // @v7.6.1 Время создания чека (начало обслуживания)
	char   G_Text[128];    // Текст наименования группы. При итерации по строкам - серийный номер
};

class PPViewCCheck : public PPView {
public:
	static int SLAPI EditCCheckSystemInfo(CCheckPacket & rPack);

	struct BrwHdr {
		PPID  ID;
		LDATE Dt;
		LTIME Tm;
		PPID  GoodsID;
		PPID  Goods2ID;
	};
	SLAPI  PPViewCCheck();
	SLAPI  PPViewCCheck(CCheckCore & rOuterCc);
	SLAPI ~PPViewCCheck();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(CCheckViewItem *);
	int    SLAPI CalcTotal(CCheckTotal *);
	int    SLAPI AddItem();
	int    SLAPI EditItemInfo(PPID);
	int    SLAPI RemoveAll();
	int    SLAPI GetPacket(PPID id, CCheckPacket * pPack); // @<<PPViewCSess::CreateDraft
	int    SLAPI ViewGraph();
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;

	const  BVATAccmArray * GetInOutVATList() const;
	CCheckCore * SLAPI GetCc();

	static int SLAPI CreateDraftBySuspCheck(PPViewCCheck * pV, PPID chkID);
private:
	int    SLAPI Helper_Construct();
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int SLAPI ViewTotal();
	virtual int SLAPI Print(const void *);
	virtual int SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx); // @v6.6.8
	SString &   SLAPI GetCtColumnTitle(int ct, SString & rBuf);
	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI DoProcessLines() const;
	void   SLAPI PreprocessCheckRec(const CCheckTbl::Rec * pRec, CCheckTbl::Rec & rResultRec, CCheckExtTbl::Rec & rExtRec);
	int    SLAPI ProcessCheckRec(const CCheckTbl::Rec * pRec, BExtInsert * pBei);
	int    FASTCALL CheckForFilt(const CCheckTbl::Rec * pRec, const CCheckExtTbl::Rec * pExtRec);
	int    FASTCALL CheckLineForFilt(const CCheckLineTbl::Rec & rLnRec);
	int    SLAPI PosPrint(PPID checkID, long);
	int    SLAPI CalcVATData();
	int    SLAPI ChangeFilt(PPViewBrowser * pBrw);
	int    SLAPI CreateGoodsCorrTbl();
	int    SLAPI ViewGoodsCorr();
	int    SLAPI EditGoods(const void * pHdr, int goodsNo);
	int    SLAPI AddGoodsToBasket(PPID checkID);
	int    SLAPI GetBrwHdr(const void * pRow, BrwHdr * pHdr) const;
	int    SLAPI ToggleDlvrTag(PPID checkID);
	int    SLAPI GetReportId() const;

	CCheckCore  * P_CC; // @v8.6.12 CC--> *P_CC
	PPObjCSession CsObj;
	PPObjGoods  GdsObj;
	PPObjPerson PsnObj;
	PPObjSCard ScObj;
	TempCCheckQttyTbl * P_TmpTbl;
	TempCCheckGrpTbl  * P_TmpGrpTbl;
	TempCCheckGdsCorrTbl * P_TmpGdsCorrTbl;
	CCheckFilt  Filt;
	enum {
		stHasExt        = 0x0001,
		stUseGoodsList  = 0x0002,
		stIterLines     = 0x0004, // @v8.3.7
		stOuterCc       = 0x0008, // @v8.6.12
		stSkipUnprinted = 0x0010  // @v9.7.11 Если в фильтре заданы конкретные кассовые узлы
			// и все они имеют установленный флаг CASHF_SKIPUNPRINTEDCHECKS, то чеки, не имеющие
			// флага CCHKF_PRINTF считаются неучитываемым (как будто имеют флаг CCHKF_SKIP).
	};
	long   State;              // @*Init_
	CCheckPacket CcPack;       //
	uint   CurLine;
	ObjIdListFilt CcIdList;    // @*Init_ Список идентификаторов чеков, ограничивающих выборку.
		// Список необходим для оптимизации выборки по неиндексированным полям (в частноси, из расширения чеков)
	ObjIdListFilt NodeIdList;  // @*Init_ Список кассовых узлов, по которым строится отчет. Может отличаться от Filt.NodeList за счет группирующих узлов
	ObjIdListFilt SessIdList;  // @*Init_
	ObjIdListFilt SCardList;   // @*Init_
	UintHashTable GoodsList;   // @*Init_ Список товаров, по которым следует фильтровать строки чеков
	LAssocArray SessCnList;    // Список ассоциация Кассовая сессия - Кассовый узел.
		// Используется для быстрой идентификации принадлежности чека кассовому узлу.
	BVATAccmArray * P_InOutVATList; //
	GoodsSubstList Gsl;        //
};
//
// @ModuleDecl(PPViewObjSync)
//
struct ObjSyncFilt : public PPBaseFilt {
	SLAPI  ObjSyncFilt();
	virtual int Init(int fullyDestroy, long extraData);
	virtual int Write(SBuffer &, long) const;
	virtual int Read(SBuffer &, long);
	virtual int Copy(const PPBaseFilt *, int);
	virtual int IsEqual(const PPBaseFilt *, int) const;

	char   ReserveStart[32]; // @anchor
	PPID   ObjType;
	PPID   DbDivID;
	long   Flags;
	PPIDArray   ObjIDList;   // @anchor
	LAssocArray CommIDList;
};

typedef ObjSyncTbl::Rec ObjSyncViewItem;

class PPViewObjSync : public PPView {
public:
	SLAPI  PPViewObjSync();
	SLAPI ~PPViewObjSync();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ObjSyncViewItem *);
	int    SLAPI AddItem();
	int    SLAPI EditItem(const ObjSyncIdent *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI EditRecord(ObjSyncTbl::Rec *);

	ObjSyncFilt Filt;
	ObjSyncCore * P_Tbl; // @notowned
	ObjSyncTbl  * P_TmpTbl;
};
//
// @ModuleDecl(PPViewObjSyncCmp)
//
struct ObjSyncCmpFilt : public PPBaseFilt {
	SLAPI  ObjSyncCmpFilt();

	enum {
		fErrOnly    = 0x0001,
		fInitialize = 0x0002  // Если этот флаг установлен, то забираются данные из файлов,
			// в противном случае просто зименяется сортировка и фильтрация этих данных
	};
	enum {
		ordByError,
		ordByCommID,
		ordBySrcID,
		ordBySrcName,
		ordByDestID,
		ordByDestName
	};
	char   ReserveStart[32]; // @anchor
	PPID   ObjType;
	long   Flags;
	long   Order;
	int    ErrCode;
	RealRange Score;
	long   Reserve;          // @anchor
};

struct ObjSyncCmpTotal {
	long   Count;    // Общее количество элементов
	long   NeCount;  // Количество безошибочных элементов
	long   N1Count;  // Количество ошибок #1
	long   N2Count;  // Количество ошибок #2
	long   N3Count;  // Количество ошибок #3
	long   N4Count;  // Количество ошибок #4
};

typedef TempSyncCmpTbl::Rec ObjSyncCmpViewItem;

class PPViewObjSyncCmp : public PPView {
public:
	SLAPI  PPViewObjSyncCmp();
	SLAPI ~PPViewObjSyncCmp();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pFilt);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ObjSyncCmpViewItem *);
	int    SLAPI CalcTotal(ObjSyncCmpTotal *);
	int    SLAPI RemoveAllSync();
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int SLAPI ViewTotal();

	ObjSyncCmpFilt Filt;
	TempSyncCmpTbl * P_TmpTbl;
	PPObjectTransmit * P_Ot;
};
//
// @ModuleDecl(PPViewObjSyncQueue)
//
struct ObjSyncQueueFilt : public PPBaseFilt {
	SLAPI  ObjSyncQueueFilt();

	char   ReserveStart[32]; // @anchor
	long   Flags;
	long   Reserve;          // @anchor
};

typedef ObjSyncQueueTbl::Rec ObjSyncQueueViewItem;

class PPViewObjSyncQueue : public PPView {
public:
	SLAPI  PPViewObjSyncQueue();
	SLAPI ~PPViewObjSyncQueue();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ObjSyncQueueViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);

	ObjSyncQueueFilt Filt;
	ObjSyncQueueCore Tbl;
};
//
// @ModuleDecl(PPViewTrfrAnlz)
//   Анализ товарных операций
//
class TrfrAnlzFilt : public PPBaseFilt {
public:
	int    SLAPI HasCntragentGrouping() const
	{
		return oneof6(Grp, gCntragent, gCntragentDate, gGoodsCntragent, gGoodsCntragentDate, gDateCntragentAgentGoods, gBillCntragent);
	}
	int    SLAPI HasGoodsGrouping() const
	{
		return oneof6(Grp, gGoods, gGoodsCntragent, gGoodsCntragentDate, gGoodsBill, gDateCntragentAgentGoods, gGoodsDate);
	}
	int    SLAPI HasDateGrouping() const
	{
		return oneof4(Grp, gCntragentDate, gGoodsCntragentDate, gDateCntragentAgentGoods, gGoodsDate);
	}
	int    SLAPI HasBillGrouping() const
	{
		return oneof2(Grp, gGoodsBill, gBillCntragent);
	}

	enum Grouping {
		gNone = 0,
		gGoods,
		gCntragent,
		gCntragentDate,
		gGoodsCntragent,
		gGoodsCntragentDate,
		gGoodsBill,
		gDateCntragentAgentGoods,
		gGoodsDate,
		gBillCntragent
	};
	enum {
		fLabelOnly          = 0x00000001,   // Только помеченные операции
		fGByDate            = 0x00000002,   // Группировка по дате (только если выбран товар - GoodsID)
		fGetRest            = 0x00000004,   // Рассчитывать товарные остатки
		fSubstPersonRAddr   = 0x00000008,   // При подстановке персоналии использовать фактический адрес
		fSubstDlvrAddr      = 0x00000010,   // При подстановке персоналии использовать адрес доставки
		fDiffByDlvrAddr     = 0x00000020,   // При группировке по контрагенту заменять контрагента на конкатенацию (контрагент+адрес доставки)
		fDontInitSubstNames = 0x00000040,   // Не инициализировать имена подставляемых объектов
			// Эта опция экономит время подготовки данных если нет необходимости сортировать записи
			// или выводить отчет на экран.
		fInitLocCount       = 0x00000080,   // Рассчитывать количество адресов доставки для каждого
			// элемента группировки. Внутренний флаг (инициализируется программно)
		fCalcRest           = 0x00000100,   // Для группировки gGoods, gGoodsBill, gGoodsDate рассчитывать остатки
		fShowAllArticles    = 0x00000200,   // Показывать отсутствующие позиции контрагентов
		fShowAllAgents      = 0x00000400,   // Показывать отсутствующие позиции агентов
		fShowAllGoods       = 0x00000800,   // Показывать отсутствующие позиции товаров
		fByZeroAgent        = 0x00001000,   // @v6.0.5  Фильтрация по нулевому агенту по документу
		fCalcVat            = 0x00002000,   // @v6.4.2  Рассчитывать суммы НДС
		fCWoVat             = 0x00008000,   // @v6.6.1  Показывать цены без НДС
		fByZeroDlvrAddr     = 0x00010000,   // @v7.1.5  Фильтрация по пустому адресу доставки
		fForceInitDlvrAddr  = 0x00020000,   // @v8.3.0  Инициализировать адрес доставки без группировки
		fShowGoodsCode      = 0x00040000,   // @v8.4.11 Показывать код (single) товара
		fShowSerial         = 0x00080000,   // @v8.4.11 Показывать серийный номер лота
		fCalcAvgRest        = 0x00100000,   // @v9.1.3 Рассчитывать среднедневные остатки (предполагает наличие флага fCalcRest)
		fCmpWrOff           = 0x00200000,   // @v9.4.10 Если отчет строится по драфт-документам, то выводить результаты
			// сравнения с документами списания.
		fCmpWrOff_DiffOnly  = 0x00400000    // @v9.5.8 Если отчет строится со сравнением драфт-документов и документов
			// списания, то отображать только различающиеся позиции.
	};
	enum {
		ctNone       = 0,  // Без кросстаба
		ctDate       = 1,  // Кросстаб по дате
		ctCntragent  = 2,  // Кросстаб по контрагенту
		ctLocation   = 3   // Кросстаб по складу
	};
	//
	// Виды показателей, используемых в кросстаб-отчете
	//
	enum {
		ctvCost = 1,
		ctvNetPrice,
		ctvIncome,
		ctvPctIncome,
		ctvLocCount,
		ctvPctMargin,
		ctvQtty
	};
	//
	// Descr: Варианты расчета дополнительных показателей отчета
	//
	enum {
		extvNone                = 0,
		extvLinkOrderDiscount   = 1, // Величина скидки в связанном со строкой продажи заказе
		extvLinkOrderPriceAbove = 2, // @v9.7.5 Превышение цены в связанном заказе над итоговой ценой продажи
		extvQuotBias            = 1000 // Смещение, обозначающее вид котировки, применяемой для вычисления дополнительного показателя
	};
	//
	//
	//
	SLAPI  TrfrAnlzFilt();
	TrfrAnlzFilt & FASTCALL operator = (const TrfrAnlzFilt & rS);
	enum {
		eqxOrder    = 0x0001,
		eqxCrosstab = 0x0002
	};
	int    SLAPI IsEqualExcept(const TrfrAnlzFilt & rS, long flags) const;
	virtual int SLAPI Describe(long flags, SString & rBuf) const;

	enum {
		ravNothing      = 0,
		ravRest         = 0x0001, // Простой остаток
		ravAvgRest      = 0x0002, // Среднедневной остаток
		ravTurnoverRate = 0x0004, // Коэффициент оборачиваемости (движение / остаток)
		// @v9.3.4 ravCost         = 0x0008, // Суммовое значение показателя в терминах цен поступления
		// @v9.3.4 ravPrice        = 0x0010  // Суммовое значение показателя в терминах цен реализации
	};

	uint8  ReserveStart[12]; // @anchor
	long   ExtValueParam[2];  // @v9.3.4 Параметры, определяющие вычисление дополнительных показателей отчета
	long   RestAddendumValue; // @v9.1.3 Параметр, определяющий варинат отображения значений, базирующихся на остатках
	PPID   AcsID;        // @v8.4.1 Таблица статей для выбора контрагента (если не выбран вид операции)
	PPID   SupplAgentID; // @v7.0.11 Агент поставщика
	DateRange Period;
	DateRange LotsPeriod;
	PPID   OpID;
	PPID   SupplID;      //
	PPID   ArID_;        // Если !0, то перебираются только те документы, у которых ObjectID == ArID
	PPID   DlvrAddrID;   // Адрес доставки. Если ArID == 0, то не используется //
		// Если Flags & fByZeroDlvrAddr, то перебираются только документы, в которых адрес доставки не указан
	PPID   AgentID_;     // Если !0, то перебираются только те документы, в которых установлен этот агент
		// Если Flags & fByZeroAgent, то перебираются только те документы, в которых не установлен агент
	PPID   PsnCatID;     // Категория персоналии
	PPID   CityID;       // Город контрагентов, по которым перебираются операции
	PPID   GoodsGrpID;   // Товарная группа, по которой ведется перебор операций. Если GoodsID != 0,
		// то этот параметр игнорируется (используется только как ограничение выбора товара в диалоге) //
	PPID   GoodsID;      // Товар, по которому ведется перебор операций (может быть обобщенным)
	long   Flags;        // TrfrAnlzFilt::fXXX
	int    InitOrd;      // PPViewTrfrAnlz::IterOrder
	long   CtKind;       // TrfrAnlzFilt::ctXXX  Вид кросстабулированного отчета
	PPID   BrandID;      //
	Grouping Grp;        // Параметр группировки

	SubstGrpGoods   Sgg; // Подстановка товара
	SubstGrpPerson  Sgp; // Подстановка персоналии
	SubstGrpDate    Sgd; // Подстановка даты
	ObjIdListFilt   BillList;     // @anchor Список документов, по которым строится отчет
	ObjIdListFilt   RcptBillList; // Список приходных документов, которыми ограничивается перебор расходных операций
	ObjIdListFilt   LocList;      // Список складов
	ObjIdListFilt   CtValList;    // TrfrAnlzFilt::ctvXXX Показатель, вычисляемый в кросстаб-отчете
	ObjIdListFilt   ArList;       // Список статей контрагентов
	ObjIdListFilt   AgentList;    // Список статей агентов
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};

struct TrfrAnlzViewItem {
	SLAPI  TrfrAnlzViewItem();
	void   SLAPI Clear();

	LDATE  Dt;             // Дата операции
	long   OprNo;          // Номер операции за день (с группировкой - 0)
	PPID   BillID;         // ИД документа
	PPID   LocID;          // ИД склада
	PPID   ArticleID;      // ИД статьи документа
	PPID   PersonID;       // ИД персоналии, соответствующей статье документа (возможна подстановка)
	PPID   OpID;           // ИД вида операции
	PPID   GoodsID;        // ->Goods2.ID   ИД товара
	PPID   SubGoodsClsID;  // ИД класса товара (только для позиций, в которых товар был подстановлен по классификатору)
	PPID   LotID;          // ->Receipt.ID  ИД лота
	PPID   LinkBillID;     // @v9.6.8
	PPID   DlvrLocID;      // ->Location.ID ИД адреса доставки
	long   LocCount;       // Количество адресов доставки, попавших эту строку
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double Rest;           // Остаток (если фильтр не предусматривает расчет остатка, то - 0)
	double Cost;           // Сумма в ценах поступления или цена поступления (в зависимости от фильтра)
	double Price;          // Сумма в ценах реализации или цена реализации (в зависимости от фильтра)
	double Discount;       // Сумма в скидки или скидка на одну единицу (в зависимости от фильтра)
	double Amount;         // Номинальная сумма (зависит от вида операции)
	double SaldoQtty;      // Товарное сальдо в торговых единицах (для отдельных опций фильтрации)
	double SaldoAmt;       // Суммовое сальдо в номинальных ценах (для отдельных опций фильтрации)
	double PVat;           // Сумма НДС в ценах реализации
	double Brutto;         // @v8.7.7
	double LinkQtty;       // @v9.6.8
	double LinkCost;       // @v9.6.8
	double LinkPrice;      // @v9.6.8
	double ExtValue[2];    // @v9.3.4 Дополнительные показатели, определяемые специальными опциями фильтра
	SString BillCode_;     // @anchor Номер документа
	SString DtText_;       // Текстовое представление даты (при подстановке возможны вариации)
	SString GoodsText_;    // Текстовое представление товара (при подстановке возможны вариации) @v6.3.0 [64]-->[128]
	SString PersonText_;   // Текстовое представление персоналии (при подстановке возможны вариации) @v6.3.0 [80]-->[128]
};

struct TrfrAnlzTotal {
	SLAPI  TrfrAnlzTotal();
	void   SLAPI destroy();

	enum {
		stProblemPhQtty = 0x0001, // Физическое количество задано не для всех товаров
		stProblemBrutto = 0x0002  // Масса брутто определена не для всех товаров
	};
	long   Count;          // Количество строк
	long   State;	       // @v8.7.7 Флаги, индицирующие особенности в расчете итогов
	double Qtty;           // Количество торговых единиц
	double PhQtty;         // Количество физических единиц
	double Cost;           // Сумма в ценах поступления //
	double Price;          // Сумма в ценах реализации
	double Discount;       // Сумма скидки
	double Amount;         // Номинальная сумма
	double SaldoQtty;      // Суммарное сальдо в торговых единицах
	double SaldoAmt;       // Суммарное сальдо в номинальных ценах
	double PVat;           // Сумма НДС в ценах реализации
	double Brutto;         // @v8.7.7 Масса брутто товарных позиций в отчете
	double ExtValue[2];    // @v9.7.5 Дополнительные показатели, определяемые специальными опциями фильтра
};

struct AlcReportParam {
	long   ImpExpTag;
	long   ManufOptBuyerTag;
	long   ManufKindID;
	long   ImportKindID;
};

struct TrfrAnlzViewItem_AlcRep {
	SLAPI  TrfrAnlzViewItem_AlcRep();
	void   SLAPI Init();

	TrfrAnlzViewItem  Item;
	Goods2Tbl::Rec    GoodsRec;
	PPGdsClsPacket    GCPack;
	GoodsStockExt     GoodsStock;
	GoodsExtTbl::Rec  GoodsExt;
	BillTbl::Rec      BillRec;
	ReceiptTbl::Rec   OrgLotRec;
	long   PersonID;
	long   OrgLot_Prsn_SupplID;
	int    IsImport;
	int    IsExport;
	int    IsManuf;
	int    IsOptBuyer;
};

class PPViewTrfrAnlz : public PPView {
public:
	struct BrwHdr {
		PPID   __ID;       // ID записи таблицы TempTrfrGrpng
		PPID   GoodsID;
		PPID   ArID;
		PPID   DlvrAddrID;
		PPID   BillID;
		LDATE  Dt;
		long   OprNo;
	};
	enum IterOrder {
		OrdByDefault = 0,
		OrdByDate,
		OrdByGoods,
		OrdByArticle
	};

	SLAPI  PPViewTrfrAnlz();
	SLAPI ~PPViewTrfrAnlz();
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(TrfrAnlzViewItem *);
	int    SLAPI Export();
	int    SLAPI CalcTotal(TrfrAnlzTotal *);
	int    SLAPI ViewGraph();
	int    SLAPI GetBrwHdr(const void * pRow, BrwHdr *) const;
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;

	int    SLAPI SetAlcRepParam(AlcReportParam * pParam);
	int    SLAPI NextIteration_AlcRep(TrfrAnlzViewItem_AlcRep *);

	int    SLAPI AllocInnerIterItem();
	const TrfrAnlzViewItem * GetInnerIterItem() const;
private:
	static int   DynFuncGetRest;
	static int   DynFuncGetAvgRest;
	static int   DynFuncGetTrnovr;

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw); // @<<PPView::Browse
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI SerializeState(int dir, SBuffer & rBuf, SSerializeContext * pCtx);

	int    SLAPI CreateTempTable();
	int    SLAPI CreateOrderTable(IterOrder);
	int    SLAPI Add(BExtInsert * pBei, long * pOprNo, TransferTbl::Rec * pTrfrRec, BillTbl::Rec * pBillRec, GCTIterator::ItemExtension * pExt);
	int    SLAPI InitGrpngNames();
	int    SLAPI NextOuterIteration();
	int    SLAPI NextInnerIteration(TrfrAnlzViewItem *);
	void   FASTCALL InitAppData(TrfrAnlzViewItem *);
	//
	// If billID != 0 (Filt.Grp == gGoodsBill) then function suppose pBuf
	// too contains bill.Code and write date format at front of them
	// (function Add must write bill code to field TempTrfrGrpngTbl.DtText).
	//
	int    SLAPI InitDateText(LDATE, PPID billID, SString & rBuf);
	//int    SLAPI InitDateText(LDATE, PPID billID, char * pBuf, size_t bufLen);
	//
	// Descr: возвращает сальдо на указанную дату. Если дата не указана (ZERODATE), тогда на текущую дату.
	//
	int    SLAPI GetSaldo(PPID goodsID, PPID artID, PPID dlvrLocID, LDATE dt, double * pSaldoQtty, double * pSaldoAmt);
	int    SLAPI AddAbsentSaldo();
	int    SLAPI GetArticlesBySaldo(PPID gdsID, PPIDArray * pArtAry);
	int    SLAPI GetDlvrLocID(const BillTbl::Rec *, PPID * pDlvrLocID);
	int    SLAPI InitDlvrLocID(const BillTbl::Rec *, PPID * pDlvrLocID, TempTrfrGrpngTbl::Rec *);
	int    SLAPI CalcInRest(PPID goodsID, double * pRest);
	SString & SLAPI GetCtColumnTitle(int ct, SString & rBuf);

	TagrCacheItem & FASTCALL GetCacheItem(uint pos) const;
	int    SLAPI FlashCacheItems(uint count);
	int    SLAPI FlashCacheItem(BExtInsert * pBei, const TagrCacheItem & rItem);

	TrfrAnlzFilt Filt; // @viewstatefilt
	enum {
		fAsGoodsCard       = 0x0001,  // Работает как карточка товара с расчетом остатка после каждой операции
		fShowSaldo         = 0x0002,  // Рассчитывать и показывать товарное сальдо по операциям с клиентом
		fAccsCost          = 0x0004,  // Разрешен доступ к ценам поступления //
		fOnceInited        = 0x0008   // Объект как минимум один раз был инициализирован вызовом Init_
	};
	long   Flags;         // @viewstate
	double InRest;        // @viewstate
	IterOrder CurViewOrd; // @viewstate
	IterOrder CurIterOrd;
	PPIDArray LocList;    // @viewstate
	GoodsSubstList Gsl;   // @viewstate
	PPObjPerson::SubstParam Psp;
	TempTrfrAnlzTbl  * P_TrAnlzTbl;  // @viewstatetable
	TempTrfrGrpngTbl * P_TrGrpngTbl; // @viewstatetable
	TempOrderTbl     * P_OrderTbl;   // @viewstatetable
	BExtQuery * P_IterOrderQuery;
	GCTIterator::GoodsRestArray GctRestList; // @viewstate
	TrfrAnlzTotal Total;
	PPID   PrevOuterID;
	PPID   CurOuterID;
	TrfrAnlzViewItem * P_InnerIterItem; // Внутренний собственнй экземпляр элемента текущей итерации.
		// Если необходим, должен быть распределен функцией AllocInnerIterItem()
	LAssocArray LocCountList;
	PPObjArticle ArObj;
	SArray Cache;
	CompFunc Cf;  // @*PPViewTrfrAnlz::Init_
	long   GrpIdCounter;
	long   LastCacheTouch;

	const uint MaxCacheItems; // Максимальное количество элементов в кэше
	const uint CacheDelta;    // Количество элементов, сбрасываемое из кэша в базу данных при переполнении кэша
	AlcReportParam AlcRepParam; // Для алкогольной декларации
	PPObjGoods  GObj;
	PPObjGoodsClass GdsClsObj;
	PPObjBill * P_BObj;
	PPObjPerson PsnObj;
	PPObjTag    TagObj;
};
//
// @v9.7.8
// Descr: Универсальная параметрическая структура для автоматического создания документов.
// Note: Это, кроме прочего - попытка унифицировать механизмы автоматического создания документов, разбросанные
//   на текущий момент по всему проекту.
//PPViewCCheck::CreateDraftBySuspCheck(PPID chkID)
//PPViewSStat::CreateDraftBySupplOrders(const SStatFilt *)
//PPViewCSess::CreateDraft(const CSessCrDraftParam *);
//
class PPBillAutoCreateParam : public PPBaseFilt {
public:
	SLAPI  PPBillAutoCreateParam();
	SLAPI  PPBillAutoCreateParam(const PPBillAutoCreateParam & rS);
	PPBillAutoCreateParam & FASTCALL operator = (const PPBillAutoCreateParam & rS);
	//
	// Descr: Возвращает внутренний фильтр для обработки данных, в зависимости от
	//   параметра a. Если a == -1, то возвращает фильтр, зависящий от текущего значения A.
	//
	PPBaseFilt * FASTCALL GetInnerFilt(int a) const;
	//
	// Descr: Типы функционала по созданию документов
	//
	enum {
		aNone = 0,
		aDraftByTrfrAnlz = 1, // Драфт-документы по анализу товарных операций
		aDraftBySuspCc,       // Драфт-документы по отложенным кассовым чекам
		aDraftBySupplOrders,  // Драфт-документы заказов поставщикам
		aDraftByCcRule        // Драфт-документы по правилам на основе кассовых чеков
	};
	uint8  ReserveStart[64];
    PPID   OpID;
    long   A;                  // Тип функционала, вызываемого по данному параметру
    long   Flags;
	int32  RuleGrpID;          // CSessCrDraftParam
	int32  RuleID;             // CSessCrDraftParam
    long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
	TrfrAnlzFilt * P_TaF;
	SStatFilt * P_SsF;
	CCheckFilt * P_CcF;
	CSessFilt  * P_CsF;
private:
	int    SLAPI InitInstance();
};

class PrcssrBillAutoCreate {
public:
	SLAPI  PrcssrBillAutoCreate();
	SLAPI ~PrcssrBillAutoCreate();
	int    SLAPI InitParam(PPBillAutoCreateParam *);
	int    SLAPI EditParam(PPBillAutoCreateParam *);
	int    SLAPI Init(const PPBillAutoCreateParam *);
	int    SLAPI Run();

	int    SLAPI CreateDraftByTrfrAnlz();
	static int SLAPI CreateDraftByCSessRule(const CSessCrDraftParam * pParam);
	static int SLAPI CreateDraftBySupplOrders(const SStatFilt * pFilt);
private:
    PPViewTrfrAnlz * P_TaV;
    PPViewSStat * P_SsV;
    PPViewCCheck * P_CcV;
    PPViewCSess * P_CsV;
	PPBillAutoCreateParam P;
};
//
// @ModuleDecl(PPViewGoodsOpAnalyze)
//   Товарный отчет по операции
//
#define ABC_GRPSCOUNT 5L

struct ABCAnlzFilt {
	enum {
		GroupByCostSum  = 0,
		GroupByPriceSum = 1,
		GroupByQtty     = 2,
		GroupByIncome   = 3
	};
	int    CheckFracts(double * pFractsSum);
	int    GetGroupName(short abcGroup, char * pBuf, size_t bufLen);
	void   SortGrpFract();

	double GrpFract[ABC_GRPSCOUNT];
	long   GroupBy;
};

struct GoodsOpAnalyzeFilt : public PPBaseFilt {
	SLAPI  GoodsOpAnalyzeFilt();
	virtual int Describe(long flags, SString & rBuff) const;
	SString & FASTCALL GetOpName(SString & rName) const;
	int    FASTCALL IsValidABCGroup(short abcGroup) const;
	void   ZeroCompareItems();
	void   FASTCALL AddTradePlanBillID(PPID);

	enum { // OpGrp
		ogSelected          = 0,      // На выбор (opr)
		ogIncoming          = 1,      // Все операции, приносящие доход (расход товара)
		ogProfitable        = 2,      // Все доходные операции, включая возвраты
		ogPayed             = 3,      // Все оплаченные доходные операции
		ogInOutAnalyze      = 4       // Анализ вход-выход (по обобщенной операции или по модификации)
	};
	enum {
		fLabelOnly           = 0x00000001, // Только по WL-документам
		fDiffByPrice         = 0x00000002, // Разбивать по ценам реализации
		fDiffByNetPrice      = 0x00000004, // Разбивать по чистым ценам реализации
		fIntrReval           = 0x00000008, // Разница цен при межскладском перемещении
		fPriceWithoutExcise  = 0x00000010, // Из цены реализации вычитать акциз
		fUseABCAnlz          = 0x00000020, // Использовать ABC анализ
		fCalcRest            = 0x00000040, // Рассчитывать колонку остатков
		fPriceDeviation      = 0x00000080, // Отклонение цен
		fDisplayWoPacks      = 0x00000100, // Количество показывать без упаковок
		fEachLocation        = 0x00000200, // Раздельно по каждому складу
		fCalcOrder           = 0x00000400, // Рассчитывать незакрытые заказы (количество)
		fShowSStatSales      = 0x00000800, // Показывать средне-дневные продажи из статистики продаж
		fCompareWithReceipt  = 0x00001000, // Сравнивать с документами закупки
		fUnprofitableGoods   = 0x00002000, // Убыточные товары
		fBadSellingGoods     = 0x00004000, // Плохо продающиеся товары
		fComparePctDiff      = 0x00008000, // При расчете сравнения разницу показывать в %
		fBillListAsTradePlan = 0x00010000, // @internal Список документов трактуется как набор документов планов продаж
		fTradePlanObjAsSuppl = 0x00020000, // @internal Интерпретировать контрагента документов плана продаж
			// как поставщика (план продаж по поставщикам)
		fTradePlanGoodsOnly  = 0x00040000, // Показывать только те позиции, которые есть в торговом плане
		fAddNzRestItems      = 0x00080000, // Дополнить отчет позициями, которые есть на остатке (при наличии флага fCalcRest)
		fCrosstab            = 0x00100000, // Кросстаб
		fABCAnlzByGGrps      = 0x00200000, // ABC анализ рассчитывать для каждой товарной группы отдельно
		fCalcCVat            = 0x00400000, // @v8.3.5 Рассчитывать валовую сумму НДС в ценах поступления //
		fCalcPVat            = 0x00800000  // @v8.3.5 Рассчитывать валовую сумму НДС в ценах реализации //
	};
	//
	// Ид. дополнительных полей товарного точета по операции
	//
	enum {
		fldidQtty  = 1,
		fldidRest,
		fldidCostRest,
		fldidPriceRest,
		fldidCostAmount,
		fldidPriceAmount,
		fldidIncome,
		fldidPctProfitable,
		fldidPctMargin
	};
	//
	// Флаги дополнительных полей
	//
	enum {
		ffldMainPeriod = 0x00000001L,
		ffldCmpPeriod  = 0x00000002L,
		ffldDiff       = 0x00000004L
	};

	char   ReserveStart[8];    // @anchor @v8.1.12 [12]-->[8]
	PPID   FreightAgentID;     // @v8.1.12 ->Person.ID Транспортный брокер
	SubstGrpBill Sgb;          // @v6.4.0 Подстановка документа.
		// Если !!Sgb то отчет строится не в разрезе товаров (или их подстановок), а в разрезе подстановочного
		// атрибута документов.
		// При этом отключаются следующие возможности:
		// -- расчет остатков (fCalcRest)
		// -- подстановка товара (Sgg)
		// -- среднедневные продажи (fShowSStatSales)
		// -- разбивка по ценам (fDiffByPrice, fDiffByNetPrice)
	LDATE  CmpRestCalcDate;    // Дата расчета остатков для сравнения (используется если Flags & fCalcRest)
	DateRange CmpPeriod;       // Период для сравнения //
	DateRange Period;          // Период документов
	PPID   OpID;               // ->Ref(PPOBJ_OPRKIND) Вид операции, по которой следует анализировать документы
	PPID   OpGrpID;            // GoodsOpAnalyzeFilt::opXXX Группа операций
	PPID   AccSheetID;         // ->Ref(PPOBJ_ACCSHEET).ID
	PPID   ObjectID;           // ->Article.ID Контрагент по документам
	PPID   ObjCityID;          // ->City.ID    Город нахождения контрагента
	PPID   SupplID;            // ->Article.ID Поставщик
	PPID   AgentID;            // ->Article.ID Агент по документам
	PPID   SupplAgentID;       // ->Article.ID Агент поставщика
	PPID   GoodsGrpID;         // ->Goods2.ID  Товарная группа. Если GoodsIdList.IsExists(), то GoodsGrpID не используется //
	long   Flags;              // Флаги
	SubstGrpGoods Sgg;         // Подстановка товара
	LDATE  RestCalcDate;       // Дата расчета остатков (используется если Flags & fCalcRest)
	ABCAnlzFilt ABCAnlz;       // Параметры ABC-анализа
	short  ABCAnlzGroup;       // 0 - no ABC, 1 - grouping recs name, 2 - grouping recs and detail, -1, -2 .. - belong to group
	uint16 Pad;                // @alignment
	PPID   QuotKindID;         // ->Quotation.ID Вид котировки, который следует использовать вместо цены реализации
	PPID   Object2;            // Дополнительный объект. Таблица статей для данного объекта берется из вида операции.
	ObjIdListFilt GoodsIdList; // Список товаров. Если GoodsIdList.IsExists() то GoodsGrpID не используется.
	ObjIdListFilt BillList;    // Список документов. Если BillList.IsExists(), то поля OpID, OpGrpID, AccSheetID,
   		// LocList и ObjectID игнорируются.
	ObjIdListFilt LocList;     // Список складов
	ObjRestrictArray CompareItems;
};

struct GoodsOpAnalyzeViewItem {
	struct CmVal {
		CmVal() { Val = Cm = 0.0; }
		operator double() const { return Val; }
		double FASTCALL operator = (double val) { Val = val; return Val; }
		void   SetCm(double cm) { Cm = cm; }
		double GetDiff() const { return (Val - Cm); }
		double GetPctDiff() const { return fdivnz(Val - Cm, Cm); }

		double Val;     // Основное значение
		double Cm;      // Значение из сравнительного периода
	};
	PPID   ID__;
	PPID   LocID;          //
	int16  InOutTag;       // -1 - in, 1 - out, 0 - undef
	int16  Reserve;        // @alignment
	PPID   GoodsID;        // Если используется подстановка инородного объекта
		// (производитель, атрибуты класса), то поле содержит маску 0x40000000L
	PPID   GoodsGrpID;
	PPID   SubstArID;      // Статья, подставленная вместо GoodsID
	PPID   SubstPsnID;     // Персоналия, подставленная вместо GoodsID
	PPID   SubstLocID;     // Склад, подставленный вместо GoodsID
	char   GoodsName[128]; //
	const  char * P_GoodsGrpName; // @OWNED_BY PPViewGoodsTaxAnalyze instance
	double UnitPerPack;
	CmVal  Qtty;
	double PhQtty;
	union {
		double OldCost;    // Старая цена поступления (для переоценки)
		double PlanQtty;   // Плановое количество
	};
	union {
		double OldPrice;   // Старая цена реализации (для переоценки)
		double PlanSumPrice; // Плановая сумма продаж (закупок)
	};
	double Cost;
	double Price;
	CmVal  SumCost;
	CmVal  SumPrice;
	CmVal  Income;         // SumPrice-SumCost
	CmVal  SumCVat;        // @v8.3.5 Валовая сумма НДС в ценах поступления
	CmVal  SumPVat;        // @v8.3.5 Валовая сумма НДС в ценах реализации
	double PctVal;
	CmVal  Rest;
	CmVal  PhRest;         // @v7.5.4 Остаток в физических единицах
	CmVal  RestCostSum;
	CmVal  RestPriceSum;
};

struct GoodsOpAnalyzeTotal {
	SLAPI  GoodsOpAnalyzeTotal();
	void   SLAPI Init();
	GoodsOpAnalyzeTotal & FASTCALL operator = (const GoodsOpAnalyzeTotal &);

	long   Count;
	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
	double Income;
	double SumCVat;        // @v8.3.5 Валовая сумма НДС в ценах поступления
	double SumPVat;        // @v8.3.5 Валовая сумма НДС в ценах реализации
	double Rest;           // @v7.5.4 Остаток в торговых единицах
	double PhRest;         // @v7.5.4 Остаток в физических единицах
	double RestCost;
	double RestPrice;
	double PlanQtty;
	double PlanSum;
	AmtList Amounts;

	long   InCount;
	double InQtty;
	double InPhQtty;
	double InCost;
	double InPrice;
	double InIncome;
};

class PPViewGoodsOpAnalyze : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByGrp_GoodsName,
		OrdByQtty,
		OrdByCostSum,
		OrdByPriceSum,
		OrdByIncome,
		OrdByRest     // Только если Filt.Flags & fCalcRest
	};
	struct BrwHdr {
		PPID   LocID;
		PPID   GoodsID;
		char   Text[128];
		double Quantity;
		double PhQtty;
		double SumCost;
		double SumPrice;
		double Income;
		short  InOutTag;
	};

	SLAPI  PPViewGoodsOpAnalyze();
	SLAPI ~PPViewGoodsOpAnalyze();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	int    SLAPI InitIteration(IterOrder);
	int    FASTCALL NextIteration(GoodsOpAnalyzeViewItem *);
	int    SLAPI ChangeOrder(BrowserWindow *);
	int    SLAPI CalcTotal(GoodsOpAnalyzeTotal *);
	int    SLAPI ViewDetail(PPID locID, PPID goodsID, short abcGroup, int viewAllLots = 0);
	int    SLAPI ConvertLinesToBasket();
	int    SLAPI ABCGrpToAltGrp(short abcGroup);
	void   SLAPI GetTempTableName(SString & rBuf) const;
	int    SLAPI GetByID(PPID id, TempGoodsOprTbl::Rec * pRec);
	int    SLAPI InitUniq(const SArray * pUniq);
	int    SLAPI CopyUniq(SArray * pUniq);
	int    SLAPI GetTabTitle(long tabID, SString & rBuf);
	int    SLAPI GetEditIds(const void * pRow, PPID * pLocID, PPID * pGoodsID, long col);
private:
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Print(const void *);
	int    SLAPI CreateTempTable(double * pUfpFactors);
	int    SLAPI CreateOrderTable(IterOrder, TempOrderTbl **);
	int    SLAPI InitGoodsRestView(PPViewGoodsRest * pGrView);
	int    FASTCALL CheckBillRec(const BillTbl::Rec *) const;
	int    SLAPI PutBillToTempTable(PPBillPacket *, double part, int sign, PPIDArray *);
	int    SLAPI InitIterQuery(PPID grpID);
	int    SLAPI NextOuterIteration();
	int    SLAPI SetupCrosstabColumns(PPViewBrowser * pBrw);
	PPViewGoodsOpAnalyze::IterOrder SLAPI GetIterOrder() const;
	int    SLAPI InitAddingBlock(const PPBillPacket * pPack, double part, int sign, GoaAddingBlock * pBlk);
		// @<<PutBillToTempTable
	int    SLAPI PreprocessTi(const PPTransferItem * pTi, const PPIDArray * pSupplBillList, long substBillVal, GoaAddingBlock * pBlk);
		// @<<PutBillToTempTable
	GoaCacheItem * FASTCALL GetCacheItem(uint pos) const;
	int    SLAPI FlashCacheItems(uint count);
	int    SLAPI FlashCacheItem(BExtInsert * pBei, const GoaCacheItem * pItem);
	int    SLAPI AddItem(GoaAddingBlock * pBlk);
	int    SLAPI ViewGraph();

	GoodsOpAnalyzeFilt Filt;

	PPObjBill   * P_BObj;
	PPObjGoods    GObj;
	PPObjPerson * P_PsnObj;
	PPObjLocation LocObj;
	PredictSalesCore * P_Psc;
	TempGoodsOprTbl * P_TempTbl;
	TempOrderTbl    * P_TempOrd;
	GoodsSubstList    Gsl;
	PPObjBill::SubstParam Bsp;           // @v6.4.0 Параметр подстановки по документам
	GoodsOpAnalyzeTotal Total;
	TrfrAnlzFilt * P_TrfrFilt;
	PPTrfrArray  * P_TradePlanPacket;
	PPViewGoodsOpAnalyze * P_CmpView;
	CompFunc Cf;                         // @*PPViewGoodsOpAnalyze::Init_
	CompFunc Cf_UniqItem;                // @*PPViewGoodsOpAnalyze::Init_
	enum {
		sFiltAltGrp     = 0x0001,        // @*PPViewGoodsOpAnalyze::Init_
		sFiltExclFolder = 0x0002,        // @*PPViewGoodsOpAnalyze::Init_
		sTotalInited    = 0x0004,
		sAccsCost       = 0x0008,
		sReval          = 0x0010         // Отчет строится по операции переоценки
	};
	long   State;
	SArray * P_Cache;
	SArray * P_Uniq;
	UintHashTable * P_GoodsList;         // @*PPViewGoodsOpAnalyze::Init_
	GoodsGroupIterator  * P_GGIter;
	IterOrder CurrentViewOrder;
	int    IterIdx;
	// @v9.6.6 char   IterGrpName[256];
	SString IterGrpName; // @v9.6.6
};
//
// @ModuleDecl(PPViewSCard)
//
struct SCardFilt : public PPBaseFilt {
	SLAPI  SCardFilt();
	SCardFilt & FASTCALL operator = (const SCardFilt & rS);

	enum {
		fSinceLastPDisUpdating = 0x0001,
		fWoOwner               = 0x0002,
		fShowOwnerAddrDetail   = 0x0004,
		fWithAddressOnly       = 0x0008, // Показывать только карты с адресами (если !fShowOwnerAddrDetail, то не применяется)
		fNumberFromBeg         = 0x0010, // this->Number трактовать как строку, содержащуюся с начала кода
		fNoTempTable           = 0x0020, // @internal
		fNoEmployer            = 0x0040, // @internal Не заполнять поле SCardViewItem::EmployerID (для увеличения производительности)
		fInnerFilter           = 0x0080  // @v8.4.3 Внутренний флаг, используемый для ограничений редактирования внутреннего фильтра
	};
	uint8  ReserveStart[12]; // @anchor // @v9.4.5 [16]-->[12]
	PPID   LocID;            // @v9.4.5 -->Location.ID Локация, которой принадлежат карты
	DateRange IssuePeriod;   // Период даты выпуска карты
	DateRange ExpiryPeriod;  // Период срока истечения годности карты
	DateRange TrnovrPeriod;  // Показывать обороты за указанный период
	PPID   SeriesID;      // Серия карт. Если ScsList.NotEmpty(), то SeriesID игнорируется.
	PPID   PersonID;      //
	PPID   EmployerID;    // Работодатель, чьи сотрудники владеют картами
	// @v9.6.6 double MinPDis;       //
	// @v9.6.6 double MaxPDis;       //
	// @v9.6.6 double MinTurnover;   //
	// @v9.6.6 double MaxTurnover;   //
	RealRange PDisR;      // @v9.6.6 (замена пары double'ов на RealRange)
	RealRange TurnoverR;  // @v9.6.6 (замена пары double'ов на RealRange)
	int16  Ft_Inherited;  //
	int16  Ft_Closed;     //
	long   Order;         // PPViewSCard::IterOrder
	long   Flags;         //
	long   Reserve;       // @anchor Заглушка для отмера плоского участка фильтра
	SString Number;       // Номер дисконтной карты
	ObjIdListFilt ScsList;     // @v8.4.2 @construction Список серий
	SysJournalFilt * P_SjF;    //
	SCardFilt * P_ExludeOwnerF; // @v8.4.2 Фильтр, по которому из выборки исключаются владельцы карт, под него подпадающие
	PersonFilt * P_OwnerF;      // @v8.4.2 @construction Фильтр по владельцам
private:
	virtual int SLAPI ReadPreviosVer(SBuffer & rBuf, int ver);
};

struct SCardTotal {
	long   Count;
	double Turnover;       // Суммарный оборот
};

struct SCardViewItem : public SCardTbl::Rec {
	PPID   EmployerID;
};

struct SCardSelPrcssrParam { // @persistent
	enum {
		fSetClosed    = 0x0001,
		fZeroDiscount = 0x0002, // Если установлен, но по всем картам скидку требуется обнулить
		fZeroExpiry   = 0x0004  // @v9.6.2 Пустое значение даты истечения срока действия
	};
	SCardSelPrcssrParam();
	int    IsEmpty() const;
	void   Init();
	int    Validate(PPID srcSeriesID);
	int    Write(SBuffer & rBuf, long) const;
	int    Read(SBuffer & rBuf, long);
	//
	// Соображения по обратной совместимости:
	//    Если в поле Ver стоит номер версии, меньший, чем 7.6.12, то считавыем это поле как Flags и пропускаем AutoGoodsID.
	//    Здесь приходится закладываться на то, что Flags мог иметь значение либо 0 либо 1.
	//
	SVerT Ver;         // @v7.6.12
	int32  Flags;
	LDATE  DtEnd;
	int32  NewSerID;
	int32  AutoGoodsID; // @v7.6.12
	//
	int32  FlagsSet;    // @v7.7.2 Флаги, которые следует установить
	int32  FlagsReset;  // @v7.7.2 Фдаги, которые следует снять
	int16  PeriodTerm;  // @v7.7.2 Тип периода длительности срока действия //
	int16  PeriodCount; // @v7.7.2 Количество периодов длительности срока действия //
	double Discount;    // @v7.7.2 Процент скидки //
	//
	SCardFilt SelFilt;
};

class PPViewSCard : public PPView {
public:
	enum IterOrder {
		OrdBySeries_Code = 0,
		OrdByDiscount,
		OrdByTrnovr,
		OrdByPerson,
		OrdByExpiry
	};
	struct BrwHdr {
		PPID   ID;
	};

	SLAPI  PPViewSCard();
	SLAPI ~PPViewSCard();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SCardViewItem *);
	int    SLAPI DeleteItem(PPID);
	int    SLAPI ViewOps(PPID);
	int    SLAPI ChargeCredit();       // Начисление на выборку кредитных карт
	int    SLAPI ChangeDiscount();     // Изменение процента скидки по выборке карт
	int    SLAPI RecalcTurnover();
	int    SLAPI RecalcRests();
	int    SLAPI Transmit(PPID);
	int    SLAPI ReplaceCardInChecks(PPID destCardID);
	int    SLAPI ChangeFlags();
	int    SLAPI RenameDup(PPIDArray * pIdList);
	// @v7.3.12 int    SLAPI CheckForFilt(SCardTbl::Rec * pRec, RAssocArray * pTrnovrList, int calcTrnovr);
	int    SLAPI PreprocessTempRec(const SCardTbl::Rec * pSrcRec, TempSCardTbl::Rec * pDestRec, RAssocArray * pTrnovrList/*, int calcTrnovr*/); // @v7.3.12
	int    SLAPI ProcessSelection(SCardSelPrcssrParam * pParam, PPLogger *);
	const  StrAssocArray & GetList() const
	{
		return List;
	}
	int    SLAPI CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pCellStyle);
private:
	struct PreprocessScRecBlock {
		PreprocessScRecBlock();

		PPID   ScID;
		double InTurnover;
		double Turnover;
	};
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI OnExecBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual void * SLAPI GetEditExtraParam();
	virtual int  SLAPI ViewTotal();
	int    SLAPI CheckForFilt(const SCardTbl::Rec * pRec, PreprocessScRecBlock * pBlk);
	int    SLAPI IsTempTblNeeded() const;
	int    SLAPI CreateTempTable();
	int    SLAPI CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	int    SLAPI UpdateTempTable(PPIDArray * pIdList);
	int    SLAPI MakeTempOrdEntry(long ord, const SCardTbl::Rec * pRec, TempOrderTbl::Rec * pOrdRec);
	int    SLAPI GetPDisUpdateDate(PPID cardID, LDATE before, LDATE * pDate);

	SCardFilt Filt;
	PPObjSCard SCObj;
	PPObjPerson PsnObj;
	PPObjStaffList * P_StffObj;
	PPLocAddrStruc Las;
	StrAssocArray List; // @v7.6.6
	ObjIdListFilt ExcludeOwnerList; // @v8.4.2
	TempSCardTbl * P_TmpTbl;
	TempOrderTbl * P_TempOrd;
};
//
// @ModuleDecl(PPViewSCardOp)
//   Operations by card
//
struct SCardOpFilt : public PPBaseFilt {
	SLAPI  SCardOpFilt();

	uint8  ReserveStart[32]; // @anchor
	PPID   SCardID;
	PPID   SCardSerID;
	DateRange Period;
	RealRange AmtR;
	long   Flags;
	long   Order;
	long   Reserve;          // @anchor Заглушка для отмера плоского участка фильтра
};

typedef SCardOpTbl::Rec SCardOpViewItem;

struct SCardOpTotal {
	long   Count;
	double InRest;
	double OutRest;
	double Debit;
	double Credit;
};

class PPViewSCardOp : public PPView {
public:
	enum {
		ordByDefault = 0,
		ordByDate,
		ordByCard,
		ordByOwner,
		ordByAmount
	};
	struct BrwHdr {
		PPID   SCardID;
		LDATE  Dt;
		LTIME  Tm;
	};
	SLAPI  PPViewSCardOp();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SCardOpViewItem *);
	int    SLAPI CalcTotal(SCardOpTotal *);
	int    SLAPI AddItem(int freezing);
private:
	static int DynFuncExtObjName;

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);

	int    SLAPI Recover();

	SCardOpFilt Filt;
	PPObjSCard SCObj;
	LDATETIME IterPos;
};
//
// @ModuleDecl(PPViewUhttSCardOp)
//
class UhttSCardOpFilt : public PPBaseFilt {
public:
	SLAPI UhttSCardOpFilt();

	enum {
		gNone = 0,
		gTotal,
		gDate,
		gSCard,
		gDlvrLoc
	};
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   GlobalAccID;
	PPID   DlvrLocID;
	int    Grp;
	long   Reserve;          // @anchor
};

struct UhttSCardOpViewItem {
	LDATETIME Dtm;
	PPID   SCardID;
	PPID   DlvrLocID;
	long   SellCount;
	double SellAmt;
	long   ChargeCount;
	double ChargeAmt;
	long   WithdrawCount;
	double WithdrawAmt;
	double SCardRest;
};

class PPViewUhttSCardOp : public PPView {
public:
	SLAPI  PPViewUhttSCardOp();
	SLAPI ~PPViewUhttSCardOp();
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(UhttSCardOpViewItem *);
	int    SLAPI CalcTotal(UhttSCardOpViewItem *, int) const;
	const TSArray <UhttSCardOpViewItem> * GetList() const { return &List; };
private:
	int    SLAPI Helper_AddItem(UhttSCardOpViewItem &);
	TSArray <UhttSCardOpViewItem> List;
	UhttSCardOpFilt Filt;
	PPObjSCard      ScObj;
	SString         ScPrefix;
};
//
// @ModuleDecl(PPViewArticle)
//
typedef ArticleTbl::Rec ArticleViewItem;

#define DEBTDIM_BRW_SHOWCOUNT 15 // @v7.1.5 6-->16

class PPViewArticle : public PPView {
public:
	enum {
		ordByName    = 0,
		ordByArticle = 1,
		ordByDefault = 2
	};
	SLAPI  PPViewArticle();
	SLAPI ~PPViewArticle();
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	virtual int  SLAPI Init_(const PPBaseFilt *);
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ArticleViewItem *);
private:
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * SLAPI GetEditExtraParam();
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI Print(const void *);
	int    SLAPI UpdateTempTable(PPID arID);
	int    SLAPI EditLinkObject(PPID arID);
	int    SLAPI InitDebtLim(TempArAgtTbl::Rec * pRec, PPClientAgreement * pCliAgt);
	int    SLAPI EditDebtDimList(PPID arID);
	int    SLAPI Transmit(PPID id);
	int    SLAPI DeleteAll();
	int    SLAPI RecoverLinkObjects();

	StrAssocArray * P_DebtDimList;
	PPObjArticle ArObj;
	ArticleFilt  Filt;
	int    CurIterOrd;
	int    CtrlX;   // @v8.0.3
	long   LimitTerm;      // @v8.2.4 @*Init_
	long   AddedLimitTerm; // @v8.2.4 @*Init_
	PPID   AgtProp; // @#[ARTPRP_CLIAGT, ARTPRP_SUPPLAGT]
	TempArAgtTbl * P_TempTbl;
};
//
// Beignig of Basket's Headers PPObj.h
//
#define GBASKF_DEFAULT   0x0001L // Корзина используемая по умолчанию
#define GBASKF_SORTITEMS 0x0002L // Сортировать строки по наименованию товаров
#define GBASKF_PRIVATE   0x0004L // @transient @v6.4.0 Приватная корзина. Удерживается в текущем
	// сеансе и не сохраняется в базе пока пользователь не завершит сеанс или не
	// снимет признак приватности.
//
// Descr: Заголовочная струкутра товарной корзины
//
struct PPGoodsBasket2 {    // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_GOODSBASKET
	long   ID;             // @id
	char   Name[48];       // @name @!refname
	char   Symb[20];       //
	char   Reserve1[56];   // @reserve
	long   Num;            // Внутренний номер (не используется, но инициализируется)
	long   Flags;          // GBASKF_XXX
	PPID   User;           // ->Ref(PPOBJ_USR) Пользователь, создавший корзину
	PPID   SupplID;        // ->Article.ID
};

DECL_REF_REC(PPGoodsBasket);

class PPBasketPacket : public ILBillPacket {
public:
	SLAPI  PPBasketPacket();
	SLAPI ~PPBasketPacket();
	void   SLAPI Init();
	PPBasketPacket & FASTCALL operator = (const PPBasketPacket &);
	//
	// Descr: Инициализирует внутренние структуры для поддержки корректного
	//   добавления элементов функцией AddItem.
	//
	void   SLAPI InitInsertion();
	//
	// Descr: Добавляет элемент в корзину
	// ARG(pItem         IN): Элемент, добавляемый в корзину.
	// ARG(pPos         OUT): Позиция, в которой находится элемент после вставки в корзину
	// ARG(replaceOption IN): Опции обработки наличия товара pItem->GoodsID в корзине.
	//   1 - возвращает ошибку (PPErrCode = PPERR_DUPBASKETITEM)
	//   2 - заменяет существующий элемент в корзине
	//   3 - удаляет существующий в корзине элемент, а на его место вставляет pItem
	//       с количеством (Quantity) равным сумме количества в существующем и вставляемом элементах
	//   other - возвращает ошибку (PPErrCode = PPERR_DUPBASKETITEM)
	//
	int    SLAPI AddItem(const ILTI * pItem, uint * pPos, int replaceOptions = 1);
	int    SLAPI DelItem(long);
	int    SLAPI SearchGoodsID(PPID goodsID, uint * pPos) const;

	PPID   GoodsID;
	PPGoodsBasket Head;
private:
	PPIDArray InsertedGoodsList; // Список товаров, добавленных в корзину
};

#define SRCH_DEFBASKET      1
#define SRCH_BASKET         2
#define SRCH_LOCKEDBASKET   3
#define SRCH_UNLOCKEDBASKET 4

// @v5.8.11 VADIM {
//   int action = 1 - disable selection;
//              = 2 - dialog to cascade;
//              = 3 - edit basket name and flags
// } @v5.8.11 VADIM
int  SLAPI GoodsBasketDialog(PPBasketCombine & rBasket, int action);

class PPObjGoodsBasket : public PPObjReference {
public:
	enum {
		ordByDefault = 0,
		ordByGoods,
		ordByGroup
	};
	static int   SLAPI IsLocked(PPID);
	static int   SLAPI ForceUnlock(PPID);
	static int   SLAPI IsPrivate(PPID id);

	class Locking {
	public:
		Locking(PPID id = 0);
		~Locking();
		int    Lock(PPID);
		int    Unlock();
	private:
		PPID   ID;
		int    L;
	};

	SLAPI  PPObjGoodsBasket(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr /*goodsID*/);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Select(PPID * pID, const char * pMsg);
	//
	// Descr: Опции функции PPObjGoodsBasket::GetPacket
	//
	enum {
		gpoProcessPrivate = 0x0001 // Если корзина приватная, то извлекать ее из буфера, а не из БД
	};

	int    SLAPI GetPacket(PPID id, PPBasketPacket * pData, long options = 0);
	int    SLAPI PutPacket(PPID * pID, PPBasketPacket * pData, int use_ta);
	int    SLAPI Print(PPBasketPacket *);
	int    SLAPI ClearDefForBaskets(int use_ta);
	int    SLAPI SearchDefaultBasket(PPID * pID, PPGoodsBasket * pRec);
	int    SLAPI SearchByName(PPID *, const char * pName, PPBasketPacket * = 0);
	int    SLAPI GetPreferredBasket(PPBasketCombine & rC);
	int    SLAPI SelectBasket(PPBasketCombine & rBasket);
	int    SLAPI Transfer(PPID);
private:
	static int    SLAPI SetAddLockErrInfo(PPID mutexID);

	virtual void  SLAPI Destroy(PPObjPack*);
	virtual int   SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int   SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int   SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual void * SLAPI CreateObjListWin(uint flags, void * extraPtr);
	int    SLAPI SerializePacket(int dir, PPBasketPacket * pPack, SBuffer & rBuf, SSerializeContext * pSCtx);
};

class PPBasketCombine {
public:
	SLAPI  PPBasketCombine()
	{
		BasketID = 0;
	}
	PPID   BasketID;
	PPBasketPacket Pack;
	PPObjGoodsBasket::Locking Lck;
};

class PPViewGoodsBasket {
public:
	enum {
		fHideCost = 0x0001
	};
	SLAPI  PPViewGoodsBasket(PPBasketPacket * pPacket);
	SLAPI ~PPViewGoodsBasket();
	int    SLAPI Init(int ord);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ILTI *);
	const  IterCounter & SLAPI GetIterCounter() const;
	int    SLAPI Print();
	const  PPBasketPacket * SLAPI GetPacket() const;
private:
	int    SLAPI CreateOrderTable();
	int    SLAPI Sort();
	IterCounter Counter;
	TempOrderTbl * P_OrdTbl;
	BExtQuery * P_IterQuery;
	PPBasketPacket * P_GBPacket;
	long   IterCount;
	long   NumIters;
	int    Order;
	long   Flags; // PPViewGoodsBasket::fXXX
};
//
// @ModuleDecl(PPViewGoodsTrnovr)
//
typedef GCTFilt GoodsTrnovrFilt;

struct GoodsTrnovrViewItem {
	union {
		LDATE  Dt;
		char   Title[12];
	};
	double RcptSuppl;
	double RcptIntr;
	double RetRetail;
	double RetClient;
	double RetSuppl;
	double XpndRetail;
	double XpndClient;
	double XpndIntr;
	double PayClient;
	double Income;
};

class PPViewGoodsTrnovr {
public:
	SLAPI  PPViewGoodsTrnovr();
	SLAPI ~PPViewGoodsTrnovr();
	const  GoodsTrnovrFilt * SLAPI GetFilt() const;
	int    SLAPI EditFilt(GoodsTrnovrFilt *);
	int    SLAPI Init(const GoodsTrnovrFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GoodsTrnovrViewItem *);
	int    SLAPI GetIterationCount(long *, long *);
	int    SLAPI ViewGrouping(LDATE);
	int    SLAPI Browse(int);
	int    SLAPI Print();
private:
	SArray * SLAPI CreateBrowserQuery();

	SArray * P_Items;
	GoodsTrnovrFilt Filt;
	IterCounter Cntr;
};
//
// Descr: План платежей
//   Отчет, рассчитывающий планируемые к оплате суммы, исходя из сроков
//   платежей по документам.
//
struct PaymPlanFilt : public PPBaseFilt {
	SLAPI  PaymPlanFilt();

	enum {
		fLabelOnly   = 0x0001,
		fCurrentDebt = 0x0002, // Долг контрагента по попадающим в интервал
		// документам ограничивать текущим долгом.
		// В противном случае долг рассчитывается на начало цикла.
		fDetail          = 0x0004,
		fCrosstab        = 0x0008,
		fDetailByBill    = 0x0010 // Детализация по документам (для каждого документа отдельная запись при вызове NextIteration)
	};
	char   ReserveStart[32]; // @anchor
	DateRange Period;
	PPCycleFilt Cycl;
	PPID   AccSheetID; // Таблица статей, к которой относятся долговые документы
	//                    if AccSheetID == 0 then AccSheetID = GetSellAccSheet()
	PPID   ObjectID;
	SubstGrpPerson Sgp;      // Подстановка персоналии
	long   Flags;            // PaymPlanFilt::fXXX
	PPID   AgentID;          // Агент по документу
	long   Reserve;          // @anchor
	ObjIdListFilt LocList;   // @v6.3.8
};

struct PaymPlanTotal {
	long   Count;
	double Amount;
	double Paym;
	double Debt;
};

struct PaymPlanViewItem {
	LDATE  Dt;         // Дата принадлежности к циклу
	LDATE  PayPlanDt;  // Дата предполагаемого платежа
	PPID   BillID;
	PPID   ObjID;
	char   Name[128];  //
	double Amount;
	double Paym;
	double Debt;
};

class PPViewPaymPlan : public PPView {
public:
	friend int IterProc_PPViewPaymPlan_ProcessPeriod(PayPlanTbl::Rec * pRec, long extraParam);

	struct BrwHdr {
		PPID   BillID;
		PPID   ObjID;
		LDATE  Dt;
	};
	SLAPI  PPViewPaymPlan();
	SLAPI ~PPViewPaymPlan();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt * pBaseFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PaymPlanViewItem *);
	void   SLAPI FormatCycle(LDATE, char * pBuf, size_t bufLen);
	int    SLAPI GetTabTitle(long tabID, SString & rBuf) const;
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int  SLAPI ViewTotal();
	int    SLAPI NextInnerIteration(PaymPlanViewItem * pItem);
	int    SLAPI GetBillList(PPID objID, LDATE dt, ObjIdListFilt * pBillList, RPairArray * pPaymList, int allowZeroPeriod);
	int    SLAPI GetEditIds(const void * pRow, LDATE * pDt, PPID * pObjID, long col);
	int    SLAPI ViewArticleInfo(const BrwHdr * pHdr, int what);

	IterCounter   InnerCounter;
	PPIDArray     BillList;
	RPairArray    PaymList;
	PPObjBill    * P_BObj;
	PPObjArticle ArObj;
	PPObjPerson  PsnObj;
	PPObjPerson::SubstParam Psp;
	PaymPlanFilt  Filt;
	PPCycleArray  CycleList;
	PaymPlanTotal Total;
	TempPaymPlanTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewSStat)
//   Статистика по продажам товаров
//
class SStatFilt : public PPBaseFilt {
public:
	SLAPI  SStatFilt();
	SStatFilt & FASTCALL operator = (const SStatFilt & s);
	int    SLAPI IsEqualExceptOrder(const SStatFilt *) const;
	void   SLAPI SetupCfgOptions(const PPPredictConfig & rCfg);
	int    SLAPI GetPckgUse() const;
	int    SLAPI GetPckgRounding() const;
	void   SLAPI SetPckgUse(int t);
	void   SLAPI SetPckgRounding(int t);

	enum {
		fSkipZeroNhCount   = 0x0001,
		fSupplOrderForm    = 0x0002,  // Отчет выводить в виде формы заказа поставщику
		fRoundOrderToPack  = 0x0004,  // Расчетный заказ округлять до емкости упаковки вверх
		fUseInsurStock     = 0x0008,  // При расчете заказа учитывать страховочный запас
		fExtByArCode       = 0x0010,  // Выборка товаров, по которым строится отчет ДОПОЛНЯЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
		fRestrictByArCode  = 0x0020,  // Выборка товаров, по которым строится отчет ОГРАНИЧИВАЕТСЯ //
			// теми товарами, которые имеют связанные с поставщиком SupplID коды (ArCodes).
			// Если SupplID == 0, то перебираются только те товары, которые имеют собственные коды.
		// @#{fExtByArCode^fRestrictByArCode}
		fOverrideCfgParams = 0x0040   // Поля _XXX переопределяют соответствующие
			// параметры конфигурации. Если флаг не установлен, то метод PPViewSStat::Init_
			// присваивает этим полям значения из конфигурации.
	};

	uint8  ReserveStart[16]; // @anchor
	//
	// Следующие 4 поля могут переопределять соотвествующие параметры конфигурации PPPredictConfig
	//
	long   _CFlags;          // PPPredictConfig::fXXX
	int16  _Method;          // PredictionMethod (PRMTHD_XXX)
	int16  _P;               // Количество последних точек, по которым строится прогноз
	int16  _TrustCriterion;  // Критерий надежности прогноза
	int16  _MinP;            // Минимальное количество точек, при которых прогноз еще считается надежным
	//
	int16  DefInsurStock;    // Минимальный запас по умолчанию (в днях)
	int16  UpRestriction;    // Если !0, то заказ рассчитывается только для тех позиций,
		// которые закончатся в течении заданного этим полем количества дней.
	DateRange Period;        //
	PPID   GoodsGrpID;       //
	PPID   SupplID;          // Поставщик
	SubstGrpGoods Sgg;       //
	LDATE  RestDate;         // Дата расчета остатков
	PPCycleFilt Cycl;        // Группирующие циклы
	int16  OrdTerm;          // Период заказа товара
	int16  DlvrTerm;         // Период доставки заказа от поставщика
	long   Order;            // PPViewSStat::IterOrder
	long   Flags;            //
	RealRange CountRange;    // Количество точек
	RealRange QttyAvgRange;  // Средние продажи в кол-ом выражении
	RealRange AmtAvgRange;   // Средние продажи в суммовом выражении
	RealRange QttyVarRange;  // Коэффициент вариации
	ObjIdListFilt LocList;   // @anchor
};

struct SStatViewItem {
	PPID   GoodsID;
	char   GoodsName[128]; // @v7.0.0 [64]-->[128]
	LDATE  Dt;             // Если фильтр определяет группировку по циклам, то дата начала цикла, иначе - 0
	long   Count;
	double QttySum;
	double QttyAvg;
	double QttySigma;
	double QttyVar;
	double QttyTrnovr;
	double AmtSum;
	double AmtAvg;
	double AmtSigma;
	double AmtVar;
	double AmtTrnovr;
	LDATE  LastCalcDate;
	double Rest;           // Остаток товара (только если Filt.Flags & fSupplOrderForm)
	double Predict;        // Прогноз продаж (только если Filt.Flags & fSupplOrderForm)
	double SupplOrder;     // Расчетный заказ (только если Filt.Flags & fSupplOrderForm)
	double MinStock;       // Минимальный запас (только если Filt.Flags & SStatFilt::fUseInsurStock)
	double PriceAvg;       // Средняя цена
	double CostAvg;        // @v7.1.7 Средняя цена поступления позиции
	int16  IsPredictTrust; // @v7.0.0 Признак надежности прогноза (только для формы заказа поставщику)
	int16  Reserve;        // @v7.0.0 @alignment
};

struct SStatTotal {
	long   LinesCount;     // Количество строк в выборке
	long   Count;          // Общее количество элементов продаж по всей выборке
	double Qtty;           // Общее количество проданных торговых единиц
	double Amount;         // Общая сумма продаж
	long   OrderCount;     // Суммарное количество строк, предлагаемых к заказу
	double OrderQtty;      // Суммарное количество торговых единиц, предлагаемых к заказу
	double OrderAmount;    // Ценовая сумма товаров, предлагаемых к заказу
	double OrderCost;      // @v7.1.7 Сумма товаров, предлагаемых к заказу с ценах поступления //
	long   UncertCount;    // Количество недостоверных элементов
};

class PPViewSStat : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByCount,
		OrdByQttyAvg,
		OrdByQttyVar,
		OrdByAmtAvg,
		OrdByAmtVar,
		OrdByPriceAvg,
		OrdByQttyAvgCount
	};
	//static int SLAPI CreateDraftBySupplOrders(const SStatFilt * pFilt);
	SLAPI  PPViewSStat();
	SLAPI ~PPViewSStat();
	//
	// Descr: Создает новый экземпляр фильтра.
	//   Инициализируется следующее:
	//     1. в список складов устанавливается текущий склад (если не ноль)
	//     2. устанавливается флаг SStatFilt::fSkipZeroNhCount
	//     3. если extraParam & 0x0001 (форма расчета заказа поставщику), то устанавливаются флаги
	//        (SStatFilt::fSupplOrderForm | SStatFilt::fRoundOrderToPack)
	//
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SStatViewItem *);
	int    SLAPI GetItem(PPID goodsID, SStatViewItem * pItem);
	int    SLAPI GetRestItem(PPID goodsID, const ObjIdListFilt * pLocList, GoodsRestViewItem *);
	int    SLAPI ConvertLinesToBasket();
	int    SLAPI CreatePurchaseBill(LDATE docDt, int autoOrder, PPBillPacket * pPack, int useTa);
	int    SLAPI EditOrder(PPID ctID, PPID goodsID);

	int    SLAPI CellStyleFunc_(const void * pData, long col, int paintAction, BrowserWindow::CellStyle * pStyle, PPViewBrowser * pBrw);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int  SLAPI Print(const void *);
	virtual int  SLAPI ViewTotal();
	int    SLAPI CalcTotal(SStatTotal * pTotal);
	void   SLAPI RecToViewItem(const TempGoodsStatTbl::Rec * pRec, SStatViewItem * pItem);
	int    SLAPI EditDlvrOrderFilt(SStatFilt *);
	int    SLAPI CreateTempTable(int use_ta);
	int    SLAPI CreateOrderTable(long ord, TempOrderTbl ** ppTbl, int use_ta);
	int    SLAPI AddStat(PPID goodsID, LDATE, int setTotal, const PredictSalesStat *, BExtInsert *);
	int    SLAPI AddStatByCycles(PPID goodsID, const PPIDArray * pIdList, int setTotal, BExtInsert *, PredictSalesStat *);
	int    SLAPI CalcOrder(double prediction, double minStock, const GoodsRestViewItem * pItem, double * pOrder);
	int    SLAPI AddPurchaseBill();
	int    SLAPI ViewCreatedBills();

	SStatFilt Filt;
	TempGoodsStatTbl * P_TempTbl;
	TempOrderTbl * P_TempOrd;
	PPViewGoodsRest * P_VGr;
	PredictSalesCore PsT;
	PPObjGoods GObj;
	GoodsSubstList Gsl;
	PPCycleArray CycleList;
	PPPredictConfig PrCfg;
	PPIDArray CreatedBillList; // Список документов, созданных из отчета для просмотра и экспорта
};
//
//
//
#define PPINETCONN_DIRECT    0
#define PPINETCONN_PRECONFIG 1
#define PPINETCONN_PROXY     2

struct PPInetConnConfig {  // @persistent @store(PropertyTbl)
	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_INETCONNCFG
	char   Agent[48];
	char   ProxyHost[48];
	char   ProxyPort[10];
	long   MaxTries;
	long   AccessType;
	long   Flags;
	char   Reserve[126];
	char   URLDir[64];
};
//
// @ModuleDecl(PPViewOprKind)
//
#define OPKF_USERANK 0x80000000L // Используется при сортировке массива с данными

struct OprKindFilt : public PPBaseFilt {
	SLAPI  OprKindFilt();

	enum {
		sortByName     = 1,
		sortByTypeName = 2
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   OpTypeID;
	PPID   LinkOpID;
	PPID   AccSheetID;
	long   Flags;
	long   SortOrd;
	long   Reserve;          // @anchor
};

struct OprKindBrwItem {
	PPID   ID;
	char   Name[48];
	char   Symb[20];
	char   AccSheet[48];
	char   OpType[48];
	char   FlagsMnems[32];
	int16  Rank;
	int16  Reserve;        // @alignment
};

struct OprKindViewItem : public OprKindBrwItem {
	char   Template[84];
};

class PPViewOprKind : public PPView {
public:
	SLAPI  PPViewOprKind();
	SLAPI ~PPViewOprKind();
	virtual int SLAPI Init_(const PPBaseFilt * pBaseFilt);
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pBaseFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(OprKindViewItem *);
	//int    SLAPI EditFilt(OprKindFilt *);
	/*const  OprKindFilt * SLAPI GetFilt() const
	{
		return &Filt;
	}*/
	int    SLAPI CreateFlagsMnemonics(const PPOprKind * pOdData, char * pBuf, size_t bufSize);
	//SArray * SLAPI CreateBrowserArray();
	//int    SLAPI EditOp(PPID * pOpID);
	//int    SLAPI AddItem();
	//int    SLAPI EditItem(PPID);
	//int    SLAPI DeleteItem(PPID);
	int    SLAPI AddBySample(PPID sampleID);
	int    SLAPI ViewLinkOps(PPID opID);
	int    SLAPI ViewBills(PPID opID);
	//int    SLAPI Browse(int modeless);
	//int    SLAPI Print();
	int    SLAPI Transmit(PPID id);
private:
	int    SLAPI InnerIteration(OprKindViewItem * pItem);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI OnExecBrowser(PPViewBrowser *);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);

	uint   OpListIdx;
	uint   TmplsIdx;
	SArray * P_OpList;
	PPAccTurnTemplArray ATTmpls;
	OprKindFilt  Filt;
	PPObjOprKind OpkObj;
	//IterCounter  Counter;
};
//
// @ModuleDecl(PPObjMrpTab)
//
// Специальные значения поля SrcID таблицы MrpLine
//
#define MRPSRCV_TOTAL  0 // Полное итоговое требование на DestReqQtty единиц товара DestID
#define MRPSRCV_DEP   -1 // Итоговое зависимое требование на DestReqQtty единиц товара DestID
#define MRPSRCV_INDEP -2 // Итоговое независимое требование на DestReqQtty единиц товара DestID
//
// Флаги записей MrpTabTbl::Rec
//
#define MRPTF_SUBST         0x0001L // Таблица замещения одного товара другим
	// Таблица замещения обязательно имеет ссылку (ParentID) на ту таблицу, в
	// которой осуществляет замещение. Если основная таблица имеет потомков, то
	// замещающая таблица - одна для всего дерева и крепится к корневой таблице.
	// Все строки замещающей таблицы имеют признак MRPLF_SUBST
//
// Флаги записей MrpLineTbl::Rec
//
#define MRPLF_TERMINAL      0x0001L // Терминальная строки (товар DestID не может быть скомплектован)
#define MRPLF_REST          0x0002L // Остаток по строке рассчитан
#define MRPLF_SUBST         0x0004L // Замещающий элемент таблицы
#define MRPLF_REPLACED      0x0008L // К элементу таблицы применена операция замещения //
#define MRPLF_UNLIM         0x0010L // Товар, с которым связана строка, является нелимитируемым
#define MRPLF_IGNOREREST    0x0020L // @v9.1.7 По строке не следует учитывать доступный остаток (строка комплектуется независимо от остатка)

struct MrpReqItem {
	SLAPI  MrpReqItem(PPID goodsID, long flags, double req, double price);
	PPID   GoodsID;
	long   Flags;   // @v9.1.7 MRPLF_XXX
	double Req;
	double Price;
};

class MrpReqArray : public TSArray <MrpReqItem> {
public:
	SLAPI  MrpReqArray();
	int    SLAPI Add(PPID goodsID, long flags, double req, double price);
};

class MrpTabCore : public MrpTabTbl {
public:
	SLAPI  MrpTabCore();
	int    SLAPI Search(PPID, MrpTabTbl::Rec * = 0);
	int    SLAPI SearchByLink(PPID objType, PPID objID, PPID locID, LDATE dt, MrpTabTbl::Rec * pRec);
	int    SLAPI SearchLine(PPID tabID, PPID destID, PPID srcID, MrpLineTbl::Rec * pRec);
	int    SLAPI SearchLineByID(PPID lineID, MrpLineTbl::Rec * pRec);
	int    SLAPI GetTotalLine(PPID tabID, PPID goodsID, MrpLineTbl::Rec *);
	int    SLAPI GetSubList(PPID tabID, PPIDArray *);
	int    SLAPI GetParentID(PPID tabID, PPID * pParentID);
	int    SLAPI EnumLinesByDest(PPID id, PPID destID, PPID * pSrcID, MrpLineTbl::Rec *);
	int    SLAPI EnumLinesBySrc(PPID id, PPID srcID, PPID * pDestID, MrpLineTbl::Rec *);
	int    SLAPI GetSrcList(PPID tabID, PPID destID, RAssocArray *);
	int    SLAPI GetDestList(PPID tabID, PPID srcID, int minusSrcReq, MrpReqArray * pList);
	int    SLAPI IsTerminalGoods(PPID tabID, PPID goodsID); // @>>MrpTabCore::IsGoodsFlagged
	int    SLAPI IsReplacedGoods(PPID tabID, PPID goodsID); // @>>MrpTabCore::IsGoodsFlagged
	//
	// Descr: Извлекает из таблицы tabID список дефицитных позиций
	// ARG(tabID    IN): ИД таблицы, по которое необходимо получить список дефицитных позиций
	// ARG(terminal IN): Фильтрующий параметр, допускающий следующие значения:
	//   -1 - извлекать дефицит только по НЕТЕРМИНАЛЬНЫМ (non-terminal) позициям
	//    0 - не обращать внимание на признак терминальности
	//   +1 - извлекать дефицит только по ТЕРМИНАЛЬНЫМ (terminal) позициям
	// ARG(replacePassiveGoods IN): Если !0, то дефицитная позиция, если она является обобщенным
	//   или пассивным товаром, по возможности замещается первым встретившемся для подстановки
	//   компонентом (который также не является пассивным или обобщенным). Компоненты для подстановки
	//   определяются функцией PPObjGoods::GetSubstList().
	// ARG(pList   OUT): Массив, в который добавляются позиции по таблице tabID
	//   Функция не очищает содержимое этого массива, по-этому, полседовательный вызов
	//   функции позволяет получить итоговый дефицит по списку таблиц
	// Returns:
	//   >0 - в список была занесена информация по крайней мере по одной дефицитной позиции
	//   <0 - список pList остался неизменным - по затребованным условиям таблица
	//        дефицита не содержит
	//   0  - ошибка
	//
	int    SLAPI GetDeficitList_(PPID tabID, PPID srcID, int terminal, int replacePassiveGoods, PUGL * pList);
	int    SLAPI GetSubst(PPID tabID, GoodsReplacementArray * pGra);
	int    SLAPI GetDependencyList(PPID tabID, PPID destGoodsID, PUGL * pList);
	int    SLAPI Create(PPID * pID, const MrpTabTbl::Rec * pRec, int use_ta);
	int    SLAPI Update(PPID id, const MrpTabTbl::Rec * pRec, int use_ta);
	int    SLAPI AddLine(PPID id, PPID destID, PPID srcID,
		double destReqQtty, double srcReqQtty, double price, long flags, int use_ta);
	int    SLAPI AddCTab(const CMrpTab *, int use_ta);
	//
	// Descr: Устанавливает значения остатка и дефицита для товара destID
	//   в таблице tabID в соответствии с параметром pVal.
	//   Если указатель pVal == 0, то считает что товар destID является нелимитируемым ресурсом,
	//   соответственно, дефицит отсутствует.
	//
	int    SLAPI SetRest(PPID id, PPID destID, const GoodsRestVal * pVal, double * pDeficit, int use_ta);
		// @<<PPObjMrpTab::SetupRest
	int    SLAPI SetSubstRest(PPID id, PPID destID, PPID srcID,
		const GoodsRestVal * pVal, double ratio, double * pDeficit, int use_ta);
	int    SLAPI RemoveSubst(PPID tabID, PPID destID, PPID srcID, int use_ta);
	int    SLAPI RemoveLines(PPID, int use_ta);
	int    SLAPI Remove(PPID, int use_ta);
	int    SLAPI Aggregate(PPID destTabID, PPID srcTabID, int use_ta);
		// @<<MrpTabPacket::Aggregate

	MrpLineTbl Lines;
private:
	int    SLAPI Helper_GetDeficit(const MrpLineTbl::Rec & rRec, int terminal, int replacePassiveGoods, PUGL * pList);
	int    SLAPI SetFlag(PPID tabID, PPID destID, PPID srcID, long flag, int set, int use_ta);
	int    SLAPI IsGoodsFlagged(PPID tabID, PPID goodsID, long flag);
};
//
// Descr: Массив, кэширующий MRP-таблицу на этапе формирования требований
//   по товарам и расчета зависимых требований.
//
class CMrpTab : public SArray {
public:
	struct Row { // Size=40
		PPID   TabID;
		PPID   DestID;
		PPID   SrcID;
		double DestReq;
		double SrcReq;   // Если SrdID == 0, то здесь хранится доступный остаток товара DestID
			// При развертывании структур используется требуемое количество (DestReq-SrcReq)
		int16  Flags;    // MRPLF_XXX
		int16  Pad;      // @alignment
		double Price;
	};
	SLAPI  CMrpTab();
	Row  & FASTCALL at(uint i) const;
	void   SLAPI Sort();
	int    SLAPI Search(PPID tabID, PPID destID, PPID srcID, uint * pPos, CMrpTab::Row * pRow) const;
	int    SLAPI Add__(PPID tabID, PPID destID, PPID srcID, double destReqQtty, double srcReqQtty, double price, /*int term*/long flags);
	int    SLAPI SetRest(PPID tabID, PPID destID, double rest);
	int    SLAPI Aggregate(PPID destTabID); // @<<MrpTabPacket::Aggregate
	int    SLAPI SetFlag(PPID tabID, PPID destID, PPID srcID, long flag, int set);
};

struct MrpTabLeaf {
	PPID   TabID;
	PPID   LocID;
	LDATE  Dt;
};

class MrpTabPacket : public TSArray <MrpTabLeaf> {
public:
	SLAPI  MrpTabPacket();
	MrpTabPacket & FASTCALL operator = (const MrpTabPacket &);
	void   SLAPI Init(PPID objType, PPID objID, const char * pName);
	void   SLAPI Destroy();
	int    SLAPI IsTree() const;
	const  char * SLAPI GetName() const;
	PPID   SLAPI GetBaseID() const;
	void   FASTCALL SetBaseID(PPID);
	int    SLAPI GetTabID(PPID locID, LDATE dt, PPID * pTabID) const;
	int    FASTCALL AddLeaf(const MrpTabTbl::Rec *);
	void   SLAPI CreateLeafRec(PPID locID, LDATE dt, MrpTabTbl::Rec & rRec) const;
	int    SLAPI GetLeaf(PPID tabID, MrpTabLeaf *) const;
	int    SLAPI GetList(PPIDArray *) const;
	//
	// Descr: Сортирует листья пакета в следующем порядке: {TabID, Dt, LocID}
	//
	void   SLAPI Sort(); // @>>SArray::sort
	//
	// Descr: Для внутреннего использования. Сортирует элементы Cache для ускорения поиска.
	//
	void   SLAPI SortCache();
	//
	// Descr: Определяет общие характеристики дерева таблиц:
	//   список складов, начальную и конечную даты.
	//   Предварительно очищает список pLocList и присваивает периоду pPeriod
	//   значения pPeriod->low = MAXDATE, pPeriod->upp = ZERODATE
	//
	void   SLAPI GetCommonParam(PPIDArray * pLocList, DateRange * pPeriod) const; // @<<PPObjMrpTab::FinishPacket
	int    SLAPI AddLine__(PPID tabID, PPID destID, PPID srcID, double destReq, double srcReq, double price, long flags/*int term*/);
	int    SLAPI SetTerminal(PPID tabID, PPID destID, int terminal);
	int    SLAPI IsTerminal(PPID tabID, PPID destID) const;
	int    SLAPI GetDestList(PPID tabID, PPID srcID, int minusSrcReq, MrpReqArray *) const;
	int    SLAPI ProcessReq(const MrpTabLeaf * pLeaf, const MrpReqItem & rReq, double * pExtReq, int dep, long cflags /* PPObjMrpTab::cfXXX */);
	int    SLAPI Aggregate();
	int    SLAPI Flash(MrpTabCore *, int use_ta);
	int    SLAPI GetAvailGoodsRest(PPID goodsID, const MrpTabLeaf * pLeaf, double * pRest) const;
	//
	// Descr: Извлекает список терминальных позиций из кэша по идентификаторму tabID
	//
	int    SLAPI GetCTerminalList(PPID tabID, CMrpTab & rList) const;
private:
	CMrpTab Cache;
	PPID   ObjType;
	PPID   ObjID;
	PPID   BaseID;
	char   Name[48];
};

struct PPMrpTabConfig {    // @persistent @store(PropertyTbl)
	PPID   Tag;             // Const=PPOBJ_CONFIG
	PPID   ID;              // Const=PPCFG_MAIN
	PPID   Prop;            // Const=PPPRP_MRPTABCFG
	long   Counter;
	long   Flags;
	char   Reserve[64];
};

class PPObjMrpTab : public PPObject {
public:
	//
	// Descr: Флаги формирования таблиц
	//
	enum {
		cfIgnoreRest = 0x0001 // Не рассчитывать остатки (считать, что доступный остаток нулевой)
	};

	static int  SLAPI ReadConfig(PPMrpTabConfig *);
	static int  SLAPI GetCounter(long * pCounter, int use_ta);
	static void SLAPI GenerateName(PPID linkObjType, PPID linkObjID, SString *, int use_ta);
	static int  SLAPI GetAvailGoodsRest(PPID goodsID, const MrpTabLeaf * pLeaf, LDATE afterDate, double * pRest);

	SLAPI  PPObjMrpTab(void * extraPtr = 0);
	SLAPI ~PPObjMrpTab();
	virtual int  SLAPI Search(PPID, void * = 0);
	virtual int  SLAPI Browse(void * extraPtr);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI DeleteObj(PPID id);
	//
	// Descr: Проверяет запись pRec на соответствие фильтру pFilt. Если pRec == 0,
	//   то запись извлекается по идентификатору id из базы данных (функцией PPObjMrpTab::Search).
	//   Если запись по этому идентификатору не найдена, то возвращается 0.
	// Returns:
	//   >0 - запись pRec (или та, что соответствует идентификатору id) удовлетворяет фильтру pFilt.
	//        Если pFilt == 0, то всегда возвращается (>0), то есть, отсутвтующему фильтру удовлетворяет
	//        любая запись.
	//   0 - запись не удовлетворяет фильтру pFilt. Если pRec == 0 и запись по идентификатору id не
	//       нейдена, также возвращается 0 (несуществующая запись не удовлетворяет ни каким условиям).
	//
	int    SLAPI CheckForFilt(const MrpTabFilt * pFilt, PPID id, MrpTabTbl::Rec * pRec);
	int    SLAPI EditDialog(MrpTabTbl::Rec *);
	int    SLAPI CreateByGoods(PPID * pID, const char * pName, PPID goodsID, PPID locID, LDATE, int use_ta);
	int    SLAPI CreateByBill(PPID * pID, const char * pName, PPID billID, int use_ta);
	int    SLAPI CreateByDraftWrOff(PPID * pID, const char * pName, PPID dwoID, PPID locID, LDATE, int use_ta);
	int    SLAPI LoadPacket(PPID tabID, MrpTabPacket *);
	int    SLAPI DestroyPacket(MrpTabPacket *, int use_ta);
	int    SLAPI GetTabID(MrpTabPacket *, PPID locID, LDATE dt, PPID * pTabID, int use_ta);
	int    SLAPI AddIndep(MrpTabPacket *, PPID tabID, PPID goodsID, double req, double price, int ignoreRest);
	int    SLAPI FinishPacket(MrpTabPacket * pPack, long cflags /* PPObjMrpTab::cfXXX */, int use_ta);
	int    SLAPI GetDeficitList(const MrpTabPacket * pPack, PPID srcID, int terminal, int replacePassiveGoods, PUGL * pList);
		// @>>MrpTabCore::GetDeficitList
	//
	// Descr: инициализирует комбо-бокс ctlID в диалоге dlg списком типов связанных
	//   объектов. В списке перечисляются только те объекты, с которыми может быть связана
	//   запись в таблице MrpTab
	//
	static int SLAPI SetupLinkObjTypeCombo(TDialog * dlg, uint ctlID, PPID initObjType);
		// @>>SetupObjListCombo
	int    SLAPI CreateModif(const MrpTabLeaf * pMrpLeaf, PPID mrpSrcID, PPID opID, PPIDArray * pBillList, PPLogger *, int use_ta);
	int    SLAPI DoMaintain(LDATE toDt);
		// @>>DoDBMaintain
private:
	virtual const char * SLAPI GetNamePtr();
	int    SLAPI CreateTreeLeaf(MrpTabPacket * pTree, PPID locID, LDATE dt, PPID * pTabID);
	int    SLAPI Helper_ExpandReq(MrpTabPacket *, const MrpTabLeaf *, const MrpReqItem & rReq, int dep, long cflags, PPIDArray * pRecurTrace);
	int    SLAPI ExpandReq(MrpTabPacket * pPack, const MrpTabLeaf * pLeaf, long cflags);
	int    SLAPI SetupRest(const MrpTabPacket * pPack, const MrpTabLeaf * pLeaf, long cflags, int use_ta); // @>>MrpTabCore::SetRest
	int    SLAPI ArrangePugl(PPID tabID, PUGL * pSrc, uint pos, PUGL * pDest);
		// @recursion, @<<PPObjMrpTab::CreateModif
public:
	TLP_MEMB(MrpTabCore, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewMrpTab)
//
struct MrpTabFilt : public PPBaseFilt {
	enum {
		fSkipChilds = 0x0001 // Исключаются таблицы, имеющие ненулевого родителя.
			// Этот флаг игнорируется если MrpTabFilt::ParentID != 0
	};
	SLAPI  MrpTabFilt();

	uint8  ReserveStart[32]; // @anchor
	PPID   ParentID;
	PPID   LinkObjType;
	PPID   LinkObjID;
	PPID   LocID;
	DateRange Period;
	long   Flags;
	PPID   SingleID;
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef MrpTabTbl::Rec MrpTabViewItem;

class PPViewMrpTab : public PPView {
public:
	SLAPI  PPViewMrpTab();
	SLAPI ~PPViewMrpTab();
	virtual int SLAPI EditBaseFilt(PPBaseFilt * pBaseFilt);
	virtual int SLAPI Init_(const PPBaseFilt * pBaseFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(MrpTabViewItem *);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	//int    SLAPI ChangeFilt(int refreshOnly, BrowserWindow *);
	int    SLAPI UpdateTempTable(PPID);

	MrpTabFilt Filt;
	PPObjMrpTab MrpObj;
	TempOrderTbl * P_TempOrd;
};
//
// @ModuleDecl(PPViewMrpLine)
//
struct MrpLineFilt : public PPBaseFilt {
	SLAPI  MrpLineFilt();
	enum {
		fShowTotalReq     = 0x0001, // Показывать только итоговые потребности
			// (MrpLine.SrcGoodsID == MRPSRCV_TOTAL)
		fShowDeficitOnly  = 0x0002, // Показывать только дефицитные позиции
		fShowTerminalOnly = 0x0004, // Показывать только терминальные строки
		fShowSubst        = 0x0008  // @v4.8.6 Показывать замещения по товару DestGoodsID
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   TabID;            // ->MrpTab.ID
	PPID   DestGoodsID;      // ->Goods2.ID
	PPID   SrcGoodsID;       // ->Goods2.ID || MRPSRCV_XXX
	long   Flags;
	//
	// Если DestGoodsID != 0, то показывается выборка
	// (TabID == Filt.TabID && DestID == Filt.DestGoodID && SrcID == Filt.SrcGoodsID),
	// Иначе (TabID == Filt.TabID && SrcID == Filt.SrcGoodsID)
	//
	long   Reserve;          // @anchor Заглушка для отмера "плоского" участка фильтра
};

typedef MrpLineTbl::Rec MrpLineViewItem;

struct MrpLineTotal {
	long   Count;       // Общее количество позиций
	long   TermCount;   // Количество терминальных позиций
	long   DfctCount;   // Количество дефицитных позиций
	double ReqQtty;     // Требуемое количество
	double Deficit;     // Дефицит
	double Cost;        // Сумма в ценах поступления //
	double Price;       // Сумма в ценах реализации  //
};

class PPViewMrpLine : public PPView {
public:
	enum IterOrder {
		OrdByDefault = 0,
		OrdByGoodsName,
		OrdByReq,
		OrdByDeficit
	};
	SLAPI  PPViewMrpLine();
	SLAPI ~PPViewMrpLine();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(MrpLineViewItem *);
	int    SLAPI CalcTotal(MrpLineTotal *);
	int    SLAPI GetItem(PPID lineID, MrpLineViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int  SLAPI ViewTotal();
	virtual int  SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI CreateOrderTable(IterOrder ord, TempOrderTbl ** ppTbl);
	int    SLAPI ChangeFilt(int refreshOnly, BrowserWindow *);

	MrpLineFilt Filt;
	PPObjMrpTab MrpObj;
	TempOrderTbl * P_TempOrd;
};
//
// @ModuleDef(PPObjDraftCreateRule)
// AHTOXA {
//
#define PPDFCRRULE_ONLYGROUPS -1L // показывать только группы, передается как extra для selector'а
#define PPDFCRRULE_ONLYRULES  -2L // показывать только правила, передается как extra для selector'а

struct PPDraftCreateRule2 {  // @persistent @store(Reference2Tbl+)
	enum PriceAlgoritm {  // агоритм образования цены реализации
		pByLastLot   = 1, // из последнего лота
		pByAvgSum    = 2, // среднее по выборке чеков
		pByAvgSumDis = 3, // среднее по выборке чеков минус скидка
		pByQuot        = 4, // по котировке
		pByCostPctVal  = 5 // из цены поступления плюс некоторый процент
	};
    enum CostAlgoritm {      // алгоритм образования цены поступлени
		cByLastLot      = 1, // из последнего лота
		cByPricePctVal  = 2, // из цены реализации минус некоторый процент
		cByQuot         = 3  // по котировке
	};
	enum {
		fExclGoodsGrp     = 0x0001,
		fIsRulesGroup     = 0x0002,
		fWoSCard          = 0x0004,
		fOnlyBanking      = 0x0008,
		fOnlyNotBanking   = 0x0010,
		fExcludeSCardSer  = 0x0020,
		fUseGoodsLocAssoc = 0x0040
	};
	PPID   Tag;            // Const=PPOBJ_DFCREATERULE
	PPID   ID;             // @id
	char   Name[48];       // @offse(28) @name @!refname
	char   Symb[20];       //
	char   Reserve[12];    // @reserve
	PPID   OpID;           // ->Ref(PPOBJ_OPRKIND)
	PPID   ArID;           // ->Article.ID
	PPID   AgentID;        // ->Article.ID
	PPID   GoodsGrpID;     // ->Goods2.ID
	PPID   CQuot;          // ->Ref(PPOBJ_QUOTKIND)
	PPID   PQuot;          // ->Ref(PPOBJ_QUOTKIND)
	int16  CostAlg;        //
	int16  PriceAlg;       //
	float  CPctVal;        //
	float  PPctVal;        //
	double MaxSum;         //
	long   MaxPos;         //
	long   Flags;          //
	PPID   ParentID;       //
	PPID   SCardSerID;     //
};

DECL_REF_REC(PPDraftCreateRule);

class PPDfCreateRulePacket {
public:
	SLAPI  PPDfCreateRulePacket();
	int    SLAPI Init();
	int    SLAPI GetCashNN(SString * pBuf, int delim = ',') const;
	int    SLAPI GetCashNN(PPIDArray * pAry) const;
	int    SLAPI SetCashNN(const char * pBuf, int delim = ',');
	int    SLAPI SetCashNN(const PPIDArray * pAry);
	int    SLAPI CheckCash(PPID cash) const;

	PPDraftCreateRule Rec;
private:
	PPIDArray CashNN;
};

class PPObjDraftCreateRule : public PPObjReference {
public:
	SLAPI  PPObjDraftCreateRule(void * extraPtr = 0);
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI GetPacket(PPID, PPDfCreateRulePacket *);
	int    SLAPI PutPacket(PPID *, PPDfCreateRulePacket *, int use_ta);
	int    SLAPI GetRules(PPID ruleGrpID, PPIDArray * pRules);
};
// } AHTOXA
//
// @ModuleDecl(PrcssrWrOffDraft)
//
class PrcssrWrOffDraftFilt : public PPBaseFilt {
public:
	SLAPI  PrcssrWrOffDraftFilt();

	enum {
		fCreateMrpTab = 0x0001
	};
	uint8  ReserveStart[32]; // @anchor
	DateRange Period;
	PPID   DwoID;
	PPID   PoolLocID;
	long   Flags;
	SString MrpTabName;      // @anchor
	PPIDArray CSessList;     // @v6.7.3 Список кассовых сессий, по которым надо списать документы.
		// Если список не пуст, то поле Period игнорируется.
};

class PrcssrWrOffDraft {
public:
	SLAPI  PrcssrWrOffDraft();
	int    SLAPI InitParam(PrcssrWrOffDraftFilt *);
	int    SLAPI EditParam(PrcssrWrOffDraftFilt *);
	int    SLAPI Init(const PrcssrWrOffDraftFilt *);
	int    SLAPI Run();
private:
	int    SLAPI WriteOff(const PPDraftWrOffPacket * pPack,
		PPIDArray * pWrOffBillList, PPIDArray * pDfctList, PUGL * pPugl, PPID * pErrBillID, int use_ta);
		// @<<PrcssrWrOffDraft::Run
	int    SLAPI UniteToPool(PPID poolOpID, const PPIDArray *, int use_ta);
	int    SLAPI ProcessDeficit(const PPDraftWrOffPacket *, const PUGL * pPugl, int use_ta);
	int    SLAPI CreateMrpTab(const PPDraftWrOffPacket *, PPID * pMrpTabID, MrpTabPacket *, int use_ta);
	int    SLAPI GetWrOffBillList(const PPDraftWrOffEntry *, PPIDArray * pDfctList, PPIDArray *);
	int    SLAPI GetWrOffBillList(const PPDraftWrOffPacket *, PPIDArray * pDfctList, PPIDArray *);
		// @>>PrcssrWrOffDraft::GetWrOffBillList(const PPDraftWrOffEntry *, PPIDArray *, PPIDArray *);
	int    SLAPI ArrangeBillList(PPIDArray * pList);
	int    SLAPI WriteOffMrp(const PPDraftWrOffPacket *, PUGL *);

	PrcssrWrOffDraftFilt P;
	PPObjBill * P_BObj;
	PPObjDraftWrOff DwoObj;
	PPObjOprKind OpObj;
	PPObjMrpTab MrpObj;
	PPLogger Logger;
};
//
// @ModuleDecl(PPObjRFIDDevice)
//
struct PPRFIDDevice {      // @persistent @store(Reference2Tbl+)
	long   Tag;            // Const=PPOBJ_RFIDDEV
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // @symb
	char   Port[16];
	long   Flags;          //
	long   ProtocolVer;
	CommPortParams Cpp;    // Size=6 (default cbr=57600, StopBits=1, Parity=none, DataBits=8)
	uint16 Reserve;        // @alignment
	uint16 Get_NumTries;
	uint16 Get_Timeout;
	uint16 Put_NumTries;
	uint16 Put_Timeout;
	uint8  ReleCount;
	long   GoodsID;
	uint8  Reserve2[19];
	long   DeviceNumber;
	long   Reserve3;
};

class PPObjRFIDDevice : public PPObjReference {
public:
	SLAPI  PPObjRFIDDevice(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int  SLAPI Browse(void * extraPtr);
	int    SLAPI Test(const PPRFIDDevice & rRec, SString & rRetBuf);
	//int SLAPI PPObjRFIDDevice::ExecOper(PPAbstractDevice * pDvc, int cmd, StrAssocArray & rIn, StrAssocArray & rOut); // @vmiller
};
//
// @ModuleDecl(PPObjGenericDevice)
//
struct PPGenericDevice {   // @persistent @store(Reference2Tbl+)
	SLAPI  PPGenericDevice();

	long   Tag;            // Const=PPOBJ_GENERICDEVICE
	long   ID;             // @id
	char   Name[48];       // @name
	char   Symb[20];       // @symb
	uint8  Reserve[60];
	long   Flags;
	long   DeviceClass;
	long   Reserve2;
};

#define GENDVCEXSTR_ENTRY    1
#define GENDVCEXSTR_PORT     2
#define GENDVCEXSTR_INITSTR  3

class PPGenericDevicePacket {
public:
	SLAPI  PPGenericDevicePacket();
	int    SLAPI GetExtStrData(int fldID, SString & rBuf) const;
	int    SLAPI PutExtStrData(int fldID, const char *);

	PPGenericDevice Rec;
	SString ExtString;
};

class PPObjGenericDevice : public PPObjReference {
public:
	//
	// Для селекторов в качестве extraParam передается класс устройства (или 0 для выбора устройства любого класса).
	//
	SLAPI  PPObjGenericDevice(void * extraPtr = 0);
	virtual int  SLAPI Edit(PPID * pID, void * extraPtr);
	int    SLAPI PutPacket(PPID * pID, PPGenericDevicePacket * pPack, int use_ta);
	int    SLAPI GetPacket(PPID id, PPGenericDevicePacket * pPack);
	int    SLAPI Test(const PPGenericDevice & rRec, SString & rRetBuf);
private:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
};
//
// @ModuleDecl(PPObjProject)
//

#define PRJCFGF_NEWTASKNOTICE        0x0001
#define PRJCFGF_NEWTASKNOTICEONLOGIN 0x0002
#define PRJCFGF_INCOMPLETETASKREMIND 0x0004
#define PRJCFGF_VALID                0x0008L  // @transient @v8.0.2 Запись инициализирована

struct PPProjectConfig {   // @persistent @store(PropertyTbl) @size=90
	PPProjectConfig();
	PPProjectConfig & Clear();

	PPID   Tag;            // Const=PPOBJ_CONFIG
	PPID   ID;             // Const=PPCFG_MAIN
	PPID   Prop;           // Const=PPPRP_PROJECTCFG
	PPID   PrjCntrID;      // ->Ref(PPOBJ_OPCOUNTER)
	PPID   PhaseCntrID;    // ->Ref(PPOBJ_OPCOUNTER)
	PPID   TaskCntrID;     // ->Ref(PPOBJ_OPCOUNTER)
	PPID   TemplCntrID;    // ->Ref(PPOBJ_OPCOUNTER)
	int16  NewTaskTerm;    // Количество дней с даты создания, в течении которых задача
		// имеет признак "Новая" (TODOSTTS_NEW). После этого срока задача переводистя в статус
		// "В ожидании" (TODOSTTS_ONHOLD). Если NewTaskTerm == 0, то задача автоматически
		// не теряет статус TODOSTTS_NEW.
		// Отсчет дней идет с текущей системной даты
	int16  RejTaskTerm;    // Количество дней с даты начала исполнения (StartDt), в течении которых задача
		// остатется актуальной (имеет один из статусов: TODOSTTS_NEW, TODOSTTS_ONHOLD, TODOSTTS_INPROGRESS)
		// После этого периода задача переводится в статус "Отменена" (TODOSTTS_REJECTED).
		// Если StartDt == 0, то отсчет начинается с даты создания (Dt)
		// Если RejTaskTerm == 0, то задача автоматически не переводится в статус TODOSTTS_REJECTED.
		// Отсчет дней идет с текущей системной даты
	int16  TemplGenTerm;   // Период (в днях) на который следует сгенерировать задачи по шаблонам
		// при вызове функции обслуживания задач.
		// Отсчет дней идет с текущей системной даты
	char   Text[38];       //
	long   Flags;          // PRGCFGF_XXX
	long   WorkHoursBeg;   //
	long   WorkHoursEnd;   //
	int16  RefreshTime;    //
	PPID   BillOpID;       //
	IntRange RemindPrd;    // @v6.4.15 AHTOXA Период напоминания о не выполненных задачах [-x..y]
};

//
// Виды записей таблицы ProjectTbl (Kind)
//
#define PPPRJK_PROJECT       1L // Проект
#define PPPRJK_PHASE         2L // Фаза
#define PPPRJK_PRJTEMPLATE   3L // Шаблон проекта
#define PPPRJK_PHSTEMPLATE   4L // Шаблон фазы
//
// Статусы проектов
//
#define PPPRJSTS_ACTIVE      1L // Проект/фаза в активной стадии работы
#define PPPRJSTS_NONACTIVE   2L // Проект/фаза завершен
#define PPPRJSTS_ARCHIVED    3L // Архивированный проект (только для проектов)

class PPObjProject : public PPObject {
public:
	static int SLAPI ReadConfig(PPProjectConfig *);
	static int SLAPI EditConfig();
	static int SLAPI FetchConfig(PPProjectConfig * pCfg); // @v8.0.2
	static int SLAPI DirtyConfig();                       // @v8.0.2

	static SString & SLAPI MakeCodeString(const ProjectTbl::Rec * pRec, SString & rBuf);

	SLAPI  PPObjProject(void * extraPtr = 0);
	SLAPI ~PPObjProject();
	virtual int    SLAPI Search(PPID id, void * b = 0);
	virtual int    SLAPI Browse(void * extraPtr);
	//
	// Если параметр parentPrjID != 0 and *pID == 0, это означает, что
	// необходимо создать элемент типа Phase.
	//
	virtual int    SLAPI Edit(PPID * pID, void * extraPtr/* parentPrjID */);
	virtual int    SLAPI DeleteObj(PPID id);
	int    SLAPI InitPacket(ProjectTbl::Rec *, int kind /* PPPRJK_XXX */, PPID parentID, int use_ta);
	int    SLAPI PutPacket(PPID * pID, ProjectTbl::Rec *, int use_ta);
	int    SLAPI GetFullName(PPID id, SString & rBuf);
private:
	virtual const char * SLAPI GetNamePtr();
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr /*parentPrjID*/);
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	//virtual int    SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	SString NameBuf;
public:
	TLP_MEMB(ProjectTbl, P_Tbl);
	void * ExtraPtr;
};
//
// @ModuleDecl(PPViewProject)
//
struct ProjectFilt : public PPBaseFilt {
	SLAPI  ProjectFilt();

	enum {
		fShowNonActive = 0x0001,
		fShowArchived  = 0x0002,
		fPrintPrjTasks = 0x0004
	};
	enum {
		ordByName = 0,
		ordByBegDt
	};
	char   ReserveStart[32];   // @anchor
	PPID   ParentID;
	DateRange StartPeriod;
	DateRange EstFinishPeriod;
	PPID   ClientID;
	PPID   MngrID;
	long   Flags;
	long   SortOrd;
	long   Reserve;            // @anchor
};

struct ProjectViewItem : public ProjectTbl::Rec {
	PPID   PrjTaskID; // Для иерархической печати проект-фазы-задачи
};

class PPViewProject : public PPView {
public:
	SLAPI  PPViewProject();
	SLAPI ~PPViewProject();
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ProjectViewItem *);
	int    SLAPI InitPrjTaskIterations(PPID prjID);
private:
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI ViewTotal();
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI Export();
	int    SLAPI Transmit(PPID);
	int    SLAPI PrintProjectTasks(PPID prjID);
	PPViewPrjTask * P_PrjTaskView;
	ProjectFilt Filt;
	PPObjProject PrjObj;
};
//
//
//
#define TODOF_OPENEDBYEMPL       0x0001 // Исполнитель видел задачу
#define TODOF_ACTIONVIEWED       0x0002 // @transient В журнал выводить
	// событие исполнитель видел задачу, вместо - объект изменен

#define PRJTASKRT_MULTCHANGE     0x0100

#define PRJTASKBIAS_CLIENT       0x20000000L
#define PRJTASKBIAS_EMPLOYER     0x40000000L
#define PRJTASKBIAS_TEMPLATE     0x80000000L

#define TODOPSN_CREATOR          1
#define TODOPSN_EMPLOYER         2
#define TODOPSN_CLIENT           3

class PPObjPrjTask : public PPObject {
public:
	static SString & SLAPI GetStatusText(int statusId, SString &);
	static SString & SLAPI GetPriorText(int priorId, SString &);
	static int SLAPI ImportFromVCal();
	//
	// Descr: восстанавливает CreatorID, EmployerID, ClientID если такой персоналии не существует
	//
	static int SLAPI RecoverAbsencePerson();

	SLAPI  PPObjPrjTask(void * extraPtr = 0);
	SLAPI ~PPObjPrjTask();
	virtual int SLAPI Search(PPID id, void * b = 0);
	virtual int SLAPI Browse(void * extraPtr);
	//
	// Descr: интерактивная функция редактирования новой или существующей задачи.
	// ARG(pID     IN/OUT): указатель на ИД редактируемой записи. Если *pID == 0, то создается новая запись.
	//   Если *pID != 0, то извлекается запись с этим идентификатором и редактируется.
	// ARG(parentPrjID IN): актуально только в случае, если *pID == 0.
	//   Если (parentPrjID & 0x7fffffff) != 0, то новая запись создается в привязке к
	//   проекту (фазе проекта) с таким идентификатором.
	//   Если parentPrjID & 0x80000000, то создается запись шаблона задачи.
	//
	virtual int SLAPI Edit(PPID * pID, void * extraPtr);
	virtual int SLAPI DeleteObj(PPID id);
	virtual int SLAPI EditRights(uint bufSize, ObjRights * buf, EmbedDialog * pDlg = 0);
	int    SLAPI InitPacket(PrjTaskTbl::Rec *, int kind /* TODOKIND_XXX */, PPID prjID, PPID clientID, PPID employerID, int use_ta);
	int    SLAPI InitPacketByTemplate(const PrjTaskTbl::Rec * pTemplRec, LDATE startDt, PrjTaskTbl::Rec * pRec, int use_ta);
	int    SLAPI AddBySample(PPID * pID, PPID sampleID);
	int    SLAPI PutPacket(PPID * pID, PrjTaskTbl::Rec * pRec, int use_ta);
	int    SLAPI GetPacket(PPID id, PrjTaskTbl::Rec * pRec);
	int    SLAPI CreateByTemplate(PPID templID, const DateRange * pPeriod, PPIDArray * pIdList, int use_ta);
	//
	// Descr: Осуществляет функции обслуживания базы данных задач:
	//   - Изменение статусов, согласно конфигурации PPProjectConfig
	//   - Формирование задач по шаблонам, имеющим статус отличный от TODOSTTS_REJECTED
	//     Задачи по шаблона формируются на период [curdate..curdate+PPProjectConfig::TemplGenTerm-1]
	//
	int    SLAPI Maintain(); // @nointeract @ta
	int    SLAPI GetLinkTasks(PPID taskID, PPIDArray * pAry);
	int    SLAPI EditDialog(PrjTaskTbl::Rec *);
private:
	virtual StrAssocArray * SLAPI MakeStrAssocList(void * extraPtr);
	virtual const char * SLAPI GetNamePtr();
	virtual int  SLAPI Read(PPObjPack *, PPID, void * stream, ObjTransmContext *);
	virtual int  SLAPI Write(PPObjPack *, PPID *, void * stream, ObjTransmContext *);
	virtual int  SLAPI ProcessObjRefs(PPObjPack *, PPObjIDArray *, int replace, ObjTransmContext * pCtx);
	virtual int  SLAPI HandleMsg(int, PPID, PPID, void * extraPtr);
	int    SLAPI SubstDescr(PrjTaskTbl::Rec *);
	int    SLAPI DetermineNewStatus(const PPProjectConfig * pCfg, const PrjTaskTbl::Rec * pRec, int * pNewStatus);
	int    SLAPI ResolveAbsencePersonHelper_(PPID newID, PPID prevID, int todoPerson);
public:
	TLP_MEMB(PrjTaskCore, P_Tbl);
	void * ExtraPtr;
	PPID   LinkTaskID;
};
//
// @ModuleDecl(PPViewPrjTask)
//
struct PrjTaskFilt : public PPBaseFilt {
public:
	SLAPI  PrjTaskFilt();
	virtual int SLAPI Init(int fullyDestroy, long extraData);
	int    SLAPI IncludeStatus(long status);
	int    SLAPI ExcludeStatus(long status);
	int    SLAPI IncludePrior(long prior);
	int    SLAPI ExcludePrior(long prior);

	int    SLAPI GetStatusList(PPIDArray *) const;
	int    SLAPI GetPriorList(PPIDArray *) const;
	SString & SLAPI GetStatusListText(SString &) const;
	SString & SLAPI GetPriorListText(SString &) const;
	//
	char   ReserveStart[32];   // @anchor
	enum EnumOrder {
		// Строки, соответствующие порядку сортировки перечислены в PPTXT_TODOORDER
		ordByDefault = 0,
		ordByDt,
		ordByStartDt,
		ordByEstFinishDt,
		ordByFinishDt,
		ordByCreator,
		ordByEmployer,
		ordByClient,
		ordByCode
	} Order;
	enum EnumTabType {
		// Строки, соответствующие кросстабу перечислены в PPTXT_TODOCROSSTAB
		crstNone = 0,
		crstDateHour,
		crstClientDate,
		crstEmployerDate,
		crstClientEmployer,
		crstEmployerHour,
	} TabType;
	enum EnumTabParam {
		ctpNone           = 0,
		ctpUnComplTask    = 1,
		ctpComplTaskRatio = 2,
		ctpWrofBillPrct   = 3,
		ctpTaskCount      = 4
	} TabParam;
	enum {
		fUnbindedOnly         = 0x0001, // Показывать только задачи, не привязанные к проектам
		fUnviewedOnly         = 0x0002, // Показывать только те задачи, которые не были кем-либо просмотрены
		fUnviewedEmployerOnly = 0x0004, // Показывать только те задачи, которые не были просмотрены исполнителем
		fNotShowPPWaitOnInit  = 0x0008, // Не выдавать сообщение "Подождите" в PPViewPrjTask::Init()
		fNoTempTable          = 0x0010  // @v8.5.11 Не строить временную таблицу
	};
	long   Kind;               // TODOKIND_XXX
	PPID   ProjectID;          // ->Project.ID Проект, к которому привязана задача
	PPID   ClientID;           // ->Person.ID  Клиент
	PPID   EmployerID;         // ->Person.ID  Исполнитель
	PPID   TemplateID;         // ->PrjTask.ID (Kind=TODOKIND_TEMPLATE)
	PPID   CreatorID;          // ->Person.ID  Персоналия, создавшая задачу
	PPID   CliCityID;          // ->City.ID Город клиента
	PPID   LinkTaskID;         // ->PrjTask.LinkTaskID Связанная задача.
		// Если != 0, Kind = TODOKIND_TASK, другие поля фильтра не используютс
	int16  PriorList[10];      // TODOPRIOR_XXX Список приоритетов, по которым необходимо получить выборку
	int16  StatusList[10];     // TODOSTTS_XXX  Список статусов, по которым необходимо получить выборку
	DateRange Period;          //
	DateRange StartPeriod;     //
	DateRange EstFinishPeriod; //
	DateRange FinishPeriod;    //
	long   Flags;              //
		// @<< PPViewPrjTask::ViewCrosstabDetail
	LTIME  StartTmPeriodBeg;   // период начала выполнения задани
	LTIME  StartTmPeriodEnd;   // используется только для построения детализации кросстаба
	SubstGrpDate Sgd;          //
	long   Reserve;            // @anchor Заглушка для отмера "плоского" участка фильтра
private:
	int    SLAPI InclInList(int16 * pList, size_t listSize, int16 val);
	int    SLAPI ExclFromList(int16 * pList, size_t listSize, int16, int16, int16 val);
	int    SLAPI GetList(const int16 * pList, size_t listSize, PPIDArray *) const;
};

typedef PrjTaskTbl::Rec PrjTaskViewItem;

class PPViewPrjTask : public PPView {
public:
	SLAPI  PPViewPrjTask();
	SLAPI ~PPViewPrjTask();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PrjTaskViewItem *);
	int    SLAPI GetItem(PPID id, PrjTaskViewItem * pItem);
	int    SLAPI GetTabTitle(PPID tabID, SString & rBuf);
	int    SLAPI ChangeTasks(PPIDArray *);
	int    SLAPI GetTimeGridItemText(PPID taskID, SString & rBuf);
	int    SLAPI EditTimeGridItem(PPID * pID, PPID rowID, const LDATETIME & rDtm);
private:
	virtual int   SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int   SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int   SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int   SLAPI ViewTotal();
	virtual int   SLAPI Print(const void *);
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI ViewCrosstabDetail(PPID tabID, const DBFieldList * pFldList);
	int    SLAPI MakeTempEntry(const PrjTaskTbl::Rec * pRec, TempOrderTbl::Rec * pTempRec);
	int    SLAPI CheckRecForFilt(const PrjTaskTbl::Rec * pRec);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList, int use_ta);
	int    SLAPI Export();
	int    SLAPI CreateByTemplate();
	int    SLAPI PutRecToTempTable(PPID tabID, int taskNotFinished, long tabType, PrjTaskTbl::Rec *);
	int    SLAPI SearchTempRec(PPID tabID, long tabType, void * pAddInfo, TempPrjTaskTbl::Rec * pRec);
	int    SLAPI Transmit(PPID, int kind);
	int    SLAPI NextOuterIteration();
	int    SLAPI NextInnerIteration(PrjTaskViewItem *);
	int    SLAPI AddItemToTimeGrid(const PrjTaskViewItem *, int rmv);
	int    SLAPI TimeChunkBrowser();
	int    SLAPI UpdateTimeBrowser(int destroy);

	PrjTaskViewItem Item;
	PrjTaskFilt Filt;
	PPObjPrjTask TodoObj;
	PPObjPerson PsnObj;
	int    UndefPriorList;
	int    UndefStatusList;
	PPIDArray PriorList;
	PPIDArray StatusList;
	TempOrderTbl   * P_TempOrd;
	TempPrjTaskTbl * P_TempTbl;
	PPIDArray UpdateTaskList;
	//
	class PrjTaskTimeChunkGrid : public STimeChunkGrid {
	public:
		SLAPI  PrjTaskTimeChunkGrid();
		SLAPI ~PrjTaskTimeChunkGrid();
		virtual int GetText(int item, long id, SString & rBuf);
		virtual int Edit(int item, long rowID, const LDATETIME & rTm, long * pID);
		virtual int MoveChunk(int mode, long id, long rowId, const STimeChunk & rNewChunk);
		//
		PPViewPrjTask * P_View; // @notowned
	};
	PrjTaskTimeChunkGrid Grid;
	ObjIdListFilt CreatorList;
	ObjIdListFilt EmployerList;
	ObjIdListFilt ClientList;
};
//
// @ModuleDecl(PPViewPriceAnlz)
//
class PriceAnlzFilt : public PPBaseFilt {
public:
	SLAPI  PriceAnlzFilt();
	PriceAnlzFilt & FASTCALL operator = (const PriceAnlzFilt & s);
	enum {
		fShowDiffAsPrc             = 0x00000001,
		fExclWOCntrCost            = 0x00000002,
		fExclWOCostOREqualBaseCost = 0x00000004,
		fDivideBySuppl             = 0x00000008
	};
	//
	// Правило расчета фактической цены
	//
	enum {
		caByFirstLot,      // По первому лоту
		caByAverageLot,    // Средняя по лотам
		caByLastLot,       // По последнему лоту
		caByMinLot,        // Минимальная по лотам
		caByMinLoc         // Минимальная по складам (по последним лотам до конца периода)
	};
	//
	// Правило расчета базовой цены
	//
	enum {
		bcByLoc,           // По лотам
		bcByContract,      // По контрактной цене
		bcByAvgLocs,       // Средняя по складам
		bcByPrevLot        // По предыдущему лоту
	};
	char   ReserveStart[32]; // @anchor
	long   CostAlg;        // Правило расчета фактической цены
	long   BaseCost;       // Правило расчета базовой цены
	PPID   SupplID;
	PPID   GoodsGrpID;
	DateRange Period;
	long   Flags;
	PPID   BaseLoc;
	ObjIdListFilt LocList; // @anchor
};

typedef TempPriceAnlzTbl::Rec PriceAnlzViewItem;

class PPViewPriceAnlz : public PPView {
public:
	SLAPI  PPViewPriceAnlz();
	SLAPI ~PPViewPriceAnlz();
	virtual PPBaseFilt * CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PriceAnlzViewItem *);
	int    SLAPI GetTabTitle(PPID tabID, SString & rBuf);
private:
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI SetContractPrices();

	PriceAnlzFilt Filt;
	PPObjGoods    GObj;
	TempPriceAnlzTbl * P_TempTbl;
};
//
// @ModuleDecl(PPViewReport)
//
class ReportFilt : public PPBaseFilt {
public:
	SLAPI  ReportFilt();
	enum {
		fShowObjects  = 0x0001
	};
	enum {
		rpttAll = 0,
		rpttStandart,
		rpttLocal
	};
	enum {
		ordByName = 1,
		ordByType,
		ordByStruc
	};

	char   ReserveStart[24];
	DateRange Period;
	long   Type;
	long   Order;
	SString StdName;
	SString StrucName;
};

typedef TempReportTbl::Rec ReportViewItem;
typedef TSArray <ReportViewItem> ReportViewItemArray;

class PPViewReport : public PPView {
public:
	struct BrwHdr {
		long ID;
	};

	SLAPI  PPViewReport();
	SLAPI ~PPViewReport();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);

	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ReportViewItem *);
	int    SLAPI SaveChanges(int remove);
	int    SLAPI CreateStdRptList(ReportViewItemArray *);
	int    SLAPI CreateRptList(ReportViewItemArray *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);

	int    SLAPI MakeTempRec(const ReportViewItem *, TempReportTbl::Rec *);
	int    SLAPI CheckForFilt(const ReportViewItem *);
	int    SLAPI EditItem(PPID * pID);
	int    SLAPI DelItem(PPID);
	int    SLAPI SendMail(long id);
	int    SLAPI Verify(long id);
	int    SLAPI CallCR(long id);
	int    SLAPI GetAltPath(long type, const char * pPath, const char * pStdName, SString & rPath);
	int    SLAPI SplitLocalRptStr(PPIniFile * pFile, int codepage, SString & rSect, SString & rBuf, ReportViewItem * pItem);

	int     LocalRptCodepage;
	SString SystemSect;
	SString CodepageParam;
	SString FmtParam;
	SString DestParam;
	SString SilentParam;
	SString DataParam;
	SString DescrParam;
	SString ModifDtParam;

	ReportFilt      Filt;
	PPIniFile       * P_StdRptFile;
	PPIniFile       * P_RptFile;
	TempReportTbl * P_TempTbl;
};
//
//
//
class PersonRelFilt : public PPBaseFilt {
public:
	SLAPI  PersonRelFilt();
	PersonRelFilt & FASTCALL operator = (const PersonRelFilt &);

	enum {
		psnfByPrmrPerson = 1,
		psnfByScndPerson
	};

	enum {
		ordByPrmrPerson = 1,
		ordByScndPerson,
		ordByRelationType
	};
	enum {
		fApplyPsnFiltToScnd  = 0x0001,
		fAddedSelectorByPrmr = 0x0002,
		fAddedSelectorByScnd = 0x0004
			// @#{fAddedSelectorByPrmr^fAddedSelectorByScnd)
	};
	char   ReserveStart[32];      // @anchor
	long   Flags;
	long   SortOrd;
	PPID   RelTypeID;
	PPID   PrmrPersonID;
	PPID   ScndPersonID;
	PersonFilt * P_PsnFilt;       // @anchor
};

struct PersonRelViewItem {
	PPID   ID;
	PPID   PrmrPersonID;
	PPID   ScndPersonID;
	PPID   RelTypeID;
	char   RelName[48];
};

class PPViewPersonRel : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
		PPID   PrmrPersonID;
    	PPID   ScndPersonID;
		PPID   RelTypeID;
	};
	SLAPI  PPViewPersonRel();
	SLAPI ~PPViewPersonRel();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PersonRelViewItem *);
	int    SLAPI CheckForFilt(const PersonCore::RelationRecord * pRec);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI OnExecBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(PPID prmrID, PPIDArray * pScndList, PPID relation, int reverse);
	int    SLAPI CreateOrderTable(long ord, TempOrderTbl ** ppTbl);
	int    SLAPI MakeTempEntry(const PersonCore::RelationRecord * pRec, TempPersonRelTbl::Rec * pTempRec);
	int    SLAPI MakeTempOrdEntry(long ord, TempPersonRelTbl::Rec * pTempRec, TempOrderTbl::Rec * pOrdRec);
	int    SLAPI ViewReverseRelations(PPID personID);

	PersonRelFilt Filt;
	ObjIdListFilt PersonList;
	PPObjPerson   PsnObj;
	UintHashTable PrmrList; // Список первичных персоналий, попавших в выборку
	UintHashTable ScndList; // Список вторичных персоналий, попавших в выборку
	TempPersonRelTbl * P_TempTbl;
	TempOrderTbl     * P_TempOrd;
};
//
//
//
class ObjLikenessFilt : public PPBaseFilt {
public:
	SLAPI  ObjLikenessFilt();
	ObjLikenessFilt & FASTCALL operator = (const ObjLikenessFilt &);

	char   ReserveStart[32]; // @anchor
	PPID   ObjTypeID;
	double Rate;
	long   Reserve;          // @anchor
};

typedef ObjLikenessTbl::Rec ObjLikenessViewItem;

class PPViewObjLikeness : public PPView {
public:
	struct BrwHdr {
		PPID   ObjType;
		PPID   ID1;
    	PPID   ID2;
	};

	static int SLAPI CreateLikenessTable();

	SLAPI  PPViewObjLikeness();
	SLAPI ~PPViewObjLikeness();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ObjLikenessViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Print(const void *);
	int    SLAPI UniteObjects(PPID objType, PPID srcID, PPID destID);

	ObjLikenessFilt Filt;
	PPObjPerson     PsnObj;
	PPObjGoods      GObj;
	ObjLikenessTbl  Tbl;
};
//
//
//
class ScaleFilt : public PPBaseFilt {
public:
	enum {
		protAll   = 0,
		protTcpIp = 1,
		protCom   = 2
	};

	SLAPI  ScaleFilt();
	ScaleFilt & FASTCALL operator = (const ScaleFilt &);

	char   ReserveStart[24];
	char   Reserve[24];
	PPID   LocID;
	PPID   ScaleTypeID;
	PPID   AltGoodsGrpID;
	long   Protocol;
	PPID   GroupID;         // @v6.x.x. AHTOXA
	long   Flags;           // SCALF_XXX // @v6.x.x. AHTOXA
	long   ReserveEnd;
};

typedef PPScale ScaleViewItem;

class PPViewScale : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewScale();
	SLAPI ~PPViewScale();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);

	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(ScaleViewItem *);
	int    SLAPI CheckScaleStatus(PPID scaleID, int statusFromList);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList);
	int    SLAPI MakeTempEntry(const PPScale * pRec, TempScaleTbl::Rec * pTempRec);
	int    SLAPI CheckForFilt(const PPScale * pRec) const;

	LAssocArray  ScaleStatusList;
	SString      ScaleTypeNames;
	ScaleFilt    Filt;
	PPObjScale   ObjScale;
	TempScaleTbl * P_TempTbl;
};
//
//
//
struct BudgetFilt : public PPBaseFilt {
	BudgetFilt();

	virtual int SLAPI Init(int fullyDestroy, long extraData);
	BudgetFilt & FASTCALL operator = (const BudgetFilt & s);

	enum {
		kBudget      = 0,
		kBudgetItems = 1
	};

	uint8     ReserveStart[32]; // @anchor
	PPID      BudgetID;
	PPID      ParentAcctID;
	long      ParentKind;
	LDATE     ParentDt;
	DateRange Period;
	uint16    Kind;
	long      Reserve;
};

struct BudgetViewItem {
	PPBudget Budget;
	BudgetItemTbl::Rec Item;
};

class PPViewBudget : public PPView {
public:
	struct Hdr {
		PPID  ID;
		PPID  AccID;
		LDATE Dt;
		long  Kind;
	};
	SLAPI  PPViewBudget();
	SLAPI ~PPViewBudget();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BudgetViewItem *);
	int    SLAPI ViewTotal();
	int    SLAPI GetTabTitle(long tabID, SString & rBuf);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual void * SLAPI GetEditExtraParam();
	virtual int   SLAPI Detail(const void *, PPViewBrowser * pBrw);
	virtual int   SLAPI Print(const void *);
	virtual int   SLAPI OnExecBrowser(PPViewBrowser * pBrw);

	int    SLAPI GetEditIds(const void * pRow, Hdr * pHdr, long col);
	int    SLAPI UpdateTempTable(PPIDArray & rIdList);
	int    SLAPI MakeTempRec(void * pRec, void * pTempRec);
	int    SLAPI CheckForFilt(void * pRec);

	PPID               UpdateID;
	BudgetFilt         Filt;
	PPObjAccount       ObjAcct;
	PPObjBudget        ObjBudg;
	TempBudgetTbl    * P_TempBudgTbl;
	TempBudgItemTbl  * P_TempBudgItemTbl;
};
//
// PPViewBizScTempl
//
class BizScTemplFilt : public PPBaseFilt {
public:
	BizScTemplFilt();
	BizScTemplFilt & operator=(const BizScTemplFilt &);

	long ReserveStart;
	long Flags;
	char ReserveEnd[32];
};

typedef PPBizScTempl BizScTemplViewItem;

class PPViewBizScTempl : public PPView {
public:
	SLAPI  PPViewBizScTempl();
	SLAPI ~PPViewBizScTempl();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BizScTemplViewItem * pItem);
private:
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);

	int SLAPI UpdateTempTable(PPID id);
	int SLAPI MakeTempRec(const PPBizScTempl * pInRec, TempBizScTemplTbl::Rec * pOutRec);
	int SLAPI CheckIDForFilt(PPID id, PPBizScTempl * pRec);

	BizScTemplFilt      Filt;
	PPObjBizScTempl     Obj;
	TempBizScTemplTbl * P_TempTbl;
};
//
// PPViewBizScValByTempl
//
struct BizScValByTemplViewItem {
	BizScValByTemplViewItem();
	~BizScValByTemplViewItem();
	BizScValByTemplViewItem & FASTCALL operator = (const BizScValByTemplViewItem & rSrc);

	long   Id;
	char   Name[32];
	char * P_Vals;
};

class BizScValByTemplFilt : public PPBaseFilt {
public:
	BizScValByTemplFilt();
	BizScValByTemplFilt & FASTCALL operator = (const BizScValByTemplFilt &);

	long   ReserveStart;
	PPID   TemplateID;
	char   ReserveEnd[32];
};


class PPViewBizScValByTempl : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};

	SLAPI  PPViewBizScValByTempl();
	SLAPI ~PPViewBizScValByTempl();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(BizScValByTemplViewItem *);
private:
	static int SLAPI GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI FetchData();
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI CheckForFilt(const PPAmountTypePacket * pPack) const;

	TSCollection<BizScValByTemplViewItem> Data;
	BizScValByTemplFilt Filt;
	PPBizScTemplPacket  Pack;
	PPObjBizScTempl     BizScTObj;
	BizScoreCore        BizScTbl;
};
//
// PPViewCheckOpJrnlFilt
//
class CheckOpJrnl : public CheckOpJrnlTbl {
public:
	SLAPI  CheckOpJrnl(CCheckCore * pCc);
	SLAPI ~CheckOpJrnl();
	int    SLAPI LogEvent(int16 action, const CCheckPacket * pPack, const CCheckLineTbl::Rec * pLineRec, int useTa);
	int    SLAPI Search(LDATE dt, LTIME tm, CheckOpJrnlTbl::Rec * pRec);
	// int    SLAPI GetEvent(PPID action, int mode, LDATETIME * pDtm, int maxDays, CheckOpJrnlTbl::Rec * pRec = 0);
	// int    SLAPI GetLastEvent(PPID action, LDATETIME * pDtm, int maxDays, CheckOpJrnlTbl::Rec * = 0);
	// int    SLAPI GetLastUserEvent(PPID action, PPID userID, PPID sessID, const DateRange * pSrchPeriod, LDATETIME *, void * = 0);
private:
	CCheckCore * P_Cc; // @notowned
};

class CheckOpJrnlFilt : public PPBaseFilt {
public:
	CheckOpJrnlFilt();
	virtual int IsEmpty() const;

	char   ReserveStart[32];
	PPID   UserID;
	PPID   AgentID;
	DateRange Period;
	LTIME  BegTm;
	PPIDArray ActionIDList;
};

typedef CheckOpJrnlTbl::Rec CheckOpJrnlViewItem;

class PPViewCheckOpJrnl : public PPView {
public:
	struct BrwHdr {
		LDATE  Dt;
		LTIME  Tm;
		int16  Action;
	};
	SLAPI  PPViewCheckOpJrnl();
	SLAPI ~PPViewCheckOpJrnl();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int  SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int  SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(CheckOpJrnlViewItem *);
	int    FASTCALL CheckRecForFilt(const CheckOpJrnlTbl::Rec * pRec);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Print(const void *);

	CheckOpJrnlFilt Filt;
	CCheckCore CC;
	CheckOpJrnl * P_Tbl;
	PPObjGoods GObj;
};
//
//
//
class CashNodeFilt : public PPBaseFilt {
public:
	enum {
		sAll       = 0,
		sOnlySync  = 1,
		sOnlyASync = 2
	};

	SLAPI  CashNodeFilt();
	CashNodeFilt & FASTCALL operator = (const CashNodeFilt &);

	char   ReserveStart[24];
	char   Reserve[24];
	PPID   CashTypeID;        // Тип ККМ (PPCMT_XXX)
	PPID   LocID;
	int16  SyncType;
	int16  Reserve2;
	long   ReserveEnd;
};

typedef PPCashNode CashNodeViewItem;

class PPViewCashNode : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewCashNode();
	SLAPI ~PPViewCashNode();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(CashNodeViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList);
	int    SLAPI MakeTempEntry(const PPCashNode * pRec, TempCashNodeTbl::Rec * pTempRec);
	int    SLAPI CheckForFilt(const PPCashNode * pRec) const;
	int    SLAPI ExecCPanel(uint ppvCmd, PPID cashID);

	SString         CashTypeNames;
	CashNodeFilt    Filt;
	PPObjCashNode   ObjCashN;
	TempCashNodeTbl * P_TempTbl;
};
//
//
//
class PalmFilt : public PPBaseFilt {
public:
	enum {
		devtAll        = 0,
		devtOnlyGroups = 1,
		devtOnlyDevs   = 2
	};

	SLAPI  PalmFilt();
	PalmFilt & FASTCALL operator = (const PalmFilt &);

	char   ReserveStart[24];
	PPID   GroupID;
	PPID   GoodsGrpID;
	PPID   OrderOpID;
	PPID   AgentID;
	PPID   FTPAcctID;
	int16  Type;
	int16  Reserve;
	long   ReserveEnd;
	ObjIdListFilt LocList;
};

struct PalmViewItem : public PPStyloPalm {
	char   Path[MAXPATH];
	char   FtpPath[MAXPATH];
};

class PPViewPalm : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewPalm();
	SLAPI ~PPViewPalm();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PalmViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList);
	int    SLAPI MakeTempEntry(const PPStyloPalmPacket & rPack, TempPalmTbl::Rec * pTempRec);
	int    SLAPI CheckForFilt(const PPStyloPalm * pRec);
	int    SLAPI ExportUhtt();

	PalmFilt        Filt;
	PPObjStyloPalm  ObjPalm;
	TempPalmTbl   * P_TempTbl;
};
//
//
//
struct ServerStatViewItem {
	uint32 TId;
	int32  Kind;
	int32  State;
	LDATETIME StartMoment;
	char   Text[256];
	char   LastMsg[512];
};

class ServerStatFilt : public PPBaseFilt {
public:
	SLAPI  ServerStatFilt();
	ServerStatFilt & FASTCALL operator = (const ServerStatFilt &);

	char   ReserveStart[32]; // @anchor
	long   Flags;
	uint32 RefreshTime;
	SString ServerAddr;     // @anchor
};

class PPViewServerStat : public PPView {
public:
	SLAPI  PPViewServerStat();
	SLAPI ~PPViewServerStat();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	//int    SLAPI InitIteration();
	//int    FASTCALL NextIteration(ServerStatViewItem *);
private:
	static int GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI StopThread(long tid);
	int    SLAPI ResetCache();

	int    SLAPI FetchStat();
	SArray Data;
	ServerStatFilt Filt;
};
//
// PPViewTransport
//
typedef PPTransport TransportViewItem;

class TransportFilt : public PPBaseFilt {
public:
	SLAPI  TransportFilt();
	int    SLAPI InitInstance();
	int    SLAPI IsEmpty() const;
	virtual int SLAPI Describe(long flags, SString & rBuf) const;

	char   ReserveStart[32];
	long   TrType;
	PPID   ModelID;
	PPID   OwnerID;
	PPID   CaptainID;
	PPID   CountryID;
	SString Code;
	SString TrailCode;
};

class PPViewTransport : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	SLAPI  PPViewTransport();
	SLAPI ~PPViewTransport();
	virtual PPBaseFilt * SLAPI CreateFilt(void * extraPtr) const;
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration(int aOrder = 0);
	int    FASTCALL NextIteration(TransportViewItem *);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	int    SLAPI IsTempTblNeeded();
	int    SLAPI CheckForFilt(TransportFilt * pFilt, PPID transpID, PPTransport * pRec);
	int    SLAPI MakeTempRec(const PPTransport * pTranspRec, TempTransportTbl::Rec * pTempRec);
	int    SLAPI UpdateTempTable(PPID transpID, PPViewBrowser * pBrw);
	int    SLAPI ViewTotal();
	int    SLAPI DeleteItem(PPID id);
	int    SLAPI Transmit(PPID);

	TransportFilt  Filt;
	PPObjTransport TObj;
	TempTransportTbl * P_TempTbl;
};
//
// PPViewAmountType
//
class AmountTypeFilt : public PPBaseFilt {
public:
	SLAPI  AmountTypeFilt();
	AmountTypeFilt & FASTCALL operator = (const AmountTypeFilt &);
	int    SLAPI IsComplementary() const;

	char   ReserveStart[24];
	long   Flags;
	PPID   RefAmtTypeID;
	PPID   TaxID;
	long   ReserveEnd;
};

struct AmountTypeViewItem {
	int32  ID;
	int32  RefAmtTypeID;
	int32  Flags;
	int32  Tax;
	double TaxRate;
	char   Formula[256];
};

class PPViewAmountType : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewAmountType();
	SLAPI ~PPViewAmountType();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(AmountTypeViewItem *);
private:
	static int SLAPI GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	int    SLAPI FetchData(long id);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI MakeListEntry(const PPAmountTypePacket * pPack, AmountTypeViewItem * pItem);
	int    SLAPI CheckForFilt(const PPAmountTypePacket * pPack) const;
	int    SLAPI Transmit(int isCharry);

	SArray            Data;
	AmountTypeFilt    Filt;
	PPObjAmountType   ObjAmtT;
};
//
// PPViewRegisterType
//
struct RegTypeViewItem {
	int32  ID;
	int32  RegOrgKind;
	int32  PersonKindID;
	int32  ExpiryPrd;
	char   Format[256];
};

class RegisterTypeFilt : public PPBaseFilt {
public:
	SLAPI  RegisterTypeFilt();
	RegisterTypeFilt & FASTCALL operator = (const RegisterTypeFilt &);

	char   ReserveStart[24];
	PPID   RegOrgKind;
	PPID   PersonKindID;
	long   St;
	long   ReserveEnd;
};

class PPViewRegisterType : public PPView {
public:
	struct BrwHdr {
		PPID   ID;
	};
	SLAPI  PPViewRegisterType();
	SLAPI ~PPViewRegisterType();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(RegTypeViewItem *);
private:
	static int GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI FetchData(long id);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI MakeListEntry(const PPRegisterTypePacket * pPack, RegTypeViewItem * pItem);
	int    SLAPI CheckForFilt(const PPRegisterTypePacket * pPack) const;
	int    SLAPI Transmit(int isCharry);

	RegisterTypeFilt  Filt;
	PPObjRegisterType ObjRegT;
	SArray Data;
};
//
// @ModuleDecl(PPViewDialog)
//
class DialogFilt : public PPBaseFilt {
public:
	DialogFilt();

	uint8  ReserveStart[64]; // @anchor
	long   Flags;
	uint8  ReserveEnd[32];   // @anchor
	SString DlFileName;
	SString Serial;
	SString SubText;
};

struct DialogViewItem {
	long   Id;
	char   Symb[64];
	char   Serial[64];
	char   Text[128];
};

class PPViewDialog : public PPView {
public:
	SLAPI  PPViewDialog();
	SLAPI ~PPViewDialog();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(DialogViewItem * pItem);
private:
	virtual SArray * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	virtual int SLAPI Detail(const void * pHdr, PPViewBrowser * pBrw);

	DialogFilt Filt;
	DlContext Ctx;
	TSArray <DialogViewItem> List;
};
//
// @ModuleDecl(PPViewSpecSeries)
//
class SpecSeriesFilt : public PPBaseFilt {
public:
	SpecSeriesFilt();
	SpecSeriesFilt & FASTCALL operator = (const SpecSeriesFilt &);

	uint8  ReserveStart[64]; // @anchor
	DateRange Period;
	PPID    GoodsGrpID;
	PPID    GoodsID;
	long    InfoKind;
	long    Flags;
	uint8   ReserveEnd[32];   // @anchor
	SString Serial;
};

typedef SpecSeries2Tbl::Rec SpecSeriesViewItem;

class PPViewSpecSeries : public PPView {
public:
	SLAPI  PPViewSpecSeries();
	SLAPI ~PPViewSpecSeries();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SpecSeriesViewItem *);
	int    SLAPI ExportUhtt();
	int    SLAPI ImportUhtt();
private:
	static int DynFuncSpcSnTextFld;

	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);

	int    SLAPI AddItem();
	int    SLAPI EditItem(PPID id);
	int    SLAPI DeleteItem(PPID id);
	int    SLAPI Import();
	SpecSeriesFilt Filt;
	SpecSeriesCore Tbl;
};
//
// @ModuleDecl(PPViewDBDiv)
//
class DBDivFilt : public PPBaseFilt {
public:
	DBDivFilt();
	DBDivFilt & FASTCALL operator = (const DBDivFilt &);

	uint8  ReserveStart[64]; // @anchor
	uint32 Flags;
	uint8  ReserveEnd[32];   // @anchor
	ObjIdListFilt LocList;
};

typedef PPDBDiv DBDivViewItem;

class PPViewDBDiv : public PPView {
public:
	SLAPI  PPViewDBDiv();
	SLAPI ~PPViewDBDiv();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(DBDivViewItem *);
	int    SLAPI ExportUhtt();
	int    SLAPI ImportUhtt();
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI UpdateTempTable(const PPIDArray * pIdList);
	int    SLAPI MakeTempEntry(const DBDivPack * pPack, TempDBDivTbl::Rec * pTempRec);
	int    SLAPI CheckForFilt(const DBDivPack * pPack) const;

	TempDBDivTbl * P_TempTbl;
	DBDivFilt Filt;
	PPObjDBDiv ObjDBDiv;
};
//
// PPViewDBMonitor
//
typedef DBFileInfo DBMonitorViewItem;

class DBMonitorFilt : public PPBaseFilt {
public:
	DBMonitorFilt();
	DBMonitorFilt & FASTCALL operator = (const DBMonitorFilt & s);

	char   ReserveStart[128]; // @anchor
	char   ReserveEnd[128];   // @anchor
};

class PPViewDBMonitor : public PPView {
public:
	PPViewDBMonitor();
	~PPViewDBMonitor();
	virtual int   SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int   SLAPI Init_(const PPBaseFilt * pFilt);
	int    SLAPI InitIteration(int order);
	int    FASTCALL NextIteration(DBMonitorViewItem *);
private:
	static int SLAPI GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void * pHdr, PPViewBrowser * pBrw);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	SString YesWord;
	SString NoWord;
	TSArray <DBMonitorViewItem> Items;
	PervasiveDBCatalog DBCat;
	DBMonitorFilt      Filt;
};
// @vmiller {
//
// PPViewSuprWare
//
typedef PPSuprWare SuprWareViewItem;

class SuprWareFilt : public PPBaseFilt {
public:
	SLAPI  SuprWareFilt();
	int    SLAPI InitInstance();
	int    SLAPI IsEmpty() const;
	virtual int SLAPI Describe(long flags, SString & rBuf) const;

	char   ReserveStart[20];  // @anchor
	PPID   PrmrID;
	PPID   ScndID;
	long   Flags;
	PPID   SuprWareType;
	PPID   SuprWareCat;
	SString SrchStr;           // @anchor Строка, содержащаяся в имени
	PPIDArray TypeIDList;      // Список групп
};

class PPViewSuprWare : public PPView {
public:
	struct BrwHdr {
		PPID ID;
	};
	SLAPI  PPViewSuprWare();
	SLAPI ~PPViewSuprWare();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI ViewTotal();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(SuprWareViewItem * pItem);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI Detail(const void *, PPViewBrowser * pBrw);
	int    SLAPI DeleteAll();

	SuprWareFilt  Filt;
	PPObjSuprWare SwObj;
};
//
// } @vmiller
//
//
// PPViewUserProfile
//
typedef TempUserProfileTbl::Rec UserProfileViewItem;

class UserProfileFilt : public PPBaseFilt {
public:
	SLAPI  UserProfileFilt();

	char   ReserveStart[32];  // @anchor
	long   Flags;
	long   FuncID;
	long   UserID;
	S_GUID DbID;
	DateRange Period;
	TimeRange TmPeriod;
	long   ReserveEnd;        // @anchor
};

class PPUserProfileCore : public UserFuncPrfTbl {
public:
	SLAPI  PPUserProfileCore();
	SLAPI ~PPUserProfileCore();

	int    SLAPI Load(const char * pPath);
	int    SLAPI ClearState(const S_GUID * pDbId, int use_ta);

	struct UfpDbEntry {
		S_GUID DbID;
		char   DbSymb[128];
	};
	int    SLAPI GetDbEntyList(TSArray <UfpDbEntry> & rList);

	UserFuncPrfSessTbl UfpSessT;
private:
	struct UfpLine {
		UfpLine();
		UfpLine & Clear();

		int    Kind;      // Profile::fkXXX
		S_GUID DbUuid;
		S_GUID SessUuid;
		long   ThreadId;
		int64  Seq;
		long   FuncId;
		SVerT Ver;
		LDATETIME Start;
		int64  Clock;
		MACAddr MAddr;
		uint8  Reserve[18];  // @alignment + @reserve
		double Factors[8];

		SString DbSymb;      // @anchor
		SString UserName;
		SString MachineName;
	};
	static int SLAPI ParseUfpLine(StringSet & rSs, SString & rTempBuf, int kind, PPUserProfileCore::UfpLine & rItem);

	int    SLAPI WriteState(int use_ta);
	int    SLAPI ReadState();

	int    SLAPI SetupSessItem(long * pSessID, const UfpLine & rLine, long funcId = 0);
	int    SLAPI OpenInputFile(const char * pFileName, int64 offset, SFile & rF);
	int    SLAPI AddAggrRecs(BExtInsert * pBei, const UserFuncPrfTbl::Rec & rRec, const UfpLine & rLine);

	struct StateItem_Internal { // @persistent
		S_GUID DbID;
		LDATETIME SessCrDtm;
		LDATETIME StartCrDtm;
		LDATETIME FinishCrDtm;
		int64  SessOffs;
		int64  StartOffs;
		int64  FinishOffs;
		uint   DbSymbP;
	};
	struct StateItem {
		SLAPI  StateItem();
		StateItem & SLAPI Clear();

		S_GUID DbID;
		LDATETIME SessCrDtm;
		LDATETIME StartCrDtm;
		LDATETIME FinishCrDtm;
		int64  SessOffs;
		int64  StartOffs;
		int64  FinishOffs;
		SString DbSymb;
	};
	class StateBlock : public SStrGroup {
	public:
		StateBlock();
		StateBlock & Clear();
		uint   GetCount() const
		{
			return L.getCount();
		}
		uint   GetItem(uint p, StateItem & rItem) const
		{
			return Helper_GetItem(p, rItem);
		}
		int    SetItem(StateItem & rItem);
		int    GetItem(const S_GUID & rDbId, StateItem & rItem) const;
		int    RemoveItem(const S_GUID & rDbId);
		int    Serialize(int dir, SBuffer & rBuf, SSerializeContext * pCtx);
	private:
		int    Helper_GetItem(uint pos, StateItem & rItem) const;

		SVerT Ver;
		TSArray <PPUserProfileCore::StateItem_Internal> L;
	};

	StateBlock StB;
};

class PPViewUserProfile : public PPView {
public:
	struct BrwHdr {
		long   SessID;
		int64  SeqID;
		long   Flags;
		char   SessUUID_s[40];
	};
	SLAPI  PPViewUserProfile();
	SLAPI ~PPViewUserProfile();
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	virtual int SLAPI Init_(const PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(UserProfileViewItem * pItem);
private:
	virtual DBQuery * SLAPI CreateBrowserQuery(uint * pBrwId, SString * pSubTitle);
	virtual int SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int SLAPI HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, PPViewBrowser * pBrw, void * extraProcPtr);

	int SLAPI LoadFromFile(PPIDArray * pIdList);
	int SLAPI RemoveAll();

	int    ParserBusy;
	TSArray <PPUserProfileCore::UfpDbEntry> UfpDbList;
	PPUserProfileCore Tbl;
	UserProfileFilt Filt;
};
//
// PPViewJobPool
//
class JobFilt : public PPBaseFilt {
public:
	SLAPI JobFilt();
	enum {
		fForAllDb = 0x00000001L
	};
	uint8  ReserveStart[32]; // @anchor
	PPID   CmdId;
	long   Flags;
	long   ReserveEnd;       // @anchor
};

struct JobViewItem {
	PPID   ID;
	char   Name[64];
	char   DbSymb[64];
	char   Dtr[64];             // План повторений запуска
	long   Flags;              //
	long   EstimatedTime;
	LDATETIME LastRunningTime;
	long   Ver;
	char   NextJob[64];
	char   Symb[20];
};

class PPViewJob : public PPView {
public:
	SLAPI  PPViewJob();
	SLAPI ~PPViewJob();
	virtual int SLAPI Init_(const PPBaseFilt *);
	virtual int SLAPI EditBaseFilt(PPBaseFilt *);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(JobViewItem *);
	int    SLAPI AddItem(PPID *);
	int    SLAPI EditItem(PPID);
	int    SLAPI DeleteItem(PPID);
private:
	static int SLAPI GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	virtual SArray  * SLAPI CreateBrowserArray(uint * pBrwId, SString * pSubTitle);
	virtual int  SLAPI PreprocessBrowser(PPViewBrowser * pBrw);
	virtual int  SLAPI ProcessCommand(uint ppvCmd, const void *, PPViewBrowser *);
	virtual int  SLAPI Print(const void *);

	int SLAPI CheckForFilt(PPJob & rJob);
	int SLAPI MakeList();
	int SLAPI SavePool();
	int SLAPI LoadPool();

	int SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	int    IsChanged;
	TSArray <JobViewItem> List;
	StrAssocArray CmdSymbList;
	JobFilt Filt;
	PPJobMngr Mngr;
	PPJobPool * P_Pool;

};
//
// @ModuleDecl(PPMail)
//
#define WIN32_LEAN_AND_MEAN
#define ORDEXT            ".ord"
#define MAILHDREXT        ".mhd"
#define SUBJSIZE          96L
#define SUBJECTDBDIV      "$PpyDbDivTransmission$"
#define SUBJECTORDER      "$PpyOrderTransmission$"
#define SUBJECTCHARRY     "$PpyCharryTransmission$"
#define SUBJECTFRONTOL    "ATOL_RMK_CHANGE_"
#define MIN_INET_PSW_SIZE 1

typedef void (*MailCallbackProc)(const IterCounter & bytesCounter, const IterCounter & msgCounter);

struct PPMailMsg {
	enum {
		fldFrom = 1,
		fldTo,
		fldSubj,
		fldBoundary,
		fldText,
		fldCc // @v8.9.11 Адреса для копий письма
	};
	enum {
		fPpyOrder  = 0x0001, // Заказ Albatros
		fPpyObject = 0x0002, // Данные передачи между разделами
		fMultipart = 0x0004, //
		fPpyCharry = 0x0008, // Объекты Charry
		fFrontol   = 0x0010  // Файл с данными с кассового модуля Фронтол
	};
	SLAPI  PPMailMsg();
	SLAPI ~PPMailMsg();
	int    SLAPI Init();
	int    SLAPI IsPpyData() const;
	SString & SLAPI MakeBoundaryCode(SString & rBuf) const;
	//
	// Parameters:
	//     start: 0 - pure boundary, 1 - start boundary, 2 - finish boundary
	// Returns:
	//     pBuf - on success, 0 - on error
	//
	SString & SLAPI GetBoundary(int start, SString & rBuf) const;
	int    SLAPI AttachFile(const char *);
	int    SLAPI EnumAttach(uint *, SString & rFileName, SString & rFullPath);
	int    SLAPI SetField(int fldId, const char *);
	int    FASTCALL IsField(int fldId) const;
	const  char * FASTCALL GetField(int fldId) const;
	int    SLAPI CmpField(int fldId, const char * pStr, size_t len = 0) const;

	struct Disposition {
		Disposition();
		enum {
			tUnkn = 0,
			tInline,
			tAttachment
		};
		int    Type;
		SString FileName;       // "filename"
		LDATETIME CreationDtm;  // "creation-date"
		LDATETIME ModifDtm;     // "modification-date"
		LDATETIME ReadDtm;      // "read-date"
		int64  Size;            // "size"
	};
	long   Flags;
	long   Size;
private:
	char   Zero[8];
	SString From;
	SString To;
	SString Cc;
	SString Subj;
	SString Boundary;
	SString Text;
	SStrCollection AttList;
};

#define POP3CMD_SUBJECT 3L
#define POP3CMD_RETR    4L
#define POP3CMD_QUIT    5L
#define POP3CMD_STAT    6L
#define POP3CMD_DELE    7L
#define POP3CMD_LIST    8L
#define POP3CMD_TOP     9L

#define SMTPCMD_MAIL   32L
#define SMTPCMD_RCPT   33L
#define SMTPCMD_DATA   34L
#define SMTPCMD_RSET   36L
#define SMTPCMD_AUTH   37L
#define SMTPCMD_STRING 38L

class PPMailFile {
public:
	SLAPI  PPMailFile(const char * pFileName = 0);
	SLAPI ~PPMailFile();
	int    SLAPI Open(const char * pFileName);
	int    SLAPI Close();
	const  char * SLAPI ReadLine();
	const  PPMailMsg & SLAPI GetHeader() const { return Msg; }
	int    SLAPI SaveAttachment(const char * pAttachName, const char * pDestPath);
	int    SLAPI SaveOrder(const char * pDestPath);
private:
	int    SLAPI ReadHeader();
	int    SLAPI ReadDisposition(PPMailMsg::Disposition * pD);
	int    SLAPI SkipHeader();
	int    SLAPI GetField(const char * pLine, uint fldID, SString & rBuf) const;
	int    SLAPI GetFieldTitle(uint id, SString & rBuf) const;
	int    SLAPI ProcessMsgHeaderLine(const char *);
	//
	// ARG(start IN): 0 - pure boundary, 1 - start boundary, 2 - finish boundary
	//
	int    SLAPI IsBoundaryLine(int start) const;

	PPMailMsg Msg;
	size_t LineBufSize;
	char * P_LineBuf;
	char * P_FieldStrBuf; // PPTXT_MAILFILEDS
	FILE * Stream;
};

class PPMail {
public:
	SLAPI  PPMail(const PPInternetAccount *);
	SLAPI ~PPMail();
	//
	// Descr: Инициирует запись учетной записи.
	//   Не реализует никаких действий по соединению.
	//
	int    SLAPI Init(const PPInternetAccount *);
	int    SLAPI Connect();
	int    SLAPI Disconnect();
protected:
	virtual int SLAPI FinalizeServerUrl(InetUrl & rUrl) = 0;
	int    SLAPI PutLine(const char *);
	int    SLAPI GetLine(SString & rBuf);
	int    SLAPI GetFieldTitle(uint id, SString & rBuf) const;
	int    SLAPI GetField(const char * pLine, uint fldID, SString & rBuf) const;
	int    SLAPI PutField(uint fldId, const char * pVal, SString & rResult) const;
	//MailSession * P_Sess;
	SMailClient Sess;
	PPInternetAccount MailAcc;
private:
	char * P_FieldStrBuf; // PPTXT_MAILFILEDS
};

class PPMailPop3 : public PPMail {
public:
	SLAPI  PPMailPop3(const PPInternetAccount *);
	int    SLAPI Login();                                                // cmd USER & PASS
	int    SLAPI GetStat(long * pCount, long * pSize);                   // cmd STAT
	int    SLAPI GetMsgInfo(long msgN /* 1.. */, PPMailMsg *);           // cmd TOP
	int    SLAPI GetMsg(long msgN, PPMailMsg *, const char * pFileName, MailCallbackProc, const IterCounter & msgCounter);               // cmd RETR
	int    SLAPI DeleteMsg(long msgN);                                   // cmd DELE

	int    SLAPI SaveAttachment(const char * pMsgFileName, const char * pAttachName, const char * pDestPath);
	int    SLAPI SaveOrder(const char * pMsgFileName, const char * pDestPath);
	/*
	int    SLAPI IsLogged()
	{
		return Logged;
	}
	*/
protected:
	virtual int SLAPI FinalizeServerUrl(InetUrl & rUrl);
private:
	int    SLAPI SendCmd(long cmd, const char * pAddedInfo, long addedInfo, SString & rReplyBuf);
	int    SLAPI ProcessMsgHeaderLine(const char * pLine, PPMailMsg * pMsg);
	//int    Logged;
};

class PPMailSmtp : public PPMail {
public:
	static int SLAPI Send(const PPInternetAccount & rAcc, PPMailMsg & rMsg, MailCallbackProc cbProc, const IterCounter & rMsgCounter);

	SLAPI  PPMailSmtp(const PPInternetAccount *);
	SLAPI ~PPMailSmtp();
	int    SLAPI CheckSmtpReply(const char * pReply);
	int    SLAPI Auth();                                                 // cmd AUTH
protected:
	virtual int SLAPI FinalizeServerUrl(InetUrl & rUrl);
private:
	int    SLAPI SendCmd(long cmd, const char * pAddedInfo, SString & rReplyBuf);
	int    SLAPI SendMsgToFile(PPMailMsg * pMsg, SString & rFileName);
	int    SLAPI SendMsgFromFile(PPMailMsg *, const char *, MailCallbackProc, const IterCounter &);
	int    SLAPI TransmitFile(const char * pFileName, MailCallbackProc, const IterCounter &);
	int    SLAPI MakeMessageID(SString & rBuf);
};

int SLAPI SendMailWithAttach(const char * pSubj, const char * pPath, const char * pLetter, const char * pMail, PPID accountID);
int SLAPI SendMail(const char * pSubj, const char * pLetter, const char * pMail, PPID mailAccId, SStrCollection * pFilesList, PPLogger * pLogger);
int SLAPI SendMail(const char * pSubj, const char * pLetter, StrAssocArray * pMailList, PPInternetAccount * pAccount, SStrCollection * pFilesList, PPLogger * pLogger);
//
//
//
class PPPosProtocol {
public:
	friend class ACS_PAPYRUS_APN;

	struct RouteBlock {
		SLAPI  RouteBlock();
		void   SLAPI Destroy();
		int    SLAPI IsEmpty() const;
		//
		// Descr: Функция сравнивает this с rS по критериям равенства Uuid или, если Uuid пустой,
		//   по равенству Code (если не пустой).
		//   Если и Uuid и Code у обоих экземпляров пустые, то экземпляры считаются эквивалентными.
		//
		int    FASTCALL IsEqual(const RouteBlock & rS) const;

		S_GUID Uuid;
		SString System;
		SString Version;
		SString Code;
	};
	class QueryBlock {
	public:
		SLAPI  QueryBlock();
		void   SLAPI SetQueryCSessionLast();
		void   SLAPI SetQueryCSessionCurrent();
		void   SLAPI SetQueryCSessionByID(PPID sessID);
		void   SLAPI SetQueryCSessionByNo(long sessN);
		void   SLAPI SetQueryCSessionByDate(const DateRange & rPeriod);
		void   SLAPI SetQueryRefs();
		void   SLAPI SetQueryTest();
        enum {
        	qUnkn = 0, // Не известный тип запроса
			qTest = 1, // Тестовый запрос для проверки обмена данными
        	qCSession, // Запрос кассовых сессий
        	qRefs,     // Запрос справочников
        };
        enum {
        	fCSessN       = 0x0001, // CSess - номер сессии
        	fCSessLast    = 0x0002,
        	fCSessCurrent = 0x0004
        };
        int    Q;
        long   Flags;
		DateRange Period;
		PPID   CSess;   // Идентификатор или номер сессии (в зависимости от флага fCSessN)
		PPID   ObjType; // Если Q==qRef, то здесь может быть указан тип объекта ()
	private:
		void   FASTCALL Init(int q);
	};
	struct QueryProcessBlock {
		SLAPI  QueryProcessBlock()
		{
			PosNodeID = 0;
		}
		PPID   PosNodeID;
		RouteBlock R;
		TSArray <QueryBlock> QL;
	};
	class ProcessInputBlock {
	public:
		friend class PPPosProtocol;

		enum {
			fProcessRefs        = 0x0001, // Акцептировать справочники в базу данных
			fProcessSessions    = 0x0002, // Акцептировать кассовые сессии (P_ACS != 0)
			fProcessQueries     = 0x0004, // Ответить на запросы
			fBackupProcessed    = 0x0008, // Сделать резервную копию обработанных файлов
			fRemoveProcessed    = 0x0010, // Удалить обработанные файлы
			fStoreReadBlocks    = 0x0020, // Если установлен, то все ReadBlock считанные в пределах одного вызова
				// ProcessInput сохраняются во внутренней коллекции (P_RbList).
			fSilent             = 0x0040  // Не выдавать на экран уведомления и сообщения (при исполнении фоновыв потоком или на сервере)
		};
		SLAPI  ProcessInputBlock();
		SLAPI  ProcessInputBlock(PPAsyncCashSession * pAcs);
		SLAPI ~ProcessInputBlock();
		const  void * SLAPI GetStoredReadBlocks() const;
		long   Flags;            // IN
		PPID   PosNodeID;        // IN Кассовый узел, запрашивающий вызов обработки входных данных.
		uint   SessionCount;     // OUT
		DateRange SessionPeriod; // OUT
		TSCollection <QueryProcessBlock> QpBlkList; // OUT
	private:
		void   SLAPI Helper_Construct();
		void * P_RbList; // Список ReadBlock считанных в процессе вызова ProcessInput. Так как
			// структура PPPosProtocol::ReadBlock приватная и определена ниже, используем трюк с opaque-указателем.
			// Фактически, это TSCollection <PPPosProtocol::ReadBlock>
		PPAsyncCashSession * P_ACS;
	};

	static int SLAPI EditPosQuery(TSArray <PPPosProtocol::QueryBlock> & rQList);

	SLAPI  PPPosProtocol();
	SLAPI ~PPPosProtocol();
    //int    SLAPI SendReferences(PPID nodeID, int updOnly, PPID sinceDlsID, DeviceLoadingStat * pDls, const char * pFileName);
	int    SLAPI SendQuery(PPID posNodeID, const PPPosProtocol::QueryBlock & rQ);
	//
	int    SLAPI ExportDataForPosNode(PPID nodeID, int updOnly, PPID sinceDlsID);
	int    SLAPI ExportPosSession(const PPIDArray & rSessList, PPID posNodeID, const PPPosProtocol::RouteBlock * pSrc, const PPPosProtocol::RouteBlock * pDestination);
	int    SLAPI ProcessInput(ProcessInputBlock & rPib);
private:
	struct WriteBlock {
		SLAPI  WriteBlock();
		SLAPI ~WriteBlock();
		void   Destroy();

		PPID   LocID;
		xmlTextWriter * P_Xw;
		SXml::WDoc * P_Xd;
		SXml::WNode * P_Root;
		PPIDArray NeededQkList;
		PPIDArray UsedQkList;
	};
	enum {
		obUnkn = 0,
		obGoods = 1,
		obGoodsGroup,
		obPerson,
		obGoodsCode,
		obSCard,
		obParent,
		obQuotKind,
		obQuot,
		obSource,
		obDestination,
		obCSession,
		obCCheck,
		obCcLine,
		obPosNode,
		obQuery,
		obLot
	};

	struct ObjectBlock {
		SLAPI  ObjectBlock();
		enum {
			fReady   = 0x0001,
			fRefItem = 0x0002  // Блок создан как внутренняя ссылка. По такому блоку объект следует создавать
				// только после того, как были перебраны блоки не имеющие такого флага.
		};
		long   Flags;
		long   ID;       // Идентификатор объекта в источнике данных
		long   NativeID; // Идентификатор объекта в нашей базе данных
		uint   NameP;
	};
	struct ParentBlock {
        SLAPI  ParentBlock();

        long   ID;
        uint   CodeP;
	};
	struct GoodsCode {
		SLAPI  GoodsCode();

		uint   GoodsBlkP;
		uint   CodeP;
        long   Pack;
	};
	struct QuotBlock {
		SLAPI  QuotBlock();
		enum {
			fGroup  = 0x0001 // Котировка относится к товарной группе (иначе - к товару)
		};
		long   BlkFlags; // Флаги, определяющие специфику блока (не проецируются на флаги котировок)
		union {
			uint   GoodsBlkP;
			uint   GoodsGroupBlkP;
		};
		uint   QuotKindBlkP;
		long   MinQtty;
		DateRange Period;
		double Value;
		long   Flags;
	};
	struct PosNodeBlock : public ObjectBlock {
		SLAPI  PosNodeBlock();
        uint   CodeP; // Символьное представление кода узла
        long   CodeI; // Целочисленное значение кода узла
	};
	struct QuotKindBlock : public ObjectBlock {
        SLAPI  QuotKindBlock();
		uint   CodeP;
		int16   Rank;
		uint16  Reserve;
		TimeRange TimeRestriction;
		DateRange Period;
		RealRange AmountRestriction;
	};
	struct GoodsBlock : public ObjectBlock {
		SLAPI  GoodsBlock();
		PPID   ParentBlkP;
		long   InnerId;
		double Price;
		double Rest;
	};
	struct GoodsGroupBlock : public ObjectBlock {
		SLAPI  GoodsGroupBlock();
		uint   CodeP;
		PPID   ParentBlkP;
	};
	struct LotBlock : public ObjectBlock {
		SLAPI  LotBlock();

		uint   GoodsBlkP;
		LDATE  Dt;
		LDATE  Expiry;
		double Cost;
		double Price;
		double Rest;
		uint   SerailP;
	};
	struct PersonBlock : public ObjectBlock {
		SLAPI  PersonBlock();
		uint   CodeP;
	};
	struct SCardBlock : public ObjectBlock {
		SLAPI  SCardBlock();
		uint   CodeP;
		uint   OwnerBlkP;
		double Discount;
	};
	struct CSessionBlock : public ObjectBlock {
		SLAPI  CSessionBlock();
        long   ID;
        long   Code;
        uint   PosBlkP;
        LDATETIME Dtm;
	};
	struct CCheckBlock : public ObjectBlock {
		SLAPI  CCheckBlock();
		long   Code;
		long   CcFlags;   // CCHKF_XXX Значения флагов чека, принимаемые из общего тега <flags>
		long   SaCcFlags; // CCHKF_XXX Значения флагов чека, принимаемые из специализированных тегов. Например <return>
			// Необходимо проверить, что бы CcFlags и SaCcFlags не конфликтовали
		long   CTableN;
		long   GuestCount;
		uint   CSessionBlkP;
		uint   AddrBlkP;
		uint   AgentBlkP;
		double Amount;
		double Discount;
		LDATETIME CreationDtm;
		LDATETIME Dtm;
		uint   SCardBlkP;
		uint   MemoP;
	};
	struct CcLineBlock : public ObjectBlock {
		SLAPI  CcLineBlock();
		long   CcID;
        long   RByCheck; // (id)
        long   CclFlags;
        long   DivN;
        long   Queue;
        uint   GoodsBlkP;
        double Qtty;
        double Price;
        double Discount;
        double SumDiscount;
		double Amount;
        uint   CCheckBlkP;
        uint   SerialP;
        uint   EgaisMarkP;
	};
	struct RouteObjectBlock : public ObjectBlock {
		SLAPI  RouteObjectBlock();

		int    Direction; // 0 - undef, 1 - source, 2 - destination
		uint   SystemP;
		uint   VersionP;
		uint   CodeP;
        S_GUID Uuid;
	};
	struct ObjBlockRef {
		SLAPI  ObjBlockRef(int t, uint pos);
		int    Type;
		uint   P;
	};
	struct ReadBlock : SStrGroup {
		SLAPI  ReadBlock();
		SLAPI ~ReadBlock();
		void   SLAPI Destroy();
		//
		// Descr: Копирует структуры, необходимые для анализа данных после разбора xml-потока
		//
		ReadBlock & FASTCALL Copy(const ReadBlock & rS);
		template <class B> int SLAPI Helper_CreateItem(TSArray <B> & rList, int type, uint * pRefPos)
		{
			int    ok = 1;
			ObjBlockRef ref(type, rList.getCount());
			B new_blk;
			THROW_SL(rList.insert(&new_blk));
			ASSIGN_PTR(pRefPos, RefList.getCount());
			THROW_SL(RefList.insert(&ref));
			CATCHZOK
			return ok;
		}
		int    SLAPI CreateItem(int type, uint * pRefPos);
		void * SLAPI GetItem(uint refPos, int * pType) const;
		int    SLAPI SearchRef(int type, uint pos, uint * pRefPos) const;
		int    SLAPI SearchAnalogRef_QuotKind(const QuotKindBlock & rBlk, uint exclPos, uint * pRefPos) const;
		const  QuotKindBlock * FASTCALL SearchAnalog_QuotKind(const QuotKindBlock & rBlk) const;
		//
		// Descr: Находит входящий аналог блока персоналии rBlk с идентифицированным
		//   NativeID.
		// Returns:
		//   Указатель на найденный блок-аналог
		//   Если поиск оказался безуспешным, то возвращает 0
		//
		const  PersonBlock * FASTCALL SearchAnalog_Person(const PersonBlock & rBlk) const;
		int    SLAPI GetRouteItem(const RouteObjectBlock & rO, RouteBlock & rR) const;

		xmlParserCtxt * P_SaxCtx;
		//
		// Descr: Флаги состояния процесса чтения
		//
		enum {
			stHeaderOccured = 0x0001,
			stError         = 0x0002,
			stRefsOccured   = 0x0004,
			stQueryOccured  = 0x0008,
			stCSessOccured  = 0x0010
		};
		//
		// Descr: Значения поля Phase
		//
		enum {
			phUnkn       = 0, // Не определенная фаза
			phPreprocess = 1, // Предварительная обработка (чтение заголовка, источника, получателя и списка присутствующих объектов)
			phProcess    = 2  // Полная обработка
		};
		int    State; // stXXX Состояние процесса чтения
		int    Phase; // phXXX Фаза обработки входящего файла

		const SymbHashTable * P_ShT; // Таблица символов, полученная вызовом PPGetStringHash(int)
		SString TempBuf; // @allocreuse
		SString TagValue;
		SString SrcFileName;
		TSStack <int> TokPath;
		TSStack <uint> RefPosStack; //
		TSArray <RouteObjectBlock> SrcBlkList;
		TSArray <RouteObjectBlock> DestBlkList;
		TSArray <GoodsBlock> GoodsBlkList;
		TSArray <GoodsGroupBlock> GoodsGroupBlkList;
		TSArray <LotBlock> LotBlkList;
		TSArray <GoodsCode> GoodsCodeList;
		TSArray <QuotKindBlock> QkBlkList;
		TSArray <QuotBlock> QuotBlkList;
		TSArray <PersonBlock> PersonBlkList;
		TSArray <SCardBlock> SCardBlkList;
		TSArray <ParentBlock> ParentBlkList; // Список абстрактных блоков, идентифицирующих родительских элементов объектов
		TSArray <PosNodeBlock> PosBlkList;
		TSArray <CSessionBlock> CSessBlkList;
		TSArray <CCheckBlock> CcBlkList;
		TSArray <CcLineBlock> CclBlkList;
		TSArray <QueryBlock> QueryList;
		TSArray <ObjBlockRef> RefList;
	};
	struct PosNodeUuidEntry {
		S_GUID Uuid;
		PPID   PosNodeID;
	};
	struct PosNodeISymbEntry {
		long   ISymb;
		PPID   PosNodeID;
	};
	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);
	static void Scb_Characters(void * ptr, const uchar * pC, int len);

	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    Characters(const char * pS, size_t len);
	void   SaxStop();

	//
	// Descr: Разбирает входящий документ из файла pFileName и складывает данные в объект RdB.
	//   После разбора данные в RdB могут быть импортированы.
	//
	int    SLAPI SaxParseFile(const char * pFileName, int preprocess);
	int    SLAPI AcceptData(PPID posNodeID, int silent);
	int    SLAPI BackupInputFile(const char * pFileName);
    void   SLAPI DestroyReadBlock();
	const PPPosProtocol::ReadBlock & SLAPI GetReadBlock() const
	{
		return RdB;
	}
	int    SLAPI ResolveGoodsBlock(const GoodsBlock & rBlk, uint refPos, int asRefOnly, PPID defParentID, PPID defUnitID, PPID srcArID, PPID locID, PPID * pNativeID);

	const  SString & FASTCALL EncText(const char * pS);
	uint   SLAPI PeekRefPos() const;
	void * SLAPI PeekRefItem(uint * pRefPos, int * pType) const;
	int    SLAPI Helper_GetPosNodeInfo_ForInputProcessing(const PPCashNode * pCnRec, TSArray <PosNodeISymbEntry> & rISymbList, TSArray <PosNodeUuidEntry> & rUuidList);
	void   FASTCALL Helper_AddStringToPool(uint * pPos);
	int    FASTCALL Helper_PushQuery(int queryType);
	QueryBlock * Helper_RenewQuery(uint & rRefPos, int queryType);
	int    SLAPI Accept_Person(PPPosProtocol::PersonBlock & rBlk, PPID kindID);
	int    SLAPI CreateGoodsGroup(const GoodsGroupBlock & rBlk, int isFolder, PPID * pID);
	int    SLAPI CreateParentGoodsGroup(const ParentBlock & rBlk, int isFolder, PPID * pID);
	int    SLAPI InitSrcRootInfo(PPID posNodeID, PPPosProtocol::RouteBlock & rInfo);

	int    SLAPI SelectOutFileName(const PPAsyncCashNode * pPosNode, const char * pInfix, StringSet & rResultSs);
	int    SLAPI StartWriting(const char * pFileName, PPPosProtocol::WriteBlock & rB);
	int    SLAPI FinishWriting(WriteBlock & rB);
	int    SLAPI WriteGoodsInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashGoodsInfo & rInfo, const PPQuotArray * pQList);
	int    SLAPI WriteGoodsGroupInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashGoodsGroupInfo & rInfo, const PPQuotArray * pQList);
	int    SLAPI WriteSCardInfo(WriteBlock & rB, const char * pScopeXmlTag, const AsyncCashSCardInfo & rInfo);
	int    SLAPI WritePersonInfo(WriteBlock & rB, const char * pScopeXmlTag, PPID codeRegTypeID, const PPPersonPacket & rPack);
	int    SLAPI WriteQuotInfo(WriteBlock & rB, const char * pScopeXmlTag, PPID parentObj, const PPQuot & rInfo);
	int    SLAPI WriteQuotKindInfo(WriteBlock & rB, const char * pScopeXmlTag, const PPQuotKind & rInfo);
	int    SLAPI WriteRouteInfo(WriteBlock & rB, const char * pScopeXmlTag, const RouteBlock & rInfo);
	int    SLAPI WritePosNode(WriteBlock & rB, const char * pScopeXmlTag, PPCashNode & rInfo);
	int    SLAPI WriteCSession(WriteBlock & rB, const char * pScopeXmlTag, const CSessionTbl::Rec & rInfo);

	SString EncBuf;
	PPObjPerson PsnObj;
	PPPosProtocol::ReadBlock RdB;

	PPObjBill * P_BObj;
	PPObjGoods GObj;
	PPObjGoodsGroup GgObj;
	PPObjQuotKind QkObj;
	PPObjCSession CsObj;
	PPObjSCard  ScObj;
	PPObjCashNode CnObj;
};
//
//
//
class PPEgaisProcessor : public PrcssrAlcReport {
public:
	struct Packet {
		Packet(int docType);
		~Packet();
		enum {
			fAcceptedBill = 0x0001, // В пакете содержится импортированный в базу данных документ
			fDoDelete     = 0x0002, // Документ следует удалить с сервера ЕГАИС
			fReturnBill   = 0x0004, // Пакет содержит документ возврата поставщику
			fFaultObj     = 0x0008  // @v9.2.8 Флаг идентифицирует пакет, являющийся инвалидным.
				// При позднем акцепте этого пакета, наличие флага сигнализирует, что акцептировать такой пакет не следует.
		};
		int    DocType;
		long   Flags;
		uint   SrcReplyPos; // Позиция документа-источника в таблице TSCollection <Reply> (+1)
		PPID   IntrBillID;  // Только для входящих WAYBILL - идентификатор документа внутренней передачи,
			// которому соответствует (PPBillPacket *)P_Data. Необходим для позднего акцепта, поскольку
			// данный идентификатора вычисляется на этапе обработки входящего xml-потока.
		void * P_Data;
	};
	//
	// Descr: Подтверждение от сервера ЕГАИС о получении запроса
	//
	struct Ack {
		Ack();
		void   Clear();

		enum {
			stError = 0x0001
		};
		uint   Ver;        // Версия протокола
		uint8  SignSize;   // Размер подписи
		uint8  Sign[260];  // Подпись // @v9.0.11 [256]-->[260]
		S_GUID Id;         // Ид присвоенный запросу сервером
		int    Status;
		SString Url;       // @v9.1.8
		SString Message;
	};
	//
	// Descr: Дескриптор ответа на запрос
	//
	struct Reply {
		Reply();
		enum {
			stError    = 0x0001,
			stAccepted = 0x0002,
			stOffline  = 0x0004, // Пакет получен не на прямую от сервера, а из каталога в файловой системе
			stDeleted  = 0x0008  // К пакету была применена операция DeleteDoc
		};
		long   Status;
		S_GUID Id;         // Ид присвоенный запросу сервером (полученный ответом на запрос - см. Ack)
        SString Url;       // Адрес сообщения с ответом
        SString AcceptedFileName; // Имя локального файла, в который получено содержимое ответа
	};
	//
	// Descr: Результат отправки данных
	//
	struct Ticket {
		Ticket();
		void   Clear();
		struct Result {
			Result();
			void   Clear();
			int    Type; // 0 - undef, 1 - ticket result, 2 - operation result
			int    Conclusion; // 0 - rejected, 1 - accepted
			LDATETIME Time;
			SString OpName; // OperationName
			SString Comment;
		};
        LDATETIME TicketTime;
        S_GUID DocUUID;
        S_GUID TranspUUID;
        int    DocType;
        SString RegIdent;
        Result R;   // Result
        Result OpR; // OperationResult
	};
	//
	//
	//
	struct ConfirmTicket {
		SLAPI  ConfirmTicket();
		PPID   BillID;
		int    Conclusion; // 0 - rejected, 1 - accepted
		SString Code;
		LDATE  Date;
		SString RegIdent;
		SString Comment;
	};
	//
	//
	//
	struct InformAReg {
		SLAPI  InformAReg();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
        int    SLAPI ToStr(SString & rBuf);
        int    SLAPI FromStr(const SString & rBuf);

        long   Qtty;
        LDATE  ManufDate;
        LDATE  TTNDate;
        SString TTNCode;
        LDATE  EGAISDate;
        SString EGAISCode;
	};
	//
	//
	//
	struct InformBItem {
		InformBItem();
		void   Clear();

		long   P;
		char   Ident[24];
		LDATE  BottlingDate; // @v9.5.5
	};

	struct InformB {
		InformB();
		void   Clear();

        SString Id;
        SString WBRegId;   // ИД накладной в системе (присвоенный)
        SString FixNumber; // Номер фиксации накладной(отгрузки) в ЕГАИС
        LDATE  FixDate;
        SString OuterCode; // Номер накладной (у отправителя)
        LDATE  OuterDate;  // Дата накладной (у отправителя)
        PPID   ShipperPsnID;
        PPID   ConsigneePsnID;
        PPID   SupplPsnID;
        TSArray <PPEgaisProcessor::InformBItem> Items;
	};

	struct ActInformItem {
		ActInformItem();
		long   P;
		char   AIdent[24];
		TSArray <PPEgaisProcessor::InformBItem> BItems;
	};

    struct ActInform {
    	ActInform();

        SString ActRegId;
        SString ActNumber;
		TSCollection <PPEgaisProcessor::ActInformItem> Items;
    };
	//
	// Descr: Структура запроса на отмену проведения документа (грузополучатель - отправляет, грузоотправитель - получает и подтверждает)
	//
    struct RepealWb {
    	RepealWb();

        PPID   BillID;
        LDATETIME ReqTime; // @v9.5.12
        int    Confirm; // Только для подтверждения отмены проведения. 1 - подтверждаем, 0 - отклоняем
        SString ContragentCode; // @v9.5.12
        SString TTNCode;
        SString ReqNumber;
        SString Memo;
    };
    //
    // Descr: Структура запроса и ответа по штрихкоду (QueryBarcode)
    //
    struct QueryBarcode {
		QueryBarcode();

    	int    RowId;
        int    CodeType; // 103, 203
        SString Rank;
        SString Number;
        SString Result;
    };
    //
    // Descr: Дескриптор сервера УТМ
    //
    struct UtmEntry {
    	SLAPI  UtmEntry();

    	enum {
    		fDefault = 0x0001 // Если флаг установлен, то это означает, что
				// MainOrgID является текущей главной организацией,
				// FSRARID получен из тега этой персоналии,
				// Url получен из конфигурации глобального обмена
    	};
    	PPID   MainOrgID; // Главная организация, с которой ассоциированы параметры Url и FSRARID.
    	long   Flags;
    	char   Url[128];
    	char   FSRARID[128];
    };
	//
	// Descr: Параметры функции TestEGAIS()
	//
	struct TestParam {
		enum {
			fReceiveDataToTempCatalog  = 0x0001,
			fAcceptDataFromTempCatalog = 0x0002
		};
		PPID   LocID;
		long   Flags;
	};
	//
	// Descr: Параметры запроса к серверу ЕГАИС
	//
	struct QueryParam {
		SLAPI  QueryParam();
		int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

		enum {
			_afQueryRefA         = 0x0001,
			_afQueryPerson       = 0x0002,
			_afQueryGoods        = 0x0004,
			_afQueryByChargeOn   = 0x0008,
			_afClearInnerEgaisDb = 0x0010
		};
		long   DocType;
		long   DbActualizeFlags;
		long   Flags; // PPEgaisProcessor::stTestSendingMode
		PPID   MainOrgID;
		PPID   LocID;
		SString ParamString;
		SString InfoText; // @transient
	};
	//
	// Descr: Типы ТТН
	//
	enum {
		wbtInvcFromMe = 1, // Инвойс от меня к контрагенту
		wbtInvcToMe,       // Инвойс от контрагента ко мне
		wbtRetFromMe,      // Возврат от меня к контрагенту
		wbtRetToMe         // Возврат от контрагента ко мне
	};

    static const char * FASTCALL GetDocTypeTag(int docType);
    static int FASTCALL RecognizeDocTypeTag(const char * pTag);
	static const char * FASTCALL GetWayBillTypeText(int wbType);
	static int FASTCALL RecognizeWayBillTypeText(const char * pText);
	static int SLAPI EditInformAReg(InformAReg & rData);
	//
	// Descr: Вызывает диалог для ввода кода акцизной марки.
	//
	static int SLAPI InputMark(PrcssrAlcReport::GoodsItem * pAgi, SString & rMark);
	//
	// Descr: Флаги создания экземпляра класса
	//
	enum {
		cfDebugMode         = 0x0001, // Работать в тестовом режиме отправки (не передавать данные в УТМ)
		cfDirectFileLogging = 0x0002  // Сообщения выводить на прямую в файлы журналов (без посредничества PPLogger)
	};

	SLAPI  PPEgaisProcessor(long cflags, PPLogger * pOuterLogger);
	SLAPI ~PPEgaisProcessor();
	int    SLAPI operator !() const;
	void   SLAPI SetTestSendingMode(int set);
	void   SLAPI SetNonRvmTagMode(int set);
	int    SLAPI CheckLic() const;
	int    SLAPI GetUtmList(PPID locID, TSArray <UtmEntry> & rList);
	void   SLAPI SetUtmEntry(PPID locID, const UtmEntry * pEntry, const DateRange * pPeriod);
	int    SLAPI GetFSRARID(PPID locID, SString & rBuf, PPID * pMainOrgID);
	int    SLAPI GetURL(PPID locID, SString & rBuf);

	int    SLAPI EditQueryParam(PPEgaisProcessor::QueryParam * pData);
	int    SLAPI ImplementQuery(PPEgaisProcessor::QueryParam & rParam);
	int    SLAPI InteractiveQuery();

	enum {
		querybyINN = 1,
		querybyCode
	};

    int    SLAPI QueryClients(PPID locID, int queryby, const char * pQ);
    int    SLAPI QueryProducts(PPID locID, int queryby, const char * pQ);
    int    SLAPI QueryRests(PPID locID, const char * /* @unused */);
    int    SLAPI QueryRestsShop(PPID locID, const char * /* @unused */);
    int    SLAPI QueryInfA(PPID locID, const char * pInfA);
    int    SLAPI QueryInfB(PPID locID, const char * pInfB);

    int    SLAPI Write(Packet & rPack, PPID locID, const char * pFileName);
    int    SLAPI Write(Packet & rPack, PPID locID, SBuffer & rBuffer);

    int    SLAPI PutQuery(PPEgaisProcessor::Packet & rPack, PPID locID, const char * pUrlSuffix, PPEgaisProcessor::Ack & rAck);
    int    SLAPI PutCCheck(const CCheckPacket & rPack, PPID locID, PPEgaisProcessor::Ack & rAck);
    PPEgaisProcessor::Packet * SLAPI GetReply(const PPEgaisProcessor::Reply & rReply);
	int    SLAPI AcceptDoc(PPEgaisProcessor::Reply & rR, const char * pFileName);
	int    SLAPI DeleteDoc(PPEgaisProcessor::Reply & rR);
	//
	// Descr: Флаги состояния документа в базе данных
	//
	enum {
		bilstfAccepted         = 0x0001, // Документ принят из ЕГАИС-сервера
		bilstfWritedOff        = 0x0002, // Документ списан
		bilstfReadyForAck      = 0x0004, // Документ готов к отправке подтверждения
		bilstfChargeOn         = 0x0008, // Документы постановки на баланс начальных остатков
		bilstfExpend           = 0x0010, // Документы продажи товара
		bilstfIntrExpend       = 0x0020, // Документы внутренней передачи
		bilstfReturnToSuppl    = 0x0040, // Документы возврата поставщику
		bilstfLosses           = 0x0080, // @v8.9.12 Документы потерь (прочие расходы)
		bilstfRepeal           = 0x0100, // @v9.2.8 Документы с запросом на отмену проведения
		bilstfTransferToShop   = 0x0200, // @v9.2.11 Документы передачи в торговый зал (Регистр 2)
		bilstfChargeOnShop     = 0x0400, // @v9.2.11 Документы постановки на баланс начальных остатков в торговом зале (Регистр 2)
		bilstfTransferFromShop = 0x0800, // @v9.3.10 Документы возврата из торговый зал (Регистр 2) на склад
		bilstfWriteOffShop     = 0x1000, // @v9.4.0  Документы списания с баланса торгового зала (Регистр 2)
		bilstfWbRepealConf     = 0x2000, // @v9.5.12 Документы, для которых получен и ожидает подтверждения запрос на отмету проведения
		bilstfV1               = 0x4000, // @v9.7.5  Специальный флаг, явно указывающий на 1-ю версию формата ЕГАИС
		bilstfV2               = 0x8000, // @v9.7.5  Документы 2-й версии ЕГАИС
	};

	struct SendBillsParam {
		SLAPI  SendBillsParam();

		PPID   LocID;
		DateRange Period;
		PPIDArray IdList;
	};

	int    SLAPI GetAcceptedBillList(const SendBillsParam & rP, long flags, PPIDArray & rList);
	int    SLAPI GetBillListForTransmission(const SendBillsParam & rP, long flags, PPIDArray & rList, PPIDArray * pRejectList);
	int    SLAPI GetBillListForConfirmTicket(/*PPID locID, const DateRange & rPeriod*/const SendBillsParam & rP, long flags, PPIDArray & rList);
	int    SLAPI GetTempFileName(const char * pPath, const char * pSubPath, const char * pPrefix, SString & rFn);

	enum {
		rifOffline             = 0x0001,
		rifRepairInventoryMark = 0x0002
	};

	int    SLAPI ReadInput(PPID locID, const DateRange * pPeriod, long flags);
	int    SLAPI DebugReadInput(PPID locID);
	int    SLAPI RemoveOutputMessages(PPID locID, int debugMode);

	//int    SLAPI SendBillActs(PPID locID, const DateRange * pPeriod);
	//int    SLAPI SendBills(PPID locID, const DateRange * pPeriod);
	int    SLAPI SendBillActs(const SendBillsParam & rP);
	int    SLAPI SendBillRepeals(const SendBillsParam & rP);
	int    SLAPI SendBills(const SendBillsParam & rP);
	int    SLAPI CreateActChargeOnBill(PPID * pBillID, int ediOp, PPID locID, LDATE restDate, const PPIDArray & rLotList, int use_ta);

	int    SLAPI CollectRefs();
private:
	struct BillTransmissionPattern {
		long   Flags;
		int    EdiOp;
		const  char * P_UrlSuffix;
	};
	int    SLAPI Helper_SendBillsByPattern(const SendBillsParam & rP, const BillTransmissionPattern & rPattern);
    int    SLAPI GetReplyList(void * pCtx, PPID locID, int direction /* +1 out, -1 - in */, TSCollection <PPEgaisProcessor::Reply> & rList);
	int    SLAPI Helper_Read(void * pCtx, const char * pFileName, long flags,
		PPID locID, const DateRange * pPeriod, uint srcReplyPos, TSCollection <PPEgaisProcessor::Packet> * pPackList, PrcssrAlcReport::RefCollection * pRefC);
	int    SLAPI Helper_Write(Packet & rPack, PPID locID, xmlTextWriter * pX);
	const SString & FASTCALL EncText(const char * pS);
	const SString & FASTCALL EncText(const SString & rS);
	enum {
		wpifPutManufInfo = 0x0001,
		wpifVersion2     = 0x0002  // Данные о товаре записываются в формате 2-й версии протокола ЕГАИС
	};
	int    SLAPI WriteProductInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, PPID goodsID, PPID lotID, long flags, const ObjTagList * pLotTagList);
	enum {
		woifStrict                 = 0x0001,
		woifDontSendWithoutFSRARID = 0x0002,
		woifVersion2               = 0x0004  // Данные о персоналии записываются в формате 2-й версии протокола ЕГАИС
	};
	int    SLAPI WriteOrgInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, PPID personID, PPID addrLocID, LDATE actualDate, long flags);
	int    SLAPI WriteOrgInfo(SXml::WDoc & rXmlDoc, const char * pScopeXmlTag, const EgaisPersonCore::Item & rRefcItem, long flags);
	int    SLAPI WriteInformCode(SXml::WDoc & rXmlDoc, const char * pNs, char informKind, SString & rCode, int v2);
	//
	// Descr: Разбирает xml-ответ от сервера УТМ (<A></A>)
	//
	int    SLAPI ReadAck(SBuffer * pBuf, PPEgaisProcessor::Ack & rAck);
	int    SLAPI Read_OrgInfo(xmlNode * pFirstNode, PPID personKindID, int roleFlags, PPPersonPacket * pPack, PrcssrAlcReport::RefCollection * pRefC, SFile * pOutFile);
	int    SLAPI Read_ProductInfo(xmlNode * pFirstNode, PPGoodsPacket * pPack, PrcssrAlcReport::GoodsItem * pExt, PrcssrAlcReport::RefCollection * pRefC, SFile * pOutFile);
	int    SLAPI Read_WayBill(xmlNode * pFirstNode, PPID locID, const DateRange * pPeriod, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	int    SLAPI Read_WayBillAct(xmlNode * pFirstNode, PPID locID, Packet * pPack);
	int    SLAPI Read_Rests(xmlNode * pFirstNode, PPID locID, const DateRange * pPeriod, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	int    SLAPI Read_Ticket(xmlNode * pFirstNode, Packet * pPack);
	int    SLAPI Read_TicketResult(xmlNode * pFirstNode, int ticketType /* 1 or 2 */, PPEgaisProcessor::Ticket::Result & rResult);
	int    SLAPI Read_TTNIformBReg(xmlNode * pFirstNode, Packet * pPack);
	int    SLAPI Read_ActInventoryInformBReg(xmlNode * pFirstNode, Packet * pPack);
	int    SLAPI Read_IformA(xmlNode * pFirstNode, Packet * pPack, PrcssrAlcReport::RefCollection * pRefC);
	SString & FASTCALL PreprocessGoodsName(SString & rName) const;
	int    SLAPI AssignManufTypeToPersonPacket(PPPersonPacket & rPack, int manufType);
	int    SLAPI FinishBillProcessingByTicket(const PPEgaisProcessor::Ticket * pT, int use_ta);
	int    SLAPI Helper_FinishBillProcessingByTicket(int ticketType, const BillTbl::Rec & rRec,
		const SString & rBillText, const PPEgaisProcessor::Ticket * pT, int conclusion, int use_ta);
	int    SLAPI Helper_FinishConfirmProcessingByTicket(const BillTbl::Rec & rRec, const SString & rBillText,
		const S_GUID & rUuid, int conclusion, int use_ta);
	//
	// Descr: Создает зарезервированную операцию постановки товаров на баланс ЕГАИС
	// ARG(pID    OUT): Идентификатор созданного вида операции
	// ARG(egaisOp IN): PPEDIOP_EGAIS_ACTCHARGEON || PPEDIOP_EGAIS_ACTCHARGEONSHOP
	// ARG(use_ta  IN): @usingtransaction
	//
	int    SLAPI GetActChargeOnOp(PPID * pID, int egaisOp, int use_ta);
	int    SLAPI GetDebugPath(PPID locID, SString & rPath);
	int    SLAPI Helper_ReadFilesOffline(const char * pPath, TSCollection <PPEgaisProcessor::Reply> & rList);
	int    SLAPI SearchActChargeByActInform(const PPEgaisProcessor::ActInform & rInf, PPID * pBillID);
	int    SLAPI MakeOutputFileName(const Reply * pReply, const SString & rTempPath, SString & rFileName);
	int    SLAPI DeleteSrcPacket(const Packet * pPack, TSCollection <PPEgaisProcessor::Reply> & rReplyList);

	int    SLAPI Helper_SendBills(PPID billID, int ediOp, PPID locID, const char * pUrlSuffix);
	int    SLAPI Helper_InitNewPack(const int docType, TSCollection <PPEgaisProcessor::Packet> * pPackList, PPEgaisProcessor::Packet ** ppPack);
	int    SLAPI Helper_FinalizeNewPack(PPEgaisProcessor::Packet ** ppNewPack, uint srcReplyPos, TSCollection <PPEgaisProcessor::Packet> * pPackList);
	int    SLAPI Helper_CollectRefs(void * pCtx, TSCollection <PPEgaisProcessor::Reply> & rReplyList, RefCollection & rRefC);
	int    SLAPI Helper_AcceptBillPacket(Packet * pPack, TSCollection <PPEgaisProcessor::Packet> * pPackList, uint packIdx);
	int    SLAPI Helper_AreArticlesEq(PPID ar1ID, PPID ar2ID);
	int    SLAPI Helper_CreateTransferToShop(const PPBillPacket * pCurrentRestPack);
	int    SLAPI Helper_CreateWriteOffShop(const PPBillPacket * pCurrentRestPack, const DateRange * pPeriod);
	int    SLAPI Helper_MakeMarkList(PPID lotID, StringSet & rSsExtCodes, uint * pExtCodeCount);
	int    SLAPI Helper_ExtractGoodsCodesFromBills(PPID opID, StringSet & rSs);

	void   FASTCALL Log(const SString & rMsg);
	void   SLAPI LogTextWithAddendum(int msgCode, const SString & rAddendum);
	void   SLAPI LogLastError();
	void   SLAPI LogTicketResult(const Ticket * pTicket, const BillTbl::Rec * pBillRec);
	//
	// Descr: Выводит в журнал сообщение об отправке пакета rPack
	//
	int    SLAPI LogSended(const Packet & rPack);
	int    SLAPI CheckBillForMainOrgID(const BillTbl::Rec & rRec, const PPOprKind & rOpRec);
	int    SLAPI ExpandBaseOpList(const PPIDArray & rBaseOpList, PPIDArray & rResultList);
	//int    SLAPI IsAcsLinkedToMainOrg(PPID acsID);

	enum {
		stError             = 0x0001, // Во время выполнения какой-то функции произошла критическая ошибка
		stOuterLogger       = 0x0002, // Экземпляр PPLogger был передан из-вне (не следует разрушать P_Logger)
		stValidLic          = 0x0004, // Присутствует лицензия на использование интерфейса с ЕГАИС
		stTestSendingMode   = 0x0008, // @v8.9.0 Тестовый режим отправки сообщений. Фактически, сообщения в виде
			// файлов копируются в каталог TEMP/EGAIX-XXX/OUT-TEST/
		stDontRemoveTags    = 0x0010, // @v8.9.9 Опция, припятствующая удалению тегов с документов при получении отрицательных тикетов
		stDirectFileLogging = 0x0020  // @v9.0.11 Сообщения выводить непосредственно в файлы журналов (обходя P_Logger)
	};
	long   State;
	const  UtmEntry * P_UtmEntry; // @notowned
	// @v9.6.4 (useless) DGQCore * P_Dgq;
	SString EncBuf;
	StringSet ExclChrgOnMarks; // @v8.9.12 Список марок, которые должны быть исключены при постановке лотов на баланс
	PPLocAddrStruc * P_Las;
	LotExtCodeTbl * P_LecT;
	PPTextAnalyzerWrapper * P_Taw;
	PPLogger * P_Logger;
};
//
// @ModuleDecl(DL200)
//
#define DL200_SIGNATURE  0x42324C44L // "DL2B"
#define DL200_VERSION    1

typedef uint16 dl2cit;

// CI - Calculated Item

#define DL2CIT_CONST_FIRST_ 1
#define DL2CIT_REAL         1 // Вещественное число
#define DL2CIT_INT          2 // Целое число
#define DL2CIT_DATE         4 // Дата
#define DL2CIT_TIME         5 // Время //
#define DL2CIT_PERIOD       6 // Период
#define DL2CIT_STRING       7 // Строка
#define DL2CIT_CONST_LAST_ 20

#define DL2CIT_METAVAR     21 // Метапеременная //
#define DL2CIT_ACC         22 // Переменная бух счета
#define DL2CIT_SCORE       23 // Показатель. Расчетная формула для вычисления показателей,
	// отличных от бухгалтерских счетов (тованые остатки, суммы по документам, чекам и т.д.)

#define DL2CIT_OP_FIRST_  101
#define DL2CIT_OP_UPLUS   101 // Unary +
#define DL2CIT_OP_UMINUS  102 // Unary -
#define DL2CIT_OP_PLUS    103 // Binary +
#define DL2CIT_OP_MINUS   104 // Binary -
#define DL2CIT_OP_MULT    105 // Binary *
#define DL2CIT_OP_DIV     106 // Binary /
#define DL2CIT_OP_LAST_  1000

#define DL2CIT_FUNC      1001
//
//
//
// @mainorg     Полное наименование главной организации
// @mainorgaddr Адрес главной организации
// @mainorginn  ИНН
// @mainorgokpo ОКПО
// @director    Директор
// @accountant  Гл. бухгалтер
// @dbname      User-friendly наименование базы данных
// @dbsymb      Символ базы данных
//
//
//
struct MetavarDecl {
	long   ID;         // Generated macro PPMETAVAR_XXX [XXX = strupr(Name)]
	dl2cit Type;       // DL2CIT_XXX
	char   Name[36];
};

class MetavarList : public SCollection {
public:
	SLAPI  MetavarList();
	SLAPI ~MetavarList();
	int    SLAPI SetVal(long id, const char * pVal);
	int    SLAPI GetStr(long id, char *, size_t) const;
	int    SLAPI GetInt(long id, long *) const;
	int    SLAPI GetReal(long id, double *) const;
	int    SLAPI GetAcc(long id, Acct *) const;
};
//
// Descr: Показатель, основанный не на бухгалтерских счетах
//   (остатки товаров, суммы по документам, текст персонального события и т.д.)
//
// @loclist(...)
// @bill(period, op, [loc])
// @paym(period, op, [loc]) // op - операция, к которой привязаны оплаты
// @personevent(period, op)
// @ccheck(period, [loc])
// @goodsrest.cost(period, [loc])
// @debt(period, accsheet)
// @bizscore(period, scoresymb)
//
class DL2_Score {
public:
	void   SLAPI Init(DL2_Resolver * pCtx);
	int    SLAPI GetFromStr(const char *, size_t * pOffs);
	int    SLAPI PutToStr(SString & rBuf) const;

	enum {
		kMetavar = 1,      // Метапеременная //
		kBill,             // Документы
		kPaym,             // Оплаты по документам
		kCCheck,           // Кассовые чеки
		kGoodsRest,        // Остатки товаров
		kPersonEvent,      // Персональные события //
		kDebt,             // Долги
		kBizScore          // Бизнес-показатели
	};
	enum {
		subNone = 0,       //
		subAmount,         // "amount"    kBill, kPaym, kCCheck, kGoodsRest, kDebt, kBizScore
		subCost,           // "cost"      kBill, kPaym, kCCheck, kGoodsRest
		subPrice,          // "price"     kBill, kPaym, kCCheck, kGoodsRest
		subDiscount,       // "discount"  kBill, kCCheck
		subNetPrice,       // "netprice"  kBill, kPaym, kCCheck, kGoodsRest
		subMargin,         // "margin"    kBill, kPaym, kCCheck, kGoodsRest
		subPctIncome,      // "pctincome" kBill, kPaym, kCCheck, kGoodsRest
		subPctMargin,      // "pctmargin" kBill, kPaym, kCCheck, kGoodsRest
		subCount,          // "count"     kBill, kPaym, kCCheck, kGoodsRest, kPersonEvent, kDebt, kBizScore
		subAverage         // "average"   kBizScore
	};
	enum {
		subsubAverage      // "average"   kBill, kPaym, kCCheck, kGoodsRest
	};
	enum {
		cmpNone = 0,
		cmpDD,             // День/День
		cmpMM,             // Месяц/Месяц
		cmpQQ,             // Квартал/Квартал
		cmpYY,             // Год/Год
		cmpPrev            // Предыдущий примыкающий период
	};
	dl2cit CiType;         // Тип показателя //
	int16  Kind;           // kXXX   Показатель
	int16  Sub;            // subXXX
	int16  Modifier;       // modXXX Модификатор показателя //
	int16  Cmp;            // cmpXXX Сравнение с предыдущим периодом
	DateRange Period;      // Период
	int32  LocListID;      // Идентификатор списка складов
	int32  GoodsGrpListID; // Идентификатор списка товарных групп
	char   OpCode[32];     // Символ вида операции (Kind == kBill, kPaym, kPersonEvent, kDebt, kBizScore)
	DL2_Resolver * P_Ctx;  // @notowned Контекст разрешения формулы
private:
	void   SLAPI Helper_Init();
	int    SLAPI ScanArg(SStrScan & rScan, SString & rBuf);
	int    SLAPI ScanArgList(const char * pStr, size_t * pOffs);
};

struct DL2_Acc {
public:
	void   SLAPI Init();
	int    SLAPI GetFromStr(const char *, int substAr = -1);
	int    SLAPI GetAco() const;
	int    SLAPI GetCorrAco() const;

	enum {
		fRest     = 0x0001, // 'R' Исключает fTurnover fInRest
		fInRest   = 0x0002, // 'I' Исключает fTurnover fRest
		fTurnover = 0x0004,	// 'T' Исключает fRest fInRest
		fDebit    = 0x0008, // 'D' Дебетовое сальдо или оборот
		fCredit   = 0x0010, // 'C' Кредитовое сальдо или оборот
		fSpread   = 0x0020, // 'S' Развернутое сальдо по субконто (подразумевает fRest или fInRest)
		fAco1     = 0x0100, // 'O1' Счет 1-го порядка
		fAco2     = 0x0200, // 'O2' Счет 2-го порядка
		fAco3     = 0x0400, // 'O3' Терминальный счет
		fCorAco1  = 0x1000, // ':O1' Корр счет 1-го порядка
		fCorAco2  = 0x2000, // ':O2' Корр счет 2-го порядка
		fCorAco3  = 0x4000, // ':O3' Терминальный корр счет
	};
	Acct   Acc;	         // Счет (натуральное представление)
	char   Code[32];
	Acct   CorrAcc;      // Корреспондирующий счет
	char   CorrCode[32]; // Код корреспондирующего счета
	uint16 Flags;        // Флаги
	uint16 PrdOfs;       // Период сдвига
	int16  NumPrdOfs;    // Количество периодов сдвига
private:
	int    SLAPI GetAcc(char ** ptr, int isCorr, int substAr = -1);
};

struct DL2_CI {
	static DL2_CI * SLAPI MakeStr(const char *);
	static DL2_CI * SLAPI Copy(const DL2_CI *);
	static void Destroy(DL2_CI *);

	void * SLAPI operator new(size_t, const char * = 0);
	int    SLAPI IsConst() const;
	void   SLAPI InitOp(uint16 op, uint16 argCount);
	void   SLAPI Init(double v);
	void   SLAPI Init(long v);
	void   SLAPI Init(LDATE v);
	void   SLAPI Init(LTIME v);
	void   SLAPI Init(const DateRange * pV);
	void   SLAPI Init(const DL2_Acc * pV);
	void   SLAPI Init(const DL2_Score * pV);
	void   SLAPI InitMetavar(long id);

	size_t SLAPI Size() const;
	int    SLAPI GetStr(char * pBuf, size_t bufLen) const;
	const  char * SLAPI GetStr() const;
	int    SLAPI ToString(char * pBuf, size_t bufLen) const;

	dl2cit CiType;
	union {
		uint16 ArgCount;
		double R;
		long   I;
		LDATE  D;
		LTIME  T;
		DateRange P;
		DL2_Acc A;
		DL2_Score Score;
		long   MvID; // Metavar ID
		uint16 Len;
	};
};
//
//
//
class DL2_Storage {
public:
	struct IndexItem {
		uint16 EntryType;
		char   Name[36];
		uint32 Offs;
	};

	static int SLAPI IsDL200File(const char *);

	SLAPI  DL2_Storage();
	SLAPI ~DL2_Storage();

	int    SLAPI Open(const char * pFileName, int readOnly);
	int    SLAPI Close();
	int    SLAPI GetDataEntriesList(SStrCollection *);
	int    SLAPI WriteEntry(const DL2_Entry *);
	int    SLAPI ReadEntry(uint type, const char * pName, DL2_Entry *);
	int    SLAPI ReadEntryHeader(uint type, const char * pName, DL2_Entry *);

	int    SLAPI AddSymb(const DL2_Entry *);
	int    SLAPI LookupSymb(uint type, const char * pName, uint * pPos, uint32 * pOffs);
	int    SLAPI CheckDupSymb(uint type, const char * pName);
	int    SLAPI EnumSymb(uint type, char * pName, uint * pPos);
private:
	struct Header {
		uint32 Signature;
		uint32 DL200_Ver;
		uint32 IndexOffs;
		uint8  Reserve[20];
	};

	friend class DL2_Entry;
	friend class DL2_Row;
	friend class DL2_Group;
	friend class DL2_Data;

	int    SLAPI AddSymb(const DL2_Entry *, uint32 offs);
	int    SLAPI ReadHeader();
	int    SLAPI WriteHeader();
	int    SLAPI ReadIndex();
	int    SLAPI WriteIndex();
	int    SLAPI _ReadEntry(uint type, const char * pName, int hdrOnly, DL2_Entry *);

	Header   Head;
	SArray * P_Index;
	int    RO_Mode;   // ReadOnly mode
	char   FileName[MAXPATH];
	FILE * P_Stream;
};
//
//
//
#define DL2ENT_DATA  1
#define DL2ENT_GROUP 2
#define DL2ENT_ROW   3

class DL2_Entry {
public:
	static uint16 SLAPI ReadEntryType(FILE *);

	enum { // Flags values
		fRef = 0x0001
	};
	SLAPI  DL2_Entry(uint16 type);
	DL2_Entry & FASTCALL operator = (const DL2_Entry &);
	int    SLAPI Setup(const char * pName, const char * pDescript, int isRef);
	virtual void SLAPI destroy();
	//
	// Order of writing to stream:
	//   {(uint32)EntryType, (uint32)Flags, Name, (uint32)strlen(P_Descript), P_Descript[strlen(P_Descript)]}
	//   if(P_Descript == 0) then { (uint32)EntryType, (uint32)Flags, Name, (uint32)0 }
	//
	virtual int  SLAPI Write(DL2_Storage *) const;
	//
	// if (readed EntryType) != EntryType then error (PPERR_DL200_INVENTRYTYPE)
	//
	virtual int  SLAPI Read(FILE *);
	virtual int  SLAPI Print(FILE *) const; // @debug

	uint16 EntryType;
	uint16 Flags;
	char   Name[36];
	char * P_Descript;
};

struct DL2_Column {
	uint16 CiType;         // DL2CIT_XXX
	uint16 MaxOutSize;     // Максимальный размер выходной строки
	uint32 Flags;
	DL2_Acc CiAc;
	char * P_Title;
};
//
//
//
class DL2_Formula {
public:
	SLAPI  DL2_Formula();
	SLAPI  DL2_Formula(const DL2_Formula &);
	SLAPI ~DL2_Formula();  // no delete P_Stack (use destroy())

	void   SLAPI destroy();
	int    SLAPI Copy(const DL2_Formula *);
	int    SLAPI IsEmpty() const;
	int    SLAPI GetCount() const;
	//
	// Construction methods
	//
	int    SLAPI PushItem(const DL2_CI *);            // Imply only one expression
	int    SLAPI PushExpression(const DL2_Formula *); // Imply only one expression
	int    SLAPI AddExpression(const DL2_Formula *);  // Put new expr at tail of list
	int    SLAPI AddItem(const DL2_CI *);             // Imply only one expression
	//
	// Processing methods
	//
	DL2_CI * SLAPI Calc(int exprNo, DL2_Resolver *) const;
	const DL2_CI * SLAPI GetByN(uint /* 1.. */) const;
	//
	// Order of writing to stream:
	//   {(uint32)Size, (uint32)Count, P_Stack[Size bytes]}
	//   if(P_Stack == 0 or Size == 0) then
	//     only {(uint32)Size, (uint32)Count}
	//
	int    SLAPI Write(FILE *) const;
	int    SLAPI Read(FILE *);

	int    SLAPI Print(FILE *) const; // @debug
private:
	int    SLAPI Push(const void * pSrc, size_t srcSize);
	DL2_CI * SLAPI Calc(int exprNo, size_t pos, size_t *, DL2_Resolver *) const;
	const DL2_CI * SLAPI Get(size_t pos, size_t * pNextPos) const;
	DL2_CI * SLAPI ResolveOp(const DL2_CI *, const DL2_Formula *) const;
	//
	// Format of storing :
	// ExprList : Count times ( ExprSize [2] Expr [ExprSize-2] )
	// Expr : n times ( ItemSize [2] Item [ItemSize-2] )
	//
	uint32 Count;    // Number of Expressions
	uint32 Size;     // Total size of buffer P_Stack
	uint8 * P_Stack; // Buffer (for allocation used 'realloc', not 'new')
};

class DL2_Row : public DL2_Entry {
public:
	SLAPI  DL2_Row();
	DL2_Row & FASTCALL operator = (const DL2_Row &);
	virtual void SLAPI destroy();
	//
	// Order of writing to stream:
	//   {[DL2_Entry], P_F}
	//   if(P_F == 0) then writing empty DL2_Formula
	//
	virtual int  SLAPI Write(DL2_Storage *) const;
	virtual int  SLAPI Read(FILE *);
	virtual int  SLAPI Print(FILE *) const; // @debug

	DL2_Formula * P_F;
};

class DL2_Group : public DL2_Entry {
public:
	SLAPI  DL2_Group();
	virtual void SLAPI destroy();
	//
	// Order of writing to stream:
	//   { (uint32)getCount(), DL2_Group[getCount] }
	//
	virtual int  SLAPI Write(DL2_Storage *) const;
	virtual int  SLAPI Read(FILE *);
	virtual int  SLAPI Print(FILE *) const; // @debug
	uint   SLAPI GetMaxNesting() const;
	size_t SLAPI GetMaxDescriptionSize(uint level) const;

	uint   SLAPI GetCount() const;
	int    SLAPI AddItem(DL2_Entry *);
	int    SLAPI RemoveAll();
	DL2_Entry * SLAPI GetItem(uint) const;
protected:
	SLAPI  DL2_Group(uint16 type);
private:
	SCollection Items; // <DL2_Row> | <DL2_Group>
	//virtual void FASTCALL freeItem(void * pItem);
};

class DL2_Data : public DL2_Group {
public:
	SLAPI  DL2_Data();
	SLAPI ~DL2_Data();
	virtual void SLAPI destroy();
	virtual int  SLAPI Write(DL2_Storage *) const;
	virtual int  SLAPI Read(FILE *);
	virtual int  SLAPI Print(FILE *) const; // @debug
	//
	// Insert pColumn into columns list.
	// ! Caution: Don't destroy pColumn->P_Title after passing to this function !
	//
	int    SLAPI AddColumn(const DL2_Column * pColumn);
	int    SLAPI SearchColumnByName(const char *, uint * pPos, DL2_Column *) const;
	uint   SLAPI GetColumnsCount() const;
	const  DL2_Column * SLAPI GetColumn(uint) const;
private:
	void   SLAPI DestroyColumns();
	SArray * P_Columns;
};

class DL2_GroupStack : public SStack {
public:
	SLAPI  DL2_GroupStack();
};

struct DL2_Filt {
	char   DataSymb[36];
	DateRange Period;
	int16  Cycle;
	int16  NumCycles;
	long   Flags;
};
//
// Descr: Контейнер списков объектов. Основное назначение - заменять текстовый список
//   объектов идентификатором.
//
class DL2_ObjList : private SCollection {
public:
	SLAPI  DL2_ObjList();
	int    SLAPI Set(PPID objType, StringSet * pSs, int32 * pId);
	int    SLAPI Get(int32 id, PPID * pObjType, ObjIdListFilt & rList);
	int    SLAPI FromString(const char * pStr, PPID & rObjType, int32 * pId);
	int    SLAPI ToString(int32 id, SString & rBuf) const;
private:
	struct Item {
		int32  Id;
		int32  ObjType;
		StringSet Ss;
	};
	static int FASTCALL GetObjToken(PPID objType, SString & rToken);
	virtual void FASTCALL freeItem(void *);
};

class DL2_Resolver {
public:
	enum {
		fDoLogging = 0x0001 // Заносить в журнал процесс разбора и вычисления выражений
	};
	class SPD {
	public:
		SPD(int kind, DL2_Resolver * pR);
		virtual ~SPD();
		virtual int IsEqHdr(const SPD *) const = 0;
		virtual int Init(const DL2_Score & rS, LDATE actualDate) = 0;
		virtual DL2_CI * Resolve(const DL2_Score & rS) = 0;
		int    ResolveWarehouseList_(int32 listId, ObjIdListFilt & rList);
		int    ResolveGoodsGroupList(int32 listId, ObjIdListFilt & rList);

		int    Kind;
		enum {
			fResolved = 0x0001
		};
		long   Flags;
		DL2_Score Sc;
		DL2_Resolver * P_R; // @notowned
	};

	SLAPI  DL2_Resolver(long flags = 0);
	SLAPI ~DL2_Resolver();
	virtual DL2_CI * SLAPI Resolve(int exprNo, const DL2_CI * pCi);

	DL2_CI * SLAPI Resolve(const DL2_CI * pCi);
	DL2_CI * SLAPI ResolveScore(const DL2_Score & rSc);
	int    SLAPI ResolveName(const char * pExpression, SString & rName);
	double SLAPI Resolve(const char * pExpression);
	int    SLAPI SetPeriod(DateRange period);
	int    SLAPI SetActualDate(LDATE);
	LDATE  SLAPI GetActualDate() const;
	int    SLAPI SetCurArticle(long ar);
	long   SLAPI GetCurArticle() const;

	int    FASTCALL Log(const char * pMsg);
	int    SLAPI ReverseFormula(const char * pFormula, SString & rResult);

	DL2_ObjList Oc; // @v7.4.12 DL2_LocList Lc --> DL2_ObjList Oc
protected:
	DL2_CI * SLAPI Helper_Resolve(const DL2_Column * pCol, const DL2_CI * pCi);

	DateRange CurPeriod;
	long   CurAr;        // Номер аналитической статьи, используемый для подстановки вместо символа '*'
	long   Flags;
	PPObjAccTurn AtObj;
	PPObjPerson PsnObj;
private:
	friend class DL2_Resolver::SPD;

	PPObjLocation LocObj;
	StrAssocArray NameVars;
	LDATE  ActualDate;
	TSCollection <SPD> SpdList; // Список уже разрешенных показателей.
		// Список необходим для того, чтобы сократить время на вычисление
		// одинаковых по расчетным критериям показателей.
};

class PrcssrDL200 : public DL2_Resolver {
public:
	struct Param {
		char   FileName[MAXPATH];
		char   DataName[36];
		DateRange Period;
		PPCycleFilt Cycl;
	};
	SLAPI  PrcssrDL200();
	SLAPI ~PrcssrDL200();
	virtual DL2_CI * SLAPI Resolve(int exprNo, const DL2_CI * pCi);
	int    SLAPI InitParam(Param *);
	int    SLAPI EditParam(Param *);
	int    SLAPI Init(const Param *);
	int    SLAPI Run();
private:
	int    SLAPI ProcessRow(const DL2_Row *);
	int    SLAPI ProcessGroup(const DL2_Group *);
	int    SLAPI InitOutput();
	int    SLAPI FinishOutput();
	DBTable * SLAPI CreateHeaderDBTable();
	DBTable * SLAPI CreateIterDBTable();
	int	   SLAPI FillHeader();
	int    SLAPI Print();
	int    SLAPI CreateFileSelCombo(TDialog *, uint ctlID, char * pPath, size_t pathBufLen);
	int    SLAPI CreateFormSelCombo(TDialog *, uint ctlID, const char * pFileName, char * pSingleFormName, size_t bufLen);

	Param  P;
	DL2_Data D;
	DL2_GroupStack GStack;
	DL2_Storage Strg;

	SString OutPath;
	BDictionary * P_Dict;
	DBTable * P_HdrTbl;
	DBTable * P_IterTbl;
};
//
//
//
class BillTotalBlock {
public:
	SLAPI  BillTotalBlock(BillTotalData * pData, PPID opID, PPID goodsTypeID, int outAmtType, long flags);
	int    FASTCALL Add(PPTransferItem *);
	int    SLAPI AddPckg(const PPTransferItem *);
	int    FASTCALL Add(const PPAdvBillItem *);
	int    SLAPI Finish(const PPBillPacket * pPack);
private:
	int    SLAPI SetupStdAmount(PPID stdAmtID, PPID altAmtID, double stdAmount, double altAmount, long replaceStdAmount, int in_out);
	int    SLAPI SetupStdAmount(PPID stdAmtID, double stdAmount, int in_out);
	enum {
		stSelling            = 0x0001,
		stAllGoodsUnlim      = 0x0002,
		stAllGoodsUnlimUndef = 0x0004,
		stExtCost            = 0x0008
	};
	int    OutAmtType;
	PPID   OpID;
	PPID   GoodsTypeID;
	PPID   DynGoodsTypeForSupplAgent; // ==PPCommConfig::DynGoodsTypeForSupplAgent
	long   State;
	long   Flags;
	PPIDArray GoodsList;
	PPObjGoodsType  GTObj;
	PPObjGoods      GObj;
	PPObjAmountType ATObj;
	BillTotalData * P_Data;
};
//
//
//
class BillContext : public ExprEvalContext {
public:
	enum {
		funcAmountByVat  = EXRP_EVAL_FIRST_FUNC + 1, // amountbyvat(x)
		funcAmountByGVat = EXRP_EVAL_FIRST_FUNC + 2, // amountbygvat(x)
			// Сумма документа по строкам, товары которых облагаются указанной ставкой НДС.
			// Отличается от amountbyvat тем, что суммируются строки, по которым не эффективная,
			// но номинальная (то есть, заданная для товара) ставка НДС равна указанной.
		funcAmountByTVat = EXRP_EVAL_FIRST_FUNC + 3, // amountbytvat(oid(GOODSTYPE, id), x)
			// Сумма документа по строкам, товары которых принадлежат типу oid(GOODSTYPE, id) и
			// облагаются ставкой НДС x%. То есть, результат аналогичен amountbyvat с той
			// разницей, что суммирование ограничивается товарами с типом oid(GOODSTYPE, id).
		funcCostByVat    = EXRP_EVAL_FIRST_FUNC + 4, // costbyvat(x)
		funcCostVat      = EXRP_EVAL_FIRST_FUNC + 5, // costvat(x)
		funcPriceByVat   = EXRP_EVAL_FIRST_FUNC + 6, // pricebyvat(x)
		funcPriceVat     = EXRP_EVAL_FIRST_FUNC + 7, // pricevat(x)
	};

	SLAPI  BillContext(const PPBillPacket * p, PPID curID, uint advLineIdx);
	virtual int SLAPI Resolve(const char * pSymb, double * pVal);
	virtual int SLAPI IsFunc(const char * pSymb, int * pFuncId);
	virtual int SLAPI ResolveFunc(int funcId, FC & rFc);
private:
	int    SLAPI CalcTotalBlock();
	int    SLAPI ProcessLink(PPID linkBillID, PPID amtID, int artefactSymb, PPID addCurID, int errOnDefault, double * pResult);

	const  PPBillPacket * P_Pack;
	BillTotalData Bt;
	PPID   LinkID;
	PPID   ReckonID;
	PPID   CurID;
	uint   AdvLineIdx;
};
//
//
//
class DL200_Context : public ExprEvalContext {
public:
	SLAPI  DL200_Context(DL2_Resolver * pResolver, BillContext * pBillCtx = 0);
	virtual int SLAPI Resolve(const char * pSymb, double * pVal);
	virtual int SLAPI IsFunc(const char * pSymb, int * pFuncId);
	virtual int SLAPI ResolveFunc(int funcId, FC & rFc);
private:
	DL2_Resolver * P_Resolver;
	BillContext * P_BillCtx;   // @notowned
	StrAssocArray FuncList;
	long   LastFuncId;
};
//
// @ModuleDecl(Generator_GnuPlot)
//
class PPGpStyle {
public:
	PPGpStyle();
	int    SetLine(COLORREF c, float width);
	int    SetPoint(COLORREF c, int type, float size);
	//
	// Descr: Устанавливает стиль точки с переменным цветом.
	//   Цвет определяется одной из переменных входящих данных.
	//
	int    SetPointVarColor(int type, float size);
	int    SetFill(int type, long ext, int noborder);
	int    ToStr(SString & rBuf) const;

	enum {
		kLine = 1,
		kPoint,
		kFill
	};
	enum {
		fIndex         = 0x0001, // Используется предопределенный стиль индексом Idx
		fVariableColor = 0x0002, // variable color (последний индекс данных должен содержать
			// ссылку на колонку, определяющую цвет)
		fNoBorder      = 0x0004  // kFill noborder
	};
	//
	// Descr: Типы точек графика
	//
	enum {
		ptNone = -1,
		ptDot = 0,
		ptCross,
		ptX,
		ptAsterix,
		ptSq,           // Квадрат
		ptSqF,          // Закрашенный квадрат
		ptCircle,
		ptCircleF,
		ptTrUp,         // Треугольник (угол вверх)
		ptTrUpF,        // Закрашенный треугольник (угол вверх)
		ptTrDn,         // Треугольник (угол вниз)
		ptTrDnF         // Закрашенный треугольник (угол вниз)
	};
	//
	// Descr: Стили заполнения (fill style) //
	//
	enum {
		ftDefault = -1, // По умолчанию
		ftEmpty = 0,    // Пустое
		ftSolid,        // Сплошное. Цвет определяется текущим стилем линии.
			// Ext определяет процент интенсивности цвета. Если Ext == 100 или Ext == 0,
			// то полная интенсивность
		ftPattern       // Шаблон заполнения. Ext - индекс шаблона [1..7]
	};
	int   Kind;
	long  Idx;
	int   T;
	long  Ext;   // Дополнительный параметр типа стиля //
	long  Flags; // fXXX
	COLORREF C;
	float Sz;    // Размер. Для линий [1..6]
};

class PPGpPlotItem {
public:
	PPGpPlotItem(const char * pSrc, const char * pTitle, int plotStyle = 0);
	int    AddDataIndex(int idx);
	int    AddDataIndex(const char * pFunc);
	int    ToStr(SString & rBuf) const;
	enum {
		sDefault,
		sLines,
		sPoints,
		sLinesPoints,
		sImpulses,
		sDots,
		sSteps,
		sFSteps,
		sHiSteps,
		sErrorBars,
		sLabels,
		sXErrorBars,
		sYEerrorBars,
		sXYErrorBars,
		sErrorLines,
		sXErrorLines,
		sYErrorLines,
		sXYErrorLines,
		sBoxes,
		sHistograms,
		sFilledCurves,
		sBoxErrorBars,
		sBoxXYErrorBars,
		sEnanceBars,
		sCandleSticks,
		sVectors,
		sImage,
		sRgbImage,
		sPm3d
	};
	enum {
		fDataFile = 0x0001
	};
	int    S;
	long   Flags;
	PPGpStyle Style;
	SString DataSrc; // Источник данных. Если Flags & fDataFile, то это - имя файла (если пусто, то '-').
	SString Title;
private:
	LongArray IdxList;
	StrAssocArray StrIdxList;
};

class PPGpTicsList {
public:
	PPGpTicsList(int type);
	int    Add(double val, const char * pText, int level = 0);
	int    Add(const LDATETIME & rVal, const char * pText, int level = 0);
	int    ToStr(SString &) const;
private:
	union V {
		double R;
		LDATETIME D;
	};
	struct Item {
		V      Val;
		int    Level;
		SString Text;
	};
	int    T; // 0 - real, 1 - datetime
	TSCollection <Item> List;
};

class Generator_GnuPlot : public SFile {
public:
	enum {
		axX,
		axY,
		axZ,
		axX2,
		axY2,
		axZ2
	};
	struct PlotParam {
		PlotParam();
		enum {
			fLines     = 0x00000001,
			fDots      = 0x00000002,
			fPoints    = 0x00000004,
			// @#{fLines^fDots^fPoints}
			fNoTitle   = 0x00000008,
			fHistogram = 0x00000010,
			fPm3D      = 0x00000020,
			fDGrid3D   = 0x00000040,
			fStereo    = 0x00000080
		};
		long   Flags;
		StrAssocArray Legend;
	};
	struct StyleFont {
		StyleFont();
		SString Face;
		uint   Size;
	};
	struct StyleTics {
		StyleTics();
		long   Flags;
		int    Rotate;
		StyleFont Font;
	};

	static SString & ColorToStr(COLORREF c, SString & rBuf);

	Generator_GnuPlot(const char * pFileName);
	const char * SLAPI GetDataFileName() const;
	int    Preamble();
	int    Cmd(const char *);
	int    SetTitle(const char *);
	int    SetAxisTitle(int axis, const char *);
	int    SetAxisRange(int axis, double lo, double hi);
	int    UnsetTics(int axis);
	int    SetTics(int axis, const StyleTics * pStyle);
	int    SetTicsInc(int axis, double inc);
	int    SetTicsInc(int axis, double inc, double low, double upp);
	int    SetTicsInc(int axis, long incSec, LDATE low, LDATE upp);
	int    SetTicsList(int axis, const PPGpTicsList &);
	int    AddTicsExplicit(int axis, double val, const char * pText, int level = 0);
	int    AddTicsExplicit(int axis, const LDATETIME & rVal, const char * pText, int level = 0);
	int    SetGrid();
	int    SetStyleFill(const char * pFillStyle);
	int    SetDateTimeFormat(int axis, int usingTime = 0);

	int    DeclareLineStyle(long idx, const PPGpStyle * pStyle);
	int    AddPlotItem(const PPGpPlotItem & rItem);

	int    StartData(int putLegend);
	void   FASTCALL PutData(LDATE);
	void   FASTCALL PutData(LTIME);
	void   FASTCALL PutData(long);
	void   PutData(LDATETIME);
	void   PutData(double);
	void   PutData(const char *, int withoutQuot = 0);
	int    PutEOR();
	int    PutEndOfData();
	int    Plot(const PlotParam *);
	int    Run();
private:
	SString & Set();
	SString & SetStyle();
	SString & AxisLetter(int axis);
	SString & Font(const StyleFont & rFont);
	SString & Color(COLORREF);
	SString & SetTics(int axis);
	int    PutLine();
	int    PutDataLine();

	SString LineBuf;
	SString DataFileName;
	SFile  DataFile;
	PlotParam Param;
	TSCollection <PPGpPlotItem> Items;
};
//
// Descr: Класс, управляющий шаблонизированным выводом данных DL600
//
class Tddo {
public:
	enum {
		ftTddo = 1,
		ftTddt
	};
	static int SLAPI GetFileName(const char * pFileName, int fileType, const char * pInputFileName, SString & rResult);
	static int SLAPI LoadFile(const char * pName, SString & rBuf);

	SLAPI  Tddo();
	SLAPI ~Tddo();
	//
	// Descr: Реализует обработку шаблона из буфера pBuf. Данные извлекаются из
	//   структуры данных DL600, определенной в теле шаблона. Если эта структура
	//   или ее родитель не совпадает со структурой, заданной наименованием pDataName,
	//   то возвращает ошибку. Данные инициализируются посредством параметров dataId и pDataPtr.
	//   Результат выводится в буфер rOut.
	//
	//int    SLAPI Process(const char * pDataName, const char * pBuf, long dataId, void * pDataPtr, const StringSet * pExtParamList, SBuffer & rOut);
	int    SLAPI Process(const char * pDataName, const char * pBuf, DlRtm::ExportParam & rEp, const StringSet * pExtParamList, SBuffer & rOut);
	//
	// Descr: Устанавливает имя входного файла. В общем случае, имя входного файла может быть
	//   пустым (поскольку функция Process обрабатывает входной поток символов из RAM), но при обработке
	//   ошибок и для правильной идентификации пути внутренних файлов имя файла может быть востребовано.
	//
	int    SLAPI SetInputFileName(const char * pFileName);
private:
	struct Meta {
		Meta();
		Meta & FASTCALL operator = (const Meta & rS);
		void   Clear();

		int    Tok;
		SString Text;
		SString Param;
	};
	struct ProcessBlock {
		ProcessBlock();

		SString SrcDataName;
		DlRtm::ExportParam Ep;
		DlRtm * P_Rtm;
		PPFilt F;
	};
	struct Result {
		Result();
		Result & Clear();

		SString S;
		DLSYMBID RefType;
		long    RefID;
	};
	int    FASTCALL ScanMeta(Meta & rM);
	int    SLAPI Helper_Process(ProcessBlock & rBlk, SBuffer & rOut, Meta & rMeta, const DlScope * pScope, int skipOutput);
	int    SLAPI ResolveVar(const SString & rText, const DlScope * pScope, Result & rR);
	int    SLAPI ResolveArgN(const SString & rText, Result & rR);
	int    SLAPI ResolveExpr(DlRtm * pRtm, const DlScope * pScope, DlRtm * pCallerRtm, SStrScan & rScan, Result & rR);
	int    SLAPI GetVar(const SString & rInput, SString & rBuf) const;
	int    SLAPI IsTextSection(const SString & rLineBuf, const char * pPattern, SString * pRet);
	int    SLAPI ExtractText(const char * pFileName, const char * pTextIdent, int langId, SBuffer & rOut);

	enum {
		stStart = 0x0001
	};
	enum {
		tNone = 0,
		tRem,
		tStart,
		tEnd,
		tIter,
		tVar,
		tFunc,
		tVarArgN,
		tCodepage,
		//
		// Далее следуют простые токены, распознаваемые ScanMeta(meta, scanSimpleToken)
		//
		tString,
		tSymbol,
		tNumber,
		tExpr,
		tPragma,
		tIf,
		tElse,
		tElif,
		tEndif,
		tText,     // @v7.5.10
		tInclude,  // @v7.5.10
		tIterCount // @v7.6.5
	};
	enum {
		fHtmlEncode  = 0x0001 // Кодировать специальные символы в извлекаемых полях html-сущностями
	};
	SStrScan Scan;
	long   ReH_Meta;
	long   ReH_Var;
	long   ReH_VarShort;
	long   ReH_VarArgN;
	long   ReH_VarArgNShort;
	long   ReH_RemLine;
	long   ReH_If;
	long   ReH_Elif;
	long   ReH_String;
	long   Flags;
	uint   LineNo;
	SCodepageIdent Cp;
	DlContext * P_Ctx;
	SString InputFileName;
	StringSet ExtParamList;
	StringSet ErrMsgList;
};
//
//
//
class SUnicodeTable : public SStrGroup {
public:
	enum {
		gcUnkn = 0,
		gcLu, // Uppercase_Letter 	an uppercase letter
		gcLl, // Lowercase_Letter 	a lowercase letter
		gcLt, // Titlecase_Letter 	a digraphic character, with first part uppercase
		gcLC, // Cased_Letter 	Lu | Ll | Lt
		gcLm, // Modifier_Letter 	a modifier letter
		gcLo, // Other_Letter 	other letters, including syllables and ideographs
		gcL,  // Letter 	Lu | Ll | Lt | Lm | Lo
		gcMn, // Nonspacing_Mark 	a nonspacing combining mark (zero advance width)
		gcMc, // Spacing_Mark 	a spacing combining mark (positive advance width)
		gcMe, // Enclosing_Mark 	an enclosing combining mark
		gcM,  // Mark 	Mn | Mc | Me
		gcNd, // Decimal_Number 	a decimal digit
		gcNl, // Letter_Number 	a letterlike numeric character
		gcNo, // Other_Number 	a numeric character of other type
		gcN,  // Number 	Nd | Nl | No
		gcPc, // Connector_Punctuation 	a connecting punctuation mark, like a tie
		gcPd, // Dash_Punctuation 	a dash or hyphen punctuation mark
		gcPs, // Open_Punctuation 	an opening punctuation mark (of a pair)
		gcPe, // Close_Punctuation 	a closing punctuation mark (of a pair)
		gcPi, // Initial_Punctuation 	an initial quotation mark
		gcPf, // Final_Punctuation 	a final quotation mark
		gcPo, // Other_Punctuation 	a punctuation mark of other type
		gcP,  // Punctuation 	Pc | Pd | Ps | Pe | Pi | Pf | Po
		gcSm, // Math_Symbol 	a symbol of mathematical use
		gcSc, // Currency_Symbol 	a currency sign
		gcSk, // Modifier_Symbol 	a non-letterlike modifier symbol
		gcSo, // Other_Symbol 	a symbol of other type
		gcS,  // Symbol 	Sm | Sc | Sk | So
		gcZs, // Space_Separator 	a space character (of various non-zero widths)
		gcZl, // Line_Separator 	U+2028 LINE SEPARATOR only
		gcZp, // Paragraph_Separator 	U+2029 PARAGRAPH SEPARATOR only
		gcZ,  // Separator 	Zs | Zl | Zp
		gcCc, // Control 	a C0 or C1 control code
		gcCf, // Format 	a format control character
		gcCs, // Surrogate 	a surrogate code point
		gcCo, // Private_Use 	a private-use character
		gcCn, // Unassigned 	a reserved unassigned code point or a noncharacter
		gcC,  // Other 	Cc | Cf | Cs | Co | Cn
	};
	enum {
		cccNot_Reordered        =   0, // Spacing and enclosing marks; also many vowel and consonant signs, even if nonspacing
		cccOverlay              =   1, // Marks which overlay a base letter or symbol
		cccNukta                =   7, // Diacritic nukta marks in Brahmi-derived scripts
		cccKana_Voicing         =   8, // Hiragana/Katakana voicing marks
		cccVirama               =   9, // Viramas
		cccAttached_Below_Left  = 200, // Marks attached at the bottom left
		cccAttached_Below       = 202, // Marks attached directly below
		cccAttached_BottomRight = 204, // Marks attached at the bottom right
		cccAttached_Left        = 208, // Marks attached to the left
		cccAttached_Right       = 210, // Marks attached to the right
		cccAttached_TopLeft     = 212, // Marks attached at the top left
		cccAttached_Above       = 214, // Marks attached directly above
		cccAttached_Above_Right = 216, // Marks attached at the top right
		cccBelow_Left           = 218, // Distinct marks at the bottom left
		cccBelow                = 220, // Distinct marks directly below
		cccBelow_Right          = 222, // Distinct marks at the bottom right
		cccLeft                 = 224, // Distinct marks to the left
		cccRight                = 226, // Distinct marks to the right
		cccAbove_Left           = 228, // Distinct marks at the top left
		cccAbove                = 230, // Distinct marks directly above
		cccAbove_Right          = 232, // Distinct marks at the top right
		cccDouble_Below         = 233, // Distinct marks subtending two bases
		cccDouble_Above         = 234, // Distinct marks extending above two bases
		cccIota_Subscript       = 240  // Greek iota subscript only
	};
	enum {
		bidiUnkn = 0,
		bidiL,   // Left_To_Right 	any strong left-to-right character
		bidiR,   // Right_To_Left 	any strong right-to-left (non-Arabic-type) character
		bidiAL,  // Arabic_Letter 	any strong right-to-left (Arabic-type) character
		bidiEN,  // European_Number 	any ASCII digit or Eastern Arabic-Indic digit
		bidiES,  // European_Separator 	plus and minus signs
		bidiET,  // European_Terminator 	a terminator in a numeric format context, includes currency signs
		bidiAN,  // Arabic_Number 	any Arabic-Indic digit
		bidiCS,  // Common_Separator 	commas, colons, and slashes
		bidiNSM, // Nonspacing_Mark 	any nonspacing mark
		bidiBN,  // Boundary_Neutral 	most format characters, control codes, or noncharacters
		bidiB,   // Paragraph_Separator 	various newline characters
		bidiS,   // Segment_Separator 	various segment-related control codes
		bidiWS,  // White_Space 	spaces
		bidiON,  // Other_Neutral 	most other symbols and punctuation marks
		bidiLRE, // Left_To_Right_Embedding 	U+202A: the LR embedding control
		bidiLRO, // Left_To_Right_Override 	U+202D: the LR override control
		bidiRLE, // Right_To_Left_Embedding 	U+202B: the RL embedding control
		bidiRLO, // Right_To_Left_Override 	U+202E: the RL override control
		bidiPDF, // Pop_Directional_Format 	U+202C: terminates an embedding or override control
		bidiLRI, // Left_To_Right_Isolate 	U+2066: the LR isolate control
		bidiRLI, // Right_To_Left_Isolate 	U+2067: the RL isolate control
		bidiFSI, // First_Strong_Isolate 	U+2068: the first strong isolate control
		bidiPDI  // Pop_Directional_Isolate 	U+2069: terminates an isolate control
	};
	enum {
		fBidiMirrored = 0x0001,
		fRange        = 0x0002
	};
	struct Item32 {
		SLAPI  Item32();
		uint32 U4;
		uint8  Gc;   // General category
		uint8  Ccc;  // Canonical Combining Class
		uint8  Bidi; // Bidi Class
        uint8  Flags;
		uint   DescrP;
		uint16 SNScriptId;
	};
	struct UPair {
		SLAPI  UPair(uint32 key, uint32 val);
		uint32 K;
		uint32 V;
	};

	static uint32 FASTCALL ParseUnicode(SString & rBuf);

	SLAPI  SUnicodeTable();
	uint32 FASTCALL GetU(uint idx) const;
	uint   FASTCALL GetIndex(uint32 u) const;
	const  Item32 * FASTCALL Get(uint32 u) const;

	int    SLAPI ParseSource(const char * pFileName);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);

	uint32 FASTCALL ToLower(uint32 u) const;
	uint32 FASTCALL ToUpper(uint32 u) const;
	uint32 FASTCALL ToCapital(uint32 u) const;
private:
	int    SLAPI PreprocessLine(SString & rLine) const;
	int    SLAPI ParseDescription(SString & rDescr, SUnicodeTable::Item32 & rD);

	uint   LastIdx;
	TSArray <Item32> List32;
	TSArray <UPair> Ranges;
	TSArray <UPair> SimpleToUpAndCap;
	TSArray <UPair> SimpleToUp;
	TSArray <UPair> SimpleToCap;
	TSArray <UPair> SimpleToLo;
	TSArray <UPair> MirrorPairs;
};

class SCodepageMapPool : public SStrGroup {
private:
	struct CMapTranslIndexTest;
public:
	struct MapEntry {
		SLAPI  MapEntry();
		int    FASTCALL operator == (const MapEntry & rS) const;
		int    FASTCALL operator != (const MapEntry & rS) const;
		int    FASTCALL Cmp(const MapEntry & rS) const;

		uint8  B[4]; // от B[0] до B[3] в порядке следования символов в строке
		uint16 U2;
	};
	enum {
		fHas4U    = 0x0001, // Один или более элементов таблицы имеет unicode-символ шириной более 2 байт
		fSolid256 = 0x0002, // Таблица представляет собой сплошной (без разрывов) участок внутри 256-байтового диапазона.
			// Если таблица содержит менее 256 элементов, то поле Solid256Offs указывает на первый элемент.
		fHas3B    = 0x0004  // Один или более элементов таблицы имеет MB код, содержащий 3 байта
	};
	struct CpMap {
		SLAPI  CpMap();
		void   SLAPI Clear();
		//
		// Descr: Ищет мультибайтовый символ b[] в таблице.
		//   Длина массива b[] не должна превышать 4 байт. Если
		//   в массиве менее 4 байт, то следующий за последним значащим байтом должен быть 0.
		//
		const  MapEntry * FASTCALL SearchC(const uint8 b[]) const; // Test - very slow func
		const  MapEntry * FASTCALL SearchU(wchar_t u, const LongArray * pIdx) const;
		const  MapEntry * FASTCALL SearchU(uint32 u) const; // Test - very slow func
		const  MapEntry * FASTCALL SearchFallback(uint32 u) const;
		int    SLAPI TranslateToU(const uint8 * pSrc, size_t srcLen, SStringU & rBuf) const;
		int    SLAPI TranslateToB(const wchar_t * pSrc, size_t srcLen, SString & rBuf) const;
		//
		// Descr: Testing function
		//
		const  MapEntry * Test_ToLower(const MapEntry * pSrc, const SUnicodeTable * pUt) const;
		const  MapEntry * Test_ToUpper(const MapEntry * pSrc, const SUnicodeTable * pUt) const;
		const  MapEntry * Test_ToCapital(const MapEntry * pSrc, const SUnicodeTable * pUt) const;

		int    SLAPI MakeUIndex(LongArray & rIdx) const;

		SCodepage Id;
		uint8  MbMl;    // Максимальная длина мультибайтовых символов (в байтах)
		uint8  Solid256Offs;  // Если Flags & fSolid256, то это поле - смещение от нуля
		uint16 StraightCount; // Количество элементов с начала таблицы, порядковый номер которых совпадает с байтовым значением.
		uint16 CpSis;   //
		uint16 Flags;
		uint   MapCount;
		uint   FallbackCount;
		uint   NScriptCount;
		const  MapEntry * P_Map;
		const  MapEntry * P_Fallback;
		const  uint16 * P_NScript;
		SString Name;
		SString Code;
		SString Version;
	private:
		int   FASTCALL Helper_BSearchB(uint32 b4, wchar_t * pU) const;
	};
	//
	// Descr: Временная структура для построения таблицы преобразования символьных таблиц
	//
	struct CMapTranslEntry {
		CMapTranslEntry()
		{
			THISZERO();
		}
		enum {
			fNone     = 0x0001,
			fFallback = 0x0002,
			fEqual    = 0x0004
		};
		uint8  S[4];
		uint8  D[4];
		uint8  F;
	};
	class TranslIndex {
	public:
		friend class SCodepageMapPool;

		SLAPI  TranslIndex();
		SLAPI  TranslIndex(const TranslIndex & rS);
		SLAPI ~TranslIndex();
		int    FASTCALL Copy(const TranslIndex & rS);
		TranslIndex & FASTCALL operator = (const TranslIndex & rS);
		const  uint8 * FASTCALL Search(const uint8 * pSrc) const;
	private:
		void   SLAPI Reset();
		size_t SLAPI GetEntrySize() const;
		int    SLAPI Setup(const SCodepageMapPool::CMapTranslIndexTest & rS);

		enum {
			fIdentical = 0x0001,
			fEmpty     = 0x0002
		};
		void * P_Tab;
		uint32 Count; // Количество элементов в P_Tab
		uint8  SL;
		uint8  DL;
		uint16 IdenticalCount;
		uint32 Flags;
	};

	SLAPI  SCodepageMapPool();
	void   SLAPI Clear();
	uint   SLAPI GetCount() const;
	int    SLAPI GetByPos(uint pos, CpMap * pM) const;
	int    SLAPI Get(SCodepage cp, CpMap * pM) const;
	int    SLAPI GetByName(const char * pName, CpMap * pM) const;
	//
	// Descr: Сравнивает две таблицы на идентичность.
	//
	uint   SLAPI Compare(const CpMap & rS1, const CpMap & rS2) const;
	uint   SLAPI Translate(const CpMap & rFrom, const CpMap & rTo, const uint8 * pSrc, size_t srcLen, SString & rDest);

	int    SLAPI ParseXml(const char * pPath, SUnicodeTable * pUt);
	int    SLAPI Serialize(int dir, SBuffer & rBuf, SSerializeContext * pSCtx);
	int    SLAPI Test(const SUnicodeTable * pUt);
	int    SLAPI MakeTranslIndex(const CpMap & rFrom, const CpMap & rTo, TranslIndex & rIdx);
private:
	struct CpEntry {
		SCodepage Id;
		uint8  MbMl;          // Максимальная длина мультибайтовых символов (в байтах)
		uint8  Solid256Offs;  // Если Flags & fSolid256, то это поле - смещение от нуля
		uint16 StraightCount; // Количество элементов с начала таблицы, порядковый номер которых совпадает с байтовым значением.
		uint16 CpSis;         //
		uint16 Flags;         //
		uint32 NameP;         //
		uint32 CodeP;         //
		uint32 VersionP;      //
		uint32 MapStart;      // Начальная позиция в MeL
		uint32 MapCount;      // Количество позиций в MeL
		uint32 FallbackStart; // Начальная позиция в FbL
		uint32 FallbackCount; // Количество позиций в FbL
		uint32 NScriptStart;  // Начальная позиция списка натуральных скриптов в кодовой странице
		uint32 NScriptCount;  // Количество натуральных скриптов в кодовой странице
	};
	struct CMapTranslIndexTest : TSArray <CMapTranslEntry> {
		CMapTranslIndexTest();
		void   Reset();
		//
		// Descr: Сортирует элементы массива по возрастанию CMapTranslEntry::S
		//
		void   Sort();

		uint   MaxSLen;
		uint   MaxDLen;
		uint   IdenticalCount;
		uint   SuccCount;
		uint   FallbackCount;
	};
	int    SLAPI ParseCpName(const SString & rName, int * pSis, SString & rCode, SString & rVersion) const;
	int    SLAPI ParseSymbols(SString & rU, const SString & rMb, MapEntry & rEntry, uint8 * pMbMl) const;
	int    SLAPI ParseXmlSingle(void * pXmlContext, const char * pFileName, SUnicodeTable * pUt);
	int    SLAPI TranslateEntry(const CpEntry & rSrc, CpMap & rDest) const;
	int    SLAPI SearchMapSeq(const TSArray <MapEntry> & rSeq, uint * pPos) const;
	int    SLAPI Helper_MakeTranslIndex(const CpMap & rFrom, const CpMap & rTo, CMapTranslIndexTest & rIdx, TranslIndex & rFinalIdx);

	TSArray <CpEntry> CpL;
	TSArray <MapEntry> MeL; // Список соответствий multibyte-unicode. Отрезок каждой таблицы отсортирован по B[4]
	TSArray <MapEntry> FbL; // Список fallback-соответствий. Отрезок каждой таблицы отсортирован по U2
	TSArray <uint16> NScrL; // Список натуральных скриптов, присутствующих в кодовых страницах
};

class SUnicodeBlock {
public:
    SLAPI  SUnicodeBlock();
    SLAPI ~SUnicodeBlock();

    int    SLAPI ReadRaw(const char * pUnicodePath, const char * pCpPath);
    int    SLAPI Read(const char * pFileName);
    int    SLAPI Write(const char * pFileName);

	SUnicodeTable Ut;
	SCodepageMapPool Cpmp;
private:
    struct StrgHeader { // @size=32
        uint32 Signature; // UTCP = 0x50435455
        uint32 Version;
        uint32 Flags;
        uint32 CRC;       // CRC32 сериализованного буфера данных (заголовок не включен)
        uint8  Reserve[16]; // @reserve
    };
};
//
// Descr: Идентификаторы распознаваемых натуральных токенов.
//   @persistent
//   Символьные обозначения токенов находятся в строке PPTXT_NATURALTOKENID
//
#define PPNTOK_UNKN           0
#define PPNTOK_NATURALWORD    1
#define PPNTOK_DIGITCODE      2
#define PPNTOK_EAN13          3
#define PPNTOK_EAN8           4
#define PPNTOK_UPCA           5
#define PPNTOK_UPCE           6
#define PPNTOK_RU_INN         7
#define PPNTOK_EGAISWARECODE  8 // Код алкогольной продукции ЕГАИС
#define PPNTOK_EGAISMARKCODE  9 // Код акцизной марки алкогольной продукции ЕГАИС
#define PPNTOK_LUHN          10 // Цифровая последовательность с контрольной цифрой по алгоритму LUHN в конце
#define PPNTOK_DIGLAT        11 // Алфавитно-цифровая последовательность (содержащая только цифры и латинские символы)
#define PPNTOK_GUID          12 // Общепринятое текстовое представление GUID
#define PPNTOK_EMAIL         13 // Адрес электронной почты
#define PPNTOK_PHONE         14 // Номер телефона
#define PPNTOK_IMEI          15 // Код IMEI (с контрольной цифрой по алгоритму LUHN в конце)

#define PPNTOKSEQ_DEC        1 // 0-9
#define PPNTOKSEQ_HEX        2 // A-F||a-f
#define PPNTOKSEQ_LATUPR     3 // A-Z
#define PPNTOKSEQ_LATLWR     4 // a-z
#define PPNTOKSEQ_DECLAT     5 // 0-9||A-F||a-f
#define PPNTOKSEQ_ASCII      6 // 1-127
#define PPNTOKSEQ_UTF8       7
#define PPNTOKSEQ_1251       8
#define PPNTOKSEQ_866        9

struct PPNaturalTokenStat {
	SLAPI  PPNaturalTokenStat();
    uint32 Len;  // Длина токена в байтах
    uint32 Seq;
};

struct PPNaturalToken {
	uint32 ID;
	float  Prob;
};

class PPNaturalTokenArray : public TSArray <PPNaturalToken> {
public:
	float  FASTCALL Has(uint32 tok) const;
	int    SLAPI Add(uint32 tok, float prob);
};

class PPTokenRecognizer : public SRegExpSet {
public:
	SLAPI  PPTokenRecognizer();
	SLAPI ~PPTokenRecognizer();
	int    SLAPI Run(const uchar * pToken, PPNaturalTokenArray & rResultList, PPNaturalTokenStat * pStat);
private:
	static int FASTCALL IsUtf8(const uchar * p, size_t restLen);
};
//
//
//
extern "C" typedef int (*TextAnalyzerSignalProc)(const char * pResource, int64 orgOffs, const char * pOrgStr, const char * pSignalStr, void * pExtraPtr);

// %/тушь%&(синяя%|синий%|син%.)%/%!keyword синяя тушь для ресниц

class PPTextAnalyzer : public STokenizer {
public:
	class Replacer {
	public:
		friend class PPTextAnalyzer;

		struct Term {
			int16  Type;
			int16  Tok;
			uint32 Id;
		};
		class Chain : public TSArray <Term> {
		public:
			Chain();
			Chain & FASTCALL operator = (const Chain & rS);
			int    Add(int type, int tok, uint32 id);
			//
			// Descr: Вспомогательная функция, используемая для формирования сложных выражений,
			//   сформулированных в инфиксной форме.
			//   Сначала в список добавляется 'лемент {type, 0, rInner.getCount}, а вслед
			//   за ним сразу следуют записи из rInner.
			//
			int    Add(int type, const PPTextAnalyzer::Replacer::Chain & rInner);
		};

		static int FASTCALL IsOp(int termType);
		static int FASTCALL IsLex(int termType);

		Replacer();
		~Replacer();
		int    InitParsing(const char * pFileName);
		void   IncLineNo();
		long   SetState(long st, int set);
		long   GetState() const;
		uint   SearchTarget(const Replacer::Chain & rChain) const;
		LongArray * SearchCortege(uint cortegeId) const;

		int    AddCortegeItem(uint cortegeId, uint srcListIdx);

		enum {
			stError   = -1, // Ошибка в терме
			stLiteral = 0,
			// 1..100 - номер группы для замены %1..%100
			stSpace = 101,     // %s [ \t]+
			stSpaceMul,        // %z [ \t]*
			stSpaceSingle,     // %_ ' '
			stEmpty,           // %E Пустое выражение (только для целевого определения)
			stTab,             // %t Табуляция //
			stDotOpt,          // %. Опциональная точка
			stHyphenOpt,       // %- Опциональный дефис
			stBegin,           // %^ Начало текста
			stEnd,             // %$ Конец текста
			stNum,             // %d term [0-9]+
			stNumL,            // %D[0-9][0-9] term Число с заданным количеством знаков. Длина хранится в Term::Tok
			stFloat,           // %f term [0-9]+(.[0-9]+)?
			stWord,            // %w term любая последовательность символов, отличная от разделителя //
			stLPar,            // %( начало группы
			stRPar,            // %) завершение группы
			stAny,             // %* Любая (не пустая) последовательность токенов
			stCortege,         // %@cortegename. Совпадение с одним из элементов кортежа (нельзя использовать в целевом определении)
			stPercent,         // %% литеральный '%'

			stLastLex,         // Служебное значение для отделения лексических типов термов от операторов
			//
			// Note: Принципиально важно, чтобы операторы stOpTo, stOpFrom, stOpOr имели меньшее значение чем
			//   stOpCapital, stOpLower, stOpUpper: после сортировки списка TSCollection <Replacer::SrcItem>
			//   сначала будут обрабатываться элементы с меньшим значением оператора.
			//
			stOpTo,            // %> single infix
			stOpFrom,          // %< single infix
			stOpOr,            // %| multi  infix
			stOpAnd,           // %& AND (применяется только внутри контекста)
			stOpCortege,       // %= single infix Один или более образцов, ассоциированных с именующим символом
			stOpSignal,        // %! single infix Аналогично stOp, но преобразованный текст не замещает оригинальный,
				// а возвращается посредством callback-процедуры вызывающей функции для специализированной обработки.

			stOpCapital,       // %K single suffix Слово преобразовывать к виду: первый символ прописной, остальные - строчные
			stOpLower,         // %a single suffix Слово преобразовывать к виду: все символы строчные
			stOpUpper,         // %A single suffix Слово преобразовывать к виду: все символы прописные

			stOpClusterStart,  // %{
			stOpClusterEnd,    // %}

			stOpComment,       // %--
			stOpPragma,        // %#

			stOpContext        // %/ Контекст (обрамляется с обеих сторон такими символами: %/apple%/
		};

		struct SrcItem {
			SrcItem();
			const  SSzChunk * FASTCALL GetTermGroup(uint termIdx, uint * pGrpIdx) const;

			enum {
				fContext = 0x0001 //
			};
			int    Op;
			uint   TargetIdx; // Если Op == stOpCortege, то TargetIdx равен индексу токена имени кортежа
			long   Flags;
			Chain  List;
			TSArray <SSzChunk> GL; // Список групп
		};
		struct TargetItem {
			Chain  List;
		};
		TSCollection <Replacer::SrcItem> SrcList;
		TSCollection <Replacer::TargetItem> TargetList;
		//
		// Descr: Элемент списка кортежей. Индексирует соответствие идентификатора кортежа списку
		//   записей SrcList.
		//
		struct CortegeItem {
			uint   CortegeId;
			LongArray SrcListIdxList;
		};

		TSCollection <CortegeItem> CrtgList;
		//
	private:
		Replacer::SrcItem * MakeSrcItem(Replacer::SrcItem * pOuterSrcItem, int op, uint targetIdx, const Chain & rList, const TSArray <SSzChunk> & rGl) const;
		int    AddClusterItem(Replacer::SrcItem * pItem);
		int    BuildSrcIndex();

		LongArray SrcListIndex; // Позиции элементов SrcList в том порядке, в котором должны обрабатываться при обработке текста
		//
		// Поля, используемые при разборе файла определения правил замены
		//
		enum {
			psCluster      = 0x0001, // Разбор находится в состоянии открытого кластера %{%}
			psSyntaxSimple = 0x0002,
			psContext      = 0x0003  // Разбор находится в состянии обработки контекста %/%/
		};
		SString FileName; // Имя исходного файла
		uint   LineNo;    // Номер строки исходного файла
		long   State;     // Флаги состояния разбора
		TSCollection <Replacer::SrcItem> * P_Cluster;
	};
	//
	// Descr: Элемент списка результатов поиска образца Replacer::SrcItem в тексте this
	//
	struct FindItem {
		uint   GrpIdx;    // Позиция группы в Replacer::SrcItem. 0 - общий результат
		uint   IdxFirst;  // Индекс первого найденного в this элемента
		uint   IdxLast;   // Индекс последнего найденного в this элемента
	};
	class TextIndex {
	public:
		enum {
			spcDigital    = -1,
			spcSpaceOrTab = -2,
			spcSpace      = -3,
			spcTab        = -4,
			//spcDot        = -5,

			spcDigL_First = -1001,
			spcDigL_Last  = -1099,
		};
		TextIndex();
		void   Reset();
		int    FASTCALL Add_(uint position, int textId);
		void   Finish();

		int    FASTCALL HasTextId(int textId) const;
		const  LongArray * FASTCALL GetTextIndex(int textId) const;
	private:
		struct Item {
			int    TextId;
			LongArray PosList;
		};
		TSCollection <Item> L;
	};
	class FindBlock : public TSArray <FindItem> {
	public:
		FindBlock(const Replacer & rR);
		~FindBlock();
		FindBlock & Init(const Replacer::SrcItem * pItem, uint idxFirst, uint idxLast);
		//
		// Descr: Сбрасывает список найденных отрезков, но сохраняет неимзенными P_Item, IdxFirst, IdxLast
		//
		FindBlock & Reset();
		const  FindItem * FASTCALL GetGroupItem(uint grpIdx) const;
		void   Sort();
		FindBlock * GetRecursiveBlock();

		const Replacer & R;
		const Replacer::SrcItem * P_Item;
		//
		uint   IdxFirst; // Индекс позиции в PPTextAnalyzer с которой надо начать поиск
		uint   IdxLast;  // Индекс позиции в PPTextAnalyzer на которой поиск заканчивается //
		enum {
			stStop         = 0x0001, // Сигнализирует о том, что продвигаться дальше по тексту с целью найти образец не имеет смысла.
				// Устанавливается функцией PPTextAnalyzer::Match(). Сбрасывается FindBlock::FindBlock(), FindBlock::Reset(), FindBlock::Init().
			stTest         = 0x0002, // Используется при рекурсивных вызовах PPTextAnalyzer::Match()
				// для пропуска ненужных операций с целью оптимизации производительности
			stParentIndex  = 0x0008  // Указатель P_Idx принадлежит родительскому 'кзмемпляру
		};
		int    State;
		uint   NextPos; // Если текст проиндексирован то очередной вызов Match может инициализировать
			// данное поле для иноформирования вызывающей функции о том, на какую позицию в тексте следует
			// переместиться для быстрого нахождения токена.
		//
		SString TempBuf; // @allocreuse
		STokenizer::Item Item_;
		TextIndex * P_Idx;
	private:
		FindBlock * P_Next; // Блок используемый для 'кономии ресурсов при рекурсивных
			// вызовах PPTextAnalyzer::Match()
	};
	SLAPI  PPTextAnalyzer();
	SLAPI ~PPTextAnalyzer();

	void   SLAPI SetSignalProc(TextAnalyzerSignalProc proc, void * pProcExtra);

	int    SLAPI ParseReplacerLine(const SString & rLine, Replacer & rReplacer);
	int    SLAPI ParseReplacerFile(const char * pFileName, Replacer & rRpl);
	//
	// Descr: Создает специальный индекс текста [idxFirst, idxLast] для оптимизации поиска.
	//
	int    SLAPI IndexText(PPTextAnalyzer::FindBlock & rBlk, uint idxFirst, uint idxLast) const;
	//
	// Descr: Выводит описание дескриптора замены в строку.
	//   Отладочная функция.
	//
	int    SLAPI ReplacerSrcItemToStr(const Replacer & rR, const Replacer::SrcItem * pItem, SString & rBuf) const;
	int    SLAPI FindReplacerSrcItem(PPTextAnalyzer::FindBlock & rBlk) const;
	int    SLAPI DoReplacement(const PPTextAnalyzer::Replacer & rR, PPTextAnalyzer::FindBlock & rBlk, SString & rBuf) const;
	//
	// Descr: Реализует обработку строки rOrg по правилам, заданным в блоке rR.
	// ARG(rR         IN): Блок правил обработки текста (замены, сигналы и т.д.)
	// ARG(pResource  IN): @{vptr0} Необязательный строковый идентификатор текста.
	// ARG(rOrg       IN): Строка, подлежащая обработке
	// ARG(rResult   OUT): Результирующая строка после применения всех замен, перечисленных в rR
	// ARG(pOuterFb   IN): Вспомогательный параметр, позволяющий ускорить обработку большого количества
	//   строк за счет снижения издержек на распределение и освобождение памяти.
	// ARG(pDebugFile IN): Необязательный параметр, указывающий на дескриптор текстового файла,
	//   в который будет выводиться отладочная информация о процессе обработки.
	// Returns:
	//   >0 - была осуществлена по крайней мере одна замена в тексе rOrg
	//   <0 - не было сделано ни одной замены (возможно, были обработаны сигналы)
	//    0 - ошибка
	//
	int    SLAPI ProcessString(const PPTextAnalyzer::Replacer & rR, const char * pResource, const SString & rOrg,
		SString & rResult, PPTextAnalyzer::FindBlock * pOuterFb, SFile * pDebugFile);

	int    SLAPI ProcessGoods();
	int    SLAPI ProcessGoodsNN();
	int    SLAPI ProcessPerson();
	int    SLAPI ProcessCtx(const char * pIdent, const char * pText, STokenizer::Context * pCtx);

	int    SLAPI Test();
private:
	int    SLAPI GetTrT(const PPTextAnalyzer::Replacer & rReplacer, SStrScan & rScan, SString & rExtBuf) const;
	int    SLAPI Match(FindBlock & rBlk, uint termIdx, const uint termLast, uint idxFirst, uint idxLast) const;
	int    SLAPI Helper_FindReplacerSrcItem(FindBlock & rBlk, const uint termFirst, const uint termLast, uint idxFirst, const uint idxLast, uint * pFoundIdx) const;
	int    SLAPI ParseContext(const Replacer & rReplacer, SStrScan & rScan, Replacer::Chain * pChain, int recur);
	int    SLAPI Helper_ReplacerSrcItemToStr(const Replacer & rR, const Replacer::SrcItem * pItem,
		const Replacer::Chain & rC, uint start, uint count, SString & rBuf) const;

	TextAnalyzerSignalProc SignalProc;
	void * P_SignalProcExtra;
};
//
// Descr: Упрощенная обертка для класса PPTextAnalyze для замены текста по правилам,
//   заданным в исходном файле. Сигналы не отрабатываются.
//
class PPTextAnalyzerWrapper {
public:
	enum {
		fInited   = 0x0001, // @internal
		fEncInner = 0x0002  // Входящая строка и результат кодируются в INNER-кодировке
	};
	SLAPI  PPTextAnalyzerWrapper();
	int    SLAPI Init(const char * pRuleFileName, long flags);
	int    SLAPI ReplaceString(const char * pText, SString & rResult);
private:
	PPTextAnalyzer A;
	PPTextAnalyzer::Replacer R;
	PPTextAnalyzer::FindBlock Fb;
	long   Flags;
	SString TempBuf; // @allocreuse
};
//
//
//
class PPObjectTokenizer : public PPTextAnalyzer {
public:
	SLAPI  PPObjectTokenizer();
	SLAPI ~PPObjectTokenizer();
	int    SLAPI AddObject(PPObjID oi, const char * pName);
	int    SLAPI SearchObjects(const char * pText, PPID objType, long flags, RAssocArray & rObjIdScoreList);

	int    SLAPI ProcessSuprWare(PPID swType, PPID swCls);
	int    SLAPI ProcessGoods(const GoodsFilt * pFilt);

	int    SLAPI SearchGoodsAnalogs(PPID goodsID, PPIDArray & rList, SString * pTransitComponentBuf);
private:
	// Временные буферы для минимизации операций распределения памяти {
	SString TextBuf;
	SString IdentBuf;
	// }
};
//
//
//
class PrcssrObjTextFilt : public PPBaseFilt { // @persistent
public:
	SLAPI  PrcssrObjTextFilt();
	PrcssrObjTextFilt & FASTCALL operator = (const PrcssrObjTextFilt & rS);
	int    SLAPI IsEmpty() const;

	enum {
		fLog          = 0x0001,
		fReplace      = 0x0002,
		fSignal       = 0x0004,
		fDebug        = 0x0008,
		fNnClassifier = 0x0010  // @v9.2.7 @construction Нейронный классификатор товаров
	};
	enum {
		otiName = 1
	};
	uint8  ReserveStart[32]; // @ancor
	PPID   ObjType;
	long   ObjTextIdent;
	long   Flags;
	uint8  ReserveEnd[32];
	SString RuleFileName;    // @ancor
	GoodsFilt * P_GoodsF;
	BrandFilt * P_BrandF;
	PersonFilt * P_PsnF;
};

class PrcssrObjText {
public:
	static int SLAPI VerifyRuleFile(const char * pFileName);

	SLAPI  PrcssrObjText();
	SLAPI ~PrcssrObjText();
	int    SLAPI InitParam(PPBaseFilt *);
	int    SLAPI EditParam(PPBaseFilt *);
	int    SLAPI Init(const PPBaseFilt *);
	int    SLAPI Run();
private:
	struct SignalProcBlock {
		SignalProcBlock()
		{
			State = 0;
		}
		enum {
			stOuterTransaction = 0x0001
		};
		int    State;
		PPObjGoods GObj;
	};
	static int SignalProc(const char * pResource, int64 orgOffs, const char * pOrgStr, const char * pSignalStr, void * pExtraPtr);

	PrcssrObjTextFilt P;
	PPTextAnalyzer Ta;
	PPTextAnalyzer::Replacer * P_Rpl;
	SFile  LogF;
};
//
//
//
class PPAutoTranslSvc_Microsoft {
public:
	struct Stat {
        uint   ReqCount;
        uint   InpChrCount;
        uint   OutpChrCount;
        uint64 TotalTiming;
	};
	SLAPI  PPAutoTranslSvc_Microsoft();
	SLAPI ~PPAutoTranslSvc_Microsoft();
	int    SLAPI Auth(const char * pIdent, const char * pSecret);
    int    SLAPI Request(int srcLang, int destLang, const SString & rSrcText, SString & rResult);
    PPAutoTranslSvc_Microsoft::Stat & SLAPI GetStat() const;
private:
	Stat   S;
	long   ExpirySec;
	int    LastStatusCode;
	SString LastStatusMessage;
	LDATETIME AuthTime;
	SString AuthName;
	SString AuthSecret;
	SString Token;
	xmlParserCtxt * P_XpCtx;
};
//
//
//
#ifdef __WIN32__
//
// PpyInetDataPrcssr
//
//const static char WinInetDLLPath[] = "wininet.dll";

#endif // __WIN32__

class PpyInetDataPrcssr {
public:
	SLAPI  PpyInetDataPrcssr();
	SLAPI ~PpyInetDataPrcssr();
#ifdef __WIN32__
	int    SLAPI Init();
	void   SLAPI Uninit();
	// @v9.7.10 @obsolete int    SLAPI ImportCurrencyList(ulong * pAcceptedRows, int use_ta);
	//int  SLAPI ImportBankList();
#endif // __WIN32__
	static int SLAPI EditCfg();
	static int SLAPI GetCfg(PPInetConnConfig * pCfg);
	static int SLAPI PutCfg(const PPInetConnConfig * pCfg, int use_ta);
protected:
#ifdef __WIN32__
	// @v9.7.10 @obsolete int    SLAPI DownloadData(const char * pURL, const char * pPath);
	void   SLAPI SetInetError();
	HINTERNET InetSession;
	HANDLE    WinInetDLLHandle;
	PPInetConnConfig IConnCfg;
#endif // __WIN32__
};
//
// FTP via wininet.lib implementation
//
class WinInetFTP {
public:
	WinInetFTP();
	~WinInetFTP();
	int    Init();
	int    Init(PPInetConnConfig * pCfg);
	int    UnInit();
	int    ReInit();
	int    Connect(PPInternetAccount * pAccount);
	int    Disconnect();

	int    CreateDir(const char * pDir);
	int    Exists(const char * pPath);
	int    GetFileList(const char * pDir, StrAssocArray * pFileList, const char * pMask = 0);
	int    SafeGet(const char * pLocalPath, const char * pFTPPath, int checkDtTm, PercentFunc pf, PPLogger * pLogger);
	int    SafePut(const char * pLocalPath, const char * pFTPPath, int checkDtTm, PercentFunc pf, PPLogger * pLogger);
	int    SafeCD(const char * pPath, int isFullPath, PPLogger * pLogger);
	int    SafeDelete(const char * pPath, PPLogger * pLogger);
	int    SafeDeleteWOCD(const char * pPath, PPLogger * pLogger);
	int    SafeCreateDir(const char * pDir, PPLogger * pLogger);
	int    SafeGetFileList(const char * pDir, StrAssocArray * pFileList, const char * pMask, PPLogger * pLogger);
private:
	int    TransferFile(const char * pLocalPath, const char * pFTPPath, int send, int checkDtTm, PercentFunc pf);
	int    ReadResponse();

	//int    Get(const char * pLocalPath, const char * pFTPPath, int checkDtTm = 0, PercentFunc pf = 0);
	//int    Put(const char * pLocalPath, const char * pFTPPath, int checkDtTm = 0, PercentFunc pf = 0);
	int    Delete(const char * pPath);
	//int    DeleteWOCD(const char * pPath);
	int    CheckSizeAfterCopy(const char * pLocalPath, const char * pFTPPath);
	int    CD(const char * pDir, int isFullPath = 1);

	HINTERNET InetSession, Connection;
	PPInetConnConfig IConnCfg;
	HANDLE    WinInetDLLHandle;
	PPInternetAccount Account;
};
//
//
//
class PPOsm : public SStrGroup {
public:
	enum {
		otUnkn = 0,
		otNode,
		otWay,
		otRelation
	};
	struct Tile { // @persistent
		SLAPI  Tile();
		SLAPI  Tile(const Tile & rS);
		Tile & FASTCALL operator = (const Tile & rS);
		void   SLAPI SetInvisible();
		void   FASTCALL SetLevel(uint8 level);
		uint8  SLAPI GetLevel() const;
		uint32 SLAPI GetZValue() const;

		uint32 V;
	};
	//
	// Descr: Представление точки карты
	//
    struct NPoint {
    	SLAPI  NPoint();
		int    FASTCALL IsEqual(const NPoint & rS) const;
		int    FASTCALL operator == (const NPoint & rS) const;
		int    FASTCALL operator != (const NPoint & rS) const;

    	uint64 ID;
		SGeoPosLL_Int C;
    };
	//
	// Descr: Представление точки карты с дополнительным атрибутом - Tile
	//
    struct Node : public NPoint {
    	SLAPI  Node();
		int    FASTCALL IsEqual(const Node & rS) const;
		int    FASTCALL operator == (const Node & rS) const;
		int    FASTCALL operator != (const Node & rS) const;

		Tile   T;
    };
    class NodeRefs {
	public:
		SLAPI  NodeRefs();
		int    FASTCALL IsEqual(const NodeRefs & rS) const;
		int    SLAPI AddWayRef(uint64 nodeID, uint64 wayID);
		int    SLAPI AddRelRef(uint64 nodeID, uint64 relID);
		void   SLAPI Clear();
		void   SLAPI Sort();

		LLAssocArray WayRefs;
		LLAssocArray RelRefs;
    };
    struct Way {
    	SLAPI  Way();
		void   Clear();
    	int    FASTCALL IsEqual(const Way & rS) const;
		int    FASTCALL operator == (const Way & rS) const;
		int    FASTCALL operator != (const Way & rS) const;

		uint64 ID;
		Tile   T;
		Int64Array NodeRefs;
    };
	struct RelMember {
		SLAPI  RelMember();
		uint64 RefID;
		uint   TypeSymbID;
		uint   RoleSymbID;
	};
    struct Relation {
    	SLAPI  Relation();
		uint64 ID;
		Tile   T;
		TSArray <RelMember> MembList;
    };
    struct Tag {
    	SLAPI  Tag();
        uint   KeySymbID; // Идентификатор символа
        uint64 ValID;     // Идентификатор значения (в варианте теста все значения хранятся в таблице символов)
    };

	struct NodeClusterStatEntry {
		uint   LogicalCount;
		uint64 ClusterCount;
		uint64 ActualCount;
		uint64 ProcessedCount; // Количество узлов, которые уже находились в БД при попытке их добавить
		uint64 Size;
	};
	struct WayStatEntry {
		uint   RefCount;
		uint64 WayCount;
		uint64 ProcessedCount; // Количество элементов, которые уже находились в БД при попытке их добавить
		uint64 Size;
	};
	//
	// Descr: Специализированная структура для упакованного хранения группы точек, принадлежащих
	//   одному тайлу. Формат хранения проще всего определяется функциями
	//   NodeCluster::Put и NodeCluster::Implement_Get
	//
	class NodeCluster : private SBuffer {
	public:
		SLAPI  NodeCluster();
		SLAPI ~NodeCluster();
        static uint SLAPI GetPossiblePackCount(const Node * pN, size_t count, uint * pPossibleCountLogic);

		struct Put__Param {
			SLAPI  Put__Param(const Node * pN, uint nodeCount);

			const  Node * P_N;
			const  LLAssoc * P_NrWayRefs;
			const  LLAssoc * P_NrRelRefs;
			uint   NCount;
			uint   NrWayRefsCount;
			uint   NrRelRefsCount;
		};
		struct Put__Result {
			SLAPI  Put__Result();

			uint   ActualCount;
			uint   ActualNrWayCount;
			uint   ActualNrRelCount;
			uint   NrWayShift; // Количество проверенных элементов из Put__Param::P_NrWayRefs.
				// На это значение надо сдвинуть вперед соответствующий счетчик при следующей итерации.
			uint   NrRelShift; // Количество проверенных элементов из Put__Param::P_NrRelRefs.
				// На это значение надо сдвинуть вперед соответствующий счетчик при следующей итерации.
		};

        int    SLAPI Put__(const Put__Param & rP, uint64 * pOuterID, Put__Result * pResult, uint forceLogicalCount);
		int    SLAPI Get(uint64 outerID, TSArray <Node> & rList, NodeRefs * pNrList);
		int    SLAPI Get(uint64 outerID, TSArray <Node> & rList, NodeRefs * pNrList, Node * pHead, uint * pCountLogic, uint * pCountActual);
		size_t SLAPI GetSize() const;
		int    SLAPI GetCount(uint64 outerID, uint * pLogicCount, uint * pActualCount);
		//
		// Descr: Возвращает заголовочный идентификатор кластера.
		// Note: Функция non-const из-за операций чтения SBuffer, которые
		//   меняют его смещение. Однако, в реальности, состояние объекта не меняется - смещения
		//   восстанавливаются в изначальном виде.
		// Returns:
		//   0 - ошибка
		//   4 - идентификатор может быть представлен 4-байтовым значением
		//   8 - идентификатор может быть представлен только 8-байтовым значением
		//
		int    FASTCALL GetHeaderID(uint64 * pID);
		//
		// Descr: Возвращает заголовочный тайл кластера.
		// Note: Так же как и GetHeaderID эта функция non-const по спецификации,
		//   но фактически состояния объекта не меняет.
		//
		int    FASTCALL GetTile(uint64 outerID, Tile * pT);
		const void * FASTCALL GetBuffer(size_t * pSize) const;
		//
		// Descr: Формирует блок кластера из "сырого" буфера данных.
		// Note: Функция опасная - она не проверяет корректности устанавливаемых данных.
		//   Используется для обмена данными с базой данных.
		//
		int    SLAPI SetBuffer(const void * pData, size_t size);
	private:
		enum {
			indfCountMask   = (0x01 | 0x02 | 0x04), // Маска битов, представляющих количество точек в пакете.
				// 0: 1, 1: 2, 2: 4, 3: 8, 4: 16, 5: 32, 6: 64, 7: 128
			indfId32        = 0x08, // Идентификатор точки представлен 32-битным значением
			indfOuterId     = 0x10, // Идентификатор точки хранится отдельно (специально для K-V хранилищ: ид держится в ключе)
			indfHasRefs     = 0x20, // В конце кластера могут быть ссылки Way->Node и(или) Relation->Node. Если флаг установлен, то
				// в любом случае последним байтом буфера будет терминатор refindfTerminal
		};
		enum {
			infindfEmpty         = 0x01, // Точка отсутствует (пропуск идентификатора). Все остальные флаги в этом случае незначимы.
			infindfPrevLatIncr8  = 0x02, // Широта представлена int8-инкрементом относительно предыдущей точки
			infindfPrevLatIncr16 = 0x04, // Широта представлена int16-инкрементом относительно предыдущей точки
			infindfPrevLonIncr8  = 0x08, // Долгота представлена int8-инкрементом относительно предыдущей точки
			infindfPrevLonIncr16 = 0x10, // Долгота представлена int16-инкрементом относительно предыдущей точки
			infindfHasTags       = 0x20, // Точка имеет теги
			infindfDiffTileLevel = 0x80  // Точка имеет отличный от заголовочной уровень тайла
		};
		enum {
			refindfIdSizeMask     = (0x01 | 0x02 | 0x04), // Маска размера идентификатора (в байтах)
			refindfTerminal       = 0x08, // Терминальный индикатор (определяет конец серии ссылок - все остальные биты нулевые)
			refindfWay            = 0x10,
			refindfRelation       = 0x20
		};
		// Формат серии ссылок: [(indicator:byte) (position: byte) (id)] (terminal_indicator:byte)
		int    SLAPI Implement_Get(uint64 outerID, TSArray <Node> * pList, NodeRefs * pNrList, Node * pHead, uint * pCountLogic, uint * pCountActual);
	};
	class WayBuffer : private SBuffer {
	public:
		SLAPI  WayBuffer();
		int    SLAPI Put(const Way * pW, uint64 * pOuterID);
		int    SLAPI Get(uint64 outerID, Way * pW);
		const  void * FASTCALL GetBuffer(size_t * pSize) const;
		int    SLAPI SetBuffer(const void * pData, size_t size);
		size_t SLAPI GetSize() const;
	private:
		// (IND) [ID] (TileLevel) [COUNT] ([INFIND] (POINT-ID))+
        enum {
        	indfLoop          = 0x01, // Замкнутый контур (последняя точка равна первой и не хранится в буфере)
            indfIncremental8  = 0x02, // Первая точка хранится как есть, все последующие - байтовый инкремент от предыдущей точки
            indfIncremental16 = 0x04, // Первая точка хранится как есть, все последующие - 2-байтовый инкремент от предыдущей точки
				// Если !(indfIncremental8|indfIncremental16), то идентификаторы всех точек хранятся с байтовым префиксом
				// определяющим способ хранения соответствующего значения.
            indfRectangle     = 0x08, // Замкнутый контур из 4 точек (предполагает одновременную установку indfLoop)
            indfCount8        = 0x10, // Количество точек байтовое (иначе - 4 байтовое)
				// Если !indfRectangle, то количество точек указывается явно (общее, включая замыкающую для контура)
            indfFirstId32     = 0x20, // Идентификатор первой точки 4-байтовый (в противном случае - 8-байтовый)
			indfId32          = 0x40, // Идентификатор объекта представлен 32-битным значением
			indfOuterId       = 0x80  // Идентификатор объекта хранится отдельно (специально для K-V хранилищ: ид держится в ключе)
        };
        enum {
        	infindfSizeMask      = (0x01|0x02|0x04),
        	infindfIncremental   = 0x08
        };
	};
	enum {
		stGridLoaded = 0x0001
	};

	SLAPI  PPOsm(const char * pDbPath);
	SLAPI ~PPOsm();
	long   FASTCALL CheckStatus(long) const;
	uint   FASTCALL SearchSymb(const char * pSymb) const;
	uint   FASTCALL CreateSymb(const char * pSymb);
	int    SLAPI GetSymbByID(uint id, SString & rSymb) const;
	int    SLAPI BuildHashAssoc();
	int    SLAPI LoadGeoGrid();
	const  SGeoGridTab & SLAPI GetGrid() const
	{
		return Grid;
	}
	//
	int    SLAPI OpenDatabase(const char * pDbPath);
	SrDatabase * SLAPI GetDb();
	static int FASTCALL SetNodeClusterStat(NodeCluster & rCluster, TSArray <NodeClusterStatEntry> & rStat);
	static int FASTCALL SetProcessedNodeStat(uint logicalCount, uint qtty, TSArray <NodeClusterStatEntry> & rStat);
	static int FASTCALL SetWayStat(WayBuffer & rWayBuf, TSArray <WayStatEntry> & rStat);
	static int FASTCALL SetProcessedWayStat(uint refCount, uint qtty, TSArray <WayStatEntry> & rStat);
private:
	SrDatabase * P_SrDb;
	//
	long   Status;
	uint   LastSymbID;
	SymbHashTable Ht;
	SGeoGridTab Grid;
};

class PrcssrOsmFilt : public PPBaseFilt { // @persistent
public:
	SLAPI  PrcssrOsmFilt();
	PrcssrOsmFilt & FASTCALL operator = (const PrcssrOsmFilt & rS);
	int    SLAPI IsEmpty() const;

	enum {
		fPreprocess        = 0x0001, // Предварительная обработка osm-файла с выводом текстовых данных для дальнейшей обработки
		fSortPreprcResults = 0x0002, // Сортировка файлов, полученных в фазе препроцессинга
		fAnlzPreprcResults = 0x0004, // Анализ данных, полученных в фазах препроцессинга и сортировки
		fImport            = 0x0008, // Импорт данных osm во внутреннюю базу данных
		fExtractSizes      = 0x0010  // Извлечение размеров объектов и вывод их в файл
	};
	uint8  ReserveStart[32]; // @ancor
	long   Flags;
	uint8  ReserveEnd[32];
	SString SrcFileName;     // @anchor
};

class PrcssrOsm {
public:
	SLAPI  PrcssrOsm(const char * pDbPath);
	SLAPI ~PrcssrOsm();
	int    SLAPI InitParam(PPBaseFilt * pBaseFilt);
	int    SLAPI EditParam(PPBaseFilt * pBaseFilt);
	int    SLAPI Init(const PPBaseFilt * pBaseFilt);
	int    SLAPI Run();
	void   SLAPI Reset();
private:
	struct CommonAttrSet {
		SLAPI  CommonAttrSet();
		void   SLAPI Reset();

		int64  ID;
		double Lat;
		double Lon;
        LDATETIME T;
        int    Ver;
        int    Visible;
        int64  ChangeSet;
        int64  UserID;
		uint   TypeSymbID;
		uint   RoleSymbID;
		int64  RefID;
        SString User;
	};
	struct StatBlock { // @persistent
		SLAPI  StatBlock();
		void   SLAPI Clear();
		int    SLAPI Serialize(int dir, SBuffer & rBuffer, SSerializeContext * pSCtx);
		uint64 SLAPI GetNcActualCount() const;
		uint64 SLAPI GetNcProcessedCount() const;
		uint64 SLAPI GetNcClusterCount() const;
		uint64 SLAPI GetNcSize() const;

		uint64 SLAPI GetWsCount() const;
		uint64 SLAPI GetWsProcessedCount() const;
		uint64 SLAPI GetWsSize() const;

		uint64 NodeCount;
		uint64 NakedNodeCount; // Количество узлов без тегов
		uint64 WayCount;
		uint64 RelationCount;
		uint64 TagNodeCount;
		uint64 TagWayCount;
		uint64 TagRelCount;
		TSArray <PPOsm::NodeClusterStatEntry> NcList;
		TSArray <PPOsm::WayStatEntry> WayList;
	};
	struct RoadStone { // @persistent
		SLAPI  RoadStone();
		int    SLAPI Serialize(int dir, SBuffer & rBuffer, SSerializeContext * pSCtx);
		SString SrcFileName;
		long   Phase;
		PrcssrOsm::StatBlock Stat;
	};
	static void Scb_StartDocument(void * ptr);
	static void Scb_EndDocument(void * ptr);
	static void Scb_StartElement(void * ptr, const xmlChar * pName, const xmlChar ** ppAttrList);
	static void Scb_EndElement(void * ptr, const xmlChar * pName);
	static int  SortCbProc(const SFileSortProgressData * pInfo);

	int    StartDocument();
	int    EndDocument();
	int    StartElement(const char * pName, const char ** ppAttrList);
	int    EndElement(const char * pName);
	int    SaxParseFile(xmlSAXHandlerPtr sax, const char * pFileName);
	void   SaxStop();

	int    SLAPI GetPhaseSymb(long phase, SString & rSymb) const;
	int    SLAPI ReadCommonAttrSet(const char ** ppAttrList, CommonAttrSet & rSet);
	int    FASTCALL FlashNodeAccum(int force);

	int    LogCoord(const SGeoPosLL_Int & rC);
	int    LogTag(int osmObjType, const PPOsm::Tag & rTag);
	int    SLAPI SortFile(const char * pSrcFileName, const char * pSuffix, CompFunc fcmp);
	int    SLAPI CreateGeoGridTab(const char * pSrcFileName, uint lowDim, uint uppDim, TSCollection <SGeoGridTab> & rGridList);
	int    SLAPI OutputStat(int detail);
	int    SLAPI ProcessWaySizes();

	int    SLAPI WriteRoadStone(RoadStone & rRs);
	int    SLAPI ReadRoadStone(long phase, RoadStone & rRs);
	//
	enum {
		stError = 0x0001
	};
	long   State;
	enum {
		phaseUnkn              = 0,
		phasePreprocess        = 1,
		phaseSortPreprcResults = 2,
		phaseAnlzPreprcResults = 3,
		phaseImport            = 4,
		phaseExtractSizes      = 5
	};
	long   Phase;
	PrcssrOsmFilt P;
	const SymbHashTable * P_ShT; // Таблица символов, полученная вызовом PPGetStringHash(int)

	xmlParserCtxt * P_SaxCtx;
	TSStack <int> TokPath;
	SGeo   G;
	PPOsm  O;
	CommonAttrSet TempCaSet;
	TSArray <PPOsm::Tag> CurrentTagList;
	PPOsm::Node LastNode;
	PPOsm::Way  LastWay;
	PPOsm::Relation LastRel;
	//
	StatBlock Stat;
	StatBlock RestoredStat;
	RoadStone * P_RoadStoneStat;

	LongArray LatAccum;
	LongArray LonAccum;
	TSArray <PPOsm::Node> NodeAccum;
	TSCollection <PPOsm::Way> WayAccum;
	LLAssocArray NodeWayAssocAccum;
	SGeoGridTab::Finder GgtFinder;
	SString FmtMsg_SortSplit;
	SString FmtMsg_SortMerge;
	LLAssoc LastNodeToWayAssoc; // Последняя ассоциация node-way считанная из P_NodeToWayAssocInF (и не попавшая в предыдущую порцию сохранения)

	SFile * P_LatOutF;
	SFile * P_LonOutF;
	SFile * P_NodeToWayAssocOutF;
	SFile * P_TagOutF;
	SFile * P_TagNodeOutF;
	SFile * P_TagWayOutF;
	SFile * P_TagRelOutF;
	SFile * P_SizeOutF; // Файл вывода размерностей (максимальных расстояний внутри Way-ев).
	SFile * P_NodeToWayAssocInF;

	SFile * P_TestNodeBinF;
	SFile * P_TestNodeF;

	PPUserFuncProfiler * P_Ufp;

	struct ProcessBlock {
		SString TempBuf;   // @allocreuse
		SString AttrBuf;   // @allocreuse
		SString LineBuf;   // @allocreuse
		SString TagKeyBuf; // @allocreuse Временный буфер для хранения ключа тега
		SString TagValBuf; // @allocreuse Временный буфер для хранения значения тега
		LLAssocArray NodeToWayAsscList;
	};

	ProcessBlock Pb;
	LongArray TempTagKeyList;
	LongArray TagKeyList; // Отладочный список ключевых символов тегов.
	//
	PPLogger Logger;
};
//
//
//
class PrcssrSartreFilt : public PPBaseFilt { // @persistent
public:
	SLAPI  PrcssrSartreFilt();
	PrcssrSartreFilt & FASTCALL operator = (const PrcssrSartreFilt & rS);
	int    SLAPI IsEmpty() const;

	enum {
		fImportFlexia      = 0x0001,
        fImportConcepts    = 0x0002,
        fImportHumNames    = 0x0004,
        fTestFlexia        = 0x0008,
        fTestConcepts      = 0x0010,
		fTestSyntaxParser  = 0x0020
	};
	uint8  ReserveStart[32]; // @ancor
	long   Flags;
	uint8  ReserveEnd[32];
	SString SrcPath;         // @anchor
};

class SrSyntaxRuleSet;

class PrcssrSartre {
public:
	SLAPI  PrcssrSartre(const char * pDbPath);
	SLAPI ~PrcssrSartre();
	int    SLAPI InitParam(PPBaseFilt * pBaseFilt);
	int    SLAPI EditParam(PPBaseFilt * pBaseFilt);
	int    SLAPI Init(const PPBaseFilt * pBaseFilt);
	int    SLAPI Run();

	//int    SLAPI ResolveSyntaxRules(SrSyntaxRuleSet & rSet, SrDatabase & rDb);
private:
	int    SLAPI ImportHumanNames(const char * pSrcFileName, const char * pLinguaSymb, int properNameType, int specialProcessing);
	int    SLAPI TestSearchWords();
	int    SLAPI TestConcept();
	int    SLAPI TestSyntax();

	PrcssrSartreFilt P;
};
//
// Descr: Шаблон функции получения указателя на объектный кэш, локальный по отношению к базе данных
//   Используется при обращении объекта PPObject к кэшу.
// Example:
//	int SLAPI PPObjArticle::Fetch(PPID id, ArticleTbl::Rec * pRec)
//	{
//		ArticleCache * p_cache = GetDbLocalCachePtr <ArticleCache> (Obj);
//		return p_cache ? p_cache->Get(id, pRec) : Search(id, pRec);
//	}
//
template <class C> C * FASTCALL GetDbLocalCachePtr(PPID objType, int doCreate = 1)
{
	C * p_cache = (C *)DS.GetDbLocalObjCache(objType);
	if(doCreate && !p_cache) {
		ENTER_CRITICAL_SECTION
		if(!p_cache && !DS.SetDbLocalObjCache(p_cache = new C)) ZDELETE(p_cache);
		LEAVE_CRITICAL_SECTION
	}
	return p_cache;
}
//
//
//
#include <dl600.h>
#include <..\Rsrc\DL600\ppexp.h>
#include <..\Rsrc\DL600\ppifc.h>
// @v9.0.3 Перенесено в начало файла
// @v8.9.12 #include <pprpt.h>
//
// PPDLGS-START
//
class PPApp : public TProgram {
public:
	PPApp(HINSTANCE hInst, const char * pAppSymb, const char * pAppName);
	void   login(int processCmdLine /*= 1*/);
	int    processCommand(uint);
	uint   LastCmd;
private:
	DECL_HANDLE_EVENT;
	virtual int  InitStatusBar();
	virtual int  LoadVectorTools(TWhatmanToolArray * pT);
	int    InitDeskTop();
	int    InitMenuBar();
	int    RegisterComServer();
	int    SetDatetimeByServer(PPIniFile * pIniFile, int force);
	enum {
		lsLockSettingTimeByServer = 0x0001
	};
	long   LocalState;
};
//
//
//
class PPViewBrowser : public BrowserWindow {
public:
	static int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, void * extraProcPtr);

	PPViewBrowser(uint brwId, DBQuery *, PPView *, int dataOwner);
	PPViewBrowser(uint brwId, SArray *, PPView *, int dataOwner);
	~PPViewBrowser();
	void   Update(); // @>>PPViewBrowser::updateView()
	int    SetRefreshPeriod(long);
	int    Export();
	int    SetupToolbarCombo(PPID objType, PPID id, uint flags, void * extraPtr);
	int    SetupToolbarCombo(PPID objType, PPID id, uint flags, const PPIDArray & rObjList);
	int    GetToolbarComboData(PPID * pID);
	int    Advise(int kind, PPID action, PPID objType, long flags);
	//
	// Descr: Отменяет свойство владение данными (IsDataOwnership).
	//   Вызывается при необходимости разрушить объект таким образом, чтобы
	//   данные, которыми он владеет (P_View) остались нетронутыми.
	// Attention:
	//   Использовать крайне осторожно. При неправильном вызове вероятна значительная потеря памяти.
	//
	int    ResetDataOwnership();
	int    InsColumnWord(int atPos, uint wordId, uint fldNo, TYPEID typ, long fmt, uint opt);
	int    InsColumn(int atPos, const char * pText, uint fldNo, TYPEID typ, long fmt, uint opt);
	//
	// Descr: Устанавливает динамическую алтернативную товарную группу как временную.
	//   Деструктор класса должен удалить все такие группы.
	//
	int    SetTempGoodsGrp(PPID grpID);
	PPView * P_View;
protected:
	DECL_HANDLE_EVENT;
	virtual void updateView();
	virtual int  getCurHdr(void *);
	int    IsDataOwner;
private:
	int    Advise();
	void   Unadvise();
	int    GetToolbarComboRect(RECT * pRect);
	int    Helper_SetupToolbarCombo(PPID objType, PPID id, uint flags, void * extraPtr, const PPIDArray * pObjList);

	int    KBF10;
	SCycleTimer RefreshTimer;
	PPIDArray TempGoodsGrpList;  // Список временных товарных групп, которые должны быть разрушены при разрушении броузера
	TInputLine * P_InputLine;    //
	ComboBox   * P_ComboBox;     //
	HFONT        H_ComboFont;    //
	PPIDArray Cookies;           //
};
//
//
//
class ObjViewDialog : public TDialog {
public:
	ObjViewDialog(uint dlgRez, PPObject * aObj, void * extraPtr);
protected:
	DECL_HANDLE_EVENT;
	//
	// Descr: вызывается в ответ на сообщение cmaMore или на нажатие CtrlEnter.
	//   В качестве параметра передается ИД текущего элемента списка.
	//
	virtual void extraProc(long);
	//
	// Descr: вызывается в ответ на сообщение cmTransmit.
	//   Базовая реализация предполагает передачу всех объектов с типом P_Obj->Obj.
	//   Если P_Obj == 0 || !IS_REF_OBJTYPE(P_Obj->Obj) базовая реализация функции
	//   возвращает -1 ничего не делая //
	//
	virtual int  transmit(PPID);
	virtual void addItem();
	virtual void removeItem();
	virtual void editItem();
	virtual int  Print();
	void   updateList(PPID id);
	PPID   getCurrID();

	SmartListBox * P_List;
	PPObject * P_Obj;
	void * ExtraPtr;
	int    Rt;                 // Access rights flags (PPR_XXX)
};
//
// Диалог для просмотра объектов унаследованных от PPObjReference с возможностью отправки данных charry
//
class RefObjViewDialog : public ObjViewDialog {
public:
	RefObjViewDialog(uint dlgRez, PPObject * aObj, long charryID, void * extraPtr);
private:
	DECL_HANDLE_EVENT;
	long   CharryID;
};
//
//
//
class PPObjListWindow : public ListWindow {
public:
	//
	// ~PPObjListWindow обязан разрушить объект, передаваемый
	// в качестве параметра конструктору. Немножко нелогично разрушать
	// то, что сам не создавал, однако иногда приходится.
	//
	PPObjListWindow(PPObject *, uint aFlags, void * extraPtr);
	PPObjListWindow(PPID objType, StrAssocArray *, uint aFlags, void * extraPtr);
	~PPObjListWindow();
protected:
	DECL_HANDLE_EVENT;
	virtual int FASTCALL valid(ushort command);
	virtual int Transmit(PPID);
	void   PostProcessHandleEvent(int update, PPID focusID);

	uint   Flags;
	uint   DefaultCmd; // Команда по умолчанию. Вызывается по двойному клику, либо нажатию клавиши Enter.
	void * ExtraPtr;
	PPObject * P_Obj;
private:
	void   Init(PPObject * aPPObj, uint aFlags, void * extraPtr);
};

class PPObjBrowser : public BrowserWindow {
public:
	PPObjBrowser(uint rezID, DBQuery * q, PPObject * _ppobj, uint _flags, long _extra);
protected:
	DECL_HANDLE_EVENT;
	PPID   currID();
	void   updateView();
	void   SetPPObjPtr(PPObject *);

	uint   flags;
	long   extra;
	PPObject * ppobj;
};

struct ListToListUIData {
	ListToListUIData();
	enum {
		fCanInsertNewItem = 0x0001,
		fIsTreeList       = 0x0002
	};
	uint   LeftCtlId;
	uint   RightCtlId;
	uint   Flags;
	uint   TitleStrID; // PPSTR_TEXT
	char * P_Title;
};

class Lst2LstDialogUI : public TDialog {
public:
	Lst2LstDialogUI(uint rezID, ListToListUIData *);
protected:
	DECL_HANDLE_EVENT;
	virtual int  addItem();
	virtual int  addNewItem();
	virtual int  removeItem();
	virtual int  addAll();
	virtual int  removeAll();
	SmartListBox  * GetLeftList();
	SmartListBox  * GetRightList();
private:
	enum defButton {
		b_ok = 0,
		b_fw = 1,
		b_bw = 2
	};
	int    setup();
	ListToListUIData Data;
};

struct ListToListAryData : public ListToListUIData {
	SLAPI  ListToListAryData(uint rezID = 0, SArray * pLList = 0, SArray * pRList = 0);
	uint   RezID;
	SArray * P_LList;
	SArray * P_RList;
};

class Lst2LstAryDialog : public Lst2LstDialogUI {
public:
	Lst2LstAryDialog(uint rezID, ListToListUIData *, SArray * left, SArray * right);
	int    getDTS(SArray * /*LstItem array*/);
protected:
	int    setupLeftList();
	int    setupRightList();
	virtual int SetupList(SArray *, SmartListBox *);
	virtual int addItem();
	virtual int addAll();
	virtual int removeItem();
	virtual int removeAll();
	SArray * GetRight() const;
	SArray * GetLeft() const;
private:
	SArray * P_Right;
	SArray * P_Left;
};

struct ListToListData : public ListToListUIData {
	ListToListData(PPID objType, void * extraPtr, PPIDArray * pList);
	ListToListData(const StrAssocArray * pSrcList, PPID objType, PPIDArray * pList);

	PPID   ObjType;
	void * ExtraPtr;
	const  StrAssocArray * P_SrcList;
	PPIDArray * P_List;
};

class Lst2LstObjDialog : public Lst2LstDialogUI {
public:
	Lst2LstObjDialog(uint rezID, ListToListData *);
	~Lst2LstObjDialog();
	int    getDTS(PPIDArray *);
protected:
	int    setup();
	int    setupLeftList();
	int    setupRightList();
	int    setupRightTList();
	int    FASTCALL Helper_AddItemRecursive(PPID id, StdTreeListBoxDef * pDef);
	int    FASTCALL Helper_RemoveItemRecursive(PPID id, StdTreeListBoxDef * pDef);
	void   GetItemText(long id, SString & rBuf);
	virtual int addItem();
	virtual int addNewItem();
	virtual int removeItem();
	virtual int addAll();
	virtual int removeAll();

	ListToListData Data;
	PPObject * P_Object;
};
//
//
//
class SCardSeriesView : public ObjViewDialog {
public:
	SLAPI  SCardSeriesView(PPObjSCardSeries * _ppobj);
	virtual void extraProc(long id);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PPSCardSeries * pRec);
	int    SLAPI Print();
	uint   CurPrnPos;
};

class PPObjSCardSeriesListWindow : public PPObjListWindow {
public:
	SLAPI  PPObjSCardSeriesListWindow(PPObject * pObj, uint flags, void * extraPtr);
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PPSCardSeries * pRec);
private:
	DECL_HANDLE_EVENT;

	uint   CurIterPos;
};
//
//
//
class SpecialInputCtrlGroup : public CtrlGroup {
public:
	SpecialInputCtrlGroup(uint ctlId, uint rdDelay = 1000);
	~SpecialInputCtrlGroup();
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlId;
	uint   RdDelay;
	SCycleTimer RdTimer;
	PPAbstractDevice * P_Ad;
	StrAssocArray Out;
};
//
//
//
class AcctCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		AcctID AcctId;      // @INOUT
		PPID   AccSheetID;  // @INOUT
		long   AccSelParam; // @IN (ACY_SEL_XXX, -1, -100)
		long   AccType;     // @OUT Type of selected account (ACY_XXX). -1 - undefined
	};
	AcctCtrlGroup(uint _ctl_acc, uint _ctl_art, uint _ctlsel_accnam, uint _stlsel_artnam);
	~AcctCtrlGroup();
	virtual int setData(TDialog *, void *); // (AcctCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (AcctCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   setup(TDialog *, Acct * acct, int sheetChanged, int accSelParamChanged = 0);
	void   processAccCombo(TDialog *);
	void   processArtCombo(TDialog *);
	int    processAccInput(TDialog *);
	int    processArtInput(TDialog *);

	PPObjAccTurn * ppobj;
	AcctID AcctId;
	PPID   AccSheetID;
	PPID   CurID;
	long   AccSelParam;
	uint   ctl_acc;
	uint   ctl_art;
	uint   ctlsel_accname;
	uint   ctlsel_artname;
};

class ArticleCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec();
		SLAPI  Rec(PPID acsID, PPID opID, const ObjIdListFilt * pArList);
		SLAPI  Rec(PPID acsID, PPID opID, PPID arID);

		PPID   AcsID;
		PPID   OpID;
		ObjIdListFilt ArList;
	};
	enum {
		fByOpAccSheet2        = 0x0001, // При выборе вида операции брать дополнительную таблицу статей операции
		fNonEmptyExchageParam = 0x0002  // @v9.2.1 Показывать только статьи с не пустой конфигурацией обмена в соглашении
			// Проекция флага sacfNonEmptyExchageParam
	};
	ArticleCtrlGroup(uint ctlselAcs, uint ctlselOp, uint ctlselAr, uint cmEditList, long accSheetID, long flags = 0);
	int    SetAccSheet(long accSheetID);
	virtual int setData(TDialog *, void *); // (ArticleCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (ArticleCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    selectByCode(TDialog *);
	void   SetupAccSheet(TDialog * pDlg);
	void   SetupOp(TDialog * pDlg);

	Rec    Data;
	PPID   OpID;
	PPID   AccSheetID;
	long   Flags;
	uint   CtlselAcs;
	uint   CtlselOp;
	uint   CtlselAr;
	uint   CmEditList;
};

class SCardSelExtra : public WordSel_ExtraBlock {
public:
	SCardSelExtra(PPID serId);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   SerID;
	PPObjSCard ScObj;
};

class PhoneSelExtra : public WordSel_ExtraBlock {
public:
	enum {
		lfPerson            = 0x0001,
		lfLocation          = 0x0002,
		lfStandaloneLocOnly = 0x0004
	};
	PhoneSelExtra(long localFlags);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	long   LocalFlags;
	//EAddrCore * P_Eac;
	PPObjPerson PsnObj;
};

class FiasSelExtra : public WordSel_ExtraBlock {
public:
	FiasSelExtra(PPFiasReference * pOuterFiasRef);
	~FiasSelExtra();
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	enum {
		stOuterFiasRef = 0x0001
	};
	long   State;
	PPFiasReference * P_Fr;
};

class PersonSelExtra : public WordSel_ExtraBlock {
public:
	PersonSelExtra(PPID accSheetID, PPID personKindID);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   PersonKindID;
	PPID   AccSheetID;     // Если != 0, то означает что поиск будет вестись по статьям, иначе по персоналиям.
	PPID   SrchRegTypeID;
	PPIDArray InhRegTypeList; // список наследуемых регистров для отношения филиал<->главная организаци
	PPObjPerson  PsnObj;
	PPObjArticle ArObj;
};

class ObjTagSelExtra : public WordSel_ExtraBlock {
public:
	enum {
		fOpenedSerialsOnly = 0x0001 // Только для objType == PPOBJ_LOT и tagID == PPTAG_LOT_SN: отображать только серии открытых лотов
	};
	ObjTagSelExtra(PPID objType, PPID tagID);
	void   SetupLotSerialParam(PPID locID, long flags);
	virtual StrAssocArray * GetList(const char * pText);
	virtual int Search(long id, SString & rBuf);
	virtual int SearchText(const char * pText, long * pID, SString & rBuf);
private:
	PPID   ObjType;
	PPID   TagID;
	long   Flags;
	PPID   LocID;
	PPObjTag TagObj;
	StrAssocArray TextBlock;
};

class PersonCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();

		enum {
			fAnonym = 0x0001
		};
		PPID   PsnKindID;
		PPID   PersonID;
		PPID   SCardID;
		long   Flags;
	};
	enum {
		fCanInsert     = 0x0001, // OLW_CANINSERT
		fLoadDefOnOpen = 0x0002, // OLW_LOADDEFONOPEN
		fDefComboFlags = fCanInsert
	};
	PersonCtrlGroup(uint ctlsel, uint ctlSCardCode, long psnKindID, long flags = fDefComboFlags);
	void   SetAnonymCtrlId(uint ctl);
	void   SetPersonKind(long psnKindID);
	virtual int setData(TDialog * pDlg, void *);
	virtual int getData(TDialog * pDlg, void *);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent &);
	int    SelectByCode(TDialog * pDlg);
	void   SetupAnonym(TDialog * pDlg, int a);

	uint   Ctlsel;
	uint   CtlSCardCode; //
	uint   CtlAnonym;    //
	long   Flags;
	Rec    Data;

	PPObjPerson PsnObj;
	PPObjSCard  ScObj;
};

class PersonListCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(PPID psnKindID = 0, const PPIDArray * pPersonList = 0);
		void   Init(PPID psnKindID = 0, const PPIDArray * pPersonList = 0);

		PPID   PsnKindID;
		PPIDArray List;
	};
	PersonListCtrlGroup(uint ctlsel, uint ctlSelPsnKind, uint cmPsnList, long flags);
	~PersonListCtrlGroup();
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    SelectByCode(TDialog *);
	int    Setup(TDialog * pDlg, long psnKindID, int force = 0);

	uint   Ctlsel;
	uint   CtlselPsnKind;
	uint   CmPsnList;
	long   Flags;
	Rec    Data;
	PPObjPerson PsnObj;
};

class SCardCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec();

		PPID   SCardID;
		PPIDArray SCardSerList;
	};
	SCardCtrlGroup(uint ctlselSCardSer, uint ctlSCard, uint cmScsList);
	virtual int setData(TDialog *, void *); // (SCardCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (SCardCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg, int onInit);

	Rec    Data;
	uint   CtlselSCardSer;
	uint   CtlSCard;
	uint   CmSCSerList;
};

class FiasAddressCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec();

		SString InputLine;
		PPID   TerminalFiasID;
        S_GUID TerminalFiasUUID;
	};
	FiasAddressCtrlGroup(uint ctlEdit, uint ctlInfo);
	virtual int setData(TDialog *, void *); // (FiasAddressCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (FiasAddressCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg, int event);
	Rec    Data;
	uint   CtlEdit;
	uint   CtlInfo;

	PPFiasReference Fr;
};

class GoodsFiltCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(PPID grpID = 0, PPID goodsID = 0, PPID locID = 0, long flags = 0, long extra = 0);
		PPID   GoodsID;
		PPID   GoodsGrpID;
		PPID   LocID;
		long   Flags;
		long   Extra;
	};
	GoodsFiltCtrlGroup(uint ctlselGoods, uint ctlselGGrp, uint cm);
	virtual int setData(TDialog *, void *); // (GoodsFiltCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (GoodsFiltCtrlGroup::Rec*)
	int    IsGroupSelectionDisabled() const;
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    EditFilt(TDialog *);
	void   SetupCtrls(TDialog * pDlg);

	int    DisableGroupSelection;
	Rec    Data;
	GoodsFilt Filt;
	uint   CtlselGoods;
	uint   CtlselGoodsGrp;
	uint   Cm;
	PPObjGoods GObj;
};

class BrandCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(const PPIDArray * pList = 0);
		PPIDArray List;
	};
	BrandCtrlGroup(uint ctlsel, uint cmSelList);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    Setup(TDialog * pDlg);

	uint   Ctlsel;
	uint   CmSelList;
	Rec    Data;
};

class EmbedDialog : public TDialog {
public:
	EmbedDialog(uint resID);
	~EmbedDialog();
	int    Embed(TDialog * pDlg);
protected:
	virtual void setChildPos(uint neighbourCtl);
	TDialog * P_ChildDlg;
};
//
// Перенесен из Cshmchn.cpp
//
class CSPanel : public TDialog {
public:
	enum {
		fcspZReport  = 0x0001,
		fcspZRepCopy = 0x0002,
		fcspXReport  = 0x0004
	};
	CSPanel(uint rezID, PPID aNodeID, char * nodeName, int fZReport /* fcspXXX, -1 - is locked */);
private:
	DECL_HANDLE_EVENT;
	void   ResetButtons();

	int    UseKeyboardWKey;
};

class CurAmtCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec();

		double Amount;
		PPID   CurID;
		double CRate;
		double BaseAmount;
		LDATE  CRateDate;
	};
	CurAmtCtrlGroup(uint amtCID, uint curSelCID,
		uint crateCID, uint baseAmtCID, uint dateCID, uint selCRateCmd, AmtList * pAmtList);
	~CurAmtCtrlGroup();
	virtual int setData(TDialog *, void *); // (CurAmtCtrlGroup::Rec *)
	virtual int getData(TDialog *, void *); // (CurAmtCtrlGroup::Rec *)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   setupCurRate(TDialog *, int fromBase);
	void   setupCurrencyCombo(TDialog *, PPIDArray *);

	uint   AmtCID;
	uint   CurSelCID;
	uint   CRateCID;
	uint   BaseAmtCID;
	uint   SelCRateCmd;
	uint   DateCID;
	LDATE  CRateDate;
	Rec    Data;
	AmtList * P_AL;
};

class AccTurnDialog : public TDialog {
public:
	AccTurnDialog(uint rezID, PPObjBill * pBObj);
	int    setDTS(PPAccTurn *, PPBillPacket * pPack, long templFlags = 0);
	int    getDTS(PPAccTurn *);
private:
	DECL_HANDLE_EVENT;
	void   setupCurrencyCombo();

	PPObjBill    * P_BObj;
	//AccountCore  * P_AccT;
	PPObjAccount AccObj;
	PPBillPacket * P_Pack;
	PPAccTurn      Data; // В форме идентификаторов
};

class GoodsCtrlGroup : public CtrlGroup {
public:
	enum { // flags
		disableEmptyGoods                 = 0x0001, // Сообщать об ошибке если товар не выбран
		enableSelUpLevel                  = 0x0002, // Разрешать выбор группы верхнего уровня //
		existsGoodsOnly                   = 0x0004, // Выбирать только те товар, которые есть на складе
		enableInsertGoods                 = 0x0008, // Разрешить создание нового товара
		activateGoodsListOnGroupSelection = 0x0010, // Активизировать список товаров при выборе группы
		ignoreRtOnlyGroup                 = 0x0020  // @v6.2.10 Игнорировать ограничение правам доступа единственной группы
	};
	struct Rec {
		SLAPI  Rec(PPID grpID = 0, PPID goodsID = 0, PPID locID = 0, uint flags = 0);
		PPID   GrpID;
		PPID   GoodsID;
		PPID   LocID;      // Склад (используется только если задан флаг existsGoodsOnly)
			// Если 0, то предполагается текущий склад (LConfig.Location)
		PPID   ArID;       // Контекстная статья для поиска товара по артикулу
		uint   Flags;
	};
	GoodsCtrlGroup(uint _ctlsel_grp, uint _ctlsel_goods);
	~GoodsCtrlGroup();
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
	int    setFlagExistsOnly(TDialog *, int on);
	int    setFlag(TDialog * pDlg, long flag, int on);
	int    setFilt(TDialog * pDlg, const GoodsFilt * pFilt);
private:
	virtual void   handleEvent(TDialog *, TEvent &);
	void   setupCtrls(TDialog *);
	uint   CtlselGrp;
	uint   CtlselGoods;
	uint   CtlGrp;
	uint   CtlGoods;
	uint   Flags;
	PPID   LocID;
	PPID   ArID;           // Контекстная статья для поиска товара по артикулу
	PPID   TempAltGrpID;   // @v8.8.2
	GoodsFilt * P_Filt;
};

class DivisionCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(PPID orgID = 0, PPID divID = 0, PPID staffID = 0, PPID postID = 0);
		PPID   OrgID;
		PPID   DivID;
		PPID   StaffID;
		PPID   PostID;
	};
	DivisionCtrlGroup(uint _ctlsel_org, uint _ctlsel_div, uint _ctlsel_staff, uint _ctlsel_post);
	int    setData(TDialog *, void *);
	int    getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);
	uint   CtlselOrg;
	uint   CtlselDiv;
	uint   CtlselStaff;
	uint   CtlselPost;
	uint   flags;
	Rec    Data;
	LocationFilt DivF;
};

class CycleCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		PPCycleFilt C;
	};
	CycleCtrlGroup(uint ctlSelCycle, uint ctlNumCycles, uint ctlPeriod);
	CycleCtrlGroup(uint ctlSelCycle, uint ctlPdc, uint ctlNumCycles, uint ctlPeriod);
	CycleCtrlGroup(uint ctlSelCycle, uint ctlNumCycles, TDialog * pPeriodDlg, uint ctlPeriod);
	virtual int setData(TDialog *, void *); // (CycleCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (CycleCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    setupCycleCombo(TDialog *, int);
	int    Recalc(TDialog * pDlg, uint leaderCtl);

	uint   CtlSelCycle;
	uint   CtlPdc;        // @v8.6.1 Контрол для ввода точной продолжительности периода (дней)
	uint   CtlNumCycles;
	uint   CtlPeriod;
	long   InpUpdLock;
	TDialog * P_PrdDialog; // don't owned by CycleCtrlGroup
};

class QCertCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(PPID qCertID = 0);
		PPID   QCertID;
	};
	QCertCtrlGroup(uint ctlInput, uint selCmd = cmSelQc);
	~QCertCtrlGroup();
	virtual int setData(TDialog *, void *); // (QCertCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (QCertCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	void   selectQCert(TDialog *);
	void   setupQcNumber(TDialog *);

	uint   CtlInput;
	uint   SelCmd;
	QCertCtrlGroup::Rec Data;
	PPObjQCert QcObj;
};

class MailAccCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		PPID   MailAccID;
		long   Extra;
	};
	MailAccCtrlGroup(uint ctlSelInput, uint editCmd = cmEditMailAcc);
	virtual int setData(TDialog *, void *); // (MailAccCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (MailAccCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlSelInput;
	uint   EditCmd;
	MailAccCtrlGroup::Rec Data;
};

class LocationCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(const ObjIdListFilt * pLocList = 0, PPID parentID = 0);
		ObjIdListFilt LocList;
		PPID   ParentID;
	};
	enum {
		fEnableSelUpLevel  = 0x0001, // Допускается выбор группы складов
		fWarehouseCell     = 0x0002, // Применять для выбора складской ячейки
		fStandaloneByPhone = 0x0004  // @v9.4.4 Выбор автономной локации по номеру телефона
	};
	LocationCtrlGroup(uint ctlselLoc, uint ctlCode, uint ctlPhone, uint cmEditLocList, uint cmEditLoc, long flags, const PPIDArray * pExtLocList);
	//LocationCtrlGroup(uint ctlselLoc, uint cmEditLocList, long flags, const PPIDArray * pExtLocList);
	//LocationCtrlGroup(uint ctlselLoc, uint ctlCode, uint cmEditLocList, long flags);
	//LocationCtrlGroup(uint ctlPhone, uint cmEditLoc, long flags);
	int    SetExtLocList(const PPIDArray * pExtLocList);
	void   SetInfoCtl(uint ctlId);
	virtual int setData(TDialog *, void *); // (LocationCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (LocationCtrlGroup::Rec*)

	int    SetWarehouseCellMode(TDialog * pDlg, int enable);
	int    SetCellSelectionByGoods(TDialog * pDlg, PPID goodsID);
private:
	void   SLAPI Helper_Construct();
	virtual void handleEvent(TDialog *, TEvent &);
	int    SLAPI EditLocList(TDialog * pDlg, uint ctlID, ObjIdListFilt * pLocList);
	void   SLAPI SetupInfo(TDialog * pDlg, PPID locID);

	Rec    Data;
	uint   CtlselLoc;
	uint   CmEditLocList;
	uint   CmEditLoc;
	uint   CtlCode;        // Поле ввода кода склада
	uint   CtlPhone;       // @v9.4.4 Поле ввода номера телефона для выбора автономной локации
	uint   CtlInfo;        // @v9.4.5 Поле с информацией об адресе
	long   Flags;          // @flags
	PPID   GoodsID;        // Товар, по наличию которого следует отбирать ячейки
	PPIDArray ExtLocList;  // @v8.1.9 Список дополнительных локаций, которые не относятся к основному списку.
	PPObjLocation LocObj;  // @v9.4.4
};
//
// Descr: Группа выбора кассового (POS) узла либо списка узлов.
//   Состоит из комбо-бокса и кнопки выбора списка.
//
class PosNodeCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	PosNodeCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (PosNodeCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (PosNodeCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	uint   Ctlsel;
	uint   CmEditList;
};

class QuotKindCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	QuotKindCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (QuotKindCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (QuotKindCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	uint   Ctlsel;
	uint   CmEditList;
};

class StaffCalCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(const ObjIdListFilt * pList = 0);
		ObjIdListFilt List;
	};
	StaffCalCtrlGroup(uint ctlsel, uint cmEditList);
	virtual int setData(TDialog *, void *); // (StaffCalCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (StaffCalCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	Rec    Data;
	uint   Ctlsel;
	uint   CmEditList;
};

class PersonOpCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(const ObjIdListFilt * pPsnOpList = 0, PPID prmrID = 0, PPID scndID = 0);
		PPID   PrmrID;
		PPID   ScndID;
		ObjIdListFilt PsnOpList;
	};
	PersonOpCtrlGroup(uint ctlselPsnOp, uint ctlselPsn1, uint ctlselPsn2, uint cmEditPsnList);
	virtual int setData(TDialog *, void *); // (PersonOpCtrlGroup::Rec*)
	virtual int getData(TDialog *, void *); // (PersonOpCtrlGroup::Rec*)
private:
	virtual void handleEvent(TDialog *, TEvent &);
	int    EditList(TDialog * pDlg);
	int    ReplySelection(TDialog *);

	Rec    Data;
	uint   CtlselPsnOp;
	uint   CtlselPsn1;
	uint   CtlselPsn2;
	uint   CmEditPsnOpList;
	PPObjPsnOpKind PokObj;
};
//
//
//
class WLDialog : public TDialog {
public:
	WLDialog(uint rezID, uint _wlCtlID);
	void   setWL(int s);
	int    getWL() const;
protected:
	DECL_HANDLE_EVENT;
	void   toggleWL(int);
	uint   wlCtlID;
	long   wl;
};
//
// GoodsDialog
//
class GoodsDialog : public TDialog {
public:
	GoodsDialog(uint rezID);
	int    setDTS(const PPGoodsPacket *);
	int    getDTS(PPGoodsPacket *);
private:
	DECL_HANDLE_EVENT;
	void   editBarcodeList();
	void   setupBarcode();
	int    getBarcode();
	void   printLabel();     // F7
	void   printInfoLabel(); // Ctrl-K
	void   completeByClass();
	void   setupInhTaxGrpName();
	void   SetupAddedInfo();

	GoodsPacketKind gpk;
	PPGoodsPacket   Data;
	PPObjGoods GObj;
	enum {
		stWoTaxFlagDisabled   = 0x0001,
		stOrgWoTaxFlagsIsTrue = 0x0002,
		stPrevGenTag          = 0x0004   // Значение признака "Обобщенный" до начала редактирования //
			// Инициализируется в setDTS, используется в getDTS
	};
	long   St;
	StringSet SSExts;
	enum {
		dummyFirst = 1,
		brushPriorBarcode    // Цвет поля штрихкода, если там установлен приоритетный штрихкод
	};
	SPaintToolBox Ptb;
};

class ClsdGoodsDialog : public TDialog {
public:
	ClsdGoodsDialog(uint dlgID, PPGdsClsPacket * pGcPack, int modifyOnlyExtRec);
	int    setDTS(const PPGoodsPacket *);
	int    getDTS(PPGoodsPacket *);
private:
	DECL_HANDLE_EVENT;
	int    setupGdsClsProp(uint selID, uint labelID, uint flag, PPGdsClsProp *, PPID dataID);
	int    setupGdsClsDim(uint inpID, uint selCmd, uint labelID, uint zeroID, uint flag, PPGdsClsDim *, long val);
	void   setupZeroDim(uint zeroCtlId, uint inpId, uint selCmd);
	int    selectDim(uint inpID, PPGdsClsDim *);
	int    getDim(uint ctlID, uint zeroID, long f, const PPGdsClsDim * pDim, long * pVal);
	void   printLabel();

	int    ModifyOnlyExtRec;
	long   ZeroFlags;         // @v7.7.2 Поле для установки признаков обнуления числовых классификаторов при массовом изменении.
	PPGoodsPacket Data;
	PPGoodsPacket Org;
	PPGdsClsPacket GcPack;
};
//
// Descr: Структура редактирования маски параметров класса товаров
//
struct GdsClsParamMask {
	//
	// ARG(options IN):
	//   0x0001 - запретить изменение класса
	//
	int    Edit(long options);

	PPID   ClsID;
	long   Mask;
};
//
//
//
class GoodsMovFiltDialog : public WLDialog {
public:
	GoodsMovFiltDialog();
	int    setDTS(const GoodsMovFilt *);
	int    getDTS(GoodsMovFilt *);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls();

	GoodsMovFilt Data;
};
//
// Диалог расширенного выбора товара для товарной операции
//

#define TIDIF_PACKS     0x00000001L // TIDlgInitData::Quantity in packs
#define TIDIF_AUTOCLOSE 0x00000002L // Автоматом закрывать диалог если Quantity != 0
#define TIDIF_DSBLGSEL  0x00000004L // Запретить выбор товара, отличного от TIDlgInitData::GoodsID
#define TIDIF_AUTOQTTY  0x00000008L // автоматическое добавление 1-цы товара, без вывода диалога

struct TIDlgInitData {
	SLAPI  TIDlgInitData();
	void   FASTCALL SetTiSign(int tisign);
	int    GetTiSign() const;
	//
	// Descr: Режим ввода строки модификации
	//
	enum {
		mmUndef    = 0, // Не определен
		mmExpend   = 1, // Расход
		mmIncoming = 2, // Выход
		mmRecompl  = 3  // Рекомплектация
	};
	PPID   GoodsGrpID;
	PPID   GoodsID;
	PPID   LotID;      // Используется при выборе по серийному номеру лота
	PPID   ArID;       // Контекстная статья для поиска товара по артикулу и проверки принадлежности
		// товара к матрице (для внутренней передачи)
	long   Flags;
	int    ModifMode;  // @v8.4.12 режим ввода строки модификации TISIGN_MINUS||TISIGN_PLUS||TISIGN_RECOMPLETE
	char   Serial[32]; // Выбранный пользователем серийный номер
	double Quantity;
	double MinQtty;
	double MaxQtty;
};

class ExtGoodsSelDialog : public TDialog {
public:
	enum {
		fExistsOnly      = 0x0001, // Показывать только те товары, которые есть на остатке
			// Если opID является расходной операцией, либо переоценкой, либо товарным заказом
			// в котором установлен флаг OPKF_ORDEXSTONLY, и не установлен флаг fForceExhausted,
			// то и без флага fExistsOnly в списке будут только товары, которые есть на остатке.
		fForceExhausted  = 0x0002, // Если установлен, то будут безусловно показаны товары, которых
			// нет на остатке.
		fByName          = 0x0004,
		fHidePassive     = 0x0008,
		fForcePassive    = 0x0010,
		fSelByPrice      = 0x0020, // @internal В конструкторе игнорируется //
		fSelByList       = 0x0040, // @internal В конструкторе игнорируется //
		fMatrix          = 0x0080, // @internal В конструкторе игнорируется //
		fSelByStrList    = 0x0100, // @internal В конструкторе игнорируется //
		fUseLotSelOnExp  = 0x0200, // @v8.4.11 Если fExistsOnly, то выбирать из лотов
		fSelectModifMode = 0x0400  // @v8.4.12 В диалог включается выбор знака операции (для модификации): расход/выход/рекомплектация
	};
	ExtGoodsSelDialog(PPID opID, PPID initGoodsGrpID = 0, long flags = 0);
	~ExtGoodsSelDialog();
	void   setSelectionByPrice(double price);
	void   setSelectionByGroup();
	void   setSelectionByGoodsList(const PPIDArray *, const char * pInfoText = 0);
	void   setSelectionByGoodsList(const StrAssocArray *, const char * pInfoText = 0);
	void   setLocation(PPID locID);
	int    setDTS(TIDlgInitData *);
	int    getDTS(TIDlgInitData *);
private:
	DECL_HANDLE_EVENT;
	void   updateList(int pos);
	void   searchBarcode();
	//
	// Returns:
	//   >0 - список был обновлен
	//   <0 - список не был обновлен из-за того, что grp==0 && gooodsID==0
	//
	int    selectGoods(PPID grp, PPID goodsID);
	PPID   getSelectedItem();

	SmartListBox * P_List;
	PPObjGoods GObj;
	PPIDArray IdList;
	StrAssocArray StrIdList;
	PPID   OpID;
	PPID   LocID;
	PPID   ArID;             // Контекстная статья для поиска товара по артикулу
	PPID   InnerSelectionID; // @v8.2.1 Идентификатор товара, выбранный в результате вывода внутреннего диалога
	long   Flags;
	double Price;
	PPObjTSession::SerialByGoodsListItem SerialData;
	int    UseBrand;
	RECORDNUMBER G2RecCount; // @*ExtGoodsSelDialog::ExtGoodsSelDialog Количество записей в таблице Goods2
	PPObjectTokenizer * P_ObjTkn;
	enum {
		dummyFirst = 1,
		bmMatrix,          // Символ включенной товарной матрицы
		brushModMode_Expend,
		brushModMode_Incoming,
		brushModMode_Recompl
	};
	SPaintToolBox Ptb;     // @v8.5.0
};
//
//
//
struct PickLotParam {
	PickLotParam(int mode);

	enum {
		mByGoodsList = 1,
		mBySerial,
		mByPrice
	};
	int    Mode;
	PPID   LocID;
	double Price;
	SString Text;
	SString SubTitle;
	StrAssocArray GoodsList;
};
//
// Descr: Отображает таблицу выбора открытого лота в соответствии с параметрами rParam
//
int SLAPI PickLot(PickLotParam & rParam, TIDlgInitData * pResult);

class SysJFiltDialog : public TDialog {
public:
	SysJFiltDialog(uint resID);
	int    setDTS(const SysJournalFilt *);
	int    getDTS(SysJournalFilt *);
private:
	DECL_HANDLE_EVENT;
	int    setupCtrls();

	SysJournalFilt Filt;
};
//
//
//
class FileBrowseCtrlGroup : public CtrlGroup {
public:
	static int SLAPI Setup(TDialog * dlg, uint btnCtlID, uint inputCtlID, uint grpID, int titleTextId, int patternId, long flags);
	enum {
		fbcgfFile         = 0x0001,
		fbcgfLogFile      = 0x0002,
		fbcgfPath         = 0x0004,
		fbcgfAllowNExists = 0x0008, // Позволяет выбирать несуществующие файлы
		fbcgfSaveLastPath = 0x0010
	};
	struct Rec {
		char   FilePath[MAXPATH];
	};

	FileBrowseCtrlGroup(uint buttonId, uint inputId, const char * pTitle, long flags);
	//
	// Descr: Устанавливает фильтрацию выбора файлов по расширению в соответствии со строкой,
	//   хранящейся в строковых ресурсах.
	//   Строка должна быть определена в группе PPSTR_TEXT в форме "description:*.ex1;*.ex2..."
	//   Рекомендуемый префикс мнемоники строки PPTXT_FILPAT_XXX.
	//
	int    addPattern(uint strID);
	void   setInitPath(const char * pInitPath);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent&);
	int    showFileBrowse(TDialog *);

	uint   ButtonCtlId;
	uint   InputCtlId;
	StringSet Patterns;
	SString   InitDir;
	SString   InitFile;
	SString   Title;
	long   Flags;       // FileBrowseFlags::fbfXXX
	Rec    Data;
};

class ImageBrowseCtrlGroup : public CtrlGroup {
public:
	enum {
		fUseExtOpenDlg = 0x0001,
		fDisableDetail = 0x0002  // @v9.6.6 Запрет на увеличенное отображение картинки
	};
	struct Rec {
		enum {
			fUpdated = 0x0001 // Изображение было изменено
		};
		Rec(SString * pBuf = 0);

		int    Flags;
		SString Path;
	};
	// Формат строки расширений: Имя:*.ext;*.ext2;*.ext3,Имя:*.ext4;*.ext5;*.ext6, ...
	ImageBrowseCtrlGroup(/* @v9.5.6 uint patternsID,*/uint ctlImage, uint cmChgImage, uint cmDeleteImage, int allowChangeImage = 1, long flags = 0);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlImage;
	uint   CmChgImage;
	uint   CmDelImage;
	int    AllowChangeImage;
	long   Flags;
	Rec    Data;
	SString DefWaitFolder;
	StringSet Patterns;
};

class PrcCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		SLAPI  Rec(PPID prcID = 0);

		PPID   PrcID;
	};
	PrcCtrlGroup(uint ctlSelPrc);
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
private:
	uint   CtlSelPrc;
	Rec    Data;
	PPObjProcessor PrcObj;
};

class PrcTechCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		PPID   PrcID;
		PPID   PrcParentID;
		PPID   TechID;
		PPID   ArID;
		PPID   Ar2ID;
		int    IdleStatus;
	};
	PrcTechCtrlGroup(uint ctlSelPrc, uint ctlSelTech, uint ctlStGoods, uint ctlSelAr, uint ctlSelAr2, uint cmdSelTechByGoods, uint cmdCreateGoods = 0);
	virtual int    setData(TDialog *, void *);
	virtual int    getData(TDialog *, void *);
	void   setIdleStatus(TDialog *, int s);
	//
	// Descr: Устанавливает возможность выбора группы процессоров в комбо-боксе процессора.
	//   По умолчанию ВКЛЮЧЕНО.
	//
	void   enableSelUpLevel(int enbl);
	//
	// Descr: Утсанавливает возможность создания нового процессора в списке
	//   комбо-бокса процессора.
	//
	void   enablePrcInsert(int enbl);
	int    getGoodsID(TDialog *, PPID * pGoodsID);
private:
	virtual void   handleEvent(TDialog *, TEvent &);
	void   onPrcSelection(TDialog *, int onIdleStatus = 0);
	void   setupArticle(TDialog *, const ProcessorTbl::Rec *);
	void   setupGoodsName(TDialog *);
	void   setupCreateGoodsButton(TDialog *);
	void   selTechByGoods(TDialog *);

	uint   CtlselPrc;
	uint   CtlselTech;
	uint   CtlStGoods;
	uint   CtlselAr;
	uint   CtlselAr2;
	uint   CmdSelTechByGoods;
	uint   CmdCreateGoods;
	PPID   SelGoodsID;
	PPID   AutoGoodsGrpID; // @!PrcTechCtrlGroup::setupCreateGoodsButton()
		// ИД товарной группы, для которой по выбранному процессору
		// существует автотехнология и, следовательно, можно создать новый товар с
		// автоматическим созданием технологии.
		// Если AutoGoodsGrpID && CmdCreateGoods тогда кнопка создания товара
		// становится видимой и доступной для использования.
		//
	Rec    Data;
	int    IdleStatus;
	enum {
		fEnableSelUpLevel = 0x0001,
		fEnablePrcInsert  = 0x0002
	};
	long   Flags;

	PPObjGoods GObj;
	PPObjTech  TecObj;
};

class SpinCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		long Value;
	};
	SpinCtrlGroup(uint ctlEdit, uint cmdUp, uint ctlUp, uint cmdDown, uint ctlDown, long minVal, long maxVal);
	virtual int setData(TDialog *, void *);
	virtual int getData(TDialog *, void *);
private:
	virtual void handleEvent(TDialog *, TEvent &);

	uint   CtlEdit;
	uint   CmdUp;
	uint   CmdDown;
	uint   CtlUp;
	uint   CtlDown;
	long   MinVal;
	long   MaxVal;

	Rec    Data;
};

class ColorCtrlGroup : public CtrlGroup {
public:
	struct Rec {
	public:
		static const COLORREF UndefC;

		Rec();
		void   SetupStdColorList();
		int    AddColorItem(SColor c, const char * pName);
		int    AddColorItem(COLORREF rgb, const char * pName);
		int    AddUndefColorItem();
		uint   GetColorItemsCount() const;
		int    GetColorItem(uint pos, COLORREF & rC, SString & rNameBuf) const;
		int    SearchColorItem(COLORREF c, uint * pPos) const;

		COLORREF C;
		StrAssocArray ColorList;
	};
	ColorCtrlGroup(uint ctl, uint ctlSel, uint cmNewColor, uint ctlNewColor);
	~ColorCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	uint   CmNewColor;
	uint   Ctl;
	uint   CtlSel;
	uint   CtlNewColor;
	Rec    Data;
	StrAssocArray ListData;
	HBRUSH H_BrBkList;
	HBRUSH H_BrSelList;
	HBRUSH H_BrFrameList;
	HBRUSH H_BrBkInput;
};

class TimePickerCtrlGroup : public CtrlGroup {
public:
	TimePickerCtrlGroup(uint ctl, uint ctlSel, TDialog * pDlg);
	~TimePickerCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	int    Edit(TDialog *);

	LTIME  Data;
	ushort Cmd;
	uint16 Reserve; // @alignment
	uint   Ctl;
	uint   CtlSel;
};
//
//
//
class PalletCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		PPID   GoodsID;
		PPID   PalletTypeID;
		uint   PalletCount;
		double Qtty;
	};
	PalletCtrlGroup(uint ctlselPalletType, uint ctlPallet, uint ctlPalletCount, uint ctlPckg, uint ctlPckgCount, uint ctlQtty, uint ctlselGoods);
	int    SetupGoods(TDialog * pDlg, PPID goodsID);
private:
	virtual void handleEvent(TDialog*, TEvent&);
	virtual int setData(TDialog*, void*);
	virtual int getData(TDialog*, void*);
	int    RecalcQtty(TDialog * pDlg, int cargoUnit);
	int    SetupPallet(TDialog * pDlg, int doSelect);

	uint   CtlselPalletType;
	uint   CtlPallet;
	uint   CtlPalletCount;
	uint   CtlPckg;
	uint   CtlPckgCount;
	uint   CtlQtty;
	uint   CtlselGoods;

	enum {
		stInputUpdLock = 0x0002  // Блокировка обработки события ввода (во избежании рекурсии)
	};
	long   State;
	Rec    Data;
	GoodsStockExt Gse; // Карго-факторы текущего выбранного товара
	PPObjGoods GObj;
};
//
//
//
class QuantityCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec();
		int    FASTCALL operator == (const Rec & rS) const;

		double UnitPerPack;
		double Packs;
		double PackTail;
		double Qtty;
	};
	QuantityCtrlGroup(uint ctlUpp, uint ctlPacks, uint ctlQtty);
private:
	virtual int setData(TDialog*, void*);
	virtual int getData(TDialog*, void*);
	virtual void handleEvent(TDialog*, TEvent&);

	int    ReadFld(TDialog * pDlg, uint master, uint ctl);
	void   SetupQuantity(TDialog * pDlg, uint master, int readFlds);

	uint   CtlUpp;
	uint   CtlPacks;
	uint   CtlQtty;
	int    LockUpdByInput;
	Rec    Data;
};

struct TagDlgParam {
	int    SLAPI GetDlgID(long tagDataType, uint * dlgCtl) const;
	int    SLAPI SetDlgData(TDialog *, const ObjTagItem *);
	int    SLAPI GetDlgData(TDialog *, ObjTagItem *);

	PPID   ObjType;
	PPID   ObjID;

	uint   BoolDlgID;
	uint   NmbDlgID;
	uint   LnkDlgID;
	uint   StrDlgID;
	uint   DateDlgID;
	uint   TimestampDlgID;
	uint   GuidDlgID;
	uint   ImgDlgID;

	uint   ObjNameCtl;
	uint   TagNameCtl;
	uint   ValBoolCtl;
	uint   ValNmbCtl;
	uint   ValLnkCtl;
	uint   ValStrCtl;
	uint   ValDateCtl;
	uint   ValTimeCtl;
	uint   ValGuidCtl;
	uint   ValImgCtl;
};
//
//
//
class PPListDialog : public TDialog {
public:
	//
	// Descr: Флаги конструктора
	//
	enum {
		fOnDblClkOk = 0x0001 // При двойном щелчке, если выбран элемент списка завершать работу диалога как по cmOK
	};
	SLAPI  PPListDialog(uint rezID, uint aCtlList, long flags = 0);
	int    SLAPI addStringToList(long id, const char * pText);
	int    SLAPI getSelection(long * pID);
	void   SLAPI updateList(long, int byPos = 1);
protected:
	DECL_HANDLE_EVENT;
	virtual int setupList();
	virtual int addItem(long * pPos, long * pID); // @<<PPListDialog::_addItem (reply on cmaInsert)
	virtual int editItem(long pos, long id); // @<<PPListDialog::_editItem (reply on cmaEdit or cmLBDblClk)
	virtual int delItem(long pos, long id); // @<<PPListDialog::_delItem (reply on cmaDelete)
	virtual int sendItem(long pos, long id);
	//
	// Descr: Должна переместить элемент в позиции pos и идентификатором id вверх или вниз по списку.
	//   Если параметр up != 0, то функция должна переместить элемент вверх по списку, если up == 0,
	//   то функция должна переместить элемент вниз по списку.
	//   Класс вызывает эту функцию в ответ на команду cmUp или cmDown
	// Returns:
	//   >0 - элемент был успешно перемещен
	//   <0 - функция не поддерживается, либо элемент не может быть перемещен в силу причин,
	//        не являющихся ошибочными (не куда или нечего перемещать).
	//   0  - ошибка
	//
	virtual int moveItem(long pos, long id, int up);
	int    SLAPI getCurItem(long * pPos, long * pID);

	uint   ctlList;
	enum {
		oHasOkButton   = 0x0001,
		oHasEditButton = 0x0002,
		oOnDblClkOk    = 0x0004
	};
	long   Options;
	SmartListBox * P_Box;
};

class ObjRestrictListDialog : public PPListDialog {
public:
	ObjRestrictListDialog(uint dlgID, uint listCtlID);
	void   setParams(PPID objType, ObjRestrictArray *);
protected:
	DECL_HANDLE_EVENT;
	virtual int    setupList();
	virtual int    addItem(long * pPos, long * pID);
	virtual int    editItem(long pos, long id);
	virtual int    delItem(long pos, long id);
	virtual int    getObjName(PPID objID, long objFlags, SString & rBuf);
	virtual void   getExtText(PPID objID, long objFlags, SString & rBuf);
	virtual int    editItemDialog(ObjRestrictItem *) { return -1; }

	PPID   ObjType;
	ObjRestrictArray * P_ORList; // ObjRestrictListDialog not owner of P_ORList
};

class AmtListDialog : public PPListDialog {
public:
	AmtListDialog(uint resID, uint listCtlID, int useCurCol, AmtList *, PPIDArray *, const char * aTitle, uint o);
	void   setCRateDate(LDATE);
	int    getDTS(AmtList *);
protected:
	virtual int setupList();
	virtual int addItem(long * pos, long * id);
	virtual int editItem(long pos, long id);
	virtual int delItem(long pos, long id);
	int    editAmount(int pos);
	int    setupListEntry(PPID idx, AmtEntry *);

	int    UseCurColumn;
	uint   Options;
	LDATE  CRateDate;
	AmtList   Data;
	int       HasRestrict;
	PPIDArray RestrictList;
	PPIDArray PosList;
	PPObjAmountType AmtObj;
};

class BankingOrderDialog : public TDialog {
public:
	BankingOrderDialog();
	int    setDTS(PPBankingOrder *);
	int    getDTS(PPBankingOrder *);
private:
	DECL_HANDLE_EVENT;
	int    setupPerson(int payerOrRcvr, PPID personID, PPID * pBnkAccID);
	int    setupBnkAcc(int payerOrRcvr, PPID bnkAccID);
	int    editTaxMarkers();
	void   setupVAT();
	void   swapPersons();

	enum {
		dummyFirst = 1,
		brushValidNumber,
		brushInvalidNumber
	};

	int PayerValidCode;
	int RcvrValidCode;
	SPaintToolBox  Ptb;
	PPBankingOrder Data;
	PPObjPerson    PsnObj;
	RegisterFilt BnkAccFilt;
};

class TagEnumListDialog : public PPListDialog {
public:
	TagEnumListDialog(uint dlgID, uint listCtlID, size_t listBufLen);
	int    setDTS(const PPTagEnumList *);
	int    getDTS(PPTagEnumList *);
private:
	virtual int setupList();
	virtual int addItem(long * pos, long * id);
	virtual int editItem(long pos, long id);
	virtual int delItem(long pos, long id);

	PPTagEnumList  Data;
};

struct GoodsGroupItem : Goods2Tbl::Rec {
	long   Level;
	char   Code[24]; // @v8.8.0 [16]-->[24]
};

class GoodsGroupView : public PPListDialog {
public:
	GoodsGroupView(PPObjGoodsGroup * _ppobj);
	~GoodsGroupView();
	//
	// Returns:
	//   0 - all groups,
	//   1 - normal groups,
	//   2 - alt groups
	//
	int    GetGrpType();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(GoodsGroupItem * pItem);
private:
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	PPID   getCurrID();
	void   ViewGoodsByGroup(long);
	void   editQuotations(long, int quotCls);
	void   setupButtons();
	void   updateList(long);
	int    Print();

	PPID   CurIterID;
	GoodsGroupIterator * P_Iter;
	PPObjGoodsGroup GGObj;
	TPoint mouse;
};
//
//
//
class PsnOpKindView : public PPListDialog {
public:
	PsnOpKindView(PPObjPsnOpKind * _ppobj);
	~PsnOpKindView();
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(PPPsnOpKind * pItem);
	long   GetLevel(PPID opKindID);
	int    CopyList(PPID parentID, StrAssocArray * pSrc, StrAssocArray * pDest);
private:
	DECL_HANDLE_EVENT;
	virtual int  setupList();
	virtual int  addItem(long * pos, long * id);
	virtual int  editItem(long pos, long id);
	virtual int  delItem(long pos, long id);
	PPID   getCurrID();

	uint   IterNo;
	StrAssocArray * P_Items;
	PPObjPsnOpKind Obj;
};
//
// Диалог отправки эл. письма
//
class SendMailDialog : public PPListDialog {
public:
	struct Rec {
		Rec();
		Rec & FASTCALL operator = (const Rec & rSrc);

		PPID   MailAccID; // Аккаунт, с которого отправляются письма
		uint32 Delay;     // Задержка между отправкой писем
		SString Subj;
		SString Text;
		StrAssocArray  AddrList;
		SStrCollection FilesList;
	};
	SendMailDialog();
	int    setDTS(const Rec *);
	int    getDTS(Rec *);
private:
	virtual int setupList();
	virtual int addItem(long * pPos, long * pID);
	virtual int editItem(long pos, long id);
	virtual int delItem(long pos, long id);

	Rec    Data;
};

class EmailCtrlGroup : public CtrlGroup {
public:
	struct Rec {
		Rec(StrAssocArray * pAddrList = 0);
		StrAssocArray AddrList;
	};
	EmailCtrlGroup(uint ctl, uint cm);
	~EmailCtrlGroup();
	virtual int setData(TDialog * pDlg, void * pData);
	virtual int getData(TDialog * pDlg, void * pData);
private:
	virtual void handleEvent(TDialog * pDlg, TEvent & event);
	int    SetLine(TDialog *);
	int    Edit(TDialog *);

	uint   Cm;
	uint   Ctl;
	Rec    Data;
};

struct EmailToBlock {
	EmailToBlock()
	{
		MailAccID = 0;
	}
	enum {
		efDisableAccount = 0x0001 // Запретить выбор аккаунта (актуально в случае, если в момент использования сеанс не будет авторизован)
	};
	int    SLAPI Edit(long flags);

	PPID   MailAccID;
	SString Subj;
	StrAssocArray AddrList;
};
//
//
//
#define USE_LOGLISTWINDOWSCI

class TVMsgLog : public PPMsgLog {
public:
	// only for dos, for windows do nothing if winDestroy = 0
	static void Delete_(TVMsgLog * pMsgLog, int winDestroy = 0);

	SLAPI  TVMsgLog();
	virtual SLAPI ~TVMsgLog();
	virtual long SLAPI ImplPutMsg(const char * pText, long flags);
	virtual int  SLAPI ShowLogWnd(const char * pTitle = 0);
	void   SLAPI RefreshList();
protected:
	friend class LogListWindow;
#ifdef USE_LOGLISTWINDOWSCI
	LogListWindowSCI * P_LWnd;
#else
	LogListWindow * P_LWnd;
#endif
	long   HorzRange;
};
//
// LotQCertDialog (Defined in V_LOT2.CPP)
//
struct LotQCertData {
	PPID   LotID;
	PPID   QCertID;
	LDATE  Expiry;
	char   Serial[32];
	char   CLB[32];
	int    IsInheritedClb;
};

class LotQCertDialog : public TDialog {
public:
	LotQCertDialog(PPObjBill * pBObj);
	int    setDTS(const LotQCertData *);
	int    getDTS(LotQCertData *);
private:
	DECL_HANDLE_EVENT;
	void   generateSerial();

	LotQCertData Data;
	PPObjBill * P_BObj;
};
//
// Descr: Диалог редактирования параметров повторения DateRepeating
//
class RepeatingDialog : public EmbedDialog {
public:
	enum {
		fEditTime            = 0x0001,
		fEditDuration        = 0x0002,
		fEditRepeatAfterItem = 0x0004
	};
	RepeatingDialog(uint options = 0 /* RepeatingDialog::fXXX */);
	~RepeatingDialog();
	void   setInitDate(LDATE);
	int    setDTS(const DateRepeating *);
	int    getDTS(DateRepeating *);
	int    setDuration(long);
	int    getDuration(long * pDuration);
private:
	DECL_HANDLE_EVENT;

	int    embedChild(long prd);
	int    embedOneChild(TDialog * pDlg);
	void   test();
	DateRepeating * P_Data;
	long   PrevPrd;
	LDATE  InitDate;
	long   Duration;
	uint   Options;
};
//
// Descr: Общий диалог редактирования параметров импорта/экспорта.
//   Другие диалоги могут наследовать упарвляющие элементы и поведение этого диалога.
//
class ImpExpParamDialog : public TDialog {
public:
	enum {
		fDisableImport = 0x0001,
		fDisableExport = 0x0002,
		fDisableName   = 0x0004
	};
	ImpExpParamDialog(uint dlgID, long options = 0);
	int    setDTS(const PPImpExpParam *);
	int    getDTS(PPImpExpParam *);
protected:
	DECL_HANDLE_EVENT;

	PPImpExpParam Data;
	long   Flags;
	int    EnableExcelImpExp;
};
//
// Descr: Общий диалог редактирования списка параметров импорта/эскпорта.
//  Другие диалоги могут наследовать управляющие элементы и поведение этого диалога.
//
class ImpExpCfgListDialog : public PPListDialog {
public:
	ImpExpCfgListDialog();
	ImpExpCfgListDialog(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pDlg);
	int    SetParams(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pDlg);
private:
	virtual int setupList();
	virtual int addItem(long * pPos, long * pID);
	virtual int editItem(long pos, long id);
	virtual int delItem(long pos, long id);
	virtual int EditParam(const char *);

	uint   IniFileID;
	uint   SDRecID;
	StringSet Sections;
	PPImpExpParam * P_Param;
	ImpExpParamDialog * P_ParamDlg;
};
//
//
//
class GoodsImpExpDialog : public ImpExpParamDialog {
public:
	GoodsImpExpDialog();
	int    setDTS(const PPGoodsImpExpParam * pData);
	int    getDTS(PPGoodsImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);

	PPGoodsImpExpParam Data;
};
//
//
//
class QuotImpExpDialog : public ImpExpParamDialog {
public:
	QuotImpExpDialog();
	int    setDTS(const PPQuotImpExpParam * pData);
	int    getDTS(PPQuotImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);

	PPQuotImpExpParam Data;
};
//
//
//
class PersonImpExpDialog : public ImpExpParamDialog {
public:
	PersonImpExpDialog();
	int    setDTS(const PPPersonImpExpParam * pData);
	int    getDTS(PPPersonImpExpParam * pData);
private:
	PPPersonImpExpParam Data;
};
//
//
//
class PhoneListImpExpDialog : public ImpExpParamDialog {
public:
	PhoneListImpExpDialog();
	int    setDTS(const PPPhoneListImpExpParam * pData);
	int    getDTS(PPPhoneListImpExpParam * pData);
private:
	PPPhoneListImpExpParam Data;
};
//
//
//
class SCardImpExpDialog : public ImpExpParamDialog {
public:
	SCardImpExpDialog();
	int    setDTS(const PPSCardImpExpParam * pData);
	int    getDTS(PPSCardImpExpParam * pData);
private:
	PPSCardImpExpParam Data;
};
//
//
//
class LotImpExpDialog : public ImpExpParamDialog {
public:
	LotImpExpDialog();
	int    setDTS(const PPLotImpExpParam * pData);
	int    getDTS(PPLotImpExpParam * pData);
private:
	PPLotImpExpParam Data;
};
//
//
//
class BillHdrImpExpDialog : public ImpExpParamDialog {
public:
	BillHdrImpExpDialog();
	int    setDTS(const PPBillImpExpParam * pData);
	int    getDTS(PPBillImpExpParam * pData);
private:
	DECL_HANDLE_EVENT;
	void   SetupCtrls(long direction);

	PPBillImpExpParam Data;
};
//
//
//
#if 0 // @v9.1.3 {
class CSessComplexImpExpDialog : public ImpExpParamDialog {
public:
	CSessComplexImpExpDialog();
	int    setDTS(const PPCSessComplexImpExpParam * pData);
	int    getDTS(PPCSessComplexImpExpParam * pData);
private:
	PPCSessComplexImpExpParam Data;
};
#endif // } 0 @v9.1.3

class PsnEventDialog : public PPListDialog {
public:
	struct Param : public TagDlgParam {
		char   DlgTitle[48];
		uint   ExValGrp;
	};
	static int SLAPI GetParam(PPID pokID, Param * pParam);

	PsnEventDialog(Param * pParam, PPObjPersonEvent * pPeObj);
	int    setDTS(PPPsnEventPacket *);
	int    getDTS(PPPsnEventPacket *);
private:
	DECL_HANDLE_EVENT;
	virtual int setupList();
	virtual int addItem(long * pPos, long * pID);
	virtual int editItem(long pos, long id);
	virtual int delItem(long pos, long id);
	void   editRegister();
	int    setupPost(int fromDialog);
	int    setupPair();
	int    Print();
	int    GetReportID();

	PPObjTag TagObj;
	Param  P;
	PPPsnOpKindPacket PokPack;
	PPPsnEventPacket  Pack;
	PPObjPersonEvent * P_PeObj;
};
//
// Descr: ReceiveMailPrctFunc
//
void   CallbackRMailPrctFunc(long *pPrc, long total, long addedInfo1, long addedInfo2);
//
// Descr: Копирует почту на носитель или отправляет по электронной почте
//
int    SLAPI PutTransmitFiles(PPID, long trnsmFlags);
//
// Descr: Забирает почту с внешнего носителя или из электронной почты
//
int    SLAPI GetTransmitFiles(ObjReceiveParam *);
//
// Descr: возвращает объект, соответствующий идентификатору obj.
//   Так как последствия отсутствия среди зарегестрированных,
//   требуемого объекта предсказать очень трудно, то такая ситуация //
//   обрабатывается макросом assert. Прочие сбои влекут за собой
//   возврат нуля и установку PPErrCode.
//
PPObject * FASTCALL GetPPObject(PPID obj, void * extraPtr);
//
// Descr: Флаги функции PPGetObjTypeList
//
enum {
	gotlfExcludeDyn      = 0x0001, // Не включать в список динамические типы объектов
	gotlfExcludeObsolete = 0x0002, // Не включать в список устаревшие типы объектов
	gotlfExcludeObjBill  = 0x0004  // Не включать в список PPOBJ_BILL
};

int    SLAPI PPGetObjTypeList(PPIDArray * pList, long flags);
int    SLAPI SendObjMessage(int msg, PPID destObj, PPID obj, PPID id, void * msgExtraPtr, ObjCollection * pDestObjColl);
int    SLAPI SendObjMessage(int msg, PPID destObj, PPID obj, PPID id);
int    SLAPI PPGetConfigList(StrAssocArray *);
//
// Descr: посылает сообщение msg всем объектам за исключением объекта srcObjType
//   от объекта {srcObjType, srcObjID} с дополнительным параметром msgExtra.
//   Если один из объектов-получателей вернул в ответ на сообщение DBRPL_ERROR,
//   то исполнение функции прерывается с возвратом значения 0.
// Returns:
//   !0 - все объекты, которым было послано сообщение, отреагировали на сообщение без ошибок
//   0  - по крайней мере один из объектов в ответ на сообщение вернул код DBRPL_ERROR
//
int    SLAPI BroadcastObjMessage(int msg, PPID srcObjType, PPID srcObjID, void * msgExtraPtr);
//
// Descr: функция очень полезна для реализации ComboBox'ов.
//   Фактически возвращает (PPObjListWindow*), однако полагаться //
//   на это не следует. Эта функция создает объект класса PPObject
//   и передает его объекту PPObjListWindow, который разрушаясь удалит и созданный PPObject.
//
ListWindow * SLAPI GetPPObjList(PPID obj, uint flags, void * extraPtr);
//
// Descr: Высокоуровневая функция настройки ComboBox'а. Полагается на то,
//   что ComboBox и его строка подстроены под заданный obj.
// Returns: Если параметр pCombo == 0, то возвращает (<0) ничего не делая.
//   Если все OK, то возвращает (>0). Иначе - 0.
//
int    SLAPI    SetupPPObjCombo(ComboBox * pCombo, PPID objType, PPID initID, uint flags, void * extraPtr);
int    FASTCALL SetupPPObjCombo(TDialog * pDlg, uint ctlId, PPID objType, PPID initID, uint flags, void * extraPtr);
int    FASTCALL SetupPPObjCombo(TDialog * pDlg, uint ctlId, PPID objType, PPID initID, uint flags);
int    SLAPI    SetupObjListCombo(TDialog *, uint, PPID, const PPIDArray * pInclList = 0);
//
// Descr: Специализированные флаги функции SetupArCombo
//
enum {
	sacfDisableIfZeroSheet   = 0x0001, // Заблокировать комбо-бокс если таблица статей не определена
	sacfNonEmptyExchageParam = 0x0002, // Показывать только статьи с не пустой конфигурацией обмена в соглашении
	sacfNonGeneric           = 0x0004  // @v9.5.9 Исключить выбор группирующих статей
};

int    SLAPI SetupArCombo(TDialog * dlg, uint ctlID, PPID id, uint flags, PPID accSheetID, long /*disableIfZeroSheet*/sacf = 0);
	// @>>SetupPPObjCombo
int    SLAPI SetupAmtTypeCombo(TDialog *, uint ctl, PPID id, uint flags, long options, PPIDArray * pInclList);
int    SLAPI SetupCurrencyCombo(TDialog *, uint ctl, PPID id, uint /*flags*/, int asSymb, PPIDArray * pInclList);
int    SLAPI SelectCurRate(PPID curID, PPID rateTypeID, double * pRate);
int    FASTCALL SearchObject(PPID obj, PPID id, void * = 0);
int    SLAPI EditPPObj(PPID objType, PPID objID);
//
// Descr: Возвращает наименование типа объекта (напр. "Документы", "Товары")
//
SString & SLAPI GetObjectTitle(PPID objType, SString & rBuf);
//
// Descr: Возвращает тип объекта, соответствующего символу pSymb.
//   Если символ предполагает уточненяющее значение, то оно возвращается по
//   указателю pExtra.
//   Например, для символа "CITY" функция возвращает PPOBJ_WORLD и
//   по указателю pExtra присваивает WORLDOBJ_CITY.
//
PPID   SLAPI GetObjectTypeBySymb(const char * pSymb, long * pExtra);
int    FASTCALL GetObjectName(PPID objType, PPID objID, char * pBuf, size_t bufLen);
int    FASTCALL GetObjectName(PPID objType, PPID objID, SString &, int cat = 0);
SString & SLAPI GetExtObjectName(const ObjIdListFilt & rObjList, PPID obj, size_t maxItems, SString & rBuf);
int    SLAPI ShowObjects(PPID objType, void * extraPtr);
	// @>>GetPPObject(objType, extra)->Browse(extra)
//
// Supplement procedure. Call simple list viewer with buttons.
// (Implemented in OBJREF.CPP)
//
int    SLAPI SimpleObjView(PPObject * ppobj, void * extraPtr);
int    SLAPI PPSelectObject(PPID objType, PPID *, uint titleID, void * extraPtr);
int    SLAPI RefObjView(PPObject * pObj, long charryID, void * extraPtr);
int    SLAPI PPGenerateKeywordSequence(const char * pContext, SString & rResult, void * pStat);
//
// Descr: Функция ожидающая создание файла pPath или его удаления в зависимости от параметра whileExists
// Параметр notifyTimeout отвечает за ожидание функцией DirChangeNotification::Wait события создания или удаления файла
//
int    SLAPI WaitForExists(const char * pPath, int whileExists, int notifyTimeout = 5000);
int    SLAPI WaitNewFile(const char * pDir, SString & rFile, int notifyTimeout = 5000);
//
// Онлайновый обмен с терминалом сбора данных
//
int    SLAPI StyloBHTExch(TcpSocket *);
//
// Онлайновый обмен с терминалом сбора данных (программа StyloBhtII)
//
int    SLAPI StyloBhtIIExchange(const char * pDbSymb, const char * pName, const char * pPassword, TcpSocket * pSo);
//
// Функции тестирования //
//
//
// Descr: Вызывается до вызова процедуры авторизации в базе данных
//
int    SLAPI TestNoLogin(); // @<<WinMain
//
// Descr: Вызывается после авторизации в базе данных
//
int    SLAPI TestLogin(); // @<<PPApp::login
//
// Descr: Генерация товарных документов
//
int    SLAPI GenerateGoodsBills();
//
// Descr: Генерация платежей для формирования тестовых данных клиент/банк
//
int    SLAPI GenerateCliBnkImpData();
//
// Descr: Функция, создающая и открывающая DBF-таблицу по образцу,
//   заданному в ресурсе rezID (PP_RCDATA).
//
DbfTable * SLAPI CreateDbfTable(uint rezID, const char * fName, int forceReplace);
DbfTable * SLAPI PPOpenDbfTable(const char * pPath);
//
// Descr: Функция форматирования количества товара. Кроме общих флагов
//   форматирования параметр fmt может включать флаги QTTYF_XXX (ppdefs.h)
//   Параметр upp (UnitsPerPack) передает емкость упаковки.
//   Если noabs != 0, то у значения qtty не будет отбрасываться знак минус.
//
char    * SLAPI QttyToStr(double qtty, double pack, long fmt, char * buf, int noabs = 0);
SString & SLAPI MoneyToStr(double nmb, long fmt, SString &);
SString & SLAPI DateToStr(LDATE dt, SString & rBuf);
SString & SLAPI GetCurSymbText(PPID curID, SString & rBuf);
SString & SLAPI VatRateStr(double rate, SString & rBuf);
int    SLAPI GetReportIDByName(const char * pRptName, uint * pRptID);
int    SLAPI StatusWinChange(int onLogon = 0, long timer = -1);
SDateRange FASTCALL DateRangeToOleDateRange(DateRange period);
DateRange  FASTCALL OleDateRangeToDateRange(const SDateRange & rRnd);
SIterCounter GetPPViewIterCounter(const void * ppviewPtr, int * pAppError);
IUnknown * GetPPObjIStrAssocList(SCoClass * pCls, PPObject * pObj, long extraParam);
//
// Descr: Опции функций PPOpenFile
//
enum {
	ofilfNExist = 0x0001 // Можно выбирать отсутствующие файлы
};

int    SLAPI PPOpenFile(SString & rPath, const char * pPatterns, long flags, HWND owner);
int    SLAPI PPOpenFile(uint strID, SString & rPath, long flags, HWND owner);
int    SLAPI PPOpenDir(SString & rPath, const char * pTitle, HWND owner);
//
//
//
struct SelPersonIdent {
	PPID   KindID;
	PPID   PersonID;
};

int    SLAPI SelectPerson(SelPersonIdent *);
int    SLAPI EditObjTagItem(PPID objType, PPID objID, ObjTagItem * item, const PPIDArray * pAllowedTags);
int    SLAPI EditTagFilt(PPID objType, TagFilt *);
int    SLAPI SelectObjTag(PPID * pTagID, const PPIDArray * pAllowedTags, ObjTagFilt * pFilt);
int    SLAPI EditObjTagValList(ObjTagList * pTags, const PPIDArray * allowedTags);
int    SLAPI EditObjTagValList(PPID objType, PPID objID, const PPIDArray * allowedTags);
int    SLAPI SelectPrinterFromWinPool(SString & rPrinter);
//
// Descr: Вызывает диалог редактирования значений тегов для изменения по выборке объектов.
//
int    SLAPI EditObjTagValUpdateList(ObjTagList * pList, const PPIDArray * pAllowedTags, int * pUpdateMode);
//
//
//
struct SelBasketParam : public PPBasketCombine {
	enum {
		fUseGoodsRestAsQtty     = 0x0001,  // Количество товара в корзине выбирать из остатков товара
		fNotSelPrice            = 0x0002,  // Запрет выбора цены
		fFillUpToMinStock       = 0x0004,  // Попольнить до минимального остатка
		fEnableFillUpToMinStock = 0x0008   // Если этот флаг не установлен, то опция fFillUpToMinStock будет недоступна
	};
	SLAPI  SelBasketParam();
	int    SLAPI StoreInReg(const char * pName) const;
	int    SLAPI RestoreFromReg(const char * pName);

	long   SelPrice;     // IN/OUT Выбор вида цены, которая должна загружаться в корзину
		// { 1 - цена поступления, 2 - номинальная цена реализации,
		// 3 - чистая цена реализации (Price-Discount)}
	long   SelReplace;   // IN/OUT Способ обработки непустой корзины
		// {1 - очистить корзину, 2 - заменить существующие товары,
		// 3 - сложить количества для существующих товаров}
	int16  Flags;        //
	int16  Reserve;      // @alignment
};
//
// Descr: вызывает диалог выбора корзины, которую необходимо заполнить из внешнего источника
//   (строки товарного документа, товарный отчет по операции и т.д.).
// ARG(pParam    IN/OUT): Структура параметров (см. комментарии к SelBasketParam
// ARG(pCallerSymb   IN):
// ARG(useGbPriceDlg IN): Использовать диалог, предлагающий выбрать одну номинальную цену и
//   три дополнительные цены (используется при выгрузке прайс-листа в корзину)
// Returns:
//   >0 - Пользователь выбрал корзину, подтвердил выбор и функция завершилась успешно.
//   <0 - Пользователь отказался от выбора корзины
//    0 - Ошибка
//
int SLAPI GetBasketByDialog(SelBasketParam * pParam, const char * pCallerSymb, uint dlgID = 0);
//
//
//
int     PPCalculator(uint32 parentWnd, const char * pInitData);
TView * SLAPI ValidView(TView *);
int     SLAPI InsertView(TBaseBrowserWindow * v);
ushort  FASTCALL ExecView(TWindow *); // @v9.0.4 TView-->TWindow
ushort  FASTCALL ExecViewAndDestroy(TWindow * pView); // @v9.0.4 TView-->TWindow
ushort  FASTCALL CheckExecAndDestroyDialog(TDialog * pDlg, int genErrMsg, int toCascade);
ushort  FASTCALL ExecView(TBaseBrowserWindow * v);
int     FASTCALL GetModelessStatus(int outerModeless = 1);
void    FASTCALL DisableOKButton(TDialog *);
int     FASTCALL PPWait(int begin);
int     FASTCALL PPWaitMsg(const char *);
int     FASTCALL PPWaitMsg(int msgGrpID, int msgID, const char * = 0);
int 	FASTCALL PPWaitLong(long);
int 	FASTCALL PPWaitPercent(ulong p, const char * pMsg = 0);
int     FASTCALL PPWaitPercent(ulong p, ulong t, const char * pMsg = 0);
int     FASTCALL PPWaitPercent(const IterCounter & cntr, const char * pMsg = 0);
int     FASTCALL PPWaitDate(LDATE);
//
// Descr: проверяет очередь клавиатуры на Escape.
//   Если Esc нажата, то выдается запрос на подтверждение. В случае
//   положительного ответа пользователя возвращается (0). В случае
//   отрицательного - (-1). Если Esc не была нажата - (1).
//
int     SLAPI PPCheckUserBreak();
int     SLAPI SetupComboByBuddyList(TDialog * pDlg, uint ctlCombo, ObjIdListFilt & rList);
int     SLAPI BarcodeInputDialog(int initChar, SString & rBuf);
int     SLAPI SetupDBEntryComboBox(TDialog * dlg, uint ctl, PPDbEntrySet2 * pDbes);
int     SLAPI SetupDBTableComboBox(TDialog * dlg, uint ctl, PPDbEntrySet2 * pDbes, long dbID, BTBLID tblID);
int     SLAPI EditAccTurnTemplate(PPObjAccTurn*, PPAccTurnTempl *);

//
// @obsolete {
// Параметр options принимает значение:
//   0 - при добавлении.
//   1 - при редактировании
//   2 - редактирование с форсированным признаком modified.
//       В случае редактирования некоторые поля блокируются.
//   3 - не выводить сообщение о том что документ был модифицирован
// }
//
int     SLAPI EditGoodsBill(PPBillPacket * pPack, long egbFlags);
int     SLAPI GetScaleData(PPID scaleID, TIDlgInitData * pData = 0);
int     SLAPI GetDefScaleData(TIDlgInitData * pData = 0);
int     SLAPI EditTransferItem(PPBillPacket *, int itemNo, TIDlgInitData *, const PPTransferItem * pOrder = 0, int sign = 0);
//
// Descr: Вызывает диалог редактирования списка штатных сумм
// ARG(pData IN/OUT): @#{vptr} Список сумм, который необходимо редактировать
// ARG(pTitle    IN): @#{vptr0} Опциональный заголовок диалога
// ARG(enableMod IN): Если этот параметр равен 0, то функция не допускает каких-либо изменений списка сумм
// Returns:
//   >0 - список был редактирован и пользователь нажал ОК
//   <0 - пользователь отменил (возможно) сделанные изменения //
//   0  - ошибка
//
int     SLAPI EditStaffAmtList(StaffAmtList * pData, const char * pTitle, int enableMod);
int     SLAPI EditStaffAmtEntry(long idx, StaffAmtList * pAmtList);
//
// Параметры функции SelectOprKind - список типов операций (PPID),
// заканчивающийся нулем. Если linkOprKind != 0, то выбираются только
// те виды операция, для которых вид связанной операции равен linkOprKind
//
PPID    SLAPIV SelectOprKind(uint opklFlags /* OPKLF_XXX */, PPID linkOprKind, ...);
PPID    SLAPI SelectOpKind(PPID linkOpID, PPIDArray * pOpTypesList, uint opklFlags /* OPKLF_XXX */);
int     SLAPI SetupOprKindCombo(TDialog *, uint ctlID, PPID id, uint flags, const PPIDArray *, uint opklFlags);
int     SLAPI BillPrelude(const PPIDArray * pOpList, uint opklFlags, PPID linkOpID, PPID * pOpID, PPID * pLocID);
int     SLAPI SetupLocationCombo(TDialog *, uint, PPID, uint flags, PPID locType, PPID owner);
int     SLAPI SetupLocationCombo(TDialog * dlg, uint ctl, PPID id, uint flags, const LocationFilt * pFilt);
int     SLAPI SetupObjTagCombo(TDialog *, uint, PPID, uint flags, ObjTagFilt * pFilt);
int     SLAPI SetupStaffListCombo(TDialog *, uint, PPID, uint flags, PPID orgID, PPID divID);
int     SLAPI SetupSubstGoodsCombo(TDialog * dlg, uint ctlID, long initID);
int     SLAPI SetupSubstBillCombo(TDialog * pDlg, uint ctlID, SubstGrpBill sgb);
int     SLAPI SetupPersonCombo(TDialog *, uint ctlID, PPID id, uint flags, PPID personKindID, int disableIfZeroPersonKind);
// @v9.7.0 int     SLAPI SetupGoodsGroupCombo(TDialog * dlg, uint ctlID, PPID id, uint flags, void * extraPtr);
int     SLAPI MessagePersonBirthDay(TDialog * pDlg, PPID psnID);
int     SLAPI SetupSubstPersonCombo(TDialog * pDlg, uint ctlID, SubstGrpPerson sgp);
int     SLAPI SetupSubstDateCombo(TDialog * dlg, uint ctlID, long initID);
int     SLAPI SetupSubstSCardCombo(TDialog * pDlg, uint ctlID, SubstGrpSCard sgc);
int     SLAPI EditCfgOptionsDialog(PPConfig *, long, EmbedDialog * = 0);
int     SLAPI EditSecurDialog(PPID obj, PPID * id, void * extraPtr);
int     SLAPI ViewLots(const LotFilt *, int asOrders, int modeless);
int     SLAPI ViewLots(PPID goods, PPID loc, PPID suppl, PPID qcert, int modeless);
int     SLAPI BillExtraDialog(PPBillExt *, ObjTagList * pTagList, int isFilt);
int     SLAPI BillFilterDialog(uint rezID, BillFilt *, const char * addText = 0);
int     SLAPI BillFilterDialog(uint rezID, BillFilt *, TDialog ** d, const char * addText = 0);
int     SLAPI ViewStatus();
int     SLAPI ViewPredictSales(PredictSalesFilt *);
// @v9.5.9 int     SLAPI ViewPrognosis();
void    FASTCALL SetPeriodInput(TDialog *, uint fldID, const DateRange *);
int     FASTCALL GetPeriodInput(TDialog *, uint fldID, DateRange *);
int     SLAPI GetPeriodInput(TDialog * dlg, uint fldID, DateRange * pPeriod, long strtoperiodFlags);
int     SLAPI SetTimeRangeInput(TDialog *, uint ctl, long fmt, const TimeRange * pTimePeriod);
int     SLAPI SetTimeRangeInput(TDialog *, uint ctl, long fmt, const LTIME * pLow, const LTIME * pUpp);
int     SLAPI GetTimeRangeInput(TDialog *, uint ctl, long fmt, TimeRange * pTimePeriod);
int     SLAPI GetTimeRangeInput(TDialog *, uint ctl, long fmt, LTIME * pLow, LTIME * pUpp);
SString & SLAPI PPFormatPeriod(const DateRange * pPeriod, SString & rBuf);
SString & SLAPI PPFormatPeriod(const LDATETIME & rBeg, LDATETIME & rEnd, SString & rBuf);
int     SLAPI SetRealRangeInput(TDialog *, uint ctl, double lo, double up, int prc = 0);
int     SLAPI SetRealRangeInput(TDialog *, uint ctl, const RealRange *, int prc = 0);
int     SLAPI GetRealRangeInput(TDialog *, uint ctl, double * pLow, double * pUpp);
int     SLAPI GetRealRangeInput(TDialog *, uint ctl, RealRange *);
int     SLAPI SetIntRangeInput(TDialog *, uint ctl, const IntRange *);
int     SLAPI GetIntRangeInput(TDialog *, uint ctl, IntRange *);
int     SLAPI PPSetupCtrlMenu(TDialog * pDlg, uint ctl, uint ctlButton, uint ctrlMenuID);

int     SLAPI ViewGoodsTurnover(long);
int     SLAPI PrintDialog(SPrinter *);
int     SLAPI FastEditRightsDialog();
int     SLAPI ActiveUsersListDialog();
int     SLAPI FastEditSumByDivDialog();
int     SLAPI FastViewDivBySumDialog();
//
enum {
	selSymbAmount    = 0x0001, // Выбирать типы сумм
	selSymbFormula   = 0x0002, // Выбирать формулы
	selSymbStaffCal  = 0x0004, // Выбирать штатные календари
	selSymbSalPeriod = 0x0008  // Выбирать периоды начисления зарплаты //
};
//
int     SLAPI SelectAmountSymb(PPID * pID, long options, int * pKind, SString & rSymbBuf);
//
int     SLAPI PrintCashOrderByGoodsBill(PPBillPacket * pPack, int prnflags = 0);
int     SLAPI PrintGoodsBill(PPBillPacket * pPack, SArray ** ppAry = 0, int printingNoAsk = 0);
//
// Descr: печатает расходный или приходный кассовый ордер.
//   Если pay_rcv != 0, то печатается расходный ордер (pay), в противном
//   случае - приходный.
//
int     SLAPI PrintCashOrder(PPBillPacket *, int pay_rcv, int prnflags = 0);
int     SLAPI ViewGoodsBills(BillFilt *, int modeless);
int     SLAPI BrowseBills(BrowseBillsType);
int     SLAPI ViewBillsByPool(PPID poolType, PPID poolOwnerID);
int     SLAPI ViewOpersByLot(PPID id, int withZeroLotID);
int     SLAPI ViewCashBills(PPID cashNode);
int     SLAPI ViewGoodsMov(int modeless);
//
// Descr: Вызывает диалог расчета формул по товару goodsID.
//   Расчет формул по товару возможен тогда, когда товар принадлежит
//   классу, для которого определена по крайней мере одна формула.
//   Диалог содержит комбо-бокс выбора формулы, три поля для ввода аргументов
//   и одно поле рещультата.
//   Вызывающая функция может задать один из аргументов, передав его номер [1..3]
//   через параметр argIdx и значение через параметр arg.
//   По указателю pVal будет присвоен результат последнего расчета.
// Returns:
//   >0 - последняя попытка расчета была реализована.
//   <0 - не было реализована последняя попытка расчета либо товар goodsID не принадлежит
//        классу, для которого определены формулы.
//   0  - ошибка
//
int     SLAPI PPGoodsCalculator(PPID goodsID, PPID tsesID, int argIdx, double arg, double * pVal);
//
//
//
struct CalcPriceParam {
	SLAPI  CalcPriceParam();
	int    SLAPI Save() const; // VarPercent, RoundPrec, RoundDir, fRoundVat, fVatAboveAddition
	int    SLAPI Restore();
	//
	// Descr: Осуществляет расчет цены на основе входящей цены inPrice.
	//   Не инициализирует переменную Price, но вместо этого возвращает рассчитанное
	//   значение (для сохранения спецификации const).
	//
	double SLAPI Calc(double inPrice, double * pVatRate, double * pVatSum, double * pExcise) const;

	enum {
		fCostWoVat        = 0x0001, // IN     Цена поступления на входе задана без НДС
		fExclTaxes        = 0x0002, // IN/OUT Исключить налоги из цены
		fRoundVat         = 0x0004, // IN/OUT Округлять до значения, кратного ставке НДС
		fVatAboveAddition = 0x0008  // IN/OUT НДС начислять на наценку
	};
	PPID   GoodsID;    // IN
	PPID   QuotKindID; // IN/OUT
	PPID   InTaxGrpID; // IN Налоговая группа на приход (если 0, то принимается равной налоговой группе на товар)
	LDATE  Dt;         // IN
	double Cost;       // IN
	double Price;      // OUT
	double VaPercent;  // IN/OUT
	double RoundPrec;  // IN/OUT
	int16  RoundDir;   // IN/OUT (-1) - round down, (+1) - round up, (0) - to nearest
	int16  Reserve;    // @alignment
	long   Flags;      // IN/OUT CalcPriceParam::fXXX
};
//
// Descr: Возвращает минимальный множитель, цены кратные которому
//   дают расчет суммы НДС без остатка.
//   Множитель возвращается долях денежной единицы, определяемых параметром prec
// ARG(rate IN): ставка НДС (в долях от единицы, например - 0.20 (20%))
// ARG(prec IN): @{0..6} точность представления результата. 0 - до целых значений,
//   3 - с точностью 0.001 и т.д.
//
ulong   SLAPI GetMinVatDivisor(double rate, uint prec);
int     SLAPI CalcPrice(CalcPriceParam *);
int 	SLAPI CalcDiff(double amount, double * pDiff);
int     SLAPI CalcTaxPrice(PPID goodsID, PPID opID, LDATE, double price, int = 0);
int     SLAPI CloseCashDay();
int     SLAPI SelectorDialog(uint dlgID, uint ctlID, uint * pVal /* IN,OUT */, const char * pTitle = 0);
//
// Descr: функция для выбора элемента из списка
//
class ListBoxSelDlg : public PPListDialog {
public:
	ListBoxSelDlg(ListBoxDef * pDef, uint dlgID = 0);
	int    setDTS(PPID id);
	int    getDTS(PPID * pID);
protected:
	virtual int setupList();
	virtual int editItem(long pos, long id);
	ListBoxDef * P_Def;
};

int     SLAPI ListBoxSelDialog(PPID objID, PPID * pID, void * extraPtr);
int     SLAPI ListBoxSelDialog(StrAssocArray * pAry, uint titleStrId, PPID * pID, uint flags);
int     SLAPI ListBoxSelDialog(StrAssocArray * pAry, const char * pTitle, PPID * pID, uint flags);
int     SLAPI ListBoxSelDialog(uint dlgID, StrAssocArray * pAry, PPID * pID, uint flags);
// @v9.2.1 int     SLAPI ComboBoxSelDialog(PPID objID, PPID * pID, uint flags, long extra);
int     SLAPI ComboBoxSelDialog2(StrAssocArray * pAry, uint subTitleStrId, uint labelStrId, long * pSelectedId, uint flags);
int     SLAPI AdvComboBoxSeldialog(StrAssocArray * pAry, SString & rTitle, SString & rLabel, PPID * pID, SString * pName, uint flags);
//
#define INIREPF_FORCELANDSCAPE 0x0001L
#define INIREPF_NOSHOWDIALOG   0x0002L
//
int     SLAPI CorrectAccTurnRest();
int     SLAPI CorrectCurRest();
int 	SLAPI RecalcBillTurns(int checkAmounts);
int     SLAPI RemoveEmptyAcctRels();
int     SLAPI EditSysjFilt2(SysJournalFilt * pFilt);

#define OBJTRNSMDLGF_SEARCHDTTM 0x00000001
int     SLAPI ObjTransmDialog(uint dlgID, ObjTransmitParam *, long dlgFlags = 0);
int     SLAPI ObjTransmDialogExt(uint dlgID, int viewId, ObjTransmitParam * pParam, PPBaseFilt * pFilt, long dlgFlags = 0); // @v6.4.3 AHTOXA
//
// Descr: Проверяет корректность создания и загрузки диалога.
//   С этой функцией вышел легкий прокол. Фактически ей должен
//   передаваться параметр типа (TDialog **), однако уродский C++ не
//   позволяет использовать неявное преобразование к этому типу от
//   указателя на класс, порожденного от TDialog. Необходимо быть
//   внимательным с этой функцией, примерный вызов следующий:
// Sample:
//   DerivedDialog * dlg = new DerivedDialog; // DerivedDialog порожден от класса TDialog.
//   THROW(CheckDialogPtr(&dlg));
// ARG(ppDlg IN/OUT): указатель на указатель созданного диалога. (TDialog **)
//   Если функция идентифицировала ошибку в диалоге, то диалог *ppDlg будет
//   ею же и разрушен. В результате *ppDlg получит 0.
// ARG(genErrMsg IN): если этот параметр !0, то функция выведет на экран сообщение
//   об ошибке.
// Returns:
//   !0 - диалог *ppDlg корректен
//   0  - диалог *ppDlg не корректен
//
int     FASTCALL CheckDialogPtr(void * ppDlg/*, int genErrMsg = 0*/);
int     FASTCALL CheckDialogPtrErr(void * ppDlg);
//
// Descr: Вызывает функцию сообщения об ошибке PPError(err, 0) и делает активным
//   элемент диалога ctlID.
// Returns:
//   0 - всегда. Для того, чтобы можно было быстро инициализировать переменную ok
//     или значение, возвращаемое вызывающей функцией.
//
int     FASTCALL PPErrorByDialog(TDialog * dlg, uint ctlID, int err);
//
// Descr: То же, что и PPErrorByDialog(TDialog * dlg, uint ctlID, int err), но
//   аргумент err = -1. Отдельная функция сделана ради уменьшения размера кода (чаще вызывается именно так).
//
int     FASTCALL PPErrorByDialog(TDialog * dlg, uint ctlID);
uint    SLAPI GetComboBoxLinkID(TDialog *, uint comboBoxCtlID);
int     SLAPI SetComboBoxLinkText(TDialog *, uint comboBoxCtlID, const char * pText);

static const char * MemosDelim = "=^%"; // разделитель примечаний объектов
//
// Descr: Блок параметров функции InputStringDialog()
//
struct PPInputStringDialogParam {
	SLAPI  PPInputStringDialogParam(const char * pTitle = 0, const char * pInputTitle = 0);
	SLAPI ~PPInputStringDialogParam();

	enum {
		fDisableSelection = 0x0001, // Не реализуется полное выделение строки ввода
		fInputMemo        = 0x0002  // Подставляется диалог DLG_MEMO
	};
	long   Flags;

	SString Title;      // Текст заголовка диалога
	SString InputTitle; // Текст заголовка строки ввода
	WordSel_ExtraBlock * P_Wse; // @owned
};
//
// Descr: Вызывает простой диалог, содержащий строку ввода, ограниченную 64 байтами.
// ARG(pParam           IN): @#{vptr0} Блок параметров диалога
// ARG(rBuf         IN/OUT): Строка, передаваемая в поле ввода. Если пользователь ввел какую-либо
//   строку и подтвердил ввод, нажав ОК, то в этом буфере вернется то, что он ввел.
// Returns:
//   >0 - пользователь подтвердил ввод строки
//   <0 - пользователь отказался от ввода
//   0  - ошибка
//
int     SLAPI InputStringDialog(PPInputStringDialogParam * pParam, SString & rBuf);
int     SLAPI InputDateDialog(const char * pTitle, const char * pInputTitle, LDATE * pDate);
int     SLAPI DateRangeDialog(const char * pTitle, const char * pInputTitle, DateRange *);
int     SLAPI InputQttyDialog(const char * pTitle, const char * pInputTitle, double *);
int     SLAPI InputNumberDialog(const char * pTitle, const char * pInpTitle, double & rValue);
int     SLAPI BigTextDialog(uint maxLen, const char * pTitle, SString & rText);
//
// Descr: Устанавливает в строке комбо-бокса текст 'Список'
//
int     SLAPI SetComboBoxListText(TDialog *, uint comboBoxCtlID);
int     SLAPI SetupStringCombo(TDialog *, uint ctlID, int strID, long initID);
int     SLAPI SetupStringCombo(TDialog *, uint ctlID, const char * pStrSignature, long initID);
int     SLAPI SetupStringComboWithAddendum(TDialog * dlg, uint ctlID, const char * pStrSignature, const StrAssocArray * pAddendumList, long initID);
// id = <string offset> + 1
// @v9.5.0 int     SLAPI SetupStringCombo(TDialog *, uint ctlID, StringSet *, long initID, uint /*flags*/);
int     SLAPI SetupStringComboDevice(TDialog *, uint ctlID, uint dvcClass, long initID, uint /*flags*/); //@vmiller
int     SLAPI GetDeviceTypeName(uint dvcClass, PPID deviceTypeID, SString & rBuf);
int		SLAPI GetStrFromDrvIni(int iniSectID, long devTypeId, int numOfOldDev, SString & str); // @vmiller
// @v9.3.4 (используется только в одном месте - теперь static) int     SLAPI SetupTaggedStringCombo(TDialog * dlg, uint ctlID, const SArray * pStrings, long initID, uint /*flags*/, size_t offs = 0, int ownerDrawListBox = 0);
int     SLAPI SetupStrAssocCombo(TDialog * dlg, uint ctlID, const StrAssocArray * pList, long initID, uint flags, size_t offs = 0, int ownerDrawListBox = 0);
int     SLAPI SetupSCollectionComboBox(TDialog * dlg, uint ctl, SCollection * pSC, long initID);
int     SLAPI ViewSysJournal(const SysJournalFilt *, int modeless);
int     SLAPI ViewSysJournal(PPID objType, PPID objID, int modeless);
int     SLAPI ChangeBillFlagsDialog(long * pSetFlags, long * pResetFlags, PPID * pStatusID);
int     SLAPI EditRightsDialog(PPRights &);
int     SLAPI GenericObjRightsDialog(PPID obj, ObjRights *, EmbedDialog * = 0);
//
// Descr: выдает на экран диалог с запросом ввода пароля и подтверждения.
//   Если параметр dlgID == 0, то используется стандартный диалог (DLG_PASSWORD).
//   В противном случае будет использоваться указанный диалог. В нем должны
//   присутствовать поля ввода CTL_PASSWORD_FIRST и CTL_PASSWORD_SECOND.
//
int     SLAPI PasswordDialog(uint dlgID, char * pBuf, size_t bufSize, size_t minLen, int withoutEncrypt = 0);
int     SLAPI UpdatePassword();
int     SLAPI UnifyGoodsPrice();
//int     SLAPI SelectLot__(PPID loc, PPID goods, PPID exclude, PPID * pLotID, ReceiptTbl::Rec *);

int     SLAPI EditMainConfig();
int     SLAPI EditCommConfig();                                                       // COMMCFG.CPP
int     SLAPI EditCurrConfig();                                                       // COMMCFG.CPP
int     SLAPI EditQCertDialog(QualityCertTbl::Rec * aRec, int viewOnly);
int     SLAPI ViewQCertDialog(PPID);
int     SLAPI ExecCSPanel(const CashNodePaneFilt *);
int     SLAPI SelectCSession(PPID cashNodeID, PPID extCashNodeID, CSessInfo * pInfo);
int     SLAPI AsyncCashnPrepDialog(AsyncCashNPrepParam * pParam);
int     SLAPI ListToListDialog(ListToListData *);
int     SLAPI ListToListAryDialog(ListToListAryData *);
int     SLAPI UISettingsDialog();
int     SLAPI GoodsFilterDialog(GoodsFilt *);
int     SLAPI GoodsFilterAdvDialog(GoodsFilt *, int disableLocSel);
int     SLAPI CreateBizScGlblUserAcct();
//
// Descr: Флаги опций просмотра ассоциаций товар-объект
//
enum {
	goafModal          = 0x0001, // Модальное окно
	goafFreeExtraAsPtr = 0x0002  // extraParam является указателем, который следует разрушить
		// при разрушении броузера.
};
//
// Descr: Вызывает броузер для просмотра ассоциаций товар-объект.
// ARG(objType    IN): Тип объектов, с которыми ассоциированы товары
// ARG(objID      IN): ИД объекта, которым необходимо ограничить просмотр ассоциаций
// ARG(asscType   IN): Тип ассоциации
// ARG(extraParam IN): Дополнительный параметр для выбора объекта
// ARG(options    IN): Опции (goafXXX)
//
int     SLAPI ViewGoodsToObjAssoc(PPID objType, PPID objID, PPID asscType, long extraParam, long options = 0);
	// @uses(PPViewGoodsToObjAssoc)
int     SLAPI ViewGoodsToLocAssoc(PPID locID, PPID asscType, const LocationFilt * pLocFilt, long options = 0);
int     SLAPI ViewGoodsToObjAssoc(long extraParam);
int     FASTCALL SetupStrListBox(TView *);
int     FASTCALL SetupStrListBox(TDialog *, uint ctl);
int     SLAPI SetupTreeListBox(TDialog * dlg, uint ctl, StrAssocArray * pData, uint fl, uint lbfl);
int     SLAPI EditDefaultPrinterCfg();
int     SLAPI AmountListDialog(AmtList *, PPIDArray * pRestrictList, LDATE cRateDate, const char * pTitle, uint options);
//
// Descr: Флаги функции CCheckPane()
//
enum {
	cchkpanfOnce = 0x0001 // Закрыть панель после проведения первого чека
};

int     SLAPI CCheckPane(PPID cashNodeID, PPID checkID, const char * pInitLine = 0, long flags = 0);
int     SLAPI ViewCashNodes();
int     SLAPI EditELinks(PPELinkArray *);
int     SLAPI ViewPerson(const PersonFilt *);
int     SLAPI EditMainOrg();
int     SLAPI ViewShipmAnalyze(ShipmAnalyzeFilt *);
int     SLAPI ViewGoodsRest(const GoodsRestFilt *, int);
int     SLAPI GoodsRestTest();
int     SLAPI ViewAccAnlz(const AccAnlzFilt *, AccAnlzKind);
int     SLAPI EditPriceListConfig();
int     SLAPI ViewGoodsTaxAnalyze(const GoodsTaxAnalyzeFilt *);
int     SLAPI ViewGoodsOpAnalyze(const GoodsOpAnalyzeFilt *);
int     SLAPI ViewArticle(const ArticleFilt *);
int     SLAPI ViewOpGrouping(const OpGroupingFilt *);
int     SLAPI ViewCCheck(const CCheckFilt *, int execFlags);
int     SLAPI ViewTrfrAnlz(const TrfrAnlzFilt *);
int     SLAPI ViewSCard(const SCardFilt *, int _modeless);
int     SLAPI ViewAddressBook();
int     SLAPI SelectAddressFromBook(PPID * pSelPersonID, SString & rAddr);
int     SLAPI ViewOprKind(OprKindFilt * pFilt); // AHTOXA
int     SLAPI ViewBillDetails(PPBillPacket * pPack, long options, PPObjBill *);
int     SLAPI ViewMrpTab(const MrpTabFilt *);
int     SLAPI ViewDLSDetail(DLSDetailFilt * pFilt);
// @todo Member of PPObjOpCounter
int     SLAPI EditCounter(PPOpCounterPacket * pPack, uint resID, PPID * pOpcID = 0); // AHTOXA
//
//
//
#define ISHIST_LEFTBILL  1
#define ISHIST_RIGHTBILL 2
#define ISHIST_BOTHBILL  3
#define ISHIST_NOTHING   4
int     SLAPI ViewGoodsBillCmp(PPID lhBillID, const PPIDArray & rRhBillList, int _modeless, int whatBillIsHistory = ISHIST_NOTHING);
int     SLAPI ViewPrjTask(const PrjTaskFilt *);
int     SLAPI ViewPrjTask_ByStatus(); // Вызывается по двойному щелчку мыши в окне статуса (показать все непросмотренные задачи)
int     SLAPI ViewPrjTask_ByReminder(); //  Вызывается по двойному щелчку мыши в окне статуса (показать все невыполненные задачи за определенный период)
int     SLAPI ViewQuot(const QuotFilt *);
int     SLAPI ViewTech(const TechFilt *);
int     SLAPI ViewTSession(const TSessionFilt *);
int     SLAPI ViewManufPlan(const TSessionFilt *);
int     SLAPI ViewTSessLine(const TSessLineFilt *);
int     SLAPI AnalyzeObjSyncCmp(int _modeless);
int     SLAPI ViewObjSyncTab(PPObjID oid);
int     SLAPI ViewJobPool();                         // @defined(ppjob.cpp)
int     SLAPI ViewLogs();
int     SLAPI DatabaseCutting();
//
// Descr: Функция возвращает указатель на строку сигнатуры кнопки, управляющей отображением календаря.
//   Сигнатура необходима для идентификации типа кнопки посредством вызова TView::GetWindowProp(hWnd, GWLP_USERDATA)
//   Если указатель на пользовательские данные не нулевой и в начале содержится строка сигнатуры, возвращаемая
//   GetCalCtrlSignature, то кнопка относится к искомому типу.
//
const   char * GetCalCtrlSignature(int type);
void    SLAPI SetupCalCtrl(int, TDialog *, uint, uint);
void    SLAPI ShowCalCtrl(int buttCtlID, TDialog * pDlg, int show);
int     SLAPI Import(PPID objType, long extraParam = 0);
int     SLAPI ImportBanks();
int     SLAPI ImportSpecSeries();
int     SLAPI ImportKLADR();
int     SLAPI ImportInventory();
int     SLAPI ImportSR25(); // @vmiller
int     SLAPI ImportCompGS(); // @vmiller
int     SLAPI ImportPhoneList();
int     SLAPI ImportWorkbook(); // @v8.1.2
int     SLAPI ImportSCard();
//int     SLAPI ImportPosRefs(TSCollection <PPPosProtocol::QueryProcessBlock> * pQpBlkList);
int     SLAPI SetDatabaseChain();
int     SLAPI DBMaintenance(PPDbEntrySet2 *, int autoMode);
int     SLAPI ViewFiltPool(); // @paul pentaho @defined(v_filtp.cpp)

struct DBMaintainParam {
	int    Read(SBuffer & rBuf, long);
	int    Write(SBuffer & rBuf, long) const;
	enum {
		tblDLS          = 0x00000001,
		tblMRP          = 0x00000002,
		tblSJ           = 0x00000004,
		tblXBill        = 0x00000008,
		tblRsrvSj       = 0x00000010,  // Восстанавливать в системном журнале записи из резервной таблицы
		tblXBillRecover = 0x00000020,  // Удалять висящие записи строк, идентификатор которых больше последнего идентификатора документа
		tblTempAltGGrp  = 0x00000040,  // @v8.5.12 Удалять временные альтернативные группы
		tblMoveObsolete = 0x00000080   // @v9.0.3 Переместить устаревшие файлы данных
	};

	int16 DLSDays;
	int16 MRPDays;
	int16 SJDays;
	int16 XBillDays;
	long  Tables;
};

int     SLAPI DBMaintainDialog(DBMaintainParam *);
int     SLAPI DoDBMaintain(DBMaintainParam *);
int     SLAPI ReadDBMaintainCfg(DBMaintainParam *);
int     SLAPI EditDBMaintainCfg();
int     SLAPI EditBackupParam(SString & rDBSymb, PPBackupScen * pScen);
int     SLAPI DeleteTmpFiles();
int     SLAPI FillPredictSales();
int     SLAPI TestPredictSales();
int     SLAPI TestReconnect();
// @v9.3.8 @obsolete int     SLAPI ImportOrders();
// @v9.7.10 @obsolete int     SLAPI ImportCurrencyList();
//
//
//
int     FASTCALL PPOpenBrowser(BrowserWindow *, int modeless);
void    FASTCALL PPCloseBrowser(TBaseBrowserWindow *);
BrowserWindow * SLAPI PPFindLastBrowser();
STimeChunkBrowser * SLAPI PPFindLastTimeChunkBrowser();
PPPaintCloth * SLAPI PPFindLastPaintCloth();
int     SLAPI InitSTimeChunkBrowserParam(const char * Symbol, STimeChunkBrowser::Param * pParam);
//
//
//
enum PUGP {
	pugpFull      = 1,
	pugpZero      = 2,
	pugpNoBalance = 3
};

int SLAPI ProcessUnsuffisientGoods(PPID goodsID, PUGP param);
int SLAPI ProcessUnsuffisientList(uint dlgID, PUGL * pList);
int SLAPI SelectGoods(PPID & rGoodsID);
int SLAPI EditObjMemos(PPID objTypeID, PPID prop, PPID objID);
int SLAPI PutObjMemos(PPID objTypeID, PPID prop, PPID objID, SString & rMemos, int useTa);

struct RemoveAllParam {
	enum {
		aRemoveAll = 1,
		aMoveToGroup
	};
	int    Action;
	PPID   DestGrpID;
};

class RemoveAllDialog : public TDialog {
public:
	RemoveAllDialog(uint resID);
	int    setDTS(const RemoveAllParam *);
	int    getDTS(RemoveAllParam *);
private:
	DECL_HANDLE_EVENT;
	RemoveAllParam Data;
};
//
//
//
class PsnSelAnalogDialog : public TDialog {
public:
	PsnSelAnalogDialog(PPObjPerson * pPsnObj);
	void   setSrchString(const char * pStr);
	int    getResult(PPID * pID);
private:
	DECL_HANDLE_EVENT;
	int    setupList();
	PPObjPerson * P_PsnObj;
	PPID   Selection;
};
//
// Descr: Таблица выбора лота
//
class SelLotBrowser : public BrowserWindow {
public:
	struct Entry {
		PPID   LotID;
		LDATE  Dt;
		long   OprNo;
		PPID   GoodsID;
		LDATE  Expiry;
		PPID   SupplID;
		double Rest;
		double Cost;
		double Price;
		char   Serial[32];
	};
	enum {
		fShowEgaisTags = 0x0001
	};
	static SArray * SLAPI CreateArray();
	static int SLAPI AddItemToArray(SArray * pAry, const ReceiptTbl::Rec * pRec, LDATE billDate, double rest, int onlyWithSerial = 0);
	SelLotBrowser(PPObjBill * pBObj, SArray * pAry, uint pos, long flags);
private:
	DECL_HANDLE_EVENT;
	static int GetDataForBrowser(SBrowserDataProcBlock * pBlk);
	int    SLAPI _GetDataForBrowser(SBrowserDataProcBlock * pBlk);

	enum {
		stMultipleGoods  = 0x0001,
		stMultipleSerial = 0x0002
	};

	long   State;
	long   Flags;
	PPObjBill * P_BObj;
	SString Serial_;
};
//
// Панель чеков
//
//
// Округление скидки
//
enum {
	fDisRoundNo,           // Округления нет
	fDisRoundDef,          // До ближайшего
	fDisRoundUp,           // В большую сторону
	fDisRoundDown          // В меньшую сторону
};
//
// Методы оплаты чека
//
enum CheckPaymMethod {
	cpmUndef     = 0,      // Неопределенный
	cpmCash      = 1,      // Наличными
	cpmBank      = 2,      // Банковская платежная карта
	cpmIncorpCrd = 3       // Корпоративная кредитная карта
};
//
//
//
struct PosPaymentBlock {
	DECL_INVARIANT_C();

	PosPaymentBlock(const CcAmountList * pCcPl, double bonusMaxPart);
	PosPaymentBlock & Clear();
	PosPaymentBlock & Init(CPosProcessor * pCpp);
	double GetTotal() const;
	double GetDiscount() const;
	double GetPctDiscount() const;
	double GetUsableBonus() const;

	int    EditDialog2();

	CheckPaymMethod Kind;  // Основной способ оплаты
	double Amount;         // Сумма к оплате
	double CashAmt;        // Сумма платежа наличными
	double BankAmt;        // Сумма платежа по банку
	double ScAmt;          // Сумма доплаты по кредитной карте
	double NoteAmt;        // Сумма полученная от покупателя наличными
	double DeliveryAmt;    // Сумма сдачи DeliveryAmt = NoteAmt - CashAmt
	double SCardRest;      // Текущий остаток по карте (без учета суммы ScAmt)
	double BonusRest;      // Сумма бонуса, доступная для использования //
	double BonusAmt;       // Сумма бонуса, которую покупатель будет использовать для платежа //
	PPID   SCardID;        // ИД кредитной карты
	PPID   ExclSCardID;    // ИД карты, которую нелья применять для приема платежа
		// Причина - эта карта уже присвоена чеку. То есть, по ней уже основная часть
		// платежа сделана (либо на нее начисляются средства).
	long   DisabledKinds;  // Биты установлены в позициях со смещением, равным
		// запрещенному виду оплаты.
	int    AltCashReg;     // @v9.6.9 Признак использования альтернативного кассового регистратора.
		// -1 - disabled, 0 - не использовать, 1 - использовать
	//
	// @v8.0.0 Следующие поля используются новой реализацией
	//
	double BonusMaxPart;
	double AmtToPaym;      // Сумма к уплате (наличными или через банк). То есть, сумма чека за минусом доступных бонусов и остатка на кредитной карте.
	CcAmountList CcPl;
private:
	double Total;          // Итоговая сумма чека     @*CPosProcessor::GetTotal())
	double Discount;       // Итоговая скидка по чеку @*CPosProcessor::GetTotal())
	double UsableBonus;    // Сумма бонуса, которая может быть использована для оплаты чека
};

struct SaModifEntry {
	enum {
		fChecked = 0x0001 // Позиция выбрана (используется для организации UI где модификаторы отображаются списком)
	};
	PPID   GoodsID;
	long   Flags;
	double Price;
	double Qtty;
};

typedef TSArray <SaModifEntry> SaModif;

class CPosProcessor {
public:
	//
	// Descr: Состояния панели
	//
	enum {
		sUNDEF = 0,              // Неопределенное (такое состояние недопустимо)
		sEMPTYLIST_EMPTYBUF = 1, // Пустой список строк, пустой буфер ввода
		sEMPTYLIST_BUF      = 2, // Пустой список строк, в буфере ввода есть товар
		sLIST_EMPTYBUF      = 3, // Непустой список строк, пустой буфер ввода
		sLIST_BUF           = 4, // Непустой список строк, в буфере ввода есть товар
		sLISTSEL_EMPTYBUF   = 5, // Режим выбора строк из чека продажи, пустой буфер ввода
		sLISTSEL_BUF        = 6, // Режим выбора строк из чека продажи, в буфере ввода есть товар
		sSCARD              = 7, // Режим ввода номера дисконтной карты
		sWAITER             = 8, // Режим ввода кода официанта
		sTABLE              = 9  // Режим ввода кода стола
	};
	//
	// Descr: Операционные права кассира
	//
	enum OperRights {
		orfReturns                 = 0x00000001, // Чек возврата
		orfEscCheck                = 0x00000002, // Удаление чека
		orfEscChkLine              = 0x00000004, // Удаление строки из чека
		orfBanking                 = 0x00000008, // Безналичный расчет
		orfZReport                 = 0x00000010, // Закрытие сессии (Z-отчет)
		orfPreCheck                = 0x00000020, // Печать пре-чека
		orfSuspCheck               = 0x00000040, // Отложить чек
		orfCopyCheck               = 0x00000080, // Печать копии чека
		orfCopyZReport             = 0x00000100, // Печать копии Z-отчета
		orfPrintCheck              = 0x00000200, // Печать чека
		orfRowDiscount             = 0x00000400, // Скидка на строку чека
		orfXReport                 = 0x00000800, // Снятие X-отчета
		orfCTblOrd                 = 0x00001000, // Снятие X-отчета
		orfSplitCheck              = 0x00002000, // Разделение чека
		orfChgPrintedCheck         = 0x00004000, // Изменение чека, по которому отпечатан счет
		orfRestoreSuspWithoutAgent = 0x00008000, // CSESSOPRT_RESTORESUSPWOA
		orfChgAgentInCheck         = 0x00010000, // @v8.2.1  CSESSOPRT_CHGCCAGENT
		orfMergeChecks             = 0x00020000, // @v8.5.5  CSESSOPRT_MERGECHK
		orfEscChkLineBeforeOrder   = 0x00040000  // @v8.7.3  CSESSOPRT_ESCCLINEBORD
	};
	struct ExtCcData {
		enum {
			fDelivery           = 0x0001,
			fFixedPrice         = 0x0002, // @v8.7.7 Проекция флага CCHKF_FIXEDPRICE
			fAttachPhoneToSCard = 0x0004, // @v9.4.11 @transient Привязать номер телефона к выбранной карте
			fSpFinished         = 0x0008, // @v9.7.7 CCHKF_SPFINISHED
		};
		ExtCcData();
		void   Clear();

		long   Flags;
		PPID   SCardID_;   // @v9.4.5 Ид карты, ассоциированной с адресом доставки.
			// Если карта не привязана к иному адресу или персоналии, то при проведении чека
			// она будет связана с созданной или существующей локацией Addr
		LDATETIME DlvrDtm;
		LDATETIME InitDtm; // Время создания чека.
		LocationTbl::Rec Addr_;
		SString Memo;
	};
	CPosProcessor(PPID cashNodeID, PPID checkID, CCheckPacket * pOuterPack, int isTouchScreen);
	~CPosProcessor();
	enum {
		eomMsgWindow = 1,
		eomStatusLine,      // Сообщение выдается в стоке состояния //
		eomPopup,           // Сообщение выдается во всплывающем немодальном окне
		eomBeep = 0x8000
	};
	virtual int MessageError(int errCode, const char * pAddedMsg, long outputMode);
	virtual int ConfirmMessage(int msgId, const char * pAddedMsg, int defaultResponse);
	//
	//
	//
	enum {
		cdispcmdClear = 1,         // Очищает дисплей. Дополнительные параметры не используются.
		cdispcmdText,              // Выводит текстовое сообщение. iVal - идентификатор текста.
		cdispcmdCurrentItem,       // Выводит информацию о текущей введенной чек позиции. Дополнительные параметры не используются.
		cdispcmdCurrentGiftItem,   // Выводит информацию о текущей введенной чек подарочной позиции. Дополнительные параметры не используются.
		cdispcmdTotal,             // Выводит информацию об общей сумме покупки. rv1 - значение суммы
		cdispcmdTotalDiscount,     // Выводит информацию о скидки по чеку. rv1 - процентное значение скидки, rv2 - абсолютное значение скидки.
		cdispcmdChange             // Выводит информацию о полученной сумме и сдаче. rv1 - полученная сумма, rv2 - сдача
	};
	//
	// Идентификаторы текстовых строк, выводимых на дисплее покупателя командой cdispcmdText
	//
	enum {
		cdisptxtOpened = 1,
		cdisptxtClosed
	};
	virtual int CDispCommand(int cmd, int iVal, double rv1, double rv2);
	//
	// Descr: Режимы функции AcceptCheck
	//
	enum {
		accmRegular         = 0, // Обычное проведение кассового чека
		accmSuspended       = 1, // Сохранение отложенного чека
		accmAveragePrinting = 2, // Аварийная печать уже проведенного чека (до этого печать завершилась с ошибкой)
		accmJunk            = 3  // Сохранение временной копии чека (с флагами CCHKF_SUSPENDED|CCHKF_JUNK)
	};

	virtual int    AcceptCheck(const CcAmountList * pPl, PPID altPosNodeID, double cash, int mode);
	virtual void   ClearCheck();
	virtual void   ClearRow();
	virtual int    OnUpdateList(int goBottom);
	//
	// Descr: Структура, обрабатываемая функцией CheckPaneDialog::PreprocessGoodsSelection
	//   и передаваемая в CPosProcessorCPosProcessor::SetupNewRow()
	//
	struct PgsBlock {
		SLAPI  PgsBlock(double qtty);

		double Qtty;
		double PriceBySerial;
		double AbstractPrice; // @v9.5.10
		SString Serial;
		SString EgaisMark;
	};
	//int    SetupNewRow(PPID goodsID, double qtty, double priceBySerial, const char * pSerial, PPID giftID = 0);
	int    SetupNewRow(PPID goodsID, PgsBlock & rBlk, PPID giftID = 0);
	int    AcceptRow(PPID giftID = 0);
	//
	// Descr: Заполняет пакет чека по указателю pPack данными из текущего состояния панели.
	//   Поле CCheckPacket::Rec::CashID получает идентификатор кассового узла, к которому привязан текущий чек.
	//
	int    GetCheckInfo(CCheckPacket * pPack);
	void   CalcTotal(double * pTotal, double * pDiscount) const;
	double GetUsableBonus() const;
	int    GetState() const;
	int    IsState(int s) const;
	PPID   GetPosNodeID() const;
	long   GetTableCode() const;
	int    GetGuestCount() const;
	PPID   GetAuthAgentID() const;
	PPID   FASTCALL GetCnLocID(PPID goodsID) const;
	int    CheckRights(long rights) const;
	int    SLAPI InitIteration();
	int    FASTCALL NextIteration(CCheckItem * pItem);
	int    SetupCTable(int tableNo, int guestCount);
	int    SetupAgent(PPID agentID, int asAuthAgent);
	int    SetupSessUuid(S_GUID & rUuid);
	int    OpenSession(LDATE * pDt, int ifClosed);
	int    RestoreSuspendedCheck(PPID ccID); // private->public
	int    Print(int noAsk, const PPLocPrinter2 * pLocPrn, uint rptId);
	//
	// Descr: selPrnType ==  1 - предварительно вызывается диалог выбора принтера (локальные или по умолчанию)
	//        selPrnType == -1 - печать на локальные принтеры (если они есть) |  используетс
	//        selPrnType ==  0 - печать на принтер по умолчанию               | для TouchScreen
	// Returns:
	//   >0 - печать чека (чеков)
	//   <0 - печать не призводится (не то состояние чека, нет локальных принтеров и т.п.)
	//    0 - ошибка
	//
	int    PrintToLocalPrinters(int selPrnType);
	int    CalculatePaymentList(PosPaymentBlock & rBlk, int interactive);
	//
	// Descr: Возвращает указатель на блок дополнительных котировок, ассоциированных
	//   с персональной картой.
	//   В зависимости от признака GF_NODISCOUNT товара и дополнительных
	//   параметров, может вернуть ноль, даже если с картой котировки ассоциированы.
	// Note: nonconst из-за вызова GObj.Fetch
	//
	const  RetailPriceExtractor::ExtQuotBlock * GetCStEqb(PPID goodsID, int * pNoDiscount);
	const  RetailPriceExtractor::ExtQuotBlock * GetCStEqbND(int nodiscount) const;
	int    GetRgi(PPID goodsID, double qtty, long extRgiFlags, RetailGoodsInfo & rRgi);
	//
	// Descr: Режимы распознавания кода функцией RecognizeCode
	//
	enum {
		crmodeAuto  = 0,
		crmodeGoods = 1,
		crmodeAgent = 2,
		crmodeSCard = 3
	};

	int    RecognizeCode(int mode, const char * pCode, int autoInput);
	int    Backend_RemoveRow(int rowNo);
	int    Backend_SetRowQueue(int rowNo, int queue);
	int    Backend_SetModifList(const SaModif & rList);
	int    ResetCurrentLine();
	//
	// Descr: Очищает процессор. Функция должна быть вызвана перед разрушением
	//   объекта при использовании вне кассовой панели.
	//
	int    Backend_Release();
	int    Backend_GetCCheckList(long ctblId, TSArray <CCheckViewItem> & rList);

	int    ExportCurrentState(SString & rBuf) const;
	int    ExportCTblList(SString & rBuf);
	int    ExportCCheckList(long ctblId, SString & rBuf);
	int    ExportModifList(PPID goodsID, SString & rBuf);
	int    GetTblOrderList(LDATE lastDate, TSArray <CCheckViewItem> & rList);
	int    AutosaveCheck();
	CCheckCore & GetCc()
	{
		return CC;
	}
	PPObjSCard & GetScObj()
	{
		return ScObj;
	}
	//
	// Descr: Реализует CalcSCardOpBonusAmount. Вынесена в отдельный блок для использования
	//   другими модулями.
	//
	static double SLAPI Helper_CalcSCardOpBonusAmount(const CCheckLineTbl::Rec & rItem, PPObjGoods & rGObj, PPID bonusGoodsGrpID, double * pNonCrdAmt);

	LongArray CTblList;
protected:
	//
	// Descr: Узкоспециализированный блок для исполнения функции AcceptCheck().
	//   Необходимость в 'том блоке обусловлена тем, что пришлось разделить функцию AcceptCheck
	//   на, собственно, процесс проведения чека и внедренную внутрь операцию взаимодействия с
	//   оборудованием, которая должна быть имплементирована порожденным классом.
	//
	struct AcceptCheckProcessBlock {
		AcceptCheckProcessBlock();
		enum {
			fIsPack    = 0x0001,
			fIsExtPack = 0x0002,
			fAltReg    = 0x0004
		};

		int    R;
		int    RExt;
		int    SyncPrnErr;
		int    ExtSyncPrnErr;
		long   Flags;
		CCheckTbl::Rec LastChkRec;
		CCheckPacket Pack;
		CCheckPacket ExtPack;
	};
	virtual int    SetupState(int st);
	virtual void   SetupInfo(const char * pErrMsg);
	virtual void   SetupRowData(int calcRest);
	virtual int    Implement_AcceptCheckOnEquipment(const CcAmountList * pPl, AcceptCheckProcessBlock & rB);
	virtual int    NotifyGift(PPID giftID, SaGiftArray::Gift * pGift);
	virtual void   SetPrintedFlag(int set);
	int    InitCashMachine();
	int    InitCcView();
	int    FASTCALL F(long f) const;
	int    SetupExt(const CCheckPacket * pPack);
	int    FASTCALL BelongToExtCashNode(PPID goodsID) const;
	PPID   FASTCALL GetChargeGoodsID(PPID scardID);
	double CalcSCardOpAmount(const CCheckLineTbl::Rec & rItem, PPID chargeGoodsID, PPID crdGoodsGrpID, double * pNonCrdAmt);
	double CalcSCardOpBonusAmount(const CCheckLineTbl::Rec & rItem, PPID bonusGoodsGrpID, double * pNonCrdAmt);
	double CalcCreditCharge(const CCheckPacket * pPack, const CCheckPacket * pExtPack, const CCheckItem * pCurItem, double * pNonCrdAmt, double * pBonusChargeAmt);
	int    CalcRestByCrdCard_(int checkCurItem);
	int    GetNewCheckCode(PPID cashNodeID, long * pCode);
	enum {
		iccpSetCurTime    = 0x0001,
		iccpDontFillLines = 0x0002,
		iccpFinish        = 0x0004  // Финишное формирование (не отложенного) чека перед сохранением в БД
	};
	int    Helper_InitCcPacket(CCheckPacket * pPack, CCheckPacket * pExtPack, const CcAmountList * pCcPl, long options);
	int    StoreCheck(CCheckPacket * pPack, CCheckPacket * pExtPack, int suspended);
	int    PreprocessRowBeforeRemoving(/*IN*/long rowNo, /*OUT*/double * pResultQtty);
	int    AcceptCheckToBeCleared();
	int    Helper_RemoveRow(long rowNo, const CCheckItem & rItem);
	int    Helper_PrintRemovedRow(const CCheckItem & rItem);
	int    Backend_AcceptSCard(PPID scardID, int ignoreRights);
	int    Implement_AcceptSCard(const SCardTbl::Rec & rScRec);
	double RoundDis(double d) const;
	void   Helper_SetupDiscount(double roundingDiscount, int distributeGiftDiscount);
	void   SetupDiscount(int distributeGiftDiscount = 0);
	int    ProcessGift();
	int    AddGiftSaleItem(TSArray <SaSaleItem> & rList, const CCheckItem & rItem) const;
	double CalcCurrentRest(PPID goodsID, int checkInputBuffer);
	int    LoadComplex(PPID goodsID, SaComplex & rComplex);
	int    SetupSCard(PPID scID, const SCardTbl::Rec * pScRec);
	void   ResetSCard();
	int    MakeDbgPrintLogList(int event, const SString & rFmtBuf, const SString & rChkBuf, const SString & rPrnName, SStrCollection & rList);
	int    Helper_SetupSessUuidForCheck(PPID checkID);
	//
	// Descr: Определяет являются ли все товары, находящиеся в пакете pPack или, если pPack == 0, то в P,
	//   специальными товарами начисления на карту scID.
	// Returns:
	//   !0 - пакет пуст либо все товары в нем - начисление на карту scID
	//   0  - в пакете есть по крайней мере один обыкновенный товар (не начисляющий средства на карту scID)
	//
	int    IsOnlyChargeGoodsInPacket(PPID scID, const CCheckPacket * pPack);
	int    LoadModifiers(PPID goodsID, SaModif & rModif);

	struct Packet : public CCheckItemArray {
	public:
		friend int CPosProcessor::SetupAgent(PPID agentID, int asAuthAgent);

		Packet();
		Packet & FASTCALL operator = (CCheckItemArray & rS);
		void   Clear();
		void   ClearCur();
		int    ClearGift();
		int    HasCur() const;
		PPID   GetAgentID(int actual = 0) const;
		double GetGoodsQtty(PPID goodsID) const;
		int    SetupCCheckPacket(CCheckPacket * pPack) const;
		int    SetupInfo(SString & rBuf);
		CCheckItem & GetCur();
		const CCheckItem & GetCurC() const;
		double GetRest() const;
		void   SetRest(double rest);
		int    MoveUp(uint itemIdx);
		int    MoveDown(uint itemIdx);
		int    Grouping(uint itemIdx);
		int    SetQueue(uint itemIdx, int8 queue);
		int    SLAPI InitIteration();
		int    FASTCALL NextIteration(CCheckItem * pItem);

		int    CurPos; // Текущая позиция чека
	private:
		CCheckItem Cur;
		double Rest;   // Остаток товара, выбранного в буфере
		uint   IterIdx;
		PPID   AgentID__;        // ->Article.ID ИД продавца (официанта) Доступ к этому полю - только на чтение.
			// Если надо изменить - SetupAgent()
		PPID   OrgAgentID;       // @v8.2.0 Агент, к которому изначально привязан чек
			// В процессе обработки текущий агент в кассовой панели может иеняться. Данное поле нужно чтобы
			// при 'том не менялся оригинальный агент.
	public:
		long   TableCode;        // Номер столика
		uint16 GuestCount;       // Количество гостей за столом
		uint16 Reserve;          // @alignment
		PPID   OrderCheckID;     // Чек заказа, к которому привязан данный чек
		PPID   OrgUserID;        // Пользователь, создавший оригинальный чек (до первого отложения/восстановления)
		LAssocArray GiftAssoc;   // Список ассоциаций {gift_pos; used_by_gift_pos}
			// Этот список нужен для распределения фиксированной подарочной скидки между
			// строками, по которым этот подарок был предоставлен.
		ExtCcData Eccd;          //
		SaModif CurModifList;    // Список выбранных модификаторов для текущей позиции
		CcAmountList AmL;        // @v8.0.0 Список оплат по чеку
	};
	struct RetBlock {
		RetBlock();
		RetBlock & Clear();

		PPID   SellCheckID;
		double SellCheckAmount;
		double SellCheckCredit;
		CcAmountList AmL;        // @v8.0.0 Список оплат чека, по которому осуществляется возврат
	};
	struct CardState {
		enum {
			fUseDscntIfNQuot  = 0x0001, // Проекция флага SCRDSF_USEDSCNTIFNQUOT из серии карт
			fNoGift           = 0x0002, // Проекция флага SCRDF_NOGIFT из записи карты
			fAmtDiscountGrade = 0x0004, // Для карты применяется скидка с градацией по сумме чека (наследуемой из серии карт)
			fUhtt             = 0x0008, // Выбранная карта синхронизирована с системой Universe-HTT
			fUseMinQuotVal    = 0x0010, // Проекция флага SCRDSF_MINQUOTVAL из серии карт
		};
		CardState();
		~CardState();
		void   Reset();
		PPID   GetID() const;
		const  char * GetCode() const;
		void   SetID(PPID id, const char * pCode);
		double GetDiscount(double ccAmount) const;

		// @v9.0.4 PPID   AddCrdCardID_;    // @#{!AddCrdCardID || SCardID}
			// ИД дополнительной кредитной карты, с которой оплачивается нехватка средств на основной карте.
		long   Flags;
		double Discount;         // Скидка
		double SettledDiscount;  // Установленная скидка (в процентах), в результате вызова CheckPaneDialog::SetupDiscount
		double UhttRest;         // Остаток по карте, извлеченный с сервера uhtt.ru. Актуально только для кредитных и
			// бонусных карт, синхронизированных с Universe-HTT.
		double RestByCrdCard;
		double UsableBonus;      //
		double MaxCreditByCrdCard;
		double AdditionalPayment;  // Доплата наличными
		// @v9.0.4 double AddCrdCardPayment_; // Доплата нехватки средств на SCardID, погашаемая за счет AddCrdCardID
		char   UhttCode[32];      // Код карты в UHTT. Так как, сервер Universe-HTT может идентифицировать
			// карту, добавляя к ней специальный префикс аккаунта, то необходимо сохранить полный номер
			// карты в UHTT для того, чтобы осуществлять с ней операции.
		char   UhttHash[32];      // Код доступа к информации о карте, синхронизированной с Universe-HTT.
		PPSCardSerRule * P_DisByAmtRule; //
		RetailPriceExtractor::ExtQuotBlock * P_Eqb; //
	private:
		PPID   SCardID;          // ИД дисконтной карты
		char   Code[32];         // Номер карты
	};
	enum {
		fNoEdit             = 0x00000001, // Запрет на редактирование чеков
		fError              = 0x00000002, // В строке статуса выводится сообщение об ошибке.
			// Текст сообщения хранится в буфере ErrMsgBuf
		fRetCheck           = 0x00000004, // Признак ввода чека возврата
		fPctDis             = 0x00000008, // Скидка указана в процентах
		fBankingPayment     = 0x00000010, // Чек оплачивается банковской кредитной картой
		fWaitOnSCard        = 0x00000020, // Ожидание ввода дисконтной карты
		fTouchScreen        = 0x00000040, // Используется TouchScreen
		fSelByPrice         = 0x00000080, // Выбор по цене
		fAsSelector         = 0x00000100, // Диалог работает на выбор строки
		fLocPrinters        = 0x00000200, // Используются локальные принтеры
		fRetByCredit        = 0x00000400, // Возврат осуществляется по чеку, часть которого была оплачена корпоративным кредитом (бонусом).
		fCashNodeIsLocked   = 0x00000800, // Кассовый узел заблокирован
		fSleepMode          = 0x00001000, // Панель находится в спящем режиме
		fSuspSleepTimeout   = 0x00002000, // Приостанавливает отсчет таймаута спящего режима
		fPrintSlipDoc       = 0x00004000, // Печать подкладного документа (вместо печати на принтер)
		fBarrier            = 0x00008000, // Флаг блокирует обработку команд. Необходим для избежания //
			// возможность "реентранса" (особенно, при работе с сенсорным экраном).
		fOnlyReports        = 0x00010000, //
		fPresent            = 0x00020000, // Ввод товара-подарка
		fSCardBonus         = 0x00040000, // Карта, ассоциированная с чеком, является бонусной
		fSelSerial          = 0x00080000, // Выбирать серийный номер после выбора товара
			// Проекция флага CASHFX_SELSERIALBYGOODS кассового узла
		fDisableBeep        = 0x00100000, // Запрет на звуковой сигнал при сообщении об ошибке
		fNotUseScale        = 0x00200000, // Не использовать прием с весов
		fForceDivision      = 0x00400000, // Не разрешать проводить строку без номера отдела
		fSCardCredit        = 0x01000000, // Чек оплачивается корпоративной кредитной картой
		fUsedRighsByAgent   = 0x04000000, // Применены права доступа по агенту.
		fPrinted            = 0x08000000, // По чеку распечатан счет (called CheckPaneDialog::Print(x, 0))
		fSelModifier        = 0x20000000, // Режим выбора модификатора
		fSCardBonusReal     = 0x40000000  // @v8.0.6 Карта, ассоциированная с чеком, является бонусной. Практически
			// дублирует флаг fSCardBonus с небольшим нюансом. Если остаток на карте нулевой, то fSCardBonus не выставляется,
			// а fSCardBonusReal - устанавливается. Такое раздвоение необходимо что бы разным образом обрабатывать начисление
			// бонуса и использование бонуса для оплаты.
	};
	enum {
		uifCloseWOAsk         = 0x0001, // Закрывать кассовую панель без подтверждения PPCFM_CLOSECCHKPANE
		uifOnce               = 0x0004, // Панель открывается только для пробития единственного чека.
			// После проведения чека панель закрывается без предупреждения. Если чек не проведен, то
			// при попытке выхода из панели предупреждение запрашивается.
		uifTSGGroupsAsButtons = 0x0008, // Отрисовывать элементы списка групп как кнопки
		uifOneGroupLevel      = 0x0010, // В списке выбора группы отображается только один уровень групп,
			// принадлежащих выбранной группе верхнего уровня. Если флаг не установлен, то выбор иерархический
		uifAutoInput          = 0x0020  // Данные в поле ввода были внесены посредством сканирующего устройства.
			// Например, сканером штрихкодов. Признак устанавливается и снимается функцией GetInput на основе
			// анализа среднего времени между вводом символов. Если ввод осущствлялся методом PASTE, то
			// флаг не устанавливается.
	};
	const  PPID CashNodeID;  // @*CheckPaneDialog::CheckPaneDialog
	PPID   ExtCashNodeID;    // @*CheckPaneDialog::CheckPaneDialog
	PPID   AltRegisterID;    // @v9.6.9 @*CheckPaneDialog::CheckPaneDialog
	PPID   TouchScreenID;    // @*CheckPaneDialog::CheckPaneDialog
	PPID   ScaleID;          // @*CheckPaneDialog::CheckPaneDialog
	long   CnFlags;          // @*CheckPaneDialog::CheckPaneDialog (PPObjCashNode(CashNodeID).Flags & (CASHF_SELALLGOODS | CASHF_USEQUOT | CASHF_NOASKPAYMTYPE))
	long   CnExtFlags;       // @*CheckPaneDialog::CheckPaneDialog PPObjCashNode(CashNodeID).ExtFlags
	long   CnSpeciality;     // PPObjCashNode(CashNodeID).Speciality
	PPID   CnLocID;          // PPObjCashNode(CashNodeID).LocID
	PPID   ExtCnLocID;       // PPObjCashNode(ExtCashNodeID).LocID
	long   Flags;            // CheckPaneDialog::fXXX
	long   UiFlags;          // CheckPaneDialog::uifXXX Флаги пользовательского интерфейса
	int    State_p;          // CheckPaneDialog::sXXX
	long   OperRightsFlags;  // CheckPaneDialog::orfXXX
	int    EgaisMode;        // @v9.0.9 Режим работы с ЕГАИС (0 - нет, 1 - использовать, 2 - тестовый режим).
		// Извлекается из записи синхронного кассового узла (PPSyncCashNode::EgaisMode)
		// Если EgaisMode != 0 и !(Flags & fNoEdit), то в конструкторе создается *P_EgPrc.
	double BonusMaxPart;     // @*CPosProcessor::CPosProcessor()
	long   OrgOperRights;    // Права доступа установленные в конструкторе либо по ключу.
		// Так как агент может переопределять права доступа, то при изменении агента OperRightsFlags
		// должны быть восстановлены из OrgOperRights.
		// Права агента имеют приоритет перед правами пользователя или ключа.
	PPID   CheckID;
	PPID   SuspCheckID;      // Загружен отложенный чек с указанным идентификатором
	PPID   AuthAgentID;      // @v8.6.10 Агент, который изначально авторизовался в сессии (для поддержки мобильного официанта)
	PPID   AbstractGoodsID;  // @v9.5.10 Абстрактный товар для проведения строк по свободной цене.
		// Если (CnExtFlags & CASHFX_ABSTRGOODSALLOWED), то равно PPGoodsConfig::DefGoodsID, в противном случае - 0.
	PPObjID OuterOi;         // Внешний объект, к которому привязывается чек.
	LDATETIME LastGrpListUpdTime;     // Время последнего обновления списка групп товаров
	PPGenCashNode::RoundParam R;      // Параметры округления //
	PPSyncCashNode::SuspCheckFilt Scf;
	SString CnName;          // Наименование кассового узла
	SString CnSymb;          // @v8.8.3 Символ кассового узла
	SString Input;
	SString ErrMsgBuf;
	SString TableSelWhatman;
	SString KitchenBellCmd;  // Команда кухонного звонка
	SString KitchenBellPort; // Порты отправки команды кухонного звонка
	SString PhnSvcLocalChannelSymb;
	SString RptPrnPort;      // @v8.8.3 Порт принтера для печати регулярный отчетов (предчек, например)
	Packet P;
	CCheckPacket SelPack;  // Чек, выбранный в качестве образца при возврате
	RAssocArray  SelLines; // Строки чека, относящиеся к образцу, выбранному при возврате
	RetBlock Rb;
	PPObjGoods GObj;
	PPObjSCard ScObj;
	PPObjArticle ArObj;
	PPObjPerson PsnObj;
	PPObjGoodsStruc GSObj;
	CCheckCore CC;
	PPObjCSession CsObj;
	PPObjCashNode CnObj;
	CardState CSt;
	PPCashMachine    * P_CM;
	PPCashMachine    * P_CM_EXT;
	PPCashMachine    * P_CM_ALT; // @v9.6.11
	GoodsToObjAssoc  * P_GTOA;
	PPObjTSession    * P_TSesObj;
	SArray           * P_DivGrpList;
	CCheckPacket     * P_ChkPack;
	PPViewCCheck     * P_CcView;
	PPEgaisProcessor * P_EgPrc; // @v9.0.9
	S_GUID SessUUID;
};

class CheckPaneDialog : public TDialog, public CPosProcessor {
public:
	friend int SLAPI CCheckPane(PPID, PPID, const char *, long);
	static int SetLbxItemHight(TDialog *, long extraParam);

	CheckPaneDialog(PPID cashNodeID, PPID checkID, CCheckPacket * = 0, int isTouchScreen = 0);
	~CheckPaneDialog();
	//
	//
	//
	virtual int    AcceptCheck(const CcAmountList * pPl, PPID altPosNodeID, double cash, int mode);
	virtual void   ClearCheck();
	virtual int    OnUpdateList(int goBottom);
	//int    SetupModifier(PPID modGoodsID);
	void   SetSCard(const char * pStr);
	void   EnableBeep(int enbl);
	void   SetInput(const char * pStr);
	int    LoadTSession(PPID tsessID);
	int    LoadChkInP(PPID chkinpID, PPID goodsID, double qtty);
private:
	static  int PalmImport(PalmBillPacket *, void * extraPtr);
	DECL_HANDLE_EVENT;
	virtual int  FASTCALL valid(ushort command);
	virtual int  SetupState(int st);
	virtual void SetupInfo(const char * pErrMsg);
	virtual int  Implement_AcceptCheckOnEquipment(const CcAmountList * pPl, AcceptCheckProcessBlock & rB);
	virtual int  NotifyGift(PPID giftID, SaGiftArray::Gift * pGift);
	virtual void ClearRow();
	virtual void SetupRowData(int calcRest);
	virtual void SetPrintedFlag(int set);
	virtual int  MessageError(int errCode, const char * pAddedMsg, long outputMode);
	virtual int  ConfirmMessage(int msgId, const char * pAddedMsg, int defaultResponse);
	virtual int  CDispCommand(int cmd, int iVal, double rv1, double rv2);
	int    SetDlgResizeParams();
	int    FASTCALL Barrier(int rmv = 0);
	int    RemoveRow();
	enum {
		sgmNormal = 0,
		sgmByPrice,
		sgmModifier,
		sgmRandom,
		sgmInnerGoodsList,
		sgmAbstractSale, // @v9.5.10
		sgmAllByName     // @v9.6.3 Все товары по наименованию (режим применяется в случае,
			// если необходимо отобразить все товары, содержащие строку, и не зависимо от остатка,
			// но опции кассового узла предписывают показывать только то, что есть на остатке).
	};
	void   SelectGoods__(int mode);
	void   AddFromBasket();
	void   AcceptQuantity();
	void   AcceptSCard(int fromInput, PPID scardID, int ignoreRights = 0);
	int    LoadCheck(const CCheckPacket *, int makeRetCheck, int notShow = 0);
	int    SetupOrder(PPID ordCheckID);
	void   setupRetCheck(int ret);
	void   setupHint();
	int    GetInput();
	void   ClearInput(int selectOnly);
	int    SelectGuestCount(int tableCode, long * pGuestCount);
	void   ProcessEnter(int selectInput);
	int    PrintCheckCopy();
	int    PrintSlipDocument();

	enum {
		scfSelSlipDocForm = 0x0001,
		scfThisNodeOnly   = 0x0002,
		scfAllowReturns   = 0x0004
	};
	int    SelectCheck(PPID * pChkID, SString * pSelFormat, long flags); // @v8.4.3 thisNodeOnly
	//int    SelectCheck(PPID * pChkID, SString * pSelFormat, int selSlipDocForm, int thisNodeOnly); // @v8.4.3 thisNodeOnly
	int    UpdateGList(int updGoodsList, PPID selGroupID);
	int    PreprocessGoodsSelection(PPID goodsID, PPID locID, PgsBlock & rBlk);
	int    SelectSerial(PPID goodsID, SString & rSerial, double * pPriceBySerial);
	void   ResetListWindows(int listCtrlID);
	int    SuspendCheck();
	int    SelectSuspendedCheck();
	int    SelectTable();
	int    ResetOperRightsByKey();
	int    PrintCashReports();
	int    IsSalCode(const SString & rInput, SString & rCode);
	int    IsCode(const SString & rInput, SString & rPfx, int asterix, SString & rCode) const;
	int    SetupSalByCode(const SString & rInput);
	int    Sleep();
	void   DrawListItem(TDrawItemData *);
	int    TestCheck(CheckPaymMethod paymMethod);

	int    InitGroupList(const PPTouchScreenPacket & rTsPack);
	int    MakeGroupEntryList(StrAssocArray * pTreeList, PPID parentID, uint level); // @recursion
	int    SelectGroup(PPID * pGrpID);
	int    GetLastCheckPacket(PPID nodeID, PPID sessID, CCheckPacket * pPack);
	int    GenerateChecks();
	void   AcceptDivision();
	int    GetDataFromScale(PPID * pGoodsID, double * pWeight);
	int    SetupRowByScale();
	int    AcceptRowDiscount();
	int    ProcessPhnSvc(int mode);

	int    InputComplexDinner(SaComplex & rComplex);
	int    EditMemo(const char * pDlvrPhone, const char * pChannel);
	void   ViewStoragePlaces(PPID goodsId);
	int    ConfirmPosPaymBank(double amount);

	ExtGoodsSelDialog * P_EGSDlg;
	long   AutoInputTolerance; // Минимальное среднее время (ms) между вводом символом, ниже которого
		// считается, что данные были введены автоматическим средством ввода (напр. сканером штрихкодов)
	long   BarrierViolationCounter; // @debug
	PPID   AltGoodsGrpID;    //
	PPID   SelGoodsGrpID;    //
	PPID   LastCtrlID;       //
	long   CnSleepTimeout;   // @*CheckPaneDialog::CheckPaneDialog()
		// Таймаут бездействия, после которого панель засыпает (clock)
	clock_t IdleClock;       // Время простоя панели в неактивном режиме (clock)
	clock_t PrintCheckClock; // Время окончания печати чека
	long   ClearCDYTimeout;  // @*CheckPaneDialog::CheckPaneDialog() Таймаут очистки дисплея покупателя после печати чека
	PPCustDisp       * P_CDY;
	PPBnkTerminal	 * P_BNKTERM; // @vmiller
	PalmImportWaiter * P_PalmWaiter;
	AsteriskAmiClient * P_PhnSvcClient;
	PPBillImporter * P_UhttImporter;
	SCycleTimer PhnSvcTimer;
	SCycleTimer UhttImportTimer;

	struct GrpListItem {
		enum {
			fFolder = 0x0001,
			fOpened = 0x0002,
			fFirst  = 0x0004,
			fLast   = 0x0008
		};
		PPID   ID;
		PPID   ParentID;
		uint16 Flags;
		uint16 Level; // Номер уровня группы (0..)
	};
	class GroupArray : public TSArray <GrpListItem> {
	public:
		GroupArray();
		GrpListItem * Get(PPID id, uint * pPos) const;

		PPID   TopID;  // Товарная группа, являющаяся родительской для тех групп, которые в текущий момент отображаются в списке выбора группы.
	};
	GroupArray GroupList;
	PPID   ActiveListID;   //
	//
	// Параметры перерисовки списка товаров
	//
	enum {
		dummyFirst = 1,
		fontGoodsList,     // Шрифт используемый для отрисовки элементов списка товаров (для TouchScreen)
		brSel,             // Кисть для выбранного товара
		brOdd,             // Кисть для нечетных строк товаров
		brEven,            // Кисть для четных строк товаров
		brGrpSel,          // Кисть для выбранной группы
		brGrp,             // Кисть для обычной группы
		brGrpParent,       // Кисть для группы верхнего уровня //
		brErrorBkg,        // Кисть фона для вывода сообщения об ошибке в строке статуса
		brPresentBkg,      // Кисть фона для вывода сообщения о подарке в строке статуса
		clrFocus,
		clrEven,
		clrOdd,
		clrGrp,
		clrParent,
		penSel,            // Рамка для выбранного элемента
		brTotalGift,       // Кисть для фона итоговой величины, если в чеке есть подарок
		brDiscountGift,    // Кисть для фона скидки, если в чеке есть подарочная скидка
		brOrderBkg         // Кисть для фона информации о чеке, если чек создан по заказу
	};
	uint   GoodsListFontHeight;
	int    GoodsListEntryGap;    //
	SPaintToolBox Ptb;           //
};
//
// PPDesktop and cmd edit
//
int   SLAPI EditCmdItem(const PPCommandGroup * pDesktop, PPCommand * pData, int isDesktopCommand);
int   SLAPI EditName(SString & rName);
int   SLAPI EditMenus(PPCommandGroup * pData, long initID, int isDesktop);
int   SLAPI EditMenusFromFile();
HMENU SLAPI PPLoadMenu(TVRez * rez, long menuID, int fromRc, int * pNotFound);

#define SELTYPE_DESKTOP      0
#define SELTYPE_DESKTOPTEMPL 1
#define SELTYPE_MENU         2
#define SELTYPE_MENUTEMPL    3

int SelectMenu(long * pID, SString * pName, int isDesktop, const PPCommandGroup * pGrp);

class PPBizScoreWindow : public TWindow {
public:
	static BOOL CALLBACK Proc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

	PPBizScoreWindow(HWND hParentWnd);
	~PPBizScoreWindow();
	int    Create();
	int    Destroy();
	int    DoCommand(TPoint p);
	int    Move();
	int    LoadData();
private:
	int    Update();
	LDATETIME  Dtm;
	LDATE  ActualDt;
	StrAssocArray  BizScoreList;
	HBRUSH Brush;
	HWND   HParentWnd;
	BizScoreCore Tbl;
};
//
// Descr: Ассоциация, связывающая ввод данных, принятый рабочим столом с исполняемой командой.
//
struct PPDesktopAssocCmd { // @transient
	enum {
		fSpecCode       = 0x0001,
		fSpecCodePrefx  = 0x0002,
		fNonInteractive = 0x0008 // Вызывать команду с минимизацией интерактивности (если возможно)
	};
	enum {
		cbString = 1,     // Просто строка                  // abc AddedStrVal получает значение 'той строки (очищенное от служебных символов и пробелов)
		cbKey,            // Клавиатурный код               // ctrl-f2
		cbSCardCode,      // Номер персональной карты       // @scard
		cbPersonRegister, // Номер персонального регистра   // @reg AddedStrVal является символом типа регистрационного документа.
			// Если AddedStrVal.IsEmpty() и AddedIntVal != 0, то AddedIntVal является идентификатором типа регистрационного документа.
		cbGoodsBarcode    // Штрихкод товара                // @barcode[5..13]
	};
	enum {
		cbfCR    = 0x00000001, // Окончанием ввода должен быть перевод каретки (Enter)
		cbfError = 0x10000000  // Ошибка разбора строки
	};
	struct CodeBlock {
		int    Type;
		long   AddedIntVal;
		long   Flags;
		KeyDownCommand Key;
		IntRange LenRange;
		SString AddedStrVal;
	};

	PPDesktopAssocCmd();
	PPDesktopAssocCmd & Clear();
	int    ParseCode(CodeBlock & rBlk) const;

	long   CmdID;
	long   Flags;
	SString Code;
	SString DvcSerial;
	SString CmdParam;
};
//
// Descr: Пул ассоциаций команд рабочего стола с вводимыми данными
//
class PPDesktopAssocCmdPool { // @persistent
public:
	PPDesktopAssocCmdPool();
	~PPDesktopAssocCmdPool();
	void   Init(PPID desktopId);
	PPID   GetDesktopID() const;
	void   SetDesktopID(PPID id);
	uint   GetCount() const;
	int    GetItem(uint pos, PPDesktopAssocCmd & rCmd) const;
	int    GetByCode(const char * pCode, uint * pPos, PPDesktopAssocCmd * pCmd, SString * pResult = 0) const;
	int    SetItem(uint pos, const PPDesktopAssocCmd * pCmd);
	int    AddItem(const PPDesktopAssocCmd * pCmd);
	int    ReadFromProp(PPID desktopId);
	int    WriteToProp(int use_ta);
private:
	struct Item {
		int32  CmdID;
		int32  Flags;
		uint32 DvcSerialP;
		uint32 CodeP;
		uint32 CmdParamP;
		uint8  Reserve[16];
	};
	int    MakeItem(const PPDesktopAssocCmd & rOuter, Item & rInner);
	int    Pack();

	PPID   DesktopID; // -1 - не определенный стол (0 - общий пул для всех рабочих столов)
	TSArray <Item> L;
	StringSet P;
};

//int	GetDesktpDevList(TSCollection <SUsbDevice> & rList); // @vmiller // ppdesktop.cpp

class PPDesktop : public TWindow {
public:
	static const char * WndClsName;
	static int   Open(long desktopID, int createIfZero = 0);
   	static LRESULT CALLBACK DesktopWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static int   RegWindowClass(HINSTANCE hInst);
	static int   EditAssocCmdList(long desktopID);
	static int   CreateDefault(long * pID);
	static PPCommandMngr * LoadDeskList(int readOnly, PPCommandGroup * pDesktopList);
	static int GetDeskName(long deskId, SString & rDeskName);
	static int HandleNotifyEvent(int kind, const PPNotifyEvent * pEv, void * procExtPtr);
	static COLORREF GetDefaultBgColor();

	PPDesktop();
	~PPDesktop();
	int    Init__(long desktopID);
	int    Destroy(int dontAssignToDb);

	TRect & CalcIconRect(TPoint lrp, TRect & rResult) const;
	int    GetIconSize() const
	{
		return IconSize;
	}
	int    GetIconGap() const
	{
		return IconGap;
	}
	int    Paint();
	int    BeginIconMove(TPoint p);
	int    MoveIcon(TPoint p);
	int    EndIconMove(TPoint p);
	int    Update(const TRect * pR, int drawBackgnd);
	int    EditIconName(long id);
	int    DoCommand(TPoint p);
	int    ArrangeIcons();
	PPBizScoreWindow * GetBizScoreWnd();
	int    CreateBizScoreWnd();
	int    LoadBizScoreData();
	int    Advise();
	void   Unadvise();
protected:
	DECL_HANDLE_EVENT;
private:
	class InputArray : public TSArray <KeyDownCommand> {
	public:
		void   Clear();

		SString DvcSerial;
	};
	struct RawInputBlock {
		RawInputBlock();
		void   ClearInput();
		PPDesktop::InputArray * AddKeyDownCommand(const KeyDownCommand & rK, const char * pDvcSerial);

		uint   RawKeyStatus; // KeyDownCommand::stateXXX
		LTIME  LastRawKeyTime;
		TSCollection <PPDesktop::InputArray> InpList;
		//
		// Далее следуют переменные, используемые как буферы для сокращения времени на распределение памяти
		// при обработке RAWINPUT
		//
		SString DvcNameBuf_;
	};
	ushort Execute();
	void   WMHCreate(LPCREATESTRUCT);
	int    DrawIcon(TCanvas & rC, long cmdID, int isSelected);
	int    DrawIcon(TCanvas & rC, long id, TPoint coord, const SString & rText, const SString & rIcon, int isSelected);
	int    AddTooltip(long id, TPoint coord, const char * pText);
	int    DrawText(TCanvas & rC, TPoint coord, COLORREF color, const char * pText);
	int    ArrangeIcon(PPCommand * pCmd);
	int    ArrangeIcon(TPoint * pCoord);
	int    SaveDesktop(PPCommandMngr * pMgr, PPCommandGroup * pDeskList);
	int    WaitCommand();
	int    ProcessRawInput(long rawInputHandle);
	int    ProcessCommandItem(const PPDesktop::InputArray * pInp, const PPDesktopAssocCmd & rCpItem);
	int    Helper_AcceptInputString(const PPDesktop::InputArray * pInp, const PPDesktopAssocCmd & rCpItem, SString & rBuf);

	int    IconSize; // default=32
	int    IconGap;  // default=8
	long   Selected;
	//long   IsIconMove;
	//int    IsChanged;           // Рабочий стол был изменен и его нужно сохранить в файле
	enum {
		stChanged  = 0x0001, // Рабочий стол был изменен и его нужно сохранить в файле
		stIconMove = 0x0002  // Состояние перемещения иконки
	};
	long   State;
	SImage Logotype;
	TPoint MoveIconCoord;
	TPoint CoordOffs;
	//
	enum {
		dummyFirst = 1,
        fontText,
        fontDef,
        cursorMain,
        brushTextRect,
        brushSelTextRect,
        brushBkg,
        brushDef,
        penTextRect,
        penSelTextRect,
        penDef,
        colorBkg
	};
	SPaintToolBox Ptb; // @v9.0.12
	//
	HWND   HwndTT;
	HWND   HBizScoreWnd;

	PPIDArray Cookies;
	PPCommandGroup * P_ActiveDesktop;
	TSCollection <SUsbDevice> UsbList; // @vmiller
	PPDesktopAssocCmdPool PrivateCp;
	PPDesktopAssocCmdPool CommonCp;
	RawInputBlock Rib;
	PPObjSCard * P_ScObj;
	PPObjGoods * P_GObj;
	PPObjPerson * P_PsnObj;
};
//
// DeleteTmpFiles
//
struct DeleteTmpFilesParam {
	enum {
		fRmvTempData     = 0x0001,
		fRmvTempPrns     = 0x0002,
		fRmvInTransm     = 0x0004,
		fRmvOutTransm    = 0x0008,
		fRmvTempCharry   = 0x0010,
		fRmvTempEmail    = 0x0020,
		fRmvBHTDataFiles = 0x0040
	};
	long   Flags;
	int16  InDays;
	int16  OutDays;
};

int SLAPI PPDeleteTmpFiles(DeleteTmpFilesParam * pDelParam);
int SLAPI DeleteTmpFilesDlg(DeleteTmpFilesParam * pParam);

struct RcvCharryParam {
	SLAPI  RcvCharryParam();
	int    SLAPI Edit();

	enum {
		aRcvFromMail   = 1, // Проверить почтовый ящик
		aGetFromInPath = 2, // Не проверять почтовый ящик
		aRcvFromFile   = 3  // Из файла
	};
	PPID   MailAccID;
	int    Action;
	long   Flags;
};
//
//
//
class PPWhatmanWindow : public TWindowBase {
public:
	//
	// Descr: Открывает окно просмотра файла ватмана pWtmFileName
	//
	static int Launch(const char * pWtmFileName, long options, TWhatmanObject::SelectObjRetBlock * pSelRetBlk);
	//
	// Descr: Открывает окно редактирования файла ватмана pWtmFileName.
	// ARG(pWtmFileName IN): @#{vptr0} Имя файла ватмана для редактирования.
	// ARG(pWtaFileName IN): @#{vptr0} Имя файла панели инструменов.
	// Returns:
	//   >0 - окно успешно создано и запущено
	//   0  - ошибка
	//
	static int Edit(const char * pWtmFileName, const char * pWtaFileName);
	//
	// Descr: Режимы работы окна
	//
	enum {
		modeEdit = 1, // Режим редактирования //
		modeView,     // Режим рабочего отображения //
		modeToolbox   // Режим панели инструментов
	};
	//
	// Descr: Флаги режима работы окна
	//
	enum {
		stfModalSelector = 0x0001 // Окно работает как модальный селектор объекта
	};
	//
	// Descr: Зарезервированные идентификаторы инструментов рисования //
	//
	enum {
		penMain = 1,
		brBackg,
		brGreen,
		fontMain,
		csToolText,
		csToolTextSel,
		paraToolText,
		//
		penObjBorder,
		penObjBorderSel,
		penObjBorderCur,
		penObjRszSq,
		brObjRszSq,
		penObjNonmovBorder,
		penRule,
		brRule,
		penGrid,
		penSubGrid,
		//
		curMove,
		curResizeEW,
		curResizeNS,
		curResizeNESW,
		curResizeNWSE,
		curOdious // @debug
	};
	PPWhatmanWindow(int mode);
	~PPWhatmanWindow();
	int    AddObject(TWhatmanObject * pObj, const TRect * pBounds);
	int    ArrangeObjects(const LongArray * pObjPosList, TArrangeParam & rParam);
	SPaintToolBox & GetToolBox();

	int    EditParam();
	int    AddTool(const char * pObjSymb);
	int    EditTool(uint objIdx);
	int    DeleteTool(uint objIdx);
	int    FileSave();
	int    FileOpen();
	int    LoadTools(const char * pFileName);
protected:
	DECL_HANDLE_EVENT;

	TWhatman W;
private:
	//
	// Descr: Дескриптор местонахождения точки.
	//
	struct Loc {
		enum {
			kNone = 0,       // Точка находится вне ватмана
			kWorkspace,      // Точка находится в рабочей области, но не принадлежит ни одному из объектов
			kObject,         // Точка находится в области объекта
			kObjectInMultSel // Точка находится в области одного из объектов, принадлежащего множеству выбранных
		};
		int    Kind;
		int    ObjIdx;
		int    ObjRszDir;
		TPoint Pt;
		const  TWhatmanObject * P_Obj;
	};
	struct ResizeState {
		ResizeState();
		~ResizeState();
		int    operator ! () const;
		void   Reset();
		int    Setup(int mode, const Loc & rLoc, int * pCursorIdent);

		enum {
			kNone = 0,      // Ничего не происходит
			kObjMove,       // Объект перемещается.
			kObjResize,     // Объект изменяет размеры.
			kObjDrag,       // Объекта переносится в рамках операции Drag'n'Drop
			kObjDragTarget, // Перемещение курсора с объектом из чужого источника
			kRectSelection, // Режим выделения прямоугольной области для выбора нескольких объектов
			kMultObjMove    // Перемещение множества выбранных объектов
		};
		enum {
			fDontDrawMovedObj = 0x0001
		};
		int    Kind;      //
		int    ObjIdx;    //
		int    ObjRszDir; // Направление изменения размера объекта (SOW_XXX)
		long   Flags;     // @flags
		TPoint StartPt;   // Стартовая точка начала перемещения //
		TPoint EndPt;     // Последняя фиксация точки, в которую необходимо осуществить перемещение.
		TWhatmanObject * P_MovedObjCopy;
	};
	struct State_ {
		int    Mode;      // PPWhatmanWindow::modeXXX
		long   Flags;     // PPWhatmanWindow::stfXXX
		int    SelectedObjIdx;
		ResizeState Rsz;
	};
	class ToolObject : public TWhatmanObject {
	public:
		ToolObject(const char * pToolSymb, const TWhatmanToolArray * pTools, const TRect & rBounds);
		virtual TWhatmanObject * Dup() const;
		virtual int Draw(TCanvas2 & rCanv);
		virtual int GetTextLayout(STextLayout & rTlo, int options) const;

		SString ToolSymb; // Символ объекта в контейнере инструментов
		const TWhatmanToolArray * P_Tools; // @notowned
	};
	struct DdotInfoBlock {
		TWindow * P_SrcWin;
		TWhatmanToolArray::Item WtaItem;
	};

	int    Resize(int mode, TPoint p);
	int    Locate(TPoint p, Loc * pLoc) const;
	int    Rearrange();
	int    LocalMenu(int objIdx);
	int    InvalidateObjScope(const TWhatmanObject * pObj);

	State_ St;
	TWhatmanToolArray Tools;
	DdotInfoBlock Dib;
};
//
//
//
void   SLAPI SetupTimePicker(TDialog * pDlg, uint editCtlID, int buttCtlID);
int    SLAPI SynchronizeObjects(PPID dest);
int    SLAPI CorrectLotsCloseTags();
int    SLAPI CorrectLotSuppl();
int    SLAPI CorrectZeroQCertRefs();
int    SLAPI CorrectAccturn();       // PPACC\C_ATURN.CPP
int    SLAPI EditQuotVal(PPQuot * pQ, int quotCls);
int    SLAPI EditQuotUpdDialog(QuotUpdFilt * pFilt);
int    SLAPI ViewQuotValueInfo(const PPQuot & rQuot);
int    SLAPI UpdateQuots(const QuotUpdFilt *);
int    SLAPI MakeCRptDataFiles(int verifyAll = 0);    // PPLIB\PPTVUTIL.CPP
int    SLAPI RecoverAbsenceLots();   // PPBILL\C_TRFR.CPP
int    SLAPI RecoverAbsenceGoods();  // PPBILL\C_TRFR.CPP
int    SLAPI RecoverAbsenceBills();  // Восстановление потерянных заголовков документов
int    SLAPI RecoverAbsenceAccounts(); // Восстановление отсутствующих счетов
int    SLAPI RecoverGoodsGroups(const GoodsGroupRecoverParam * pParam);
	// @<<cmCorrectGoodsGroups
	// @>>PPObjGoodsGroup::Recover
int    SLAPI RecoverGoodsGroupsNIA();
int    SLAPI RecoverTransfer();
//
// Descr: Удаление "плохих" зачетов
//
int    SLAPI RemoveBadReckons();
int    SLAPI CurReval();
int    SLAPI RestoreBalance();
int    SLAPI SaveBalance();
int    SLAPI MakeDatabase();
// @unused int    SLAPI UpdateLicense();
// @unused int    SLAPI Registration();
//
// Descr: Интерактивная функция, вызывающая диалог добавления товара goodsID
//   в товарную корзину. Корзина может быть выбрана прямо в этом диалоге.
//   Если goodsID == 0, то функция ничего не делает.
//   Параметр defLocID определяет, с какого склада брать текущие данные по товару
//   (цену, срок годности, емкость упаковки и т.д.)
//
int    SLAPI AddGoodsToBasket(PPID goodsID, PPID defLocID, double qtty = 0.0, double price = 0.0);
int    SLAPI RevalAssets();
int    SLAPI WriteOffDrafts(const PPIDArray * pCSessList);
int    SLAPI ProcessDL200();
int    SLAPI ProcessGoodsSaldo();
//
// Descr: Редактирование списка выходных для прогнозирования //
//
int    SLAPI EditHolidays();
int    SLAPI ViewGoodsInfo(const InfoKioskPaneFilt * pFilt);
int    SLAPI ViewSCardInfo(PPID * pSCardID, int asSelector);
//
// Descr: Отображает список товарных позиций, соответсвующих забракованной серии pSerial
//
int    SLAPI ViewSpoilList(SpecSeriesCore * pTbl, const char * pSerial, int useText);
int    SLAPI SendCharryObject(PPID strucID, const PPIDArray & rObjIdList);
int    SLAPI SendCharryFiles();
int    SLAPI ReceiveCharryObjects(RcvCharryParam *);
//
// Descr: Вызывает функцию обслуживания задач объекта PPObjPrjTask.
//   Перед вызовом требует подтверждения пользователем
// Returns:
//   >0 - Функция успешно выполнена
//   <0 - Функция отклонена пользователем
//   0  - Ошибка
//
int    SLAPI MaintainPrjTask();      // @>>PPObjPrjTask::Maintain
int    SLAPI ExecPrcPane(PPID prcID);
//
// Поддержка импорта-экспорта в клиент-банк
//
int    SLAPI SetupCliBnkFormats();
int    SLAPI SetupCliBnkAssoc();
int    SLAPI CliBnkImport();
int    SLAPI CliBnkSelectCfgDialog(int direction /*1 - export, 2 - import*/, SString & rSection);
int    SLAPI ConvertRbcBnk(const char * pPath);
//
// Descr: Вызывает диалог конфигурирования импорта специальных серий
//
int    SLAPI EditSpecSeriesFormatDescription();
//
// Descr: Вызывает диалог просмотра картинки и информации ей сопутствующей
//
int    SLAPI ViewImageInfo(const char * pImagePath, const char * pInfo, const char * pWarn);
//
//
//
int    SLAPI EditImpExpParams(uint iniFileID, uint sdRecID, PPImpExpParam * pParam, ImpExpParamDialog * pParamDlg);
int    SLAPI EditBillImpExpParams(int editBill);
int    SLAPI EditInventoryImpExpParams();
int    SLAPI EditGoodsImpExpParams(const char * pIniSection);
int    SLAPI EditGoodsImpExpParams();
int    SLAPI EditImpExpConfigs();

int    SLAPI ImportBills(PPBillImpExpParam * pBillParam, PPBillImpExpParam * pBRowParam, PPID opID, PPID locID);
int    SLAPI ImportEmailAccts();
int    SLAPI ExportEmailAccts(PPIDArray * pMailAcctsList);
//
// @v9.1.3 int SLAPI EditCSessImpExpParams(int onlyAltImport = 0);
// @v9.1.3 int SLAPI SelCSessImpExpParams(PPImpExpParam * pCSessParam, PPImpExpParam * pCCheckParam, PPImpExpParam * pCCLineParam, int import);
int    SLAPI SupplGoodsImport();

int    SLAPI EditSupplExpFilt(SupplExpFilt * pFilt, int selOnlySuppl);
int    SLAPI DoSupplInterchange(SupplInterchangeFilt * pFilt); // @v9.2.1 ExportDataForSuppl-->DoSupplInterchange
int    SLAPI EditPriceListImpExpParams();
int    SLAPI EditDebtLimList(PPClientAgreement & rCliAgt);

int    SLAPI EditCheckInPersonItem(const PPCheckInPersonConfig * pCfg, PPCheckInPersonItem * pData);
int    SLAPI EditCheckInPersonList(const PPCheckInPersonConfig * pCfg, PPCheckInPersonArray * pData);
void   PPViewTextBrowser(const char * pFileName, const char * pTitle, int toolbarId = -1);
int    SLAPI PPEditTextFile(const char * pFileName);

struct ResolveGoodsItem {
	ResolveGoodsItem(PPID goodsID = 0);

	PPID   GoodsID;
	PPID   ResolvedGoodsID;
	PPID   ArID;              // Статья, с которой связан код ArCode
	char   GoodsName[128];
	char   Barcode[24];
	char   ArCode[24];        // Код, ассоциированный со статьей ArID. @v8.8.0 [16]-->[24]
	double Quantity;
};

class ResolveGoodsItemList : public TSArray <ResolveGoodsItem> {
public:
	SLAPI  ResolveGoodsItemList();
	SLAPI  ResolveGoodsItemList(const ResolveGoodsItemList & s);
	ResolveGoodsItemList & FASTCALL operator = (const ResolveGoodsItemList & s);
	ResolveGoodsItemList & FASTCALL operator = (const PPIDArray & s);
};
//
// Descr: Разрешает с помощью диалога неизвестные системе товары
//
#define RESOLVEGF_RESOLVEALLGOODS 0x0001 // Выдавать ошибку, если не все товары были разрешены
#define RESOLVEGF_SHOWBARCODE     0x0002 // Показывать вместе с именем товара штрихкод
#define RESOLVEGF_SHOWQTTY        0x0004 // Показывать вместе с именем товара количество
#define RESOLVEGF_MAXLIKEGOODS    0x0008 // Выдавать список товаров для подстановки по нечеткому поиску
#define RESOLVEGF_SHOWRESOLVED    0x0010 // Показывать товары для которых подстановка уже выполнена
#define RESOLVEGF_SHOWEXTDLG      0x0020 // Отображать диалог DLG_SUBSTGL

int SLAPI ResolveGoodsDlg(ResolveGoodsItemList * pData, int flags);
//
// Descr: Диалог редактирования параметров для массового изменения пластиковых карт
//
class SCardSelPrcssrDlg : public TDialog {
public:
	SCardSelPrcssrDlg(PPViewSCard * pView, int editSCardFilt);
	int    setDTS(const SCardSelPrcssrParam * pData);
	int    getDTS(SCardSelPrcssrParam * pData);
private:
	DECL_HANDLE_EVENT;
	int    EditSCardFilt;
	SCardSelPrcssrParam Data;
	PPViewSCard * P_View;
};
//
// Конвертация сертификатов качества в теги лотов (для Лэнда).
//
int SLAPI ConvertLandQCertToLotTag();
// @v3.7.2 int SLAPI Convert229();
// @v3.7.2 int SLAPI Convert253();
// @v3.7.2 int SLAPI Convert270();
// @v3.7.2 int SLAPI Convert300();
//int SLAPI Convert301();
//int SLAPI Convert329();
//int SLAPI Convert3512();  // Перенесено в Convert4405
int SLAPI Convert372();
//int SLAPI Convert380();   // Перенесено в Convert4405
int SLAPI Convert31102();
int SLAPI Convert31110();
int SLAPI Convert400();
int SLAPI Convert4108();
// @v6.2.2 int SLAPI Convert4208();
int SLAPI Convert4402();
int SLAPI Convert4405();
int SLAPI Convert4515();
int SLAPI Convert4707();
int SLAPI Convert4802();    // AHTOXA
int SLAPI Convert4805();
int SLAPI Convert4911();
// [Перенесено в Convert6202()] int SLAPI Convert5006();    // VADIM
int SLAPI Convert5009();    // @v5.0.10 AHTOXA
int SLAPI Convert5200();
int SLAPI Convert5207();    // @v5.2.7 AHTOXA
int SLAPI Convert5501();    // @v5.5.1
// [Перенесено в Convert6202()] int SLAPI Convert5506();    // @v5.5.6 VADIM
// [Перенесено в Convert6202()] int SLAPI Convert5512();    // @v5.5.12 Добавился индекс к таблице World
int SLAPI Convert5608();    // @v5.6.08 ObjSync Значительное изменение
int SLAPI Convert5810();    // @v5.8.10 Reference-->Reference2; CGoodsLine
int SLAPI Convert6202();    // @v6.2.2  (SpecSeries значительное изменение) +
int SLAPI Convert6303();    // @v6.3.3
int SLAPI Convert6407();    // @v6.4.7
int SLAPI Convert6611();    // @v6.6.11
// [Перенесено в Convert7601()] int SLAPI Convert6708();    // @v6.7.8
int SLAPI Convert7311();   // @v7.3.11
int SLAPI ConvertQuot720(); // @v7.1.11
int SLAPI Convert7305();    // @v7.3.5
int SLAPI Convert7506();    // @v7.5.6
int SLAPI Convert7601();    // @v7.6.1
// @v9.4.0 int SLAPI Convert7702();    // @v7.7.2
int SLAPI Convert7708();    // @v7.7.8
int SLAPI Convert7712();    // @v7.7.12
int SLAPI Convert7907();
// @v8.3.6 int SLAPI Convert8203();
int SLAPI Convert8306();
int SLAPI Convert8800();
int SLAPI ConvertWorkbook813(); // @v8.1.3
int SLAPI Convert8910(); // @v8.9.10
// @v9.0.4 int SLAPI Convert9003();
int SLAPI Convert9004(); // @v9.0.4
int SLAPI Convert9108(); // @v9.1.8
int SLAPI Convert9214(); // @v9.2.14
int SLAPI Convert9400(); // @v9.4.0
int SLAPI DoChargeSalary();
int SLAPI DoDebtRate();
int SLAPI DoBizScore(PPID bzsID);
int SLAPI DoProcessObjText(PrcssrObjTextFilt * pFilt);
int SLAPI DoProcessOsm(PrcssrOsmFilt * pFilt);
int SLAPI DoProcessSartre(PrcssrSartreFilt * pFilt);
int SLAPI DoConstructionTest();

template <typename Dlg, typename D> int PPDialogProcBodyID(uint dlgID, D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg(dlgID);
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

template <typename Dlg, typename D> int PPDialogProcBody(D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg;
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

template <typename Dlg, typename D> int PPDialogProcBody(uint dlgId, D * pData)
{
	int    ok = -1;
	Dlg * dlg = new Dlg(dlgId);
	if(CheckDialogPtrErr(&dlg) && dlg->setDTS(pData)) {
		while(ok <= 0 && ExecView(dlg) == cmOK)
			if(dlg->getDTS(pData))
				ok = 1;
	}
	else
		ok = 0;
	delete dlg;
	return ok;
}

#define DIALOG_PROC_BODY(dlg_class, data_param)          \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class;                         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODYERR(dlg_class, data_param)        \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class;                         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P1(dlg_class, param1, data_param) \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1);                 \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P2(dlg_class, param1, param2, data_param) \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1, param2);         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P1ERR(dlg_class, param1, data_param) \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1);                 \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;

#define DIALOG_PROC_BODY_P2ERR(dlg_class, param1, param2, data_param) \
int ok = -1;                                             \
dlg_class * dlg = new dlg_class(param1, param2);         \
if(CheckDialogPtrErr(&dlg) && dlg->setDTS(data_param)) { \
	while(ok <= 0 && ExecView(dlg) == cmOK)              \
		if(dlg->getDTS(data_param)) ok = 1;              \
		else PPError();                                  \
}                                                        \
else ok = 0;                                             \
delete dlg; return ok;
//
//
//
#endif // } __PP_H
