// PPEXP.DL6
// Copyright (c) A.Sobolev 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025
// Этот файл создается и модифицируется только разработчиками системы и распространяется с дистрибутивом.
// ! Ни в коем случае не модифицируйте этот файл самостоятельно !
//
// DataObject           Объект данных
// Global               Общие параметры
// User                 Пользователь
// DBDiv                Раздел базы данных
// OprKind              Вид операции
// OprKindList          Список видов операций
// Currency             Валюта
// CurRateType          Тип валютного курса
// AccSheet             Таблица аналитических статей
// Article              Аналитическая статья             //
// ArticleView          Список аналитических статей
// CurRateView          Список валютных курсов
// Country              Государство
// City                 Город
// Warehouse            Склад (LocationTbl::Rec)
// Person               Персоналия                       //
// PersonReq            Расширенные реквизиты персоналии
// Bill                 Документ
// AmountType           Суммы документов
// Unit                 Единица измерения                //
// GoodsType            Тип товара
// GoodsTaxGrp          Группа налогообложения товаров
// AssetWrOffGrp        Группа списания основных фондов
// GoodsGroup           Группа товаров
// Goods                Товар
// GoodsView            Список товаров (PPViewGoods)
// QualityCert          Сертификат качества
// QuotKind             Вид котировки
// Transport            Транспортное средство
// Brand                Торговая марка
// GoodsRest            Остатки товаров (PPViewGoodsRest)
// GoodsTaxAnlz         Налоговый анализ товарооборота
// GoodsOpAnlz          Товарный отчет по операции
// GoodsOpAnlzCmp       Товарный отчет по операции со-сравнением
// PriceListData        Прайс-лист
// PriceListQCert       Сертификаты к прайс-листу
// GoodsBillBase        Базовая структура для товарных документов
// GoodsBillQCert       Сертификаты к товарной накладной
// GoodsReval           Товарная переоценка
// CashOrder            Кассовый ордер (обобщение приходного и расходного касоовых ордеров)
// PayCashOrder         Расходный кассовый ордер
// RcvCashOrder         Приходный кассовый ордер
// BnkPaymOrder         Банковское платежное поручение (платежное требование)
// Lots                 Лоты (PPViewLots)
// BillList             Реестр документов (PPViewBill)
// ContentBList         Реестр документов с содержанием (PPViewBill)
// CashBook             Кассовая книга
// SysJournal           Системный журнал
// GoodsBillData        Товарная накладная //
// LadingBillData       Товарно-транспортная накладная, форма ТОРГ-12 и т.д.
// InvoiceData          Счет-фактура
// GoodsBillLoss        Акт о порче, бое, ломе
// OperBillList         Реестр документов по операции
// NominalBList         Реестр документов в номинальных ценах
// DebetBillList        Реестр документов с суммой долга
// DebtCard             Долговая карточка контрагента
// DebtTrnovr           Долговая ведомость по контрагентам
// IntrBillList         Реестр межскладских перемещений
// Account              Бухгалтерский счет
// AccRel               Служебная структура (счет, статья)
// AccountView          План счетов (PPViewAccont)
// AccturnList          Опись проводок
// AccAnlz              Анализ счета
// SupplTrnovr          Обороты по поставщикам
// Balance              Баланс
// VatBook              Книга продаж/покупок
// OpGrouping           Группировка операций
// GoodsStruc           Структура товара
// GoodsMov             Отчет о движении товаров
// GoodsMov2            Отчет о движении товаров расчитанный по новому алгоритму
// CashNode             Кассовый узел
// CSession             Кассовая сессия //
// CSessionView         Кассовые сессии
// CSessExc             Излишки по кассовым сессиям
// TrfrAnlzBase         Базовая структура анализа товарных операций
// GoodsBasket          Корзина товаров
// ShipmAnlz            Анализ отгрузки
// GoodsTurnovr         Товарооборот
// PaymPlan             План платежей
// AdvanceRep           Авансовый отчет
// SCardOpList          Список операций по пластиковой карте (PPViewSCardOp)
// BillTotal            Итоги по документам
// GoodsRestTotal       Итоги по остаткам товаров
// GTaxAnlzTotal        Итоги налогового анализа товарооборота
// PersonList           Список персоналий (PPViewPerson)
// AssetReceipt         Инвентарная карточка основных средств
// ObjSyncCmp           Анализ синхронизации объектов (PPViewObjSyncCmp)
// AssetView            Основные средства
// LogList              Журнал сообщений
// Warrant              Доверенность
// FreightList          Список зафрахтованных документов
// QuotView             Список котировок
// GoodsBillCmp         Сравнение строк товарных документов
// Complete             Состав изделия //
// MrpLines             Строки MRP-таблицы
// Processor            Процессор
// TechView             Список технологий
// PrjTaskView          Список задач
// BillInfo             Специальная информация о документе
// BillInfoList         Специальная информация по списку документов
// PriceAnlz            Сравнительный анализ цен
// RptInfo              Сведения об отчетах
// PersonEvent          Персональные операции
// PsnEventItem         Персональная операция  //
// PsnRelList           Персональные отношения //
// GoodsStrucList       Список товарных структур
// JobPool              Список задач сервера
// Salary               Анализ начисления зарплаты
// SalaryByPost         Анализ начисления зарплаты с группировкой по штатным назначениям
// StaffCalView         Анализ штатных календарей
// SupplNameList        Поставщики товара за последние 3 мес.
// Employee             Служащий
// LocPrnTest           Тест печати на локальный принтер
// PsnOpKindView        Список видов персональных операций
// TransportView        Список транспортных средств
// BudgetItem           Элементы Бюджета
// Budget               Бюджет
// CheckOpJrnl          Журнал чековых операций

//
// Сокращения, используемы в комментариях к полям:
// @id        - целочисленный уникальный идентификатор записи
// @name      - основное наименование записи
// @symb      - символ записи
// @flags     - поле флагов
// @alignment - поле не используется. Введено в структуру только для выравнивания предыдущих полей по границе двойного слова (4 байта).
//

//
// Флаги функции qttytostr
//   0x0100  - Просто число
//   0x0200  - "q/p"
//   0x0400  - "q/p+f"
//   0x0800  - 9.999 три знака после точки

//
// Типы объектов данных
//
data DataObject {
	key    ID;
	string Name[48];
}
//
// Общие данные, необходимые для печати отчетов
//
data Person;
data Currency;
data AccSheet;
data Article;
data GlobalUserAcc;
data Location;
data DebtDim;
data CCheck;
data SCard;
data PersonKind;
data ObjectTag;
data AlcoRepConfig;
data UhttStore;
data GoodsFilt;

data Global {
	key    ID;                     // @id
	link   Person MainOrgID;       // ИД главной организации
	link   Currency BaseCurID;     // Базовая валюта
	link   Location MainAddrID;    // Ссылка на юридический адрес главной организации
	link   Location MainRAddrID;   // Ссылка на фактический адрес главной организации. Если в базе данных фактический адрес
		// не определен, то ссылка получает значение равное MainAddrID
	string MainOrgName[48];        // Наименование главной организации
	string ShortOrgName[48];       // Сокращенное наименование главной организации
	string MainOrgMemo[128];       // Примечание к персоналии главной организации
	string MainOrgExtName[128];    // Расширенное наименование главной организации
	string MainOrgBankAcc[128];    // Полный текст основного банковского счета (вместе с именем банка)
	string MainOrgBnkName[128];    // Наименование банка, в котором открыт основной расчетный счет
	string MainOrgBnkAccN[32];     // Номер основного расчетного банковского счета
	string Director[48];           // Имя директора
	string Cashier[48];            // Имя кассира
	string Accountant[48];         // Имя главного бухгалтера
	string Address[128];           // Юридический адрес
	string RAddress[128];          // Фактический адрес
	string Phone[128];             // Список электронных адресов
	string INN[32];                // ИНН главной организации
	string KPP[12];                // КПП
	string OKPO[16];               // ОКПО
	int16  IsPrivateEnt;           // Признак того, что главная организация имеет статус частного предпринимателя //
	int16  Reserve;                // @alignment
	date   CurDate;                // Текущая операционная дата
	//
	// Descr: Возвращает ссылку на персоналию, занимающую (занимавшую) фиксированный
	//   штатный пост, определяемый параметром post на дату dt.
	// ARG(post IN): 1 - директор, 2 - главный бухгалтер.
	// ARG(dt   IN): дата, на которую было действительно назначение. Если
	//   данные в базе не позволяют получить точный ответ на эту дату, то
	//   возвращается персоналия, занимающая пост в текущее время.
	//
	link   Person GetFixedStaffPost(int post, date dt);
	//
	// Descr: Возвращает ссылку на таблицу аналитических статей, связанную с поставщиками.
	//
	link   AccSheet GetSupplAccSheet();
	//
	// Descr: Возвращает ссылку на таблицу аналитических статей, связанную с покупателями.
	//
	link   AccSheet GetClientAccSheet();
	//
	// Descr: Возвращает ссылку на таблицу аналитических статей с символом symb.
	//
	link   AccSheet GetAccSheet(string symb[20]);
	//
	// Descr: Возвращает ссылку на статью аналитического учета, ассоциированную
	//   в персоналией personID по таблице статей accSheetID.
	//
	link   Article  PersonToArticle(long personID, long accSheetID);
	//
	// Descr: Возвращает ссылку на идентификатор глобальной учетной записи,
	//   установленный в текущем потоке.
	//
	link   GlobalUserAcc GetCurrentGlobalUser();
	//
	// Descr: Проверка прав текущей глобальной учетной записи.
	//
	int    CheckCurrentGlobalUserRights(int tagID, int flags, string scope[128]);
	//
	// Descr: Проверка флага
	//
	int    CheckFlag(int flags, int flag);
	//
	// Descr: Добавляет в конец кода barcode контрольную цифру если:
	//   -- длина barcode > 3
	//   -- в конфигурации справочника товаров сброшен флаг "Штрихкод содержит контрольную цифру"
	//   -- префикс штрихкода не является весовым, заданным в конфигурации товаров
	// Returns:
	//   Скорректированная строка штрихкода
	//
	string AdjustBarcodeCD[20](string barcode[20]);
	long   GetCounter(string counterSymb[20]);
	int    UpdateCounter(string counterSymb[20], long newValue);
	link   AlcoRepConfig GetAlcoRepConfig();
	//
	// Descr: Возвращает UUID базы данных в текстовом формате
	//
	string GetDbUUID[40]();
}
//
// Пользователь системы
//
data User {
	key    ID;
	string Name[32];
	string Symb[20]; //
	link   Person PersonID; // Персоналия, на которую ссылается пользователь
}
//
// Запись системного журнала.
// Эта запись идентифицируется суррогатным ключом, создаваемым
// при обращении к функции извлечения события из других структур.
//
data SysJournalEntry {
	key    SurID;               // Суррогатный ключ, имеющий силу только внутри одного сеанса системы
	link   User       UserID;
	link   DataObject ObjType;
	long   ObjID;
	long   ActionID;
	date   Dt;
	time   Tm;
	long   Extra;
	string ActionName[48];

	TmTxt       = (format(Tm, ~>&N));
	UserName    = UserID.Name;
	ObjTypeName = ObjType ? ObjType.Name : "";
}
//
// Раздел базы данных
//
data DBDiv {
	key    ID;                     // @id
	string Name[48];               // @name
}
//
// Валюта
// @uhtt
//
data Currency {
	declare "Set"
	key    ID;                     // @id
	string Name[32];               // @name
	string Symb[16];               // @symb
	int32  DigitCode;              //
}
//
// Тип валютного курса
//
data CurRateType {
	declare "Set"
	key    ID;                     // @id
	string Name[32];               // @name
	string Symb[20];               // @symb
}
//
// Таблица статей аналитического учета
//
data AccSheet {
	key    ID;                     // @id
	string Name[48];               // @name
	link   DataObject LinkObjType; // Ссылка на тип связанных со статьями объектов данных
}
//
// Операционные счетчики
//
data OpCounter {
	key    ID;                     // @id
	string Name[48];               // @name
	string Symb[20];               // @symb
	string CodeTemplate[24];       // Шаблон нумерации
	link   DataObject ObjType;     // Тип объекта, владеющего счетчиком. Если 0, то PPOBJ_OPRKIND
	long   Flags;                  // OPCNTF_XXX
	long   Counter;                // Текущее значение счетчика
	long   OwnerObjID;             // Объект-владелец счетчика (если 0, то может принадлежать более чем одной операции)
}
//
// Вид операции
//
data OprKind {
	key    ID;                     // @id
	string Name[48];               // @name
	string Symb[20];               // @symb
	string ExpSymb[48];            // Символ вида операции для экспорта. Papyrus не поддерживает уникальность этого символа.
	link   AccSheet AccSheetID;    // Основная таблица статей
	link   AccSheet AccSheet2ID;   // Дополнительная таблица статей
	link   OprKind  LinkOpID;      // Связанная операция //
	link   OpCounter OpCntrID;     // Счетчик нумерации документов
	long   OpType;                 //
	long   Flags;                  // Флаги
	int16  fNeedPayment;           // Требует платежного документа //
	int16  fProfitable;            // Доходная операция //
	int16  fReckon;                // Зачетная операция //
	int16  Reserve;                // @alignment
}
//
// Список видов операций
//
data OprKindList {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global   Glb;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	int16  FltReckon;
	int16  FltNeedPayment;
	int16  FltProfitable;
	int16  FltPassive;
	string FltOpTypeName[64];
	long   FltOpType;
	link   AccSheet FltAccSheet;
	FltAccSheetName = FltAccSheet.Name;
	FltReckonTxt   = ((FltReckon)      ? "зачетные" : "");
	FltNeedPaymTxt = ((FltNeedPayment) ? "требующие оплаты" : "");
	FltProfitblTxt = ((FltProfitable)  ? "доходные" : "");
	FltPassiveTxt  = ((FltPassive)     ? "пассивные" : "");
	TitleText      = (if(length(FltOpTypeName) != 0) "тип операции: " + FltOpTypeName);

	iteration {
		link OprKind OpID;
		string OpType[64];
		string FlagsMnemonics[32];
		string Template[84];

		Name = OpID.Name;
		Symb = OpID.Symb;
		AccSheetName = OpID.AccSheetID.Name;
		LinkOpName = OpID.LinkOpID.Name;
	}
}
//
// Валютные курсы
//
data CurRateView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global   Glb;
	link   Currency FltCurID;
	link   Currency FltBaseCurID;
	link   CurRateType FltRateTypeID;
	date   FltBeg;
	date   FltEnd;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltCurName      = FltCurID.Name;
	FltCurSymb      = FltCurID.Symb;
	FltBaseCurName  = FltBaseCurID.Name;
	FltBaseCurSymb  = FltBaseCurID.Symb;
	FltRateTypeName = FltRateTypeID.Name;
	Period = formatperiod(FltBeg, FltEnd);

	iteration {
		date   Dt;
		link   Currency    CurID;
		link   Currency    BaseCurID;
		link   CurRateType RateTypeID;
		double Rate;

		CurName      = CurID.Name;
		CurSymb      = CurID.Symb;
		BaseCurName  = BaseCurID.Name;
		BaseCurSymb  = BaseCurID.Symb;
		RateTypeName = RateTypeID.Name;
	}
}
//
// Обобщенное представление географического объекта
// @uhtt
//
data World {
	key    ID;                     // @id
	long   Kind;                   // WORLDOBJ_CONTINENT(1) || WORLDOBJ_GENREGION(2) || WORLDOBJ_COUNTRY(3) || WORLDOBJ_REGION(4) || WORLDOBJ_CITY(5) || WORLDOBJ_STREET(6)
	link   World     ParentID;     // ->World.ID
	link   World     CountryID;    // ->World.ID (WORLDOBJ_COUNTRY)
	link   Currency  CurrencyID;   // Валюта для государств ->Ref(PPOBJ_CURRENCY)
	long   Status;                 //
	long   Flags;                  //
	double Latitude;               // Географическая широта
	double Longitude;              // Географическая долгота
	string Name[48];               // @name
	string Abbr[20];               // Для государств используется alpha-2 код по ISO 3166
	string Phone[20];              //
	string Code[20];               // Код по какой-либо внешней классификации. Если такая классификация используется,
		// то все записи должны иметь код именно по этой классификации (или не иметь вовсе)
		// Для государств используется числовой код по ISO 3166
	string ZIP[12];                // ZIP-код географического объекта. Модуль адреса сможет использовать этот код
}
//
// Государство
//
data Country {
	key    ID;                     // @id
	link   World WID;              // =ID
	string Name[30];               // @todo [48]
	string Abbr[20];               //
	string Phone[20];              //
	string Code[20];               // Классификатор (скорее всего по КЛАДР)
	int16  fNativeLand;            // Признак того, что государство является родным для главной организации
	int16  Reserve;                // @alignment
}
//
// Населенный пункт
//
data City {
	key    ID;                     // @id
	link   World WID;              // =ID
	link   Country CountryID;      //
	link   World   RegionID;       //
	string Name[30];               // @todo [48]
	string Abbr[20];               //
	string Phone[20];              //
	string Code[20];               // Классификатор (скорее всего по КЛАДР)
	string ZIP[16];                //
}
//
// Типы регистров
//
data RegisterType {
	key    ID;                     // @id
	string Name[48];               // @name
	string Symb[20];               // Символ для ссылок из формул и т.д.
	link   PersonKind KindID;      // Вид персоналии, к которой и только к которой может относиться этот регистр. Если 0, то к любому виду.
	link   PersonKind RegOrgKindID; // Вид регистрирующей организации
	long   Flags;                  // Флаги
}
//
// Регистрационный документ
//
data PersonRegister {
	key    ID;                     // @id
	link   RegisterType RegTypeID; // Тип регистрационного документа
	link   Person       PersonID;  // Персоналия, которой принадлежит этот регистр
	link   Location     LocID;     // Локация, которой принадлежит регистр
		// @#{PersonID^LocID}
	link   Person       RegOrgID;  // Регистрирующая организация //
	long   EventID;                // Персональная операция, к которой привязан регистр
	date   Dt;                     // Дата начала действия регистра
	date   Expiry;                 // Дата окончания действия регистра
	long   Flags;                  // Флаги PREGF_XXX
	string Serial[12];             // Серийный номер
	string Number[32];             // Номер
	//
	// Descr: Возвращает строку с информацией о регистре в соответствии с форматом,
	//   определенном в типе регистрационного документа.
	//
	string Format[256]();
}
//
// Место (в т.ч. склад)
// @uhtt
//
data Location {
	key    ID;
	link   Location ParentID;      // Родительская локация //
	long   Type;                   // Тип локации
		// 1 - склад главной организации
		// 2 - складская зона хранени
		// 3 - адрес персоналии
		// 4 - структурное подразделение
		// 5 - группа складов
	link   Person OwnerID;         // Персоналия-владелец локации
	string Code[16];               // Код локации (внутренний символ для идентификации)
	string Name[48];               // @name
	string ZIP[16];                // Почтовый код адреса
	link   City CityID;            //
	double Latitude;               // Географическая широта
	double Longitude;              // Географическая долгота
	string Text[128];              // Строка короткого адреса (без города и индекса)
	string Addr[128];              // @todo must be [256] Синтезированная строка полного адреса
	string Phone[48];              // Телефон (специализированное поле)
	string Contact[64];            // Наименование контакта, ассоциированное с адресом
	//
	// Descr: Возвращает текст дополнительного поля адреса по идентификатору
	//   поля addedStringId.
	//
	string GetAddedString[64](long addedStringId);
	//
	// Descr: Возвращает длинную строку адреса.
	// Note: Функция введена для того, чтобы избежать увеличения ширины поля Addr
	//   и следующей за этим верификации значительного числа отчетов.
	//
	string GetLongAddr[256]();
	//
	// Descr: Извлекает регистр с символом regCode из данной локации.
	//   Если у локации нет такого регистра и параметр inherit != 0, то предпринимается попытка извлечь такой регистр
	//   у персоналии-владельца данной локации.
	//
	link PersonRegister GetRegister(string regCode[20], int inherit);
	//
	// Descr: Извлекает регистр с символом regCode из данной локации. При этом учитывается актуальность
	//   регистра на дату dt. Если dt == 0, то функция работает аналогично GetRegister(string).
	//   Если у локации нет такого регистра и параметр inherit != 0, то предпринимается попытка извлеч такой регистр
	//   у персоналии-владельца данной локации.
	//
	link PersonRegister GetRegisterD(string regCode[20], date dt, int inherit);
	link ObjectTag GetTag(string tagSymb[20]);
}
//
// Виды персоналий
// @uhtt
//
data PersonKind {
	key    ID;                     // @id
	string Name[48];               // @name
	string Code[20];               //
}
//
// Персональная регистрация //
//
data CheckInPerson {
	key    ID;              // Идентификатор ассоциации. В пределах одного раздела БД строка идентифицируется 'тим полем.
	long   Kind;            // Вид ассоциации. 25 - ассоциация TSession->Person
	long   PrmrID;          // Идентификатор первичного объекта, для которого фиксируется регистрация (например, PPObjTSession)
	link   Person PersonID; // Персоналия //
	link   SCard  SCardID;  // Карта, с которой ассоциирована зерегистрированная персоналия //
	link   CCheck CCheckID; // Кассовый чек, которым оплачено подтверждение регистрации
	long   Num;             // Номер записи в однородном списке относительно заданного первичного объекта
	int16  RegCount;        // Количество персоналий, включенное в данную регистрацию. Как правило =1,
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	int16  CiCount;         // Количество персоналий, включенное в данную регистрацию со статусом CheckedIn. Как правило =(0|1),
		// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
	long   Flags;           // @flags
	date   RegDt;           // Дата регистрации //
	time   RegTm;           // Время регистрации //
	date   CiDt;            // Дата подтверждения регистрации (CheckID)
	time   CiTm;            // Время подтверждения регистрации (CheckID)
	double Amount;          // Сумма, уплаченная или которая должна быть уплачена за регистрацию (подтверждение)
}
//
// Значения типов данных тегов объектов
//
// OTTYP_BOOL          1 // Логическое значение
// OTTYP_STRING        2 // Строка
// OTTYP_NUMBER        3 // double
// OTTYP_ENUM          4 // Перечисление (PPObjectTag::TagEnumID)
// OTTYP_INT           5 // long
// OTTYP_OBJLINK       6 // Ссылка на объект (PPObjectTag::TagEnumID)
// OTTYP_DATE          7 // LDATE
//
data TagType {
	key    ID;                     // @id
	long   TagDataType;            // OTTYP_XXX
	long   Flags;                  // OTF_XXX
	link   DataObject TagEnumID;   // Тип ссылочного объекта
	long   LinkObjGrp;             // Дополнительный параметр для ссылочного объекта
	link   DataObject ObjTypeID;   // Тип объекта, для которого определен тег
	long   TagGroupID;             // Группа, к которой относится тег
	string Name[48];               // Наименование тега
	string Symb[20];               // @symb
}
//
// Значение тега объекта.
// Эта запись идентифицируется суррогатным ключом, создаваемым
// при обращении к функции извлечения события из других структур.
//
data ObjectTag {
	key    SurID;
	link   DataObject ObjTypeID;
	long   ObjID;
	link   TagType    TagID;
	long   TagByObj;       // [ObjType, ObjID, TagID] Make keys unique
	long   IntVal;         //
	double RealVal;        //
	date   DateVal;        //
	string StrVal[128];    //
	//
	// Descr: Возвращает строковое представление значения тега.
	//
	string GetStr[128]();
}
//
// Юридический статус персоналии
//
data PersonStatus {
	key    ID;
	string Name[48];
}
//
// Категория персоналии
// @uhtt
//
data PersonCat {
	declare "Set"
	key    ID;                     // @id
	string Name[48];               // @name
	string Code[20];               //
}
//
// Банковский счет
//
data BankAccount {
	key    ID;                     // @id
	link   Person PersonID;        // ИД владельца
	link   Person BankID;          // ИД банка
	long   AccType;                // Тип счета
	long   Flags;                  // @flags
	int16  fPreferable;            // Признак предпочтительного счета
	int16  Reserve;                // @alignment
	string Code[32];               // Номер счета
}
//
// Персоналии
//
data PersonReq;

data Person {
	key    ID;                     // @id
	link   PersonReq ReqID;        // Ссылка на структуру PersonReq, соответствующую этой персоналии
	link   Location LocID;         // Адрес (юридический)
	link   Location RLocID;        // Фактический адрес
	link   PersonStatus Status;    // для PersonList нужен Status.Name
	link   PersonCat Category;     // Категория персоналии
	link   PersonRegister TradeLicID; // Регистр торговой лицензии
	string Name[128];              // Наименование персоналии
	string Memo[128];              // Примечание
	string Passport[48];           // Текстовое представление паспортных данных
	long   Flags;                  //
	int16  fNativeLand;            // Признак того, что персоналия является государством
		// которое является родным для главной организации
	int16  fHasImage;              // Запись имеет изображение
	int16  fNoVat;                 // Персоналия освобождена от уплаты НДС
	int16  fReserve;               // @reserve
	Address = LocID.Addr;          // Текст юридического адреса
	RAddr   = RLocID.Addr;         // Текст фактического адреса

	link PersonRegister GetRegister(string regCode[20]);
	link PersonRegister GetRegisterD(string regCode[20], date dt);
	//
	// Descr: Возвращает ссылку на банковский счет персоналии. Если параметр
	//   bankID не нулевой, то возвращается первый счет или предпочтительный счет,
	//   открытый в банке с ИД=bankID.
	//   Если bankID == 0, то возвращается предпочтительный счет, либо (если предпочтительного нет)
	//   первый расчетный счет из списка.
	//
	link BankAccount    GetBankAccount(long bankID);
	string GetTagStr[48](string tagSymb[20]);
	long   GetTagInt(string tagSymb[20]);
	double GetTagReal(string tagSymb[20]);
	date   GetTagDate(string tagSymb[20]);
	link   ObjectTag GetTag(string tagSymb[20]);
	//
	// Descr: Возвращает ссылку на аналитическую статью, связанную с данной персоналией
	//   посредством таблицы статей accSheetID.
	//
	link   Article GetArticle(long accSheetID);
	//
	// Descr: Возвращает ссылку на персоналию, с которой у данной персоналии установлено отношение
	//   с типом, определяемым символом relSymb.
	// Note: Функция возвращает первую найденную персоналию, соответствующую заданному критерию,
	//   однако, может существовать более одной персоналии, с которыми у данной установлено отношение
	//   одного типа.
	//
	link   Person  GetSingleRelation(string relSymb[20]);
	//
	// Descr: Возвращает один email адрес персоналии. Если персоналия имеет более одного адреса,
	//   то возвращается только первый.
	//
	string GetSingleEmail[64](); //
	string FormatRegister[256](string regCode[20]); //
	string FormatRegisterD[256](string regCode[20], date dt); //
	string GetExtName[256](); //
}
//
// Реквизиты персоналии, необходимые для печати некоторых форм
//
data PersonReq {
	key    ID;                     // @id
	link   Person PersonID;        // Прямая ссылка на структуру Person
	link   Person BankID;          // Банк, к которому относится основной расчетный счет
	string Name[128];              // Наименование персоналии
	string ExtName[128];           // Расширенное наименование персоналии
	string Memo[128];              // Примечание
	string Passport[64];           // Строка паспортных данных
	string Address[128];           // Адрес (юридический)
	string RAddr[128];             // Фактический адрес
	string BankAccount[128];       // Строка банковского счета
	string BankCity[48];           // Наименование города банка
	string OKPO[32];               //
	string OKONF[32];              //
	string INN[32];                //
	string KPP[12];                // Код причины постановки на налоговый учет
	string Phone[32];              //
	link   RegisterType SrchRegTypeID; // Тип регистра для поиска. Если для персоналии не определено ни одного
		// поискового регистра, то SrchRegTypeID = 0 (даже если для какого-либо из видов, которому принадлежит
		// персоналии такой тип регистра определен).
	string SrchCode[32];           // Номер поискового регистра (тип этого регистра прописан в виде персоналии).
		// Если персоналия относится к нескольким видам, то тип поискового регистра берется из первого
		// встреченного вида, которому принадлежит персоналия и для которого определен тип поискового регистра.
	long   Flags;                  // @flags
	ExtName2 = (length(ExtName) == 0) ? Name : ExtName;
}

data AmountType;
//
// Штатный календарь
//
data StaffCal {
	key    ID;                     // @id
	string Name[30];               // Наименование. Для порожденных календарей (LinkCalID != 0) - пусто
	string Symb[18];               // Символ. Для порожденных календарей (LinkCalID != 0) - пусто
	link   DataObject LinkObjType; // Тип связанного объекта
	long   Flags;                  // @flags
	int16  fInherited;             // Календарь наследует элементы от родителя. То есть, такой календарь не может содержать собственных элементов.
	int16  Reserve;                // @alignment
	link   StaffCal   LinkCalID;   // ИД родительского календаря //
	long   LinkObjID;              // ИД связанного объекта
}
//
// Штатное начисление
//
data SalCharge {
	key    ID;                     // @id
	string Name[30];               // Наименование
	string Symb[10];               // Символ
	link   AmountType AmtID;       // ->Ref(PPOBJ_AMOUNTTYPE) Тип учетной суммы для этого начисления //
	link   StaffCal   CalID;       // ->Ref(PPOBJ_STAFFCAL)   Календарь, используемый для этого начисления //
	long   Flags;                  // @flags
	int16  fGroup;                 // Группа начислений (объединяет произвольный упорядоченный набор обыкновенных начислений)
	int16  Reserve;                // @alignment
	string Formula[128];           // Расчетная формула
}
//
// Штатная должность
//
data StaffNom {
	key    ID;                     // @id
	link   Person    OrgID;        // Работодатель
	link   Location  DivID;        // Подразделение
	link   SalCharge ChargeGrpID;  // Группа начислений, используемая для этой должности
	string Name[48];               // Наименование должности
	long   Rank;                   // Ранг должности (чем меньше величина, тем выше иерархическое положение)
	long   FixedStaff;             // Зарезервированный ИД должности (PPFIXSTF_XXX)
	long   Flags;                  // @flags
	int16  VacancyCount;           // Общее количество ставок
	int16  VacancyBusy;            // Занятое количество вакансий
}
//
// Штатное назначение
//
data PersonPost {
	key    ID;                     // @id
	string Code[16];               // Personal Code
	link   StaffNom  StaffID;      // ->StaffList.ID
	link   Person    PersonID;     // ->Person.ID
	date   Dt;                     // Дата приема в штат
	date   Finish;                 // Дата, когда персоналия PersonID оставила назначение
	link   SalCharge ChargeGrpID;  // Группа начислений, используемая для этого назначения.
		// Если 0, то используется StaffList(PostID).ChargeGrpID.
	long   Flags;                  // @flags
	int16  Closed;                 // Закрытое назначение (Finish != 0). Если персоналия через некоторое время //
		// снова вступает в должность, то для нее создается новая запись назначения. Если и после этого она
		// покидает должность, то значение Closed увеличивается на единицу по сравнению с предыдущим оставлением поста.
	int16  Reserve;                // @alignment
	long   PsnEventID;             // ->PersonEventID ИД персональной операции, которая сформировала это назначение. При изменении
		// персональной операции, вероятно, будет меняться и это назначение
}
//
// Сотрудник
//
data Employee {
	key    ID;                     // = PersonID
	link   Person     PersonID;    // Персонали
	link   PersonPost PsnPostID;   // Назначение
	string TabNum[32];             // Табельный номер
	EmplName = PersonID.Name;      // ФИО служащего
	DivName  = PsnPostID.StaffID.DivID.Name; // Наименование подразделения //
	PostName = PsnPostID.StaffID.Name;       // Наименование должности
}
//
// Склад
//
data Warehouse {
	key    ID;                     // Идентификатор склада
	link   Warehouse ParentID;     // Родительская группа склада
	link   Person RspnsPersonID;   // Ответственное лицо
	link   City CityID;            // Город адреса склада
	link   Location LocID;         // Искусственная ссылка, позволяющая ссылаться на структуру локации,
		// соответствующую данной структуре. Фактически, LocID == ID
	long   Flags;                  // @flags
	int16  fVatFree;               // Освобожден от НДС
	int16  fComparable;            // Сравниваемый магазин (магазин открыт более года назад)
	string Code[16];               // Код локации (внутренний символ для идентификации)
	string ZIP[16];                // Почтовый код адреса
	string Name[48];               // Наименование склада
	string Addr[128];              // Адрес склада
}
//
// Складская ячейка
//
data WhCell {
	key    ID;
	link   Warehouse ParentID;
	long   Flags;
	long   Layer;          // (@location_storey) Ярус ячейки (1 - самый нижний, 0 - не определен).
	long   MassCapacity;   // Максимальная вместимость по массе (г)
	long   X;              // Длина  (мм)
	long   Y;              // Ширина (мм)
	long   Z;              // Высота (мм)
	long   DisposeRestr;   // Флаги ограничений размещения //
	long   DisposeRestrCount; // Максимальное количество паллет (DisposeRestr & LOCDISPRESTR_PALLETCOUNT)
	string Code[16];
	string Name[48];
}
//
// Вид котировки
//
data QuotKind {
	key    ID;                     // @id
	link   OprKind OpID;           // Вид операции, к которой привязана котировка
	string Name[30];               // Наименование вида котировки
	int16  PadName;                // @alignment
	string Symb[20];               // Символ вида котировки
	double Discount;               // Скидка, предусмотренная котировкой
	int16  fAbsDiscount;           // Если !0, то Discount задана как суммовая величина, иначе - в процентном выражении
	int16  fPad;                   // @alignment
}
//
// Соглашение
//
data Agreement {
	key    ID;                     // @id
	link   Article  AgentID;       // Агент, закрепленный за клиентом/поставщиком
	link   Article  ExtObjectID;   // Дополнительный объект для документов по этому соглашению
	link   QuotKind QKindID;       // Вид котировки, закрепленный за клиентом
	string Code[24];               // Номер соглашения // @v10.4.2 [12]-->[24]
	date   BegDt;                  // Начало действия //
	date   Expiry;                 // Срок действия //
	double MaxCredit;              // Максимальный кредит
	double MaxDscnt;               // Максимальная скидка в %%
	double Dscnt;                  // Обычная скидка в %%
	int16  DefPayPeriod;           // Количество дней от отгрузки до оплаты по умолчанию
	int16  DefDlvrTerm;            // Срок доставки товара в днях, начиная с даты документа закупки
	int16  PctRet;                 // Максимальный объем возврата товара по накладной в процентах от суммы накладной
	int16  Reserve;                // @alignment
	string EDIPrvdrSymb[20];       //
}
//
// Статья аналитического учета
//
data Article {
	key    ID;                     // @id
	link   AccSheet   SheetID;     // Таблица статей
	link   DataObject LinkObjType; // == SheetID.LinkObjID
	link   PersonReq  PersonID;    // if LinkObjType == PPOBJ_PERSON(1004) then PersonID != 0
	link   Warehouse  WhID;        // if LinkObjType == PPOBJ_LOCATION(1010) then WhID != 0
	link   Agreement  AgrID;       // == ID
	long   Number;                 // Номер статьи (уникальный внутри таблицы)
	string Name[128];              // Наименование
	int16  Group;                  // Группирующая статья //
	int16  Closed;                 // Статья закрыта
	int16  Stop;                   // Статья имеет признак "Стоп" (отгрузка запрещена)
	int16  Reserve;                // @alignment
	//
	// Descr: Возвращает ссылку на долговую размерность, с которой связана данная статья (только для статей агентов)
	//
	link   DebtDim GetDebtDim();
}
//
// @v10.4.2 Verification needed (из-за изменения длины поля Agreement.Code)
//
data ArticleView {
	declare "Destroy"
	declare "DOSSTUB"
	link   Global     Glb;
	string FltAccSheetName[48];
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	iteration {
		link Article ArticleID;
		ID  = ArticleID.ID;
		Number      = ArticleID.Number;
		Name        = ArticleID.Name;
		Closed      = ArticleID.Closed;             // Статья закрыта
		Stop        = ArticleID.Stop;               // Статья имеет признак "Стоп" (отгрузка запрещена)

		Agent       = ArticleID.AgrID.AgentID.Name; // Агент, закрепленный за клиентом/поставщиком
		QuotKind    = ArticleID.AgrID.QKindID.Name; // Вид котировки, закрепленный за клиентом
		AgrCode     = ArticleID.AgrID.Code;         // Номер соглашения //
		BegDate     = ArticleID.AgrID.BegDt;        // Начало действия //
		Expiry      = ArticleID.AgrID.Expiry;       // Срок действия //
		MaxCredit   = ArticleID.AgrID.MaxCredit;    // Максимальный кредит
		MaxDscnt    = ArticleID.AgrID.MaxDscnt;     // Максимальная скидка в %%
		Dscnt       = ArticleID.AgrID.Dscnt;        // Обычная скидка в %%
		PayPeriod   = ArticleID.AgrID.DefPayPeriod; // Количество дней от отгрузки до оплаты по умолчанию
		DlvrTerm    = ArticleID.AgrID.DefDlvrTerm;  // Срок доставки товара в днях, начиная с даты документа закупки
		PctRet      = ArticleID.AgrID.PctRet;       // Максимальный объем возврата товара по накладной в процентах от суммы накладной
	}
}
//
// Серия пластиковых карт
//
data SCardSeries {
	key    ID;                     // @id
	string Name[48];               // @name
	double PDis;                   // Discount (percents)
	double Overdraft;              // Maximum credit overdraft (for credit cards)
	date   IssueDate;              // Дата выпуска
	date   Expiry;                 // Дата окончания срока действия //
	long   Flags;                  // @flags
	int16  fCredit;                // Credit card
	int16  Reserve2;               // @alignment
}
//
// Персональная карта
//
data Goods;

data SCard {
	declare "Set"
	key    ID;                     // @id
	link   SCardSeries SeriesID;   // Ссылка на серию карт
	link   PersonReq OwnerReqID;   // Ссылка на владельца карты
	link   Goods     AutoGoodsID;  // Товар для автоматического включения в чек
	string Code[24];               // Номер карты
	string Hash[12];               // Хэш
	string Phone[24];              // @v10.1.3
	date   IssueDate;              // Дата выпуска
	date   Expiry;                 // Дата окончания срока действия //
	time   UsageTmStart;           //
	time   UsageTmEnd;             //
	string UsageTmStr[16];         // Строковое представление ограничения времени использования (hh:mm)
	int16  PeriodTerm;             // Тип периода длительности срока действия [1; 7; 30; 90; 180; 360] //
	int16  PeriodCount;            // Количество периодов длительности срока действия //
	double PDis;                   // Discount (percents)
	double Overdraft;              // Maximum credit overdraft (for credit cards)
	double Debit;                  // Приходы по карте (для кредитных карт)
	double Credit;                 // Расходы (покупки) по карте
	double Rest;                   // Остаток
	long   Flags;                  // @flags
	int16  fCredit;                // Кредитная карта
	int16  fClosed;                // Закрытая карта
	int16  fInherited;             // Карта наследует IssueDate, Expiry, PDis, Overdraft от серии
	int16  fNoGift;                // При использовании карты в кассовой панели, подарки предоставляться не будут
	int16  fNeedActivation;        // Карта требует активации
	int16  fAutoActivation;        // Карта, требующая активации, активируется автоматически при первом использовании.
	string Memo[128];              // @v10.1.3 Примечание к карте

	link   SysJournalEntry GetCreationEvent();   // Возвращает ссылку на запись системного журнала, соответствующую созданию карты.
	link   SysJournalEntry GetActivationEvent(); // Возвращает ссылку на запись системного журнала, соответствующую активации карты.
}
//
// Транспорт
//
data Transport {
	key    ID;                     // @id
	long   TrType;                 // 1 - Автомобиль, 2 - Судно
	double Capacity;               // Грузоподъемность, кг
	string Name[64];               // @name
	string Code[16];               // Номер транспортного средства
	string TrailerCode[16];        // Номер прицепа (для автотранспорта)
	string ModelName[48];          // Наименование модели транспорта
	link   Person  OwnerID;        // Владелец транспорта
	link   Country CountryID;      // Страна, которой принадлежит транспорт
	link   Person  CaptainID;      // Командир (водитель/капитан) транспорта
	link   ObjectTag GetTag(string tagSymb[20]); // @v11.3.7
}
//
// Торговая марка
//
data GoodsGroup;

data Brand {
	declare "Set"
	key    ID;                     // @id
	string Name[64];               // @name
	string Code[20];               // @reserve Код
	link   Person OwnerID;         // Владелец торговой марки
	link   GoodsGroup GoodsGrpID;  // @reserve Товарная группа, к которой относится брэнд
	link   ObjectTag GetTag(string tagSymb[20]); // @v11.3.7
}
//
// Статус документа
//
data BillStatus {
	key    ID;                     // @id
	string Name[20];               // @name
	string Symb[16];               // @symb
	long   Flags;                  // Флаги
	long   CheckFields;            // Флаги проверяемых полей
	long   Rank;                   // Ранг статуса
	link   OpCounter OpCntrID;     // Счетчик, на который переключатся нумерация документа при установке этого статуса
	link   OprKind   RestrictOpID; // Вид операции (возможно, обобщенный) для которого допустим данный статус
}
//
// Долговая размерность
//
data DebtDim {
	key    ID;
	string Name[48];
	string Symb[20];
}
//
// Документ
//
data Bill {
	key    ID;
	link   Article    ArticleID;
	link   Article    Object2ID;
	link   Warehouse  LocID;
	link   OprKind    OprKindID;
	link   Currency   CurID;
	link   BillStatus StatusID;    // Статус документа
	link   Bill       LinkBillID;  // ИД связанного документа
	link   User       UserID;      // Пользователь, создавший документ
	date   Dt;                     //
	string Code[24];               //
	string Memo[128];              //
	long   Flags;                  // BILLF_XXX
	int16  fNeedPayment;           // Требует платежного документа
	int16  fPayout;                // Оплачен
	int16  fWL;                    // WL-метка
	int16  Pad1;                   // @alignment
	date   DueDate;                // Срок исполнения (заказа, заявки поставщику и т.д.)
	double Amount;                 // Bill.Amount
	double CostSum;                // PPAMT_BUYING
	double PriceSum;               // PPAMT_SELLING
	double Discount;               // PPAMT_DISCOUNT
	double GenCostSum;             // PPAMT_BUYING   + replaced amount from GoodsType
	double GenPriceSum;            // PPAMT_SELLING  + replaced amount from GoodsType
	double GenDiscount;            // PPAMT_DISCOUNT + replaced amount from GoodsType
	double ManPctDscnt;            // Manual percent discount on bill
	double ManAbsDscnt;            // Manual absolute discount on bill
	double Payment;                // PPAMT_PAYMENT
	double Debt;                   // Bill.Amount - PPAMT_PAYMENT
	double CVat;                   // PPAMT_CVAT
	double PVat;                   // PPAMT_PVAT
	double SalesTax;               // PPAMT_SALESTAX
	double Excise;                 // PPAMT_EXCISE
	//
	// Налоговые суммы НДС (ставка и сумма)
	//
	double Vat1Rate;
	double Vat1Sum;
	double Vat2Rate;
	double Vat2Sum;
	date   LastPayDate;            // Срок последней оплаты
	//
	// Расширение
	//
	link   Article PayerID;        // ИД плательщика
	link   Article AgentID;        // ИД торгового агента
	link   QuotKind ExtPriceQkID;  // ИД вида котировки, по которому
		// рассчитывается дополнительная печатаемая цена в накладной
	string InvoiceCode[24];        // Номер счета-фактуры
	date   InvoiceDate;            // Дата счета-фактуры
	string PaymBillCode[10];       // Номер платежно-расчетного документа (для инвойсов)
	int16  Pad2;                   // @alignment
	date   PaymBillDate;           // Дата  платежно-расчетного документа (для инвойсов)
	//
	// Данные о фрахте
	//
	string FreightCode[20];        // Номер фрахта
	link   Transport TranspID;     // ИД транспорта
	link   Person  CaptainID;      // Капитан судна (водитель автомобиля)
	link   Person  Captain2ID;     // 2-й капитан судна (водитель автомобиля)
	link   Person  VesselsAgentID; // Транспортный брокер
	link   City    PortOfLoading;  // Порт погрузки
	link   City    PortOfDschrg;   // Порт разгрузки
	link   Location DlvrLocID;     // Адрес доставки
	date   IssueDate;              // Дата отплытия (отправления)
	date   ArrivalDate;            // Дата прибытия в пункт назначения //
	int16  NmbOrigsBsL;            // Number Of Original Bs/L
	int16  Pad3;                   // @alignment
	//
	// Рента
	//
	date   RcStart;                // Начало периода действия ренты
	date   RcFinish;               // Окончание периода действия ренты
	long   RcFlags;
	int16  fRcPctCharge;           // Процентные начисления по ренте
	int16  fRcClosed;              // Закрытый договор ренты
	int16  RcCycle;                // Цикличность начисления по ренте (0, 1, 7, 30, 90, 180, 360)
	int16  RcDayOffs;              // Смещение даты начисления (в днях)
	double RcPercent;              // Процент (годовой)
	double RcPartAmount;           // Частичная сумма начисления (на каждый период) //
	string RcCycleText[16];        // Текст наименования цикла (RcCycle)
	string GetMemo[512]();         // Возвращает примечание к документу полной длины
	double GetAmount(string amountTypeSymb[20]); // Возвращает сумму документа, принадлежащую типу с символом amountTypeSymb.
	//
	// Возвращает общее количество торговых единиц по всем строка товарного документа с учетом знака.
	//   Если sign > 0, то возвращает сумму только приходных строк,
	//   если sign < 0, то возвращает сумму только расходных строк,
	//   если sign == 0, то возвращает простую сумму по всем строкам.
	// Замечание по производительности: при выполнении функция полностью извлекает пакет документа
	//   из базы данных.
	//
	double GetTotalTrfrQtty(int sign);
	//
	// Возвращает количество товарных строк документа.
	// Замечание по производительности: при выполнении функция полностью извлекает пакет документа
	//   из базы данных.
	//
	long   GetTotalTrfrLines();
	link   Bill GetLastPaymBill(); // Возвращает ИД последнего документа оплаты.
	link   Bill GetReckonBill();   // Возвращает ИД зачетного документа, который зачитывается данным документом
	link   Bill GetOrderBillSingle(); // Возвращает ИД один из документов заказа, к которому привязан данный документ.
		// Если данный документ отгружает по нескольким документам заказа, то функция вернет ИД только одого из них.
	link   SysJournalEntry GetCreationEvent(); // Возвращает ссылку на запись системного журнала,
		// соответствующую созданию документа.
	link   ObjectTag GetTag(string tagSymb[20]);
	//
	// Возвращает строку, идентфицирующую документ как UED-объект.
	// Строка представляет собой 8-байтовый идентфикатор (meta UED_META_PRV_DOC) в виде 16-ной строки (буквы в верхнем регистре).
	//
	string GetUedIdent[20](); // @v12.2.10
}
//
// Descr: Пул документов
// Note: Эта структура в общем случае инициализируется двумя параметрами:
//   1. Идентификатором типа ассоциации
//   2. Идентификатором объекта-владельца пула
//   В связи с этим прямая ссылка на эту структуру из других структур (пока) невозможна.
//
data TSession;
data CSession;

data BillPool {
	key    ID;                     // @id
	int32  Kind;                   // Вид пула:
		// bpkReckon    = 1,       // Зачитывающие документы
		// bpkCSess     = 2,       // Документы списания кассовой сессии
		// bpkTSess     = 3,       // Документы списания технологической сессии
		// bpkCSessDfct = 4,       // Документы покрытия дефицита по кассовым сессиям
		// bpkTSessDfct = 5        // Документы покрытия дефицита по технологическим сессиям
	int32  AssocType;              // Inner: Идентификатор типа ассоциации пула
	link   Bill BillID;            // Заголовочный документа пула. Может быть 0 (если пул построен
		// по техн сессии либо кассовой сессии).
	link   TSession TSessID;       // Если пул принадлежит техн сессии, то !0
	link   CSession CSessID;       // Если пул принадлежит кассовой сессии, то !0

	link   Bill GetMemberByOp(string opSymb[20]); // Возвращает первый документ в пуле,
		// имеющий вид операции с символом opSymb

	iteration {
		long   Num;                // Порядковый номер членства в пуле
		link   Bill InnerBillID;
	}
}
//
// Суммы документов
//
data AmountType {
	key    ID;
	string Name[48];
	string Symb[20];
	long   Flags;
	long   Tax;
	long   TaxRate;
}
//
// Единица измерения //
//
data Unit {
	key    ID;
	string Name[24];
	string Abbr[20];
	string Code[12];
}
//
// Тип товаров
//
data GoodsType {
	key    ID;
	string Name[48];
	link   AmountType CVatAmtID;
	link   AmountType CostAmtID;
	link   AmountType PriceAmtID;
	link   AmountType DscntAmtID;
	long   Flags;
	int16  fUnlimited;      // GTF_UNLIMITED      Неограниченный ресурс
	int16  fRplcCost;       // GTF_RPLC_COST      Заменить станд сумму поступления //
	int16  fRplcPrice;      // GTF_RPLC_PRICE     Заменить станд сумму реализации
	int16  fRplcDscnt;      // GTF_RPLC_DSCNT     Заменить станд сумму скидки
	int16  fPriceInclDis;   // GTF_PRICEINCLDIS   Сумма реализации включает скидку
	int16  fExclAmount;     // GTF_EXCLAMOUNT     Не включать в номинальную сумму документа
	int16  fAutoCompl;      // GTF_AUTOCOMPL      Автокомплектация //
	int16  fAllowZeroPrice; // GTF_ALLOWZEROPRICE Допускается нулевая цена реализации
	int16  fAsset;          // GTF_ASSETS         Основные фонды
	int16  fPad;            // @alignment
}
//
// Товарная налоговая группа
//
data GoodsTaxGrp {
	key    ID;                     // @id
	string Name[30];               // @name
	int16  PadName;                // @alignment
	double VAT;                    // Ставка НДС
	double Excise;                 // Ставка акциза
	double SalesTax;               // Ставка налога с продаж
	string OrderStr[16];           // Строка порядка расчета
	int16  fAbsExcise;             // Акциз задан в абсолютном выражении
	int16  PadFlags;               // @alignment
}
//
// Класс товаров
//
data GoodsClass {
	key    ID;                          //
	string Name[48];                    // Наименование класса
	long   DefGrpID;                    // Группа товаров по умолчанию
	string DefGrpName[64];              // Наименование группы по умолчанию (группа определена ниже - ссылка невозможна)
	link   Unit DefUnitID;              // Торговая единица измерения по умолчанию
	link   Unit DefPhUnitID;            // Физическая единица измерения по умолчанию
	link   GoodsTaxGrp DefTaxGrpID;     // Налоговая группа по умолчанию
	link   GoodsType   DefGoodsTypeID;  // Тип товара по умолчанию
	long   Flags;                       // Флаги
	long   DynGenMask;                  // Маска динамического обобщения //
	//
	// Параметры свойства Kind
	//
	string PropKindNam[32];             // Наименование свойства
	long   PropKindObj;                 // Объект перечисления свойства
	string PropKindObjN[32];            // Наименование объекта перечисления свойства
	//
	// Параметры свойства Grade
	//
	string PropGradNam[32];
	long   PropGradObj;
	string PropGradObjN[32];
	//
	// Параметры свойства Add
	//
	string PropAddNam[32];
	long   PropAddObj;
	string PropAddObjN[32];
	//
	// Параметры размерности X
	//
	string DimXName[32];
	int16  DimXScale;
	int16  PadDimX;                     // @alignment
	string DimXValues[48];
	//
	// Параметры размерности Y
	//
	string DimYName[32];
	int16  DimYScale;
	int16  PadDimY;                     // @alignment
	string DimYValues[48];
	//
	// Параметры размерности Z
	//
	string DimZName[32];
	int16  DimZScale;
	int16  PadDimZ;                     // @alignment
	string DimZValues[48];

	string NameConv[64];                // Формула, по которой формируется наименование товара
	string PhUPerU_Form[48];            // Формула, по которой формируется соотношение физических единиц к торговым
	string TaxMult_Form[48];            // Формула, по которой формируется налоговый фактор
	string Package_Form[48];            // Формула, по которой формируется емкость упаковки поставки
}
//
// Список классов товаров
//
data GoodsClassView {
	declare "Destroy"
	declare "DOSSTUB"

	link Global     Glb;

	CurDt	= Glb.CurDate;
	OrgName = Glb.MainOrgName;

	iteration {
		link   GoodsClass GcID;
		Name  = GcID.Name;                 // Наименование класса
		DefGrpName    = GcID.DefGrpName;           // Группа товаров по умолчанию
		DefUnitName   = GcID.DefUnitID.Name;       // Торговая единица измерения по умолчанию
		DefPhUnitName = GcID.DefPhUnitID.Name;     // Физическая единица измерения по умолчанию
		DefTaxGrpName = GcID.DefTaxGrpID.Name;     // Налоговая группа по умолчанию
		DefTypeName   = GcID.DefGoodsTypeID.Name;  // Тип товара по умолчанию
		Flags = GcID.Flags;                // Флаги
		DynGenMask    = GcID.DynGenMask;           // Маска динамического обобщения //
		//
		// Параметры свойства Kind
		//
		PropKindNam   = GcID.PropKindNam;          // Наименование свойства
		PropKindObj   = GcID.PropKindObj;          // Объект перечисления свойства
		PropKindObjN  = GcID.PropKindObjN;         // Наименование объекта перечисления свойства
		//
		// Параметры свойства Grade
		//
		PropGradNam   = GcID.PropGradNam;
		PropGradObj   = GcID.PropGradObj;
		PropGradObjN  = GcID.PropGradObjN;
		//
		// Параметры свойства Add
		//
		PropAddNam    = GcID.PropAddNam;
		PropAddObj    = GcID.PropAddObj;
		PropAddObjN   = GcID.PropAddObjN;
		//
		// Параметры размерности X
		//
		DimXName      = GcID.DimXName;
		DimXScale     = GcID.DimXScale;
		DimXValues    = GcID.DimXValues;
		//
		// Параметры размерности Y
		//
		DimYName      = GcID.DimYName;
		DimYScale     = GcID.DimYScale;
		DimYValues    = GcID.DimYValues;
		//
		// Параметры размерности Z
		//
		DimZName      = GcID.DimZName;
		DimZScale     = GcID.DimZScale;
		DimZValues    = GcID.DimZValues;

		NameConv      = GcID.NameConv;                // Формула, по которой формируется наименование товара
		PhUPerU_Form  = GcID.PhUPerU_Form;            // Формула, по которой формируется соотношение физических единиц к торговым
		TaxMult_Form  = GcID.TaxMult_Form;            // Формула, по которой формируется налоговый фактор
		Package_Form  = GcID.Package_Form;            // Формула, по которой формируется емкость упаковки поставки
	}
}
//
// Группа списания основных фондов
//
data AssetWrOffGrp {
	key    ID;
	string Name[30];
	string Code[14];
	int32  WrOffType;
	int32  WrOffTerm; // Срок полного списания (months)
	long   Flags;
}
//
// Группа товаров
//
data GoodsGroup {
	key    ID;                   // Идентификатор
	link   Unit        UnitID;   // Торговая единица измерения (наследуется товарами) //
	link   Unit        PhUnitID; // Физическая единица измерения (наследуется товарами) //
	link   GoodsType   TypeID;   // Товарный тип
	link   GoodsTaxGrp TaxGrpID; // Налоговая группа
	link   GoodsGroup  ParentID; // Родительская группа
	link   GoodsClass  ClsID;    // Класс товаров
	long   Flags;                //
	string Code[24];             // Код группы
	string Name[64];             //
	string FullName[128];        // Наименование группы, включающее все группы, в которые вложена эта

	link   GoodsFilt GetFilt();
	string GetFullName[512](); // @v10.2.0
}
//
// Поставщики товара за последние 3 месяца
//
data SupplNameList {
	key    ID;              // ID товара
	string SupplNames[128]; // Список наименований поставщиков
}
//
// Товар
//
data Lot;

data Goods {
	key    ID;
	link   Unit          UnitID;       // Торговая единица измерения   //
	link   Unit          PhUnitID;     // Физическае единица измерения //
	link   GoodsGroup    GroupID;      // Непосредственная родительская группа
	link   GoodsType     TypeID;       // Тип товара
	link   GoodsClass    ClsID;        // Класс товара
	link   Person        ManufID;      // Производитель
	link   GoodsTaxGrp   TaxGrpID;     // Налоговая группа
	link   AssetWrOffGrp WrOffGrpID;   // Группа списания основных фондов
	link   Brand         BrandID;      // Торговая марка
	link   SupplNameList Snl;          // Поставщики данного товара за x последних месяцев
	long   Flags;                      //
	int    Kind;                       // Вид записи.
		// Не смотря на то, что для большинства из видов записей есть специальные структуры,
		// иногда ссылка, указывая якобы на товар (Kind=2), в действительно ссылается на запись
		// иного вида:
		//
		// 1 Группа товаров
		// 2 Товар
		// 3 Тип пакета
		// 4 Транспортное средство
		// 5 Бренд
		// 6 Группа брендов
		// 7 Составной товар
		//
	double PhPerUnit;                  // Соотношение физических единиц к торговым

	double Brutto;                     // Масса брутто одной единицы товара, кг
	long   Length;                     // Габаритная длина упаковки поставки,  мм
	long   Width;                      // Габаритная ширина упаковки поставки, мм
	long   Height;                     // Габаритная высота упаковки поставки, мм
	double MinStock;                   // Минимальный запас товара
	double Package;                    // Емкость упаковки поставки (торговых единиц)
	int16  ExpiryPeriod;               // Срок годности товара (дней).
	int16  GseFlags;                   // Флаги параметров хранения и отгрузки товара.
		// 0x0001 - MinShippmQtty одновременно определяет кратность отгужаемого количества
	double MinShippmQtty;              // Минимальное допустимое количество для отгрузки
	string Name[128];                  //
	string SingleBarCode[16];          //
	string Storage[128];               // Условия хранения товара
	string Standard[48];               // Стандарт или тех условия изготовления товара
	string Ingred[128];                // Ингредиенты
	string Energy[128];                // Энергетическая ценность
	string Usage[128];                 // Способ использования (приготовления)
	string LabelName[64];              // Наименование для печати ценника
	string OKOF[24];                   // Код ОКОФ для основных средств
	//
	// Поля из расширенной записи
	//
	double DimX;                       // Размерность X
	double DimY;                       // Размерность Y
	double DimZ;                       // Размерность Z
	double DimW;                       // Размерность W
	long   KindID;                     //
	string KindText[48];               //
	long   GradeID;                    //
	string GradeText[48];              //
	long   AddObjID;                   //
	string AddObjText[48];             //
	long   AddObj2ID;                  //
	string AddObj2Text[48];            //
	//
	// Descr: Возвращает артикул товара, соответствующий статье arID
	//
	string GetArCode[16](long arID);
	//
	// Descr: Возвращает сокращенное наименование товара (Goods2.Abbr)
	//
	string GetAbbr[128]();
	//
	// Descr: Возвращает идентификатор последнего лота по складу locID.
	//   Если locID = 0, то возвращает ид последнего лота по любому из складов.
	//
	link   Lot GetLastLot(long locID);
	//
	// Descr: Возвращает идентификатор последнего лота по складу locID на дату dt.
	//   Если locID = 0, то возвращает ид последнего лота по любому из складов.
	//
	link   Lot GetLastLotForDate(long locID, date dt);
	//
	// Descr: Возвращает среднюю себестоимость товара на дату dt по складу locID.
	//   Если serial не пустой, то ограничивает выборку лотов для расчета себестоимости
	//   только теми, которые имеют этот серийный номер (чаще всего это - единственный лот).
	//
	double GetAverageCost(date dt, long locID, string serial);
	//
	// Descr: Возвращает значение товарной котировки вида quotKindSymb
	//   по складу locID статье arID и для валюты curID.
	//
	double GetQuot(string quotKindSymb[20], long locID, long arID, long curID);
	//
	// Descr: Возвращает идентификатор одной из непересекающихся альтернативных
	//   товарных групп, которой принадлежит товар и которая, в свою очередь,
	//   принадлежит группе-папке с кодом exclAltFolerCode.
	//   Эта группа-папка должна иметь признак "Непересекающиеся альтернативные группы".
	//   Если искомой группы нет, то возвращает 0.
	//
	link   GoodsGroup GetExclAltGroupMembership(string exclAltFolerCode);
	//
	// Descr: Возвращает одну из дополнительных строк товара согласно символу symb.
	//   Символом может быть одна из следующих строк (однобуквенных):
	//   "A", "B", "C", "D", "E".
	//   Данная функция почти дублирует функционал полей Storage (A), Standard (B), Ingred (C), Energy (D), Usage (E)
	//   с тем нюансом, что максимальная длина результата может быть 511 символов.
	//
	string GetAddedText[512](string symb[8]);
	//
	// Descr: Возвращает минимальный страховочный остаток товара для склада locID.
	//
	double GetMinStock(long locID);
	//
	// Descr: Возвращает тег товара по символу tagSymb
	//
	link   ObjectTag GetTag(string tagSymb[20]);
	//
	// Descr: Возвращает наименование (код, аббревиатуру) страны производителя товара.
	//   Если параметр textKind == 0, тогда возвращает наименование,
	//   если textKind == 1 - аббревиатуру,
	//   если textKind == 2 - цифровой код,
	//   для остальных значений - наименование
	//
	string GetManufCountryText[48](int textKind);
	//
	// Descr: Возвращает список штрих кодов через разделитель
	//
	string GetBarcodeList[2048](string delim[8]);
	string GetSingleEgaisCode[24]();
	//
	// Descr: Возвращает путь к файлу с изображением товара.
	// ARG(rel): Если не 0, то возвращается путь, относительный к каталогу, в который выгружается основная порция данных.
	//   В противном случае возвращается абсолютный путь.
	// ARG(stub): Путь к файлу, замещающему отсутствующее у данного товава изображение.
	//
	string GetImagePath[256](int rel, string stub[256]);
	//
	// Descr: Возвращает номер, идентифицирующий товар внутри альтернативной группы altGroupID.
	//   Если товар не принадлежит группе algGroupID или эта группа не является альтернативной(не динамической),
	//   то возвращает 0.
	//
	long   GetCodeInAltGroup(long altGroupID);
	//
	//
	//
	double GetExtDim(int dimId);
	int    GetExtDimI(int dimId);
	string GetExtProp[128](int propId);
}
//
//
//
data GoodsFilt {
	key    SurID;                 // Суррогатный ключ, имеющий силу только внутри одного сеанса системы
	link   QuotKind  RestrictQuotKindID; // Вид ограничивающей котировки (извлекаются только те товары, которые имеют котировку этого вида)
	link   Warehouse MtxLocID; // Если (Flags & (fRestrictByMatrix|fOutOfMatrix)), то данное поле
		// определяет склад, по которому проверяется принадлежность (не принадлежность) матрице.
		// Если (Flags & (fRestrictByMatrix|fOutOfMatrix)) и MtxLocID == 0, то принадлежность (не принадлежность) матрице
		// проверяется относительно склада LocID_.
	link   Person    BrandOwnerID; //
	link   Article   CodeArID;     // Статья, по которой фильтровать коды, связанные со статьями
	link   GoodsGroup GrpID;       //
	link   Brand      BrandID_; // Товарный брэнд
	link   Person    ManufID;      //
	link   Country   ManufCountryID; //
	link   Unit      UnitID;      //
	link   Unit      PhUnitID;    //
	link   Article   SupplID;     //
	link   GoodsType GoodsTypeID; //
	link   GoodsTaxGrp TaxGrpID;  //
	link   Warehouse LocID_;      //
	link   UhttStore UhttStoreID; // Магазин Universe-HTT в контексте которого извлекаются товары.
	date   LotPeriodLow;       //
	date   LotPeriodUpp;       //
	long   Flags;              //
	long   InitOrder;          //
	long   VatRate;            // Ставка НДС, которой облагается товар. Ненулевое значение этого поля исключает фильтрацию по полю TaxGrpID.
	date   VatDate;            // Дата, на которую следует брать ставку НДС. Используется только если VatRate != 0
	string  SrchName[128];
	string  SrchBarcode[128];
	string  BarcodeLen[32];
}
//
// Сертификат качества
//
data QualityCert {
	key    ID;
	link   Person     PersonID;
	string Code[26];
	int16  Pad1;            // @alignment
	string Blank[16];
	string InnerCode[10];   // Внутренний код сертификата
	int16  Pad2;            // @alignment
	string GoodsName[48];   // Не зависит от поля Name таблицы Goods2
	string ManufName[30];
	int16  Pad3;            // @alignment
	string ProduceDate[20];
	int16  Passive;         // Признак пассивности (сертификат не виден в списках выбора)
	int16  Pad4;            // @alignment
	date   InitDate;
	date   Expiry;
	string Etc[32];
	RegOrgan = PersonID.Name;
}
//
// Лот
//
data Lot {
	key    ID;
	link   Goods     GoodsID;
	link   Warehouse LocID;
	link   Article   SupplID;
	link   Bill      BillID;
	link   QualityCert QCertID;
	link   GoodsTaxGrp InTaxGrpID;
	date   Dt;
	date   CloseDt;
	date   Expiry;
	int16  Closed;
	int16  Pad1;         // @alignment
	long   Flags;        // LOTF_XXX
	double UnitPerPack;
	double Qtty;
	double Rest;
	double Cost;
	double Price;
	string Serial[28];
	string CLB[28];

	link   Lot GetOrgLotID(); // Возвращает оригинальный лот. Если данный лот не имеет предков, то
		// возвращается ID.
	link   ObjectTag GetTag(string tagSymb[20]);
	link   ObjectTag GetTagByID(long tagID);
}
//
// Список товаров (PPViewGoods)
// @todo Длину StrucType необходимо увеличить (в т.ч. ради выравнивания)
//
data GoodsView {
	declare "Destroy"
	declare "DOSSTUB"

	link Global     Glb;
	link GoodsGroup FltGrpID;
	link Person     FltManufID;
	link Unit       FltUnitID;
	link Unit       FltPhUnitID;
	link GoodsType  FltGoodsTypeID;
	link Brand      FltBrandID;
	link GoodsTaxGrp FltTaxGrpID;

	CurDt	= Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltGrpName    = FltGrpID.Name;
	FltManufName  = FltManufID.Name;
	FltUnitName   = FltUnitID.Name;
	FltPhUnitName = FltPhUnitID.Name;

	iteration {
		link   Goods GoodsID;
		string BarCode[32];
		Name       = GoodsID.Name;
		ManufName  = GoodsID.ManufID.Name;
		UnitName   = GoodsID.UnitID.Name;
		PhUnitName = GoodsID.PhUnitID.Name;
		PhPerUnit  = GoodsID.PhPerUnit;
		GoodsGroup = GoodsID.GroupID.Name;
		GoodsType  = GoodsID.TypeID.Name;
		TaxGrpName = GoodsID.TaxGrpID.Name;
		BrandName  = GoodsID.BrandID.Name;             // Наименование торговой марки товара
		BrandOwnerName = GoodsID.BrandID.OwnerID.Name; // Наименование владельца торговой марки товара
		Brutto     = GoodsID.Brutto;
		Length     = GoodsID.Length;
		Width      = GoodsID.Width;
		Height     = GoodsID.Height;
		MinStock   = GoodsID.MinStock;
		Package    = GoodsID.Package;
		string StrucType[14];
	}
}
//
// Остатки товаров (PPViewGoodsRest)
// @v8.7.5 Verification needed
//
data GoodsRest {
	declare "Destroy"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;

	date   Dt;               // Дата, на которую рассчитаны остатки (ZERODATE - текущие остатки)
	date   FltPrgnBeg;       //
	date   FltPrgnEnd;       //
	long   PriceType;        // Тип цены для вывода
	long   InPacks;          // Остаток товара показан в упаковках

	long   Flags;
	int16  fNullRest;        // Включать товары с нулевыми остатками
	int16  fCalcOrder;       // Расчитывать заказанное количество
	int16  fGroupByGenGoods; // Группировать по обобщенным товарам
	int16  fNoZeroOrderOnly; // Только с ненулевыми остатками
	int16  fEachLocation;    // По каждому складу отдельной строкой
	int16  fUnderMinStock;   // Только те товары, остатки по которым ниже минимального значения.

	TitleText  = (!Dt ? "Текущие остатки товаров" : "Остатки товаров по состоянию на " + format(Dt, ~<#dc));
	PrgnPeriod = formatperiod(FltPrgnBeg, FltPrgnEnd);
	Suppl      = if(FltSupplID != 0) ("Поставщик:"*FltSupplID.Name);
	FltLocName = (FltLocID != 0) ? FltLocID.Name : "Все склады";
	CurDt	   = Glb.CurDate;
	OrgName    = Glb.MainOrgName;
	PrnDate    = (!Dt ? CurDt : Dt);
	FltGoodsGrpName = FltGoodsGrpID.Name;
	Price_Type = if(PriceType != 0) ((PriceType == 2) ? "Реализации" : "Поступления");

	iteration {
		link   Goods GoodsID @id;               // Товар
		link   Warehouse LocID;                 // Склад (если таблица строится раздельно по каждому складу)
		long   AltNo;                           // Альтернативный номер товара (для загрузки на весы)
		double Rest;                            // Остаток в торговых единицах
		double PhRest;                          // Остаток в физических единицах
		double MinStock;                        // Минимальный допустимый остаток
		double Cost;                            // Цена поступления //
		double Price;                           // Цена реализации  //
		double UnitsPerPack;                    // Емкость упаковки //
		double Order;                           // Заказанное покупателями количество
		string GoodsGrpName[128];               // Наименование группы товаров
		double SCost;                           // Сумма в ценах поступления //
		double SPrice;                          // Сумма в ценах реализации  //
		double PctAddedVal;                     // Средняя наценка (%) //
		string CRest[16];                       // Текстовое представление остатка товаров
		double Prognosis;                       // Прогноз продаж на период FltPrgnBeg..FltPrgnEnd
		double RestInDays;                      // Остаток товара в днях
		double Deficit;                         // Количество по документам покрытия дефицита кассовых сессий
		double DraftRcpt;                       // Будущие приходы товара
		long   SubstAsscCount;                  // Количество терминальных позиций в подстановке
		string GoodsName[128];                  // Наименование товара или подставного объекта
		NCRest  = if(PriceType != 3) CRest;
		NCost   = (1 < PriceType) ? Price : Cost;
		NSCost  = (PriceType < 2) ? SCost : (if(PriceType != 3) SPrice);
		UnitName  = GoodsID.UnitID.Name;
		Barcode   = GoodsID.SingleBarCode;
		LocName   = fEachLocation ? LocID.Name : "";
		date   LastSellDate; // Дата последней продажи (если в фильтре не выбрана соответствующая опция, то 0)
		int    MatrixStatus; // Статус принадлежности матрице (инициализируется только если в фильтре выбрана опция отображения принадлежности матрице)
		double GetCVatAmount();
		double GetVatAmount();
	}
}

data SpcGoodsRest : GoodsRest {
	iteration {
		DimX = GoodsID.DimX;
		DimY = GoodsID.DimY;
		DimZ = GoodsID.DimZ;
		KindText  = GoodsID.KindText;
		GradeText = GoodsID.GradeText;
		AddObjText = GoodsID.AddObjText;
	}
}
//
// Налоговый анализ товарооборота (PPViewGoodstaxAnalyze)
//
data GoodsTaxAnlz {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;
	link   OprKind    FltOpID;

	date   FltBeg;
	date   FltEnd;
	date   FltLotsBeg;
	date   FltLotsEnd;

	string Prd[32];      // Период отчета
	string LotsPrd[32];  // Период поступления товаров
	int16  FltCycle;     // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles; // Количество циклов
	long   FltFlags;
	int16  fNozeroExciseOnly;
	int16  fLabelOnly;
	int16  fByGroups;
	int16  fDayly;
	double VATRate1;
	double VATRate2;
	double VATRate3;
	double VATRate4;
	double VATRate5;
	double VATSumIn1;
	double VATSumIn2;
	double VATSumIn3;
	double VATSumIn4;
	double VATSumIn5;
	double VATSumOut1;
	double VATSumOut2;
	double VATSumOut3;
	double VATSumOut4;
	double VATSumOut5;
	double PTrnovr1;
	double PTrnovr2;
	double PTrnovr3;
	double PTrnovr4;
	double PTrnovr5;
	double Discount1;
	double Discount2;
	double Discount3;
	double Discount4;
	double Discount5;

	VATText1 = (VATSumIn1 != 0 || VATSumOut1 != 0) ? ("НДС вход. / исход." + format(VATRate1, ~<.0) + "% - " + format(VATSumIn1, ~>12.2$) + " / " + format(VATSumOut1, ~>12.2$)) : "";
	VATText2 = (VATSumIn2 != 0 || VATSumOut2 != 0) ? ("НДС вход. / исход." + format(VATRate2, ~<.0) + "% - " + format(VATSumIn2, ~>12.2$) + " / " + format(VATSumOut2, ~>12.2$)) : "";
	VATText3 = (VATSumIn3 != 0 || VATSumOut3 != 0) ? ("НДС вход. / исход." + format(VATRate3, ~<.0) + "% - " + format(VATSumIn3, ~>12.2$) + " / " + format(VATSumOut3, ~>12.2$)) : "";
	VATText4 = (VATSumIn4 != 0 || VATSumOut4 != 0) ? ("НДС вход. / исход." + format(VATRate4, ~<.0) + "% - " + format(VATSumIn4, ~>12.2$) + " / " + format(VATSumOut4, ~>12.2$)) : "";
	VATText5 = (VATSumIn5 != 0 || VATSumOut5 != 0) ? ("НДС вход. / исход." + format(VATRate5, ~<.0) + "% - " + format(VATSumIn5, ~>12.2$) + " / " + format(VATSumOut5, ~>12.2$)) : "";
	PTrnovrText1  = (VATSumIn1 != 0 || VATSumOut1 != 0) ? ("Оборот: " + format(PTrnovr1, ~>12.2$)) : "";
	PTrnovrText2  = (VATSumIn2 != 0 || VATSumOut2 != 0) ? ("Оборот: " + format(PTrnovr2, ~>12.2$)) : "";
	PTrnovrText3  = (VATSumIn3 != 0 || VATSumOut3 != 0) ? ("Оборот: " + format(PTrnovr3, ~>12.2$)) : "";
	PTrnovrText4  = (VATSumIn4 != 0 || VATSumOut4 != 0) ? ("Оборот: " + format(PTrnovr4, ~>12.2$)) : "";
	PTrnovrText5  = (VATSumIn5 != 0 || VATSumOut5 != 0) ? ("Оборот: " + format(PTrnovr5, ~>12.2$)) : "";
	DiscountText1 = (VATSumIn1 != 0 || VATSumOut1 != 0) ? ("Скидка: " + format(Discount1, ~>12.2$)) : "";
	DiscountText2 = (VATSumIn2 != 0 || VATSumOut2 != 0) ? ("Скидка: " + format(Discount2, ~>12.2$)) : "";
	DiscountText3 = (VATSumIn3 != 0 || VATSumOut3 != 0) ? ("Скидка: " + format(Discount3, ~>12.2$)) : "";
	DiscountText4 = (VATSumIn4 != 0 || VATSumOut4 != 0) ? ("Скидка: " + format(Discount4, ~>12.2$)) : "";
	DiscountText5 = (VATSumIn5 != 0 || VATSumOut5 != 0) ? ("Скидка: " + format(Discount5, ~>12.2$)) : "";

	// 0 (INCM_DEFAULT)    По умолчанию
	// 1 (INCM_BYSHIPMENT) По отгрузке
	// 2 (INCM_BYPAYMENT)  По оплате
	int16  IncomeMethod;
	int16  PadIm;        // @alignment

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltLocName = FltLocID.Name;
	TxtIncomeMethod =
		if(IncomeMethod == 1)
			"по отгрузке"
		else if(IncomeMethod == 2)
			"по оплате"
		else
			"по флажкам операций";
	TxtLotsPeriod = (FltLotsBeg || FltLotsEnd) ? ("Период поступления лотов " + LotsPrd) : "";

	iteration {
		date   Dt;
		string BillNo[24];            // Номер документа (при детализации по документам)
		string CycleText[32];
		link   Goods       GoodsID;
		link   GoodsGroup  GoodsGrpID;
		link   GoodsTaxGrp GTaxGrpID; // Налоговая группа на товар
		link   GoodsTaxGrp LTaxGrpID; // Налоговая группа на лот
		string Name[128];             // Наименование товара
		string GrpName[128];
		string TaxStr[48];

		double Qtty;
		double PhQtty;

		double TrnovrCost;
		double TrnovrPrice;
		double Income;

		int16  fIsVatFree;
		int16  fToggleSTax;

		double ExciseSum;
		double C_VATSum;
		double C_STaxSum;
		double IncVATSum;
		double VATSum;                // Сумма НДС
		double STaxSum;               // Сумма налога с продаж
		double ExpQtty;               // Для отчета по приходам - израсходованное количество
		double Rest;                  // Для отчета по приходам - не израсходованный остаток в торговых единицах
	}
}
//
// Товарный отчет по операции
// @v7.5.4  Verification needed
//
data GoodsOpAnlz {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   Warehouse  FltLocID;        // Фильтр: Склад
	link   OprKind    FltOpID;         // Фильтр: Вид операции
	link   Article    FltObjectID;     // Фильтр: Контрагент документов
	link   Article    FltSupplID;      // Фильтр: Поставщик
	link   Article    FltAgentID;      // Фильтр: Агент в документах
	link   Article    FltSupplAgentID; // Фильтр: Агент поставщика
	link   GoodsGroup FltGoodsGrpID;   // Фильтр: товарная группа
	date   FltBeg;                     // Фильтр: начало периода расчета
	date   FltEnd;                     // Фильтр: конец периода расчета
	string FltOpTxt[64];               // Фильтр: наименование вида операции (возможно, консолидирующее название)
	long   FltOpGrpID;                 // Фильтр: ид вида операции, по которой ведется расчет
	long   FltFlags;                   // Фильтр: флаги
	int16  fDiffByPrice;               // Фильтр: Разбивать по ценам реализации (Price)
	int16  fDiffByNetPrice;            // Фильтр: Разбивать по чистым ценам реализации (Price-Discount)
	int16  fIntrReval;                 // Фильтр: Разница цен при межскладском перемещении
	int16  fLabelOnly;                 // Фильтр: Только помеченные документы
	int16  fPriceWithoutExcise;        // Фильтр: Цены реализации рассчитаны без акциза
	int16  fCalcRest;                  // Фильтр: Рассчитывается колонка остатков
	int16  fEachLocation;              // Фильтр: По каждому складу отдельной строкой
	int16  Sgg;                        // Фильтр: Подстановка товара
	string SggTxt[32];                 // Фильтр: Текст, описывающий подстановку товара
	date   RestCalcDate;               // Фильтр: Дата расчета остатков (if fCalcRest != 0)

	CurDt   = Glb.CurDate;                          // Текущая дата
	OrgName = Glb.MainOrgName;                      // Наименование главной организации
	Period  = formatperiod(FltBeg, FltEnd);         // Фильтр: Текстовое представление периода расчета
	FltLocName = FltLocID.Name;                     // Фильтр: Наименование склада
	FltAgentName = FltAgentID.Name;                 // Фильтр: Наименование агента
	FltSupplAgentName = FltSupplAgentID.Name;       // Фильтр: Наименование агента поставщика
	FltSuppTxt = (FltSupplID  ? ("Поставщик" + ":" * FltSupplID.Name)  : "");
	FltObjTxt  = (FltObjectID ? ("Контрагент" + ":" * FltObjectID.Name) : "");
	SggTxt2    = Sgg ? "Подстановка товара:" * SggTxt : "";
	FlagsTxt = (
		(fPriceWithoutExcise ? "Цены реализации без акциза." : "") *
		(fDiffByPrice ? "С разбивкой по ценам реализации." : "") *
		(fDiffByNetPrice ? "С разбивкой по чистым ценам реализации." : ""));

	iteration {
		link   Goods      GoodsID;             // ИД товара
		link   GoodsGroup GoodsGrpID;          // ИД товарной группы
		link   Article    SubstArID;           // Статья, подставленная вместо GoodsID
		link   Person     SubstPsnID;          // Персоналия, подставленная вместо GoodsID
		link   Warehouse  SubstLocID;          // Склад, подставленный вместо GoodsID
		link   Warehouse  LocID;               // ИД Склада
		int16  InOutTag;                       // >0 - приход, <0 - расход
		int16  Reserve;                        // @alignment
		string GoodsName[128];  // Наименование товара
		string GrpName[128];    // Наименование товарной группы
		double UnitPerPack;     // Емкость упаковки (из лота, если нет - из информации по товару)
		double Qtty;            // Количество торговых единиц
		double PhQtty;          // Количество физических единиц
			// Для отчета сравнения драфт-документов со списанием - количество в документах списания //
		double OldCost;         // Старая цена поступления (переоценка). Для отчета сравнения драфт-документов со списанием - сумма в ценах поступления документов списания //
		double OldPrice;        // Старая цена реализации (переоценка). Если отчет рассчитывается с колонкой средних продаж, то это значение попадает в эту переменную
			// Для отчета сравнения драфт-документов со списанием - сумма в ценах реализации документов списания //
		double Cost;            // Цена поступления //
		double Price;           // Цена реализации (скидка учтена)
		double SumCost;         // Сумма в ценах поступления //
		double SumPrice;        // Сумма в ценах реализации (скидка учтена)
		double Income;          // Доходность (SumPrice-SumCost)
		double PctVal;          // Процентаная величина доходности
		double Rest;            // Остаток на указаную в фильтре дату (или текущий) в торговых единицах
		double PhRest;          // Остаток в физических единицах
		double RestCost;        // Остаток в ценах поступления //
		double RestPrice;       // Остаток в ценах реализации
		string CQtty[16];       // Текстовое представление количества (в зависимости от конфигурации - в упаковках)
		string CRest[16];       // Текстовое представление остатка (в зависимости от конфигурации - в упаковках)

		Barcode  = Sgg ? "" : GoodsID.SingleBarCode;
		UnitName = Sgg ? "" : GoodsID.UnitID.Name;
		InOutTxt = if(InOutTag < 0) ("Вход") else if(InOutTag > 0) ("Выход") else ("");
		LocName  = fEachLocation ? LocID.Name : "";
	}
}
//
// Товарный отчет по операции со сравнением
//
data GoodsOpAnlzCmp {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   Warehouse  FltLocID;        // Фильтр: Склад
	link   OprKind    FltOpID;         // Фильтр: Вид операции
	link   Article    FltObjectID;     // Фильтр: Контрагент документов
	link   Article    FltSupplID;      // Фильтр: Поставщик
	link   Article    FltAgentID;      // Фильтр: Агент в документах
	link   Article    FltSupplAgentID; // Фильтр: Агент поставщика
	link   GoodsGroup FltGoodsGrpID;   // Фильтр: товарная группа
	date   FltBeg;                     // Фильтр: начало периода расчета
	date   FltEnd;                     // Фильтр: конец периода расчета
	date   CmpFltBeg;                  // Фильтр: начало периода расчета для сравнения //
	date   CmpFltEnd;                  // Фильтр: конец периода расчета для сравнения  //
	string FltOpTxt[64];               // Фильтр: наименование вида операции (возможно, консолидирующее название)
	long   FltOpGrpID;                 // Фильтр: ид вида операции, по которой ведется расчет
	long   FltFlags;                   // Фильтр: флаги
	int16  fDiffByPrice;               // Фильтр: Разбивать по ценам реализации (Price)
	int16  fDiffByNetPrice;            // Фильтр: Разбивать по чистым ценам реализации (Price-Discount)
	int16  fIntrReval;                 // Фильтр: Разница цен при межскладском перемещении
	int16  fLabelOnly;                 // Фильтр: Только помеченные документы
	int16  fPriceWithoutExcise;        // Фильтр: Цены реализации рассчитаны без акциза
	int16  fCalcRest;                  // Фильтр: Рассчитывается колонка остатков
	int16  fEachLocation;              // Фильтр: По каждому складу отдельной строкой
	int16  Sgg;                        // Фильтр: Подстановка товара
	string SggTxt[32];                 // Фильтр: Текст, описывающий подстановку товара
	date   RestCalcDate;               // Фильтр: Дата расчета остатков (if fCalcRest != 0)
	date   CmpRestCalcDate;            // Фильтр: Дата расчета остатков (if fCalcRest != 0) для сравнения //

	CurDt   = Glb.CurDate;                             // Текущая дата
	OrgName = Glb.MainOrgName;                         // Наименование главной организации
	Period  = formatperiod(FltBeg, FltEnd);            // Фильтр: Текстовое представление периода расчета
	CmpPeriod  = formatperiod(CmpFltBeg, CmpFltEnd);   // Фильтр: Текстовое представление периода расчета
	FltLocName = FltLocID.Name;                        // Фильтр: Наименование склада
	FltAgentName = FltAgentID.Name;                    // Фильтр: Наименование агента
	FltSupplAgentName = FltSupplAgentID.Name;          // Фильтр: Наименование агента поставщика
	FltGoodsGrpName = FltGoodsGrpID.Name;              // Фильтр: Наименование товарной группы
	FltSuppTxt = (FltSupplID  ? ("Поставщик: "  + FltSupplID.Name)  : "");
	FltObjTxt  = (FltObjectID ? ("Контрагент: " + FltObjectID.Name) : "");
	SggTxt2    = Sgg ? "Подстановка товара:" * SggTxt : "";
	FlagsTxt = (
		(fPriceWithoutExcise ? "Цены реализации без акциза." : "") *
		(fDiffByPrice ? "С разбивкой по ценам реализации." : "") *
		(fDiffByNetPrice ? "С разбивкой по чистым ценам реализации." : ""));

	iteration {
		link   Goods      GoodsID;    // ИД товара
		link   GoodsGroup GoodsGrpID; // ИД товарной группы
		link   Article    SubstArID;  // Статья, подставленная вместо GoodsID
		link   Person     SubstPsnID; // Персоналия, подставленная вместо GoodsID
		link   Warehouse  SubstLocID; // Склад, подставленный вместо GoodsID
		link   Warehouse  LocID;      // ИД Склада
		string GoodsName[128];        // Наименование товара
		string GrpName[128];          // Наименование товарной группы
		double Qtty;                  // Количество торговых единиц
		double SumCost;               // Сумма в ценах поступления //
		double SumPrice;              // Сумма в ценах реализации (скидка учтена)
		double Income;                // Доходность (SumPrice-SumCost)
		double Rest;                  // Остаток на указаную в фильтре дату (или текущий)
		double PhRest;                // Остаток в физических единицах
		double RestCostSum;           // Остаток на указаную в фильтре дату (или текущий) в ценах поступления //
		double RestPriceSum;          // Остаток на указаную в фильтре дату (или текущий) в ценах реализации
		double CmpQtty;               // Количество торговых единиц для сравнения //
		double CmpSumCost;            // Сумма в ценах поступления  для сравнения //
		double CmpSumPrice;           // Сумма в ценах реализации (скидка учтена) для сравнения //
		double CmpIncome;             // Доходность (SumPrice-SumCost) для сравнения //
		double CmpRest;               // Остаток на указаную в фильтре дату (или текущий) для сравнения //
		double CmpPhRest;             // Остаток на указаную в фильтре дату (или текущий) в физических единицах для сравнения //
		double CmpRestCostSum;        // Остаток на указаную в фильтре дату (или текущий) в ценах поступления //
		double CmpRestPriceSum;       // Остаток на указаную в фильтре дату (или текущий) в ценах реализации
	}
}

data GoodsOpAnlzCmp_SubstLoc : GoodsOpAnlzCmp {
	iteration {
		SubstLocName = SubstLocID.Name;
		SubstLocCmprbl = SubstLocID.fComparable ? "Да" : "Нет";
	}
}

data SpcGoodsOpAnlz : GoodsOpAnlz {
	iteration {
		DimX = GoodsID.DimX;
		DimY = GoodsID.DimY;
		DimZ = GoodsID.DimZ;
		KindText   = GoodsID.KindText;
		GradeText  = GoodsID.GradeText;
		AddObjText = GoodsID.AddObjText;
	}
}
//
// Прайс-лист
//
data PriceListData {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   Warehouse  LocID;
	link   Article    SupplID;
	link   QuotKind   FltQuotKindID;
	link   Person     FltManufID;
	link   GoodsGroup FltGoodsGrpID;
	link   QuotKind   CfgPriceQuot1;
	link   QuotKind   CfgPriceQuot2;
	link   QuotKind   CfgPriceQuot3;
	string PLMemo[128];
	long   PListID;
	date   Date;
	double FltAddPct;
	date   FltLotBeg;
	date   FltLotEnd;
	LotPrd = formatperiod(FltLotBeg, FltLotEnd);

	int16  fPresentOnly;
	int16  fByQuot;
	int16  fExcludeGoodsGrp;
	int16  fPlistNew;

	OrgName    = Glb.MainOrgName;
	CurDate    = Glb.CurDate;
	OrgBnkAcc  = Glb.MainOrgBankAcc;
	OrgAddress = Glb.Address;
	OrgPhone   = Glb.Phone;
	OrgINN     = Glb.INN;
	SupplName  =
		if(SupplID) (
			"Поставщик:" * SupplID.Name
		);
	LocName = LocID ? LocID.Name : "";
	FltQuotName  = (FltQuotKindID > 0) ? FltQuotKindID.Name : "";
	CfgQuot1Name = (CfgPriceQuot1 > 0) ? CfgPriceQuot1.Name : "";
	CfgQuot2Name = (CfgPriceQuot2 > 0) ? CfgPriceQuot2.Name : "";
	CfgQuot3Name = (CfgPriceQuot3 > 0) ? CfgPriceQuot3.Name : "";

	iteration {
		long   __HLID; // Это поле необходимо для установки связи с полем __ID__
			// таблицы заголовка отчета. В противном случае CR10 отказывается печатать
			// поля из заголовка в каждом ценнике.
		link   QualityCert QCertID;
		link   GoodsGroup  GoodsGrpID;
		link   Goods       GoodsID;
		link   Unit        UnitID;
		link   Person      ManufID;
		link   QuotKind    QuotKindID;
		long   LN;                         // Номер строки по итератору
		long   LineNo;
		long   GoodsCode;
		date   Expiry;
		double UnitPerPack;
		double Price;
		double AddPrice1;
		double AddPrice2;
		double AddPrice3;
		double Rest;                       // Остаток товара
		string GoodsName[128];             //
		string ExtGroupName[128];          // Наименование группы со всеми подгруппами
		string Memo[128];
		ManufName = GoodsID.ManufID.Name;
		PackPrice = Price*UnitPerPack;
		PackAddPrice1 = AddPrice1*UnitPerPack;
		PackAddPrice2 = AddPrice2*UnitPerPack;
		PackAddPrice3 = AddPrice3*UnitPerPack;
		GroupName = GoodsGrpID.Name;
		UnitName  = UnitID.Name;
		QuotKindName =
			if(QuotKindID > 0) (
				QuotKindID.Name
			)
			else if(QuotKindID == 0) (
				"Базовая цена"
			)
			else (
				""
			);
		PhPerUnit = GoodsID.PhPerUnit;
		Barcode   = GoodsID.SingleBarCode;
		LabelName = (length(GoodsID.LabelName) != 0) ? GoodsID.LabelName : GoodsName;
	}
}
//
// Сертификаты качества к прайс-листу
//
data PriceListQCert : PriceListData {
	iteration {
		QRegOrgan    = QCertID.RegOrgan;
		QManuf       = QCertID.ManufName;
		QInitDate    = QCertID.InitDate;
		QCode        = QCertID.Code;
		QBlank       = QCertID.Blank;
		QExpiry      = QCertID.Expiry;
		QProduceDate = QCertID.ProduceDate;
	}
}
//
// Товарная этикетка
//
data GoodsLabel {
  	link   Global Glb;
	link   Goods     HdrGoodsID;
	link   Warehouse LocID;
	int    NumCopies;
	int    nn;
  	OrgName    = Glb.MainOrgName;
  	OrgAddress = Glb.Address;
  	CurDate    = Glb.CurDate;
	iteration {
  		link   Goods  GoodsID;
  		date   Expiry;
  		double Price;
		double UnitPerPack;
		string PrnBarcode[32]; // Версия штрихкода для печати
		PackPrice  = Price*UnitPerPack;
  		GoodsName  = GoodsID.Name;
		GoodsGroup = GoodsID.GroupID.Name;
  		Barcode    = GoodsID.SingleBarCode;
		LabelName  = (length(GoodsID.LabelName) != 0) ? GoodsID.LabelName : GoodsName;
  		Ingred     = GoodsID.Ingred;
  		Energy     = GoodsID.Energy;
  		Storage    = GoodsID.Storage;
  		Usage      = GoodsID.Usage;
		Standard   = GoodsID.Standard;
  		ManufName  = GoodsID.ManufID.Name;
  		ManufCountry = GoodsID.ManufID.LocID.CityID.CountryID.Name;
  		PhPerUnit  = GoodsID.PhPerUnit;
	}
}

data BarcodeLabelList {
  	link   Global Glb;
	link   Warehouse LocID;
	int    NumCopies;
	int    nn;
  	OrgName    = Glb.MainOrgName;
  	OrgAddress = Glb.Address;
  	CurDate    = Glb.CurDate;
	iteration {
  		link   Goods  GoodsID;
  		date   BillDate;       // Дата документа прихода лота
  		string BillNo[32];     // Номер документа прихода лота
  		date   Expiry;
  		double Qtty;           // Оприходованное количество в лоте
  		double PhQtty;         // Оприходованное количество в лоте в физических единицах
  		double Brutto;         // Масса брутто оприходованного количества
  		double Price;
  		double RevalPrice;     // Цена до переоценки
		double UnitPerPack;
		string Barcode[32];    // Штрихкод товара
		string Serial[32];     // Серийный номер
		MainOrgName = Glb.MainOrgName;
		PackPrice  = Price*UnitPerPack;
  		GoodsName  = GoodsID.Name;
		GoodsGroup = GoodsID.GroupID.Name;
		LabelName  = (length(GoodsID.LabelName) != 0) ? GoodsID.LabelName : GoodsName;
  		Ingred     = GoodsID.Ingred;
  		Energy     = GoodsID.Energy;
  		Storage    = GoodsID.Storage;
  		Usage      = GoodsID.Usage;
		Standard   = GoodsID.Standard;
  		ManufName  = GoodsID.ManufID.Name;
  		ManufCountry = GoodsID.ManufID.LocID.CityID.CountryID.Name;
  		PhPerUnit  = GoodsID.PhPerUnit;
  		PCode      = PrintableBarcode(Barcode, 0);
	}
}
//
// Базовая структура для описания товарного документа
// @todo (v4.4.5) Использовать все возможности для наследования параметров
//                от таблицы Bill вместо непосредственного заполнения полей
//
data GoodsBillBase {
	link   Global  Glb;
	link   OprKind OprKindID;
	long   ExpendFlag;          // 1 - Расход товара (или заказ), 2 - Приход товара
	link   Bill      BillID;
	link   Bill      LinkBillID;
	link   Currency  CurID;
	link   Article   ObjectID;
	link   Article   PayerID;
	link   Article   AgentID;
	link   Warehouse LocID;
	//
	// Если контрагент в документе имеет отношение типа "Филиал" с другой персоналией,
	// то собственно контрагент трактуется как грузополучатель (грузоотправитель) а
	// персоналия, с которой он связан этим отношением - покупателем (поставщиком).
	// Если такой связи нет, то и грузополучатель (грузоотправитель) совпадает с
	// покупателем (поставщиком)
	//
	link   Person    DlvrID;       // Поставщик
	link   PersonReq DlvrReq;      // Поставщик (как PersonReq)
	link   Warehouse DlvrLocID;    // Склад поставщика
	link   Person    RcvrID;       // Покупатель
	link   PersonReq RcvrReq;      // Покупатель (как PersonReq)
	link   Warehouse RcvrLocID;    // Склад покупателя //
	link   PersonReq ConsignorReq; // Грузоотравитель
	link   PersonReq ConsigneeReq; // Грузополучатель
	date   Dt;                // Дата документа
	date   PayDt;             // Срок оплаты по документу (последняя дата из плана платежей)
	long   Flags;             //
	int16  fSupplIsVatExempt; // Признак того, что персоналия DlvrID освобождена от НДС
	int16  fShortMainOrg;     // Печатать сокращенное название
	int16  fMergeSameGoods;   // Объединять идентичные строки
	int16  RowOrder;          // Порядок сортировки строк
	string Code[24];
	string Memo[128];         // @todo Воспользоваться ссылкой BillID.Memo
	double TotalSum;
	double TotalSalesTax;     // Сумма налога с продаж
	double TotalVAT;          // Сумма НДС
	double TotalQtty;         // Общее количество товарных единиц
	double TotalPhQtty;       // Общее количество физических единиц
	double TotalPacks;        // Количество полных упаковок
	double TotalBrutto;       // Масса брутто товара, определенного в документе (kg)
	long   TotalGoodsLines;   // Количество товарных строк в документе
	long   TotalGoodsNames;   // Количество наименований товаров (<= TotalLines)
	string TxtManualDscnt[64];

	CurSymb = CurID.Symb;
	double VATRate1;
	double VATRate2;
	double VATSum1;
	double VATSum2;
	//
	// Descr: Возвращает количественное сальдо по товару goodsID
	//   для контрагента ObjectID (член структуры).
	//   Сальдо - входящее, то есть без учета количества, присутствующего в документе.
	//   Если ObjectID == 0, то результат - 0.
	//
	double CalcInSaldo(long goodsID);
	//
	// Descr: Возвращает !0 если все товары документа являются нелимитируемыми
	//   (как правило, услугами).
	//
	int    UnlimGoodsOnly();
	//
	// Descr: Возвращает текущий долг клиента (если данный документ долговой, то он тоже включен в сумму долга).
	//
	double GetClientDebt(); // @v12.3.10

	iteration {
		long   nn;                      // Порядковый номер строки.
		link   Goods       GoodsID;     // ИД товара
		link   Lot         LotID;       // ИД лота
		string CLB[28];                 // Номер грузовой таможенной декларации
		string GoodsGrpName[64];        // Наименование группы товара (заполняется только если задана сортировка по группе и товару).
		double Cost;                    // Цена поступления торговой единицы товара
		double Price;                   // Цена реализации торговой единицы товара
		double Discount;                // Скидка на одну торговую единицу товара
		double MainPrice;               // Номинальная цена торговой единицы товара
		double CurPrice;                // Валютная цена торговой единицы товара
		double CurSum;                  // Валютная сумма строки
		double Qtty;                    // Количество торговых единиц
		double UnitsPerPack;            // Умкость упаковки (из лота)
		double FullPack;                // Количество полных упаковок
		string CQtty[32];               // При печати ценников - имя альт группы
		double VATRate;                 // Ставка НДС (%)
		double VATSum;                  // Сумма НДС
		double ExcRate;                 // Ставка акциза (%)
		double ExcSum;                  // Сумма акциза
		double STRate;                  // Ставка налога с продаж (%)
		double STSum;                   // Сумма налога с продаж (при печати ценников - номер товара в альт группе)
		double ExtPrice;                // Дополнительная расчетная цена (по котировке Bill.ExtPriceQkID)

		AbsQtty   = ((Qtty < 0) ? (-Qtty) : Qtty);
		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
		UnitName  = GoodsID.UnitID.Name;
		PhQtty    = AbsQtty * GoodsID.PhPerUnit;
		//
		// Descr: Возвращает количество акцизных марок, ассоциированных со строкой.
		//   Фактически, функция нужна для того, чтобы определить привязаны ли к строке марки или нет.
		//
		// @v10.2.12 @construction int    GetEgaisMarkCount();
		//
		// Descr: Возвращает суммовую величину по строке. Тип величины задается строковым параметром amtSymb[]
		// Возможные значения amtSymb:
		//   "qty" | "qtty" | "quantity"
		//   "cost"
		//   "costsum"
		//   "price"
		//   "pricesum"
		//   "discount"
		//   "vatrate"         ставка НДС в номинальных ценах
		//   "vat"             величина НДС в номинальной цене
		//   "vatsum"          величина НДС в номинальной сумме (в цене, умноженной на количество)
		//   "costvatrate"     ставка НДС в ценах поступления
		//   "costvat"         величина НДС в цене поступления
		//   "costvatsum"      величина НДС в сумме поступления (в цене поступления, умноженной на количество)
		//   "pricevatrate"
		//   "pricevat"
		//   "pricevatsum"
		//
		double GetRowAmount(string amtSymb[32]);
		//
		// Descr: Возвращает !0 если после отгрузки этой накладной остаток товара обнуляется (то есть, мы забрали последние остатки товара этим документом).
		//   Если текущая строка документа не является расходной, то функция автоматически возвращает 0.
		//
		int    IsStockExhausted(); // @v12.3.10
	}
}
//
// Описание списка сертификатов как приложения к товарному документу
//
data GoodsBillQCert {
	link   Global    Glb;
	link   Bill      BillID;
	link   Warehouse LocID;
	link   PersonReq DlvrReq;
	link   Location  DlvrLocID;
	link   PersonReq RcvrReq;
	link   Location  RcvrLocID;

	long   ExpendFlag;
	date   Dt;
	string Code[24];       //
	int16  fShortMainOrg;  //
	int16  fPad;           // @alignment

	OrgName    = if(fShortMainOrg == 1) Glb.ShortOrgName else Glb.MainOrgName;
	OrgAddress = if(fShortMainOrg != 1) Glb.Address;
	OrgPhone   = if(fShortMainOrg != 1) Glb.Phone;
	SupplName  = DlvrReq.ExtName2;
	SupplAddress = DlvrReq.Address;                    // Адрес поставщика
	SupplLocAddr =                                     // Адрес грузоотправителя //
		DlvrLocID ? DlvrLocID.Addr : (DlvrReq.RAddr == "" ? DlvrReq.Address : DlvrReq.RAddr);
	SupplPhone   = DlvrReq.Phone;
	SupplAccount = DlvrReq.BankAccount;
	SupplCity    = DlvrReq.BankCity;
	SupplINN     = DlvrReq.INN;
	SupplOKPO    = DlvrReq.OKPO;
	SupplLoc     = if(ExpendFlag) (LocID.Name + "   " + LocID.Addr) else "";
	BuyerName    = (RcvrReq != 0) ? RcvrReq.ExtName2 : BillID.ArticleID.Name;
	BuyerAddress = RcvrReq.Address; // Адрес покупателя //
	BuyerLocAddr = RcvrLocID ?      // Адрес грузополучател
		RcvrLocID.Addr : (RcvrReq.RAddr == "" ? RcvrReq.Address : RcvrReq.RAddr);
	BuyerPhone   = RcvrReq.Phone;
	BuyerAccount = RcvrReq.BankAccount;
	BuyerCity    = RcvrReq.BankCity;
	BuyerINN     = RcvrReq.INN;
	BuyerOKPO    = RcvrReq.OKPO;
	iteration {
		long   nn @nn;
		link   Goods GoodsID;
		link   Lot   LotID;
		link   QualityCert QualityCertID;
		double Qtty;
		string LExpiry[20];

		ManufName    = QualityCertID.ManufName;
		QRegOrgan    = QualityCertID.RegOrgan;
		QInitDate    = QualityCertID.InitDate;
		QCode        = QualityCertID.Code;
		QBlank       = QualityCertID.Blank;
		QExpiry      = QualityCertID.Expiry;
		Etc  = QualityCertID.Etc;
		QProduceDate = QualityCertID.ProduceDate;
		GoodsName    = GoodsID.Name;
		GoodsStorage = GoodsID.Storage;
		GoodsStd     = GoodsID.Standard;
	}
}
//
// Товарная переоценка
// @v7.5.8 Verification needed
// @v8.1.2 Verification needed
// @v8.6.2 Verification needed
// @v11.1.7 Verification needed
//
data GoodsReval {
	link   Global    Glb;
	link   Bill      BillID;
	link   Bill      LinkBillID;
	link   Article   ArticleID;
	link   Warehouse LocID;
	long   ExpendFlag;  // 1 - Расход товара (или заказ), 2 - Приход товара
	string Code[24];    // Номер документа
	date   Dt;          // Дата документа
	//
	// Если контрагент в документе имеет отношение типа "Филиал" с другой персоналией,
	// то собственно контрагент трактуется как грузополучатель (грузоотправитель) а
	// персоналия, с которой он связан этим отношением - покупателем (поставщиком).
	// Если такой связи нет, то и грузополучатель (грузоотправитель) совпадает с
	// покупателем (поставщиком)
	//
	link   Person    DlvrID;       // Поставщик
	link   PersonReq DlvrReq;      // Поставщик (как PersonReq)
	link   Warehouse DlvrLocID;    // Склад поставщика
	link   Person    RcvrID;       // Покупатель
	link   PersonReq RcvrReq;      // Покупатель (как PersonReq)
	link   Warehouse RcvrLocID;    // Склад покупателя //
	link   PersonReq ConsignorReq; // Грузоотравитель
	link   PersonReq ConsigneeReq; // Грузополучатель
	double TotalSum;
	double TotalSalesTax;     // Сумма налога с продаж
	double TotalVAT;          // Сумма НДС
	double TotalQtty;         // Общее количество товарных единиц
	double TotalPhQtty;       // Общее количество физических единиц
	double TotalPacks;        // Количество полных упаковок
	double TotalBrutto;       // Масса брутто товара, определенного в документе (kg)
	long   TotalGoodsLines;   // Количество товарных строк в документе
	long   TotalGoodsNames;   // Количество наименований товаров (<= TotalLines)
	int16  fSupplIsVatExempt; // Признак того, что персоналия DlvrID освобождена от НДС
	int16  fReserve;          // @alignment
	double VATRate1;
	double VATRate2;
	double VATSum1;
	double VATSum2;
	string Memo[128];
	//
	// Descr: Возвращает !0 если все товары документа являются нелимитируемыми (как правило, услугами).
	//
	int    UnlimGoodsOnly();

	OrgName   = Glb.MainOrgName;
	Accountant = Glb.Accountant;
	Director  = Glb.Director;
	CurDate   = Glb.CurDate;
	LocName   = LocID.Name;
	//
	//
	//
	Txt_Hdr  = "N" * Code * "от" * format(Dt, ~<#DC);
	TextSalesTax = if(TotalSalesTax != 0) ("Сумма включает налог с продаж" * format(TotalSalesTax, ~<12.2));
	TextSum      = Money2Str(TotalSum-TotalSalesTax, 90);

	SupplName    = DlvrReq.ExtName2;
	SupplNameShrt = DlvrReq.Name;       // Сокращенное наименование поставщика
	SupplMemo    = DlvrReq.Memo;
	SupplAddress = DlvrReq.Address;     // Адрес поставщика
	SupplPhone   = DlvrReq.Phone;
	SupplAccount = DlvrReq.BankAccount;
	SupplCity    = DlvrReq.BankCity;
	SupplINN     = DlvrReq.INN;
	SupplOKPO    = DlvrReq.OKPO;
	SupplKPP     = DlvrReq.KPP;         // Код КПП поставщика
	SupplLoc     = if(ExpendFlag) (LocID.Name + "   " + LocID.Addr) else "";
	// Грузоотправитель {
	ConsignorName     = ConsignorReq.ExtName2; //
	ConsignorNameShrt = ConsignorReq.Name;     // Сокращенное наименование грузоотправителя //
	ConsignorLocAddr = DlvrLocID ? DlvrLocID.Addr : (ConsignorReq.RAddr == "" ? ConsignorReq.Address : ConsignorReq.RAddr); // Адрес грузоотправителя //
	// } Грузоотправитель
	BuyerName    = (RcvrReq != 0) ? RcvrReq.ExtName2 : BillID.ArticleID.Name;
	BuyerMemo    = RcvrReq.Memo;
	BuyerAddress = RcvrReq.Address;     // Адрес покупателя           //
	BuyerPhone   = RcvrReq.Phone;       // Телефоны покупателя        //
	BuyerAccount = RcvrReq.BankAccount; // Расчетный счет покупателя  //
	BuyerCity    = RcvrReq.BankCity;    // Город покупателя           //
	BuyerINN     = RcvrReq.INN;         // ИНН покупателя             //
	BuyerOKPO    = RcvrReq.OKPO;        // ОКПО покупателя            //
	BuyerKPP     = RcvrReq.KPP;         // Код КПП покупателя         //
	// Грузополучатель {
	ConsigneeName    = ConsigneeReq.ExtName2;
	ConsigneeLocAddr = RcvrLocID ? RcvrLocID.Addr : (ConsigneeReq.RAddr == "" ? ConsigneeReq.Address : ConsigneeReq.RAddr); // Адрес грузополучателя //
	// } Грузополучатель
	PaymBillCode = BillID.PaymBillCode; //
	PaymBillDate = BillID.PaymBillDate; //
	fUnlimGoodsOnly = UnlimGoodsOnly(); // Признак того, что в документе - только нелимитированные товары
	LinkBillCode = LinkBillID.Code;
	LinkBillDate = LinkBillID.Dt;
	iteration {
		link   Goods GoodsID;
		long   nn;
		long   RByBill;     // @v11.1.7 Фиксированный порядковый номер строки в документе
		long   OrgRByBill;  // @v11.1.7 Фиксированный порядковый номер строки в связанном (оригинальном) документе
		link   Lot LotID; //
		double OldCost;   //
		double NewCost;   //
		double OldPrice;  //
		double NewPrice;  //
		double Quantity;  //
		double OldQtty;   //
		double VATRate;   // Ставка НДС (%)
		double VATSum;    // Сумма НДС
		double ExcRate;   // Ставка акциза (%)
		double ExcSum;    // Сумма акциза
		double STRate;    // Ставка налога с продаж (%)
		double STSum;     // Сумма налога с продаж (при печати ценников - номер товара в альт группе)
		double VATSumOldCost;
		double VATSumNewCost;
		double VATSumOldPrice;
		double VATSumNewPrice;

		UnitName  = GoodsID.UnitID.Name;
		PriceSum  = (NewPrice-OldPrice)*Quantity;
		CostSum   = (NewCost-OldCost)*Quantity;
		GoodsName = GoodsID.Name;          // Наименование товара
		Serial    = LotID.Serial;          // Серийный номер лота
		CLB       = LotID.CLB;             // @v11.1.7 ГТД
		Barcode   = GoodsID.SingleBarCode; // Штрихкод товара
		//
		// Descr: Возвращает суммовую величину по строке. Тип величины задается строковым параметром amtSymb[]
		// Возможные значения amtSymb:
		//   "qty" | "qtty" | "quantity" абсолютное значение количества
		//   "cost"
		//   "costsum"
		//   "price"
		//   "pricesum"
		//   "discount"
		//   "vatrate"         ставка НДС в номинальных ценах
		//   "vat"             величина НДС в номинальной цене
		//   "vatsum"          величина НДС в номинальной сумме (в цене, умноженной на количество)
		//   "costvatrate"     ставка НДС в ценах поступления
		//   "costvat"         величина НДС в цене поступления
		//   "costvatsum"      величина НДС в сумме поступления (в цене поступления, умноженной на количество)
		//   "pricevatrate"
		//   "pricevat"
		//   "pricevatsum"
		//
		double GetRowAmount(string amtSymb[32]); // @v10.3.6 @construction

		OldPriceWoVat = GetRowAmount("old-price-wo-vat");
		OldPriceSumWoVat = GetRowAmount("old-price-sum-wo-vat");
		OldPriceSum = GetRowAmount("old-price-sum");
		NewPriceWoVat = GetRowAmount("new-price-wo-vat");
		NewPriceSumWoVat = GetRowAmount("new-price-sum-wo-vat");
		NewPriceSum = GetRowAmount("new-price-sum");
		OldCostVat = GetRowAmount("old-cost-vat");
		NewCostVat = GetRowAmount("new-cost-vat");
		OldPriceVat = GetRowAmount("old-price-vat");
		NewPriceVat = GetRowAmount("new-price-vat");
		ManufName = if(GoodsID.ManufID.Status == 12) // @v11.1.7 PPPRS_COUNTRY = 12 (Персоналия - страна)
				if(GoodsID.ManufID.fNativeLand)
					"---"
				else
					GoodsID.ManufID.Name
			else
				if(GoodsID.ManufID.LocID.CityID.CountryID.fNativeLand)
					"---"
				else
					GoodsID.ManufID.LocID.CityID.CountryID.Name;
		ManufCntryCode = GoodsID.GetManufCountryText(2); // @v11.1.7 Цифровой код страны-производителя
	}
}
//
// Документ модификации товаров
// @v8.9.11 Verification needed
//
data GoodsBillModif {
	link Global  Glb;
	link OprKind OprKindID;

	long   BillID;
	link   Currency  CurID;
	link   Article   ObjectID;
	link   Warehouse LocID;
	link   Person    CntragntID;
	link   PersonReq CntragntReq;
	date   Dt;
	long   Flags;
	int16  fShortMainOrg;    // Печатать сокращенное название
	int16  Reserve;          // @alignment
	string Code[24];         //
	string Memo[128];

	double ExpendQtty;       // Общее количество израсходованных товарных единиц
	double ExpendPacks;      // Количество израсходованных полных упаковок
	double ExpendCost;       // Расход в ценах поступлени
	double ExpendPrice;      // Расход в ценах реализации
	double ExpendSum;        // Расход в номинальных ценах
	double ExpendVAT;        // НДС на расход
	double ExpendExcise;     // Акциз на расход

	double ReceiptQtty;      // Общее количество полученных товарных единиц
	double ReceiptPacks;     // Количество полученных полных упаковок
	double ReceiptCost;      // Приход в ценах поступлени
	double ReceiptPrice;     // Приход в ценах реализации
	double ReceiptSum;       // Приход в номинальных ценах
	double ReceiptVAT;       // НДС на приход
	double ReceiptExcise;    // Акциз на приход

	Txt_Hdr = "N" * Code * "от" * format(Dt, ~<#DC);
	CurDate = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	OrgMemo = if(fShortMainOrg != 1) Glb.MainOrgMemo;
	LocName = LocID.Name;

	iteration {
		long   Iter_NN;       // @internal
		long   Sign_NN;
		link   Goods GoodsID;
		link   Lot   LotID;   // Идентификатор лота
		short  Sign;          // Знак операции (-1 - расход, 1 - выход)
		int16  Reserve;       // @alignment
		double Cost;
		double Price;
		double MainPrice;
		double CurPrice;
		double CurSum;
		double Qtty;
		double UnitsPerPack;
		double FullPack;
		string CQtty[32];
		double VATRate;
		double VATSum;
		double ExcRate;
		double ExcSum;

		GoodsName = GoodsID.Name;
		UnitName  = GoodsID.UnitID.Name;
		AbsQtty = ((Qtty < 0) ? (-Qtty) : Qtty);
		MainSum    = MainPrice*AbsQtty;
		Barcode    = GoodsID.SingleBarCode;
		CSumma     = Cost*AbsQtty;
		PSumma     = Price*AbsQtty;
		SignText = (Sign > 0) ? "ВЫХОД" : "РАСХОД";
	}
}
//
// Размещение строк товарного документа по складским ячейкам
//
data GoodsBillDispose {
	link   Global Glb;
	link   OprKind OprKindID;
	long   ExpendFlag;          // 1 - Расход товара (или заказ), 2 - Приход товара
	link   Bill      BillID;
	link   Bill      LinkBillID;
	link   Currency  CurID;
	link   Article   ObjectID;
	link   Article   PayerID;
	link   Article   AgentID;
	link   Warehouse LocID;
	//
	// Если контрагент в документе имеет отношение типа "Филиал" с другой персоналией,
	// то собственно контрагент трактуется как грузополучатель (грузоотправитель) а
	// персоналия, с которой он связан этим отношением - покупателем (поставщиком).
	// Если такой связи нет, то и грузополучатель (грузоотправитель) совпадает с
	// покупателем (поставщиком)
	//
	link   Person    DlvrID;       // Поставщик
	link   PersonReq DlvrReq;      // Поставщик (как PersonReq)
	link   Warehouse DlvrLocID;    // Склад поставщика
	link   Person    RcvrID;       // Покупатель
	link   PersonReq RcvrReq;      // Покупатель (как PersonReq)
	link   Warehouse RcvrLocID;    // Склад покупателя //
	link   PersonReq ConsignorReq; // Грузоотравитель
	link   PersonReq ConsigneeReq; // Грузополучатель

	date   Dt;                // Дата документа
	date   PayDt;             // Срок оплаты по документу (последняя дата из плана платежей)
	long   Flags;             //
	int16  fSupplIsVatExempt; // Признак того, что персоналия DlvrID освобождена от НДС
	int16  fShortMainOrg;     // Печатать сокращенное название
	int16  fMergeSameGoods;   // Объединять идентичные строки
	int16  RowOrder;          // Порядок сортировки строк
	string Code[24];
	string Memo[128];
	double TotalSum;
	double TotalSalesTax;     // Сумма налога с продаж
	double TotalVAT;          // Сумма НДС
	double TotalQtty;         // Общее количество товарных единиц
	double TotalPhQtty;       // Общее количество физических единиц
	double TotalPacks;        // Количество полных упаковок
	double TotalBrutto;       // Масса брутто товара, определенного в документе (kg)
	long   TotalGoodsLines;   // Количество товарных строк в документе
	long   TotalGoodsNames;   // Количество наименований товаров (<= TotalLines)

	DlvrName = DlvrID.Name; // @v10.2.8
	RcvrName = RcvrID.Name; // @v10.2.8

	iteration {
		long   nn;                      // Порядковый номер строки.
		link   Goods       GoodsID;     // ИД товара
		link   Lot         LotID;       // ИД лота
		link   WhCell      CellID;      // ИД ячейки хранения //
		double Cost;                    // Цена поступления торговой единицы товара
		double Price;                   // Цена реализации торговой единицы товара
		double Discount;                // Скидка на одну торговую единицу товара
		double MainPrice;               // Номинальная цена торговой единицы товара
		double CurPrice;                // Валютная цена торговой единицы товара
		double CurSum;                  // Валютная сумма строки
		double Qtty;                    // Количество торговых единиц в строке.
		double UnitsPerPack;            // Умкость упаковки (из лота)
		double FullPack;                // Количество полных упаковок
		double ExtPrice;                // Дополнительная расчетная цена (по котировке Bill.ExtPriceQkID)

		long   DispRByLoc;              // Индекс размещения по ячейке
		long   DispRByBill;             // Индекс размещения по документу
		date   DispDt;                  // Дата размещения //
		time   DispTm;                  // Время размещения //
		link   User        DispUserID;  // Пользователь, осуществивший размещение
		long   DispOp;                  // Вид операции размещения //
		long   DispFlags;               // Флаги размещения //
		long   PalletTypeID;            // Тип палетта
		long   PalletCount;             // Количество палетт
		double DispQtty;                // Размещенное количество. abs(DispQtty) <= abs(Qtty)
		double DispRestByGoods;         // Остаток товара GoodsID в ячейке после размещения //
		double DispRestByLot;           // Остаток лота LotID в ячейке после размещения //
		string CQtty[32];               // Представление общего количества торговых единиц в строке.
		string CDispQtty[32];           // Представление размещенного количества

		CellCode  = CellID.Code;
		CellName  = CellID.Name;
		CellLayer = CellID.Layer;
		AbsQtty     = abs(Qtty);
		AbsDispQtty = abs(DispQtty);
		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
		UnitName  = GoodsID.UnitID.Name;
		PhQtty    = abs(Qtty) * GoodsID.PhPerUnit;
		CLB       = LotID.CLB;          // Номер грузовой таможенной декларации
		Serial    = LotID.Serial;       // Серийный номер
	}
}
//
// Базовая структура для описания кассового ордера (приходного и расходного)
//
data CashOrder {
	link Global    Glb;
	link Article   ArticleID;
	link Article   Article2ID;
	link PersonReq PersonReqID;
	link PersonReq Person2ReqID;
	link Bill      BillID;

	double Amount;
	string Code[24];
	date   Dt;
	string Memo[128];
	long   CashAc;      // Счет кассы
	long   CashSb;      // Субсчет кассы
	long   Ac;
	long   Sb;
	long   Ar;
	double VAT;

	double VATRate1;
	double VATSum1;
	double VATRate2;
	double VATSum2;
	double STaxRate;
	double STaxSum;

	SalesTaxText = format(Amount * 5 / 105, ~<.2) + " руб.";
	VATText = format(VAT, ~<.2) + " руб.";

	VATText1 = (
		if(VATSum1 != 0) (
			"В т.ч. НДС " + format(VATRate1, ~<.0) + "% - "// + format(VATSum1, ~>8.2$)
		)
		else (
			""
		));
	VATText2 = (
		if(VATSum2 != 0) (
			"В т.ч. НДС " + format(VATRate2, ~<.0) + "% - "// + format(VATSum2, ~>8.2$)
		)
		else (
			""
		));
	STaxText = (
		if(STaxSum != 0) (
			"В т.ч. налог с продаж - "// + format(STaxSum, ~>8.2$)
		)
		else (
			""
		));
	RcvDocument  = PersonReqID.Passport;
	Rcv2Document = Person2ReqID.Passport;
	Contragent  = (PersonReqID.ExtName == "" ? ArticleID.Name : PersonReqID.ExtName);
	Contragent2 = Article2ID.Name;
	OrgName     = Glb.MainOrgName;
	Cashier     = Glb.Cashier;
	Accountant  = Glb.Accountant;
	Director    = Glb.Director;
	OKPO        = Glb.OKPO;
	TxtDate     = Date2WStr(Dt, 46);
	TextAmount  = Money2Str(Amount, 128);
}
//
// Расходный кассовый ордер
//
data PayCashOrder : CashOrder {
	TxtAmt0    = wrap(TextAmount, 67);
	TxtAmt1    = middle(TextAmount, length(TxtAmt0)+1, 67);
	OrgNameExt = Glb.MainOrgExtName;
	BnkName    = Glb.MainOrgBnkName;
	BnkAcc     = Glb.MainOrgBnkAccN;
}
//
// Новая форма Объявления на взнос наличными
//
data BnkCashDeclare : PayCashOrder {
	INN = Glb.INN;
	KPP = Glb.KPP;
	OKATO = Glb.MainOrgID.GetRegister("OKATO").Number;
	BIC   = Glb.MainOrgID.ReqID.BankID.GetRegister("BIC").Number;
}
//
// Приходный кассовый ордер
//
data RcvCashOrder : CashOrder {
	TxtAmt0 = wrap(TextAmount, 49);
	TxtAmt1 = middle(TextAmount, length(TxtAmt0)+1, 49);
	TxtVat  = if((int)VAT) "В т.ч. НДС";
}
//
// Банковское платежное поручение (платежное требование)
// @v8.1.9   Verification needed
// @v10.7.9  Verification needed
//
data BnkPaymOrder {
	declare "DOSSTUB"

	link Global    Glb;
	link PersonReq PayerID;
	link PersonReq RcvrID;
	link PersonReq PayerBnkID;
	link PersonReq RcvrBnkID;
	link Bill      BillID;
	date   LclDt;              // may be not eq BillID.Dt
	string LclCode[24];        // may be not eq BillID.Code
	string LclMemo[512];       // may be not eq BillID.Memo
	long   PayerBnkAccID;
	string PayerBnkCity[48];
	string PayerBIC[24];
	string PayerBnkCorAcc[24];
	string PayerAcc[28];       //
	long   RcvrBnkAccID;
	string RcvrBnkCity[48];
	string RcvrBIC[24];
	string RcvrBnkCorAcc[24];
	string RcvrAcc[28];        //
	int16  BnkPaymMethod;
	int16  BnkQueueing;
	int16  FormalPurpose;      // @v10.7.9 Формальное назначение платежа
	int16  Reserve;            // @v10.7.9 @alignment
	int16  PayerStatus;
	int16  fNoAccept;          // Безакцептное платежное требование
	string TxtPayerStatus[8];  //
	double Amount;
	double VATRate;
	double VATSum;
	//
	// Налоговые маркеры
	//
	string TxmClass[24];       // Код бюджетной классификации (КБК)
	string TxmOKATO[16];       // Код ОКАТО муниципального образования //
	string TxmReason[8];       // Основание бюджетного платежа
	string TxmPeriod[12];      // Показатель налогового периода
	string TxmDocNumber[12];   // Номер документа, согласно которому осуществляется платеж
	date   TxmDocDate;         // Дата документа, согласно которому осуществляется платеж
	string TxmPaymType[8];     // Показатель типа платежа
	string UIN[24];            // Код УИН

	PayerName = PayerID.ExtName;
	PayerINN  = PayerID.INN;
	PayerKPP  = PayerID.KPP;           // КПП Плательщика
	PayerBnkName = PayerBnkID.ExtName;
	RcvrName  = RcvrID.ExtName;
	RcvrINN   = RcvrID.INN;
	RcvrKPP   = RcvrID.KPP;            // КПП получателя платежа
	RcvrBnkName = RcvrBnkID.ExtName;
	BnkPaymMethodText = if(BnkPaymMethod == 0)
			""
		else if(BnkPaymMethod == 1)
			"почтой"
		else if(BnkPaymMethod == 2)
			"телеграфом"
		else if(BnkPaymMethod == 3)
			"электронно"
		else if(BnkPaymMethod == 4)
			"срочно"
		else
			"электронно";
	VatText = if(VATRate > 0)
			"В том числе НДС " + format(VATRate, ~<.0) + "% - "
		else if(VATSum > 0)
			"В том числе НДС "
		else
			"НДС нет";
	AmountText = Money2Str(Amount, 128, 1);
	AcceptText = (fNoAccept ? "Без акцепта" : "С акцептом");
}
//
// План платежей по документу
//
data BillPayPlan {
	link   Global  Glb;
	link   OprKind OprKindID;
	link   Bill      BillID;
	int16  fProfitable;                                    // 1 - доходная операция, 0 - не доходная операция //
	Dt   = BillID.Dt;
	Code = BillID.Code;
	LocID        = BillID.LocID;
	ObjectID     = BillID.ArticleID;
	PayerID      = BillID.PayerID;
	AgentID      = BillID.AgentID;
	Amount       = BillID.Amount;
	Memo = BillID.Memo;
	CurSymb      = BillID.CurID.Symb;
	ObjName      = BillID.ArticleID.Name;                  // Наименование статьи контрагента по документу
	CaName       = BillID.ArticleID.PersonID.ExtName2;     // (Расширенное) наименование персоналии-контрагента
	CaPhone      = BillID.ArticleID.PersonID.Phone;        // Телефон контрагента
	CaPassport   = BillID.ArticleID.PersonID.Passport;     // Паспортные данные контрагента
	CaAddr       = BillID.ArticleID.PersonID.Address;      // Юридический адрес контрагента
	CaRAddr      = BillID.ArticleID.PersonID.RAddr;        // Фактический адрес контрагента
	CaINN        = BillID.ArticleID.PersonID.INN;          // ИНН контрагента
	CaBankAcc    = BillID.ArticleID.PersonID.BankAccount;  // Банковский счет контрагента
	RcStart      = BillID.RcStart;                         // Начало периода действия ренты
	RcFinish     = BillID.RcFinish;                        // Окончание периода действия ренты
	fRcPctCharge = BillID.fRcPctCharge;                    // Процентные начисления по ренте
	fRcClosed    = BillID.fRcClosed;                       // Закрытый договор ренты
	RcCycle      = BillID.RcCycle;                         // Цикличность начисления по ренте (0, 1, 7, 30, 90, 180, 360)
	RcCycleText  = BillID.RcCycleText;                     // Текстовая строка, идентифицирующая цикличность начисления //
	RcDayOffs    = BillID.RcDayOffs;                       // Смещение даты начисления (в днях)
	RcPercent    = BillID.RcPercent;                       // Процент (годовой)
	RcPartAmount = BillID.RcPartAmount;                    // Частичная сумма начисления (на каждый период) //
	TextAmount   = Money2Str(Amount, 90);
	MainOrgName  = Glb.MainOrgExtName;
	MainOrgINN   = Glb.INN;
	MainOrgPhone = Glb.Phone;
	MainOrgAddr  = Glb.Address;
	MainOrgBankAcc = Glb.MainOrgBankAcc;
	Accountant   = Glb.Accountant;
	Director     = Glb.Director;

	iteration {
		long   nn;        // Номер строки по порядку (для внутреннего использования)
		date   PayDate;   // Дата платежа
		double Amount;    // Сумма платежа по основному долгу
		double Interest;  // Сумма процентных (рентных) выплат
		double Rest;      // Остаток основного долга
		TotalPaym = Amount + Interest;
	}
}
//
// Лоты
//
data Lots {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;
	link   Goods      FltGoodsID;
	date   FltBeg;
	date   FltEnd;
	date   FltExpiryBeg;
	date   FltExpiryEnd;
	long   IsOper;
	date   OperLow;
	date   OperUpp;
	long   FltFlags;
	int16  FltClosedTag;    // 0 - all, 1 - opened lots only, 2 - closed lots only
	int16  fWithoutQCert;   // Только те лоты, у которых нет сертификатов
	int16  fOrders;         // Лоты заказов
	int16  fCostAbovePrice; // Только те лоты, у которых цена поступления выше цены реализации

	CurDate  = Glb.CurDate;
	OrgName  = Glb.MainOrgName;
	Location = FltLocID ? ("Склад: " + FltLocID.Name) : "Все склады";
	FltSupplName = FltSupplID.Name;
	Period   = formatperiod(FltBeg, FltEnd);
	OperationPeriod  = formatperiod(OperLow, OperUpp);

	iteration {
		link   Lot     LotID;
		string CQtty[16];
		string CRest[16];

		double BegRest;
		double EndRest;
		double Sales;
		double QttyPlus;  // Количество, поступившее за операционный период
		double QttyMinus; // Количество, израсходнованное за операционный период
		string CBegRest[16];
		string CEndRest[16];
		string CSales[16];

		GoodsID  = LotID.GoodsID;
		Dt       = LotID.Dt;
		Expiry   = LotID.Expiry; // Срок годности товара
		Rest     = LotID.Rest;
		Quantity = LotID.Qtty;
		Cost     = LotID.Cost;
		Price    = LotID.Price;
		CLB      = LotID.CLB;    // Грузовая таможенная декларация.
		QEndRest  = if(IsOper) EndRest else Rest;
		RestCost  = QEndRest*Cost;
		RestPrice = QEndRest*Price;
		GoodsName = LotID.GoodsID.Name;
		SupplName = LotID.SupplID.Name;
	}
}
//
// Операции по лоту
// @v10.7.4  Verification needed
//
data LotOps {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Lot     LotID;
	CurDate   = Glb.CurDate;
	OrgName   = Glb.MainOrgName;
	GoodsID   = LotID.GoodsID;
	LocName   = LotID.LocID.Name;
	GoodsName = LotID.GoodsID.Name;
	SupplName = LotID.SupplID.Name;
	LotBillNo = LotID.BillID.Code;
	LotDt     = LotID.Dt;             // Дата прихода товара
	Expiry    = LotID.Expiry;         // Срок годности товара
	LotRest   = LotID.Rest;           // Текущий остаток по лоту
	LotQtty   = LotID.Qtty;           // Поступившее количество
	LotCost   = LotID.Cost;           // Цена поступления //
	LotPrice  = LotID.Price;          // Цена реализации
	UnitsPerPack = LotID.UnitPerPack; // Емкость упаковки
	CLB       = LotID.CLB;            // Грузовая таможенная декларация //

	iteration {
		link   Bill     BillID;
		link   Currency CurID;
		date   Dt;
		int16  OprNo;
		double Qtty;
		double Rest;
		double Cost;
		double Price;
		double OldQtty;         // @v10.7.4 Старое количество (переоценка или корректировка)
		double OldCost;         // @v10.7.4 Старая цена поступления (переоценка или корректировка)
		double OldPrice;        // @v10.7.4 Старая цена реализации (переоценка или корректировка)
		double Discount;
		double CurPrice;
		ContragentName = BillID.ArticleID.Name;
		BillNo = BillID.Code;
		OpName = BillID.OprKindID.Name;
	}
}
//
// Реестр документов
//
data BillList {
	declare "Destroy"

	link   Global    Glb;
	link   OprKind   FltOprKindID;
	link   Warehouse FltLocID;
	link   Article   FltArtID;
	link   Article   FltPayerID;
	link   Article   FltAgentID;
	link   Currency  FltCurID;
	date   FltBeg;
	date   FltEnd;
	double FltMinAmt;
	double FltMaxAmt;
	long   Flags;
	int16  fAllCurrencies;
	double InDebt;         // Для долговой карточки
	double OutDebt;        // Для долговой карточки

	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;
	PayerName  = if(FltPayerID) ("Плательщик:"*FltPayerID.Name);
	FltAgentName = FltAgentID.Name;
	FltLocName = (FltLocID ? ("Склад: " + FltLocID.Name) : "");
	Period     = formatperiod(FltBeg, FltEnd);
	FltCurText = (
			if(fAllCurrencies)
				"По всем валютам"
			else
				(FltCurID ? ("Валюта: " + format(FltCurID.Symb, ~<)) : " ")
		);
	iteration {
		link   Bill BillID;
		date   LastPaymDate; // Дата последнего платежа по документу. Инициализируется только в том случае, когда поднимается реестр документов с суммой долга (BillFilt::fShowDebt)
		double Debit;                           // Для долговой карточки
		double Credit;                          // Для долговой карточки
		double Saldo;                           // Для долговой карточки
		Dt     = BillID.Dt;             // Дата документа
		Code   = BillID.Code;           // Номер документа
		ContrAgentName = BillID.ArticleID.Name; // Наименование контрагента по документу
		StatusName     = BillID.StatusID.Name;  // Статус документа
		CurSymb        = BillID.CurID.Symb;     // Символ валюты
		AgentName      = BillID.AgentID.Name;   // Наименование агента
		OpName = BillID.OprKindID.Name; // Наименование вида операции
		Amount = BillID.Amount;         // Номинальная сумма документа
	}
}
//
// Реестр товарных документов с содержанием
// @v8.4.9 Verification needed
// @v11.3.6 Verification needed
//
data ContentBList {
	declare "Destroy"

	link   Global    Glb;
	link   OprKind   FltOprKindID;
	link   Warehouse FltLocID;
	link   Article   FltPayerID;
	link   Currency  FltCurID;
	date   FltBeg;
	date   FltEnd;
	int16  fAllCurrencies;
	double TotalVatRate1;
	double TotalVatRate2;
	double TotalVatRate3;
	double TotalVatRate4;

	TotalVatRTxt1 = ((TotalVatRate1 != 0) ? (format(TotalVatRate1, ~>.0) + "%") : "");
	TotalVatRTxt2 = ((TotalVatRate2 != 0) ? format(TotalVatRate2, ~>.0) + "%" : "");
	TotalVatRTxt3 = ((TotalVatRate3 != 0) ? format(TotalVatRate3, ~>.0) + "%" : "");
	TotalVatRTxt4 = ((TotalVatRate4 != 0) ? format(TotalVatRate4, ~>.0) + "%" : "");

	double TotalVat1;
	double TotalVat2;
	double TotalVat3;
	double TotalVat4;

	OrgName    = Glb.MainOrgName;
	CurDate    = Glb.CurDate;
	PayerName  = FltPayerID ? ("Плательщик:" * FltPayerID.Name) : "";
	FltOpName  = FltOprKindID.Name;
	FltLocName = FltLocID ? ("Склад: " + FltLocID.Name) : "";
	Period     = formatperiod(FltBeg, FltEnd);
	iteration {
		link   Bill  BillID;
		link   Goods GoodsID;
		link   Lot   LotID;
		long   recNo;
		long   grpNo;
		double Quantity;
		double Cost;
		double Price;
		double NominalPrice; // @v11.3.6 Номинальная цена (зависит от вида операции)
		double CurPrice;
		double VaTax;
		double ExTax;
		double StTax;
		double VatSum;
		double ExtSum;
		double StSum;
		double OldCost;   // Для переоценки и корректирующих документов: старая цена поступления
		double OldPrice;  // Для переоценки и корректирующих документов: старая цена реализации
		double OldQtty;   // Для переоценки и корректирующих документов: старое значение количества

		Dt        = BillID.Dt;
		Code      = BillID.Code;
		Memo      = BillID.Memo;
		GoodsName = GoodsID.Name;
		LocName   = BillID.LocID.Name;
		ContrAgentName = BillID.ArticleID.Name;
		SCost     = Quantity*Cost;
		Summa     = Quantity*Price;
		SNominal  = Quantity*NominalPrice; // @v11.3.6 Сумма в номинальных ценах (зависит от вида операции)
		OpName    = BillID.OprKindID.Name;
		CostRevalSum  = (Cost  - OldCost)  * Quantity;
		PriceRevalSum = (Price - OldPrice) * Quantity;
		//
		// Descr: Возвращает суммовую величину по строке. Тип величины задается строковым параметром amtSymb[]
		// Возможные значения amtSymb:
		//   * "qty" | "qtty" | "quantity"
		//   "cost"
		//   "costsum"
		//   "price"
		//   "pricesum"
		//   "discount"
		//   "vatrate"         ставка НДС в номинальных ценах
		//   "vat"             величина НДС в номинальной цене
		//   "vatsum"          величина НДС в номинальной сумме (в цене, умноженной на количество)
		//   * "costvatrate"     ставка НДС в ценах поступления
		//   * "costvat"         величина НДС в цене поступления
		//   * "costvatsum"      величина НДС в сумме поступления (в цене поступления, умноженной на количество)
		//   * "pricevatrate"
		//   * "pricevat"
		//   * "pricevatsum"
		//
		double GetRowAmount(string amtSymb[32]); // @v12.2.0

		//TestAmount01 = GetRowAmount("qtty"); // @debug
		//TestAmount02 = GetRowAmount("pricevat"); // @debug
		//TestAmount03 = GetRowAmount("costvatsum"); // @debug
	}
}
//
// Кассовая книга
//
data CashBook {
	link Global Glb;
	OrgName    = Glb.MainOrgName;
	Cashier    = Glb.Cashier;
	Accountant = Glb.Accountant;
	double InRest;
	double OutRest;
	date   Dt;
	TextDate = Date2Str(Dt, 30);
	long   PayCashCnt;
	long   RcvCashCnt;
	PayCashCnt_Text = Num2Str((double) PayCashCnt, 32);
	RcvCashCnt_Text = Num2Str((double) RcvCashCnt, 32);

	iteration {
		string Code[16];
		string CorrAcc[16];
		string CorrAccName[32];
		double Debit;
		double Credit;
		string Memo[128];
	}
}
//
// Системный журнал
//
data SysJournal {
	declare "Destroy"

	link Global Glb;
	link User       FltUserID;
	link DataObject FltObjType;
	long FltAction;
	date FltBeg;
	date FltEnd;
	int16  FltSysJSubst;      // Параметр подстановки
	int16  FltDateSubst;      // Параметр подстановки даты
	Period = formatperiod(FltBeg, FltEnd);

	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;

	FltSysJSubstTxt =
		if(FltSysJSubst == 1)
			"по событию"
		else if(FltSysJSubst == 2)
			"по пользователю"
		else if(FltSysJSubst == 3)
			"по типу объекта"
		else
			"";
	FltDateSubstTxt =
		if(FltDateSubst == 1)
			"по неделе"
		else if(FltDateSubst == 2)
			"по месяцу"
		else if(FltDateSubst == 3)
			"по кварталу"
		else if(FltDateSubst == 4)
			"по году"
		else
			"";

	iteration {
		link   User       UserID;
		link   DataObject ObjType;
		long   ObjID;
		long   ActionID;
		date   Dt;
		time   Tm;
		string ActionName[48];
		string ObjName[64];
		string GrpText1[64];
		long   GrpCount;
		string AvgEvTime[32];

		TmTxt       = (format(Tm, ~>&N));
		UserName    = UserID.Name;
		ObjTypeName = ObjType ? ObjType.Name : "";
	}
}
//
//
//
data GoodsBillData : GoodsBillBase {
	Title    =
		if(ExpendFlag == 1)
			"расход товара"
		else if(ExpendFlag == 2)
			"приход товара";
	Txt_Hdr  = "N" * Code * "от" * format(Dt, ~<#DC);
	Txt_Qtty = Num2Str(TotalQtty, 128);
	Txt_Sum  = Money2Str(TotalSum, 128);
	Txt_Sum1 = wrap(Txt_Sum, 60);
	Txt_Sum2 = middle(Txt_Sum, length(Txt_Sum1)+1, 60);

	OrgName  = if(fShortMainOrg == 1) Glb.ShortOrgName else Glb.MainOrgName;
	OrgReq   = OrgName + if(fShortMainOrg != 1)
		(if(length(Glb.Address)) ";" * Glb.Address) + (if(length(Glb.Phone)) ";" * Glb.Phone);
	OrgBankAcc     = if(fShortMainOrg != 1) Glb.MainOrgBankAcc;
	OrgMemo        = if(fShortMainOrg != 1) Glb.MainOrgMemo;
	ContragentMemo = RcvrID.Memo;
	DlvrName       = (DlvrID == Glb.ID) ? DlvrLocID.Name : DlvrReq.ExtName2;
	ConsignorName  = (ConsignorReq == Glb.ID) ? DlvrLocID.Name : ConsignorReq.ExtName2; // Грузоотправитель
	ConsignorLocAddr = DlvrLocID ? // Адрес грузоотправителя
		DlvrLocID.Addr : (ConsignorReq.RAddr == "" ? ConsignorReq.Address : ConsignorReq.RAddr);

	// BillUED = BillID.GetUedIdent(); // @v12.2.11 @debug убрать после отработки

	RcvrName   =
		if(RcvrID == Glb.ID) (
			RcvrLocID.Name
		)
		else if(RcvrID != 0) (
			RcvrReq.ExtName2
		)
		else (
			BillID.ArticleID.Name
		);
	ConsigneeName   =
		if(ConsigneeReq == Glb.ID) (
			RcvrLocID.Name
		)
		else if(ConsigneeReq != 0) (
			ConsigneeReq.ExtName2
		)
		else (
			BillID.ArticleID.Name
		);                           // Грузополучатель
	ConsigneeLocAddr = (RcvrLocID != 0) ? RcvrLocID.Addr : (ConsigneeReq.RAddr == "" ? ConsigneeReq.Address : ConsigneeReq.RAddr); // Адрес грузополучателя //

	OprName    = OprKindID.Name;
	OprFlags   = OprKindID.Flags;
	PayerName  = if(PayerID) ("Плательщик:" * PayerID.Name);
	Payment     = if(PayDt) ("Оплатить до" * format(PayDt, ~<#DC));
	VATRateStr1 = if(VATRate1 != 0) ("НДС"*format(VATRate1, ~>2.0)+"%");
	VATRateStr2 = if(VATRate2 != 0) ("НДС"*format(VATRate2, ~>2.0)+"%");
	iteration {
		MainSum    = Round(MainPrice * AbsQtty, 2);
		CSumma     = Round(Cost*AbsQtty, 2);
		PSumma     = Round(Price*AbsQtty, 2);
		TaxFreeSum = MainSum-ExcSum-VATSum-STSum;
	}
}
//
// Структура для печати товарной накладной с полем поставщика (для сортировки по поставщику)
//
data GoodsBillSuppl : GoodsBillData {
	iteration {
		SupplName = LotID.SupplID.Name;
	}
}
//
// Структура для печати товарной накладной с полями наименования места хранения и полной товарной группы
//
data GoodsBillWpG : GoodsBillData {
	iteration {
		// GoodsGrpName системой заполняется как наименование места хранения //
		FullGrpName = GoodsID.GroupID.FullName;
	}
}
//
// Структура для печати товарного документа с отображением сальдо контрагента по товарам
//
// @construction
data GoodsBillSaldo : GoodsBillData {
	iteration {
		InSaldo = CalcInSaldo(GoodsID.ID);
		OutSaldo = InSaldo + Qtty;
	}
}
//@construction
//
// Структура для печати товарного документа с UED документа в виде штрихкода
//
// @construction
data GoodsBillBCUED : GoodsBillData { // @v12.2.11
	BillUED = BillID.GetUedIdent();
}
//@construction
//
// Структура для печати товарных этикеток из товарного документа
//
data PLabelBillData : GoodsBillData {
	iteration {
		Standard     = GoodsID.Standard;
		Usage        = GoodsID.Usage;
		Ingred       = GoodsID.Ingred;
		ManufName    = GoodsID.ManufID.Name;
		ManufCountry = GoodsID.ManufID.LocID.CityID.CountryID.Name;
		QCertManuf   = LotID.QCertID.ManufName;      // Наименование производителя (по сертификату)
		Expiry       = LotID.Expiry;                 // Дата истечения срока годности лота
		PBarcode     = PrintableBarcode(Barcode, 0); // Печатаемая версия штрихкода
		LabelName    = (length(GoodsID.LabelName) != 0) ? GoodsID.LabelName : GoodsName; // Наименование товара
	}
}
//
// Структура для печати товарных этикеток из документа переоценки
//
data PLabelRvlData : GoodsReval {
	iteration {
		Standard     = GoodsID.Standard;
		Usage        = GoodsID.Usage;
		Ingred       = GoodsID.Ingred;
		// @v11.1.7 (такая переменная введена в GoodsReval) ManufName    = GoodsID.ManufID.Name;
		ManufCountry = GoodsID.ManufID.LocID.CityID.CountryID.Name;
		LabelName    = (length(GoodsID.LabelName) != 0) ? GoodsID.LabelName : GoodsName;
	}
}
//
// Товарно-транспортная накладная //
//
data LadingBillData : GoodsBillData {
	Accountant  = Glb.Accountant;
	Director    = Glb.Director;
	DlvrOrgName = DlvrID.Name;
	DlvrAddress = DlvrReq.Address;
	DlvrPhone   = DlvrReq.Phone;
	DlvrINN     = DlvrReq.INN;         //
	DlvrKPP     = DlvrReq.KPP;         //
	DlvrOKPO    = DlvrReq.OKPO;        //
	DlvrBnkAcc  = DlvrReq.BankAccount; //

	RcvrAddress = RcvrReq.Address;
	RcvrPhone   = RcvrReq.Phone;
	RcvrAccount = RcvrReq.BankAccount; // Банковский счет покупателя //
	RcvrINN     = RcvrReq.INN;         // ИНН покупателя //
	RcvrKPP     = RcvrReq.KPP;         // КПП покупателя //
	RcvrOKPO    = RcvrReq.OKPO;        // ОКПО покупателя //
	RcvrExtName = RcvrReq.ExtName2;    //
	TxtGoodsNames = Num2Str((double)TotalGoodsNames, 60);
	TxtTotalGoodsLines = Num2Str(TotalGoodsLines, 60); //
	TxtTotalPacks = Num2Str(TotalPacks, 60);
	SupplLoc = if(ExpendFlag) LocID.Addr else "";

	ConsignorINN    = ConsignorReq.INN;         //
	ConsignorKPP    = ConsignorReq.KPP;         //
	ConsignorOKPO   = ConsignorReq.OKPO;        //
	ConsignorPhone  = ConsignorReq.Phone;       //
	ConsignorBnkAcc = ConsignorReq.BankAccount; //

	ConsigneeINN    = ConsigneeReq.INN;         //
	ConsigneeKPP    = ConsigneeReq.KPP;         //
	ConsigneeOKPO   = ConsigneeReq.OKPO;        //
	ConsigneePhone  = ConsigneeReq.Phone;       //
	ConsigneeBnkAcc = ConsigneeReq.BankAccount; //

	FreightCode     = BillID.FreightCode;
	ShipName        = BillID.TranspID.Name;
	ShipModel       = BillID.TranspID.ModelName;
	ShipCode        = BillID.TranspID.Code;
	TrailerCode     = BillID.TranspID.TrailerCode;
	ShipFlag        = BillID.TranspID.CountryID.Name;
	ShipOwnerName   = BillID.TranspID.OwnerID.Name;
	ShipCaptainName = BillID.CaptainID.Name;
	ShipAgentName   = BillID.VesselsAgentID.Name;
	PortOfLoading   = BillID.PortOfLoading.Name;
	PortOfDschrg    = BillID.PortOfDschrg.Name;
	IssueDate       = BillID.IssueDate;
	ArrivalDate     = BillID.ArrivalDate;
	NmbOrigsBsL     = BillID.NmbOrigsBsL;

	iteration {
		DimX = GoodsID.DimX;
		DimY = GoodsID.DimY;
		DimZ = GoodsID.DimZ;
		KindText   = GoodsID.KindText;
		GradeText  = GoodsID.GradeText;
		AddObjText = GoodsID.AddObjText;
	}
}
//
// Счет-фактура
// @v7.1.12 Verification needed
// @v11.1.4 Verification needed
//
data InvoiceData : GoodsBillBase {
	fUnlimGoodsOnly = UnlimGoodsOnly(); // Признак того, что в документе - только нелимитированные товары
	Txt_Hdr  = "N" * Code * "от" * format(Dt, ~<#DC);
	TextSalesTax = if(TotalSalesTax != 0) ("Сумма включает налог с продаж" * format(TotalSalesTax, ~<12.2));
	TextSum      = Money2Str(TotalSum-TotalSalesTax, 90);
	Accountant   = Glb.Accountant;
	Director     = Glb.Director;
	SupplName    = DlvrReq.ExtName2;
	SupplNameShrt = DlvrReq.Name;       // Сокращенное наименование поставщика
	SupplMemo    = DlvrReq.Memo;
	SupplAddress = DlvrReq.Address;     // Адрес поставщика
	SupplPhone   = DlvrReq.Phone;
	SupplAccount = DlvrReq.BankAccount;
	SupplCity    = DlvrReq.BankCity;
	SupplINN     = DlvrReq.INN;
	SupplOKPO    = DlvrReq.OKPO;
	SupplKPP     = DlvrReq.KPP;         // Код КПП поставщика
	SupplLoc     = if(ExpendFlag) (LocID.Name + "   " + LocID.Addr) else "";
	// Грузоотправитель {
	ConsignorName     = ConsignorReq.ExtName2; //
	ConsignorNameShrt = ConsignorReq.Name;     // Сокращенное наименование грузоотправителя //
	ConsignorLocAddr = (DlvrLocID != 0) ? DlvrLocID.Addr : (ConsignorReq.RAddr == "" ? ConsignorReq.Address : ConsignorReq.RAddr); // Адрес грузоотправителя //
	// } Грузоотправитель
	BuyerName    = (RcvrReq != 0) ? RcvrReq.ExtName2 : BillID.ArticleID.Name;
	BuyerMemo    = RcvrReq.Memo;
	BuyerAddress = RcvrReq.Address;     // Адрес покупателя           //
	BuyerPhone   = RcvrReq.Phone;       // Телефоны покупателя        //
	BuyerAccount = RcvrReq.BankAccount; // Расчетный счет покупателя  //
	BuyerCity    = RcvrReq.BankCity;    // Город покупателя           //
	BuyerINN     = RcvrReq.INN;         // ИНН покупателя             //
	BuyerOKPO    = RcvrReq.OKPO;        // ОКПО покупателя            //
	BuyerKPP     = RcvrReq.KPP;         // Код КПП покупателя         //
	// Грузополучатель {
	ConsigneeName    = ConsigneeReq.ExtName2;
	ConsigneeLocAddr = (RcvrLocID != 0) ? RcvrLocID.Addr : (ConsigneeReq.RAddr == "" ? ConsigneeReq.Address : ConsigneeReq.RAddr); // Адрес грузополучателя //
	// } Грузополучатель
	PaymBillCode = BillID.PaymBillCode; //
	PaymBillDate = BillID.PaymBillDate; //
	OrgBillCode = BillID.Code; // @v11.1.4 Для invoice программа в поле GoodsBillBase::Code подставляет номер счет-фактуры. Теперь нужен еще и оригинальный номер накладной.
	OrgBillDate = BillID.Dt;   // @v11.1.4 Для invoice программа в поле GoodsBillBase::Dt подставляет дату счет-фактуры. Теперь нужна еще и оригинальная дата накладной.

	iteration {
		Total      = (Flags & 0x10000) ? -(Round(MainPrice*AbsQtty, 2)-STSum) : (Round(MainPrice*AbsQtty, 2)-STSum);
		InvcVATSum = (Flags & 0x10000) ? -VATSum : VATSum;
		PSumma     = (Total-InvcVATSum);
		FreePrice  = (AbsQtty > 0) ? Round((MainPrice*AbsQtty-STSum-InvcVATSum)/AbsQtty, 2) : PSumma;
		InvcExciseSum = (Flags & 0x10000) ? -ExcSum : ExcSum;
		Excise = (AbsQtty > 0) ? (InvcExciseSum/AbsQtty) : InvcExciseSum;
		ManufName =
			if(GoodsID.ManufID.Status == 12) // PPPRS_COUNTRY = 12 (Персоналия - страна)
				if(GoodsID.ManufID.fNativeLand)
					"---"
				else
					GoodsID.ManufID.Name
			else
				if(GoodsID.ManufID.LocID.CityID.CountryID.fNativeLand)
					"---"
				else
					GoodsID.ManufID.LocID.CityID.CountryID.Name;
		ManufCntryCode = GoodsID.GetManufCountryText(2); // Цифровой код страны-производителя //
		UnitCode = GoodsID.UnitID.Code;                  // Цифровой код единицы измерения //

		//TestAmount01 = GetRowAmount("qtty"); // @debug
		//TestAmount02 = GetRowAmount("pricesum"); // @debug
	}
}

data InvoiceExtData : InvoiceData {
	iteration {
		QCertManuf = LotID.QCertID.ManufName;
		PBarcode   = PrintableBarcode(Barcode, 0);
	}
}

data OperBillList : BillList {
	FltOpName = FltOprKindID.Name;
	iteration {
		ContrAgentID = BillID.ArticleID;
		CostSum      = BillID.GenCostSum;
		Discount     = BillID.GenDiscount;
		PriceSum     = BillID.GenPriceSum-Discount;
		PVatSum      = BillID.PVat;
		CVatSum      = BillID.CVat;
		Vat1Rate     = BillID.Vat1Rate;
		Vat1Sum      = BillID.Vat1Sum;
		Vat2Rate     = BillID.Vat2Rate;
		Vat2Sum      = BillID.Vat2Sum;
		SalesTaxSum  = BillID.SalesTax;
		Memo = BillID.Memo;
	}
}

data NominalBList : BillList {
	FltOpName = FltOprKindID.Name;
	iteration {
		ContrAgentID = BillID.ArticleID;
		Memo = BillID.Memo;
	}
}

data DebetBillList : BillList {
	FltOpName = FltOprKindID.Name;
	iteration {
		ContrAgentID = BillID.ArticleID;
		Debt    = BillID.Debt;
		PayDate = BillID.LastPayDate;
		PVatSum = BillID.PVat;
		CVatSum = BillID.CVat;
		Memo    = BillID.Memo;
	}
}
//
// Долговая карточка
//
data DebtCard : BillList {
	ContragntName = FltArtID.Name;
	iteration {
		Debt     = BillID.Debt;
		PayDate  = BillID.LastPayDate;
		BillMemo = BillID.Memo;
	}
}
//
// Долговая ведомость
//
data DebtTrnovr {
	declare "Destroy"

	link   Global    Glb;
	link   Warehouse FltLocID;
	link   AccSheet  FltAccSheetID;
	link   Article   FltArID;
	link   Currency  FltCurID;
	link   Country   FltCountryID; // Государство контрагентов
	link   World     FltRegionID;  // Регион контрагентов
	link   City      FltCityID;    // Город контрагентов
	link   PersonCat FltCatID;     // Категория контрагентов
	date   FltBeg;
	date   FltEnd;
	date   FltPaymentBeg;
	date   FltPaymentEnd;
	date   FltExpiryBeg;
	date   FltExpiryEnd;
	date   FltExpiry;              // Для списков рассылки: дата возврата подтверждения;
	long   Flags;

	int16  fDebtOnly;      // Показывать только те документы, которые имеют положительную сумму долга
	int16  fNoForwardPaym; // Не включать форвардные оплаты (дата которых превышает период отгрузки)
	int16  fLabelOnly;     // Только WL-документы
	int16  fAllCurrencies; // По всем валютам
	int16  fExtended;      // Расширенная ведомость (с данными по зачетным документам)
	int16  fDeliveryAddr;  // При определении адреса контрагента сначала пытаться использовать адрес доставки
	int16  fCalcTotalDebt; // Рассчитывать значение общего долга до конца периода оплаты
		// (независимо от периода отгрузки и периода срока оплаты)
	int16  CycleKind;      // Вид цикличности:
		// 0 - Нет
		// 1 - Долги по количеству дней, прошедших с установленного срока оплаты
		// 2 - Долги по количеству дней, прошедших с дня отгрузки (даты документа)
		// 3 - Отгрузки по циклам
		// 4 - Оплаты по циклам
	int16  FltCycle;       // Значение одного цикла (если CycleKind == 1 || CycleKind == 2, то
		// эта величина в днях)
	int16  FltNumCycles;   // Количество циклов
	int    SellOrSuppl;    //
	string CtTitle[48];    // Заголовок для кросстаб-отчета

	Period       = formatperiod(FltBeg, FltEnd);
	ExpiryPeriod = formatperiod(FltExpiryBeg, FltExpiryEnd);
	PaymPeriod   = formatperiod(FltPaymentBeg, FltPaymentEnd);

	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;
	DebtorKindText = FltAccSheetID.Name;
	FltLocText = FltLocID.Name;
	FltCurSymb = fAllCurrencies ? "По всем валютам" : ("Валюта: " + FltCurID.Symb);
	ExtraText  = fNoForwardPaym ? "Учтены только те оплаты, которые сделаны за заданный период" : "";

	iteration {
		link   Bill      BillID;
		link   Article   ArID;
		link   Currency  CurID;
		link   PersonReq RelPersonID;
		long   ArNo;
		string ArName[80];              //
		long   TabID;                   // Номер табуляции для построение кросс-таб
		string TabText[32];             // Текст табулятора
		double Debit;                   // Сумма отгрузки
		double Credit;                  // Сумма оплаты
		double Debt;                    // Сумма долга
		double RPaym;                   // Сумма зачетных документов
		double Reckon;                  // Зачтенная сумма (сумма зачитывающих документов)
		double RDebt;                   // Незачтенная сумма зачетных документов
		double TDebt;                   // Общий долг (Debt-RDebt)
		double CtVal;                   // Величина, используемая для кросстаб-отчета.
			// Эта величина равна одному из значений Debit, Credit, Debt и устанавливается //
			// системой в зависимости от
		double _AvgPaym;                // Средняя оплата по табуляторам без учета нулевых значений
		date   BillPayDate;             //
		date   LastPaymDate;            // Дата последнего платежа по документу
		Dt        = BillID.Dt;
		Code      = BillID.Code;
		CurSymb   = CurID.Symb;
		BillMemo  = BillID.Memo;
		Phone     = RelPersonID.Phone;
		AgentName = BillID.AgentID.Name;
		LocName   = BillID.LocID.Name;
	}
}
//
// Статистика дебиторов
//
data DebtorStat {
	declare "Destroy"
	declare "DOSSTUB"

	link Global    Glb;
	link AccSheet  AccSheetID;
	date   LastDate;         // Дата последнего сбора статистики
	time   LastTime;         // Время последнего сбора статистики
	string LastTimeText[20]; // Текстовое представление даты и времени последнего сбора статистики
	CurDt     = Glb.CurDate;
	OrgName   = Glb.MainOrgName;
	AccSheetName = AccSheetID.Name;

	iteration {
		link   Article ArID;
		date   Dt;             // Дата расчета
		time   Tm;             // Время расчета
		long   Flags;
		double DelayMean;      // Среднее значение задержки платежей
		double DelaySd;        // Стандартное отклонение задержки платежей
		double DelayTestGamma;
		double DelayTestChSq;
		long   PaymPeriod;     // Период платежей (в днях, начиная с первого платежа до последнего платежа включительно)
		double PaymDensity;    // Плотность платежей (сумма / день)
		string Rating[12];     // Рассчитанный на основе статистики рейтинг дебитора
		long   LimitTerm;      // Период в днях, на который рассчитан кредитный лимит
		double Limit;          // Расчетный предельный кредит для клиента
		double DebtCost;       // Расчетная стоимость кредита (на одну денежную еденицу исходя из конфигурационной ставки стоимости денег)
		double ExpiryMean;     // Средняя просроченность платежей (в днях)
		double SigmFactor;     // Сигмоидальный коэффициент поправки к плотности платжей
		fMainOrg = (ArID == 0) ? 1 : 0; // Строка является агрегирующей по всему предприятию
		fAgent   = (Flags & 1) ? 1 : 0; // Строка является агрегирующей по агенту
		fHolding = (Flags & 2) ? 1 : 0; // Строка является агрегирующей по холдингу
		ArName   = ArID.Name;
		CurAgtLimit = ArID.AgrID.MaxCredit;
	}
}
//
// Реестр межскладских перемещений
//
data IntrBillList : BillList {
	FltOpName = (FltOprKindID == 6) ? "Межскладской приход" : FltOprKindID.Name;
	iteration {
		ContrAgentID = BillID.ArticleID;
		LocName  = BillID.LocID.Name;
		CostSum  = BillID.GenCostSum;
		PriceSum = BillID.GenPriceSum-BillID.GenDiscount;
		Discount = BillID.GenDiscount;
	}
}
//
//
//
data PaymBillList {
	declare "Destroy"
	declare "DOSSTUB"

	link Global    Glb;
	link Bill      LinkBillID;
	CurDt     = Glb.CurDate;
	OrgName   = Glb.MainOrgName;
	Dt        = LinkBillID.Dt;
	HBillNo   = LinkBillID.Code;
	HOprNam   = LinkBillID.OprKindID.Name;
	int    Kind;
		// 0 - оплаты
		// 1 - начисления ренты
		// 2 - зачеты
		// 3 - зачтенные документы
		// 4 - reserved
		// 5 - документы списания дафт-документа
		//
	PaymBillTitle =
		if(Kind == 0)
			("Оплаты по документу")
		else if(Kind == 1)
			("Начисления ренты по документу")
		else if(Kind == 2)
			("Зачитывающие оплаты")
		else if(Kind == 3)
			("Зачтенные документы")
		else if(Kind == 5)
			("Документы списания драфт-документа")
		else
			("Зачеты по документу");
	AmountTxt =
		if(Kind == 0)
			("Оплачено")
		else if(Kind == 1)
			("Начислено")
		else if(Kind == 2)
			("Зачтено")
		else if(Kind == 3)
			("Зачтено");
	RestTxt   =
		if(Kind == 0)
			("Остаток")
		else if(Kind == 1)
			("Долг")
		else
			("Остаток");
	iteration {
		link   Currency CurrencyID;
		link   Bill BillID;         // Ссылка на документ оплаты
		link   Bill ItLinkBillID;   // Ссылка на оплачиваемый документ
		link   Bill ItRcknBillID;   // Ссылка на зачетный документ
		string BillNo[24];          //
		string OpName[48];          //
		date   PaymDt;              //
		double Amount;              //
		double Rest;                //
		string Memo[128];           //
		CurSymb = CurrencyID.Symb;  //
	}
}

data TransferBase {
	link   Global Glb;
	date   StartDate;
	date   EndDate;
	link   Warehouse FltLocID;
	link   Goods     FltGoodsID;
	link   OprKind   FltOprKindID;
	link   Person    FltContrAgentID;
	iteration {
		link Bill      BillID;
		link Warehouse LocID;
		link Goods     GoodsID;
		link OprKind   OprKindID;
		link Person    ContrAgentID;

		double Quantity;
		double Rest;
		AbsQuantity = if(Quantity < 0) -Quantity else Quantity @qtty;
		double Price;
		double Cost;
		double Discount;
		RealPrice = Price-Discount;
	}
}
//
// Бухгалтерский счет
//
data Account {
	key    ID;
	int    Ac;       // Номер счета
	int    Sb;       // Номер субсчета
	int    Kind;     // Вид счета (ACT_ACTIVE = 1, ACT_PASSIVE = 2, ACT_AP = 3)
	int    Type;     // 0 - Балансовый, 1 - забалансовый, 2 - группирующий
	string Name[48]; // Наименование счета
	string Code[32];
	long   Flags;
	link   Currency CurID;      // Ид валюты
	link   AccSheet AccSheetID; // Ид таблицы аналитических статей

	AccNo = format(Ac, ~<) + ((Sb == 0) ? "" : ("." + format(Sb, ~<)));
}
//
//
//
data AccRel {
	key    ID;
	link   Account AccID;   // Ид счета
	link   Article ArID;    // Ид аналитической статьи
	int16  Ac;              // Номер счета
	int16  Sb;              // Номер субсчета
	int32  Ar;              // Номер аналитической статьи
	link   Currency CurID;  // Ид валюты
	string AccName[64];     // Наименование счета

	AccNo = format(Ac, ~<) + "." + format(Sb, ~<) + "." + format(Ar, ~<);
}
//
// План счетов
//
data AccountView {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	int  FltType;
	long FltFlags;
	CurDt    = Glb.CurDate;
	OrgName  = Glb.MainOrgName;

	iteration {
		link   Account AccID;
		string CurListTxt[48];
		Ac    = AccID.Ac;
		Sb    = AccID.Sb;
		Code  = AccID.Code;
		AccNo = AccID.AccNo;
		Name  = AccID.Name;
		Kind  = AccID.Kind;
		KindTxt = (
			if(Kind == 1)
				"Акт"
			else if(Kind == 2)
				"Пасс"
			else if(Kind == 3)
				"Акт-Пасс"
			else
				""
			);
		AccSheetName = AccID.AccSheetID.Name;
	}
}
//
// Список бухгалтерских проводок (включая группировки и циклы)
//
data AccturnList {
	declare "Destroy"

	link   Global Glb;
	date   FltBeg;
	date   FltEnd;
	link   OprKind  FltOprKindID;
	link   Currency FltCurID;
	double FltMinAmount;
	double FltMaxAmount;
	int16  fAllCurrencies; // По всем валютам, иначе по валюте FltCurID
	int16  fWlOnly;        // Только WL-документы
	int16  GrpAco;         // Порядок счета по которому группируются проводки
	//                        если 0, то без группировки
	int16  FltCycle;       // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles;   // Количество циклов
	//
	// Следующие 7 параметров предназначены для фильтрации описи проводок
	// по конкретным счетам.
	//
	int16  Aco;       // Порядок счетов, по которым следует фильтровать опись
	//                   если 0, то не фильтровать по счетам
	int16  FltDbtAc;  //
	int16  FltDbtSb;  //
	int32  FltDbtAr;  //
	int16  FltCrdAc;
	int16  FltCrdSb;
	int32  FltCrdAr;

//	FltDbtAccNo =
//		if(Aco == 0)
//			""
//		else if(Aco == 1)
//			format(FltDbtAc, ~<)
//		else if(Aco == 2)
//			(format(FltDbtAc, ~<) + (FltDbtSb ? ("." + format(FltDbtSb, ~<)) : ""))
//		else
//			(format(FltDbtAc, ~<) +
//			(FltDbtSb ? ("." + format(FltDbtSb, ~<)) : "") +
//			(FltDbtAr ? ("." + format(FltDbtAr, ~<)) : ""));
//	FltCrdAccNo =
//		if(Aco == 0)
//			""
//		else if(Aco == 1)
//			format(FltCrdAc, ~<)
//		else if(Aco == 2)
//			(format(FltCrdAc, ~<) + (FltCrdSb ? ("." + format(FltCrdSb, ~<)) : ""))
//		else
//			(format(FltCrdAc, ~<) +
//			(FltCrdSb ? ("." + format(FltCrdSb, ~<)) : "") +
//			(FltCrdAr ? ("." + format(FltCrdAr, ~<)) : ""));
	GrpAcoText = (GrpAco == 0) ? "" : ((GrpAco == 1) ? "ПО СЧЕТУ" : ((GrpAco == 2) ? "ПО СУБСЧЕТУ" : "ПО СУБКОНТО"));
	FltOpName  = FltOprKindID.Name;
	FltCurSymb = (fAllCurrencies ? "По всем валютам" : ("Валюта: " + FltCurID.Symb));
	FltPeriod  = formatperiod(FltBeg, FltEnd);
	CurDt      = Glb.CurDate;
	OrgName    = Glb.MainOrgName;

	iteration {
		date   Dt;
		string CycleText[32];
		long   OprNo;
		link   Bill     BillID;
		short  RByBill;
		link   Account  DbtAccID;
		link   AccRel   DbtRelID;
		link   Account  CrdAccID;
		link   AccRel   CrdRelID;
		link   Currency CurID;
		double CRate;
		double Amount;

		BillNo   = BillID.Code;
		CurSymb  = CurID.Symb;
		DbtAccNo = (DbtRelID ? DbtRelID.AccNo : DbtAccID.AccNo);
		CrdAccNo = (CrdRelID ? CrdRelID.AccNo : CrdAccID.AccNo);
		DbtAccName = (DbtRelID ? DbtRelID.AccName : DbtAccID.Name);
		CrdAccName = (CrdRelID ? CrdRelID.AccName : CrdAccID.Name);
	}
}
//
// Анализ счета
//
data AccAnlz {
	declare "Destroy"

	link   Global  Glb;
	int    LeafNo;                // Номер листа кассовой книги
	date   FltBeg;
	date   FltEnd;
	date   ExpiryDate;            // Для списков рассылки: дата возврата подтверждения //
	link   Account FltAccID;      // Счет, по которому проводится анализ
	link   Article FltArID;       // Статья, по которой ведется анализ
	link   AccRel  FltAccRelID;   // Терминальный счет по которому проводится анализ (if Aco != ACO_3 then FltAccRelID = 0)
	link   Currency FltCurID;
	int16  Aco;
	//
	// Фильтрующие флаги
	//
	int16  fAllCurrencies; // Анализ по всем валютам
	int16  fWlOnly;        // Анализ по WL-документам
	//
	// Флаги fGroupByCorAcc и fTrnovrBySheet взаимоисключающие
	//
	int16  fGroupByCorAcc; // Анализ с группировкой по корр счету
	int16  fTrnovrBySheet; // Обороты по статьям счета
	int16  fTrnovrBySuppl; // Обороты по поставщику (fTrnovrBySheet != 0)
	//
	// Следующие два флага имеют смысл только если fTrnovrBySheet | fTrnovrBySuppl
	//
	int16  fSpprZTrnovr; // Не показывать статьи с нулевыми оборотами
	int16  fSpprZSaldo;  // Не показывать статьи с нулевым исходящим сальдо

	int16  CorAco;
	int16  FltCycle;     // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles; // Количество циклов
	int16  FltOrder;     // Порядок сортировки
	long   FltFlags;
	string FltPeriod[32];  //
	string FltAccText[96]; //
	//
	// Итоговые величины
	//
	long   TotalCount;
		// if fAllCurrencies then this TotalInRest counts by BaseCurrency
	double TotalInRest;
	double TotalOutRest;
	long   TotalDbtCount;
	long   TotalCrdCount;
	//
	// Формулы
	//
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltBegTxt  = Date2WStr(FltBeg, 32);
	FltCurSymb = (fAllCurrencies ? "По всем валютам" : ("Валюта: " + FltCurID.Symb));

	CorAcoTxt = (
		if(CorAco == 1)
			"по счетам первого порядка"
		else if(CorAco == 2)
			"по счетам второго порядка"
		else if(CorAco == 3)
			"по субконто"
		else if(CorAco == 101)
			"по виду операции"
		else if(CorAco == 102)
			"по складу"
		else if(CorAco == 103)
			"по дополнительному объекту"
		else if(CorAco == 104)
			"по агенту"
		);
	DbtCountTxt = Num2Str((double)TotalDbtCount, 64);
	CrdCountTxt = Num2Str((double)TotalCrdCount, 64);

	Cashier    = Glb.Cashier;
	Accountant = Glb.Accountant;

	iteration {
		date   Dt;
		string CycleText[32];
		long   OprNo;
		link   Bill     BillID;
		int16  RByBill;
		int16  Reverse;
		link   AccRel   ThisAccRelID; // ИД счета, по которому ведется анализ (возможно, не равен FltAccRelID при группировке)
		link   Account  CorAccID;
		link   AccRel   CorAccRelID;
		link   Currency CurID;
		link   PersonReq RelPersonID; // Для оборотной ведомости по статьям счета
		string CorAccName[128];       //
		long   Count;   // If CorAco == 0 then Count == 1
		double InRest;
		double DbtAmt;
		double CrdAmt;
		double OutRest;
		double GoodsRestAmt;
		string OrderText[32]; // Поле для группировки

		BillNo   = BillID.Code;
		BillMemo = BillID.Memo;
		ThisAccNo = ThisAccRelID.AccNo;
		ThisArNo  = ThisAccRelID.Ar;
		ThisAccName = ThisAccRelID.AccName;
		CorAccNo = (CorAccRelID ? CorAccRelID.AccNo : CorAccID.AccNo);
		ArNo     = CorAccRelID.Ar;
		CurSymb  = CurID.Symb;
	}
}
//
// Обороты по поставщикам
//
data SupplTrnovr : AccAnlz {
	iteration {
		DbtInRest  = ((InRest > 0) ? InRest : (double)0);
		CrdInRest  = ((InRest > 0) ? (double)0 : -InRest);
		DbtOutRest = ((OutRest > 0) ? OutRest : (double)0);
		CrdOutRest = ((OutRest > 0) ? (double)0 : -OutRest);

		CrdSaldo = -OutRest-GoodsRestAmt;

		DebtAboveGRest = ((CrdSaldo > 0) ? CrdSaldo  : (double)0);
		GRestAboveDebt = ((0 > CrdSaldo) ? -CrdSaldo : (double)0);
	}
}
//
// Акт сверки дебиторской задолженности (Анализ счета с оборотами по статьям)
//
data DebtAck : AccAnlz {
	Name  = Glb.MainOrgName;
	INN   = Glb.INN;
	Addr  = Glb.Address;
	Phone = Glb.Phone;
	Director   = Glb.Director;
	iteration {
		DebtorName  = RelPersonID.Name;
		DebtorINN   = RelPersonID.INN;
		DebtorAddr  = RelPersonID.Address;
		DebtorPhone = RelPersonID.Phone;

		PreambleTxt = (OutRest < 0) ?
			"Наша задолженность составила по состоянию на:" :
			"Ваша задолженность составила по состоянию на:";
		BegDebtTxt = (FltBeg ? (format(FltBeg, ~<#DC) + "  " + format(((OutRest * InRest) < 0) ? -abs(InRest) : abs(InRest), ~>.2) + " рублей") : "");
		EndDebtTxt = (FltEnd != FltBeg) ? (format(FltEnd, ~<#DC) + "  " + format(abs(OutRest), ~>.2) + " рублей") : " ";
	}
}
//
// Акт сверки дебиторской задолженности (Меню Расчеты с дебиторами и кредиторами)
//
data DebtAck1 : DebtTrnovr {
	Name  = Glb.MainOrgName;
	INN   = Glb.INN;
	Addr  = Glb.Address;
	Phone = Glb.Phone;
	Director   = Glb.Director;
	Accountant = Glb.Accountant;
	iteration {
		DebtorName  = RelPersonID.Name;
		DebtorINN   = RelPersonID.INN;
		DebtorAddr  = RelPersonID.Address;
		DebtorPhone = RelPersonID.Phone;
		PreambleTxt = (Debt < 0) ?
			"Наша задолженность составила по состоянию на:" :
			"Ваша задолженность составила по состоянию на:";
		EndDebtTxt  = FltEnd ? (format(FltEnd, ~<#DC) + "  " + format(abs(Debt), ~>.2) + " рублей") : " ";
	}
}
//
// Балансы
//
data Balance {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global   Glb;
	link   Currency FltCurID;
	date   FltBeg;
	date   FltEnd;
	link   Account  FltAccID;
	long   FltFlags;
	int16  fAllCurrencies; // По всем валютам

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	FltCurSymb = (fAllCurrencies ? "По всем валютам" : ("Валюта: " + FltCurID.Symb));

	iteration {
		date   Dt         @dt;
		link   Account  AccID;
		link   Currency CurID;
		double InDbtRest;
		double InCrdRest;
		double DbtTrnovr;
		double CrdTrnovr;
		double OutDbtRest;
		double OutCrdRest;

		AccNo   = AccID.AccNo;
		AccName = AccID.Name;
		CurSymb = CurID.Symb;
	}
}
//
// Книга продаж/покупок
// @v7.2.9 Verification needed
// @v7.3.11 Verification needed
// @v12.3.1 Verification needed
//
data VatBook {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	long   FltKind;           // 1 - Книга продаж; 2 - Книга покупок
	date   FltBeg;            // Дата начала периода выборки
	date   FltEnd;            // Дата окончания периода выборки
	double HVat1Rate;         // 1-я процентная ставка НДС
	double HVat2Rate;         // 2-я процентная ставка НДС
	double HVat3Rate;         // 3-я процентная ставка НДС
	int16  fByPayment;        // Если !0, то книга построена по оплатам, иначе - по отгрузке
	int16  fShowLinkedOnly;   // Если !0, то в отчет включены только записи, имеющие связанные документы,
		// иначе - может содержать свободные записи, созданные в ручную.
	int16  fShowUnlinkedOnly; // Если !0, то в отчет включены только записи, созданные в ручную,
		// иначе - содержит и те записи, что имеют ссылку на документ.
	int16  fShowExcluded;     // Если !0, то в отчете показаны записи, имеющие признак "Исключена" (то есть те,
		// которые не должны попадать в окончательный вариант книги).
	long   Counter;           // @internal

	CurDt   = Glb.CurDate;     // Операционная дата на момент создания данного отчета
	OrgName = Glb.MainOrgName; // Наименование главной организации
	OrgINN  = Glb.INN;         // ИНН главной организации
	OrgKPP  = Glb.KPP;         // КПП главной организации
	Period  = formatperiod(FltBeg, FltEnd); // Текстовое представление периода выборки
	Accountant = Glb.Accountant; // Имя главного бухгалтера главной организации
	Director   = Glb.Director;   // Имя директора главной организации

	iteration {
		long   ID;               // Идентификатор записи в базе данных == VATBook.ID
		long   DtLineNo;         // == VATBook.LineNo
		long   LineNo;           // Номер строки по итератору
		int16  fExcluded;        // Признак исключенной записи
		int16  fVatFree;         // Признак документа, освобожденного от НДС
		int16  fFixed;           // Признак фиксированной записи
		int16  fPartPayment;     // Признак частичной оплаты
		int16  fSlVatAddendum;   // Признак дополнительной строки в упрощенной книге доходов/расходов, отражающей сумму НДС в расходной части.
		int16  Reserve;          // @reserve
		string Code[24];         // Номер документа
		string ManufCountry[30]; // Страна производителя //
		string CLB[28];          // Грузовая таможенная декларация (ГТД)
		date   Dt;               // Дата записи
		date   InvcDate;         // Дата счета-фактуры
		date   PaymDate;         // Дата оплаты
		date   RcptDate;         // Дата прихода
		link   Article   ArticleID;  // ИД аналитической статьи (контрагента), связанной с записью
		link   PersonReq PersonID;   // ИД персоналии, связанной со статьей ArticleID (если статья не связана с персоналией, то 0)
		link   Bill      LinkBillID; // ИД документа, связанного с записью
		link   OprKind   OpID;       // Вид операции документа, связанного с записью
		double Amount;           // Сумма сделки, отраженная записью
		double Excise;           // Сумма акциза
		double Export;           // Сумма экспортной части сделки
		double Vat0Amount;       // Сумма сделки, облагаемая нулевой ставкой НДС
		double Vat1Amount;       // Сумма сделки, облагаемая ставкой НДС и индексом 1 (HVat1Rate)
		double Vat2Amount;       // Сумма сделки, облагаемая ставкой НДС и индексом 2 (HVat2Rate)
		double Vat3Amount;       // Сумма сделки, облагаемая ставкой НДС и индексом 3 (HVat3Rate)
		double Vat4Amount;       // Сумма сделки, облагаемая ставкой НДС и индексом 4 (HVat4Rate) // @v12.3.1
		double Vat5Amount;       // Сумма сделки, облагаемая ставкой НДС и индексом 5 (HVat5Rate) // @v12.3.1
		double Vat1Rate;         // Ставка НДС с индексом 1 (HVat1Rate)
		double Vat2Rate;         // Ставка НДС с индексом 2 (HVat2Rate)
		double Vat3Rate;         // Ставка НДС с индексом 3 (HVat3Rate)
		double Vat4Rate;         // Ставка НДС с индексом 4 (HVat4Rate) // @v12.3.1
		double Vat5Rate;         // Ставка НДС с индексом 5 (HVat5Rate) // @v12.3.1
		double Vat1Sum;          // Сумма НДС по ставке с индексом 1 (HVat1Rate)
		double Vat2Sum;          // Сумма НДС по ставке с индексом 2 (HVat2Rate)
		double Vat3Sum;          // Сумма НДС по ставке с индексом 3 (HVat3Rate)
		double Vat4Sum;          // Сумма НДС по ставке с индексом 4 (HVat4Rate) // @v12.3.1
		double Vat5Sum;          // Сумма НДС по ставке с индексом 5 (HVat5Rate) // @v12.3.1
		double VatFreeAmount;    // Сумма сделки, освобожденная от НДС

		date   CBillDt;          // Дата корректирующего документа
		string CBillCode[24];    // Номер корректирующего документа

		OpName      = OpID.Name;                   // Наименование вида операции документа, связанного с записью
		OpMemo      = LinkBillID.Memo;             // Примечание к документу, связанного с записью
		Date_N_Code = format(InvcDate, ~<) * Code; // Строка, комбинирующая дату и номер записи (для печати)
		ArticleName = ArticleID.Name;              // Наименование аналитической статьи, связанной с записью
		INN = PersonID.INN;                // ИНН контрагента (если статья записи не связана с персоналией, то пусто)
		KPP = PersonID.KPP;                // КПП контрагента (если статья записи не связана с персоналией, то пусто)
		Contragent  = (PersonID.ExtName == "" ? ArticleName : PersonID.ExtName); // Полное наименование контрагента.
	}
}
//
// OpGrouping
//
data OpGrouping {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   OprKind    FltOpID;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   Article    FltObjectID;
	link   GoodsGroup FltGoodsGrpID;
	link   Goods      FltGoodsID;
	link   GoodsType  ExtGoodsTypeID;

	date   FltBeg;
	date   FltEnd;
	date   FltLotBeg;
	date   FltLotEnd;

	int16  FltCycle;     // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles; // Количество циклов
	long   Flags;
	int16  fWlOnly;

	CurDt       = Glb.CurDate;
	OrgName     = Glb.MainOrgName;
	Period      = formatperiod(FltBeg, FltEnd);
	FltLocName  = FltLocID.Name;
	FltGoodsTxt = FltGoodsID ? ("Товар: " + FltGoodsID.Name) :
		(FltGoodsGrpID ? ("Товарная группа: " + FltGoodsGrpID.Name) : "");
	FltSupplTxt = (FltSupplID ? ("Поставщик: " + FltSupplID.Name) : "");
	FltExtGTypeName = ExtGoodsTypeID.Name;

	double TotalQtty;
	double TotalPhQtty;
	double TotalCost;
	double TotalPrice;
	double TotalAmount;
	double TotalExtCost;
	double TotalExtPrice;
	long   TotalCount;

	iteration {
		long   RecNo;              //
		long   GrpNo;              //
		date   Dt;
		string CycleText[32];
		link   Bill        BillID;
		link   Article     ObjectID;
		link   OprKind     OpID;
		link   Goods       GoodsID;
		link   GoodsTaxGrp GoodsTaxGrpID;
		link   GoodsTaxGrp LotTaxGrpID;
		string OpName[48];
		int16  Sign;        // Знак операции @#{-1, 0, +1}

		double Qtty;
		double PhQtty;
		double SumCost;
		double SumPrice;
		double SumDiscount; //
		double Income;
		double Amount;
		double ExtCost;     // Сумма в ценах поступления, соответствующая FltExtGoodsTypeID
		double ExtPrice;    // Сумма в ценах реализации, соответствующая FltExtGoodsTypeID
		long   Count;

		double SumVat;
		double SumExcise;
		double SumSalesTax;
		date   BillDt;
		double BillQtty;
		double BillPhQtty;
		double BillAmount;
		double BillCostSum;
		double BillPriceSum;
		double BillDscntSum; //
		GrpTotal  = (OpID == -1) ? "Начальные остатки" : ((OpID == 10000) ? "Исходящие остатки" : "Итого:");
		UnitsName = (OpID == -1 || OpID == 10000) ? "позиций" : "документов";
		BillNo       = BillID.Code;
		Contragent   = BillID.ArticleID.Name;
		GoodsName    = GoodsID.Name;
		SignTxt      = if(Sign < 0) "Расход" else if(Sign > 0) "Приход" else "";
	}
}
//
// GoodsStruc
//
data GoodsStruc {
	declare "Destroy"
	declare "DOSSTUB"

	long   ID;                // Идентификатор структуры
	link   Global    Glb;
	link   Goods     GoodsID; // Идентификатор товара, к которому относится структура
	link   Warehouse LocID;   // Склад, для которого рассчитываются ожидаемые цены
	link   GoodsStruc ParentID; // Родительская структура
	string Name[48];          // Наименование структуры //
	string Symb[20];          // Символ структуры
	long   Flags;
	int16  fAllowCompl;       // Допускает комплектацию
	int16  fAllowDecompl;     // Допускает разукомплектацию
	int16  fPartitial;        // Частичная структура
	int16  fNamed;            // Именованная структура
	int16  fUncertainPrice;   // Цена EstPrice не может быть вычислена правильно поскольку не известны цены на один или более компонентов структуры.
	int16  fOutpWoVat;        // Выход без НДС
	int16  fFolder;           // Структура верхнего уровня.
	int16  fChild;            // Дочерняя структура (не может быть именованной)
	int16  fAutoWrOff;        // Автоматическое списание в техн сессиях (исключен ручной ввод)
	int16  fSubst;            // Структура подстановки (позиции, которые можно использовать вместо той, к которой относится структура)
	int16  fPresent;          // Подарок
	int16  fGiftPotential;    // Информировать кассира о близкой возможности предоставления подарка
	int16  fComplex;          // Комплекс
	int16  fPosModifier;      // POS-модификаторы (только в комбинации с fPartitial)
	int16  fOverlapGift;      // Подарок с "перекрытием": такой подарок назначается независимо от того,
		// что по некоторым позициям были выданы другие подарки. При этом два и более подарка с перекрытием взаимно исключаются.
	int16  Reserve;           // @alignment
	double CommDenom;         // Общий делитель для количества компонентов
	long   ItemsCount;        // Количество элементов структуры
	double EstPrice;          // Ожидаемая цена реализации товара,
		// вычисленная исходя из цен компонентов
	long   VariedPropObjType; // Тип объекта изменяющейся характиристики заголовочного
		// товара структуры и элементов структуры.
	date   PeriodLow;         // Начало периода действия структуры
	date   PeriodUpp;         // Конец периода действия структуры
	CurDt        = Glb.CurDate;
	OrgName      = Glb.MainOrgName;
	LocName      = LocID.Name;
	GoodsName    = GoodsID.Name;
	GoodsGrpName = GoodsID.GroupID.Name;
	UnitName     = GoodsID.UnitID.Name;
	PhUnitName   = GoodsID.PhUnitID.Name;

	iteration {
		long   LineNo;          // Порядковый номер строки [1..]
		link   Goods ItemID;    // Идентификаторо компонента
		link   Lot   LotID;     // Ссылка на последний лот по товару GoodsID на момент формирования отчета
		long   Flags;
		int16  fPercentVal;     // Количество задано в процентном отношении
		int16  fRoundDown;      // Отбрасывать дробную часть в количестве
		int16  fPhUnitVal;      // Количество задано в физических единицах
		int16  fUncertainPrice; // Цена компонента не определена
		int16  fAutoTsWrOff;    // Автосписание в технологических сессиях в случае, если этот товар не присутствует в строках сессии.
		int16  fQttyAsPrice;    // Только для нелимитированных ресурсов. Количество устанавливать в 1, а цену в процентах от суммы основного товара.
		int16  fMainItem;       // Основной компонент структуры (используется в производственных отчетах)
		int16  fFormula;        // Компонент содержит формулу для расчета количества
		int16  fSubPartStr;     // Вычитать количество этого компонента из количества основного товара применяя частичную структуру.
		int16  fGoodsGroup;     // Вместо товара в поле PPGoodsStrucItem::GoodsID установлена товарная группа (для подарков)
		int16  fIdentical;      // Для подарочных структур: заданное количество применимо только для одинаковых позиций.
		int16  fQueryExpLot;    // При автоматическом внесении компонента в документ как расходной строки запрашивать выбор лота.
		double Netto;           // Нетто (без отходов) количество компонента в составе структуры
		double Median;          // Количество единиц компонента
		double PerUnit;         // на PerUnit единиц составного товара
		string CMedian[32];     //
		double Price;           // Цена единицы компонента
		double SumPerUnit;      // Стоимость компонента на единицу составного товара
		ItemName       = ItemID.Name;          // Наименование компонента
		ItemUnitName   = ItemID.UnitID.Name;   // Наименование торговой единицы измерения компонента
		ItemPhUnitName = ItemID.PhUnitID.Name; // Наименование физической единицы измерения компонента
	}
}
//
// PPViewGoodsStruc
// Список товарных структур
//
data GoodsStrucList {
	declare "Destroy"
	declare "DOSSTUB"

	long   ID;                // Идентификатор структуры
	link   Global    Glb;
	link   Warehouse LocID;   // Склад, для которого рассчитываются ожидаемые цены
	link   GoodsGroup FltPrmrGroupID; //
	link   Goods FltPrmrGoodsID;      //
	link   GoodsGroup FltScndGroupID; //
	link   Goods FltScndGoodsID;      //
	long   FltFlags;                  //
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	LocName = LocID.Name;
	iteration {
		link   GoodsStruc GsID;      //
		link   GoodsStruc ParentID;  // Родительская структура
		link   Goods     GoodsID;    // Идентификатор товара, к которому относится структура
		link   Goods     ItemID;
		link   QuotKind  GiftQuotKindID; //
        double CommDenom;  //
        double GiftLimit;  //
        double GiftAmtRestrict; //
        double Median;     //
        double Denom;      //
        double Netto;      //
        long   StrucFlags; //
        long   ItemFlags;  //
		//string GoodsName[128];
		GoodsName = GoodsID.Name;
		ItemName = ItemID.Name;      // Имя компонента
		string SQtty[32];            //
		string Type[16];             //
		RQtty = tonumber(SQtty);
	}
}
//
// GoodsMov
// Отчет о движении товаров
//
data GoodsMov {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;

	date   FltBeg;
	date   FltEnd;
	string Period[32];

	long   Flags;
	int16  fLabelOnly;
	int16  fCostWoVat;

	CurDt        = Glb.CurDate;
	OrgName      = Glb.MainOrgName;
	FltLocName   = FltLocID.Name;
	FltSupplTxt  = FltSupplID    ? "Поставщик: " + FltSupplID.Name         : "";
	FltGrpTxt    = FltGoodsGrpID ? "Группа товаров: " + FltGoodsGrpID.Name : "";

	iteration {
		link   Goods GoodsID;
		string GoodsGrpName[128];
		double PhPerU;
		//
		// Начальный остаток
		//
		double InRest_Qtty;
		double InRest_Cost;
		double InRest_Price;
		string InRest_CQtty[32];
		InRest_PhQtty  = InRest_Qtty * PhPerU;
		InRest_AvCost  = InRest_Cost  / InRest_Qtty;
		InRest_AvPrice = InRest_Price / InRest_Qtty;
		//
		// Приход товара от поставщика
		//
		double Rcpt_Qtty;
		double Rcpt_Cost;
		double Rcpt_Price;
		string Rcpt_CQtty[32];
		Rcpt_PhQtty  = Rcpt_Qtty * PhPerU;
		Rcpt_AvCost  = Rcpt_Cost  / Rcpt_Qtty;
		Rcpt_AvPrice = Rcpt_Price / Rcpt_Qtty;
		//
		// Прочий приход
		//
		double _Rcpt_Qtty;
		double _Rcpt_Cost;
		double _Rcpt_Price;
		string _Rcpt_CQtty[32];
		_Rcpt_PhQtty  = _Rcpt_Qtty * PhPerU;
		_Rcpt_AvCost  = _Rcpt_Cost  / _Rcpt_Qtty;
		_Rcpt_AvPrice = _Rcpt_Price / _Rcpt_Qtty;
		//
		// Оплаченная реализация //
		//
		double Rlz_Qtty;
		double Rlz_Cost;
		double Rlz_Price;
		string Rlz_CQtty[32];
		Rlz_PhQtty  = Rlz_Qtty * PhPerU;
		Rlz_AvCost  = Rlz_Cost  / Rlz_Qtty;
		Rlz_AvPrice = Rlz_Price / Rlz_Qtty;
		//
		// Доходная реализация //
		//
		double SRlz_Qtty;
		double SRlz_Cost;
		double SRlz_Price;
		string SRlz_CQtty[32];
		SRlz_PhQtty  = SRlz_Qtty * PhPerU;
		SRlz_AvCost  = SRlz_Cost  / SRlz_Qtty;
		SRlz_AvPrice = SRlz_Price / SRlz_Qtty;
		//
		// Прочий расход
		//
		double Expnd_Qtty;
		double Expnd_Cost;
		double Expnd_Price;
		string Expnd_CQtty[32];
		Expnd_PhQtty  = Expnd_Qtty * PhPerU;
		Expnd_AvCost  = Expnd_Cost  / Expnd_Qtty;
		Expnd_AvPrice = Expnd_Price / Expnd_Qtty;
		//
		// Суммарный приход
		//
		double TRcpt_Qtty;
		double TRcpt_Cost;
		double TRcpt_Price;
		string TRcpt_CQtty[32];
		TRcpt_PhQtty  = TRcpt_Qtty * PhPerU;
		TRcpt_AvCost  = TRcpt_Cost  / TRcpt_Qtty;
		TRcpt_AvPrice = TRcpt_Price / TRcpt_Qtty;
		//
		// Суммарный расход
		//
		double TExpnd_Qtty;
		double TExpnd_Cost;
		double TExpnd_Price;
		string TExpnd_CQtty[32];
		TExpnd_PhQtty  = TExpnd_Qtty * PhPerU;
		TExpnd_AvCost  = TExpnd_Cost  / TExpnd_Qtty;
		TExpnd_AvPrice = TExpnd_Price / TExpnd_Qtty;
		//
		// Исходящий остаток
		//
		double OutRest_Qtty;
		double OutRest_Cost;
		double OutRest_Price;
		string OutRest_CQtty[32];
		OutRest_PhQtty  = OutRest_Qtty * PhPerU;
		OutRest_AvCost  = OutRest_Cost  / OutRest_Qtty;
		OutRest_AvPrice = OutRest_Price / OutRest_Qtty;

		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
	}
}
//
// GoodsMov2
//
data GoodsMov2 {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;
	link   OprKind    FltOpID;

	date   FltBeg;
	date   FltEnd;
	string Period[32];

	long   Flags;
	int16  fLabelOnly;
	int16  fCostWoVat;

	CurDt        = Glb.CurDate;
	OrgName      = Glb.MainOrgName;
	FltLocName   = FltLocID.Name;
	FltOpName    = FltOpID.Name;
	FltSupplTxt  = FltSupplID    ? "Поставщик: " + FltSupplID.Name : "";

	iteration {
		link   Goods GoodsID;

		long   OpID;
		double Qtty;
		double Cost;
		double Price;
		string CQtty[32];
		string OpName[48];

		AvCost    = Cost  / Qtty;
		AvPrice   = Price / Qtty;
		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
	}
}
//
// Кассовый узел
//
data CashNode {
	key    ID;
	string Name[32];
	long   CashType;
	long   CurSessID;
	date   CurDate;
	link   Warehouse LocID;
	link   ObjectTag GetTag(string tagSymb[20]); // @v11.3.7
}
//
// Кассовая сессия //
//
data CSession {
	key    ID;
	link   Global   Glb;
	link   CashNode CashNodeID;
	long   SuperSessID;
	long   SessNumber;
	long   CashNumber;
	date   Dt;
	time   Tm;
	double Amount;       // Полная суммы выручки по сессии
	double Discount;
	double AggrAmount;   // Сумма списания по кассовой сессии
	double AggrRest;
	double WrOffAmount;
	double Banking;      // Сумма, оплаченая по банковским картам
	double CSCardAmount; // Сумма, оплаченная корпоративными картами
}
//
// Структура для печати кассовых отчетов по кассовой сессии
//
data CSessionKM : CSession {
	INN  = Glb.INN;
	OKPO = Glb.OKPO;
	MainOrg = Glb.MainOrgExtName;
	RAddress = Glb.RAddress;
	Phone = Glb.Phone;
	Director = Glb.Director;
	Cashier = Glb.Cashier;
	AmountTxt = money2str(Amount, 64);
}
//
// Кассовый чек
//
data CCheck {
	key    ID;                    // @id
	long   Code;                  // Номер чека
	long   CashID;                // Для синхронной сессии - ИД кассового узла, для асинхронной - номер кассового аппарата.
	link   User     UserID;       //
	link   CSession SessID;       // Кассовая сессия, которой принадлежит чек
	link   SCard    SCardID;      //
	link   SCard    AddCrdCardID; // Дополнительная кредитная карта, используемая для оплаты чека.
	link   Article  AgentID;      // Агент по чеку
	link   CCheck   LinkCheckID;  // Ссылка на связанный чек (например, чек заказа стола).
	link   Location DlvrLocID;    // Ссылка на адрес доставки (для чеков с доставкой)
	long   TableNo;               // Номер стола
	int16  GuestCount;            // Количество гостей за столом
	int16  Reserve;               // @alignment
	long   Flags;                 // Флаги чека
	int16  fPrinted;              // Чек отпечатан
	int16  fBanking;              // Чек оплачен банковской картой
	int16  fIncorpCard;           // Чек оплачен корпоративной кредитной картой
	int16  fSuspended;            // Отложенный чек
	int16  fOrder;                // Чек заказа стола
	int16  fDelivery;             // Чек требует доставки
	int16  fClosedOrder;          // Закрытый заказ (выполненная доставка)
	int16  fReturn;               // Чек возврата
	date   Dt;                    // Дата проведения чека
	time   Tm;                    // Время проведения чека
	double Amount;                // Общая сумма чека (сумма к оплате).
	double Discount;              // Сумма скидки (включена в общую сумму чека).

	double CashAmount;            // Сумма оплаты наличными
	double BnkAmount;             // Сумма оплаты через банк
	double CCrdAmount;            // Сумма оплаты корпоративной кредитной картой

	double AddCrdCardPaym;        // Сумма, оплаченная по дополнительной кредитной карте (AddCrdCardID)
	date   CreationDt;            // Дата создания чека
	time   CreationTm;            // Время создания чека
	date   OrderStartDt;          // (Для чеков заказа стола) дата начала обслуживания //
		// Для чеков с доставкой - планируемая дата доставки
	time   OrderStartTm;          // (Для чеков заказа стола) время начала обслуживания //
		// Для чеков с доставкой - планируемое время доставки
	date   OrderEndDt;            // (Для чеков заказа стола) дата завершения обслуживания //
	time   OrderEndTm;            // (Для чеков заказа стола) время завершения обслуживания //
	string OrderStartTxt[32];     // Текстовое представление даты/времени начала обслуживания (исполнения доставки)
	string OrderEndTxt[32];       // Текстовое представление даты/времени завершения обслуживания //
	string CreationTxt[32];       // Текстовое представление даты/времени создания чека //
	string SCardCode[24];         // Номер карты (SCardID)
	//
	// Descr: Функция извлекает строку расширения из кассового чека по символьной мнемонике.
	//   Список мнемоник вот он:
	//     "Memo"
	//     "Sign"
	//     "EgaisUrl"
	//     "RemoteProcessingTa"
	//     "ChZnProcessingTag"
	//     "BuyerINN"
	//     "BuyerName"
	//     "BuyerPhone"
	//     "BuyerEMail"
	//     "Uuid"
	//     "PrescrDate"
	//     "PrescrSerial"
	//     "PrescrNumber"
	//     "EgaisProcessingTag"
	//     "SourceSymb"
	//     "OuterIdent"
	//     "OuterExtTag"
	//     "LinkBillUuid"
	//
	string GetExtText[512](string symb[20]); // @v11.8.12
}
//
// Список кассовых чеков
// @v7.0.9 Verification needed
// @v8.2.10 Verification needed
// @v8.4.9 Verification needed
//
data CCheckView {
	declare "Destroy"

	link   Global     Glb;
	link   CashNode   FltCashNodeID;
	long   FltCashNumber;
	link   Goods      FltGoodsID;
	link   GoodsGroup FltGoodsGrpID; //
	link   SCard      FltSCardID;
	link   Article    FltAgentID;    // Агент, по которому фильтруется отчет
	double AmountQuant;              // Квант группировки чеков по сумме или кол-ву
	date   FltBeg;
	date   FltEnd;
	long   FltFlags;    // Флаги фильтрации
	/*
		@todo Добавить поля из фильтра
	*/
	int16  FltGrp; // 0 (none); 1 (hour); 2 (date); 3 (day of week);
		// 4 (day of week and hour); (5 (machine); 6 (card); 7 (amount);
		// 8 (quantity); 9 (goods); 10 (cashier); 11 (agent)
	int16  FltTableNo;     // Номер стола
	int16  fSuspendedOnly; // Только отложенные чеки
	int16  fGiftOnly;      // Только чеки с подарками
	int16  fOrderOnly;     // Только чеки заказа столов
	int16  fDeliveryOnly;  // Только чеки с доставкой
	Period  = formatperiod(FltBeg, FltEnd);
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltCashNodeName = FltCashNodeID.Name;
	FltAgentName = FltAgentID.Name;

	GrpngText = (
		if(FltGrp == 1)       ("по часам")
		else if(FltGrp == 2)  ("по дням")
		else if(FltGrp == 3)  ("по дням недели")
		else if(FltGrp == 4)  ("по дням недели и часам")
		else if(FltGrp == 5)  ("по аппаратам")
		else if(FltGrp == 6)  ("по карточкам")
		else if(FltGrp == 7)  ("по процентам скидки")
		else if(FltGrp == 8)  ("по сумме")
		else if(FltGrp == 9)  ("по количеству")
		else if(FltGrp == 10) ("по товарам")
		else if(FltGrp == 11) ("по товару и дате")
		else if(FltGrp == 12) ("по кассирам")
		else if(FltGrp == 13) ("по агентам")
		else if(FltGrp == 14) ("по количеству строк в чеке")
		else if(FltGrp == 15) ("по номеру отдела")
		else if(FltGrp == 16) ("по количеству гостей")
		else if(FltGrp == 17) ("по номеру стола")
		else if(FltGrp == 18) ("по агентам и часам")
		else if(FltGrp == 19) ("по кассовым узлам")
		else if(FltGrp == 20) ("по агентам и товарам")
		else if(FltGrp == 21) ("по кассирам и товарам")
		else if(FltGrp == 22) ("по адресам доставки")
		else if(FltGrp == 23) ("по товару и серии карт")
		else if(FltGrp == 24) ("по сумме и товару")
		else if(FltGrp == 25) ("по агенту-товару-серии карт")
		else if(FltGrp == 26) ("по товару-дате-серии")

	);
	GrpngHdrText = (
		if(FltGrp == 1)       ("Время")
		else if(FltGrp == 2)  ("Дата")
		else if(FltGrp == 3)  ("День недели")
		else if(FltGrp == 4)  ("День недели и час")
		else if(FltGrp == 5)  ("Касса")
		else if(FltGrp == 6)  ("Карта")
		else if(FltGrp == 7)  ("Процент скидки")
		else if(FltGrp == 8)  ("Сумма")
		else if(FltGrp == 9)  ("Количество")
		else if(FltGrp == 10) ("Товар")
		else if(FltGrp == 11) ("Товар/дата")
		else if(FltGrp == 12) ("Кассир")
		else if(FltGrp == 13) ("Агент")
		else if(FltGrp == 14) ("Количество строк")
		else if(FltGrp == 15) ("Номер отдела")
		else if(FltGrp == 16) ("Количество гостей")
		else if(FltGrp == 17) ("Номер стола")
		else if(FltGrp == 18) ("Агент/час")
		else if(FltGrp == 19) ("Кассовый узел")
		else if(FltGrp == 20) ("Агент/товар")
		else if(FltGrp == 21) ("Кассир/товар")
		else if(FltGrp == 22) ("Адрес доставки")
		else if(FltGrp == 23) ("Товару/серия карт")
		else if(FltGrp == 24) ("Сумма/товар")
		else if(FltGrp == 25) ("Агент/товар/серия")
	);
	double VATRate1;
	double VATRate2;
	double VATRate3;
	double VATRate4;
	double VATRate5;
	double PTrnovr1;
	double PTrnovr2;
	double PTrnovr3;
	double PTrnovr4;
	double PTrnovr5;
	double Discount1;
	double Discount2;
	double Discount3;
	double Discount4;
	double Discount5;

	VATText1 = if(PTrnovr1 != 0) ("НДС " + format(VATRate1, ~<.0) + "%") else ("");
	VATText2 = if(PTrnovr2 != 0) ("НДС " + format(VATRate2, ~<.0) + "%") else ("");
	VATText3 = if(PTrnovr3 != 0) ("НДС " + format(VATRate3, ~<.0) + "%") else ("");
	VATText4 = if(PTrnovr4) ("НДС " + format(VATRate4, ~<.0) + "%") else ("");
	VATText5 = if(PTrnovr5) ("НДС " + format(VATRate5, ~<.0) + "%") else ("");
	PTrnovrText1 = if(PTrnovr1 != 0) ("Оборот: " + format(PTrnovr1, ~>12.2$)) else ("");
	PTrnovrText2 = if(PTrnovr2 != 0) ("Оборот: " + format(PTrnovr2, ~>12.2$)) else ("");
	PTrnovrText3 = if(PTrnovr3 != 0) ("Оборот: " + format(PTrnovr3, ~>12.2$)) else ("");
	PTrnovrText4 = if(PTrnovr4 != 0) ("Оборот: " + format(PTrnovr4, ~>12.2$)) else ("");
	PTrnovrText5 = if(PTrnovr5 != 0) ("Оборот: " + format(PTrnovr5, ~>12.2$)) else ("");
	DiscountText1 = if(PTrnovr1 != 0) ("Скидка: " + format(Discount1, ~>12.2$)) else ("");
	DiscountText2 = if(PTrnovr2 != 0) ("Скидка: " + format(Discount2, ~>12.2$)) else ("");
	DiscountText3 = if(PTrnovr3 != 0) ("Скидка: " + format(Discount3, ~>12.2$)) else ("");
	DiscountText4 = if(PTrnovr4 != 0) ("Скидка: " + format(Discount4, ~>12.2$)) else ("");
	DiscountText5 = if(PTrnovr5 != 0) ("Скидка: " + format(Discount5, ~>12.2$)) else ("");

	iteration {
		link   CCheck  CheckID;
		link   SCard   GSCardID;    // ИД карты (для группировки по картам)
		link   Goods   Goods1ID;    // ИД товара1 (для корреляции товаров по кассовым чекам)
		link   Goods   Goods2ID;    // ИД товара2 (для корреляции товаров по кассовым чекам)
		link   Article CcAgentID;   // Агент по чеку. При группировке, включающей в себя агента, это поле инициализируется!
		double Amount;
		double Discount;
		double CashAmount; // Сумма оплаты наличными
		double BnkAmount;  // Сумма оплаты через банк
		double CCrdAmount; // Сумма оплаты корпоративной кредитной картой
		long   GCount;
		date   GDate;
		double GPctPart;
		double GAmount;
		double GDiscount;
		double GQtty;
		string GrpngItemText[128];
		// @todo Суммы наличных, безналичных оплат и оплат по корп картам

		SessNumber   = CheckID.SessID;
		CashNumber   = CheckID.CashID;
		CheckNumber  = CheckID.Code;
		SCard        = CheckID.SCardID;
		Dt   = CheckID.Dt;
		Tm   = CheckID.Tm;
		TmTxt = (format(Tm, ~<&N));
		SCardCode    = GSCardID ? GSCardID.Code : CheckID.SCardCode;
		GSCardSer    = GSCardID.SeriesID.Name;   // Наименование серии карты (только для группировки по картам)
		GSCardOwner  = GSCardID.OwnerReqID.Name; // Наименование владельца карты (только для группировки по картам)
		GoodsName1   = Goods1ID.Name;            // Наименование коррелирующего товара 1
		GoodsName2   = Goods2ID.Name;            // Наименование коррелирующего товара 2
		DlvrAddr  = CheckID.DlvrLocID.Addr;      // Адрес доставки
		DlvrPhone = CheckID.DlvrLocID.Phone;     // Контактный телефон для доставки
		OrderStartTxt = CheckID.OrderStartTxt;   // Время начала обслуживания по заказу (время доставки)
		OrderEndTxt   = CheckID.OrderEndTxt;     // Время завершения обслуживания по заказу
		//
		// Descr: Если отчет строится с группировкой, включающей серийный номер строки чека,
		//   то эта функция вернет соответствующий строке серийный номер.
		//
		string GetSerial[32]();
	}
}

data CCheckViewDetail {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	date   FltBeg;      //
	date   FltEnd;      //
	long   FltFlags;    // Флаги фильтрации
	iteration {
		link   CCheck CheckID;  // Идентификатор чека
		long   Code;            // Номер чека
		link   User UserID;     //
		link   CSession SessID; //
		link   SCard SCardID;   //
		date   Dt;              //
		time   Tm;              //
		long   MachineN;        // Для синхронный узлов - идентификатор кассового узла, для асинхронных - номер кассовой машины
		long   CcFlags;         // Флаги записи чека
		long   LinesCount;      // Количество товарных строк в этом чеке
		double CcAmount;        // Сумма чека
		double CcDiscount;      // Скидка по чеку

		link   Goods GoodsID;
		int16  RByCheck;        // Счетчик строк по чеку
		int16  LineQueue;       // Порядковый номер очередности подачи
		int16  lfPrinted;       // Строка отправлена на принтер для изготовления //
		int16  lfGift;          // Товар является подарком
		int16  lfUsedByGift;    // По строке был предоставлен подарок
		int16  lfQuotedByGift;  // Подарок по строке был предоставлен в виде котировочной цены
		int16  lfPartOfComplex; // Строка является частью комплексного товара
		int16  lfModifier;      // Признак модификатора предыдущего товара. На печати следует выделять такой товар.
		long   LnFlags;         // Флаги строки чека
		long   LnDiv;           // Номер отдела
		double LnPrice;         // Цена торговой единицы товара (без скидки)
		double LnDiscount;      // Скидка по строке
		double LnQuantity;      // Количество торговых единиц в строке
		double LnAmount;        // Полная сумма строки
	}
}
//
// Детальная информация о кассовом чеке
//
// @attention: Данная структура заполняется не непосредственно из базы данных, а через внутреннюю структуру
//   кассовой панели. В связи с этим поле CheckID может оказаться равным 0 и, кроме того, одноименные с CCheck
//   поля могут быть отличны от аналогов структуры CCheck.
//
// @v7.0.10 Verification needed
// @v7.1.5  Verification needed
// @v8.2.2  Verification needed
//
data CCheckDetail {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   CashNode   CashNodeID;
	link   Article    AgentID; // Агент (официант)
	link   CCheck     CheckID; //
	link   CCheck     LinkCheckID; // Ссылка на связанный чек (чек заказа)
	link   Location   DlvrLocID;   // ИД Адреса доставки
	long   CheckNumber;        // Номер чека
	date   CheckDt;            // Дата проведения чека
	time   CheckTm;            // Время проведения чека
	double CheckAmount;        // Полная сумма чека
	double CheckDiscount;      // Полная скидка по чеку
	double BnkAmt;             // @unused @todo @v6.8.0 Сумма чека, оплаченная безналично (банк)
	double CrdAmt;             // @unused @todo @v6.8.0 Сумма чека, оплаченная по корпоративной кредитной карте
	double OrderPrepay;        // Предоплата по заказу. Это значение заполняется и для чека заказа
		// (в этом случае OrderPrepay == CheckAmount) и для чека обслуживания по заказу.
	double UsableBonus;        // Сумма бонуса, которая может быть использована для оплаты чека
	double UsableCredit;       // Сумма с кредитной карты, которая может быть использована для оплаты чека
	string CheckSCardCode[24]; // Номер карты, с которой связан чек
	int32  TableNo;            // Номер столика
	int16  GuestCount;         // Количество гостей за столом
	int16  Reserve;            // @alignment
	int16  fPrinted;           // Чек отпечатан
	int16  fBanking;           // Чек оплачен банковской картой
	int16  fIncorpCard;        // Чек оплачен корпоративной кредитной картой
	int16  fSuspended;         // Отложенный чек
	int16  fOrder;             // Чек заказа стола
	int16  fDelivery;          // Чек требует доставки
	int16  fClosedOrder;       // Закрытый заказ (выполненная доставка)
	int16  fReturn;            // Чек возврата
	date   OrderStartDt;       //
	time   OrderStartTm;       //
	date   OrderEndDt;         //
	time   OrderEndTm;         //
	date   CreationDt;         // Дата создания чека
	time   CreationTm;         // Время создания чека
	string OrderStartTxt[32];  // Текстовое представление даты/времени начала обслуживания (исполнения доставки)
	string OrderEndTxt[32];    // Текстовое представление даты/времени завершения обслуживания //
	string OrderCode[16];      // Специальный штрихкод, позволяющий идентифицировать заказ.
	string CreationTxt[32];    // Текстовое представление даты/времени создания чека //
	string Memo[256];          // Примечание к чеку
	string DlvrAddr[128];      // Адрес доставки (fDelivery != 0)
	string DlvrPhone[48];      // Контактный телефон доставки (fDelivery != 0)
	string DlvrContact[64];    // Текст контактной информации (fDelivery != 0)
	//
	// Возвращает строку коду чека с префексом отложенного чека, заданным в конфигурации оборудования //
	//
	string GetPrefixedCode[32]();
	//
	// Возвращает печатную версию строки коду чека с префексом отложенного чека, заданным в конфигурации оборудования //
	//
	string GetPrintablePrefixedCode[32]();
	//
	// Возвращает наименование стола, если значение TableNo является символом записи
	//   в справочнике столов ресторанного зала. В противном случае возвращает строковое представление TableNo.
	//
	string CTableName[48]();

	CurDt      = Glb.CurDate;
	OrgName    = Glb.MainOrgName;
	FltCashNodeName = CashNodeID.Name;
	AgentName  = AgentID.Name;                    // Имя агента (официанта)
	POrderCode = PrintableBarcode(OrderCode, 39); // Печатная версия спец штрихкода для идентификации заказа.

	iteration {
		link   Goods GoodsID;
		int16  LineGrpN;       // Номер группы (если строка сгруппирована)
		int16  LineQueue;      // Порядковый номер очередности подачи
		int16  fPrinted;       // Строка отправлена на принтер для изготовления //
		int16  fGift;          // Товар является подарком
		int16  fUsedByGift;    // По строке был предоставлен подарок
		int16  fQuotedByGift;  // Подарок по строке был предоставлен в виде котировочной цены
		int16  fPartOfComplex; // Строка является частью комплексного товара
		int16  fModifier;      // Признак модификатора предыдущего товара. На печати следует выделять такой товар.
		double Price;          // Цена торговой единицы товара (без скидки)
		double Discount;       // Скидка по строке
		double Quantity;       // Количество торговых единиц в строке
		double Amount;         // Полная сумма строки

		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
	}
}
//
//
//
data CCheckPacket {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   CashNode   PosNodeID;
	link   Article    AgentID; // Агент (официант)
	link   CCheck     CheckID; // CCheck
	link   CCheck     LinkCheckID; // Ссылка на связанный чек (чек заказа)
	link   SCard      SCardID; // Карта, связанная с чеком
	long   CheckNumber;        // Номер чека
	date   CheckDt;            // Дата проведения чека
	time   CheckTm;            // Время проведения чека
	double CheckAmount;        // Полная сумма чека
	double CheckDiscount;      // Полная скидка по чеку
	double BnkAmt;             // Сумма чека, оплаченная безналично (банк)
	double CrdAmt;             // Сумма чека, оплаченная по корпоративной кредитной карте
	int32  TableNo;            // Номер столика
	int16  GuestCount;         // Количество гостей за столом
	int16  fOrder;             // Признак чека заказа
	date   OrderStartDt;       //
	time   OrderStartTm;       //
	string OrderStartTmText[20]; //
	date   OrderEndDt;         //
	time   OrderEndTm;         //
	string OrderEndTmText[20]; //

	string Memo[256];          // Примечание к чеку

	CurDt     = Glb.CurDate;
	OrgName   = Glb.MainOrgName;
	PosNodeName = PosNodeID.Name;
	AgentName = AgentID.Name;  // Имя агента (официанта)
	SCardCode = SCardID.Code;  // Номер карты, с которой связан чек
	SCardOwnerName = SCardID.OwnerReqID.Name; // Иая владельца карты

	iteration {
		link   Goods GoodsID;
		double Price;          // Цена торговой единицы товара (без скидки)
		double Discount;       // Скидка по строке
		double Quantity;       // Количество торговых единиц в строке
		double Amount;         // Полная сумма строки
		string Serial[24];     // Серийный номер проданного товара

		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
	}
}
//
// Список кассовых сессий
//
data CSessionView {
	declare "Destroy"

	link   Global     Glb;
	link   CSession   FltSuperSessID;
	link   CashNode   FltCashNodeID;
	long   FltCashNumber;
	date   FltBeg;
	date   FltEnd;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	FltCashNodeName = FltCashNodeID.Name;
	iteration {
		link CSession SessID;
		CashNodeName    = SessID.CashNodeID.Name;
		SessNumber      = SessID.SessNumber;
		CashNumber      = SessID.CashNumber;
		Dt      = SessID.Dt;
		Tm      = SessID.Tm;
		Amount  = SessID.Amount;
		Banking = SessID.Banking;
		Discount        = SessID.Discount;
		AggrAmount      = SessID.AggrAmount;
		AggrRest        = SessID.AggrRest;
		WrOffAmount     = SessID.WrOffAmount;
		double WrOffRcptAmount;
		double Income;
		short  SessIncomplete;
		TmTxt = (format(Tm, ~<&N));
		long   CheckCount;
		double WORetAmount;
		double RetAmount;
	}
}
//
// Структура для печати кассовых отчетов по списку кассовых сессий
//
data CSessionViewKM : CSessionView {
	INN = Glb.INN;
	OKPO = Glb.OKPO;
	RAddress = Glb.RAddress;
	Phone = Glb.Phone;
	Director = Glb.Director;
	Cashier = Glb.Cashier;
}
//
// Излишки по кассовым сессиям
//
data CSessExc {
	declare "Destroy"

	link   Global     Glb;
	link   CSession   FltSessID;
	link   CashNode   FltCashNodeID;
	link   GoodsGroup FltGoodsGrpID;
	link   Goods      FltGoodsID;

	date   FltBeg;
	date   FltEnd;
	int16  FltSessNum;
	int16  FltSessIncompl;
	date   FltSessBegDt;
	time   FltSessBegTm;
	date   FltSessEndDt;
	time   FltSessEndTm;
	long   FltFlags;
	int16  fNoZeroAltGoods; // Если этот флаг установлен то выбираются все        //
		// строки, содержащие альтернативный товар, при этом игнорируется наличия //
		// излишков по этим строкам.                                              //

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	FltCashNodeName = FltCashNodeID.Name;

	TxtSessInfo =
		if(FltSessNum > 1) (
			"Сессии:" * format(FltSessNum, ~<$S) * "    " *
			format(FltSessBegDt, ~<#G) * format(FltSessBegTm, ~<&H) *
			"-" * format(FltSessEndDt, ~<#G) * format(FltSessEndTm, ~<&H)
		)
		else if(FltSessNum == 1) (
			"Сессия:" * format(FltSessBegDt, ~<#) * format(FltSessBegTm, ~<&H) *
			((FltSessIncompl) ? "- не закрыта (" + format(FltSessNum, ~<$S)+")" : "- закрыта")
		)
		else
			"";
	iteration {
		link   Goods GoodsID;
		link   Goods AltGoodsID;
		double Qtty;
		double Rest;
		double Price;
		double Sum;
		double RestSum;

		GoodsName = GoodsID.Name;
		Barcode   = GoodsID.SingleBarCode;
		UnitName  = GoodsID.UnitID.Name;

		AltGoodsName = AltGoodsID.Name;
		AltBarcode   = AltGoodsID.SingleBarCode;
		double AltGoodsPrice;               // Цена альтернативного товара
		double AltGoodsQtty;                // Количество списанного альтернативного товара
		double AltGoodsSum;                 // Сумма списанного альтернативного товара
		double AltDiff;                     // Результат от подстановки альтернативного товара AltGoodsSum-Price*AltGoodsQtty
	}
}
//
//
//
data AlcoRepConfig {
	key    ID;
	link   OprKind RcptOpID;             // Операция прихода от поставщика
	link   OprKind SaleRetOpID;          // Операция возврата от покупателя
	link   OprKind RcptEtcOpID;          // Операция прочего прихода
	link   OprKind ExpndOpID;            // Операция расхода
	link   OprKind SupplRetOpID;         // Операция возврата поставщику
	link   OprKind ExpndEtcOpID;         // Операция прочего расхода
	link   OprKind IntrExpndOpID;        // Операция внутреннего перемещения
	link   GoodsGroup AlcGoodsGrpID;     // Товарная группа, ограничивающая алкогольную продукцию
	link   GoodsGroup BeerGoodsGrpID;    // Товарная группа, ограничивающая пивную продукцию
	link   TagType CategoryTagID;        // Тег, определяющий категорию вида продукции (имеет приоритет перед CategoryClsDim)
	link   RegisterType AlcLicRegTypeID; // Тип регистра алкогольной лицензии
	link   RegisterType KppRegTypeID;    // Тип регистра КПП. Если 0, то используется зарезервированный тип регистра для КПП.
	link   TagType WhsExpTagID;          // Тег персоналии Оптовый покупатель/Экспорт (1/2)
	link   TagType ManufImpTagID;        // Тег персоналии Производитель/Импортер
	link   RegisterType TransportLicRegTypeID;
	link   GoodsClass AlcGoodsClsID;
	int    CategoryClsDim;               // PPGdsCls2::e... Размерность класса, определяющая категорию алкогольной продукции
	int    VolumeClsDim;                 // PPGdsCls2::e... Размерность класса, определяющая объем алкоголя в одной торговой единице
	int    ProofClsDim;                  // PPGdsCls2::e... Размерность класса, определяющая крепость алкоголя в одной торговой единице (в объемных %)
	string SubstCategoryCode[8];         // Код алкогольной продукции, используемый в некоторых случаях вместо любого иного кода
}
//
// Анализ товарных операций
//
data TrfrAnlzBase {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	date   FltBeg;
	date   FltEnd;
	link   OprKind    FltOpID;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   Article    FltObjectID;
	link   GoodsGroup FltGoodsGrpID;
	link   Goods      FltGoodsID @fgid;

	long   Flags;
	int16  fLabelOnly;
	int16  Ord;       // For internal use
	int16  Grp;       // 0 (none); 1 (goods); 2 (object); 3 (goods, object);
	//                   4 (goods, object, date); 5 (goods object date); 6 (goods bill);
	//                   7 (date, object, agent, goods); 8 (goods date)
	int16  Sgg;       // GoodsID  subst: 1 (generic goods); 2 (group); 3 (manuf)
	int16  Sgp;       // PersonID subst: 1 (city); 2 (region); 3 (country); 4 (category); 5(mainorg); 6(billagent); 7(vesselagent);
	int16  Sgd;       // Dt       subst: 1 (month); 2 (quart); 3 (year)
	int16  CtValKind; // Для кросстаб отчета - вид табулируемой величины
		// 1 - Cost, 2 - NetPrice, 3 - Income, 4 - PctIncome, 5 - LocCount, 6 - PctMargin
	int16  Reserve;   // @alignment

	Period  = formatperiod(FltBeg, FltEnd);

	iteration {
		link   Bill    BillID;
		link   Goods   GoodsID;
		link   OprKind OpID;
		link   Lot       LotID;
		link   Warehouse LocID;
		link   Location  DlvrLocID; // Инициализируется только если задана группировка по (дате, контрагенту, агенту, товару) или
			// при группировке, включающей контрагента выставлен флаг "Разбивать контрагентов по адресам доставки"
		link   Article   ObjectID;
		link   Article   _AgentID;  // Инициализируется только если задана группировка по агенту. В противном случае следует
			// использовать BillID.AgentID
		link   Person    ContragentID;
		date   Dt;
		double Qtty;
		double Rest;            // GoodsCard
		double PhQtty;
		double Cost;
		double Price;
		double Discount;
		double Amount;
		double SalQtty;
		double SalAmt;
		double PVat;            // Сумма НДС в ценах реализации (инициализируется если в фильтре установлен флаг TrfrAnlzFilt::fCalcVat)
		long   RptGrpngVal;
		long   LocCount;        // Количество адресов доставки, попадающее в группировку
		double CtVal;           // Кросстабулируемое значение
		string GoodsText[128];  //
		string PersonText[228]; //
		string DtText[32];
		//
		// Descr: Возвращает значение дополнительного показателя, рассчитанного в соответствии
		//   со специальным критерием фильтра.
		// Параметр extValId определяет номер дополнительного показателя. Сейчас возможно
		//   только значение 1.
		//
		double GetExtVal(int extValId);
		//
		// Descr: Возвращает идентификатор документа, связанного с BillID (если возможно: нет группировки,
		//   условия фильтрации предполагают наличие такого документа).
		//
		link   Bill GetLinkBillID();
		//
		// Descr: Возвращает значение показателя из связанного документа (если возможно: условия фильтрации
		//   предполагают наличие таких показателей).
		// ARG(valueId IN): Идентификатор показателя:
		//   1 - количество (quantity)
		//   2 - сумма в ценах поступления (cost)
		//   3 - сумма в ценах реализации (price)
		//
		double GetLinkValue(int valueId);
	}
}
//
//
//
data TrfrAnlz : TrfrAnlzBase {
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltLocName      = FltLocID ? FltLocID.Name : "Все склады";
	FltGoodsName    = FltGoodsID.Name;
	FltGoodsGrpName = FltGoodsGrpID.Name;
	FltOpName       = FltOpID.Name;
	FltSupplName    = FltSupplID.Name;

	iteration {
		GoodsName  = GoodsID.Name;
		BillCode   = BillID.Code;
		OpName     = OpID.Name;
		ObjectName = ObjectID.Name;
	}
}
//
// Структура, содержащая поля, ссылающиеся на лот.
// Данные по этой структуре рассчитываются несколько медленнее, чем
// по TrfrAnlz из-за необходимости в каждой итерации обращаться к таблице Receipt
//
data TrfrAnlz_Lot : TrfrAnlz {
	iteration {
		LotDate = LotID.Dt;
		LotBillCode = LotID.BillID.Code;
		LotClb = LotID.CLB; // ГТД по лоту
	}
}
//
//
//
data TrfrAnlz_G : TrfrAnlzBase {
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltLocName     = FltLocID ? FltLocID.Name : "Все склады";
	FltGoodsName   = FltGoodsID.Name;
	FltGoodsGrpName = FltGoodsGrpID.Name;
	FltOpName = FltOpID.Name;

	GrpngText = (
			if(Grp == 1) ("по товару")
			else if(Grp == 2) ("по контрагенту")
			else if(Grp == 3) ("по контрагенту и дате")
			else if(Grp == 4) ("по товару и контрагенту")
			else if(Grp == 5) ("по товару, контрагенту и дате")
			else if(Grp == 6) ("по товару и документу")
			else if(Grp == 7) ("по дате, контрагенту, агенту и товару")
			else if(Grp == 8) ("по товару и дате")
			else if(Grp == 9) ("по документу и контрагенту")
			else if(Grp == 10) ("по товару и поставщику")
		);
	ExtraInfo = (
			if(Grp == 1) ("Контрагент: " + FltObjectID.Name)
			else if(Grp == 2) ("Товар: " + FltGoodsID.Name)
			else ""
		);
	GrpngHdrText = (
			if(Grp == 1) ("Товар")
			else if(Grp == 2) ("Контрагент")
			else if(Grp == 3) ("Контрагент")
			else if(Grp == 4) ("Товар и контрагент")
			else if(Grp == 5) ("Товар, контрагент и дата")
			else if(Grp == 8) ("Товар")
		);
	GrpngHdrText_1 = (
			if(Grp == 1) ("Товар")
			else if(Grp == 2) ("Контрагент")
			else if(Grp == 3) ("Контрагент")
			else if(Grp == 4) ("Товар")
			else if(Grp == 5) ("Товар")
			else if(Grp == 6) ("Товар")
			else if(Grp == 7) ("Дата")
			else if(Grp == 8) ("Товар")
		);
	GrpngHdrText_2 = (
			if(Grp == 3) ("Дата")
			else if(Grp == 4) ("Контрагент")
			else if(Grp == 5) ("Контрагент")
			else if(Grp == 6) ("Документ")
			else if(Grp == 7) ("Контрагент")
			else if(Grp == 8) ("Дата")
		);
	GrpngHdrText_3 = (
			if(Grp == 5) ("Дата")
			else if(Grp == 7) ("Агент")
		);
	GrpngHdrText_4 = (
			if(Grp == 7) ("Товар")
		);

	iteration {
		GrpngItemText = (
			if(Grp == 1) (GoodsText)
			else if(Grp == 2) (PersonText)
			else if(Grp == 3) (PersonText + ", " + DtText)
			else if(Grp == 4) (GoodsText + ", " + PersonText)
			else if(Grp == 5) (GoodsText + ", " + PersonText + ", " + DtText)
			else if(Grp == 8) (GoodsText)
		);
		GrpngItemText_1 = (
			if(Grp == 1) (GoodsText)
			else if(Grp == 2) (PersonText)
			else if(Grp == 3) (PersonText)
			else if(Grp == 4) (GoodsText)
			else if(Grp == 5) (GoodsText)
			else if(Grp == 6) (GoodsText)
			else if(Grp == 7) (DtText)
			else if(Grp == 8) (GoodsText)
		);
		GrpngItemText_2 = (
			if(Grp == 1) ("")
			else if(Grp == 2) ("")
			else if(Grp == 3) (DtText)
			else if(Grp == 4) (PersonText)
			else if(Grp == 5) (PersonText)
			else if(Grp == 6) (BillID.Code)
			else if(Grp == 7) (PersonText)
			else if(Grp == 8) (DtText)
		);
		GrpngItemText_3 = (
			if(Grp == 1) ("")
			else if(Grp == 2) ("")
			else if(Grp == 3) ("")
			else if(Grp == 4) ("")
			else if(Grp == 5) (DtText)
			else if(Grp == 6) ("")
			else if(Grp == 7) (_AgentID.Name)
			else if(Grp == 8) ("")
		);
		GrpngItemText_4 = (
			if(Grp == 1) ("")
			else if(Grp == 2) ("")
			else if(Grp == 3) ("")
			else if(Grp == 4) ("")
			else if(Grp == 5) ("")
			else if(Grp == 6) ("")
			else if(Grp == 7) (GoodsText)
			else if(Grp == 8) ("")
		);
	}
}
//
//
//
data TrfrAnlz_DPAG : TrfrAnlz_G {
	iteration {
		DlvrAddress = DlvrLocID.Addr;
		DlvrCity    = DlvrLocID.CityID.Name;
		GoodsGrpName =
			if(Sgg == 0)
				GoodsID.GroupID.Name
			else if(Sgg == 2)
				GoodsText
			else
				"";
	}
}
//
//
//
data GoodsCard : TrfrAnlzBase {
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltLocName     = FltLocID ? FltLocID.Name : "Все склады";
	FltGoodsName   = FltGoodsID.Name;
	FltBarcode     = FltGoodsID.SingleBarCode;
	FltGoodsUnit   = FltGoodsID.UnitID.Name;
	FltGoodsPhUnit = FltGoodsID.PhUnitID.Name;
	FltGoodsManuf  = FltGoodsID.ManufID.Name;
	FltGoodsTaxGrp = FltGoodsID.TaxGrpID ? FltGoodsID.TaxGrpID.Name : ("*" * FltGoodsID.GroupID.TaxGrpID.Name);
	iteration {
		BillCode = BillID.Code;
		LocName  = LocID.Name;
		OpName   = OpID.Name;
		ObjectName = ObjectID.Name;
		ExpendQtty = Discount;
		IncomeQtty = Qtty;
	}
}
//
//
//
data AlcoTrnovrJournal : TrfrAnlzBase {
	OrgName = Glb.MainOrgName;
	FltLocName = FltLocID ? FltLocID.Name : "Все склады";
	OrgINN = Glb.INN;
	OrgKPP = Glb.KPP;
	OrgExtName = Glb.MainOrgExtName;
	FltLocAddr = FltLocID.Addr;
	NnStart = Glb.GetCounter("AlcoJournal");
	iteration {
		// Glb.GetAlcoRepConfig().CategoryTagID
        AlcoVCode    = GoodsID.GetExtDimI(Glb.GetAlcoRepConfig().CategoryClsDim); // DimZ
        AlcoVCodeByTag = LotID.GetTagByID(Glb.GetAlcoRepConfig().CategoryTagID).GetStr();
		BillDt       = BillID.Dt;
		BillCode     = BillID.Code;
		DLocID       = BillID.DlvrLocID.ID;
		SupplName    = LotID.SupplID.PersonID.Name;
		SupplExtName = LotID.SupplID.PersonID.ExtName;
		SupplINN     = LotID.SupplID.PersonID.INN;
		SupplKPP     = LotID.SupplID.PersonID.KPP;
		LotBillDt    = LotID.BillID.Dt;
		LotBillCode  = LotID.BillID.Code;
		//LotTagOldCod = LotID.GetTag("oldcod").GetStr();
		PhPerUnit    = GoodsID.PhPerUnit;
		GoodsName    = GoodsID.Name;
		GoodsKind    = GoodsID.KindText;
		OpName       = OpID.Name;
		ObjectName   = ObjectID.Name;
	}
}
//
// Invent
// @v7.7.1 verification needed
// @10.7.1 verification needed
//
data Invent {
	declare "Destroy"
	declare "DOSSTUB"

	link   Bill   BillID; // Заголовочный документ -> Bill.ID (PPOPT_INVENTORY)
	link   Global Glb;
	CurDt    = Glb.CurDate;
	OrgName  = Glb.MainOrgName;
	DocDt    = BillID.Dt;
 	Code     = BillID.Code;
	Memo     = BillID.Memo;
	LocName  = BillID.LocID.Name;
	Txt_Hdr  = "N" * Code * "®в" * format(DocDt, ~<#DC);

	long   Flags;          // Флаги
	int16  fLack;          // Показывать недостачи
	int16  fSurplus;       // Показывать излишки
	int16  fAmtVal;        // Величина разногласий в суммовом выражении
	int16  fPctVal;        // Процентная величина разногласий
	int16  fWrOff;         // Показывать списанные строки
	int16  fUnwrOff;       // Показывать не списанные строки
	int16  fZeroByDefault; // По умолчанию остаток нулевой
	int16  fReserve;       // @alignment
	link   GoodsGroup FltGrpID;
	FltGrpName  = if(FltGrpID) ("Группа:"*FltGrpID.Name) else "";
	FltKindText =
		if (fLack && fSurplus)
			"Только рассогласования"
		else if (fLack)
			"Только недостачи"
		else if (fSurplus)
			"Только излишки"
		else
			""; // Текст  по фильтру
	iteration {
		link   Bill ItemBillID; // @v10.7.1 Ссылка на ид документа. При отчете по нескольким документам может отличаться от Hdr.BillID
		long   LineNo;          //
		link   Goods ItemID;    // Товар
		//
		// @v10.7.3 Значения флагов ItemFlags
		// INVENTF_GENAUTOLINE  0x00000001L // Автоматически сгенерированная строка (не подтвержденная)
		// INVENTF_GENWROFFLINE 0x00000002L // Строка сгенерирована при списании (списан по умолчанию весь остаток)
		// INVENTF_WRITEDOFF    0x00000004L // Строка списана
		// INVENTF_SURPLUS      0x00000008L // Знак рассогласований 1
		// INVENTF_LACK         0x00000010L // Знак рассогласований -1
		//
		long   ItemFlags;       // @v10.7.3 Флаги строки инвентаризации
		int16  WritedOff;       // Строка списана
		int16  AutoLine;
		//
		// 1 - Автоматически сгенерированная строка (не подтвержденная)
		// 2 - Строка сгенерирована при списании (списан по умолчанию весь остаток)
		// 0 - Строка создана пользователем
		//
		double UnitPerPack;     // Емкость упаковки
		double Quantity;        // Фактический остаток
		double StockRest;       // Учетный остаток
		double Price;           // Фактическая цена
		double StockPrice;      // Учетная цена
		int16  DiffSign;        // Знак рассогласований (-1 - lack, 1 - surplus, 0 - equal)
		int16  Reserve;         // @alignment
		double DiffQtty;        // Абсолютная величина рассогласования //
		double DiffPctQtty;     // Абсолютная величина рассогласования в процентах
		double UnwritedDiff;    // Не списанная величина рассогласования //
		string ExtGrpName[128]; // Полное наименование группы товаров (с подгруппами)
		double WrOffPrice;      // цена списани
		double CSesDfctQtty;    // Дефицит товара по кассовым сессиям за период, начиная с даты, указанной в документе
		double CSesDfctPrice;   // Средняя цена дефицита товара по кассовым сессиям за период, начиная с даты, указанной в документе
		string Serial[24];      // Серийный номер

		MFSum  = Quantity * Price;
		STkSum = StockRest * Price;
		RSum   = (Quantity-StockRest)*WrOffPrice;
		ItemName       = ItemID.Name;
		GrpName        = ItemID.GroupID.Name;
		ItemUnitName   = ItemID.UnitID.Name;
		ItemPhUnitName = ItemID.PhUnitID.Name;
		DiffPlusQtty   = if(DiffSign > 0)  DiffQtty else 0.0;
		DiffMinusQtty  = if(DiffSign < 0) -DiffQtty else 0.0;
		PlusRsum       = if(DiffSign > 0)  RSum else 0.0;
		MinusRsum      = if(DiffSign < 0) -RSum else 0.0;
	}
}
//
//
//
data PUGL {
	declare "DOSSTUB"

	iteration {
		long   nn @nn;
		link   Goods GoodsID;
		link   Warehouse LocID;
		double NeedQtty;
		double Deficit;

		GoodsName = GoodsID.Name;
		LocName   = LocID.Name;
	}
}
//
// GoodsBasket
//
data GoodsBasket {
	declare "Destroy"
	declare "DOSSTUB"

	long   ID;
	link   Global  Glb;
	link   Article FltSupplID;

	string Name[30];
	string Phones[32];
	FltSupplName = FltSupplID.Name;
	long   Flags;
	long   ItemsCount;   // Количество элементов структуры
	double EstPrice;     // Ожидаемая цена реализации товара
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	iteration {
		long   LineNo;
		link   Goods ItemID;
		long   Flags;
		double Price;      // Цена единицы компонента
		double Quantity;   // Цена единицы компонента
		double SumPerUnit; // Стоимость компонента на единицу составного товара
		string CQtty[32];
		ItemName       = ItemID.Name;
		ItemCode       = ItemID.SingleBarCode;
		ItemUnitName   = ItemID.UnitID.Name;
		ItemPhUnitName = ItemID.PhUnitID.Name;
		GrpID  = ItemID.GroupID.ID;
		GrpName        = ItemID.GroupID.Name;
		Brutto = ItemID.Brutto;
	}
}
//
// ShipmAnlz (Shipment analyze by goods)
//
data ShipmAnlz {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   Warehouse FltLocID;
	link   OprKind   FltOpID;
	link   AccSheet  FltAccSheetID;
	link   Article   FltArID;
	date   FltBeg;
	date   FltEnd;
	long   Flags;
	int16  fDebtOnly;   // Только по неоплаченным документам
	int16  fLabelOnly;  // Только по меченым документам
	int16  fDiffByBill;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	FltLocName = FltLocID ? FltLocID.Name : "Все склады";
	FltOpName  = FltOpID.Name;
	FltArName  = FltArID.Name;

	iteration {
		link   Bill  BillID;
		link   Goods GoodsID;
		double OrderQtty;
		double OrderAmount;
		double ShipmentQtty;
		double ShipmentAmount;
		double AckQtty;
		double AckAmount;

		BillDate  = BillID.Dt;
		BillNo    = BillID.Code;
		BillMemo  = BillID.Memo;
		GoodsName = GoodsID.Name;
	}
}
//
//
//
data PredictSales {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   Goods  FltGoodsID;
	link   Warehouse FltLocID;
	date   FltBeg;
	date   FltEnd;
	int16  FltCycle;     // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles; // Количество циклов
	date   Watershed;    // Дата, разделяющая отсчет циклов вперед и назад
	long   Flags;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltGoodsName = FltGoodsID.Name;
	FltLocName   = FltLocID.Name;
	FltPeriod = formatperiod(FltBeg, FltEnd);
	iteration {
		date    Dt;
		string  CycleText[32];
		double  Qtty;
		double  QttyPredict;
		double  QttyAbsErr;
		double  QttyPctErr;
		double  Amt;
		double  AmtPredict;
		double  AmtAbsErr;
		double  AmtPctErr;
	}
}
//
//
//
data GoodsTurnovr {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	date   FltBeg;
	date   FltEnd;
	link   GoodsGroup FltGoodsGrpID;
	string FltLocName[48];
	string FltSupplName[64];
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	FltGoodsGrpName = FltGoodsGrpID.Name;
	iteration {
		date   Dt;
		double RcptSuppl;
		double RcptIntr;
		double RetRetail;
		double RetClient;
		double RetSuppl;
		double ExpndRetail;
		double ExpndClient;
		double ExpndIntr;
		double PayClient;
		double Income;
	}
}
//
//
//
data PaymPlan {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	date   FltBeg;
	date   FltEnd;
	link   AccSheet  FltAccSheetID;
	link   Article   FltArID;
	link   Warehouse FltLocID;
	int16  FltCycle;     // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles; // Количество циклов
	long   FltFlags;

	Period     = formatperiod(FltBeg, FltEnd);
	FltLocName = FltLocID ? FltLocID.Name : "Все склады";
	FltAccSheetName = FltAccSheetID.Name;
	FltArName = FltArID ? "Контрагент:" + FltArID.Name : "";
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	iteration {
		link   Bill    BillID;
		link   Article ArID;
		date   Dt;
		string CycleText[32];
		string Name[128];
		double Amount;
		double Paym;
		double Debt;
		BillDt      = BillID.Dt;
		BillCode    = BillID.Code;
		BillObjName = BillID.ArticleID.Name;
		BillMemo    = BillID.Memo;
	}
}
//
// @v7.8.2 Verification needed
//
data AdvanceRep {
	declare "DOSSTUB"

	link Global Glb;
	link Bill   BillID;

	string Rcp1Text[28];     // Описание 1-го источника полученной суммы
	date   Rcp1Dt;           // Дата 1-го получения суммы
	double Rcp1Amt;          // 1-я полученная сумма
	string Rcp2Text[28];     // Описание 2-го источника полученной суммы
	date   Rcp2Dt;           // Дата 2-го получения суммы
	double Rcp2Amt;          // 2-я полученная сумма

	double InRest;           // Остаток от предыдущего аванса
	double RcpAmount;        // Полученная сумма
	double ExpAmount;        // Израсходованная сумма
	double OutRest;          // Остаток
	int16  NumAddedBills;    // Количество прилагаемых первичных документов
	int16  NumAddedSheets;   // Количество листов прилагаемых первичных документов

	int16  nn;               // Счетчик итераций

	CurDt      = Glb.CurDate;
	OrgName    = Glb.MainOrgName;
	Accountant = Glb.Accountant;
	Director   = Glb.Director;
	OKPO       = Glb.OKPO;
	BillDt     = BillID.Dt;
	BillNo     = BillID.Code;
	ArName     = BillID.ArticleID.Name;
	LocName    = BillID.LocID.Name;
	Memo       = BillID.Memo;
	TxtDate    = Date2WStr(BillDt, 46);
	TextAmount = Money2Str(ExpAmount, 128);

	iteration {
		string AdvCode[10];
		date   AdvDt;
		long   AdvBillKindID;
		string AdvBillKindName[48];
		link   Bill    AdvBillID;
		link   Account AccID;
		link   Article ArID;
		long   Flags;
		double Amt;
		double ExtAmt;
		string Memo[128]; //

		AccNo = AccID.AccNo;
	}
}
//
// Список персональных карт
//
data SCardList {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	date   FltTrnovrBeg;
	date   FltTrnovrEnd;
	link   SCardSeries FltSeriesID;
	link   PersonReq   FltOwnerReqID;
	link   PersonReq   FltEmplrReqID;
	int16  Ft_Inherited;
	int16  Ft_Closed;
	long   FltFlags;
	double FltMinPDis;
	double FltMaxPDis;
	double FltMinTurnover;
	double FltMaxTurnover;

	CurDt      = Glb.CurDate;
	OrgName    = Glb.MainOrgName;

	Period = formatperiod(FltTrnovrBeg, FltTrnovrEnd);
	FltSeriesName = FltSeriesID.Name;
	FltOwnerName  = FltOwnerReqID.Name;
	FltOwnerINN   = FltOwnerReqID.INN;
	FltOwnerAddr  = FltOwnerReqID.Address;
	FltOwnerPassp = FltOwnerReqID.Passport;

	FltEmplrName  = FltEmplrReqID.Name;
	FltEmplrINN   = FltEmplrReqID.INN;
	FltEmplrAddr  = FltEmplrReqID.Address;

	TxtTitle =
		if(FltSeriesID)
			(FltSeriesID.fCredit ? "Кредитные карты" : "Дисконтные карты")
		else
			"Персональные карты";
	iteration {
		link SCard SCardID;
		link PersonReq EmployerID;
		double Debit;
		double Credit;
		double Rest;

		Code   = SCardID.Code;
		Disc   = SCardID.PDis;
		Issue  = SCardID.IssueDate;
		Expiry = SCardID.Expiry;
		TxtClosed = SCardID.fClosed ? "+" : "";
		OwnerName = SCardID.OwnerReqID.Name;
		EmployerName = EmployerID.Name;
	}
}
//
// Операции по персональной карте
//
data SCardOpList {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	link   SCard SCardID;
	link   PersonReq EmployerID;
	date   Beg;
	date   End;
	double InRest;
	double OutRest;

	CurDt      = Glb.CurDate;
	OrgName    = Glb.MainOrgName;

	Period     = formatperiod(Beg, End);
	CardCode   = SCardID.Code;
	CardDisc   = SCardID.PDis;
	CardIssue  = SCardID.IssueDate;
	CardExpiry = SCardID.Expiry;
	CardRest   = SCardID.Rest;
	TxtClosed  = SCardID.fClosed ? "Карта закрыта" : "";
	OwnerName  = SCardID.OwnerReqID.Name;
	OwnerINN   = SCardID.OwnerReqID.INN;
	OwnerAddr  = SCardID.OwnerReqID.Address;
	OwnerPassp = SCardID.OwnerReqID.Passport;
	EmployerName = EmployerID.Name;

	iteration {
		date   Dt;
		time   Tm;
		link   CCheck CheckID;
		link   User   UserID;
		link   Bill   BillID;
		long   Flags;
		double Amount;  // Сумма операции
		double Rest;    // Остаток после операции

		CashNode = CheckID.SessID.CashNodeID.Name;
		Debit  = (Amount > 0) ? Amount : (double)0;
		Credit = (Amount < 0) ? Amount : (double)0;
		CheckCode = CheckID.Code;
	}
}
//
// Итоги по документам
//
data BillTotal {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   Warehouse FltLocID;
	link   OprKind   FltOpID;
	link   Article   FltObjID;
	date   FltBeg;
	date   FltEnd;
	long   Count;
	double Nominal;
	double Debt;
	long   Flags;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	LocName = FltLocID ? FltLocID.Name : "Все склады";
	OprName = FltOpID.Name;
	ObjName = FltObjID.Name;

	iteration {
		long   LineNo;
 		link   AmountType AmtTypeID;
		link   Currency   CurID;
		double Amt;

		AmtTypeName = AmtTypeID.Name;
		CurSymb     = CurID.Symb;
	}
}
//
// Итоги по остаткам товаров
//
data GoodsRestTotal {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   Article    FltSupplID;
	link   GoodsGroup FltGoodsGrpID;
	link   QuotKind   FltQuotKindID;
	date   FltDate;
	long   Count;
	double SumCost;
	double SumPrice;
	double Quantity;
	double PhQtty;
	long   Flags;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	TitleText = (!FltDate ? "Текущие итоги товарных остатков" : "Итоги товарных остатков на " + format(FltDate, ~<#dc));
	LocName = FltLocID ? FltLocID.Name : "Все склады";
	SupplName    = FltSupplID.Name;
	GoodsGrpName = FltGoodsGrpID.Name;
	QuotKindName = FltQuotKindID.Name;

	iteration {
		long   LineNo;
		link   AmountType AmtTypeID;
		double Amt;
		AmtTypeName = AmtTypeID.Name;
	}
}
//
// Итоги налогового анализа товарооборота
//
data GTaxAnlzTotal {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   OprKind    FltOpID;
	link   GoodsGroup FltGoodsGrpID;
	link   Article    FltSupplID;
	link   Article    FltSupplAgentID;

	date   FltBeg;
	date   FltEnd;
	date   FltLotsBeg;
	date   FltLotsEnd;
	// 0 (INCM_DEFAULT)    По умолчанию
	// 1 (INCM_BYSHIPMENT) По отгрузке
	// 2 (INCM_BYPAYMENT)  По оплате
	int16  IncomeMethod;

	long   Count;
	double TrnovrCost;
	double TrnovrPrice;
	double Income;
	double ExciseSum;
	double C_VATSum;
	double VATSum;
	double IncVATSum;
	double STaxSum;

	CurDt  = Glb.CurDate;
	OrgName        = Glb.MainOrgName;
	Period = formatperiod(FltBeg, FltEnd);
	TxtLotsPeriod  = ((FltLotsBeg || FltLotsEnd) ? ("Период поступления лотов " + formatperiod(FltLotsBeg, FltLotsEnd)) : "");
	LocName        = FltLocID ? FltLocID.Name : "Все склады";
	OprKindName    = FltOpID.Name;
	GoodsGrpName   = FltGoodsGrpID.Name;
	SupplName      = FltSupplID.Name;
	SupplAgentName = FltSupplAgentID.Name;
	TxtIncomeMethod =
		if(IncomeMethod == 1)
			"по отгрузке"
		else if(IncomeMethod == 2)
			"по оплате"
		else
			"по флажкам операций";

	iteration {
		long   LineNo;
		double VatRate;
		double InVat;
		double OutVat;
	}
}
//
// Список персоналий
// @v7.0.9  verification needed
//
data PersonList {
	declare "Destroy"
	declare "DOSSTUB"

	link Global       Glb;
	link PersonKind   PsnKindID;
	link PersonStatus StatusID;
	link Country      CountryID;
	link City         CityID;
	link RegisterType RegTypeID;
	link TagType      TagTypeID; // Идентификтора типа тега как дополнительного атрибута выборки
	int  AttrType;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	AttrName = if(AttrType == 1) "(Телефон/адрес)"
		else if(AttrType == 2)   "(Расчетный счет)"
		else if(AttrType == 3)   "(Регистр:" * RegTypeID.Name + ")"
		else if(AttrType == 4)   "(Тег:" * TagTypeID.Name + ")"
		else if(AttrType == 5)   "(Все адреса)"
		else if(AttrType == 6)   "(Зависшие адреса)"
		else if(AttrType == 7)   "(Адреса доставки)"
		else if(AttrType == 8)   "(Дублированные адреса доставки)"
		else "";

	TxtFilt = (PsnKindID ? "Вид:"       * PsnKindID.Name * "    ": "") *
		(StatusID  ? "Юр.статус:" * StatusID.Name  * "    ": "") *
		(CountryID ? "Страна:"    * CountryID.Name * "    ": "") *
		(CityID    ? "Город:"     * CityID.Name : "");
	iteration {
		link Person PersonID;
		link Location AddrID;   // Ид адреса (если отчет поднимается с дополнительным адресным атрибутом [5,7,8])
		Name   = PersonID.Name;
		Status = PersonID.Status.Name;
		Info   = PersonID.Memo;
		string   Phone[128];    // Список электронных адресов
		string   Address[128];  // Юридический адрес
		string   RAddress[128]; // Фактический адрес
		string   BnkName[128];  // Наименование банка
		string   BnkAcct[28];   // Номер банковского счета
		string   Serial[12];    // Серия регистра
		string   Number[64];    // Номер регистра
		date     InitDate;      // Дата регистра
		date     Expiry;        // Дата истечения срока действия регистра
	}
}

data PersonListAddr : PersonList {
	RetAddrCode = Glb.MainRAddrID.Code;
	RetAddrZIP  = Glb.MainRAddrID.ZIP;
	RetAddrCity = Glb.MainRAddrID.CityID.Name;
	RetAddrText = Glb.MainRAddrID.Text;
	RetAddrFullText = Glb.MainRAddrID.GetLongAddr();
	iteration {
		AddrCode = AddrID.Code;
		AddrZIP  = AddrID.ZIP;
		AddrCity = AddrID.CityID.Name;
		AddrText = AddrID.Text;
		AddrFullText = AddrID.GetLongAddr();
		AddrPhone = AddrID.Phone;
		AddrContact = AddrID.Contact;
	}
}
//
// @v12.2.10
// Анализ клиентской активности
//
data ClientActivity {
	declare "Destroy"

	link   Global       Glb;
	link   PersonKind KindID;      // Вид персоналии, по которой фильтруется отчет
	date   EvalDate;               // Опорная дата для анализа состояния клиентов в соответствии со статистикой их активности. Если ZERODATE, то - текущая дата.
	date   NewCliBeg;              // Дата начала периода идентификации новых клиентов
	date   NewCliEnd;	           // Дата окончания периода идентификации новых клиентов

	iteration {
		link Person PersonID;
		Name   = PersonID.Name;
		long   EventCount;            // Общее количество событий
		double GapDaysAvg;            // Средняя задержка в днях между событиями
		double GapDaysStdDev;         // Стандартное отклонение задержки между событиями в днях
		long   DelayDays;             // Текущая задержка от последнего события в днях
		double DelaySd;               // Текущая задержка от последнего события в стандартных отклонениях
		int16  IsNew;                 // Если клиент новый, то 1 иначе 0
		int16  Reserve;               // @alignment
		long   ActivityState;
		string ActivityStateText[48];
		string Phone[128];            //
	}
}
//
// Инвентарная карточка объекта основных средств
//
data AssetReceipt {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	link Lot    LotID;        // Текущий лот объекта
	link Lot    OrgLotID;     // Лот, по которому поступил объект
	link Account AssetAccID;
	link Article AssetArID;
	link Bill    ExplBillID; // Документ ввода в эксплуатацию
	double StartCost;        // Балансовая стоимость на дату поступления (без НДС) //
	double StartPrice;       // Остаточная стоимость на дату поступления (без НДС) //
	long   MovLineNo;        // Номер строки списка перемещений

	OrgName    = Glb.MainOrgName;
	OrgINN     = Glb.INN;
	OrgOKPO    = Glb.OKPO;
	OrgAddress = Glb.Address;
	OrgPhone   = Glb.Phone;
	OrgBnkAcc  = Glb.MainOrgBankAcc;
	OrgDirector   = Glb.Director;
	OrgAccountant = Glb.Accountant;

	SupplName    = OrgLotID.SupplID.Name;
	SupplINN     = OrgLotID.SupplID.PersonID.INN;
	SupplOKPO    = OrgLotID.SupplID.PersonID.OKPO;
	SupplAddress = OrgLotID.SupplID.PersonID.Address;
	SupplPhone   = OrgLotID.SupplID.PersonID.Phone;
	SupplBnkAcc  = OrgLotID.SupplID.PersonID.BankAccount;

	BillNo     = OrgLotID.BillID.Code;       // Номер документа на поступление
	BillDt     = OrgLotID.BillID.Dt;         // Дата документа на поступление
	ExplBillNo = ExplBillID.Code;            // Номер документа на ввод в эксплуатацию
	ExplBillDt = ExplBillID.Dt;              // Дата документа на ввод в эксплуатацию
	AssetAccNo = AssetAccID.AccNo;           // Номер балансового счета
	AssetArNo  = AssetArID.Number;           // Номер аналитической статьи
	AssetName  = LotID.GoodsID.Name;         // Наименование объекта основных средств
	ManufName  = LotID.GoodsID.ManufID.Name; // Производитель
	GoodsOKOF  = LotID.GoodsID.OKOF;         // Код ОКОФ основного средства
	Serial     = OrgLotID.Serial;            // Инвентарный номер
	LocName    = LotID.LocID.Name;           // Наименование подразделения //
	LocAddr    = LotID.LocID.Addr;           // Адрес подразделения //
	Qtty       = LotID.Qtty;
	Rest       = LotID.Rest;
	AwogCode   = LotID.GoodsID.WrOffGrpID.Code; // Код группы списания //
	AwogTerm   = LotID.GoodsID.WrOffGrpID.WrOffTerm;    // Срок списания, мес
	AwogAnnualAmrt = AwogTerm ? (100 * 12 / AwogTerm) : 0;
	//
	// Список перемещений объекта основных средств
	//
	iteration {
		link Bill  MovBillID;      // Документ поступления или перемещения //
		link Lot   MovLotID;
		link Warehouse DestLocID;  // Склад, на который поступил объект
		double MovPrice;           // Остаточная стоимость объекта на момент перемещения //

		MovDt     = MovBillID.Dt;
		ModBillNo = MovBillID.Code;
		MovOpName = MovBillID.OprKindID.Name;
		DestLocName = DestLocID.Name;
		DestLocResp = DestLocID.RspnsPersonID.Name; // Ответственный по складу
	}
}
//
// Анализ синхронизации объектов
// @v7.1.10 Verification needed
//
data ObjSyncCmp {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   DataObject FltObjType;
	link   DBDiv DestDbDiv;
	int    FltErrCode;
	int    fErrOnly;
	int    Order;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltObjTypeName = FltObjType.Name;
	DestDbDivName  = DestDbDiv.Name;
	FltErrSelTxt =
		if(FltErrCode == 1)
			"Отсутствует информация о синхронизации"
		else if(FltErrCode == 2)
			"Различаются наименования синхронизированных объектов"
		else if(FltErrCode == 3)
			"Не эквивалентная синхронизация"
		else if(FltErrCode == 4)
			"Отсутствует синхронизированный объект"
		else if(fErrOnly)
			"Только ошибочные строки";
	OrderTxt =
		if(Order == 0)
			"По коду ошибки"
		else if(Order == 1)
			"По общему идентификатору"
		else if(Order == 2)
			"По идентификатору отправителя"
		else if(Order == 3)
			"По наименованию отправителя"
		else if(Order == 4)
			"По собственному идентификатору"
		else if(Order == 5)
			"По собственному наименованию";

	iteration {
		link   DataObject ObjType;
		int16  CommIdPfx;
		long   CommID;              //
		int16  Reserve;             // @alignment
		long   SrcID;
		long   DestID;
		int    ErrCode;
		double CmpScore;
		date   SrcModDt;            // Дата модификации  объекта в чужом разделе
		time   SrcModTm;            // Время модификации объекта в чужом разделе
		date   DestModDt;           // Дата модификации  объекта в своем разделе
		time   DestModTm;           // Время модификации объекта в своем разделе
		string CommIdTxt[16];       // Текстовое представление общего идентификатора
		string SrcTmTxt[12];        // Текстовое представление времени модификации объекта в чужом разделе
		string DestTmTxt[12];       // Текстовое представление времени модификации объекта в своем разделе
		string SrcName[64];
		string DestName[64];
		ObjTypeName = ObjType.Name; //
	}
}
//
// Реестр основных средств
//
data AssetView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Warehouse  FltLocID;
	link   GoodsGroup FltGrpID;
	date   FltBeg;
	date   FltEnd;
	date   FltOperBeg;
	date   FltOperEnd;
	int16  Ft_InExpl;  // (0) ignored, (<0) только не введенные в эксплуатацию, (>0) только введенные в эксплуатацию.

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd);
	OperPeriod = formatperiod(FltOperBeg, FltOperEnd);
	FltLocName = FltLocID ? FltLocID.Name : "Все склады";
	FltGrpName = FltGrpID.Name;
	FltInExplTxt =
		if(Ft_InExpl > 0)
			"Только введенные в эксплуатацию"
		else if(Ft_InExpl < 0)
			"Только не введенные в эксплуатацию"
		else
			"";
	iteration {
		link   Lot LotID;
		link   Goods GoodsID;
		date   Dt;                 // Дата поступления //
		date   ExplDt;             // Дата ввода в эксплуатацию
		string GoodsGrpName[128];  // Наименование группы
		double Cost;               // Балансовая стоимость
		double Price;              // Остаточная стоимость
		double Deprec;             // Амортизированная сумма
		double Cost2;              // Балансовая стоимость на конец периода
		double Price2;             // Остаточная стоимость на конец периода
		double Deprec2;            // Амортизированная сумма на конец периода

		GoodsName = GoodsID.Name;
		Serial    = LotID.Serial;
		WrOffTerm = GoodsID.WrOffGrpID.WrOffTerm; // Срок списания (мес)
		DiffCost   = Cost2-Cost;
		DiffDeprec = Deprec2-Deprec;
		Closed = LotID.Closed;
	}
}
//
// Статистика по товарам
//
data SStatView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	date   FltBeg;
	date   FltEnd;
	int16  FltCycle;               // Цикличность отчета (если 0, то сплошной период Beg..End)
	int16  FltNumCycles;           // Количество циклов
	link   Warehouse  LocID;       // Склад
	link   GoodsGroup GoodsGrpID;  // Группа товаров
	link   Article    SupplID;     // Поставщик
	date   RestDate;               // Дата расчета остатков
	int16  OrdTerm;                // Период заказа товара (дней)
	int16  DlvrTerm;               // Период доставки заказа от поставщика (дней)
	long   Flags;
	int16  fSkipZeroNhCount;       // Не показывать позиции с нулевым количеством дней в продаже
	int16  fSupplOrderForm;        // Форма заказа поставщику
	int16  fRoundOrderToPack;      // Расчетный заказ округлять до емкости упаковки вверх

	CurDt        = Glb.CurDate;
	OrgName      = Glb.MainOrgName;
	FltPeriod    = formatperiod(FltBeg, FltEnd);
	LocName      = LocID.Name;
	SupplName    = SupplID.Name;
	GoodsGrpName = GoodsGrpID.Name;
	iteration {
		link   Goods GoodsID;
		GoodsGrpID = GoodsID.GroupID;
		string GoodsName[64];
		long   Count;
		date   Dt;
		string CycleText[32];
		double QttySum;
		double QttyAvg;
		double QttySigma;
		double QttyVar;    // Коэффициент вариации (QttySigma / QttyAvg)
		double QttyTrnovr; // Оборачиваемость в днях (1 / QttyAvg)
		double AmtSum;
		double AmtAvg;
		double AmtSigma;
		double AmtVar;     // Коэффициент вариации (AmtSigma / AmtAvg)
		double AmtTrnovr;  // Оборачиваемость в днях (1 / AmtAvg)
		double Rest;       // Остаток товара (только если Filt.Flags & fSupplOrderForm)
		double Predict;    // Прогноз продаж (только если Filt.Flags & fSupplOrderForm)
		double SupplOrder; // Расчетный заказ (только если Filt.Flags & fSupplOrderForm)
		double PriceAvg;   // Средняя цена
	}
}
//
// LogList
//
data LogList {
	declare "Destroy"

	link   Global     Glb;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	iteration {
		string LogListStr[255];
	}
}
//
// Доверенность
// @v8.7.2  Verification needed
//
data Warrant {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   PersonReq PersonReqID;
	link   Article   SupplID;
	link   Bill      BillID;

	OrgName    = Glb.MainOrgName;
	Account    = Glb.MainOrgBankAcc;
	BnkName    = Glb.MainOrgBnkName;
	Director   = Glb.Director;
	Accountant = Glb.Accountant;
	Address    = Glb.Address;
	INN        = Glb.INN;

	string WarrantNo[12];
	date   WarrantDt;
	date   ExpiryDt;  // Действительна до ...
	string Memo[128]; // Примечание к документу

	WarrantDate = Date2WStr(WarrantDt, 48);
	ExpyryDate  = Date2WStr(ExpiryDt, 48);
	// Потребитель и его адрес
	Consumer_n_Address = OrgName + "," * Address;
	// Доверенность выдана ...
	PsnName  = PersonReqID.ExtName2;
	Passport = PersonReqID.Passport;
	Supplier = SupplID.PersonID ? SupplID.PersonID.ExtName2 : SupplID.Name;
	iteration {
		int    LineNo;
		string GdsName[128]; //
		string Unit[16];     //
		string Qtty[128];    //
	}
}
//
// Freight
//
data FreightList {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	date   FltBillBeg;
	date   FltBillEnd;
	date   FltShipmBeg;
	date   FltShipmEnd;
	date   FltArrvlBeg;
	date   FltArrvlEnd;
	link   Warehouse FltLocID;
	link   OprKind   FltOpID;
	link   Article   FltObjectID;
	link   City      FltPortID;
	long   FltFlags;

	int16  fUnshippedOnly;
	int16  fShippedOnly;
	int16  fFillLaggageFields;
	int16  fReserve; // @alignment

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltBillPeriod = formatperiod(FltBillBeg, FltBillEnd);
	FltShipmPeriod = formatperiod(FltShipmBeg, FltShipmEnd);
	FltArrvlPeriod = formatperiod(FltArrvlBeg, FltArrvlEnd);
	FltLocName = FltLocID ? FltLocID.Name : "Все склады";
	FltOpName  = FltOpID.Name;
	FltObjectName = FltObjectID.Name;
	FltPortName   = FltPortID.Name;

	UnshipText = fUnshippedOnly ? "Только неотгруженные" : (fShippedOnly ? "Только отгруженные" : "");

	iteration {
		link Bill BillID;
		link Article ObjectID;
		date   BillDate;      // Дата документа
		date   ArrvlDate;     // Дата прибытия //
		date   ShipmDate;     // Дата отгрузки
		int16  IsShipped;     // Признак того, что документ уже отгружен
		int16  Reserve;       // @alignment
		string BillCode[24];  // Номер документа
		string ShipName[64];  // Наименование транспорта
		link   City PortID;   // Порт (город) доставки
		string PortName[48];  // Наименование порта (города) доставки
		link   Location DlvrAddrID; // Адрес доставки
		string DlvrAddr[64];  // Текст адреса доставки
		double Amount;        // Сумма документа
		double Brutto;        // Масса брутто документа
		double Volume;        // Объем зафрахтованного товара
		double PackCount;     // Количество упаковок

		ObjectName = ObjectID.Name;              // Имя контрагента по документу
		ShipmTagText = IsShipped ? "X" : "";     // Текстовое представление признака отгрузки документа
		LocName = BillID.LocID.Name;             // Склад, к которому относится документ
		CaptainName = BillID.CaptainID.Name;     // Капитан судна (водитель автомобиля)
	}
}
//
// Список котировок
//
data QuotView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   QuotKind   FltQuotKindID; // Вид котировки
	link   Warehouse  FltLocID;      // Склад
	link   Article    FltClientID;   // Клиент
	link   Currency   FltCurID;      // Валюта
	link   GoodsGroup FltGoodsGrpID; // Группа товаров
	link   Goods      FltGoodsID;    // Товар
	long   Flags;
	long   NumQuotKinds;             // Действительное количество видов котировок
	string QuotName1[30];
	string QuotName2[30];
	string QuotName3[30];
	string QuotName4[30];
	string QuotName5[30];
	string QuotName6[30];
	string QuotName7[30];
	string QuotName8[30];
	string QuotName9[30];
	string QuotName10[30];
	string QuotName11[30];
	string QuotName12[30];
	string QuotName13[30];
	string QuotName14[30];
	string QuotName15[30];
	string QuotName16[30];

	string QuotName17[30];
	string QuotName18[30];
	string QuotName19[30];
	string QuotName20[30];
	string QuotName21[30];
	string QuotName22[30];
	string QuotName23[30];
	string QuotName24[30];
	string QuotName25[30];
	string QuotName26[30];
	string QuotName27[30];
	string QuotName28[30];
	string QuotName29[30];
	string QuotName30[30];
	string QuotName31[30];
	string QuotName32[30];

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltQuotKindName = FltQuotKindID.Name;
	FltLocName    = FltLocID.Name;
	FltClientName = FltClientID.Name;
	FltGrpName    = FltGoodsGrpID.Name;
	FltGoodsName  = FltGoodsID.Name;

	iteration {
		link   Goods GoodsID;
		link   Warehouse LocID;
		link   Article   ClientID;
		string Quot1[10];
		string Quot2[10];
		string Quot3[10];
		string Quot4[10];
		string Quot5[10];
		string Quot6[10];
		string Quot7[10];
		string Quot8[10];
		string Quot9[10];
		string Quot10[10];
		string Quot11[10];
		string Quot12[10];
		string Quot13[10];
		string Quot14[10];
		string Quot15[10];
		string Quot16[10];
		string Quot17[10];
		string Quot18[10];
		string Quot19[10];
		string Quot20[10];
		string Quot21[10];
		string Quot22[10];
		string Quot23[10];
		string Quot24[10];
		string Quot25[10];
		string Quot26[10];
		string Quot27[10];
		string Quot28[10];
		string Quot29[10];
		string Quot30[10];
		string Quot31[10];
		string Quot32[10];

		GoodsName = GoodsID.Name;
		LocName = LocID.Name;
		ClientName = ClientID.Name;
	}
}
//
// Сравнение товарных строк двух документов
//
data GoodsBillCmp {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global     Glb;
	link   Bill LhBillID;   // Левый сравниваемый документ
	link   Bill RhBillID;   // Правый сравниваемый документ
	int16  fOnlyDiffQtty;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	LhBillCode = LhBillID.Code;
	LhBillDt   = LhBillID.Dt;
	LhOpName   = LhBillID.OprKindID.Name;
	RhBillCode = RhBillID.Code;
	RhBillDt   = RhBillID.Dt;
	RhOpName   = RhBillID.OprKindID.Name;

	iteration {
		link Goods GoodsID;
		double LhQtty;      // Количество в строке левого документа
		double RhQtty;      // Количество в строке правого документа
		double DiffQtty;    // RhQtty-LhQtty
		double LhPrice;     // Номинальная цена в строке левого документа
		double RhPrice;     // Номинальная цена в строке правого документа
		double DiffPrice;   // RhPrice-LhPrice

		GoodsName = GoodsID.Name;
		Barcode = GoodsID.SingleBarCode;
	}
}
//
// Состав изделия //
//
data Complete {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Lot     ParentLotID;
	link   Bill    BillID; // Документ, которым был скомплектован лот ParentLotID

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	PGoodsName = ParentLotID.GoodsID.Name;
	BillCode = BillID.Code;
	BillDate = BillID.Dt;

	iteration {
		link   Goods GoodsID;
		link   Lot   LotID;

		GoodsName = GoodsID.Name;
		GoodsGrpName = GoodsID.GroupID.Name;
		string Serial[24];
		double Qtty;
		double Cost;
		double Price;
	}
}
//
// MRP-таблица
//
data MrpTab {
	key    ID;
	string Name[48];
	link   DataObject LinkObjType;
	long   LinkObjID;
	link   Warehouse LocID;
	date   Dt;
	long   Flags;
	string LinkObjName[64];
}
//
// Строка MRP-таблицы
//
data MrpLines {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   MrpTab  TabID;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	TabName     = TabID.Name;
	LinkObjType = TabID.LinkObjType;
	LinkObjTypeName = TabID.LinkObjType.Name;
	LinkObjName = TabID.LinkObjName;
	TabLocID    = TabID.LocID;
	TabLocName  = TabID.LocID.Name;
	TabDate     = TabID.Dt;

	int16  FltRowKind;      // 0 - total, -1 - зависимые потребности, -2 - независимые потребности
	int16  FltShowDfctOnly; // Показаны только дефицитные позиции
	int16  FltShowTermOnly; // Показаны только терминальные позиции

	iteration {
		long   ID;
		link   Goods GoodsID;
		double ReqQtty;
		double Rest;
		double Deficit;
		Cost   = GoodsID.GetLastLotForDate(TabLocID, TabDate).Cost;
		Price  = GoodsID.GetLastLotForDate(TabLocID, TabDate).Price;
		GoodsName = GoodsID.Name;
	}
}
//
// Процессор
//
data Processor {
	key    ID;                     // @id
	link   Processor ParentID;     // -> Processor.ID
	long   Kind;                   // PPPRCK_XXX
	string Name[48];               // Наименование процессора
	string Code[10];               // Код процессора
	link   Warehouse  LocID;       // Склад, которому принадлежит процессор
	link   Unit       TimeUnitID;  //
	long   Flags;                  // PRCF_XXX
	link   DataObject LinkObjType; //
	long   LinkObjID;              //
	link   OprKind    WrOffOpID;   //
	link   Article    WrOffArID;   //
	link   Transport  LinkTransp;  // if LinkObjType == PPOBJ_TRANSPORT then LinkObjID else 0
	link   Person     LinkPerson;  // if LinkObjType == PPOBJ_PERSON    then LinkObjID else 0
}
//
// Список процессоров
//
data ProcessorView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Processor FltGrpID;
	link   Warehouse FltLocID;
	long   FltKind;        // 1 - группы, 2 - процессоры
	long   Flags;          // reserved

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltGrpName = FltGrpID.Name;
	FltLocName = FltLocID.Name;

	iteration {
		link   Processor PrcID;
		link   Processor ParentID; // == PrcID.ParentID

		Name        = PrcID.Name;
		Code        = PrcID.Code;
		ParentName  = ParentID.Name;
		LocName     = PrcID.LocID.Name;
		WrOffOpName = PrcID.WrOffOpID.Name;
		WrOffArName = PrcID.WrOffArID.Name;
		PCode       = PrintableBarcode(Code, 39);
	}
}
//
// Технология //
//
data Tech {
	key    ID;                     // @id
	string Code[24];               // Код технологии
	link   Processor  PrcID;       // -> Processor.ID
	link   Goods      GoodsID;     // -> Goods.ID
	long   GStrucID;               // -> Ref(PPOBJ_GOODSSTRUC)
	string GStrucName[30];         //
	long   Flags;                  // TECF_XXX
	int16  Sign;                   // @#{-1,0,+1} -1 - расход, +1 - приход, 0 - остаток не меняется (использование) //
	double Timing;                 // Время загрузки процессора на одну торговую единицу товара GoodsID (sec)
	double Cost;                   // Суммарная стоимость операции на одну торговую единицу GoodsID
	double Capacity;               // Производительность процессора ProcID при использовании этой технологии
		// (торговых единиц / ProcID.TimeUnitID)
	string Memo[160];              // Примечание
}
//
// Технологическая сессия //
//
data TSession {
	key    ID;                     // @id
	link   Global  Glb;            //
	long   ParentID;               // -> TSession.ID
	long   Number;                 // Номер сессии (уникальный по процессору)
	link   Tech      TechID;       //
	link   Processor PrcID;        //
	link   CCheck    CCheckID;     // Кассовый чек, привязанный непосредственно к сессии (не путать с чеками, ассоциированными с персональной регистрацией)
	link   SCard     SCardID;      // Персональная карта, привязанная к сессии
	link   Bill      LinkBillID;   // Документ, ассоциированный с сессией
	string Name[48];               // Составное наименование сессии
	string SuperName[48];          // Составное наименование родительской сессии
	date   StDt;                   // Дата начала сессии
	time   StTm;                   // Время начала сессии
	string StTmTxt[12];            // Текстовое время начала сессии
	date   FinDt;                  // Дата окончания сессии
	time   FinTm;                  // Время окончания сессии
	string FinTmTxt[12];           // Текстовое время окончания сессии
	int16  Incomplete;             // @#{0,5,10} Закрытие сессии не было завершено
	int16  Status;                 // @#{1..5}   Состояние сессии TSESST_XXX
	int16  Idle;                   // Простой процессора
	int16  Reserve;                // @alignment
	string StatusText[12];         // Строковое представление статуса сессии
	long   Flags;                  // TSESF_XXX
	link   Article   ArID;         // Основная статья для подстановки в документ списания //
	link   Article   Ar2ID;        // 2-я статья для подстановки в документ списания //
	long   PlannedTiming;          // Планируемое время работы (секунд)
	string PlnTimingText[24];      // Текстовое представление планируемого времени [hh:mm:ss]
	double PlannedQtty;            // Планируемый объем производства (TechID.GoodsID.UnitID)
	long   ActTiming;              // Фактическое время работы (секунд)
	string ActTimingText[24];      // Текстовое представление фактического времени [hh:mm:ss]
	double ActQtty;                // Фактический объем производства (TechID.GoodsID.UnitID)
	double Amount;                 // Сумма сессии
	string Memo[160];              // Примечание

	link   Bill GetWrOffMemberByOp(string opSymb[20]); // Возвращает первый документ в пуле документов списания,
		// имеющий вид операции с символом opSymb
	//
	// Descr: Возвращает тег технологической сессии по символу tagSymb
	//
	link   ObjectTag GetTag(string tagSymb[20]);
}

data TSessionData : TSession {
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	PrcName     = PrcID.Name;
	PrcCode     = PrcID.Code;

	ArName      = ArID.Name;
	PersonName  = ArID.PersonID.ExtName2;
	PersonPassp = ArID.PersonID.Passport;
	PersonAddr  = ArID.PersonID.Address;
	PersonRAddr = ArID.PersonID.RAddr;
	PersonPhone = ArID.PersonID.Phone;
	PersonINN   = ArID.PersonID.INN;

	Ar2Name      = Ar2ID.Name;
	Person2Name  = Ar2ID.PersonID.ExtName2;
	Person2Passp = Ar2ID.PersonID.Passport;
	Person2Addr  = Ar2ID.PersonID.Address;
	Person2RAddr = Ar2ID.PersonID.RAddr;
	Person2Phone = Ar2ID.PersonID.Phone;
	Person2INN   = Ar2ID.PersonID.INN;

	MainGoodsName = TechID.GoodsID.Name;

	MainGoodsDimX  = TechID.GoodsID.DimX;
	MainGoodsDimY  = TechID.GoodsID.DimY;
	MainGoodsDimZ  = TechID.GoodsID.DimZ;
	MainGoodsGcKind  = TechID.GoodsID.KindText;
	MainGoodsGcGrade = TechID.GoodsID.GradeText;
	MainGoodsGcAdd   = TechID.GoodsID.AddObjText;
	MainGoodsPhPerU  = TechID.GoodsID.PhPerUnit;
}

data TechView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Processor FltPrcID;
	link   Goods     FltGoodsID;
	long   FltGsID;        // Структура товара
	long   SignFlags;      // TechFilt::signXXX
	long   Flags;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltPrcName   = FltPrcID.Name;
	FltGoodsName = FltGoodsID.Name;

	iteration {
		link   Tech TechID;
		string TimingTxt[16];
		TechCode  = TechID.Code;
		PrcID     = TechID.PrcID;
		PrcName   = TechID.PrcID.Name;
		GoodsID   = TechID.GoodsID;
		GoodsName = TechID.GoodsID.Name;
		GsName    = TechID.GStrucName;
		Sign      = TechID.Sign;
		Cost      = TechID.Cost;
		Capacity  = TechID.Capacity;        // Производительность (1/сек)
		CapacityM = TechID.Capacity * 60;   // Производительность (1/минута)
		CapacityH = TechID.Capacity * 3600; // Производительность (1/час)
		Memo      = TechID.Memo;
	}
}

data TSessionView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   TSession  FltSuperID;
	link   Processor FltPrcID;
	link   Tech      FltTechID;
	link   Article   FltArID;
	link   Article   FltAr2ID;

	date   FltStBeg;
	date   FltStEnd;
	date   FltFnBeg;
	date   FltFnEnd;
	int    Ft_Idle;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	StPeriod = formatperiod(FltStBeg, FltStEnd);
	FnPeriod = formatperiod(FltFnBeg, FltFnEnd);
	FltSuperName = FltSuperID.Name;
	FltPrcName   = FltPrcID.Name;
	FltArName    = FltArID.Name;
	FltAr2Name   = FltAr2ID.Name;
	FltIdleText = (Ft_Idle == 0) ? "" : (Ft_Idle > 0 ? "Простои процессоров" : "Без учета простоев");

	iteration {
		link TSession SessID;

		SuperName = SessID.SuperName;
		Number    = SessID.Number;
		Name      = SessID.Name;
		PrcName   = SessID.PrcID.Name;
		TechName  = SessID.TechID.Code;
		TechGoodsName = SessID.TechID.GoodsID.Name;
		StDt    = SessID.StDt;
		StTm    = SessID.StTm;
		StTmTxt = SessID.StTmTxt;
		FnDt    = SessID.FinDt;
		FnTm    = SessID.FinTm;
		FnTmTxt = SessID.FinTmTxt;

		PlannedTiming = SessID.PlannedTiming; // Планируемое время работы (секунд)
		PlnTimingText = SessID.PlnTimingText; // Текстовое представление планируемого времени [hh:mm:ss]
		PlannedQtty   = SessID.PlannedQtty;   // Планируемый объем производства (TechID.GoodsID.UnitID)
		ActTiming     = SessID.ActTiming;     // Фактическое время работы (секунд)
		ActTimingText = SessID.ActTimingText; // Текстовое представление фактического времени [hh:mm:ss]

		StatusText = SessID.StatusText;
		Idle    = SessID.Idle;
		ArName  = SessID.ArID.Name;
		Ar2Name = SessID.Ar2ID.Name;
		Memo    = SessID.Memo;
	}
}
//
// Выборка технологических сессий совмещенная с данными о персональной регистрации для каждой из сессий
//
data TSessionCipView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   TSession  FltSuperID;
	link   Processor FltPrcID;
	link   Tech      FltTechID;
	link   Article   FltArID;
	link   Article   FltAr2ID;

	date   FltStBeg;
	date   FltStEnd;
	date   FltFnBeg;
	date   FltFnEnd;
	int    Ft_Idle;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	StPeriod = formatperiod(FltStBeg, FltStEnd);
	FnPeriod = formatperiod(FltFnBeg, FltFnEnd);
	FltSuperName = FltSuperID.Name;
	FltPrcName   = FltPrcID.Name;
	FltArName    = FltArID.Name;
	FltAr2Name   = FltAr2ID.Name;
	FltIdleText = (Ft_Idle == 0) ? "" : (Ft_Idle > 0 ? "Простои процессоров" : "Без учета простоев");

	iteration {
		link TSession SessID;
		link CheckInPerson CipID;

		SuperName = SessID.SuperName;
		Number    = SessID.Number;
		Name      = SessID.Name;
		PrcName   = SessID.PrcID.Name;
		TechName  = SessID.TechID.Code;
		TechGoodsName = SessID.TechID.GoodsID.Name;
		StDt    = SessID.StDt;
		StTm    = SessID.StTm;
		StTmTxt = SessID.StTmTxt;
		FnDt    = SessID.FinDt;
		FnTm    = SessID.FinTm;
		FnTmTxt = SessID.FinTmTxt;

		PlannedTiming = SessID.PlannedTiming; // Планируемое время работы (секунд)
		PlnTimingText = SessID.PlnTimingText; // Текстовое представление планируемого времени [hh:mm:ss]
		PlannedQtty   = SessID.PlannedQtty;   // Планируемый объем производства (TechID.GoodsID.UnitID)
		ActTiming     = SessID.ActTiming;     // Фактическое время работы (секунд)
		ActTimingText = SessID.ActTimingText; // Текстовое представление фактического времени [hh:mm:ss]

		StatusText = SessID.StatusText;
		Idle    = SessID.Idle;
		ArName  = SessID.ArID.Name;
		Ar2Name = SessID.Ar2ID.Name;
		Memo    = SessID.Memo;

		CipPersonID = CipID.PersonID; // Персоналия //
		CipPersonName = CipID.PersonID.Name; // Имя зарегистрированной персоналии
		CipSCardCode  = CipID.SCardID.Code;  // Номер карты, с которой ассоциирована зерегистрированная персоналия //
		CipNum      = CipID.Num;      // Номер записи в однородном списке относительно заданного первичного объекта
		CipRegCount = CipID.RegCount; // Количество персоналий, включенное в данную регистрацию.
		CipCiCount  = CipID.CiCount;  // Количество персоналий, включенное в данную регистрацию со статусом CheckedIn.
		CipFlags    = CipID.Flags;    // @flags
		CipRegDt    = CipID.RegDt;    // Дата регистрации //
		CipRegTm    = CipID.RegTm;    // Время регистрации //
		CipCiDt     = CipID.CiDt;     // Дата подтверждения регистрации (CheckID)
		CipCiTm     = CipID.CiTm;     // Время подтверждения регистрации (CheckID)
		CipAmount   = CipID.Amount;   // Сумма, уплаченная или которая должна быть уплачена за регистрацию (подтверждение)
	}
}
//
// Выборка технологических сессий совмещенная с данными о документах списания для каждой сессии
//
data TSessionBillView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global    Glb;
	link   TSession  FltSuperID;
	link   Processor FltPrcID;
	link   Tech      FltTechID;
	link   Article   FltArID;
	link   Article   FltAr2ID;

	date   FltStBeg;
	date   FltStEnd;
	date   FltFnBeg;
	date   FltFnEnd;
	int    Ft_Idle;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	StPeriod = formatperiod(FltStBeg, FltStEnd);
	FnPeriod = formatperiod(FltFnBeg, FltFnEnd);
	FltSuperName = FltSuperID.Name;
	FltPrcName   = FltPrcID.Name;
	FltArName    = FltArID.Name;
	FltAr2Name   = FltAr2ID.Name;
	FltIdleText = (Ft_Idle == 0) ? "" : (Ft_Idle > 0 ? "Простои процессоров" : "Без учета простоев");

	iteration {
		link TSession SessID;
		link Bill BillID;

		SuperName = SessID.SuperName;
		Number    = SessID.Number;
		Name      = SessID.Name;
		PrcName   = SessID.PrcID.Name;
		TechName  = SessID.TechID.Code;
		TechGoodsName = SessID.TechID.GoodsID.Name;
		StDt    = SessID.StDt;
		StTm    = SessID.StTm;
		StTmTxt = SessID.StTmTxt;
		FnDt    = SessID.FinDt;
		FnTm    = SessID.FinTm;
		FnTmTxt = SessID.FinTmTxt;

		PlannedTiming = SessID.PlannedTiming; // Планируемое время работы (секунд)
		PlnTimingText = SessID.PlnTimingText; // Текстовое представление планируемого времени [hh:mm:ss]
		PlannedQtty   = SessID.PlannedQtty;   // Планируемый объем производства (TechID.GoodsID.UnitID)
		ActTiming     = SessID.ActTiming;     // Фактическое время работы (секунд)
		ActTimingText = SessID.ActTimingText; // Текстовое представление фактического времени [hh:mm:ss]

		StatusText = SessID.StatusText;
		Idle    = SessID.Idle;
		ArName  = SessID.ArID.Name;
		Ar2Name = SessID.Ar2ID.Name;
		Memo    = SessID.Memo;

		BillCode = BillID.Code;
		BillDate = BillID.Dt;
		BillAmount = BillID.Amount;
	}
}
//
//
//
data TSessLineView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   TSession FltSessID;  // Сессия //
	link   Goods    FltGoodsID; // Товар
	long   FltFlags;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltSessName  = FltSessID.Name;
	FltGoodsName = FltGoodsID.Name;

	iteration {
		link   TSession SessID;
		link   Goods    GoodsID; // ИД товара
		link   User     UserID;  // Пользователь, который ввел операцию
		long   OprNo;
		int16  Sign;             // @#{-1,0,+1} -1 - расход, +1 - приход, 0 - остаток не меняется    //
		date   Dt;               // Дата ввода строки (не обязательно соответствует дате сессии)     //
		time   Tm;               // Время ввода строки (не обязательно соответствует времени сессии) //
		long   Flags;            // TSESLF_XXX
		double Qtty;             // @#{>0}
		double Price;            // Серийный номер, ассоциированный со строкой.
		string Serial[24];       // Стоимость единицы товара

		SessName  = SessID.Name;
		GoodsName = GoodsID.Name;
		UserName  = UserID.Name;
		PrcName   = SessID.PrcID.Name;
		TechGoodsName = SessID.TechID.GoodsID.Name;
		TmTxt     = format(Tm, ~>&N);
	}
}
//
// @ModuleDef(PPViewTSessAnlz)
//
data TSessAnlz {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   TSession   PlanSessID;    // Сессия производственного плана
	link   TSession   SingleSessID;  // Если !0, то ИД единственной сессии, по которой строится анализ
	link   Processor  FltPrcID;
	link   GoodsGroup FltGoodsGrpID;
	link   Article FltArID;
	link   Article FltAr2ID;

	date   FltStBeg;     // Начальная дата периода начала сессий
	date   FltStEnd;     // Конечная дата периода начала сессий
	time   FltStTime;    // Время начала первой сессии (если FltStBeg == 0, то не используется)
	date   FltFnBeg;     // Начальная дата периода завершения сессий
	date   FltFnEnd;     // Конечная дата периода завершения сессий
	time   FltFnTime;    // Время окончания последней сессии (если FltFnEnd == 0, то не используется)
	string StPeriod[32]; // Текстовое представление периода начала (включая время начала)
	string FnPeriod[32]; // Текстовое представление периода окончания (включая время окончания)

	long   FltFlags;
	int16  fAll;              // Отчет по всей выборке сессий. Иначе - по одной
	int16  fPrmrGoodsOnly;    // Только по основным товарам (исключает DiffMg)
	int16  fShowRest;         // Показывать строки фиксированных остатков
	int16  fExtrapolToPeriod; // Экстраполировать итоги анализа по плану на неполный период.
		// Эта опция используется при расчете анализа по производственному плану, работа по которому еще не закончилась.
	int16  fAddTotalRows;     // Показывать итоги по каждой из позиций без группировки
		// Актуальна только если DiffPrc || DiffMg || DiffDt.
	int16  fNmgRestrictOnly;  // NmGoodsGrpID (если !0) только ограничивает выборку, но не замещает позиции

	int16  DiffPrc;           // Дифференциация по процессору
		// Варианты дифференциации отчета по процессорам
		// 0 - Нет дифференциации
		// 1 - Дифференцировать собственно по процессорам
		// 2 - Дифференцировать по группам процессоров (самый близкий к процессорам уровень)
		// 3 - Дифференцировать по статьям сессий
		//
	int16  DiffMg;            // Дифференциация по основному товару
		// Варианты дифференциации отчета по основным товарам
		// 0 - Нет
		// 1 - Дифференцировать собственно по основным товарам
		// 2 - Дифференцировать по группам основных товаров
		//
	int16  DiffDt;            // Дифференциация по дате
		// Варианты дифференциации отчета по дате
		// 0 - Нет
		// 1 - Дифференцировать собственно по дате начала сессий
		// 2 - Дифференцировать по суперсессиям
		//
	int16  Reserve; // alignment(4)
	CurDt  = Glb.CurDate;
	PlanSessName   = PlanSessID.Name;
	SnglSesPrcName = SingleSessID.PrcID.Name;
	SnglSesArName  = SingleSessID.ArID.Name;
	SnglSesAr2Name = SingleSessID.Ar2ID.Name;
	SnglSesStDt    = SingleSessID.StDt;
	SnglSesStTm    = SingleSessID.StTmTxt;
	SnglSesFinDt   = SingleSessID.FinDt;
	SnglSesFinTm   = SingleSessID.FinTmTxt;
	OrgName        = Glb.MainOrgName;
	FltPrcName     = FltPrcID.Name;
	FltArName      = FltArID.Name;

	iteration {
		link   Processor PrcID;
		link   Goods     PrmrGoodsID;
		link   Goods     GoodsID;
		date   Dt;                             // Дата
		int16  NotPrmrLine;                    // Строка не является первичным товаром. Это поле позволяет
			// отсортировать отчет таким образом, чтобы основные позиции предшествовали вторичным.
		int16  PlanPhUnit;                     // План-факт представлены в физических единицах
		double InQtty;                         // Фактический вход
		double OutQtty;                        // Фактический выход
		double InQttyPh;                       // Фактический вход в физических единицах
		double OutQttyPh;                      // Фактический выход в физических единицах
		double PlanInQtty;                     // Запланированный вход
		double PlanOutQtty;                    // Запланированный выход
		double OutRest;                        // Исходящий остаток
		double Dev;                            // Отклонение от плана абсолютное
		double DevPct;                         // Отклонение от плана в процентах
		double InCompPart;                     // Доля компонента в общем расходе (в физических единицах)
		double OutCompPart;                    // Доля компонента в общем выходе  (в физических единицах)
		string PrmrGoodsName[64];              //
		string GoodsName[64];                  //
		string PrcName[48];                    //
		string DtText[48];                     //
		string Intrn_PrcName[48];              // Внутреннее поле, используемое для правильной сортировки групп отчета
		GoodsGrpName  = GoodsID.GroupID.Name;
		UnitName      = GoodsID.UnitID.Name;   // Наименование торговой единицы измерения   //
		PhUnitName    = GoodsID.PhUnitID.Name; // Наименование физической единицы измерения //
		PhPerUnit     = GoodsID.PhPerUnit;     // Количество физических единиц в одной торговой
		DimX     = GoodsID.DimX;
		DimY     = GoodsID.DimY;
		DimZ     = GoodsID.DimZ;

		PrmrPhPerU = PrmrGoodsID.PhPerUnit;

		InQttyEx      = InQtty  * DimZ;
		OutQttyEx     = OutQtty * DimZ;
		PlanInQttyEx  = PlanInQtty  * DimZ;
		PlanOutQttyEx = PlanOutQtty * DimZ;
	}
}
//
// Проект
//
data Project {
	key    ID;                     // @id
	long   Kind;                   // PPPRJK_XXX {1=Project, 2=Phase, 3=ProjectTemplate, 4=PhaseTemplate}
	long   ParentID;               //
	string Name[128];              // Наименование проекта
	string Code[16];               // Код проекта
	date   Dt;                     // Дата создания проекта
	date   BeginDt;                // Дата начала работ по проекту
	date   EstFinishDt;            // Предполагаемая дата завершения работ по проекту
	date   FinishDt;               // Фактическая дата  завершения работ по проекту
	link   Person  MngrID;         // Менеджер проекта
	link   Person  ClientID;       // Клиент
	long   TemplateID;             // -> Project (Kind = XxxTemplate) Шаблон проекта/фазы (прецедент)
	long   Status;                 // PPPRJSTS_XXX Состояние проекта/фазы {1=Active, 2=Non-Active, 3=Archived}
	long   Flags;                  // @flags
	string FullName[96];           // Составное имя фазы (Проект/Фаза)
	string Descr[256];             // Краткое описание проекта/фазы
	string Memo[1024];             // Примечание к проекту
}
//
// Задача
//
data PrjTask {
	key    ID;                     // @id
	link   Project ProjectID;      // Ссылка на проект, которому принадлежит задача
	long   Kind;                   // {Task=1, Template=2}
	string Code[16];               //
	link   Person   CreatorID;     // ->User.ID
	long   GroupID;                //
	link   Person   EmployerID;    // ->Person.ID
	link   Person   ClientID;      // ->Person.ID
	link   Location DlvrAddrID;    // Адрес доставки, ассоциированный с клиентом ClientID
	link   Article  BillArID;      // Статья для документа разноски
	link   PrjTask  TemplateID;    // ->PrjTask(Kind = Template) Шаблон задачи
	link   PrjTask  LinkTaskID;    // ->PrjTask Связанная задача
	date   Dt;                     // Дата создания записи
	time   Tm;                     // Время создания записи
	date   StartDt;                // Дата начала работы
	time   StartTm;                // Время начала работы
	date   EstFinishDt;            // Предполагаемая дата завершения работы
	time   EstFinishTm;            // Предполагаемое время завершения работы
	date   FinishDt;               // Фактическая дата завершения работы
	time   FinishTm;               // Фактическое время завершения работы
	int16  Priority;               // {1=Highest, 2=High, 3=Normal, 4=Low, 5=Lowest}
	int16  Status;                 // {1=New, 2=Rejected, 3=InProgress, 4=OnHold, 5=Completed}
	double Amount;                 // Сумма, связанная с задачей
	//
	// Следующие 3 поля соответствуют структуре DateRepeating
	//
	int16  DrPrd;                  // DateRepeating::Prd
	int16  DrKind;                 // DateRepeating::RepeatKind
	int32  DrDetail;               // Использование зависит от DrPrd и DrKind
	//
	long   Flags;                  // @flags
	string PriorText[16];          // Наименование приоритета задачи
	string StatusText[16];         // Наименование статуса задачи
	string Descr[256];             // Описание задания
	string Memo[1024];             //
}
//
//
//
data ProjectView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Project FltParentID;  //
	link   Person  FltClientID;  //
	link   Person  FltManagerID; //
	long   FltFlags;

	date   FltStart_beg;
	date   FltStart_end;
	FltStart = formatperiod(FltStart_beg, FltStart_end);

	date   FltEstFn_beg;
	date   FltEstFn_end;
	FltEstFn = formatperiod(FltEstFn_beg, FltEstFn_end);

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltParentName  = FltParentID.Name;
	FltClientName  = FltClientID.Name;
	FltManagerName = FltManagerID.Name;
	ListTitle = "Список " + ((FltParentID == 0) ? "проектов" :
		(((FltFlags & 0x0004) ? "задач" : "фаз") + " проекта " + FltParentName)) + ((FltStart == "") ? "" : (" с началом работ " + FltStart));

	iteration {
		link Project ProjectID;
		link PrjTask PrjTaskID;

		Name        = (PrjTaskID == 0) ? ProjectID.Name : "";
		Code        = (PrjTaskID == 0) ? ProjectID.Code : PrjTaskID.Code;
		ManagerName = (PrjTaskID == 0) ? ProjectID.MngrID.Name : PrjTaskID.EmployerID.Name;
		ClientName  = (PrjTaskID == 0) ? ProjectID.ClientID.Name : PrjTaskID.ClientID.Name;
		Dt  = (PrjTaskID == 0) ? ProjectID.Dt : PrjTaskID.Dt;
		BeginDt     = (PrjTaskID == 0) ? ProjectID.BeginDt : PrjTaskID.StartDt;
		EstFinishDt = (PrjTaskID == 0) ? ProjectID.EstFinishDt : PrjTaskID.EstFinishDt;
		FinishDt    = (PrjTaskID == 0) ? ProjectID.FinishDt : PrjTaskID.FinishDt;
		Status      = (PrjTaskID == 0) ? ProjectID.Status : 0;
		StatusText  = (PrjTaskID == 0) ? "" : PrjTaskID.StatusText;
		Descr       = (PrjTaskID == 0) ? ProjectID.Descr : PrjTaskID.Descr;
		Memo        = (PrjTaskID == 0) ? ProjectID.Memo : PrjTaskID.Memo;
	}
}
//
//
//
data PrjTaskView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	long   FltKind;               // TODOKIND_XXX
	link   Project FltProjectID;  //
	link   Person  FltClientID;   //
	link   Person  FltEmployerID; //
	link   PrjTask FltTemplateID; //
	link   Person  FltCreatorID;  //
	long   FltFlags;
	string FltPriorList[48];
	string FltStatusList[48];

	date   FltPeriod_beg;
	date   FltPeriod_end;
	FltPeriod = formatperiod(FltPeriod_beg, FltPeriod_end);

	date   FltStart_beg;
	date   FltStart_end;
	FltStart = formatperiod(FltStart_beg, FltStart_end);

	date   FltEstFn_beg;
	date   FltEstFn_end;
	FltEstFn = formatperiod(FltEstFn_beg, FltEstFn_end);

	date   FltFn_beg;
	date   FltFn_end;
	FltFn = formatperiod(FltFn_beg, FltFn_end);

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltProjectName  = FltProjectID.FullName;
	FltProjectCode  = FltProjectID.Code;
	FltCreatorName  = FltCreatorID.Name;
	FltClientName   = FltClientID.Name;
	FltEmployerName = FltEmployerID.Name;
	FltTemplateCode = FltTemplateID.Code;
	//
	// Поле FltKindText следует использовать в качестве заголовка отчетов
	//
	FltKindText =
		if(FltKind == 1)
			"Задачи"
		else if(FltKind == 2)
			"Шаблоны задач"
		else
			"Задачи и шаблоны";

	iteration {
		link PrjTask TodoID;
		link PrjTask TemplID; // ==TodoID.TemplateID ИД шаблона
		link PrjTask LinkID;  // ==TodoID.

		Code = TodoID.Code;
		TemplCode = TemplID.Code;              // Код шаблона
		PrjName   = TodoID.ProjectID.FullName; // Наименование проекта
		LinkCode  = LinkID.Code;               // Код связанной задачи
		CreatorName  = TodoID.CreatorID.Name;
		EmployerName = TodoID.EmployerID.Name;
		ClientName   = TodoID.ClientID.Name;
		DlvrAddr     = TodoID.DlvrAddrID.Addr;
		Dt   = TodoID.Dt;
		Tm   = TodoID.Tm;
		TmT  = format(TodoID.Tm, ~>&NB);
		StartDt      = TodoID.StartDt;
		StartTm      = TodoID.StartTm;
		StartTmT     = format(TodoID.StartTm, ~>&NB);
		EstFinishDt  = TodoID.EstFinishDt;
		EstFinishTm  = TodoID.EstFinishTm;
		EstFinishTmT = format(TodoID.EstFinishTm, ~>&NB);
		FinishDt     = TodoID.FinishDt;
		FinishTm     = TodoID.FinishTm;
		FinishTmT    = format(TodoID.FinishTm, ~>&NB);
		Amount       = TodoID.Amount;
		PriorText    = TodoID.PriorText;
		StatusText   = TodoID.StatusText;
		Descr        = TodoID.Descr;
		Memo = TodoID.Memo;
	}
}
//
// Список задач с табуляцией
//
data PrjTaskViewCt {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	long   FltKind;               // TODOKIND_XXX
	link   Project FltProjectID;  //
	link   Person  FltClientID;   //
	link   Person  FltEmployerID; //
	link   PrjTask FltTemplateID; //
	link   Person  FltCreatorID;  //
	long   FltFlags;
	string FltPriorList[48];
	string FltStatusList[48];

	date   FltPeriod_beg;
	date   FltPeriod_end;
	FltPeriod = formatperiod(FltPeriod_beg, FltPeriod_end);

	date   FltStart_beg;
	date   FltStart_end;
	FltStart = formatperiod(FltStart_beg, FltStart_end);

	date   FltEstFn_beg;
	date   FltEstFn_end;
	FltEstFn = formatperiod(FltEstFn_beg, FltEstFn_end);

	date   FltFn_beg;
	date   FltFn_end;
	FltFn = formatperiod(FltFn_beg, FltFn_end);

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltProjectName  = FltProjectID.Name;
	FltProjectCode  = FltProjectID.Code;
	FltCreatorName  = FltCreatorID.Name;
	FltClientName   = FltClientID.Name;
	FltEmployerName = FltEmployerID.Name;
	FltTemplateCode = FltTemplateID.Code;

	string IdxFld[48];
	string TabFld[48];
	iteration {
		string IdxName[48];
		string TabName[48];
		long   Value;
	}
}
//
// v4.8.0 Специальная информация о документе
//
data BillInfo {
	link Global  Glb;

	link   Bill      BillID;
	ID        = BillID.ID;
	CurID     = BillID.CurID;
	ObjectID  = BillID.ArticleID;
	Object2ID = BillID.Object2ID;
	PayerID   = BillID.PayerID;
	AgentID   = BillID.AgentID;
	OprKindID = BillID.OprKindID;
	LocID     = BillID.LocID;

	PaymBillCode = BillID.PaymBillCode; // Номер платежно-расчетного документа (для инвойсов)
	PaymBillDate = BillID.PaymBillDate; // Дата  платежно-расчетного документа (для инвойсов)

	DlvrLocID = BillID.DlvrLocID;

	Dt   = BillID.Dt;
	Code = BillID.Code;
	Memo = BillID.Memo;

	// Flags
	fNeedPayment = BillID.fNeedPayment;
	fPayOut      = BillID.fPayout;
	fWhiteLabel  = BillID.fWL;
	int16 fTotalDiscount;
	int16 fGReceipt;
	int16 fGExpend;
	int16 fGReval;
	int16 fGModif;
	int16 fClosedOrder;
	int16 fCash;
	int16 fCCheck;
	int16 fNoAturn;
	int16 fRmvExcise;
	int16 fFixedAmounts;
	int16 fFreight;
	int16 fRent;
	int16 fRecon;
	int16 fBanking;
	int16 fShipped;
	int16 fWritedOff;
	int16 fCSessWrOff;
	int16 fAdvanceRep;
	int16 fTGGLexCsNPrice;
	int16 fTSessWrOff;

	iteration {
		long nn; // счетчик сумм
		link AmountType AmountID;
		link Currency CurrencyID;
		Type    = AmountID.Name;
		Flags   = AmountID.Flags;
		Tax     = AmountID.Tax;
		TaxRate = AmountID.TaxRate;
		CurName = CurrencyID.Name;
		double Amount;
	}
}
//
// v4.8.0 Специальная информация по списку документов
//
data BillInfoList {
	link Global  Glb;

	iteration {
		link   Bill      BillID;       // ИД документа
		ID        = BillID.ID;         // ИД документа
		CurID     = BillID.CurID;      // ИД валюты
		ObjectID  = BillID.ArticleID;  // ИД основной статьи документа
		Object2ID = BillID.Object2ID;  // ИД дополнительной статьи документа
		PayerID   = BillID.PayerID;    // ИД плательщика (из дополнения документа)
		AgentID   = BillID.AgentID;    // ИД агента (из дополнения документа)
		OprKindID = BillID.OprKindID;  // ИД вида операции документа
		LocID     = BillID.LocID;      // ИД склада, к которому относится документ

		PaymBillCode = BillID.PaymBillCode; // Номер платежно-расчетного документа (для инвойсов)
		PaymBillDate = BillID.PaymBillDate; // Дата  платежно-расчетного документа (для инвойсов)

		DlvrLocID = BillID.DlvrLocID;  // ИД адреса доставки (из фрахта документа)

		Dt   = BillID.Dt;              // Дата документа
		Code = BillID.Code;            // Номер документа
		Memo = BillID.Memo;            // Примечание к документу

		// Flags
		fNeedPayment = BillID.fNeedPayment; // Требует платежного документа
		fPayOut      = BillID.fPayout;      // Оплачен
		fWhiteLabel  = BillID.fWL;          // Помечен
		int16 fTotalDiscount;               // На документ установлена общая скидка
		int16 fGReceipt;                    // Приход товара
		int16 fGExpend;                     // Расход товара
		int16 fGReval;                      // Переоценка товара
		int16 fGModif;                      // Модификация товара
		int16 fClosedOrder;                 // Закрытый заказ
		int16 fCash;                        // Кассовый документ (чек)
		int16 fCCheck;                      //
		int16 fNoAturn;                     // Бухгалтерские проводки по документу заблокированы
		int16 fRmvExcise;                   // Признак переключения налога с продаж
		int16 fFixedAmounts;                // Суммы по документу зафиксированы
		int16 fFreight;                     // Документ содержит информацию по фрахту
		int16 fRent;                        // Документ ренты
		int16 fRecon;                       // Зачитывающий платежный документ
		int16 fBanking;                     // Банковский ордер (платежное поручение)
		int16 fShipped;                     // Признак отгруженного документа (фрахт)
		int16 fWritedOff;                   // Списанный документ (для драфт-документов и инвентаризаций)
		int16 fCSessWrOff;                  // Документ списания кассовой сессии
		int16 fAdvanceRep;                  // Документ содержит строки бухгалтерского расширения //
		int16 fTGGLexCsNPrice;              // Налог с продаж по документу переключен без изменения цены
		int16 fTSessWrOff;                  // Документ списания технологической сессии
		// Следующие поля представляют собой информацию о сумме по документу
		// Из-за отсутствия многоуровневых итераторов, для каждой суммы документа
		// все вышеперечисленные поля повторяются  //
		long nn; // счетчик сумм            // Номер суммы по документу
		link AmountType AmountID;           // ИД типа суммы
		link Currency CurrencyID;           // ИД валюты суммы
		Type    = AmountID.Name;            // Наименование типа суммы
		Flags   = AmountID.Flags;           // Флаги типа суммы
		Tax     = AmountID.Tax;             // Тип налога, ассоциированного с типом суммы
		TaxRate = AmountID.TaxRate;         // Налоговая ставка, ассоциированная с типом суммы (для налоговых сумм)
		CurName = CurrencyID.Name;          // Наименование валюты суммы
		double Amount;                      // Значение суммы
	}
}
//
//
//
data PriceAnlz {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Person  FltSupplID;
	SupplName = FltSupplID.Name;
	date   FltPeriod_beg;
	date   FltPeriod_end;
	FltPeriod = formatperiod(FltPeriod_beg, FltPeriod_end);

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	iteration {
		link Goods     GoodsID;
		link Warehouse LocID;
		GoodsName = GoodsID.Name;
		GroupName = GoodsID.GroupID.Name;
		LocName   = LocID.Name;
		double ContractCost;
		double Cost;
		double CostDiff;
	}
}

data PrcBusyView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	link   Processor FltPrcID;
	date   FltStDt;
	time   FltStTm;
	date   FltFnDt;
	time   FltFnTm;
	time   FltMinDuration;
	long   FltFlags;
	int16  fFree;

	FltPrcName = FltPrcID.Name;

	iteration {
		link   Processor PrcID;
		link   TSession  TSessID;
		date   StDt;
		time   StTm;
		date   FnDt;
		time   FnTm;
		long   Duration;

		string TxtPeriod[48];
		string TxtDuration[16];

		PrcName   = PrcID.Name;
		TSessName = TSessID.Name;
	}
}
//
// Информация об отчетах
//
data RptInfo {
	declare "Destroy"
	link Global Glb;
	CurDate = Glb.CurDate;

	iteration {
		string StdName[30];
		date   ModifDt;
		string Descr[128];
		string DataStruc[30];
		string AltName[70];
		long   Type;
		TypeText =
			if(Type == 1)
				"Стандартный"
			else if(Type == 2)
				"Локальный";
	}
}

data SCardSerView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	iteration {
		link   QuotKind    QuotKindID;
		link   PersonKind  PsnKindID;
		string Name[30];
		string CodeTempl[18];
		double PDis;
		double MaxCredit;
		date   IssueDate;
		date   Expiry;
		int16  fCredit;
		QuotKind    = QuotKindID.Name;
		PsnKind     = PsnKindID.Name;
		CrdCardSymb = (fCredit == 0) ? "" : "К";
	}
}
//
//
//
data GoodsGroupView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global  Glb;
	int16  GrpType;
	int16  Reserve;              // @alignment
	CurDt     = Glb.CurDate;
	OrgName   = Glb.MainOrgName;
	TitleText = ((GrpType == 0) ? "Т" : (((GrpType == 1) ? "Обычные" : "Альтернативные") + " т")) + "оварные группы";

	iteration {
		link   GoodsGroup GrpID; //
		long   Level;            // Уровень вложенности группы (0 - родителей нет)
		string Code[16];         // Код группы
		int16  fAlt;             // Альтернативная группа
		int16  fTempAlt;         // Временная альтернативная группа
		int16  fDynAlt;          // Динамическая альтернативная группа
		int16  fReserve;         // @alignment
		Name       = GrpID.Name;
		//@v10.2.0 FullName   = GrpID.FullName;
		FullName   = GrpID.GetFullName(); // @v10.2.0
		UnitName   = GrpID.Name;
		PhUnitName = GrpID.PhUnitID.Name;
		TypeName   = GrpID.TypeID.Name;
		TaxGrpName = GrpID.TaxGrpID.Name;
		GdsClsName = GrpID.ClsID.Name;
		GrpSymb    = (fAlt ? "A" : "") + (fTempAlt ? "T" : "") + (fDynAlt ? "D" : "");
	}
}
//
//
//
data PersonEventOp {
	key    ID;             // @id
	string Name[48];       // @name
	string Symb[20];       // Символ
	link   RegisterType RegTypeID; // ->Ref(PPOBJ_REGISTERTYPE).ID Тип регистрационного документа
	int16  ExValGrp;       // Группа дополнительного значения (POPKEVG_XXX)
	int16  PairType;       // Тип парности (POPKPT_XXX)
		// 0 (POKPT_NONE)  Не парная (PPPsnOpKind::PairOp == 0)
		// 1 (POKPT_OPEN)  Открывающая      //
		// 2 (POKPT_CLOSE) Закрывающая      //
		// 3 (POKPT_NULLCLOSE) Нуль-закрывающая (открывающая операция не обязательна) //
	long   ExValSrc;       // Источник дополнительного значения //
		// if(ExValGrp == POPKEVG_TAG) then ExValSrc ->Ref(PPOBJ_TAG).ID
	long   Flags;          // Флаги (POPKF_XXX)
	link   OprKind LinkBillOpID; // ->Ref(PPOBJ_OPRKIND).ID
	link   PersonEventOp PairOp; // @#{PairOp != ID} ->self.ID   Парная операция //
}
//
// Базовая структура персональной операции
//
data PersonEventBase {
	key    ID;          // Ид
	date   Dt;          // Дата
	time   Tm;          // Время операции
	long   OprNo;       // Номер операции за дату
	link   PersonEventOp OpID;       // Вид персональной операции ->Ref(PPOBJ_PERSONOPKIND)
	link   Person        PersonID;   // Первичная персоналия      ->Person.ID
	link   Person        SecondID;   // Вторичная персоналия      ->Person.ID
	link   Location      LocID;      // Локация                   ->Location.ID
	link   Bill          LinkBillID; // Связанный документ
	long   Extra;       // Доп идентификатор        ->???
	long   Flags;       // Флаги
	int16  EstDuration; // Ожидаемая продолжительность незакрытого парного состояния (дней)
		// Пользователь это значение может ввести только для открывающей парной операции
	int16  Reserve;     // @alignment
	link   SCard PrmrSCardID; // Первичная персональная карта (связанная с первичной персоналией)
	link   SCard ScndSCardID; // Вторичная персональная карта (связанная со вторичной персоналией)
	string Memo[240];   // Примечание
	//
	// Descr: Возвращает ссылку на структуру парного события.
	// ARG(dir IN): направление поиска парной операции
	//   0 - (recomended) искать по направлению парности операции (для открывающей парной - вперед, для закрывающей - назад)
	//   1 - искать вперед по шкале времени
	//  -1 - искать с отсчетом времени назад
	//   2 - искать сначала вперед, затем - назад
	//
	link   PersonEventBase GetPair(int dir);
	//
	// Descr: Возвращает время, прошедшее до парного события. Если данное событие не
	//   имеет парного, то функция возвращает 0.
	//   Если парное событие предшествует данному, то продолжительность положительная.
	//   Если парное событие имело место после данного, то продолжительность отрицательная.
	//   Если парное событие не обнаружено, то результат - 0.
	//
	// ARG(dir IN): направление поиска парной операции
	//   0 - (recomended) искать по направлению парности операции (для открывающей парной - вперед, для закрывающей - назад)
	//   1 - искать вперед по шкале времени
	//  -1 - искать с отсчетом времени назад
	//   2 - искать сначала вперед, затем - назад
	//
	long   GetPairDuration(int dir);
}

data PersonEvent {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	date   FltBeg;
	date   FltEnd;            // Период обзора
	link   Person FltPrmrID;  // Первичная персоналия //
	link   Person FltScndID;  // Вторичная персоналия //
	int16  FltPsnEvSubst;     // Параметр подстановки
	int16  FltDateSubst;      // Параметр подстановки даты

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period      = formatperiod(FltBeg, FltEnd);
	FltPrmrName = FltPrmrID.Name;
	FltScndName = FltScndID.Name;
	FltPsnEvSubstTxt =
		if(FltPsnEvSubst == 1)
			"по виду операции"
		else if(FltPsnEvSubst == 2)
			"по первичной персоналии"
		else if(FltPsnEvSubst == 3)
			"по вторичной персоналии"
		else
			"";
	FltDateSubstTxt =
		if(FltDateSubst == 1)
			"по неделе"
		else if(FltDateSubst == 2)
			"по месяцу"
		else if(FltDateSubst == 3)
			"по кварталу"
		else if(FltDateSubst == 4)
			"по году"
		else
			"";

	iteration {
		link PersonEventBase EvID;
		string GrpText1[48];
		string GrpText2[48];
		string AvgEvTime[32];
		long   GrpCount;
		Dt = EvID.Dt;
		Tm = EvID.Tm;
		TmTxt      = format(Tm, ~>&N);
		OprNo      = EvID.OprNo;
		LocName    = EvID.LocID.Name;
		PersonName = EvID.PersonID.Name;
		SecondName = EvID.SecondID.Name;
		OpName     = EvID.OpID.Name;
		Memo       = EvID.Memo;
	}
}
//
//
//
data PsnEventItem {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	link PersonEventOp PsnOpID;
	link Warehouse LocID;
	//link Person    PersonID;
	link Employee  PersonID;
	link Person    SecondID;
	link PersonRegister RegisterID;
	date   Dt;
	time   Tm;
	long   OprNo;
	long   Duration;                // Продолжительность
	string Memo[128];
	CurDt    = Glb.CurDate;
	OrgName  = Glb.MainOrgName;
	Director = Glb.Director;
	PersonName = PersonID.EmplName;
	SecondName = SecondID.Name;
	LocName    = (LocID == 0) ? PersonID.DivName : LocID.Name;
	PostName   = PersonID.PostName;
	TabNum     = PersonID.TabNum;
	DocNumber  = RegisterID.Number; // Номер документа
	BegDate    = RegisterID.Dt;     // Дата начала действи
	EndDate    = RegisterID.Expiry; // Дата окончания действи
	TxtBegDate = Date2WStr(BegDate, 48);
	TxtEndDate = Date2WStr(EndDate, 48);
	DurationTxt =
		if(Duration == 0)
			""
		else
			Num2Str((double)Duration, 48);
	OpName = PsnOpID.Name;

	iteration {
		link   TagType TagID;
		long   nn;
		TagName = TagID.Name;
		string TagValue[128];
	}
}
//
//
//
data PsnRelList {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	iteration {
		link Person    PersonID;
		link Person    SecondID;

		PersonName = PersonID.Name;
		SecondName = SecondID.Name;
		string RelationName[30];
	}
}
//
//
//
data JobPool {
	declare "Destroy"
	declare "DOSSTUB"

	link Global Glb;
	CurDt   = Glb.CurDate        @curdate ~<;
	OrgName = Glb.MainOrgName    @mainorg ~<;

	iteration {
		long    nn ~>;
		long    ID ~>;
		string  Name[48] ~<;
		string  Symb[32] ~<;
		string  DateTimeRepeating[48] ~<;
	}
}
//
//
//
data Salary {
	declare "Destroy"

	link   Global Glb;
	date   FltBeg;                     // Начало обзора периода начисления //
	date   FltEnd;                     // Конец  обзора периода начисления //
	link   PersonPost FltPostID;       // Штатное назначение (может конфликтовать с PersonID)
	link   SalCharge  FltSalChargeID;  // Вид штатного начисления //
	link   Person     FltOrgID;        // Предприятие
	link   Location   FltDivID;        // Подразделение
	link   StaffNom   FltStaffID;      // Штатная должность
	link   Person     FltPersonID;     // Персоналия (может конфликтовать с PostID)
	long   FltFlags;                   // Флаги

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltPeriod = formatperiod(FltBeg, FltEnd);

	iteration {
		long   ID;                     // Идентификатор элемента
		date   Beg;                    // Начало периода расчета
		date   End;                    // Окончание периода расчета
		link   PersonPost PostID;      // Штатное назначение, по которому сделан расчет
		link   SalCharge  SalChargeID; // Штатное начисление, использованное для расчета
		double Amount;                 // Сумма начисления //
		long   Flags;                  // Флаги
		link   Bill LinkBillID;        // Документ, по которому сгенерировано начисление
		link   Bill GenBillID;         // Документ, сгенерированный по этому начислению
		long   RByGenBill;             // Номер строки документа LinkBillID, соответствующей этой записи
		string ChargeName[30];         // Наименование начисления (в случае кросстаба добавляется номер начисления в группе)

		FltPeriod  = formatperiod(Beg, End);
		PostCode   = PostID.Code;
		StaffName  = PostID.StaffID.Name;
		PersonName = PostID.PersonID.Name;
	}
}
//
//
//
data SalaryByPost {
	declare "Destroy"

	link   Global Glb;
	date   FltBeg;                     // Начало обзора периода начисления //
	date   FltEnd;                     // Конец  обзора периода начисления //
	link   PersonPost FltPostID;       // Штатное назначение (может конфликтовать с PersonID)
	link   SalCharge  FltSalChargeID;  // Вид штатного начисления //
	link   Person     FltOrgID;        // Предприятие
	link   Location   FltDivID;        // Подразделение
	link   StaffNom   FltStaffID;      // Штатная должность
	link   Person     FltPersonID;     // Персоналия (может конфликтовать с PostID)
	long   FltFlags;                   // Флаги

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Accountant = Glb.Accountant;
	Director   = Glb.Director;
	FltPeriod = formatperiod(FltBeg, FltEnd);

	iteration {
		long   ID;                     // Идентификатор элемента
		date   Beg;                    // Начало периода расчета
		date   End;                    // Окончание периода расчета
		link   PersonPost PostID;      // Штатное назначение, по которому сделан расчет
		FltPeriod  = formatperiod(Beg, End);
		PostCode   = PostID.Code;
		StaffName  = PostID.StaffID.Name;
		PersonName = PostID.PersonID.Name;
		PersonTabNum = PostID.PersonID.GetRegister("TAB_NUM").Number; // Табельный номер сотрудника
		//
		// Descr: Возвращает сумму начисления //
		//
		double GetAmount(string chargeSymb[20]);

		N_SAL      = GetAmount("SAL");       // Оклад
		N_SAL_A    = GetAmount("SAL_A");     // Аванс выданный
		N_REG_F    = GetAmount("REG_F");     // Фактическое количество отработанных дней по регулярному календарю
		N_REG_NORM = GetAmount("REG_NORM");  // Норма рабочих дней по регулярному календарю
		N_ATW_F    = GetAmount("ATW_F");     // Фактическое количество отработанных дней по календарю выходов на работу
		N_ATW_NORM = GetAmount("ATW_NORM");  // Норма рабочих дней по календарю выходов на работу
		N_NDFL     = GetAmount("NDFL");      // Сумма НДФЛ
		N_NDFL_BASE= GetAmount("NDFL_BASE"); // База для расчета НДФЛ
		N_NDFL_101 = GetAmount("NDFL_101");
		N_NDFL_103 = GetAmount("NDFL_103");
		N_MONEY    = GetAmount("MONEY");     // Сумма "На руки"
		N_SAL_S    = GetAmount("SAL_S");     // Оклад по отдельному начислению SAL_S (для специального расчета по формуле)
		N_CNORD    = GetAmount("CNORD");     // Северная надбавка
		N_CREG     = GetAmount("CREG");      // Районная надбавка
		N_ILL      = GetAmount("ILL");       // Начисление по больничному листу
		N_HOLIDAY  = GetAmount("HOLIDAY");   // Начисление отпускных
	}
}
//
//
//
data StaffCalView {
	declare "Destroy"

	link   Global Glb;
	date   FltBeg;                     // Начало периода //
	date   FltEnd;                     // Конец  периода //
	long   FltFlags;                   // Флаги
	link   DataObject FltLinkObjType;  // Тип связанных объектов
	long   FltSingleLinkObjID;         // Единственный связанный объект из списка
	link   StaffCal   FltSingleCalID;  // Единственный календарь из списка
	long   FltOrder;                   // Порядок сортировки
	string FltSingleObjName[64];
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	FltPeriod = formatperiod(FltBeg, FltEnd);
	FltLinkObjName    = FltLinkObjType.Name;
	FiltSingleCalName = FltSingleCalID.Name;

	iteration {
		link   StaffCal CalID;
		date   Dt;
		time   TmStart;
		time   TmEnd;
		long   Duration;
		long   Flags;
		link   DataObject LinkObjType;
		long   LinkObjID;
		string LinkObjName[64];
		string TxtDur[20];
		long   Count;
		string DtText[32];
		CalName  = CalID.Name;
		TxtTmStart = (format(TmStart, ~>&N));
		TxtTmEnd   = (format(TmEnd,   ~>&N));
	}
}
//
// Штатное расписание
//
data StaffListView {
	declare "Destroy"

	link   Global Glb;
	link   AmountType ExtAmt1ID;
	link   AmountType ExtAmt2ID;
	link   AmountType ExtAmt3ID;
	OrgName    = Glb.MainOrgName;
	Accountant = Glb.Accountant;
	ExtAmt1Name = ExtAmt1ID.Name;
	ExtAmt2Name = ExtAmt2ID.Name;
	ExtAmt3Name = ExtAmt3ID.Name;
	iteration {
		link   StaffNom StaffID;
		DivName  = StaffID.DivID.Name;
		PostName = StaffID.Name;
		VacCount = StaffID.VacancyCount;
		VacBusy  = StaffID.VacancyBusy;
		double BaseAmt;
		double ExtAmt1;
		double ExtAmt2;
		double ExtAmt3;
	}
}
//
// Структура определителя бизнес-показателя //
//
data BizScore {
	declare "Set"

	key    ID;
	string Name[48];
	string Symb[20];
	link   User UserID;
	long   Flags;
	string Descr[128];
	string Formula[252];
}
//
// Структура списка значений бизнес-показателей
//
data BizScoreValView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	date   FltBeg;              // Начало периода расчетной даты
	date   FltEnd;              // Конец периода расчетной даты
	date   SinceDate;           // Дата, начиная с которой отсчитываются моменты модификации записей
	time   SinceTime;           // Время, начиная с которого отсчитываются моменты модификации записей
	link   User     FltUserID;
	link   BizScore FltScoreID;
	long   Flags;               //
	long   Order;               //

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	Period  = formatperiod(FltBeg, FltEnd); // Период расчетной даты

	iteration {
		date   ActualDate;         // Дата, для которой проводился расчет
		date   Dt;                 // Дата расчета
		time   Tm;                 // Время расчета
		string DbUUID[40];         // UUID базы данных
		link   User       UserID;  // ->Ref(PPOBJ_USR)
		link   BizScore   ScoreID; // ->Ref(PPOBJ_BIZSCORE)
		link   DataObject ObjType; // Тип связанного с показателем объекта
		long   ObjID;              // Ид связанного с показателем объекта
		long   Flags;              // Флаги значения. 0x01 - значение ниже допустимой границы,
			// 0x02 - значение выше допустимой границы.
		double Val;                // Числовое значение показателя //
		string Str[252];           // Строковое значение показателя //

		UserName = UserID.Name;
		ScoreName = ScoreID.Name;
		ScoreSymb = ScoreID.Symb;
		ScoreDescr = ScoreID.Descr;
	}
}
//
// Тест печати на локальный принтер
//
data LocPrnTest {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	string Name[48];
	link   Warehouse LocID;
	LocName = LocID.Name;
	iteration {
		long   IterNo;
		string TestIterText[255];
	}
}

//
// Список видов персональных операций
//
data PsnOpKindView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	iteration {
		link PersonEventOp PsnOpKindID;
		long   Level;            // Уровень вложенности персональной операции (0 - родителей нет)
		Name       = PsnOpKindID.Name;
		OpKindName = PsnOpKindID.LinkBillOpID.Name;
		RegTypName = PsnOpKindID.RegTypeID.Name;
	}
}
//
// Список транспортных средств
// @v7.2.8 Verification needed
//
data TransportView {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;
	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;
	long FltType;
	link Person  FltOwnerID;
	link Person  FltCaptainID;
	link Country FltCountryID;
	string FltCode[16];
	string FltTrailCode[16];
	string FltModelName[48];
	FltTypeName = (FltType == 1) ? "Автомобиль" : "Судно";
	FltOwnerName   = FltOwnerID.Name;
	FltCaptainName = FltCaptainID.Name;
	FltCountryName = FltCountryID.Name;

	iteration {
		link Transport TransportID;
		Name        = TransportID.Name;
		TypeName    = (TransportID.TrType == 1) ? "Автомобиль" : "Судно";
		ModelName   = TransportID.ModelName;
		OwnerName   = TransportID.OwnerID.Name;
		CaptainName = TransportID.CaptainID.Name;
		CountryName = TransportID.CountryID.WID.CountryID.Name;
		Code        = TransportID.Code;
		TrailCode   = TransportID.TrailerCode;
		Capacity    = TransportID.Capacity; // Грузоподъемность, кг
	}
}
//
// Элемент бюджета
//
data BudgetItem {
	long     ID;
	long     BudgetID;
	link     Account Acc;
	long     Flags;
	long     Kind;
	date     Dt;
	double   Amount;
	string   Memo[256];
}
//
// Бюджет
//
data Budget {
	declare "Destroy"
	declare "DOSSTUB"

	link   Global Glb;

	CurDt   = Glb.CurDate;
	OrgName = Glb.MainOrgName;

	string Name[32];
	string Code[16];
	date   PeriodBeg;              // Начало периода расчетной даты
	date   PeriodEnd;              // Конец периода расчетной даты

	iteration {
		link BudgetItem BudgItemID;
		long No;
		ItemCode = BudgItemID.Acc.Code;
		ItemName = BudgItemID.Acc.Name;
		KindText = (BudgItemID.Kind > 0) ? "Факт" : "План";
		Dt     = BudgItemID.Dt;
		Amount = BudgItemID.Amount;
		Memo   = BudgItemID.Memo;
		AmtPlan = (BudgItemID.Kind > 0) ? 0 : BudgItemID.Amount;
		AmtFact = (BudgItemID.Kind > 0) ? BudgItemID.Amount : 0;
	}
}
//
// Системный журнал
//
data CheckOpJrnl {
	declare "Destroy"

	link Global Glb;
	link User       FltUserID;
	long FltAction;
	date FltBeg;
	date FltEnd;
	Period = formatperiod(FltBeg, FltEnd);

	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;

	iteration {
		link   User       UserID;
		link   Goods      GoodsID;
		link   CCheck     CheckID;
		long   CheckNum;
		long   ActionID;
		date   Dt;
		time   Tm;
		string ActionName[48];
		string PrinterName[48];
		double Price;
		double Summ;

		TmTxt       = (format(Tm, ~>&N));
		UserName    = UserID.Name;
		GoodsName   = GoodsID ? GoodsID.Name : "";
	}
}
//
//
//
data LocTransfView {
	declare "Destroy"

	link   Global Glb;
	link   GoodsGroup FltGoodsGrpID;
	link   Goods FltGoodsID;
	link   Lot   FltLotID;
	long   Mode; // 0 - операции, 1 - текущие остатки, 2 - пустые ячейки, 3 - размещение документов
	long   MoveOp;

	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;

	iteration {
		long   TempID__;
		link   WhCell  CellID;
		long   RByLoc;
		date   Dt;
		time   Tm;
		link   User UserID;
		link   Bill BillID;
		long   RByBill;
		long   Op;
		long   Flags;
		link   Goods GoodsID;
		link   Lot   LotID;
		long   PalletTypeID;
		long   PalletCount;
		double RestByGoods;        // Остаток в ячейке после операции по товару
		double RestByLot;          // Остаток в ячейке после операции по лоту
		double Qtty;               // Количество в операции
		double BillQtty;           // Количество в связанной строке документа
	}
}
//
//
//
data GeoTracking {
	declare "Destroy"

	link   Global Glb;
	date   FltBeg;   // Дата начала периода обзора
	date   FltEnd;   // Дата окончания периода обзора
	time   FltBegTm; // Время начала периода обзора (действует только если FltBeg != 0)
	link   DataObject FltObjType;
	long   FltObjID;
	link   DataObject FltExtObjType;
	long   FltExtObjID;
	double LuLat; // Географическая широта левого верхнего угла
	double LuLon; // Географическая долгота левого верхнего угла
	double RbLat; // Географическая широта правого нижнего угла
	double RbLon; // Географическая долгота правого нижнего угла

	Period = formatperiod(FltBeg, FltEnd);
	OrgName = Glb.MainOrgName;
	CurDate = Glb.CurDate;

	iteration {
		long   ObjType;    // Тип объекта, с которым связана регистрация положения
		long   ExtObjType; // Тип дополнительного объекта, с которым связана регистрация положения
		long   ObjID;      // ИД объекта, с которым связана регистрация положения
		long   ExtObjID;   // ИД дополнительного объекта, с которым связана регистрация положения
		long   Flags;      // Флаги положения
		long   ExtEvent;   // Дополнительное значение, обеспечивающее привязку регистрации местоположения к некоторому событию
		date   Dt;
		time   Tm;         // Время
		double Latitude;   // Географическая широта  (degree)
		double Longitude;  // Географическая долгота (degree)
		long   Altitude;   // Высота, m
		long   Speed;      // Скорость, dm/sec
	}
}
//
// Структура, представляющая абстрактный список, состоящий из идентификатора
// объекта, идентификатора родительского объекта и текста.
// Note:
//   При создании в качестве идентификатора должен передаваться указатель на структуру StrAssocArray
//
data StrAssocArray {
	iteration {
		long   Id;
		long   ParentId;
		string Txt[128];
	}
}

data IntArray {
	iteration {
		long   Id;
	}
}
//
//
// Структуры данных для проекта Universe-HTT
//
//
data UhttGoods {
	declare "Set"
	//
	key    ID;
	link   GoodsGroup    GroupID;      // Родительская группа
	link   Unit          UnitID;       // Торговая единица измерения   //
	link   Unit          PhUnitID;     // Физическае единица измерения //
	link   GoodsType     TypeID;       // Тип товара
	link   GoodsClass    ClsID;        // Класс товара
	link   Person        ManufID;      // Производитель
	link   GoodsTaxGrp   TaxGrpID;     // Налоговая группа
	link   Brand         BrandID;      // Торговая марка
	long   Flags;                      // @flags
	double PhPerUnit;                  // Соотношение физических единиц к торговым
	double Brutto;                     // Масса брутто одной единицы товара, кг
	long   Length;                     // Габаритная длина упаковки поставки,  мм
	long   Width;                      // Габаритная ширина упаковки поставки, мм
	long   Height;                     // Габаритная высота упаковки поставки, мм
	double Package;                    // Емкость упаковки поставки (торговых единиц)
	int32  ExpiryPeriod;               // Срок годности товара (дней).
	string Name[256];                  // @name
	string Storage[4000];              // Условия хранения товара
	string Standard[4000];             // Стандарт или тех условия изготовления товара
	string Ingred[4000];               // Ингредиенты
	string Energy[4000];               // Энергетическая ценность
	string Usage[4000];                // Способ использования (приготовления)
	string OKOF[24];                   // Код ОКОФ для основных средств
	//
	iteration BarcodeList {
		string Code[20];
		double Package;
	}
	iteration TagList {
		link   TagType  TagTypeID;
		string TagSymb[20];
		long   IntVal;
		double RealVal;
		date   DateVal;
		string StrVal[1024]; // @v10.7.9 [128]-->[1024]
	}
}
//
// Descr: Представление товарного кода, ассоциированного с контрагентом.
// В качестве идентификатора должен передаваться указатель на структуру UhttGoodsArCodeIdent
//
data UhttGoodsArCode {
	long   GoodsID;
	string ArCode[32];
	string Name[128];
}

data UhttPerson {
	declare "Set"
	//
	key    ID;
	link   Person PsnID;            //
	link   PersonCat    CategoryID; // ИД категории, к которой относится персоналия //
	link   PersonStatus StatusID;   // ИД юридического статуса
	string Name[128];               //
	string Code[32];                //
	string Memo[256];               //
	CategoryName = CategoryID.Name;
	StatusName   = StatusID.Name;
	//
	iteration KindList {
		link PersonKind KindID;
		string Name[48]; // Из-за метода Set здесь нельзя применять функцию (KindID.Name)
		string Code[20]; // Из-за метода Set здесь нельзя применять функцию (KindID.Code)
	}
	iteration PhoneList {
		string Code[64];
	}
	iteration EMailList {
		string Code[64];
	}
	iteration UrlList {
		string Code[64];
	}
	iteration RegisterList {
		link   PersonRegister RegID;
		link   RegisterType RegTypeID;
		link   Person PersonID;
		link   Person RegOrgID;
		date   RegDt;
		date   RegExpiry;
		string RegSerial[12];
		string RegNumber[32];
	}
	iteration AddrList {
		link   Location LocID;
		link   City CityID;
		int    LocKind;           // 0 - undefined, 1 - legal, 2 - residence place, 3 - delivery addr
		string LocCode[16];       // Код локации (возможно, GLN)
		string LocName[48];
		string ZIP[16];
		string Address[128];
		double Latitude;
		double Longitude;
		CountryID = LocID.CityID.CountryID;
		Country   = LocID.CityID.CountryID.Name;
		City      = LocID.CityID.Name;
	}
}
//
// Структура представления значения котировки для интерфейса с проектом Universe-HTT //
// В качестве идентификатора должен передаваться указатель на структуру PPQuot
//
data UhttQuot {
	link   QuotKind QuotKindID;                    // ИД вида котировки
	link   Article  SellerArID;                    // @internal ИД статьи поставщика
	link   Location SellerLocID;                   // ИД склада поставщика
	link   Article  BuyerArID;                     // @internal Если запрос котировок содержал ИД статьи покупателя, то это поле равно такому ИД.
	link   Goods    GoodsID;                       // ИД товара
	link   Currency CurID;                         // ИД валюты
	long   Flags;                                  // Флаги значения //
	date   Dt;                                     // Дата установки значения //
	time   Tm;                                     // Время установки значения //
	long   MinQtty;                                // Минимальное количество, для которого справедливо значение Quot
	double Quot;                                   // Значение котировки

	QuotKindSymb = QuotKindID.Symb;                // Символ вида котировки
	SellerID = SellerArID.PersonID;                // ИД персоналии поставщика
	SellerCode = SellerArID.PersonID.SrchCode;     // Код поставщика
	SellerLocCode = SellerLocID.Code;              // Код склада поставщика
	BuyerID = BuyerArID.PersonID;                  // ИД персоналии покупателя //
	BuyerCode = BuyerArID.PersonID.SrchCode;       // Код покупателя //
	GoodsCode       = GoodsID.SingleBarCode;       // Штрихкод товара
	GoodsSellerCode = GoodsID.GetArCode(SellerArID); // Артикул товара от поставщика
	GoodsBuyerCode  = GoodsID.GetArCode(BuyerArID);  // Артикул товара от покупателя //
	CurSymb = CurID.Symb;                          // Символ валюты
}
//
// Структура, используемая для обмена значениями котировок с JobServer'ом
// Note:
//   При создании в качестве идентификатора должен передаваться указатель на структуру TSArray <PPQuotItem_>
//
data QuotArray {
	iteration {
		link   Goods     GoodsID;
		link   QuotKind  KindID;
		link   Location  LocID;
		link   Article   ArID;
		link   Currency  CurID;
		date   Dt;
		time   Tm;
		date   ActualPeriodUpp;
		date   ActualPeriodLow;
		double MinQtty;
		long   Flags;
		double Val;
		//
		//SellerID = LocID.OwnerID.ID;
		BuyerID = ArID.PersonID.PersonID.ID;
	}
}
//
// Структура глобальной учетной записи
//
data GlobalUserAcc {
	declare "Set"
	//
	key    ID;
	link   Person PersonID; //
	string Name[48];
	string Symb[20];
	string Password[40];
	link   User LocalUserID;
	long   Flags;
	string Descr[128];
	link   ObjectTag GetTag(string tagSymb[20]); // @v11.3.7
}
//
// Курс валюты
// @uhtt
//
data UhttCurRateIdent {
	declare "Set"
	//
	link   Currency     CurID;
	link   Currency     BaseCurID;
	link   CurRateType  RateTypeID;
	date   Dt;
	double Rate;
}
//
// Массив курсов валют
// @uhtt
//
data UhttCurRateArray {
	iteration {
		link   Currency     CurID;
		link   Currency     BaseCurID;
		link   CurRateType  RateTypeID;
		date   Dt;
		string Ts[16];
		double Rate;
	}
}
//
// Локация
// @uhtt
//
data UhttLocation {
	declare "Set"
	//
	key    ID;
	link   Location ParentID;      // Родительская локация
	int16  Type;                   // Тип локации
		// 1 - склад главной организации
		// 2 - складская зона хранени
		// 3 - адрес персоналии
		// 4 - структурное подразделение
		// 5 - группа складов
	int16  Flags;                  // @flags
	link   Person OwnerID;         // Персоналия-владелец локации
	link   City CityID;            // Город
	string Code[16];               // Код локации (внутренний символ для идентификации)
	string Name[64];               // @name
	string ZIP[16];                // Почтовый код адреса
	double Latitude;               // Географическая широта
	double Longitude;              // Географическая долгота
	string Address[256];           // Строка адреса
	string Phone[48];              // Телефон (специализированное поле)
	string EMail[128];             // Электронная почта, ассоциированная с (автономным) адресом
	string Contact[128];           // Наименование контакта, ассоциированное с адресом
}
//
// Документ
// @uhtt
//
data UhttBill {
	key       ID;
	date      Dt;
	string    Code[24];
	link      OprKind       OprKindID;
	link      Article       ArticleID;
	link      UhttLocation  LocID;
	link      UhttLocation  DlvrLocID;
	link      Currency      CurID;
	link      Article       AgentID;
	link      BillStatus    StatusID;
	double    Amount;
	double    Discount;
	string    GUID[40];
	long      Flags;
	string    Memo[256];
	iteration Items {
		link   Goods  GoodsID;
		string Serial[32];
		double Qtty;
		double Cost;
		double Price;
		double Discount;
		double Amount;
		long   Flags;
		long   TSessID;        // Идентификатор сессии, для которой необходимо зафиксировать регистрацию
		string PlaceCode[16];  // Код посадочного места, для которого фиксируется регистрация по техсессии (TSessID)
	}
}
//
// Специальные серии
// @uhtt
//
data UhttSpecSeries {
	declare "Set"
	//
	key    ID;
	link   Goods   GoodsID;
	link   Person  LabID;
	link   Person  ManufID;
	link   World   ManufCountryID;
	string Serial[32];
	string GoodsName[48];
	string Barcode[32];
	string ManufName[48];
	date   InfoDate;
	int    InfoKind;
	string InfoIdent[24];
	date   AllowDate;
	string AllowNumber[24];
	string LetterType[8];
	int    Flags;
}
//
// Информация по бонусным картам
// @uhtt
//
data UhttSCardOpArray {
	long   TotalSellCnt;
	double TotalSellAmt;
	long   TotalChargeCnt;
	double TotalChargeAmt;
	long   TotalWithdrawCnt;
	double TotalWithdrawAmt;
	double TotalSCardRest;
	iteration {
		link   SCard     SCardID;
		link   Location  DlvrLocID;
		date   Dt;
		time   Tm;
		long   SellCount;
		double SellAmt;
		long   ChargeCount;
		double ChargeAmt;
		long   WithdrawCount;
		double WithdrawAmt;
		double SCardRest;
	}
}
//
// Интернет магазин
// @uhtt
//
data UhttStore {
	declare "Set"
	//
	key    ID;
	link   UhttPerson   OwnerID;
	link   UhttLocation LocID;
	string Name[48];              // @name
	string Symb[20];              //
	int    Kind;                  // Вид магазина: 0 - generic store, 1 - tsessio cip
	int    Flags;                 // @flags
	double UpRestShowThreshold;   // Порог остатка, после которого следует отображать значение в виде "более 8"
	iteration TagList {
		link   TagType  TagTypeID;
		string TagSymb[20];
		long   IntVal;
		double RealVal;
		date   DateVal;
		string StrVal[128];
	}
}
//
// Массив товаров интернет магазина
// @uhtt
//
data UhttStoreItemArray {
	iteration {
		link   UhttGoods  GoodsID;
		link   Currency   CurID;
		date   Dt;
		time   Tm;
		double Value;
		double Rest;
		int    Flags;
		GoodsName = GoodsID.Name;
		CurName   = CurID.Name;
		Package   = format(GoodsID.Package, ~>.2$);
	}
}
//
// Статистика
// @uhtt
//
data UhttStatistic {
	key   ID;
	int   GGroupsNumber;
	int   BrandsNumber;
	int   GoodsNumber;
	int   PersonNumber;
}
//
// Список остатков товара по складам
// @uhtt
//
data UhttDraftTransitGoodsRestList {
	iteration {
		link    UhttGoods     GoodsID;
		link    UhttLocation  LocID;
		double  Rest;
		date    RestBillDt;
	}
}
//
// Контент
// @uhtt
//
data UhttWorkbook {
	declare "Set"
	//
	key    ID;
	link   UhttWorkbook  ParentID;
	link   UhttWorkbook  CssID;
	link   UhttWorkbook  LinkID;
	string Name[128];             // @name
	string Symb[20];              //
	int    Type;
	int    Rank;
	int    Flags;
	int    KeywordCount;          // Количество ключевых слов в генерируемой заглушке для crawler
	int    KeywordDilute;         // Параметр разжижения ключевых слов в генерируемой заглушке для crawler
	//
	// Внимание: {Dt, Tm} - не дата последнего изменения, но просто условная временная метка записи. Например, дата/время новости и т.д.
	//
	date   Dt;                    // Дата содержания содержания //
	time   Tm;                    // Временная метка содержания //
	//
	date   ModifDt;               // Дата последней модификации записи //
	time   ModifTm;               // Время последней модификации записи //
	date   ContentModifDt;        // Дата последней модификации файла содержания //
	time   ContentModifTm;        // Время последней модификации файла содержания //
	string Version[8];            // Символ версии записи
	string Descr[512];            // Описание
	iteration TagList {
		link   TagType  TagTypeID;
		string TagSymb[20];
		long   IntVal;
		double RealVal;
		date   DateVal;
		string StrVal[1024];
	}
}
//
//
//
data UhttStyloDevice {
	declare "Set"
	//
	key    ID;
	string Name[48];
	string Symb[20];
	link   UhttStyloDevice ParentID;
	long   Flags;
	long   DeviceVer;
	string RegisterTime[24];
}

data UhttProcessor {
	declare "Set"
	//
	key    ID;
	string Name[48];
	string Symb[20];
	link   UhttProcessor ParentID;
	long   Kind;
	long   Flags;
	link   Location LocID;
	link   DataObject LinkObjType;
	long   LinkObjID;
	link   PersonKind CipPersonKindID;
	long   CipMax;
	long   OwnerGuaID; // Глобальная учетная запись - владелец процессора
	iteration Places {
        link Goods GoodsID;
        string Range[256];
        string Descr[256];
	}
}

data UhttTSession {
	declare "Set"
	//
	key    ID;
	long   Num; // Номер сессии (уникальный по процессору)
	link   Processor PrcID;
	link   Tech TechID;
	link   TSession ParentID;
	long   Status;
	long   Flags;
	string StTime[24];      // Время начала сессии (дата/время в формате ISO8601)
	string FinTime[24];     // Время окончания сессии (дата/время в формате ISO8601)
	string Memo[256];       // Примечание
	string Detail[4000];    // Длинное описание сессии
	iteration Lines {
		link   TSession TSessID;
		long   OprNo;
		link   Goods GoodsID;
		link   Lot   LotID;
		link   User  UserID;
		long   Sign;
		string Tm[24];
		long   Flags;
		double Qtty;
		double WtQtty;
		double Price;
		double Discount;
		string Expiry[24];
		string Serial[32];
	}
	iteration Cips {
		long   ID;         // Идентификатор ассоциации. В пределах одного раздела БД строка идентифицируется этим полем.
		long   Kind;       // Вид ассоциации.
		long   PrmrID;     // Идентификатор первичного объекта, для которого фиксируется регистрация (например, PPObjTSession)
		link   Person PersonID; // ->Person.ID
		long   Num;        // Номер записи в однородном списке относительно заданного первичного объекта
		long   RegCount;   // Количество персоналий, включенное в данную регистрацию. Как правило =1,
			// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
		long   CiCount;    // Количество персоналий, включенное в данную регистрацию со статусом CheckedIn. Как правило =(0|1),
			// но в некоторых случаях может быть >1, например, для анонимной или групповой регистрации
		long   Flags;      // @flags
		string RegTm[24];  // Время регистрации //
		string CiTm[24];   // Время подтверждения регистрации (CheckID)
		double Amount;     // Сумма, уплаченная или которая должна быть уплачена за регистрацию (подтверждение)
		link   CCheck CCheckID; // Кассовый чек, которым оплачено подтверждение регистрации
		link   SCard  SCardID;  // Карта, с которой ассоциирована зерегистрированная персоналия //
		string Memo[256];       // Примечание
		string PlaceCode[16];   // Номер места (для регистрации, ассоциированной с посадочным местом)
	}
	iteration Places {
        link Goods GoodsID;
        string Range[256];
        string Descr[256];
	}
	iteration TagList {
		link   TagType  TagTypeID;
		string TagSymb[20];
		long   IntVal;
		double RealVal;
		date   DateVal;
		string StrVal[128];
	}
}
//
// Descr: Информация о статусе места регистрации для технологической сессии.
// Note: В качестве инициализирующих данных должна получать указатель на TSCollection<PPObjTSession::PlaceStatus>
//
data UhttTSessPlaceStatusList {
	iteration {
		link   TSession TSessID; // ИД технологической сессии
		string Code[8];          // Код места
		string PinCode[8];       // PIN-код, подтверждающий аутентичность заказа
		link   Goods GoodsID;    // Товар, ассоциированный с местом
		link   Person PersonID;  // Персоналия, ассоциированная с местом (заказчик). Если Status >= 0, то 0
		long   CipID;      // Идентификатор в таблице персональных регистраций сессии. Если Status >= 0, то 0
		double Price;      // Цена, полученная по котировке товара GoodsID
		int    Status;     // Статус места 0 - не идентифицировано, 1 - свободно, -1 - занято
		string Descr[128]; // Описание места
	}
}

data UhttCommonMqsConfig {
    string Address[128];
    string Login[128];
    string Secret[128];
}
//
// Descr: Специальная структура, используемая как базовая для
//   препроцессинга html-контента.
//
data HttpPreprocessBase {
	long   __Dummy;
}
