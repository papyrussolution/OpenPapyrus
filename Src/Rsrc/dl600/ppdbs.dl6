// PPDBS.DL6
// Copyright (c) A.Sobolev 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025
// @codepage UTF-8
// Database structures
//
// Общие справочники
//
// Первые 100 типов объектов и 100 идентификаторов объектов зарезервированы за главным приложением.
// Следующие 900 номеров зарезервированы для сторонних приложений.
// Пользовательские типы и идентификаторы начинаются с 1001.
//
// План конвертации v11.2.0
//   @done -- Bill: Code[24]-->Code[48]; Memo move to UnxTextRef; убрать индекс #7; ? добавить индекс {Code, Dt, OprNo}
//   @done -- Tech: Code[24]-->Code[48]; Memo move to UnxTextRef
//   @done -- Person: Memo move to UnxTextRef
//   @done -- PersonEvent: Memo move to UnxTextRef
//   -- AdvBillItem: AdvCode[24]-->AdvCode[48]; Memo move to UnxTextRef
//   -- CCheckExt: Memo move to UnxTextRef
//   -- BudgetItem: Memo move to UnxTextRef
//   -- BizScore: Str move to UnxTextRef
//   -- GlobalBizScore: ScoreDescr && Str move to UnxTextRef
//   -- UserFuncPrfSess: DbUUID_s и SessUUID_s преобразовать в guid; DbName, UserName, MachineName перенести в UnxTextRef
//

//
// Descr: Справочники (небольшие и многочисленные)
//
table Reference2 {         // size=148
	long   ObjType;        // Тип объекта
	long   ObjID;          // Ид объекта
	string ObjName[48];    // Наименование объекта
	string Symb[20];       // Альтернативный текст
	raw    ExtData[64];    // Произвольные данные (зависят от типа объекта)
	long   Val1;           // Дополнительные данные (зависят от типа объекта)
	long   Val2;           // Дополнительные данные (зависят от типа объекта)
index:
	ObjType, ObjID (unique);
	ObjType, ObjName acs (dup mod);
	ObjType, Val1 (dup mod);
	ObjType, Val2 (dup mod);
file:
	"ref2.btr";
	acstable = "rusncase.alt";
	access=3;
}
//
// Descr: Свойства объектов
//
// Первые 500 идентификаторов свойств зарезервированы за главным приложением.
// Следующие 500 - за сторонними приложениями. Пользовательские свойства начинаются с 1001.
//
table Property {           // size=84+2048
	long   ObjType;        // ->Reference.ObjType Тип объекта
	long   ObjID;          // ->Reference.ObjID   Ид объекта
	long   Prop;           // Ид свойства
	raw    Text[64];       //
	long   Val1;           // Значение 1
	long   Val2;           // Значение 2
	blob   VT[2048];
index:
	ObjType, ObjID, Prop (dup mod); // #0
	ObjType, Prop, ObjID (dup mod); // #1 @v6.2.2
file:
	"prop.btr";
	vlr;
	access=3;
}
//
// Descr: таблица, хранящая ассоциации GUID<->int32 с целью снизить издержки на хранение
//   GUID-идентификаторов там, где их использование необходимо.
//
table UuidRef {
	autolong ID;
	raw UUID[16];
index:
	ID (unique);
	UUID (unique);
file:
	"uuidref.btr";
	balanced;
	page=4096;
}
//
// Descr: Индексированные текстовые записи
//
table TextRef {
	long   ObjID;
	int16  ObjType;
	int16  Prop;
	int16  Lang;
	wstring Text[125];
	blob   VT[2048];
index:
	ObjType, Prop, Text ignorecase (dup mod);
	ObjType, Prop, ObjID, Lang (unique mod);
file:
	"textref.btr";
	compress;
	vlr;
}
//
// Descr: Неиндексированные текстовые записи произвольной длины
//
table UnxTextRef {
	long   ObjID;
	int16  ObjType;
	int16  Prop;
	int16  Lang;
	long   Size; // Длина текста, содержащегося в VT
	blob   VT[2048];
index:
	ObjType, Prop, ObjID, Lang (unique mod);
file:
	"unxtxref.btr";
	vlr;
}
//
// @v12.3.4
// Descr: Таблица для индексации операция по маркам егаис и чзн.
//   Необходима для ускорения выборки операций, связанных с конкретной маркой.
//   Сейчас такая выбора осуществляется без индексации из-за чего может быть очень медленной.
//
table ExtCodeRef {
	string Code[156];
	raw    Reserve[32];
	blob   VT[2048];
index:
	Code (unique mod); // #0
file:
	"xcoderef.btr";
	vlr;
}
//
//
//
table ObjLikeness {
	long   ObjType;
	long   ID1;
	long   ID2;
	double Rate;
index:
	ObjType, ID1, ID2 (unique mod);
	ObjType, ID1, Rate (dup mod);
	ObjType, Rate (dup mod);
file:
	"objliken.btr";
}
//
// Таблица синхронизации объектов. Используется для синхронизации объектов в распределенной базе данных.
//
// Координаты {DBID, ObjType, ObjID=0, CommIdPfx=DBID} используются для хранения последнего использованного
//   значения общего идентификатора CommID. Это необходимо для того, чтобы избежать сбоя синхронизации при
//   удалении объекта, соответствующего максимальному значению.
//
table ObjSync {            // size=24
	int16  DBID;           // ИД раздела БД, в которой объект имеет ИД ObjID
	int16  ObjType;        // Тип объекта
	long   ObjID;          // ИД объекта в БД ObjSync.DBID
	int16  CommIdPfx;      // Префикс общего идентификатора
	long   CommID;         // Общий для всех БД ИД объекта
	int16  Flags;          // 0x0001 - удален, 0x0002 - объединен
	date   Dt;             // Дата модификации объекта разделом DBID
	time   Tm;             // Время модификации объекта разделом DBID
index:
	ObjType, CommIdPfx, CommID, DBID (unique mod); // #0
	ObjType, ObjID, DBID (unique mod);             // #1
file:
	"objsync.btr";
	balanced;
}
//
// @construction
// Descr: Резервная таблица синхронизации. Содержит только записи синхронизации,
//   соответствующие собственному разделу базы данных.
//   Запись таблицы сжата
//
table ObjSyncBu {       // size=20
	int16  ObjType;     // Тип объекта
	long   ObjID;       // ИД объекта в БД ObjSync.DBID
	int16  CommIdPfx;   // Префикс общего идентификатора
	long   CommID;      // Общий для всех БД ИД объекта
	int16  Flags;       //
	int16  SDt;         // Дата модификации объекта разделом DBID (сокращенный формат даты)
	time   Tm;          // Время модификации объекта разделом DBID
index:
	ObjType, CommIdPfx, CommID (unique mod);
	ObjType, ObjID (unique mod);
file:
	"objsyncb.btr";
}
//
// Descr: Таблица очереди приема объектов из других разделов
//  Записи, содержащие наименования файлов с объектами, имеют поля {ObjType = 0; ObjID = 0;
//  CommIdPfx = 0; CommID = infile version; ObjName = file_name; FileId = 0;
//  ModDt = file_mod_date; ModTm = file_mod_time; Flags = org_file_header.Flags}.
//
table ObjSyncQueue {       // size=112
	autolong ID;           // @id
	int16  DBID;           // ИД раздела БД, в которой объект имеет ИД ObjID
	int16  ObjType;        // Тип объекта
	long   ObjID;          // ИД объекта в БД ObjSync.DBID
	int16  CommIdPfx;      // Префикс общего идентификатора
	long   CommID;         // Общий для всех БД ИД объекта
	int16  Flags;          //
	long   PrimObjID;      // Идентификатор объекта в собственном разделе (заполняется после акцепта объекта)
	date   ModDt;          // Дата  модификации объекта в разделе-отправителе
	time   ModTm;          // Время модификации объекта в разделе-отправителе
	long   Priority;       // Приоритет приема объекта (чем меньше значение, тем выше приоритет)
	long   FileId;         // Ид файла, в котором находится объект
	long   FilePos;        // Позиция в файле FileId, по которой располагается объект
	long   RedirID;        // ->ObjSyncQueue.ID Идентификатор записи, которая замещает этот объект
	note   ObjName[256];   // Наименование объекта в разделе-отправителе
index:
	ID (unique);
	ObjType, ObjID, DBID (anysegnull unique mod);
	ObjType, CommIdPfx, CommID, DBID (anysegnull unique mod);
	Priority, ModDt, ModTm (dup mod);
	RedirID (anysegnull dup mod);
file:
	"objsyque.btr";
	vlr;
}
//
// Таблица ассоциаций объектов
//
// Эта таблица позволяет хранить ассоциативные связи между объектами.
// Тип ассоциации (AsscType) определяет типы объектов и характер связи.
// Общим свойством всех связей, хранимых в этой таблице является то,
// что одному первичному (PrmrObjID) объекту может быть поставлено
// в соответствие множество вторичных объектов (ScndObjID).
//
table ObjAssoc {           // size=84
	autolong ID;           // @id
	long   AsscType;       // Тип ассоциации
	long   PrmrObjID;      // ИД первичного объекта
	long   ScndObjID;      // ИД вторичного объекта
	long   InnerNum;       // Номер вторичного объекта по внутренней классификации
	raw    Text[64];       // Наименование вторичного объекта (опционально) // @v6.2.2 string Name[48]-->raw Text[64]
index:
	ID (unique);
	AsscType, PrmrObjID, ScndObjID (unique mod);
	AsscType, ScndObjID, PrmrObjID (unique mod);
	AsscType, PrmrObjID, InnerNum  (unique mod);
file:
	"objassoc.btr";
	acstable = "rusncase.alt";
}
//
//
//
table ObjTag {             // size=156
	long   ObjType;        // Object type (PPOBJ_XXX)
	long   ObjID;          // Object ID
	long   TagID;          // ->Ref(PPOBJ_TAG).ID
	long   TagByObj;       // [ObjType, ObjID, TagID] Make keys unique
	long   IntVal;         //
	double RealVal;        //
	string StrVal[128];    // @v7.3.5 [48]-->[128]
index:
	ObjType, ObjID, TagID, TagByObj (unique mod);
	TagID, ObjID (dup mod);
	TagID, IntVal (dup mod);
	TagID, StrVal acs (anysegnull dup mod); // @v7.3.5 anysegnull
file:
	"objtag.btr";
	acstable = "rusncase.alt";
	compress;
	balanced;
}
//
// Индекс электронных адресов. Используется для быстрого поиска телефонов, ip-адресов и, возможно, чего-то еще.
//
table EAddr {
	autolong ID;           // @id
	long   LinkObjType;    // Тип связанного объекта
	long   LinkObjID;      // ИД связанного объекта
	raw    Addr[16];       // Структура адреса (PPEAddr)
index:
	ID (unique);
	Addr, LinkObjType, LinkObjID (unique mod);
	LinkObjType, LinkObjID, Addr (unique mod);
file:
	"eaddr.btr";
	balanced;
}
//
// Географические объекты
//
table World {           // size=156
	autolong   ID;      // @id
	long   Kind;        // WORLDOBJ_CONTINENT || WORLDOBJ_GENREGION || WORLDOBJ_COUNTRY || WORLDOBJ_REGION || WORLDOBJ_CITY || WORLDOBJ_STREET
	long   ParentID;    // ->World.ID
	long   CountryID;   // ->World.ID (WORLDOBJ_COUNTRY)
	long   Status;      //
	long   Flags;       //
	long   CurrencyID;  // @v6.2.2 Валюта для государств ->Ref(PPOBJ_CURRENCY)
	double Latitude;    // @v6.2.2 Географическая широта
	double Longitude;   // @v6.2.2 Географическая долгота
	string Name[48];    // @name
	string Abbr[20];    // Для государств используется alpha-2 код по ISO 3166
	string Phone[20];   //
	string Code[20];    // Код по какой-либо внешней классификации. Если такая классификация используется,
		// то все записи должны иметь код именно по этой классификации (или не иметь вовсе)
		// Для государств используется числовой код по ISO 3166
	string ZIP[12];     // ZIP-код географического объекта. Модуль адреса сможет использовать этот код
index:
	ID (unique);
	ParentID, Name acs (dup mod);
	CountryID, Name acs (dup mod);
	Kind, Name acs (dup mod);
	Code (anysegnull dup mod); // Так как внешние классификаторы грешат вероятными дубликатами, ключ делаем неуникальным
file:
	"world.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Descr: Временная таблица для импорта Российского классификатора адресов (КЛАДР)
//
table TempKLADR {
	autolong ID__;      // Временный уникальный идентификатор
	long   ParentID;    // Ссылка на родительский объект по идентификатору ID__ этой же таблицы
	long   StatusCode;  // Код статуса объекта
	string Name[48];
	string Code[20];
	string ZIP[8];
index:
	ID__ (unique);
	Code (dup mod);
	ParentID, Name (dup mod);
file:
	"tmp_kldr.btr";
	temporary;
}
//
//
//
table FiasAddrObj {
	//
	// Официальное наименование, формальное наименование и planecode храняться в TextRef со ссылкой на идентификатор записи
	//
	long   RecUuID;
	long   IdUuRef;         // AOGUID
	long   ParentUuRef;     // PARENTGUID
	long   PrevRecUuRef;
	long   NextRecUuRef;
	long   NameTRef;       // Ссылка на формальное наименование
	long   OfcNameTRef;    // Ссылка на официальное наименование
	long   SnTRef;         // Ссылка на короткое обозначение типа объекта (ул, г и т.д.)
	long   Flags;
	int16  LevelStatus;
	int16  CenterStatus;
	int16  ActionStatus;
	int16  KladrCurStatus;  // Статус актуальности КЛАДР (2 цифры)
	int16  IfnsJ;           // Код ИФНС ЮЛ
	int16  TerrIfnsJ;       // Код территориального участка ИФНС ЮЛ
	int16  IfnsI;           // Код ИФНС ФЛ
	int16  TerrIfnsI;       // Код территориального участка ИФНС ФЛ
	long   OkatoTRef;       //
	long   OktmoTRef;       //
	long   PostalCode;      // Числовое представление почтового индекса (длина индекса в России равна 6 десятичным знакам)
	long   KladrCodeTRef;   // Ссылка на код КЛАДР (без суффиксного признака актуальности)
	date   UpdateDt;        // Дата внесения записи
	date   StartDt;         // Начало действия записи
	date   EndDt;           // Окончание действия записи
index:
	RecUuID (unique mod);           // #0
	IdUuRef (dup mod);              // #1
	ParentUuRef (dup mod);          // #2
	NameTRef (dup mod);             // #3
	KladrCodeTRef (dup mod);        // #4
	PostalCode (dup mod);           // #5
file:
	"fiasaddr.btr";
}

table FiasHouseObj {
	long   IdUuRef;         //
	long   ParentUuRef;     //
	int32  IntStart;        // Начальное значение инервала
	int32  IntEnd;          // Конечное значение интервала
	int16  IntStatus;       // FIASHSEINTSTATUS_XXX 0 - запись отдельного дома; 1 - обычный интервал, включающий четные и нечетные номера домов; 2 - только четные значения; 3 - только нечетные значения
	int16  EstStatus;       // FIASHSEESTSTATUS_XXX 0 - для интервала; 1 - владение; 2 - дом; 3 - домовладение; 4 - участок
	int16  BuildStatus;     // FIASHSEBLDSTATUS_XXX 0 - для интервала; 1 - строение; 2 - сооружение; 3 - литер
	long   NumTRef;         // Строка "номер дома;номер корпуса;номер строения"
	int16  IfnsJ;           // Код ИФНС ЮЛ
	int16  TerrIfnsJ;       // Код территориального участка ИФНС ЮЛ
	int16  IfnsI;           // Код ИФНС ФЛ
	int16  TerrIfnsI;       // Код территориального участка ИФНС ФЛ
	long   OkatoTRef;       //
	long   OktmoTRef;       //
	long   PostalCode;      // Числовое представление почтового индекса (длина индекса в России равна 6 десятичным знакам)
	date   UpdateDt;        // Дата внесения записи
	date   StartDt;         // Начало действия записи
	date   EndDt;           // Окончание действия записи
index:
	IdUuRef (unique mod);                                // #0
	ParentUuRef (dup mod);                               // #1
	IntStart, IntEnd, ParentUuRef (anysegnull dup mod);  // #2
	NumTRef, ParentUuRef          (anysegnull dup mod);  // #3
	PostalCode, ParentUuRef (dup mod);                    // #4
file:
	"fiashouse.btr";
	compress;
}
//
// Descr: Таблица регистрации событий гео-трекинга.
//
table GeoTrack {
	int16  ObjType;    // Тип объекта, с которым связана регистрация положения
	int16  ExtObjType; // Тип дополнительного объекта, с которым связана регистрация положения
	long   ObjID;      // ИД объекта, с которым связана регистрация положения
	long   ExtObjID;   // ИД дополнительного объекта, с которым связана регистрация положения
	long   Flags;      // Флаги положения
	int16  ExtEvent;   // Дополнительное значение, обеспечивающее привязку регистрации местоположения к некоторому событию
	int16  Dts2010;    // Дата в формате количества дней, прошедших с 1/1/2010
	time   Tm;         // Время
	double Latitude;   // Географическая широта  (degree)
	double Longitude;  // Географическая долгота (degree)
	int16  Altitude;   // Высота, m
	int16  Speed;      // Скорость, dm/sec
index:
	ObjType, ObjID, Dts2010, Tm (unique);
	ExtObjType, ExtObjID, Dts2010, Tm (anysegnull unique);
file:
	"geotrack.btr";
}
//
// Персоналии
// @done @v11.1.12 @todo Memo перенести в UnxTextRef
//
table Person {           //
	autolong ID;         // @id
	string Name[128];    // Наименование @v6.2.2 [48]-->[128]
	long   Status;       // Юридический статус           ->Ref(PPOBJ_PRSNSTATUS)
	//
	// Поле MainLoc ссылается на место, идентифицирующее адрес персоналии.
	// При этом соответствующая запись объекта PPOBJ_LOCATION не обязательно
	// ссылается полем Location.Owner на эту запись персоналии.
	//
	long   MainLoc;      // Основной адрес               ->Location.ID
	long   RLoc;         // Фактический адрес            ->Location.ID
	long   CatID;        // Категория персоналии ->Ref(PPOBJ_PRSNCATEGORY)
	long   Flags;        // @flags
	//
	// Следующие два поля используются для кадрового учета. Не очень
	// удачно они сюда вписываются, тем более, что эта же информация //
	// по начальному замыслу должна вводиться через теги. В дальнейшем
	// их нахождение здесь, возможно, будет пересмотрено.
	//
	long   Division;    // Подразделение        ->Location.ID
	long   Position;    // Должность            ->?
	// @v11.1.12 note   Memo[512];   // Примечание @v6.2.2 [128]-->[252] @v7.0.0 [252]-->[512]
index:
	ID (unique);                       // #0
	Name acs (dup mod);                // #1
	CatID, Name (anysegnull dup mod);  // #2 @v6.2.2
	MainLoc (anysegnull dup mod);      // #3 @v6.2.2
	RLoc (anysegnull dup mod);         // #4 @v6.2.2
file:
	"person.btr";
	// @v11.1.12 vlr;
	acstable = "rusncase.alt";
	balanced;
	access=3;
}
//
// Ассоциации Person-PersonKind в отношении многие-ко-многим.
//
table PersonKind {      // size=136
	long   KindID;      // Вид персоналии ->Ref(PPOBJ_PERSONKIND)
	long   PersonID;    //                ->Person.ID
	// Вспомогательное поле. Один-к-одному дублирует соответствующее
	// поле из таблицы Person. Служит для сортировки выборок.
	string Name[128];   // @v6.2.2 [48]-->[128]
index:
	KindID, Name acs, PersonID (unique mod);
	PersonID, KindID (unique);
file:
	"perskind.btr";
	acstable = "rusncase.alt";
	balanced;
	access=1;
}
//
// Таблица Register хранит сведения о регистрационных документах.
// Регистр может относится либо к событию (произошедшему с персоналией), тогда он содержит
// ссылку и на событие (PsnEventID) и на персоналию (PsnID), либо может прямо относиться к
// персоналии, тогда ссылка на событие равна нулю.
// Некоторые регистры могут не иметь конкретной (известной) даты. В этом случае поле Dt = 0;
//
// Поля, помеченные символом '*' исключаются при определении эквивалентности
// двух экземпляров структуры RegisterTbl::Rec
// (see 'int operator != (const RegisterTbl::Rec &, const RegisterTbl::Rec &)')
//
table Register {          // size=88
	autolong ID;          //                           @# !0
	long   ObjType;       // @v8.3.6 Тип объекта, к которому привязан регистр
	long   ObjID;         // @v8.3.6 ИД объекта, к которому привязан регистр
	// @v8.3.6 long   PsnID;         // ->Person.ID               @# !0
	long   PsnEventID;    // ->PersonEvent.ID
	long   RegTypeID;     // ->Ref(PPOBJ_REGISTERTYPE) @# !0
	date   Dt;            //
	long   RegOrgID;      // ->Person.ID
	string Serial[32];    // @v12.0.0 [12]-->[32]
	string Num[128];      // @#{!0} @v5.8.11 Number-->Num // @v12.0.0 [32]-->[128]
	date   Expiry;        // Дата окончания действия документа
	long   UniqCntr;      // @v4.4.5 Счетчик, делающий индекс (RegTypeID, Serial, Number, UniqCntr) уникальным
	long   Flags;         // @v4.4.5
	long   ExtID;         // @v9.0.4 Reserved-->ExtID Дополнительное значение.
		// Для банковских счетов (PPREGT_BANKACCOUNT) трактуется как тип банковского счета.
index:
	ID         (unique);                                                                       // #0
	ObjType, ObjID (anysegnull dup mod);                                                       // #1
	// @v8.3.6 PsnID      (anysegnull dup mod); // #1
	PsnEventID (anysegnull dup mod);                                                           // #2
	//
	// @v4.4.5 {
	// Методы RegisterCore::Add и RegisterCore::Update
	// автоматически управляют значение поля UniqCntr используя метод
	// RegisterCore::GetUniqCntr. Если поле Flags содержит флаг PREGF_DUPNUMBER (0x01L),
	// то UniqCntr получает значение на единицу большее максимального для аналогичного
	// сочетания {RegTypeID, Serial, Num}.
	// } @v4.4.5
	//
	RegTypeID, Serial, Num, UniqCntr (unique mod);            // #3
	RegTypeID, Num, Serial, UniqCntr (unique mod); // @v8.2.3 // #4
file:
	"register.btr";
	balanced;
	compress;
	access=1;
}
//
// Персональные события //
// @done @v11.1.12 @todo Memo перенести в UnxTextRef
//
table PersonEvent {
	autolong ID;        // Ид
	date   Dt;          // Дата
	long   OprNo;       // Номер операции за дату
	long   OpID;        // Вид персональной операции ->Ref(PPOBJ_PERSONOPKIND)
	long   PersonID;    // Первичная персоналия      ->Person.ID
	long   SecondID;    // Вторичная персоналия      ->Person.ID
	long   LocationID;  // Локация                   ->Location.ID
	//
	// if(PPPsnOpKind(OprNo).ExValGrp == POPKEVG_TAG) {
	//     var TagID == PPPsnOpKind(OprNo).ExValSrc
	//     then Extra ->ObjTag.{PPOBJ_PERSONEVENT, TagID}
	//     restriction !(PPObjectTag(TagID).Flags & OTF_DUP)
	// }
	// else if(PPPsnOpKind(OprNo).ExValGrp == POPKEVG_POST)
	//     then Extra ->StaffList.ID
	// else
	//     Extra == 0
	//
	long   Extra;       // Доп идентификатор        ->???
	long   Flags;       // Флаги
	long   LinkBillID;  // ->Bill.ID Связанный документ
	time   Tm;          // Время операции
	int16  EstDuration; // Ожидаемая продолжительность незакрытого парного состояния (дней)
		// Пользователь это значение может ввести только для открывающей парной операции
	raw    Reserve[18]; // @reserve
	long   PrmrSCardID; // @v7.7.12 ->SCard.ID @#{SCardID.PersonID==PersonID}
	long   ScndSCardID; // @v7.7.12 ->SCard.ID @#{SCardID.PersonID==SecondID}
	// @v11.1.12 note   Memo[512];   // Примечание @v5.2.8 [128]-->[240] @v7.0.0 [240]-->[512]
index:
	ID (unique);                                 // #0
	Dt, OprNo (unique mod);                      // #1
	OpID, Dt, OprNo (unique mod);                // #2
	PersonID, Dt, OprNo (unique mod);            // #3
	SecondID, Dt, OprNo (anysegnull unique mod); // #4 @v11.1.12
file:
	"psnevent.btr";
	// @v11.1.12 vlr;
	balanced;
	access=1;
}

table PersonPost {         //
	// @# (Finish && Closed) || (!Finsh && !Closed)
	autolong ID;           // @id
	string Code[48];       // Personal Code // @v12.4.7 [16]-->[48]
	long   StaffID;        // ->StaffList.ID
	long   PersonID;       // ->Person.ID
	date   Dt;             // Дата приема в штат
	date   Finish;         // Дата, когда персоналия PersonID оставила назначение
	long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этого назначения. Если 0, то используется StaffList(PostID).ChargeGrpID.
	long   Flags;          // Бит (0x10000000L) зарезервирован как признак того, что список сумм не отконвертирован
	int16  Closed;         // Закрытое назначение (Finish != 0). Если персоналия через некоторое время //
		// снова вступает в должность, то для нее создается новая запись назначения. Если и после этого она
		// покидает должность, то значение Closed увеличивается на единицу по сравнению с предыдущим оставлением поста.
	int16  Reserve1;       // @alignment
	long   PsnEventID;     // ->PersonEventID ИД персональной операции, которая сформировала это назначение. При изменении персональной операции, вероятно, будет меняться и это назначение
	raw    Reserve2[32];   // @reserve // @v12.4.7 [28]-->[32]
index:
	ID (unique);                             // #0
	StaffID, PersonID, Closed (unique mod);  // #1
	PersonID, StaffID, Closed (unique mod);  // #2
	PsnEventID (anysegnull dup mod);         // #3 // @v12.4.7 (anysegnull unique mod)-->(anysegnull dup mod)
file:
	"psnpost.btr";
	acstable = "rusncase.alt";
}
//
// Элементы штатных календарей
//
table StaffCalendar {      //
	long   CalID;          // Ид календаря //
	long   ObjID;          // Ид объекта, с которым связано создание этой записи
		// Если Flags & STCALEF_BYPEVENT, то тип объекта - персональное событие (PPOBJ_PERSONEVENT)
		// Если Flags & STCALEF_BYDUTYSCHED, то тип объекта - график дежурств (PPOBJ_DUTYSCHED)
	int16  Kind;           //
	int16  Flags;          // STCALEF_XXX
	long   DtVal;          //
	long   TmVal;          // Количество времени (сек)
	time   TmStart;        //
	time   TmEnd;          //
index:
	CalID, DtVal, TmStart (unique mod);
	CalID, ObjID, DtVal, TmStart (unique mod);
	ObjID, CalID, DtVal, TmStart (unique mod);
file:
	"stafcal.btr";
	balanced;
}

table TempStaffCal {
	autolong ID__;         //
	long   CalID;          // base calendar
	long   LinkObjID;      //
	long   NameIdx;        // Индекс наименования объекта (для правильной сортировки с
		// избежанием необходимости хранить эти наименования в таблице, что будет весьма накладно)
	date   Dt;             //
	time   TmStart;        //
	time   TmEnd;          //
	long   TmVal;          //
	string DtText[32];     // Для группировки по дате
	long   Count;          // Количество позиций, для группировки по дате
index:
	ID__ (unique);
	Dt, NameIdx, CalID (dup mod);
	NameIdx, Dt, CalID (dup mod);
	CalID, LinkObjID, Dt, TmStart (unique mod); // @v7.7.12 TmStart
file:
	"tmp_sc.btr";
	temporary;
	balanced;
}
//
// Начисления зарплаты
// Записи этой таблицы формируются как правило "гуртом" в результате запуска процедуры начисления зарплаты.
// Класс SalaryCore следит за тем, чтобы периоды, определяемые [Beg, End] не персекались, то есть,
// пользователь не может начислить зарплату сначала за [1/05/2007..31/05/2007], а затем за [10/05/2007..9/06/2007].
// По этой причине индексация реализуется только по Beg (End в индексах не участвует за избыточностью).
//
// Еще одна важная особенность: предполагаемое количество записей в таблице велико, но урезка старых
// записей видится проблематичной из-за того, что по этим записям формируются учетные документы.
// Следовательно, при конструировании таблицы учитываются факторы экономии. Зарезервированное поле Reserve,
// противоречащее экономии, необходимо из-за предполагаемых в будущем трудностей с конвертацией этой таблицы
//
// Так или иначе, в течении ближайшего года, видимо, конвертации не избежать (пока не все проблемы видны)
//
//
table Salary {             //
	autolong ID;           // @id
	date   Beg;            // Начало периода расчета
	date   End;            // Окончание периода расчета
	long   PostID;         // ->PersonPost.ID
	long   SalChargeID;    // ->Ref(PPOBJ_SALCHARGE)
	double Amount;         // Сумма начисления //
	long   Flags;          // Флаги
	long   LinkBillID;     // ->Bill.ID Документ, по которому сгенерировано начисление
	long   GenBillID;      // ->Bill.ID Документ, сгенерированный по этому начислению
	long   RByGenBill;     // Номер строки документа LinkBillID, соответствующей этой записи
	long   ExtObjID;       // @v6.3.3 Дополнительный объект. Тип объекта определяется видом начисления SalChargeID
	raw    Reserve[28];    // @reserve
index:
	ID (unique);
	PostID, SalChargeID, ExtObjID, Beg (unique mod); // @v6.3.3 +ExtObjID
	Beg, PostID, SalChargeID, ExtObjID (unique mod); // @v6.3.3 +ExtObjID
	SalChargeID, ExtObjID, Beg, PostID (unique mod); // @v6.3.3 +ExtObjID
	GenBillID, RByGenBill (allsegnull dup mod);
	LinkBillID (anysegnull dup mod);
file:
	"salary.btr";
	balanced;
}

table TempSalary {
	long   ID;             // @id
	date   Beg;            // Начало периода расчета
	date   End;            // Окончание периода расчета
	long   PostID;         // ->PersonPost.ID
	long   SalChargeID;    // ->Ref(PPOBJ_SALCHARGE)
	long   ExtObjID;       // @v6.3.3
	double Amount;         // Сумма начисления //
	long   Flags;          // Флаги
	long   LinkBillID;     // ->Bill.ID Документ, по которому сгенерировано начисление
	long   GenBillID;      // ->Bill.ID Документ, сгенерированный по этому начислению
	long   RByGenBill;     // Номер строки документа LinkBillID, соответствующей этой записи
	long   StaffID;        //
	long   PersonID;       //
	long   OrgID;          //
	long   DivID;          //
	string Text[64];       //
index:
	ID (unique);
	Beg (dup mod);
	Text (dup mod);
	PostID, SalChargeID, ExtObjID, Beg (unique mod);
file:
	"tmp_sal.btr";
	temporary;
}
//
// Товары, товарные группы, транспортные средства
//
table Goods2 {             // size=200
	autolong ID;           // @id
	long   Kind;           // Вид объекта (группа, товар и т.д.) PPGDSK_XXX
	string Name[128];      // @name                    // @v6.2.2 [64]-->[128]
	string Abbr[128];      // Сокращенное наименование // @v6.2.2 [64]-->[128] // @v11.9.12 For PPOBJ_SWPROGRAM used as 'Исполняемый файл'
	long   ParentID;       // ->Goods2.ID (Kind = PPGDSK_GROUP [1])
	long   GoodsTypeID;    // Тип товара ->Ref(PPOBJ_GOODSTYPE)
	long   UnitID;         // Единица измерения       ->Ref(PPOBJ_UNIT)
	long   PhUnitID;       // Физич единица измерения ->Ref(PPOBJ_UNIT)
	double PhUPerU;        // PhUPerU = PhUnit / Unit;
	long   ManufID;        // Производитель           ->Person.ID               For PPOBJ_BRAND used as Owner // @v6.2.2 For PPOBJ_TRANSPORT used as Owner
	long   StrucID;        // Структура товара        ->Ref(PPOBJ_GOODSSTRUC)
	long   TaxGrpID;       // Группа налогообложения  ->Ref(PPOBJ_GOODSTAX)     For PPOBJ_PCKGTYPE used as Counter
	long   WrOffGrpID;     // Группа списания         ->Ref(PPOBJ_ASSTWROFFGRP) For PPOBJ_PCKGTYPE used as GoodsGrpID // @v11.9.12 For PPOBJ_SWPROGRAM and PPOBJ_COMPUTER used as Category
	long   Flags;          // Флаги GF_XXX
	long   GdsClsID;       // ИД отраслевого класса товара ->Ref(PPOBJ_GDSCLS)  For PPOBJ_TRANSPORT used as TransportType
	long   BrandID;        // Брэнд ->Goods2.ID (Kind = PPGDSK_BRAND [5])       // @v6.2.2 For PPOBJ_TRANSPORT used as TransportModel -->Ref(PPOBJ_TRANSPMODEL)
	long   DefBCodeStrucID;
		// PPOBJ_GOODSGROUP: ->Ref(PPOBJ_BCODESTRUC) Шаблон штрихкода, присваиваемого новому товару, принадлежащему группе
		// PPOBJ_TRANSPORT:  ->World.ID Государственная принадлежность транспорта
	long   DefPrcID;       // Процессор (группа процессоров), для которого следует автоматически создавать технологию
	long   RspnsPersonID;  // @v6.2.2 -->Person.ID
		// PPOBJ_TRANSPORT: Капитан судна (водитель автомобиля)
	long   GoodsLimit;     // Максимальное количество товаров в группе. (<=0) - unlimited
	int16  Rank;           // @v8.9.8 Ранг записи для изменения порядка сортировки
	int16  VanType;        // @v10.2.0 PPOBJ_TRANSPORT: Тип фургона
	raw    Reserve[4];
index:
	ID (unique);                                // #0
	Kind, ParentID, Name acs (unique mod);      // #1
	Kind, Name acs (unique mod);                // #2
	// @v6.2.2 Kind, ParentID, Abbr acs (dup mod); //
	Kind, BrandID (anysegnull dup mod);            // #3 @v6.2.2
	Kind, Abbr acs (dup mod);                   // #4
	StrucID (anysegnull dup mod); // @v5.2.0    // #5
file:
	"goods2.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Справочник штрихкодов
// Так как одному товару могут соответствовать более одного штрихкода
// (разные упаковки), то отношение товары - коды имеет характер
// многие-к-одному. Именно это является главной причиной того, что
// справочник штрихкодов вынесен в отдельную таблицу, но есть и другие.
//
// Коды товарных групп хранятся с префиксом         '@'
// Номера транспортных средств хранятся с префиксом '^'
//
table Barcode {         // size=40 // @v8.8.0 32-->40
	long   GoodsID;     // Ид товара
	double Qtty;        // Количество единиц товара в упаковке
	long   BarcodeType; // @v8.8.0 long-->int16 Тип кода. Если BarcodeType == 1000, то это - предпочтительный код, то есть
		// имеющий приоритет перед всеми остальными.
	string Code[24];    // @v8.8.0 [16]-->[24]  Штрихкод
index:
	Code acs (unique mod);
	GoodsID (dup mod);
file:
	"barcode.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Таблица товарных кодов, ассоциированных с контрагентами
//
table ArGoodsCode {
	long   GoodsID;     // ->Goods2.ID  Ид товара
	long   ArID;        // ->Article.ID Статья, с которой ассоциирован штрихкод
	long   Pack;        // @fixedpoint3 Количество единиц в упаковке
	string Code[24];    // Код товара // @v8.8.0 [16]-->[24]
index:
	ArID, Code acs (unique mod);
	Code acs, ArID (unique mod);
	GoodsID, ArID  (dup mod);
file:
	"argcode.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Таблица дополнительных характеристик товара, определяемых отраслевым классом этого товара
//
table GoodsExt {           // size=56
	long   GoodsID;        // ->Goods2.ID
	long   GoodsClsID;     // ->Ref(PPOBJ_GOODSCLASS)
	long   KindID;         //
	long   GradeID;        //
	long   AddObjID;       //
	long   X;              //
	long   Y;              //
	long   Z;              //
	long   W;              //
	long   AddObj2ID;      //
	long   UniqCntr;       // Счетчик, обеспечивающий уникальность индекса #1
	long   Reserve;        // @reserve
	double TaxFactor;      // Множитель, на который умножается операционное количество для расчета налогов
index:
	GoodsID (unique mod); // #0
	// @v5.1.9 GoodsClsID, KindID, GradeID, X, Y, Z, AddObjID (unique mod);
	GoodsClsID, KindID, GradeID, X, Y, Z, AddObjID, AddObj2ID, W, UniqCntr (unique mod); // #1 @v5.1.9
file:
	"goodsext.btr";
}

table Package {            // size=84
	long   ID;             // ->Receipt.ID  (1 - 1)
	long   PrevID;         // ->Package.ID
	long   PckgTypeID;     // ->Goods2.ID (Goods2.Kind = PPGDSK_PCKGTYPE)
	long   LocID;          // ->Location.ID (== Receipt(ID).Location)
	string Code[16];       //
	int16  Closed;         //
	int16  UniqCntr;       //
	long   Flags;          // PCKGF_XXX
	raw    Reserve[48];    // @reserve
index:
	ID (unique mod);
	Closed, Code acs, PckgTypeID, UniqCntr (unique mod);
	PrevID, ID (unique mod);
file:
	"package.btr";
	acstable = "rusncase.alt";
}

table PackageLink {
	long   PckgID;
	long   LotID;
index:
	PckgID, LotID (unique mod);
	LotID (unique mod);
file:
	"pckglink.btr";
}
//
//
//
table SpecSeries {
	string Serial[64];
	string Barcode[64];
	string GoodsName[128];
	string ManufName[128];
	date   InfoDate;
	long   InfoKind;       // SPCSERIK_XXX
	string InfoIdent[24];
	raw    Reserve[48];    // @reserve
	long   GoodsID;
	long   LabID;
	string LabName[160];
	long   ManufID;
	long   ManufCountryID;
	string ManufCountryName[128];
	date   AllowDate;
	string AllowNumber[24];
	string SpecName[160];
	string LetterType[8];
	long   Flags;
index:
	InfoKind, Serial (anysegnull dup mod); // @v5.2.1 unique-->dup
	InfoKind, Barcode (anysegnull unique mod);
	InfoKind, InfoIdent (dup mod);
file:
	"spcsn.btr";
}
//
// Информация о специальных серийных номерах (брак и т.д.)
// Большинство неиндексируемых текстовых полей храняться в Tail
// Идентификаторы этих полей:
//   SPCSNEXSTR_GOODSNAME        1 // Текстовое наименование товара (может отличаться от GoodsID.Name)
//   SPCSNEXSTR_MANUFNAME        2 // Текстовое наименование производителя (может отличаться от ManufID.Name)
//   SPCSNEXSTR_LABNAME          3 // Текстовое наименование лаборатории, осущестсвлявшей анализ
//   SPCSNEXSTR_MANUFCOUNTRYNAME 4 // Текстовое наименование страны происхождения (может отличаться от ManufCountryID.Name)
//   SPCSNEXSTR_DESCRIPTION      5 // Текстовое описание серии (характер дефекта и т.д.)
//
table SpecSeries2 { // size=204+1024
	autolong ID;                  // @id @v7.3.0
	string Serial[32];            // @v7.3.0 [64]-->[32]
	string Barcode[32];           // @v7.3.0 [64]-->[32]
	date   InfoDate;              //
	long   InfoKind;              // SPCSERIK_XXX
	string InfoIdent[24];         //
	long   GoodsID;               // ->Goods2.ID
	long   LabID;                 //
	long   ManufID;               // ->Person.ID
	long   ManufCountryID;        // ->World.ID
	date   AllowDate;             //
	string AllowNumber[24];       //
	string LetterType[8];         //
	long   Flags;                 //
	raw    Reserve[48];           // @reserve
	note   Tail[1024];            //
index:
	ID (unique);
	InfoKind, Serial acs (anysegnull dup mod);
	InfoKind, Barcode (anysegnull dup mod);
	InfoKind, InfoIdent acs (dup mod);
	InfoKind, InfoDate, Serial acs (dup mod);
	InfoKind, GoodsID (anysegnull dup mod);
	InfoKind, ManufID (anysegnull dup mod);
file:
	"spcsn2.btr";
	acstable = "rusncase.alt";
	vlr;
	balanced;
}
//
// @v2.2.4
// Для того, чтобы вторичные индексы (1..) были уникальными в этой таблице
// пришлось ввести уникальное поле Counter. Программа самостоятельно
// поддерживает уникальность этого поля через функцию LocationCore::Add
// Функции перечисления используют этот счетчик для хранения итераций.
// На поле Counter никаких ссылок в других таблицах нет.
//
// Замечания по особенностям хранения данных в таблице:
//    Строковые поля: ZIP, Address, FullAddress храняться в хвосте переменной длины Tail.
//    Формат хранения следующий: <1>ZIP<2>Address<3>FullAddress.
//    Если какое-либо из этих трех значений пустое, то оно опускается вместе с тегом-префиксом.
//
// @todo @20251018 Перенести поле Tail в UnxTextRef
//
table Location {           // size=136+1024
	autolong ID;           // @id
	long   Counter;        // Уникальный счетчик для внутреннего использования //
	long   ParentID;       // ->Location.ID Ид позиции предыдущего уровня //
	int16  Type;           // Тип позиции (LOCTYP_XXX)
	int16  Flags;          // Флаги
	long   OwnerID;        // ->Person.ID   Владелец позиции
	long   CityID;         // ->World.ID Город. Для LOCTYP_WHCOLUMN и LOCTYP_WHCELL - складской проход, к которому примыкает колонна или ячейка.
	long   RspnsPersonID;  // ->PersonID Ответственное лицо
	double Latitude;       // @v6.2.2 Географическая широта
	double Longitude;      // @v6.2.2 Географическая долгота
	int16  NumRows;        // @v6.1.0 (LOCTYP_WHZONE, LOCTYP_WHCOLUMN) Количество рядов зоны. Для LOCTYP_WHCELL - положение ячейки вдоль колонны (1 - самый ближний к проходу, 0 - не определено)
	int16  NumLayers;      // (LOCTYP_WHZONE, LOCTYP_WHCOLUMN) Количество вертикальных уровней зоны
		// Для LOCTYP_WHCELL - номер яруса (1 - самый нижний, 0 - не определено).
	//
	// Следующие 4 поля применяются для мест хранения (LOCTYP_WHZONE, LOCTYP_WHCOLUMN, LOCTYP_WHCELL)
	//
	long   MassCapacity;   // Максимальная вместимость по массе (г)
	long   X;              // Длина  (мм)
	long   Y;              // Ширина (мм)
	long   Z;              // Высота (мм)
	long   DisposeRestr;   // Флаги ограничений размещения //
	int16  DisposeRestrCount; // @v6.7.1 Максимальное количество паллет (DisposeRestr & LOCDISPRESTR_PALLETCOUNT)
	int16  Depth;          // Глубина складской колонны (количество ячеек). По умолчанию - 1 (если Depth <= 0).
		// Для LOCTYP_WHCELL - номер ячейки в глубину (1 - самый ближний к проходу, 0 - не определено)
	string Name[48];       // Наименование позиции // @v6.2.2 [32]-->[48]
	string Code[16];       // Код локации. Используется как уникальный идентификатор склада при обмене данными между разделами для контекстной синхронизации.
	note   Tail[1024];     // @v6.2.2 FullAddr[160]-->Tail[1024]
index:
	ID (unique);                                       // #0
	Counter (unique mod);                              // #1
	Type, ParentID, Counter (unique mod);              // #2
	Type, OwnerID, Counter (anysegnull unique mod);    // #3
	CityID, Counter (anysegnull unique mod);           // #4
	Code, Counter (unique mod);                        // #5 @v6.4.0 (anysegnull) removed
file:
	"location.btr";
	vlr;
	balanced;
	access=1;
}
//
// Курсы валют
//
table CurrencyRate {
	date   Dt;
	long   CurID;
	long   RelCurID;
	long   RateTypeID;
	double Rate;
index:
	RateTypeID, CurID, RelCurID, Dt (unique mod);
	CurID, RelCurID, RateTypeID, Dt (unique mod);
file:
	"crate.btr";
	access=1;
}
//
// Документ на перемещение товаров или бух. проводку
//
// Универсальная таблица для накладных, проводок и прочих
// документов. Конкретная характеристика документа определяется полем Bill.OpID.
// @done @v11.1.12 @todo Memo перенести в UnxTextRef
//
table Bill {            //
	autolong  ID;       // @id
	string Code[48];    // Код документа // @v11.1.12 [24]-->[48]
	date   Dt;          // Дата документа
	long   BillNo;      // Номер документа за день
	date   DueDate;     // Срок исполнения (заказа, заявки поставщику и т.д.)
	long   OpID;        // Вид операции          ->Ref(PPOBJ_OPRKIND)
	long   StatusID;    // Статус документа      ->Ref(PPOBJ_BILLSTATUS)
	long   UserID;      // Пользователь          ->Ref(PPOBJ_USR)
	// @v11.1.12 long   MainOrgID;   // Организация           ->Person.ID
	long   LocID;       // Позиция               ->Location.ID
	long   Object;      // Контрагент            ->Article.ID
	long   Object2;     // Дополнительный объект ->Article.ID
	long   CurID;       // Валюта (0 - базовая)  ->Ref(PPOBJ_CURRENCY)
	double CRate;       // Курс валюты для пересчета в базовую валюту
	double Amount;      // Номинальная сумма (в единицах CurID)
	long   LinkBillID;  // Связанный документ    ->Bill.ID
	long   Flags;       // Флаги BILLF_XXX
	long   Flags2;      // Расширение флагов BILLF2_XXX
	long   SCardID;     // ->SCard.ID
	//
	// Следующие два поля применяются в специальных документах: бюджеты, списание по счетам и т.д.
	//
	date   PeriodLow;   // @v6.1.9 Начало периода действия //
	date   PeriodUpp;   // @v6.1.9 Конец периода действия //
	//
	int16  LastRByBill; // @v8.0.3 Последнее значение номера строки Transfer или CpTransf по документу.
		// Необходимо для того, чтобы новые строки не замещали значения RByBill удаленных строк.
	int16  EdiOp;       // @v8.5.5 Тип EDI-операции, которой соответствует документ
	double PaymAmount;  // @v8.5.7 Для ускорения расчета долга по документу сумму оплаты будем дублировать в записи документа.
	long   AgtBillID;   // @v8.7.2 Ссылка на соглашение с контрагентом (договор). Если 0, то применяется общее соглашение.
	raw    Reserve[16]; // @v11.1.12
	// @v11.1.12 note   Memo[512];   // Примечание // @v7.0.0 [160]-->[512]
index:
	ID (unique);                                                   // #0
	Dt, BillNo (unique mod);                                       // #1
	OpID, Dt, BillNo (unique mod);                                 // #2
	Object, Dt, BillNo (unique mod);                               // #3
	LinkBillID, Dt, BillNo (anysegnull unique mod);                // #4
	LocID, Dt, BillNo (unique mod);                                // #5 @v4.1.08
	SCardID, Dt, BillNo (anysegnull unique mod);                   // #6 @v4.1.08
	// @v11.1.12 MainOrgID, Dt, BillNo (anysegnull unique mod);       // #7 @v4.9.10
	Code acs, Dt, BillNo (anysegnull unique mod);                  // #7 @v11.1.12
	//
	// При изменении структуры или порядка следования индексов
	// аналогичные изменения необходимо сделать в таблице TempBill
	//
file:
	"bill.btr";
	// @v11.1.12 vlr;
	compress; // @v11.1.12
	acstable = "rusncase.alt"; // @v11.1.12
	access=1;
}
//
// Суммы документов
//
table BillAmount {      // size=20
	long   BillID;      // ->Bill.ID               Ид документа
	long   AmtTypeID;   // ->Ref(PPOBJ_AMOUNTTYPE) Тип суммы
	long   CurID;       // ->Ref(PPOBJ_CURRENCY)   Валюта
	double Amount;      // Значение
index:
	BillID, AmtTypeID, CurID (unique);
file:
	"billamt.btr";
	access=1;
}
//
// График оплаты документа
//
table PayPlan {         // size=16
	long   BillID;      // ->Bill.ID Ид. документа
	date   PayDate;     // Дата оплаты
	double Amount;      // Сумма оплаты @v4.9.11 money[8]-->double
	double Interest;    // @v5.1.8 Сумма процентных выплат
index:
	BillID, PayDate (unique mod);
file:
	"payplan.btr";
	access=1;
}
//
// Приход товара
//
// Поле PrevLot используется для отслеживания передач порций товара из одного лота.
// При создании лота пробегаются все предыдущие лоты и, если один из предыдущих лотов находится  //
// на той же позиции, на которой планируется создать новый, то создание отменяется, а изменяется //
// лишь остаток предыдущего лота и операция получает ссылку на этот лот.
//
// 11/12/96
// Поле CloseDate предназначено исключительно для вычисления остатков товаров на предшествующую дату.
// Если лот открыт, то это поле равно 0x7fffffffL, если же закрыт, то дате последней операции. Таким
// образом, при вычислении остатка товара необходимо будет перебрать только те лоты, дата закрыти
// которых больше даты, на которую вычисляется остаток.
//
// @todo 02/04/2005 {
//     1. Добавить индекс {Location, GoodsID, Dt, OprNo (unique mod)}
//        Этот индекс позволит значительно ускорить расчет остатков по складу
//     2. Тип полей Cost, Price перевести в double
//     3. Добавить поле ExtCost - накладные расходы в цене Cost
//     4. Добавить поле Weight - масса лота (для товаров, которые одновременно принимают
//        и по массе и по количеству, причем одно в другое однозначно не пересчитывается)
// } @done @v4.7.7
//
table Receipt {         // size=112 // 94
	autolong   ID;      // @id
	long   BillID;      // Ид. документа ->Bill.ID
	long   LocID;       // Позиция поступления от поставщика ->Location.ID
	date   Dt;          // Дата операции прихода на позицию
	long   OprNo;       // Номер операции за день
	int16  Closed;      // Признак нулевого остатка по приходу
	int16  Reserve1;    // @v4.7.7 @# ==0
	long   GoodsID;     // Ид товара                         ->Goods.ID
	long   QCertID;     // Ид сертификата качества           ->QualityCert.ID
	double UnitPerPack; // Количество единиц в упаковке
	double Quantity;    // Поступившее количество единиц
	// @v5.1.5 double Weight;      // @v4.7.7 Масса (объем, площадь и т.д.) - дополнительная количественная величина
		// поступившего товара, которая не может быть однозначно выведена из Quantity
	float  WtQtty;      // @v5.1.5 Поступившее количество в независимых физических единицах
	float  WtRest;      // @v5.1.5 Остаток после операции в независимых физических единицах
	double Cost;        // Текущая цена поступления //
	double ExtCost;     // Величина накладных расходов (включена в состав Cost) //
	double Price;       // Текущая цена реализации  //
	double Rest;        // Текущий остаток
	long   PrevLotID;   // Предыдущий лот                    ->Receipt.ID
	long   SupplID;     // Поставщик                         ->Article.ID
	date   CloseDate;   // Дата закрытия лота
	date   Expiry;      // Срок годности
	long   InTaxGrpID;  // Налоговая группа прихода          ->Ref(PPOBJ_GOODSTAXGROUP)
	long   Flags;       // Флаги
index:
	ID (unique);                                      // #0
	Dt, OprNo (unique mod);                           // #1
	GoodsID, Dt, OprNo (unique mod);                  // #2
	Closed, GoodsID, LocID, Dt, OprNo (unique mod);   // #3
	PrevLotID, Dt, OprNo (unique mod);                // #4
	SupplID, Dt, OprNo (unique mod);                  // #5
	QCertID, Dt, OprNo (unique mod);                  // #6
	//
	// Индекс для расчета остатков по заданному складу
	//
	LocID, Closed, Dt, OprNo (unique mod); // @v4.7.7 // #7
file:
	"receipt.btr";
	balanced;
	access=1;
}
//
// Остатки товаров на текущий момент
//
// При обнулении поля Rest запись удаляется.
//
table CurRest {         // size=16
	long   LocID;       // ->Location.ID Позиция //
	long   GoodsID;     // ->Goods.ID    Товар
	double Rest;        // Остаток на текущий момент
index:
	GoodsID, LocID (unique);
	LocID, GoodsID (unique); // @v6.6.11
file:
	"currest.btr";
	balanced;
	access=1;
}
//
//
//
table LotCurRest {
	double LDRest; // Остаток на дату D
	long   LotID;  // ->Receipt.ID
	int16  D;      // Индекс даты (количество дней от 31/12/1995)
index:
	LotID, D (unique mod);
	D, LotID (unique mod);
file:
	"lcrest.btr";
	page=4096;  // @v6.6.10 При автоматически определяемом размере страницы может не хватить предела для размера файла.
	access=1;
}

table LotCurRest2 {
	long   LDRestF; // Остаток на дату D (fixed .001)
	long   LotID;   // ->Receipt.ID
	int16  D;       // Индекс даты (количество дней от 31/12/1995)
index:
	LotID, D (unique mod);
	D, LotID (unique mod);
file:
	"lcrest2.btr";
	page=4096;
	access=1;
}
//
// Специализированная таблица, позволяющая хранить список кодов, ассоциированных с лотом.
// Пока применяется только для ассоцииации лотов со списком акцизных марок ЕГАИС для поставновки на баланс.
//
table LotExtCode {
	long   LotID;
	long   BillID;    // @v9.8.11
	int16  RByBill;   // @v9.8.11
	// @v10.2.9 int16  Sign;      // @v9.8.11 +1 - приход, -1 - расход, 0 - не определено (или по контексту)
	int16  Flags;     // @v10.2.9 0x01 box, 0x02 minus, 0x04 plus
	long   BoxNo;     // @v10.2.9
	string Code[156]; // @v9.8.11 [96]-->[80] // @v10.0.12 [80]-->[156]
index:
	LotID, BillID, RByBill, Code (unique mod); // #0
	Code, BillID, RByBill (unique mod);        // #1
    BillID, RByBill, BoxNo, Code (unique mod /*@v10.2.9 anysegnull*/); // @v9.8.11 // #2 // @v10.2.9 BoxNo
file:
	"lotxcode.btr";
	compress;
	access=1;
}
//
// Внутренняя структура для хранения данных о товарах, предоставляемых системой ЕГАИС
//
table EgaisProduct {
	autolong ID;
	string AlcCode[24];
	string ManufRarIdent[16];
	string ImporterRarIdent[16];
	string CategoryCode[8];
    int32  Proof;          // Промилле
    int32  Volume;         // x100000
    date   ActualDate;
    long   Flags; // @v9.2.12
index:
	ID (unique);
	AlcCode (dup mod);
file:
	"egaisprod.btr";
	access=1;
}
//
// Внутренняя структура для хранения данных о контрагентах, предоставляемых системой ЕГАИС
//
table EgaisPerson {
	autolong ID;
	string RarIdent[16];
	string INN[16];
	string KPP[16];
	string UNP[16];
	string RNN[16];
	int16  CountryCode;
	int16  RegionCode;
	long   Flags; // EgaisPersonCore::rolefXXX
	date   ActualDate;
index:
	ID (unique);
	RarIdent (dup mod);
	INN (dup mod);
file:
	"egaispsn.btr";
	access=1;
}
//
// Внутренняя структура для хранения данных о справках А, предоставляемых системой ЕГАИС
//
table EgaisRefA {
	autolong ID;
	string RefACode[20];
	string AlcCode[24];
	string ManufRarIdent[16];
	string ImporterRarIdent[16];
	string ShipperRarIdent[16];   // @v10.9.5
	string ConsigneeRarIdent[16]; // @v10.9.5
	string EgaisNumber[24];       // @v10.9.5
	string TTNNumber[48];         // @v10.9.5
	int16  CountryCode;
	int32  Volume;         // x100000
	date   BottlingDate;
	date   ActualDate;
	long   Flags;
	date   EgaisDate;             // @v10.9.5
	date   TTNDate;               // @v10.9.5
	raw    Reserve[12];
index:
	ID (unique);
	RefACode (dup mod);
	AlcCode (dup mod);
file:
	"egaisrefa.btr";
	access=1;
}
//
//
//
table VetisEntity {
	autolong ID;
	long   GuidRef;  // ->UuidRef.ID Ссылка на GUID
	long   UuidRef;  // ->UuidRef.ID Ссылка на UUID
	long   Kind;     // Вид записи PPVetisInterface::entXXX
	long   Flags;
	long   Status;
	long   NextGuidRef;
	raw    Reserve[128];
index:
	ID (unique);               // #0
	GuidRef, UuidRef (unique); // #1
	UuidRef, GuidRef (unique); // #2
	Kind (dup);                // #3
file:
	"vetisent.btr";
	access=1;
}

table VetisProduct {
	long   EntityID;
	long   LinkGoodsID;  // ->Goods.ID
	long   ProductType;
	long   ProductID;    // для ProductItem
	long   SubProductID; // для ProductItem
	long   ProducerLocID;
	long   GostTRef;     // @selfreftext
	string GTIN[16];
	string ArCode[24];   // Артикул
	raw    Reserve[88];
index:
	EntityID (unique);
	LinkGoodsID (dup mod);
	ProductID (anysegnull dup mod);
	SubProductID (anysegnull dup mod);
	GTIN (anysegnull dup mod);
file:
	"vetisprd.btr";
	access=1;
}

table VetisPerson {
	long   EntityID;
	long   LinkPersonID;   // ->Person.ID
	long   EnterpriseType;
	long   CountryID;      // ->VetisEntity.ID
	long   RegionID;       // ->VetisEntity.ID
	string INN[16];
	string KPP[16];
	long   LinkDlvrLocID;  // ->Location.ID
	raw    Reserve[124];
index:
	EntityID (unique);
	LinkPersonID (dup mod);
	INN (dup mod);
file:
	"vetispsn.btr";
	access=1;
}

table VetisDocument {
	long   EntityID;
	long   LinkBillID;
	int16  LinkBillRow;
	int16  VetisDocForm;
	int16  VetisDocType;
	int16  VetisDocStatus;
	date   IssueDate;         // Дата документа
	string IssueNumber[64];   // Номер документа
	date   WayBillDate;       // Дата транспортного документа
	string WayBillNumber[64]; // Номер транспортного документа
	long   FromEntityID;      // -->VetisEntity.ID
	long   FromEnterpriseID;  // -->VetisEntity.ID
	long   ToEntityID;        // -->VetisEntity.ID
	long   ToEnterpriseID;    // -->VetisEntity.ID
	long   ProductID;         // -->VetisEntity.ID Группа продукции
	long   SubProductID;      // -->VetisEntity.ID Подгруппа продукции
	long   ProductItemID;     // -->VetisEntity.ID Собственно, продукт. Может быть не идентифицирован, но содержать только имя, тогда это имя
		// сохраняется в UnxTextRef с кодом (PPOBJ_VETISENTITY, EntityID, txtprpProductItemName).
	long   OrgCountryID;      // -->VetisEntity.ID Страна происхождения продукта
	long   UOMID;             // -->VetisEntity.ID
	int16  ProductType;       //
	int16  TranspStrgType;    // Тип траснпортного хранения
	int16  TranspType;        // Тип транспорта
	int16  Reserve;           // @alignment
	long   Flags;             // @flags VetisVetDocument::fXXX
	double Volume;
	int64  ManufDateFrom;     // SUniTime
	int64  ManufDateTo;       // SUniTime
	int64  ExpiryFrom;        // SUniTime
	int64  ExpiryTo;          // SUniTime
	long   ConfirmNameTRef;
	long   ConfirmPostTRef;
	long   PackingAmount;     //
	long   LinkGoodsID;       // Ид сопоставленного строке товара
	long   LinkFromPsnID;     // Ид персоналии-отправителя, сопоставленной строке
	long   LinkFromDlvrLocID; // Ид адреса доставки отправителя
	long   LinkToPsnID;       // Ид персоналии-получателя, сопоставленной строке
	long   LinkToDlvrLocID;   // Ид адреса доставки получателя
	long   OrgDocEntityID;    // -->VetisDocument.EntityID Ссылка на документ, по которому товар появился у нас
	double AckVolume;         // @v10.5.8 @duetoreserve
	guid   AppReqId;          // @v10.5.9 Ид запроса, по которому еще не получен ответ
	long   DepDocEntityID;    // @v10.6.3 Идентификатор записи, которая зависит от данной записи (для документов производства, например).
	raw    Reserve2[8];       // @v10.5.8 [36]-->[28] // @v10.5.9 [28]-->[12] // @v10.6.3 [12]-->[8]
index:
	EntityID (unique);                                 // #0
	LinkBillID, LinkBillRow (allsegnull dup mod);      // #1
	IssueDate, IssueNumber (allsegnull dup mod);       // #2
	WayBillDate, WayBillNumber (allsegnull dup mod);   // #3
	FromEntityID (anysegnull dup mod);                 // #4
	FromEnterpriseID (anysegnull dup mod);             // #5
	ToEntityID (anysegnull dup mod);                   // #6
	ToEnterpriseID (anysegnull dup mod);               // #7
	ProductItemID (anysegnull dup mod);                // #8
	OrgDocEntityID (anysegnull dup mod);               // #9
file:
	"vetisdoc.btr";
	access=1;
}
//
// Инвентаризация товаров
//
table Inventory {          // size=128
	long   BillID;         // ->Bill.ID (PPOPT_INVENTORY) Заголовочный документ
	long   OprNo;          // Номер операции по BillID
	long   GoodsID;        // ->Goods.ID Товар
	long   Flags;          // Флаги
	double UnitPerPack;    // Емкость упаковки
	double Quantity;       // Фактический остаток
	double StockRest;      // Учетный остаток
	double Price;          // Фактическая цена
	double StockPrice;     // Учетная цена
	double DiffQtty;       // Абсолютная величина рассогласования //
	double DiffPctQtty;    // Абсолютная величина рассогласования в процентах
	double UnwritedDiff;   // Не списанная величина рассогласования //
	double CSesDfctQtty;   // Дефицит товара по кассовым сессиям за период, начиная с даты, указанной в документе
	double CSesDfctPrice;  // Средняя цена дефицита товара по кассовым сессиям за период, начиная с даты, указанной в документе
	double WrOffPrice;     // Цена списания строки
	string Serial[24];     // @v6.4.6
index:
	BillID, OprNo (unique mod);
	BillID, GoodsID, Serial (unique mod); // @v6.4.6 +Serial
	GoodsID, Serial, BillID (unique mod); // @v6.4.6 +Serial
file:
	"inventry.btr";
	access=1;
}

table TempInventorySubst {
	long   GoodsID;
	string Name[128];
	double Quantity;       // Фактический остаток
	double StockRest;      // Учетный остаток
	double SumPrice;       // Фактическая цена
	double SumStockPrice;  // Учетная цена
	double SumWrOffPrice;  // Цена списания строки
	double DiffQtty;       // Абсолютная величина рассогласования //
	double DiffPctQtty;    // Абсолютная величина рассогласования в процентах
	double DiffPrice;      // Суммовое рассогласование
index:
	GoodsID (unique mod);
	Name (dup mod);
file:
	"tmp_inv.btr";
	access=1;
}
//
// Котировки @v2.2.4
// Используется для хранения котировок 1-го поколения.
// Котировки 2-го поколения хранятся в таблицах Quot2Rel и Quotation2.
//
table Quotation {          // size=56
	autolong ID;           // @id
	date   Dt;             //
	time   Tm;             // Not used (0)
	long   OprNo;          //
	long   GoodsID;        // ->Goods.ID            Товар
	long   Kind;           // ->Ref(PPOBJ_QUOTKIND) Вид котировки
	long   Location;       // ->Location.ID         Склад
	long   Flags;          //
	short  Actual;         // Признак текущей котировки @v5.8.11 Current-->Actual
	long   ArID;           // ->Article.ID          Клиент
	raw    Reserve1[2];    //
	long   MinQtty;        // @v5.5.2 Минимальное количество, начиная с которого действует котировка
	double Quot;           // Значение котировки
	long   CurID;          // ->Ref(PPOBJ_CURRENCY) Валюта котировки
index:
	ID (unique);
	Dt, OprNo (unique mod); // @unused
	GoodsID, Actual, Dt, OprNo (unique mod);
file:
	"quot.btr";
	access=1;
}
//
//
//
table Quot2Rel { // size=56
	autolong ID;           // @id
	long   QuotKindID;     // ->Ref(PPOBJ_QUOTKIND) Вид котировки
	long   LocID;          // ->Location.ID         Склад
	long   ArID;           // ->Article.ID          Клиент
	long   CurID;          // ->Ref(PPOBJ_CURRENCY) Валюта котировки
	long   MinQtty;        // Минимальное количество, начиная с которого действует котировка
	int32  PeriodIdx;      // @v7.3.5 Индекс периода действия котировки (младшее слово - начало периода, старшее слово - конец)
		// Слово определяет смещение даты границы периода от опорной даты.
	uint8  Reserve[28];    // @reserve @v7.3.5 [32]-->[28]
index:
	ID (unique);                                                 // #0
	// @v7.3.5 QuotKindID, LocID, ArID, CurID, MinQtty (unique);
	QuotKindID, LocID, ArID, CurID, PeriodIdx, MinQtty (unique); // #1 @v7.3.5
	LocID (dup);                                                 // #2
	ArID (dup);                                                  // #3
file:
	"quotrel.btr";
	balanced;
}

table Quotation2 { // size=32
	long   RelID;          // ->Quot2Rel.ID
	long   GoodsID;        // ->Goods.ID            Товар
	date   Dt;             //
	time   Tm;             //
	int16  Actual;         // @#{[0, 1]} Признак текущей котировки
	int16  Flags;          //
	long   TaID;           // ИД транзакции, создавшей это значение. Используется для отката
		// изменения котировок. Этот ИД хранится как доп параметр записи системного журнала
		// для события PPACN_GOODSQUOTUPD.
	double Quot;           // Значение котировки
index:
	GoodsID, RelID, Dt, Tm (unique mod);          // #0
	RelID, GoodsID, Dt, Tm (unique mod);          // #1
	Actual, RelID, GoodsID (anysegnull dup mod);  // #2
	Actual, GoodsID, RelID (anysegnull dup mod);  // #3
	Dt, Tm, GoodsID, RelID (unique mod);          // #4
	TaID, GoodsID (anysegnull dup);               // #5
file:
	"quot2.btr";
	access=1;
}
//
// Заголовки прайс-листов
//
table PriceList {
	autolong ID;
	long   SupplID;     // Поставщик (0 - главная организация) ->Article.ID
	long   LocID;       // Локация (для главной организации)   ->Location.ID
	date   Dt;          // Дата
	long   QuotKindID;  // Котировка (0 - по всем либо по базовым ценам. If !(Flags & PLISTF_BYQUOT) then ->Ref(PPOBJ_QUOTKIND)
	long   Flags;       // PLISTF_XXX
	long   GoodsGrpID;  // Группа товаров                      ->Goods2.ID
	long   UserID;      // Идентификатор пользователя, который составил прайс-лист
	raw    Reserve[16]; // @reserve
	note   Memo[512];   // @v7.0.0 [128]-->[512]
index:
	ID (unique);
	UserID, SupplID, LocID, QuotKindID, Dt (unique mod); // @v4.8.2
file:
	"plist.btr";
	vlr;
	balanced;
}
//
// Строки прайс-листов
// @v4.4.5 Поле Name увеличено с 48 до 64 байт; Тип поля Price изменен с money на double.
//
table PriceLine {       // size=168+128
	long   ListID;      // Ид. заголовка ->PriceList.ID
	long   GoodsID;     // Товар         ->Goods.ID
	int16  LineNo;      // Порядковый номер по товару
	long   GoodsGrpID;  // Группа товара       == Goods.Grp      ->GoodsGroup.ID
	long   ManufID;     // Производитель       == Goods.Producer ->Person.ID
	string Name[64];    // Наименование товара == Goods.Name     ->Goods.Name
	long   UnitID;      // Единица измерения ->Ref(PPOBJ_UNIT)
	int16  IsPresent;   // Признак наличия на складе
	double UnitPerPack; // Количество в упаковке
	double Price;       // Цена
	long   QuotKindID;  // @v2.9.9 Ид. котировки   ->Ref(PPOBJ_QUOTKIND)
	// Дополнительные цены. Определяются настройкой прайс-листа.
	double AddPrice1;   // @v3.4.4
	double AddPrice2;   // @v3.4.4
	double AddPrice3;   // @v3.4.4
	raw    Reserve[20]; // @reserve
	long   GoodsCode;   // @v4.5.14
	double Rest;        //
	date   Expiry;      // @v3.6.1
	note   Memo[512];   // @v7.0.0 [128]-->[512]
index:
	ListID, GoodsID, QuotKindID, LineNo (unique mod);
	ListID, Name acs, QuotKindID (dup mod);
	ListID, GoodsGrpID, Name acs, QuotKindID (dup mod);
file:
	"pline.btr";
	vlr;
	acstable = "rusncase.alt";
	balanced;
}
//
// Перемещение товаров
//
// Если проводка осуществляется между двумя позициями с (Ид. > 100),
// то в таб. Transfer вносится две записи. Если одна из позиций имеет
// (Ид. <= 100), то такая проводка заносится как одна запись с полем
// Location равным Ид. позиции, который превышает 100.
//
// Переоценка лота заносится в таблицу Transfer с полем Quantity == 0 и
// установленным флагом PPTFR_REVAL.
//
table Transfer {        // size=104
	long   LocID;       // Позиция                   ->Location.ID          @v4.9.10 Location-->LocID
	date   Dt;          // Дата передачи (не обязательно дублирует Bill.Dt)
	long   OprNo;       // Номер операции за день
	long   BillID;      // Ид документа              ->Bill.ID
	int16  RByBill;     // Номер операции по документу
	int16  Reverse;     // Признак зеркальной записи
	long   CorrLoc;     // Корреспондирующая позиция ->Location.ID
	long   LotID;       // Ид приходной записи       ->Receipt.ID
	long   GoodsID;     // Ид товара                 ->Goods.ID
	long   Flags;       // Флаги
	double Quantity;    // Количество товара (Приход +/Расход -/Переоценка 0)
	double Rest;        // Остаток после операции (Lot)
	double Cost;        // Учетная цена поступления //                      @v4.9.10 money[8]-->double
	float  WtQtty;      // @v5.1.5 Количество в независимых физических единицах
	float  WtRest;      // @v5.1.5 Остаток в независимых физических единицах
	double Price;       // Учетная цена реализации  //                      @v4.9.10 money[8]-->double
	double QuotPrice;   // Фиксированная часть цены реализации              @v4.9.10
	double Discount;    // Скидка                                           @v4.9.10 money[8]-->double
	long   CurID;       // Валюта цены ->Ref(PPOBJ_CURRENCY)
	double CurPrice;    // Цена в валюте CurID (В зависимости от операции   @v4.9.10 money[8]-->double
		// это может быть либо цена поступления либо цена реализации).
		// Если CurID == 0, то CurPrice == (Flags & PPTFR_SELLING) ? Cost : (Price-Discount)
index:
	BillID, Reverse, RByBill (unique mod); // #0
	Dt, OprNo (unique mod);                // #1
	LotID, Dt, OprNo (unique mod);         // #2
	GoodsID, Dt, OprNo (unique mod);       // #3
file:
	"transfer.btr";
	access=1;
}
//
// Таблица перемещений лотов в местах хранения //
//
// Записи с Op == 0 содержат текущие остатки по товару либо лоту.
// При этом запись с текущим остатком по товару имеет LotID = 0,
// а запись с текущим остатком по лоту имеет GoodsID = 0.
// @v12.4.1 conversion needed
//
table LocTransf { // size=104
	long   LocID;            // ->Location.ID
	long   RByLoc;           //
	date   Dt;               //
	time   Tm;               //
	long   UserID;           // ->Ref(PPOBJ_USR) Пользователь, создавший строку
	long   BillID;           // ->Bill.ID Связанный документ
	int16  RByBillLT;        // @v12.4.1 RByBill-->RByBillLT. See comments to LOCTRF_OWNEDBYBILL.
	int16  LTOp;             // 0 rest, 1 receipt, 2 expend, 3 inventory // @v12.4.1 Op-->LTOp
	int16  Domain;           // @v12.4.1 Область действия операций. 0 - локальный склад, 1 - клиентские адреса,
		// на которых размещаются наши (либо находящиеся под нашей ответственностью) активы
	int16  PalletCount;      // @v12.4.1 Количество паллетов типа PalletTypeID
	long   Flags;            // LOCTRF_XXX
	long   GoodsID;          // ->Goods2.ID
	long   LotID;            // ->Receipt.ID
	double Qtty;             // Количество товара (торговых единиц)
	double RestByGoods;      // @#{RestByGoods >= 0.0} Остаток товара в ячейке после этой операции
	double RestByLot;        // @#{RestByLot >= 0.0 && (LotID || RestByLot == 0.0)} Остаток лота в ячейке после этой операции
	//
	// Пара {LinkLocID, LinkRByLoc} применяется для связки совместно используемых
	//   ячеек в одну операцию. При этом ведущая операция определяет все атрибуты,
	//   а связанные операции (которые ссылаются на ведущую) не идентифицируют: GoodsID, LotID, BillID, Qtty, Rest
	//
	long   LinkLocID;
	long   LinkRByLoc;
	long   PalletTypeID;     // ->Ref(PPOBJ_PALLET) Тип паллета, используемого для загрузки
	// @v12.4.1 int16  PalletCount;  // Количество паллетов типа PalletTypeID
	// @v12.4.1 int16  Reserve1;     // @alignment
	long   LocOwnerPersonID; // Персоналия-владелец локации (LocID) в случае, если Domain==LOCTRFRDOMAIN_BAILMENT
	long   OrderBillID;      // Пара {OrderBillID; OrderRByBill} используется для привязки операции к записи заказа. Это относится к LOCTRFRDOMAIN_BAILMENT.
	int16  OrderRByBill;     //
	raw    Reserve2[14];     // @reserve
index:
	LocID, RByLoc (unique mod);                       // #0
	LotID, LocID, RByLoc (anysegnull unique mod);     // #1
	GoodsID, LocID, RByLoc (unique mod);              // #2
	BillID, RByBillLT (allsegnull dup mod);           // #3 В случае с ORACLE allsegnull не помогает боротся с неуникальностью пары {0; 0}. Поэтому индекс dup.
		// В дополнение к предыдущему замечанию: по одной строке документа может быть несколько операций размещения. Важно лишь, чтобы программа
		// следила, чтобы по одной строке не было размещено большее количество, чем в строке.
	LinkLocID, LinkRByLoc (allsegnull dup mod);       // #4
	Domain, LTOp, LocID, GoodsID, RByLoc (unique mod); // #5 Индекс для быстрого поиска текущих остатков (LTOp==0), @v12.4.1 Включен сегмент Domain
file:
	"loctrfr.btr";
}
//
// Временная таблица для размещения по ячейкам строк товарных документов.
//
table TempLocTransf {
	autolong ID__;         // @id
	long   LocID;          // ->Location.ID
	long   RByLoc;         //
	date   Dt;             //
	time   Tm;             //
	long   UserID;         // ->Ref(PPOBJ_USR) Пользователь, создавший строку
	long   BillID;         // ->Bill.ID
	int16  RByBillLT;
	int16  LTOp;           // см. примечание к LocTransf::LTOp
	int16  Domain;         // @v12.4.1
	int16  PalletCount;    // Количество паллетов типа PalletTypeID
	long   Flags;          // LOCTRF_XXX
	long   GoodsID;        // ->Goods2.ID
	double BillQtty;       // Количество в строке документа
	double DispQtty;       // Количество, размещенное в ячейку LocID
	double RestByGoods;    // @#{RestByGoods >= 0.0} Остаток товара в ячейке после этой операции
	double RestByLot;      // @#{RestByLot >= 0.0 && (LotID || RestByLot == 0.0)} Остаток лота в ячейке после этой операции
	long   PalletTypeID;   // ->Ref(PPOBJ_PALLET) Тип паллета, используемого для загрузки
	long   LocOwnerPersonID; // Персоналия-владелец локации (LocID) в случае, если Domain==LOCTRFRDOMAIN_BAILMENT
index:
	ID__ (unique);
	BillID, RByBillLT (dup mod);
	LocID, RByLoc (allsegnull unique mod);
file:
	"tmp_lctr.btr";
	temporary;
}
//
// @v4.0.7
// @v9.1.8 Конвертация. Добавлено поле (индексное) DlvrLocID и убрано зарезервированное пространство (за много лет не применялось)
//
table GoodsDebt {
	long   GoodsID;
	long   ArID;
	long   DlvrLocID; // @9.1.8
	date   Dt;
	double SaldoQtty;
	double SaldoAmount;
	// @v9.1.8 raw    Reserve[20];    // @reserve
index:
	GoodsID, ArID, DlvrLocID, Dt (unique mod); // @v9.1.8 DlvrLocID
	ArID, DlvrLocID, GoodsID, Dt (unique mod); // @v9.1.8 DlvrLocID
file:
	"gdsdebt.btr";
}
//
// @v8.9.11 @done // @todo Поля PartNo и Clb перенести в хвост переменной длины. Reserve2 сократить
//
table CpTransf {          // size=156
	long   BillID;        // ->Bill.ID
	int16  RByBill;       //
	int16  Reserve1;      //
	long   GoodsID;       // ->Goods2.ID
	long   LocID;         // ->Location.ID
	long   OrdLotID;      // ->Receipt.ID
	long   CurID;         // ->Ref(PPOBJ_CURRENCY)
	double UnitPerPack;   //
	double Qtty;          //
	double Rest;          // Излишек при списании
	double Cost;          //
	double Price;         //
	double Discount;      //
	double CurPrice;      //
	date   Expiry;        //
	long   QCertID;       // ->QualityCert.ID
	long   InTaxGrpID;    // ->Ref(PPOBJ_GOODSTAX)
	long   Flags;         //
	//string PartNo[24];    // Номер партии (пакета)
	//string Clb[24];       // Номер ГТД
	// @v8.9.11 raw    Reserve2[28];  // @reserve
	note   Tail[128];     //
index:
	BillID, RByBill (unique mod);
	GoodsID, LocID (dup mod); // @v4.9.11
file:
	"cptrfr.btr";
	vlr;
	page=4096;  // @v8.3.0 При автоматически определяемом размере страницы может не хватить предела для размера файла.
}
//
// @v3.9.0
// Таблица строк расширения бухгалтерских документов
// Документы, которые могут содержать такие строки, относятся к
// типу операции PPOPT_ACCTURN и их вид операции имеет признак OPKF_ADVACC.
// @todo {
//     Размер поля AdvCode - [24]
//     Для выравнивания после RByBill добавить int16 Reserve2;
// } @v6.2.2
// @todo Memo перенести в UnxTextRef
//
table AdvBillItem {        // size=128+128
	long   BillID;         // ->Bill.ID (!=0)
	int16  RByBill;        // (>0)
	int16  Reserve2;       // @alignment
	string AdvCode[24];    // @v6.2.2 [10]-->[24]
	date   AdvDt;
	long   AdvBillKindID;  // ->Ref(PPOBJ_ADVBILLKIND)
	long   AdvBillID;      // ->Bill.ID
	long   AccID;          // ->Account.ID
	long   ArID;           // ->Article.ID
	long   Flags;
	long   CalcGrpID;      // ?
	double Amount;
	double ExtAmt1;
	double ExtAmt2;
	double ExtAmt3;
	double ExtAmt4;
	double ExtAmt5;
	raw    Reserve[36];    // @reserve
	note   Memo[128];      // @v4.2.8 Примечание
index:
	BillID, RByBill (unique mod);
	AccID, ArID, BillID, RByBill (unique mod);
	AdvBillID, BillID, RByBill (unique mod);
file:
	"advbitem.btr";
	vlr;
	access=1;
}
//
// @v8.4.10 Текстовые сегменты индексов получили атрибут acs. Для того, чтобы атрибуты заработали
// необходима ручная перестройка таблицы (посредством ремонта базы данных).
//
table Workbook {
	autolong ID;
	string Name[128];
	string Symb[20];
	long   Type;
	long   ParentID;
	long   LinkID;
	long   CssID;
	long   Rank;
	long   Flags;
	int16  KeywordCount;   // Количество ключевых слов в генерируемой заглушке для crawler
	int16  KeywordDilute;  // Параметр разжижения ключевых слов в генерируемой заглушке для crawler
	date   Dt;             // @v8.1.6
	time   Tm;             // @v8.1.6
	string Version[8];     // @v8.2.0 Символ версии записи
	long   OwnerGuaID;     // @v9.3.7 ->Ref(PPOBJ_GLOBALUSERACC) Глобальная учетная запись, владеющая узлом и его потомками
	raw    Reserve[24];
	blob   VT[2048];
index:
	ID (unique);                           // #0
	Name acs (unique mod);                 // #1
	Rank, Name acs (unique mod);           // #2
	Type, Rank, Name acs (unique mod);     // #3
	ParentID, Rank, Name acs (unique mod); // #4
	Symb acs (allsegnull unique mod);      // #5
file:
	"workbook.btr";
	vlr;
	acstable = "rusncase.alt";
	access=1;
}
//
// Project management
// @done @todo Descr и Memo перенести в UnxTextRef
//
table Project {         // size=384+128=512
	autolong   ID;      // @id
	long   Kind;        // PPPRJK_XXX {Project, Phase, ProjectTemplate, PhaseTemplate}
	long   ParentID;    // ->Project.ID Родительский проект
	string Name[128];   // Наименование проекта/фазы
	string Code[24];    // Код проекта/фазы
	date   Dt;          // Дата создания проекта
	date   BeginDt;     // Дата начала работ по проекту
	date   EstFinishDt; // Предполагаемая дата завершения работ по проекту
	date   FinishDt;    // Фактическая дата завершения работ по проекту
	long   MngrID;      // ->Person.ID
	long   ClientID;    // ->Person.ID
	long   TemplateID;  // ->Project (Kind = XxxTemplate) Шаблон проекта/фазы (прецедент)
	long   Status;      // PPPRJSTS_XXX Состояние проекта/фазы {Active, Non-Active, Archived}
	long   Flags;       // @flags
	long   BillOpID;    // Операция разноски документов
	raw    Reserve[44]; // @reserve
	// @v10.7.2 string Descr[256];  // Краткое описание проекта/фазы
	// @v10.7.2 note   Memo[1024];
index:
	ID (unique);
	ParentID, Name (unique mod);
	ParentID, Code (dup mod);
	BeginDt, EstFinishDt (dup mod);
	EstFinishDt (dup mod);
file:
	"project.btr";
	// @v10.7.2 vlr;
}
//
// @done @todo Descr и Memo перенести в UnxTextRef
//
table PrjTask {         // size = 144
	autolong ID;        //
	long   ProjectID;   // ->Project.ID
	long   Kind;        // {Task=1, Template=2}
	string Code[24];    // @v6.2.2 Code[16]-->Code[24]
	long   CreatorID;   // ->Person.ID
	long   GroupID;     // @unused
	long   EmployerID;  // ->Person.ID
	long   ClientID;    // ->Person.ID
	long   TemplateID;  // ->PrjTask(Kind = Template) Шаблон задачи
	date   Dt;          // Дата создания записи
	time   Tm;          // Время создания записи
	date   StartDt;     // Дата начала работы
	time   StartTm;     // Время начала работы
	date   EstFinishDt; // Предполагаемая дата завершения работы
	time   EstFinishTm; // Предполагаемое время завершения работы
	date   FinishDt;    // Фактическая дата завершения работы
	time   FinishTm;    // Фактическое время завершения работы
	int16  Priority;    // {Highest, High, Normal, Low, Lowest}
	int16  Status;      // {New, Rejected, In Progress, On Hold, Completed}
	//
	// Следующие 3 поля соответствуют структуре DateRepeating {
	//
	int16  DrPrd;       // DateRepeating::Prd
	int16  DrKind;      // DateRepeating::RepeatKind
	int32  DrDetail;    // Использование зависит от DrPrd и DrKind
	// }
	long   Flags;       // TODOF_XXX
	long   DlvrAddrID;  // Адрес доставки, ассоциированный с клиентом ClientID
	long   LinkTaskID;  // ->PrjTask.ID
	double Amount;
	int32  OpenCount;   // Количество просмотров (увеличивается, когда кто-либо открывает диалог с задачей)
	long   BillArID;    // ->Article.ID Статья разноски закрытой задачи: при закрытии задачи формируется связанный документ со основной статьей =BillArID.
	long   LinkBillID;  // @v12.4.7 ->Bill.ID Связанный документ.
	raw    Reserve[12]; // @reserve // @v12.4.7 [16]-->[12]
	// @v10.7.2 string Descr_[256];  // Описание задания // @v6.2.2 Descr[224]-->Descr[256]
	// @v10.7.2 note   Memo_[1024];  // @v6.2.2 Memo[128]-->Memo[1024]
index:
	ID (unique);                      // #0
	Dt, Tm (unique mod);              // #1
	ProjectID, Dt, Tm (unique mod);   // #2
	TemplateID, Dt, Tm (unique mod);  // #3
	EmployerID, Dt, Tm (unique mod);  // #4
	ClientID, Dt, Tm (unique mod);    // #5
	LinkTaskID, Dt, Tm (unique mod);  // #6
	LinkBillID, Dt, Tm (unique mod);  // #7 // @v12.4.7
file:
	"prjtask.btr";
	// @v10.7.2 vlr;
}
//
// Descr: Персональные карты.
// Attention: При изменении раскладки полей следует соответствующим образом изменить
//   раскладку полей в таблице TempSCard до отметки "End SCard fields".
//
table SCard {              // size=104 // @v7.7.2 104-->128 // @v9.4.0 128-->120
	autolong ID;           // @id
	string Code[24];       // Номер карты
	// @v9.4.0 string Password[8];    // Пароль для удаленной авторизации владельца
	long   SeriesID;       // ->Ref(PPOBJ_SCARDSERIES)
	long   PersonID;       // ->Person.ID
	long   Flags;          // @flags
	date   Dt;             // Open date
	date   Expiry;         // Дата истечения срока действия карты
	long   PDis;           // Discount (.01%)
	long   AutoGoodsID;    // ->Goods2.ID Товар, автоматически списываемый по карте в чековой панели
	double MaxCredit;      // For credit cards [Ref(PPOBJ_SCARDSERIES).SeriesID.Flags & SCRDSF_CREDIT]
	double Turnover;       // Оборот по карте (по всем закрытым сессиям)
	double Rest;           // Текущий остаток по кредитной карте
	double InTrnovr;       // Для временной таблицы по кредитным картам дебетовый оборот (приходы). Для обычной таблицы - резерв.
	time   UsageTmStart;   // @v6.2.0
	time   UsageTmEnd;     // @v6.2.0
	int16  PeriodTerm;     // @v7.7.2 Тип периода длительности срока действия //
	int16  PeriodCount;    // @v7.7.2 Количество периодов длительности срока действия //
	long   LocID;          // @v9.4.0 ->Location.ID
	long   PoolDestSerID;  // @v10.2.7 Только для карт резервного пула: серия, в которую следует перенести карту при вводе в действие.
	long   FixedBonus;     // @v10.5.5 (.01) Для бонусных и кредитных карт фиксированная сумма бонуса на один чек. Специальный сценарий.
	raw    Reserve[8];     // @v7.7.2 @v9.4.0 [20]-->[16]
index:
	ID (unique);                   // #0
	Code, SeriesID (unique mod);   // #1
	SeriesID, Code (unique mod);   // #2
	PersonID (anysegnull dup mod); // #3
	LocID (anysegnull dup mod);    // #4 @v9.4.0
file:
	"scard.btr";
	access=1;
}
//
// Descr: Временная таблица для отчета по персональным картам.
// Attention: Поля до отметки "End SCard fields" должны совпадать по типам и порядку следования с полями
//   таблицы SCard.
//
table TempSCard {
	long   ID;             //
	string Code[24];       //
	// @v9.4.0 string Password[8];    //
	long   SeriesID;       // ->Ref(PPOBJ_SCARDSERIES)
	long   PersonID;       // ->Person.ID
	// @v9.6.5 @fix long   LocID;          // ->Location.ID @v9.4.0
	long   Flags;          //
	date   Dt;             // Open date
	date   Expiry;         //
	long   PDis;           //
	long   AutoGoodsID;    //
	double MaxCredit;      //
	double Turnover;       //
	double Rest;           //
	double InTrnovr;       //
	time   UsageTmStart;   //
	time   UsageTmEnd;     //
	int16  PeriodTerm;     // @v7.7.2 Тип периода длительности срока действия //
	int16  PeriodCount;    // @v7.7.2 Количество периодов длительности срока действия //
	long   LocID;          // @v9.6.5 @fix ->Location.ID
	raw    Reserve[16];    // @v7.7.2
	//
	// End SCard fields
	//
	/* @v9.8.9
	string Phone[48];      //
	string Address[252];   //
	string ZIP[12];
	string LocalArea[64];
	string City[48];
	string Street[128];
	string House[48];
	string Apart[32];
	string AddrAddend[64];
	*/
	// @v9.8.9 {
	uint   PhoneP;
	uint   AddressP;
	uint   ZipP;
	uint   LocalAreaP;
	uint   CityP;
	uint   StreetP;
	uint   HouseP;
	uint   ApartP;
	uint   AddrAddendP;
	// } @v9.8.9
index:
	ID (unique);                  // #0
	Code, SeriesID (unique mod);  // #1
	SeriesID, Code (unique mod);  // #2
file:
	"tmp_sc.btr";
	compress;
}
//
// Операции с персональными картами (для кредитных и бонусных карт).
//
table SCardOp {         // size=72 // @v7.7.12 48-->60 // @v12.0.6 60-->72
	long   SCardID;     // ->SCard.ID
	date   Dt;          //
	time   Tm;          //
	// @v7.7.12 long   CheckID;     // ->CCheck.ID (may be zero)
	long   UserID;      // ->Ref(PPOBJ_USR)
	// @v7.7.12 long   BillID;      // ->Bill.ID (may be zero)
	long   Flags;       // @flags SCARDOPF_XXX
	double Amount;      // Сумма операции
	double Rest;        // Остаток после операции
	long   DestSCardID; // @v6.8.0 (was reserved) Ссылка на карту, на которую перенесена сумма по данной операции.
		// Спаренная операция начисления отдалена от операции списания на 0.1 сек. (LDATETIME.addhs(10))
	long   LinkObjType; // @v7.7.12
	long   LinkObjID;   // @v7.7.12
	date   FreezingStart; // @v8.6.4 (за счет резерва)
	date   FreezingEnd;   // @v8.6.4 (за счет резерва)
	long   CtAmount;      // @v12.0.5 Количественная величина операции (для кредитных карт, на которые начисляется как сумма, так и количество)
	long   CtRest;        // @v12.0.5 Количественный остаток после операции (для кредитных карт, на которые начисляется как сумма, так и количество)
	long   CtGoodsID;     // @v12.0.6 Товар для учета количественного остатка (пока четкой спецификации нет). Точно известно, что на товарных остаток по складу такая операция не влияет.
	raw    Reserve[4];    // @v7.7.12 // @v12.0.5 [4]-->[8] // @v12.0.6 [8]-->[4]
index:
	SCardID, Dt, Tm (unique mod);
	// @v7.7.12 CheckID, Dt, Tm (unique mod); // @todo anysegnull
	// @v7.7.12 BillID,  Dt, Tm (anysegnull unique mod);
	LinkObjType, LinkObjID, SCardID, Dt, Tm (anysegnull unique mod); // @v7.7.12 сегмент SCardID необходим только для обеспечения уникальности
file:
	"scardop.btr";
}
//
// Descr: Кассовые сессии
//
table CSession {
	autolong ID;
	long   SuperSessID;    // ->CSession.ID
	long   CashNodeID;     // ->Ref(PPOBJ_CASHNODE)
	long   CashNumber;     // Для сессий, созданных по распределенному кассовому узлу - ид адреса доставки (магазина)
	long   SessNumber;
	date   Dt;
	time   Tm;
	int16  Incomplete;     // Закрытие сессии не было завершено
	int16  Temporary;      // @v3.9.11 Временная сессия (не списывать и не объединять в суперсессии)
	double Amount;
	double Discount;
	double AggrAmount;
	double AggrRest;
	double WrOffAmount;
	double WrOffCost;      // @v3.8.4 used in temp table only
	double Income;         // @v3.8.4 used in temp table only
	double BnkAmount;      // @v4.3.15 Сумма по чекам, оплаченная безналично
	double CSCardAmount;   // @v6.2.1 Сумма по корпоративным кредитным картам
index:
	ID (unique);
	CashNodeID, Dt, Tm (unique mod);
	CashNodeID, CashNumber, SessNumber, Dt (unique mod);
	SuperSessID, CashNumber, Dt, Tm (unique mod);
	Dt, Tm, CashNodeID (unique mod); // @v7.7.12
file:
	"csess.btr";
	access=1;
}
//
// @v5.0.8 VADIM
//
table TempCSessChecks {
	autolong ID;           // @id Внутренний id записи
	long   SuperSessID;    // ->CSession.ID
	long   CashNodeID;     // ->Ref(PPOBJ_CASHNODE)
	long   CashNumber;     //
	long   SessNumber;     //
	date   Dt;             //
	time   Tm;             //
	int16  Incomplete;     // Уровень незавершенности сессии
	int16  Temporary;      // Сессия временная //
	double Amount;         // Сумма чеков (с учетом скидки)
	double Discount;       // Сумма скидки
	double AggrAmount;     // Агрегированная по товарам сумма
	double AggrRest;       // Агрегированная по товарам сумма за вычетом списанной суммы
	double WrOffAmount;    // Сумма списания //
	double WrOffCost;      // Сумма списания в ценах поступления //
	double Income;         // Доходность
	double BnkAmount;      // Сумма безналичных чеков
	double CSCardAmount;   // @v6.2.1 Сумма по корпоративным кредитным картам
	// -- До этой точки структура совпадает со структурой CSession
	long   ChkCount;       // Количество чеков
	double WORetAmount;    // Сумма чеков без учета скидок
	double WORetBnkAmount; // Сумма безналичных чеков без учета скидок
	double BnkDiscount;
index:
	ID (unique);
	CashNodeID, Dt, Tm (unique mod);
	CashNodeID, CashNumber, SessNumber, Dt (unique mod);
	SuperSessID, CashNumber, Dt, Tm (unique mod);
file:
	"tmp_csch.btr";
	temporary;
	access=1;
}
//
// Descr: Кассовые чеки
//
table CCheck {             // size=52
	autolong ID;           // ИД чека уникальный по этой таблице
	long   Code;           // Код чека по внутреннему реестру ККМ, если Flags & CCHKF_ZCHECK, тогда Code - это номер Z-отчета
	long   PosNodeID;      // if (Flags & (CCHKF_SYNC|CCHKF_TRANSMIT)) then (CashID ->Obj(PPOBJ_CASHNODE).ID) else (CashID - Code of cash machine) // @v11.9.3 CashID-->PosNodeID
	long   UserID;         // Пользователь, создавший чек
	long   SessID;         // ->CSession.ID
	date   Dt;             // Дата чека
	time   Tm;             // Время чека
	long   Flags;          // CCHKF_XXX
	money  Amount[8];      // Общая сумма чека (с учетом скидки)
	money  Discount[8];    // Общая скидка по чеку
	long   SCardID;        // ->SCard.ID
index:
	ID (unique);                            // #0
	Dt, Tm, PosNodeID (unique mod);         // #1
	PosNodeID, Code, Dt, Tm (unique mod);   // #2
	SessID, PosNodeID, Dt, Tm (unique mod); // #3
	SCardID, Dt, Tm (anysegnull dup mod);   // #4
file:
	"ccheck.btr";
	access=1;
}
//
// Descr: Таблица расширения чеков. Содержит информацию, необходимую для учета
//   чеков по продавцам и столам (для общепита).
//   Эти данные не вводятся в общую структуру чека из-за того, что таблица CCheck
//   очень большая, а поля расширения используются нечасто и лишь отдельными видами бизнеса
// @todo Memo перенести в UnxTextRef
//
table CCheckExt {          // size=20
	long   CheckID;        // ->CCheck.ID
	long   SalerID;        // ->Article.ID
	long   TableNo;        // Номер стола
	long   AddPaym_unused; // 0.01 Доплата наличными @v6.0.6 VADIM // @v9.0.4 @unused
	int16  GuestCount;     // @v6.2.2 Количество гостей за столом
	int16  Op_;            // @v12.2.11 Reserve[2]-->Op_
	// @v12.2.11 raw    Reserve[2];     // @reserve @v6.7.8 [2]-->[14]
	long   AddrID;         // @v7.0.7 Ид адреса доставки
	long   AddCrdCardID_unused;   // @v6.8.0 Дополнительная кредитная карта, с которой оплачивается покупка // @v9.0.4 @unused
	// @v10.6.8 long   AddCrdCardPaym_unused; // @v6.8.0 0.01 Сумма, оплаченная по дополнительной кредитной карте // @v9.0.4 @unused
	long   CreationUserID; // @v10.6.8 (insteed AddCrdCardPaym_unused) -->User.ID Пользователь, создавший чек
	long   LinkCheckID;    // @v6.7.8 -->CCheck.ID Ссылка на связанный чек.
		// Дополнение спецификации начиная с версии @v12.2.9:
		//   -- для чека возврата (CCheckTbl::Rec::Flags & CCHKF_RETURN) LinkCheckID - ид чека, по которому сделан возврат
		//   -- для чека коррекции (CCheckTbl::Rec::Flags & CCHKF_CORRECTION) LinkCheckID - ид чека, по которому сделана коррекция
	datetime StartOrdDtm;  // @v6.7.8 Для чека заказа: время начала обслуживания //
	datetime EndOrdDtm;    // @v6.7.8 Для чека заказа: время завершения обслуживания //
	datetime CreationDtm;  // @v7.6.1 Время создания чека
	note   Memo[256];      // @v6.7.8 Примечание к чеку
index:
	CheckID (unique mod);
	LinkCheckID, CheckID (anysegnull unique mod); // @v6.7.8
	TableNo, CheckID (anysegnull unique mod);     // @v6.7.8
	// @todo AddCrdCardID, CheckID (anysegnull unique mod);
file:
	"ccext.btr";
	vlr;
	access=1;
}
//
// Descr: Таблица платежей по чеку.
//
table CCheckPaym {
	long   CheckID;
	int16  RByCheck;
	int16  PaymType;  // 1 - cash, 2 - bank, 3 - credit scard, 4 - bonus scard
	long   Amount;    // 0.01 Сумма оплаты
	long   SCardID;   // ИД платежной карты
	long   CurID;     // @v9.0.4 Валюта оплаты
	long   CurAmount; // @v9.0.4 Сумма оплаты в валюте CurID
index:
	CheckID, RByCheck (unique mod);
	SCardID, CheckID (anysegnull unique mod);
file:
	"ccpaym.btr";
	access=1;
}
//
//
//
table TempCCheckQtty { // Size=60
	autolong ID;        // ИД чека уникальный по этой таблице
	long   Code;        // Код чека по внутреннему реестру ККМ, если Flags & CCHKF_ZCHECK, тогда Code - это номер Z-отчета
	long   CashID;      // if (Flags & (CCHKF_SYNC|CCHKF_TRANSMIT)) then
		// (CashID ->Obj(PPOBJ_CASHNODE).ID) else (CashID - Code of cash machine)
	long   UserID;      //
	long   SessID;      // ->CSession.ID
	date   Dt;          //
	time   Tm;          //
	long   Flags;       // CCHKF_XXX
	double Amount;      //
	double Discount;    //
	double BnkAmt;      // @v8.3.0
	double CrdCardAmt;  // @v8.3.0
	long   SCardID;     // @v3.7.2  ->SCard.ID
	double Qtty;        //
	long   SkuCount;    // @v6.9.3
	long   LinesCount;  // @v6.9.3
index:
	ID (unique);
	Dt, Tm, CashID, Code (unique mod); // @v7.6.3 (, Code)
	CashID, Code, Dt, Tm (unique mod);
	SessID, CashID, Dt, Tm, Code (unique mod);  // @v3.1.12 // @v7.6.3 (, Code)
	SCardID, Dt, Tm (anysegnull dup mod); // @v3.11.10
file:
	"tmp_cchq.btr";
	temporary;
	access=1;
}

table TempCCheckGrp {
	autolong ID__;
	string Text[128];  // @v6.3.7 [48]-->[128]
	string Serial[32]; // @v10.2.6
	date   Dt;
	time   Tm;
	long   CashID;
	long   SCardID;
	long   GoodsID;
	long   Count;
	int16  DivID;      // @v6.7.10 // @v10.9.1 Div-->DivID
	int16  GuestCount; // @v6.7.10
	long   SkuCount;   // @v6.9.3
	long   LinesCount; // @v6.9.3
	double Amount;
	double Discount;
	double BnkAmt;      // @v8.3.0
	double CrdCardAmt;  // @v8.3.0
	double PctPart;
	double Qtty;
index:
	ID__ (unique);
	Dt, Tm, CashID, SCardID, GoodsID, Serial (unique mod); // @v10.2.6 Serial
	Text (dup mod);
	Count desc, Dt, Tm, Text (dup mod);
	Qtty desc, Dt, Tm, Text (dup mod);
	Amount desc, Dt, Tm, Text (dup mod);
	Text, Dt (dup mod);
file:
	"tmp_cchk.btr";
	temporary;
	access=1;
}

table TempCCheckGdsCorr {
	autolong ID__;
	long   Goods1ID;
	long   Goods2ID;
	//string GoodsName1[128]; // @v8.3.0 [48]-->[128]
	//string GoodsName2[128]; // @v8.3.0 [48]-->[128]
	string GoodsName1[64];
	string GoodsName2[64];
	long   Count;
	long   ChecksCount;
	double ChecksCountPct;
index:
	ID__ (unique);
	Goods1ID, Goods2ID (unique mod);
	Goods2ID, Goods1ID (unique mod);
	GoodsName1, Count desc, GoodsName2 (unique mod);
	Count desc, GoodsName1, GoodsName2 (unique mod);
file:
	"tmp_ccgc.btr";
	temporary;
	// page=4096;  // @v8.4.8 При автоматически определяемом размере страницы может не хватить предела для размера файла.
	compress; // @v8.3.0
	access=1;
}
//
//
//
table TempCCheckLine {     // size=
	long   CheckID;        // ->CCheck.ID
	long   CheckCode;      // ->CCheck.Code
	int16  DivID;          // Отдел магазина
	date   Dt;             // Дата продажи == CCheck(CheckCode).Dt
	long   GoodsID;        // ->Goods.ID
	string BarCode[24];    // Штрихкод // @v8.8.0 [16]-->[24]
	// @v10.7.3 string Serial[24];     // Серийный номер
	double Quantity;       // Количество товара
	long   Price;          //
	double Dscnt;          // @v5.2.7 long(0.01)-->double
	long   ExtTextSize;    // @v10.7.3 Длина текста, содержащегося в VT
	blob   VT[2048];       // @v10.7.3
index:
	CheckCode (dup mod);
	Dt, GoodsID (dup mod);
	CheckID (dup mod);
file:
	"tmp_ccl.btr";
	vlr; // @v10.7.3
	temporary;
	access=1;
}
//
//
//
table CCheckLine {         // size=32
	long   CheckID;        // ->CCheck.ID
	int16  RByCheck;       // Счетчик строк по чеку
	int16  DivID;          // Отдел магазина
	long   GoodsID;        // ->Goods.ID
	double Quantity;       // Количество товара
	long   Price;          // Цена 0.01
	double Dscnt;          // @v5.2.7 long(0.01)-->double
index:
	CheckID, RByCheck (unique mod);
file:
	"ccline.btr";
	access=1;
}
//
// Descr: Таблица расширения строк кассовых чеков.
//   Применяется тогда, когда необходимо учитывать продажи по серийным номерам.
//   @todo Увеличить поле Serial [24]-->[64]
//
table CCheckLineExt {      // size=32
	long   CheckID;        // ->CCheck.ID
	int16  RByCheck;       //
	int8   Queue;          // Очередность подачи блюда (для ресторанов)
	int8   Flags;          // @flags
	string Serial[24];     // @obsolete @todo Убрать это поле
index:
	CheckID, RByCheck (unique mod);
file:
	"cclnext.btr";
	access=1;
}
//
//
//
table CGoodsLine {         // size=52
	date   Dt;             //
	int16  Sign;           // @#{-1; +1}
	int16  Flags;          // CCheckGoodsEntry::fXXX
	long   SessID;         // ->CSession.ID
	long   GoodsID;        // ->Goods.ID
	long   SerialID;       //
	double Qtty;           //
	double Rest;           //
	double Sum;            //
	long   AltGoodsID;     // ->Goods.ID Товар, который может быть списан вместо GoodsID
	float  AltGoodsQtty;   // @v4.4.10 Количество, списанное по альтернативному товару
index:
	SessID, Dt, Sign, GoodsID, SerialID (unique mod);
file:
	"cgline.btr";
	access=1;
}
//
// @todo:
//   -- Добавить поля Moment.dt, Moment.tm для отражения момента, от которого отсчитываются изменений в БД
//   -- Добавить поле UserID для отражения ид пользователя, который осуществил загрузку
//
table DvcLoadingStat {
	autolong ID;
	int16  DvcType;     // 1 - Кассовый узел, 2 - Весы
	long   DvcID;       // ИД устройства
	date   Dt;          // Дата начала загрузки
	time   Tm;          // Время начала загрузки
	long   Cont;        // Продолжительность загрузки (мс)
	int16  Status;      // Статус завершения загрузки (1 - OK, 0 - Error)
	int16  Reserve;
	long   Flags;
	string SysData[24]; // Системная информация //
index:
	ID (unique);
	DvcType, DvcID, Dt, Tm (unique mod);
	Dt, Tm, DvcType, DvcID (unique mod);
file:
	"dls.btr";
}

table DlsObj {             // size=22
	long   DlsID;          // ->DvcLoadingStat.ID
	int16  ObjType;        // @#{PPOBJ_GOODS, PPOBJ_SCARD}
	long   ObjID;          // ИД объекта (товар или дисконтная карта)
	long   LVal;           // @v4.8.5 Для загрузки товаров на весы - PLU
	double Val;            // Для товаров - цена, для дисконтных карт - процент скидки
index:
	ObjType, ObjID, DlsID (unique mod);
	DlsID, ObjType, ObjID (unique mod); // @v4.8.5
file:
	"dlso.btr";
}
//
// Сертификат качества
//
// Так как один сертификат может быть выписан на несколько различных товаров использование идентификатора
// товара вызывает значительные трудности. Покамест будем просто набивать наименование товара.
// Дата производства может быть не указана, или вместо нее может быть текст (например "На упаковке").
// Вследствии этого под это поле выделяем символьную строку SPrDate.
// @v4.4.5 Часть зарезервированного поля выделена под поле InnerCode; добавлен индекс {Passive, Code}
// @todo BlankCode, GoodsName, Manuf, SPrDate перенести в UnxTextRef
//
table QualityCert {        // size=224
	autolong ID;           // Ид. сертификата
	int16  Passive;        // @v4.3.5 Пассивный
	int16  Reserve1;       // @reserve
	string Code[26];       // Код
	string BlankCode[16];  // Код бланка
	long   GoodsID;        // Ид. товара           ->Goods.ID (не используется)
	string GoodsName[40];  // Наименование товара
	string Manuf[30];      // Изготовитель
	date   ProduceDate;    // Дата производства (Не используется)
	string SPrDate[20];    // Дата производства
	date   InitDate;       // Дата выдачи сертификата
	date   Expiry;         // Дата окончания срока действия     //
	long   RegOrgan;       // ->Person.ID Регистрирующий орган
	string Etc[32];        // Прочая информация                 //
	raw    Reserve2[22];   // @reserve
	string InnerCode[10];  // Внутренний код сертификата (для классификации внутри организации)
index:
	ID (unique);
	Code acs (dup mod);
	Expiry (dup mod);
	RegOrgan, InitDate (dup mod);
	Passive, Code acs (dup mod); // @v4.4.5
file:
	"qcert.btr";
	acstable = "rusncase.alt";
	balanced;
	access=1;
}
//
// Descr: Аналитические статьи бухгалтерских счетов
//   Список таблиц хранится в таб Reference (ObjType = PPOBJ_ACCSHEET).
//
table Article {            // size=160
	autolong ID;           // @id
	long   AccSheetID;     // Таблица ->Ref(PPOBJ_ACCSHEET)
	long   Article;        // Субсчет или аналитическая статья //
	long   ObjID;          // Ассоциированный объект (== Article - для неассоциированных таблиц)
	string Name[128];      // @name @v6.2.2 [48]-->[128]
	int16  AccessLevel;    // @unused Уровень доступа
	int16  Closed;         //
	long   Flags;          //
	raw    Reserve2[8];    // @reserve
index:
	ID (unique);
	AccSheetID, Article  (unique mod);
	AccSheetID, Name acs (dup mod);
	AccSheetID, ObjID    (unique mod);
file:
	"article.btr";
	acstable = "rusncase.alt";
	balanced;
	access=3;
}
//
// Вспомогательная таблица. Содержит соответствия между балансовыми
// счетами и аналитическими статьями. Каждое такое соответствие
// уникально и имеет идентификатор. Кроме того, оно имеет дополнительные
// признаки (иногда избыточные). Каждое новое соответствие добавляется лишь
// по факту бухгалтерской проводки, которая ссылается на эту
// таблицу. Если по сочетанию {счет, статья} не было проводок, то
// такого сочетания в таблице нет.
//
// Если запись имеет признак Closed, то она больше не ограничивает
// существования соответствующих записей в Account и Article. Естественно
// больше нет необходимости в сохранении связанных объектов.
// Вместо наименования счета будет выдаваться что-то вроде "Закрытый счет".
//
// @todo 18/12/2006 {
//     1. Поле MainOrgID
//     2. В индекс #3 добавить лидирующий сегмент MainOrgID
// }
//
table AcctRel {            // size=48
	autolong ID;           // @id
	long   AccID;          // ->Account.ID
	long   ArticleID;      // ->Article.ID
	long   CurID;          // ->Ref(PPOBJ_CURRENCY)
	int16  Ac;             // ->Account.Ac
	int16  Sb;             // ->Account.Sb
	long   Ar;             // ->Article.Article
	int16  Kind;           // Активность счета
	int16  Closed;         // Признак закрытого счета (Проводки не допускаются). Закрытие счета с номером,
		// для которого уже существует закрытый счет, влечет увеличение значения Closed на единицу
	long   Flags;          // @flags
	long   BankAccID;      // ->BankAccount.ID Корр. банковский счет
	int16  AccessLevel;    // Уровень доступа
	date   FRRL_Date;      // Начальная дата блокировки пересчета форвардных остатков
	raw    Reserve[6];     // @reserve
index:
	ID (unique);                            // #0
	AccID, ArticleID (unique mod);          // #1
	ArticleID, AccID (unique mod);          // #2
	Ac, Sb, Ar, CurID, Closed (unique mod); // #3
file:
	"acctrel.btr";
	balanced;
	access=1;
}
//
// Бухгалтерские проводки
//
// Каждая проводка в таблице дублируется (зеркальные записи).
// Первой для каждой проводки (Reverse == 0) идет запись
// с Acc по дебету. Зеркальная - Acc по кредиту.
//
// Проводка "задним числом" вносится как последняя проводка
// за день. Перед занесением такой проводки проверяются //
// все форвардные проводки. Пересчитываются все форвардные
// остатки и балансы. После корректного исполнения всех этих
// операций можно заносить "левую" проводку.
//
table AccTurn {            // size=44
	long   Acc;            // ->AcctRel.ID  Ид. ведущего счета
	long   Bal;            // ->Account.ID  Ид. балансового счета
	date   Dt;             // Дата операции
	long   OprNo;          // Номер записи за день (1..)
	long   BillID;         // ->Bill.ID     Связанный док. учета // @v12.1.5 Bill-->BillID
	int16  RByBill;        // Номер записи для документа Bill
		// Для проводок покрытия валютных операций базовой валютой
		// значение RByBill имеет смещение BASE_RBB_BIAS = 1000 (ppdefs.h)
	int16  Reverse;        // Признак зеркальной записи {0, 1}
	long   CorrAcc;        // ->AcctRel.ID  Ид. корреспондирующего счета
	money  Amount[8];      // Сумма проводки
	money  Rest[8];        // Остаток по счету после проводки
index:
	BillID, Reverse, RByBill (unique);
	Acc, Dt, OprNo (unique mod);
	Dt, OprNo (unique);
	Bal, Dt, OprNo (unique mod);
file:
	"accturn.btr";
	balanced;
	access=1;
}
//
// Остатки по балансовым счетам за каждый день.
// Если по балансовому счету за день не было проводок, то
// за этот день по этому счету запись не хранится //
//
// @todo {
//     17/12/2006 Заменить money[10] на double
// }
//
table Balance {            // size=28
	date   Dt;             //
	long   AccID;          // ->Account.ID
	money  DbtRest[10];    //
	money  CrdRest[10];    //
index:
	Dt, AccID (unique);
	AccID, Dt (unique);
file:
	"balance.btr";
	balanced;
	access=1;
}
//
// Бюджет
// @todo Memo перенести в UnxTextRef
//
table BudgetItem {
	autolong ID;           // @id
	long   BudgetID;       //
	long   Acc;            // ->AcctRel.ID  Ид. ведущего счета
	long   Flags;          // @flags
	long   Kind;           // Вид величины (0 - план, 1 - факт)
	date   Dt;             //
	double Amount;         //
	raw    Reserve[32];    // @reserve
	note   Memo[512];      // @memo @v7.0.0 [256]-->[512]
index:
	ID (unique mod);                      // #0
	BudgetID, Acc, Kind, Dt (unique mod); // #1
file:
	"budgitem.btr";
	vlr;
	balanced;
	access=1;
}
//
// Книги продаж и покупок
// Специализированная таблица
// Предназначена для формирования отчетности по НДС
// для предоставления в налоговую службу.
//
/* @v12.2.6 table VATBook {            // size=268
	autolong  ID;          // @id
	string Code[24];       // Номер счета-фактуры или документа. v4.4.2 [10]-->[24]
	int16  LineType_;      // Тип строки (PPVTB_SELL = 1 | PPVTB_BUY = 2 | PPVTB_SIMPLELEDGER [PPOBJ.H])
	int16  LineSubType;    // @v7.2.8 Подтип строки (для случаев, когда запись по одному документу должна разбиваться на несколько).
	int16  Excluded;       // Исключенная запись
	uint16 Reserve;        // @alignment
	date   Dt;             // Дата документа
	long   LineNo;         // Номер строки за дату
	date   InvcDt;         // Дата поступления счета-фактуры
	date   PaymDt;         // Дата оплаты счета-фактуры
	date   RcptDt;         // Дата поступления/отгрузки товара
	long   Object;         // ->Article.ID Контрагент
	long   Object2;        // Дополнительная статья //
	long   Link;           // ->Bill.ID    Связанный документ (может быть 0)
	long   OpID;           // ->Ref(PPOBJ_OPRKIND), = Bill(Link).OprKind
	long   LocID;          // ->Location.ID Склад, к которому относится запись
	long   Flags;          // Флаги
	money  Amount[8];      // Номинальная сумма                        | (PPVTB_SIMPLELEDGER) Доход
	money  Excise[8];      // Сумма акциза                             | (PPVTB_SIMPLELEDGER) Доход для налогообложения //
	money  VAT0[8];        // Сумма со ставкой НДС = 0%                | (PPVTB_SIMPLELEDGER) Расход
	money  Export[8];      // Сумма экспортной части сделки (НДС = 0%) | (PPVTB_SIMPLELEDGER) Расход для налогообложения //
	money  VAT1[8];        // Сумма по 1-й ставке НДС (без НДС)
	money  SVAT1[8];       // Сумма НДС по 1-й ставке
	money  VAT2[8];        // Сумма по 2-й ставке НДС (без НДС)
	money  SVAT2[8];       // Сумма НДС по 2-й ставке
	money  VAT3[8];        // Сумма по переходной ставке НДС (без НДС)
	money  SVAT3[8];       // Сумма НДС по переходной ставке
	date   CBillDt;        // @v7.3.11 Дата корректирующего документа
	string CBillCode[24];  // @v7.3.11 Номер корректирующего документа
	string TaxOpCode[8];   // @v8.5.11 Код номера операции для налоговой декларации
	raw    Reserve2[72];   // @v7.3.11 @reserve
index:
	ID (unique);
	Link, LineType_, Dt, LineNo, LineSubType (unique mod); // three last segs added since @v3.11.2
	Dt, LineNo (unique mod);
	LineType_, Dt, LineNo, LineSubType (unique mod);
	Object, Dt, LineNo (unique mod);
	LineType_, PaymDt (dup mod);
	Object, PaymDt (dup mod);
file:
	"vatbook.btr";
	balanced;
	access=1;
}*/

table VATBook {            // @v12.2.6 size=324
	autolong  ID;          // @id
	date   Dt;             // Дата документа
	string Code[48];       // Номер счета-фактуры или документа. v4.4.2 [10]-->[24] // @v12.2.6 [24]-->[48]
	date   CBillDt;        // @v7.3.11 Дата корректирующего документа
	string CBillCode[48];  // @v7.3.11 Номер корректирующего документа // @v12.2.6 [24]-->[48]
	string TaxOpCode[8];   // @v8.5.11 Код номера операции для налоговой декларации
	long   LineNo;         // Номер строки за дату
	date   InvcDt;         // Дата поступления счета-фактуры
	date   PaymDt;         // Дата оплаты счета-фактуры
	date   RcptDt;         // Дата поступления/отгрузки товара
	long   ArID;           // ->Article.ID Контрагент по документу         // Object-->ArID
	long   Ar2ID;          // ->Article.ID Дополнительная статья документа // Object2->Ar2ID
	long   LinkBillID;     // ->Bill.ID    Связанный документ (может быть 0) // @v12.2.6 Link-->LinkBillID
	long   OpID;           // ->Ref(PPOBJ_OPRKIND), = Bill(Link).OprKind
	long   LocID;          // ->Location.ID Склад, к которому относится запись
	long   Flags;          // Флаги
	double Amount;         // Номинальная сумма                        | (PPVTB_SIMPLELEDGER) Доход
	double Excise;         // Сумма акциза                             | (PPVTB_SIMPLELEDGER) Доход для налогообложения //
	double VAT0;           // Сумма со ставкой НДС = 0%                | (PPVTB_SIMPLELEDGER) Расход
	double Export;         // Сумма экспортной части сделки (НДС = 0%) | (PPVTB_SIMPLELEDGER) Расход для налогообложения //
	double VAT1;           // Сумма по 1-й ставке НДС (без НДС)
	double SVAT1;          // Сумма НДС по 1-й ставке
	double VAT2;           // Сумма по 2-й ставке НДС (без НДС)
	double SVAT2;          // Сумма НДС по 2-й ставке
	double VAT3;           // Сумма по переходной ставке НДС (без НДС)
	double SVAT3;          // Сумма НДС по переходной ставке
	double VAT4;           // @v12.2.6
	double SVAT4;          // @v12.2.6
	double VAT5;           // @v12.2.6
	double SVAT5;          // @v12.2.6
	int16  LineType_;      // Тип строки (PPVTB_SELL = 1 | PPVTB_BUY = 2 | PPVTB_SIMPLELEDGER [PPOBJ.H])
	int16  LineSubType;    // @v7.2.8 Подтип строки (для случаев, когда запись по одному документу должна разбиваться на несколько).
	int16  Excluded;       // Исключенная запись
	raw    Reserve2[50];   // @v7.3.11 @reserve // @v12.2.6 [72]-->[50] (48 + 2байта для выравнивания предыдущего поля)
index:
	ID (unique);
	LinkBillID, LineType_, Dt, LineNo, LineSubType (unique mod); // three last segs added since @v3.11.2
	Dt, LineNo (unique mod);
	LineType_, Dt, LineNo, LineSubType (unique mod);
	ArID, Dt, LineNo (unique mod);
	LineType_, PaymDt (dup mod);
	ArID, PaymDt (dup mod);
file:
	"vatbook.btr";
	balanced;
	access=1;
}
//
// Заголовки MRP-таблиц
//
table MrpTab {          // size=88
	autolong ID;        // @id
	long   ParentID;    // ->MrpTab.ID Родительская таблица
	string Name[48];    // @name
	long   LinkObjType; // Тип связанного объекта (PPOBJ_BILL, PPOBJ_GOODS, PPOBJ_DRAFTWROFF, ...)
	long   LinkObjID;   // ИД связанного объекта
	long   LocID;       // ->Location.ID Склад, к которому привязана MRP-таблица
	date   Dt;          // Дата, на которую должны рассчитываться остатки
	long   Flags;       //
	raw    Reserve[16]; // @reserve
index:
	ID (unique);
	LinkObjType, LinkObjID, Dt, LocID (dup mod);
	Dt, LocID (dup mod);
	ParentID, LocID, Dt (dup mod);
	Name acs (dup mod);
file:
	"mrptab.btr";
	acstable = "rusncase.alt";
	access=1;
}
//
// Строки MRP-таблиц
// Таблица пар {Изделие ->Материал} (DestID означает Изделие, SrcID означает Материал)
// Если SrcID ==  0, то запись означает полное итоговое требование на DestReqQtty единиц товара DestID
// Если SrcID == -1, то запись означает итоговое зависимое требование на DestReqQtty единиц товара DestID
// Если SrcID == -2, то запись означает итоговое независимое требование на DestReqQtty единиц товара DestID
//
table MrpLine { // Size=68
	autolong ID;
	long   TabID;       // ->MrpTab.ID
	long   DestID;      // ->Goods2.ID Исходящий товар
	long   SrcID;       // ->Goods2.ID Входящий товар
	double DestReqQtty; // Требуемое количество исходящего товара
	double SrcReqQtty;  // Требуемое количество входящего товара (связано с DestReqQtty через структуру)
		// Для записей, имеющих флаг MRPLF_REPLACED и SrcID == MRPSRCV_TOTAL в этом поле указывается //
		// количество, замещенное другими позициями
	double DestRest;    // Остаток товара DestID на дату, определяемую MRP-таблицей. Определен только для SrcID == MRPSRCV_TOTAL
	double DestDfct;    // Дефицит товара DestID. Определен только для SrcID == MRPSRCV_TOTAL
	double Cost;        // Цена поступления товара DestID. Для строк с независимым требованием
		// рассчитывается по себестоимости компонентов, от которых зависит.
		// Для строк с зависимым требованием извлекается из БД
	double Price;       // Цена реализации товара DestID. Для строк с независимым требованием
		// рассчитывается по цене реализации компонентов, от которых зависит.
		// Для строк с зависимым требованием извлекается из БД
	long   Flags;       // MRPLF_XXX
		// Терминальные (не комплектуемые) позиции DestID имеют флаг MRPLF_TERMINAL
index:
	ID (unique);
	TabID, DestID, SrcID (unique mod);
	TabID, SrcID, DestID (unique mod);
file:
	"mrpline.btr";
	access=1;
}
//
// Системный журнал
// @todo {
//     Поля Action и ObjType сделать 2-байтовыми для сокращения размера записи
// }
//
table SysJournal {         // size=24 // @v7.7.8 28-->24
	date   Dt;
	time   Tm;
	long   UserID;         // ->Ref(PPOBJ_USR) @v5.8.11 User-->UserID
	long   Action;         // @v7.7.8 long-->int16 ->Ref(PPOBJ_ACTION)
	long   ObjType;        // @v7.7.8 long-->int16
	long   ObjID;
	long   Extra;          //
	// if Action == PPACN_UPDBILL || Action == PPACN_RMVBILL:
	//    Если в БД поддерживается технология сохранения версий документа, то поле Extra
	//    принимает значение HistBill.ID предыдущей версии документа
	//
index:
	Dt, Tm (dup);                 // @v7.7.8 unique-->dup
	ObjType, ObjID, Dt, Tm (dup); // @v7.7.8 unique-->dup
file:
	"sj.btr";
	access=1;
}
//
// Резервная таблица системного журнала.
// Если не удалось записать в основной журнал, то запись пишется в резервный.
// Потом из резерва все записи переносятся в основной.
// Структура таблицы отличается от SysJournal только отсутствием всех индексов кроме первого.
//
table SjRsrv {
	date   Dt;
	time   Tm;
	long   UserID;         // ->Ref(PPOBJ_USR) @v5.8.11 User-->UserID
	long   Action;         // @v7.7.8 long-->int16 ->Ref(PPOBJ_ACTION)
	long   ObjType;        // @v7.7.8 long-->int16
	long   ObjID;          //
	long   Extra;          //
index:
	Dt, Tm (dup);          // @v7.7.8 unique-->dup
file:
	"sjr.btr";
	access=1;
}
//
//
//
table GtaJournal {
	date   Dt;
	time   Tm;
	long   GlobalAccID;
	long   Op;
	long   ObjType;
	long   ObjID;
	long   Count;
	long   Duration;
	raw    Reserve[64];
index:
	Dt, Tm, GlobalAccID (unique);
	GlobalAccID, Dt, Tm (unique);
	Op, Dt, Tm, GlobalAccID (unique);
	ObjType, ObjID, Dt, Tm, GlobalAccID (unique);
file:
	"gtaj.btr";
	access=1;
}
//
// @construction
// Сохраненные версии модифицированных и удаленных объектов.
// Записи с типом и идентификатором объекта 0 представляют собой
// сохраненный контекст синхронизации, соответствующий версии системы SysVer.
// Для таких записей Ver == SysVer (для индексации).
//
table ObjVer {
	autolong ID;    // Уникальный идент записи
	long   ObjType; // Тип объекта
	long   ObjID;   // ИД объекта
	long   Ver;     // Версия объекта
	uint32 SysVer;  // Пороговая версия системы, сформировавшей запись. Необходима для правильной трансляции
		// данных при изменении формата данных.
	long   Size;    // Размер сохраненного пакета
	blob   Data[2048]; // Бинарное представление пакета объекта
index:
    ID (unique);
    ObjType, ObjID, Ver (unique);
file:
	"objver.btr";
	vlr;
}
//
// Descr: Запросы к удаленным сервисам, требующие длительного времени отклика
// (Delayed Global Query)
//
/* @v9.6.4 (useless)
table DGQ {
	raw    QUUID[16]; // UUID запроса
	string QSID[48];  // Строковый идентификатор запроса
	date   QDt;       // Дата запроса
	time   QTm;       // Время запроса
	date   ADt;       // Дата ответа
	time   ATm;       // Время ответа
	long   QueryType; // PPEDIOP_XXX
	int16  Ready;     // Признак выполненного запроса
    int16  Flags;     //
	blob   VT[512];
index:
    QUUID (anysegnull unique);  // #0
    QSID  (anysegnull unique);  // #1
    Ready, QDt, QTm (dup mod);  // #2
file:
	"dgq.btr";
	compress;
	vlr;
	access=1;
}
*/
//
// Таблицы для интерфейса с кассовым модулем Кристалл-УКМ
//
table Cr_PosLoad {
	lstring Cash_Code[21];   // Номер кассы в торговой системе
	int16  DataType;         // Тип данных
		//  0 - признак наличия данных для кассы
		//  1 - товары
		//  2 - штрих-код
		//  3 - секции
		//  4 - кассиры
		//  7 - предельная цена товара
		// 11 - Дисконтные карты
	int32  KeyLongint;       // Код товара
	lstring KeyString[31];   // Штрихкод, Табельный номер
	lstring F_MODE[2];       // Режим  "+" - добавить, "-" - удалить
	lstring F_FIRM_NAME[31]; // Товары: Наименование; Кассиры: Пароль
	lstring F_ARTIKL[31];    // Товары: Артикул; ШК: Штрих код;
		// Кассиры: Имя кассира; Секции: Наименоване секции
	double  F_CONTR_COST;
	lstring F_CURRENCY[4];   // Товары: Валюта
	double  F_COST;          // Товары: Цена; ШК: Цена
	lstring F_UNIT[6];       // Товары: Единица измерения //
	lstring F_ORIGIN[3];     // Товары, ШК = "W0" - запрашивать количество
	lstring F_GRCODE[10];    // Товары, ШК = Секции
	lstring F_CODE[17];      // Товары, ШК = Код товара
	double  F_QUANT;         // Товары: Количество; ШК: Количество по умолчанию
	lstring F_STORE[7];      // Товары: Код склада
	lstring F_BAR_CODE[14];  // Товары: Штрихкод
	int16   F_GROOP1;        // Товары: Первый уровень классификатора
	int16   F_GROOP2;
	int16   F_GROOP3;
	int16   F_GROOP4;
	int16   F_GROOP5;
	double  F_NDSX1;         // Товары: НПС
	double  F_NDSX2;         // Товары = Ставка НДС
	double  F_NDSX3;
	double  F_NDSX4;
	double  F_NDSX5;
	lstring F_SERIA[11];     // Товары: характеристика 1
	lstring F_BESTB[11];     // Товары: характеристика 2
	lstring F_ENABLEX[2];    // Товары: Признак оприходования товара
	double  F_PRESISION;     // Товары: Мерность товара; ШК: Скидка на штрих код
	lstring F_CONTR_CODE[8];
	lstring F_PARENT[5];
	lstring F_RAW_MAT[7];
	lstring F_COLOR[11];
	lstring F_MODEL[8];
	lstring F_SORT[4];
	lstring F_SIZE[12];
	date    F_MK_DATA;
	double  F_PERCENT;
	double  F_EXTRA_SUM;
	date    F_DATE;
	double  F_SUM;
	time    F_MK_TIME;
	int32   F_M_COD;
	lstring F_S_COD[41];     // Кассиры: права доступа
index:
	Cash_Code, DataType, KeyLongint (dup mod);
	Cash_Code, DataType, KeyString (dup mod);
file:
	"posload.btr";
}

table Cr_CredoPay {
	lstring BarCode[23];    // Номер карты
	date    PayDate;        // Дата операции
	time    PayTime;        // Время операции
	int16   PayType;        // Тип документа (ПКО-5,РКО-6,Чек-7)m 5
	double  PaySumma;       // Сумма по операции (расход с минусом) +
	double  RestSumma;      // Остаток по карте
	long    CashCode;       // Номер кассы
	lstring DocNumber[11];  // Номер документа (чека)
	date    DocDate;        // Дата документа
	int16   ShopIndex;      // Магазин
	long    DiscCliID;      // Внутренний ID карты
	long    Rezerv;         // Резерв
index:
	BarCode, PayDate, PayTime (unique mod);
	CashCode, DocNumber, PayDate, BarCode (dup mod);
	DiscCliID, DocDate, DocNumber, PayType (dup mod);
file:
	"credopay.btr";
}

table Cr_ZReport {
	long   CashNumber;  // *
	long   ZNumber;     // *
	double ZSale;
	double ZReturn;
	double ZDiscount;
	date   ZDate;       // *
	time   ZTime;       // *
	double ZCrSale;
	double ZCrReturn;
	double ZCrDiscount;
	double TSale;
	double TReturn;
	double CrSale;
	double CrReturn;
	double CurMoney;
index:
	CashNumber, ZNumber (dup mod);
	CashNumber, ZDate (dup mod);
file:
	"zreport.btr";
}

/*
table Cr_Sale2 { // В рамках проекта 'Кристалл-SetRetail-gateway'
	int32 NSmena;
	double PriceNSP;
	double SumNSP;
	double SumNDS;
	double Summa;
	time Times;
	double NDSx2;
	double NDSx1;
	lstring BestB[11];
	lstring Seria[11];
	double Ck_Disc;
	double Ck_Disg;
	lstring Ck_CurAbr[4];
	double Ck_Curs;
	int32 Ck_Number;
	lstring Store[7];
	double Price;
	date DateOperation;
	double Contr_Cost;
	lstring Contr_Code[8];
	int32 Ck_Card;
	int32 Cash_Code;
	lstring Cassir[11];
	int32 Code;
	int16 GrCode;
	double Quant_S;
	lstring Operation[2];
	double Quant;
}
*/

table Cr_Sale {
	double  Quant;         // * Quantity
	lstring Operation[2];  // * Код операции
	date    DateOperation; // * Дата операции
	double  Price;         // * Цена (руб)               // 22
	lstring Store[7];      // Склад                      // 29
	long    Ck_Number;     // * Номер чека               // 31
	double  Ck_Curs;       // Курс валюты                // 39
	lstring Ck_CurAbr[4];  // Аббревиатура валюты        // 43
	double  Ck_Disg;       // Скидка на покупку в рублях //
	double  Ck_Disc;       // * Скидка на чек в рублях
	double  Quant_S;       //
	int16   GrCode;        // Код группы товара
	long    Code;          // * ИД товара
	lstring Cassir[11];    // Кассир
	long    Cash_Code;     // * Код кассы              ->Cr_ZReport.CashNumber
	long    Ck_Card;       // * Код кредитной карты
	lstring Contr_Code[8]; // Код поставщика
	double  Contr_Cost;    // Цена поступления //
	lstring Seria[11];
	lstring BestB[11];
	double  NDSx1;         // Ставка НДС, %
	double  NDSx2;         // Ставка налога с продаж, %
	time    Times;         // * Время продажи
	double  Summa;         // * Сумма покупки (руб)
	double  SumNDS;        // Сумма НДС (руб)
	double  SumNSP;        // Сумма налога с продаж (руб)
	double  PriceNSP;      // Продажная цена (руб)
	long    NSmena;        // * Номер смены             ->Cr_ZReport.ZNumber
index:
	DateOperation, GrCode, Cash_Code, Ck_Number (dup mod); // #0
	GrCode, DateOperation, Cash_Code, Ck_Number (dup mod); // #1
	Cash_Code, Ck_Number, GrCode, Code, Price   (dup mod); // #2
	DateOperation, Cash_Code, Ck_Number         (dup mod); // #3
	DateOperation, Cassir, Cash_Code, Ck_Number (dup mod); // #4
	Cassir, DateOperation, Cash_Code, Ck_Number (dup mod); // #5
	DateOperation, GrCode, Code, Price          (dup mod); // #6
	Code, DateOperation                         (dup mod); // #7
	Cash_Code, NSmena                           (dup mod); // #8 // *
file:
	"sale.btr";
}

table Cr_CashAuth {
	int16  ShopIndex;
	int16  CashNumber;
	int16  ZNumber;
	long   CheckNumber;
	int16  ID;
	lstring CardNumber[20];
	lstring AuthCode[10];
	lstring Casher[11];
	date   DateSale;
	time   TimeSale;
	int16  Depart;
	long   Tovar;
	double Price;
	double Summa;
index:
	ShopIndex, CashNumber, ZNumber, CheckNumber, ID (unique mod);
file:
	"cashauth.btr";
}

table Cr_CashDCrd {
	int16  ShopIndex;
	int16  CashNumber;
	int16  ZNumber;
	int32  CheckNumber;
	int16  CardType;
	lstring CardNumber[23];
	double DiscountRub;
	double DiscountCur;
	lstring Casher[11];
	date   DateSale;
	time   TimeSale;
index:
	ShopIndex, CashNumber, ZNumber, CheckNumber, CardType, CardNumber (unique mod);
	CardType, CardNumber (dup mod);
	DateSale, CardType, CardNumber (dup mod);
file:
	"cashdcrd.btr";
}
//
// Таблица продаж
//
table PredictSales { // Size=20
	long   GoodsID;  // ->Goods2.ID
	int16  Loc;
	int16  Dt;       // Number of days since 31/12/1995
	int16  RType;    // PSRECTYPE_XXX (pp.h)
	int16  Flags;    // PRSALF_XXX (pp.h)
	float  Quantity;
	float  Amount;
index:
	RType, Loc, GoodsID, Dt (unique mod);
file:
	"psales.btr";
}
//
// Таблица для хранения статистических характеристик товаров
//
table GoodsStat { // Size=42 // @v6.0.9 [42]-->[36]
	int16  Loc;
	int16  LastDate;
	long   GoodsID;
	float  QttySum;
	float  QttySqSum;
	float  AmtSum;
	float  AmtSqSum;
	int16  Count;
	raw    Reserve2[10];   // (+2 @alignment)
index:
	Loc, GoodsID (unique mod);
	GoodsID, Loc (unique mod); // @v6.0.9
file:
	"gstat.btr";
	// @v6.0.9 vlr;
}
//
// Процессоры.
// Таблица, определяющая группы процессоров и процессоры.
// @todo Добавить зарезервированное пространство.
// @todo Увеличить длину поля TimeChunkBrowserQuant до int32.
// @todo Увеличить длину поля Name до [128]
// @todo Добавить индекс {LinkObjType, LinkObjID}
//
table Processor {          // size=144
	autolong  ID;          //
	long   ParentID;       // ->Processor.ID
	long   Kind;           // @#{PPPRCK_GROUP || PPPRCK_PROCESSOR}
	string Name[48];       //
	long   LocID;          // ->Location.ID Склад, к которому относится процессор. Если 0, то наследуется от ParentID
	long   TimeUnitID;     // ->Ref(PPOBJ_UNIT) Единица времени, используемая для расчета мощности процессора, и для учета использования //
		// Если 0, то наследуется от ParentID
	long   Flags;          // PRCF_XXX
	long   LinkObjType;    // Если 0, то наследуется от ParentID
	long   LinkObjID;      // Для групп процессоров - если LinkObjType != 0, то определяет группу ассоциации
		// (например, вид персоналии для персоналий)
	long   WrOffOpID;      // ->Ref(PPOBJ_OPRKIND) Операция списания сессий. Если 0, то наследуется от ParentID
	long   WrOffArID;      // ->Article.ID         Контрагент списания сессий. Если 0, то наследуется от ParentID
	long   SuperSessTiming; // [sec] Стандартная продолжительность суперсессии (только для групп)
	long   RestAltGrpID;   // ->Goods2.ID ИД альтернативной товарной группы, по которой учитываются //
		// исходящие остатки по закрытию сессии для этой группы процессоров
	long   PrinterID;      // ->Ref(PPOBJ_BCODEPRINTER) Принтер, используемый для печати этикеток
	int16  LabelCount;     // @v5.0.2 Количество этикеток, которое следует печатать на принтере
	string Code[10];       // @v5.0.9 Код процессора
	long   WrOffGenOpID;   // @v5.4.1 Обобщенная операция списания, позволяющая выбрать конкретную операцию в ручную
	string SrvJobSymb[20]; // @v6.5.0 Символ серверной задачи, которая должна быть выполнена при
		// переводе сессии процессора в состояние TSESST_CLOSED (только в случае завершения сессии сервером).
	long   CipPersonKindID; // @v7.7.2 Вид персоналий, которые могут регистрироваться в тех сессиях.
	int16  CipMax;         // @v7.7.2 Максимальное количество персоналий, которое может быть загеристрировано на тех сессии процессора.
	int16  TcbQuant;       // @v7.9.3 Квант времени (5сек) во временной диаграмме. Параметр переопределяет
		// аналогичный в конфигурации PPTSessConfig. При смешении в одной диаграмме процессоров с разными
		// квантами выбирается тот, что меньше.
index:
	ID (unique);
	Kind, ParentID, Name acs (unique mod);
	Kind, Name acs (unique mod);
file:
	"processr.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Технологии. Таблица, связывающая процессоры с обрабатываемыми на них
// (производимыми или расходуемыми) товарами и, возможно, структурами этих товаров.
// @done @v11.1.12 @todo Memo перенести в UnxTextRef
//
table Tech {               // size=104+160
	autolong ID;           // @id
	string Code[48];       // Код технологии // @v11.1.12 [24]-->[48]
	long   PrcID;          // ->Processor.ID
	long   GoodsID;        // ->Goods.ID
	long   GStrucID;       // ->Ref(PPOBJ_GOODSSTRUC)
	long   Flags;          // TECF_XXX
	int16  Sign;           // @#{-1,0,+1} -1 - расход, +1 - приход, 0 - остаток не меняется (использование) //
	int16  Kind;           // @v5.2.0 {0 - обычная технология, 1 - технология перенастройки, 2 - автотехнология (правило автоматического создания), 3 - папка}
	long   PrevGoodsID;    // @v5.2.0 Для перенастройки. Товар, который производился непосредственно до GoodsID.
	long   Duration;       // @v5.2.0 Для перенастройки - время перенастройки в секундах.
	double Cost;           // Суммарная стоимость операции на одну торговую единицу GoodsID
	double Capacity;       // Производительность процессора ProcID при использовании этой технологии (торговых единиц / sec).
	double Rounding;       // @v5.0.6 Округление в торговых единицах основного товара
	//
	// Следующие два поля используются технологиями перенастройки
	// для идентификации варианов перенастройки.
	//
	long   TransClsID;     // @v5.2.1 Переходный класс товара
	long   TransMask;      // @v5.2.1 Маска изменения параметра
	float  InitQtty;       // @v5.5.4 Количество товара по умолчанию, устанавливаемое как планируемое, в новую сессию
	long   ParentID;       // @v7.5.6 Родительская технология //
	long   OrderN;         // @v7.5.6 Счетчик, обеспечивающий уникальность по родительской технологии.
		// Кроме того, этот счетчик управляет порядком следования технологий внутри родительской технологии.
	int16  CipMax;         // @v7.7.2 Максимальное количество персоналий, которое может быть загеристрировано на тех сессии процессора.
	raw    Reserve3[10];   // @reserve  // @v11.1.12 [2]-->[10]
	// @v11.1.12 note   Memo[512];      // @memo @v7.0.0 [160]-->[512]
index:
	ID (unique);                           // #0
	Code acs (anysegnull unique mod);      // #1
	PrcID, GoodsID, GStrucID (unique mod); // #2
	GoodsID, GStrucID, PrcID (unique mod); // #3
	GStrucID, GoodsID, PrcID (unique mod); // #4
	ParentID, OrderN (unique mod);         // #5 @v7.5.6
file:
	"tech.btr";
	compress; // @v11.1.12
	acstable = "rusncase.alt"; // @v11.1.12
	// @v11.1.12 vlr;
}
//
// Технологические сессии
// Одна сессия может использовать только один процессор и (или) одну технологию.
// @todo Memo перенести в UnxTextRef
//
table TSession {           // size=104+160
	autolong ID;           // @id
	long   ParentID;       // ->TSession.ID
	long   Num;            // Номер сессии (уникальный по процессору) @v5.8.11 Number-->Num
	long   TechID;         // @#{!0} ->Tech.ID
	long   PrcID;          // @#{!0 && PrcID == TechID.PrcID} ->Processor.ID
	date   StDt;           // Дата начала сессии
	time   StTm;           // Время начала сессии
	date   FinDt;          // Дата окончания сессии
	time   FinTm;          // Время окончания сессии
	int16  Incomplete;     // @#{0,5,10} Закрытие сессии не было завершено
	int16  Status;         // @#{1..5}   Состояние сессии TSESST_XXX
	long   Flags;          // TSESF_XXX
	long   ArID;           // ->Article.ID Основная статья для подстановки в документ списания //
	long   Ar2ID;          // ->Article.ID 2-я статья для подстановки в документ списания //
	long   PlannedTiming;  // Планируемое время работы (секунд)
	double PlannedQtty;    // Планируемый объем производства (TechID.GoodsID.UnitID)
	double ActQtty;        // Фактический объем производства (TechID.GoodsID.UnitID)
	long   OrderLotID;     // ->Receipt.ID Связанный лот заказа
	long   PrevSessID;     // ->TSession.ID ИД предыдущей сессии. Привязка к предыдущей сессии уникальна.
		// То есть, на сессию, как на предыдущую может ссылаться ноль или одна сессия.
		// @#{PrcID == PrevSessID.PrcID}
	double Amount;
	long   LinkBillID;     // ->Bill.ID Документ, к которому привязана сессия //
		// Схема функционирования этой ссылки:
		//   1. Формируется сессия, привязанная по этой ссылке к драфт-документу
		//   2. После закрытия сессия списывается //
		//   3. Документы списания одновременно становятся членами пула списания сессии и членами пула
		//      списания документа LinkBillID. Соответственно, LinkBillID получает статус списанного документа.
		//
	long   SCardID;        // ->SCard.ID  Дисконтная карта, по которой предоставляется скидка в ценах сессии
	long   ToolingTime;    // Время на перенастройку (секунд). Рассчитывается автоматически по технологиям перенастройки.
	long   CCheckID_;      // ->CCheck.ID Ид кассового чека, сформированного и проведенного, на основании этой сессии.
	raw    Repeating[8];   // @v11.0.4 (DateRepeating) Расписание повтора
	long   RepBaseID;      // @v11.0.4 ->TSession.ID Ид сессии, на основе расписания которой была сформирована данная сессия //
	raw    Reserve[16];    // @v11.0.4 @reserve
	// @v11.0.4 (moved to UnxTextRef) note   Memo[512];      // @memo @v7.0.0 [160]-->[512]
index:
	ID (unique);                                       // #0
	PrcID, Num (unique mod);                           // #1
	StDt, StTm (dup mod);                              // #2
	FinDt, FinTm  (dup mod);                           // #3
	PrcID, StDt, StTm (unique mod);                    // #4
	TechID, StDt, StTm (dup mod);                      // #5
	ParentID, PrcID, Num (unique mod);                 // #6
	OrderLotID, PrcID, Num (anysegnull unique mod);    // #7 @v4.9.17
	PrevSessID, PrcID, Num (anysegnull unique mod);    // #8 @v5.0.2 // @v6.3.0 +(PrcID, Num)
file:
	"tsess.btr";
	// @v11.0.4 vlr;
	access=1;
}
//
// Строки технологических сессий
//
table TSessLine {          // size=128
	long   TSessID;        // TSession.ID
	long   OprNo;          //
	long   GoodsID;        // ->Goods.ID
	long   LotID;          // ->Receipt.ID Лот, в который отображается строка после списания //
	long   UserID;         // ->Ref(PPOBJ_USR) Пользователь, который ввел операцию
	int16  Sign;           // @#{-1,0,+1} -1 - расход, +1 - приход, 0 - остаток не меняется //
	int16  Reserve;        // @#{0}
	date   Dt;             // Дата ввода строки.  Инициализируется программно. Модификация только аварийная //
	time   Tm;             // Время ввода строки. Инициализируется программно. Модификация только аварийная //
	long   Flags;          // TSESLF_XXX
	double Qtty;           // @#{>0}
	string Serial[24];     // Серийный номер
	double Price;          // Стоимость единицы товара
	double WtQtty;         // Количество в независимых физических единицах
	date   Expiry;         // Срок годности товара, оприходованного строкой
	double Discount;       // Скидка к цене Price. Итоговая цена по строке равна (Price-Discount)
	double LotDimX;        // @v11.0.4 Размерность лота X
	double LotDimY;        // @v11.0.4 Размерность лота Y
	double LotDimZ;        // @v11.0.4 Размерность лота Z
	// @v11.0.4 long   Reserve2;       // @reserve
	double OrgQtty;        // @v11.0.7 (в счет резерва) Оригинальное количество, сопоставленное со строкой. Смысл поля в
		// том, чтобы обеспечить автоматическое обратимое изменение основного количества Qtty посредством пересчета на основе
		// полной информации о сессии.
index:
	TSessID, OprNo (unique mod);       // #0
	TSessID, Dt, Tm (unique mod);      // #1
	GoodsID, Dt, Tm (dup mod);         // #2
	Serial, Sign (allsegnull dup mod); // #3
	// @todo TSessID, GoodsID, OprNo (unique mod);
file:
	"tsessln.btr";
}
//
// Descr: Рассчитанные бизнес-показатели
// @todo Str перенести в UnxTextRef
//
table BizScore {
	date   ActualDate;     // Дата, для которой проводился расчет
	date   Dt;             // Дата расчета
	time   Tm;             // Время расчета
	long   UserID;         // ->Ref(PPOBJ_USR)
	long   ScoreID;        // ->Ref(PPOBJ_BIZSCORE)
	long   ObjType;        // Тип связанного с показателем объекта
	long   ObjID;          // Ид связанного с показателем объекта
	double Val;            // Числовое значение показателя //
	long   Flags;          // @flags
	raw    Reserve[12];    // @reserve
	note   Str[252];       // Строковое значение показателя //
index:
	ActualDate, ScoreID, ObjID (unique mod);
	ScoreID, ActualDate, ObjID (unique mod);
	UserID, ActualDate, ScoreID, ObjID (unique mod);
	Dt, Tm, ScoreID (unique mod);
file:
	"bizscore.btr";
	vlr;
}

table GlobalBizScore {
	long   UpdCounter;     // Счетчик обновления записей. Каждая группа обновлений имеет свой номер,
		// заносимый в системное событие PPACN_GLOBBIZSCOREUPD как дополнительный идентификатор
	date   ActualDate;     // Дата, для которой проводился расчет
	date   Dt;             // Дата расчета
	time   Tm;             // Время расчета
	long   GlobalUserID;   // ->Ref(PPOBJ_GLOBALUSERACC)
	long   LocalScoreID;   //
	double Val;            // Числовое значение показателя //
	long   Flags;          // @flags
	raw    Reserve[12];    // @reserve
	string ScoreName[48];  //
	string ScoreDescr[252]; //
	note   Str[252];       // Строковое значение показателя //
index:
	ActualDate, GlobalUserID, LocalScoreID (unique mod);
	GlobalUserID, ActualDate, LocalScoreID (unique mod);
	UpdCounter, GlobalUserID, ActualDate, LocalScoreID (unique mod);
file:
	"bizsglob.btr";
	vlr;
}

table BizScore2 { // @v11.9.1 @construction
	autolong ID;          // @id
	int16  Kind;          // Вид записи. 0 - регулярное значение, 1 - планируемое значение
	uint16 Reserve2;      // @alignment
	long   ScoreID;       // ->Ref(PPOBJ_BIZSCORE2)
	long   ArID;          // ->Article.ID
	date   Dt;            //
	time   Tm;            //
	date   PlanPeriodFn;  // Для планируемого значения - конец периода планирования (началом периода планирования является Dt)
	long   Flags;
	long   AgentID;       // Участник показателя (тип объекта - PPOBJ_PERSON, вид персоналии определяется полем PPBizScore2::AgentPsnKindID)
	long   LinkObjID;     // ИД связанного объекта (тип объекта определяется полем PPBizScore2::LinkObjType)
	long   IntVal;
	double RealVal;
	raw    Reserve[64];
index:
	ID (unique);                       // #0
	Kind, Dt, Tm, ScoreID (dup mod);   // #1
	Kind, ScoreID, Dt, Tm (dup mod);   // #2
file:
	"bizsc2.btr";
}
//
//
//
table DebtStat {
	long   AccSheetID;
	long   ArID;
	date   Dt;
	time   Tm;
	long   Flags;          // PPDebtorStat::fXXX
	double DelayMean;      //
	double DelaySd;        //
	double DelayTestGamma; //
	double DelayTestChSq;  //
	long   PaymPeriod;     // Период платежей (в днях, начиная с первого платежа до последнего платежа включительно)
	double PaymDensity;    // Плотность платежей (сумма / день)
	string Rating[12];     // Рассчитанный на основе статистики рейтинг дебитора
	double CreditLimit;    // Расчетный предельный кредит для клиента // @v10.9.1 Limit-->CreditLimit
	double DebtCost;       // Расчетная стоимость кредита (на одну денежную еденицу исходя из конфигурационной ставки стоимости денег)
	double ExpiryMean;     // Средняя просроченность платежей (в днях)
	double SigmFactor;     // Сигмоидальный коэффициент поправки к плотности платежей
	int16  LimitTerm;      // Срок (в днях) не который рассчитан кредитный лимит
	int16  Pad;            // @alignment
	long   RelArID;        // ->Article.ID Статья, связанная с ArID ОБРАТНЫМ персональным отношением HOLDING
		// (то есть, ArID - дочернее предприятие, RelArID - холдинг).
	raw    Reserve[24];    // @reserve
index:
	Dt, AccSheetID, ArID (unique mod);
	Dt, AccSheetID, RelArID, ArID (unique mod);
file:
	"dstat.btr";
}
//
// Журнал чековых операций
//
table CheckOpJrnl {         // size=44 // @v7.9.9 [36]-->[44]
	date   Dt;
	time   Tm;
	long   UserID;
	int16  Action;
	int16  PrinterID;
	long   CheckID;
	long   CheckNum;
	float  Summ;
	float  Price;
	long   GoodsID;
	long   AgentID;     // @v7.9.9 Агент, ассоциированный с кассовым чеком
	long   PosNodeID;   // @v7.9.9 Кассовый узел, с которым ассоциированн чек
index:
	Dt, Tm (unique);
file:
	"chkopj.btr";
	access=1;
}
//
// @todo DbUUID_s и SessUUID_s преобразовать в guid; DbName, UserName, MachineName перенести в UnxTextRef
//
table UserFuncPrfSess {
	autolong ID;            // @id
	string DbUUID_s[40];    // GUID базы данных
	string SessUUID_s[40];  // GUID сессии
	long   ThreadId;        // Ид потока
	date   Dt;              // Дата регистрации сессии
	time   Tm;              // Время регистрации сессии
	long   Ver;             // Версия системы, создавшей сессию
	long   Flags;           // @flags
	raw    MACAdr[8];       // MAC-адрес компьютера
	string DbName[48];      // Текстовое наименование базы данных (символ базы данных)
	string UserName[48];    // Текстовое наименование пользователя (локальное по отношению к DbUUID_s)
	string MachineName[48]; // Имя компьютера
	raw    Reserve[48];     // @reserve
index:
	ID (unique);                   // #0
	SessUUID_s, ThreadId (unique); // #1
	DbUUID_s, Dt, Tm (dup);        // #2
	Dt, Tm (dup);                  // #3
	//ThreadId, DbUUID_s, Ver, SessUUID_s (unique); // @v8.1.7
file:
	"ufpsess.btr";
	compress;
	acstable = "rusncase.alt";
}
//
//
//
table UserFuncPrf {
	long   SessID;
	int64  SeqID;
	long   FuncID;
	date   Dt;
	time   Tm;
	int64  Clock;
	long   Flags;
	double Factor1;
	double Factor2;
	double Factor3;
	int64  ElemCount;
	double QuadSum1;
	double QuadSum2;
	double QuadSum3;
	double QuadClockSum;
	raw    Reserve[8];
index:
	SessID, SeqID (unique);
	Dt, Tm, SessID, SeqID (unique);
	FuncID, Dt, Tm, SessID, SeqID (unique);
file:
	"ufp.btr";
	acstable = "rusncase.alt";
}
//
// @v10.8.9 События. Специальные объекты, информирующие о тех или иных ситуациях.
// Текстовое содержание извещения хранится в таблице UnxTextRef
//
table Event {
	autolong ID;
	date   Dt;
	time   Tm;
	long   EventType;
	long   Status;
	long   UserID;         // 0 - for all
	long   GlobalUserID;   // 0 - for all
	long   ObjType;        // Тип связанного с событием объекта
	long   ObjID;          // Ид связанного с событием объекта
	long   Flags;          // @flags
	long   EvSubscrID;     // -Ref(PPOBJ_EVENTSUBSCRIPTION) Ид подписки на события, в соответствии с которой была сформирована запись
	raw    Reserve[28];
	blob   VT[2048];
index:
	ID (unique);
	Dt, Tm (unique mod);
	EventType, Dt, Tm (unique mod);
	UserID, Dt, Tm (unique mod);
	GlobalUserID, Dt, Tm (unique mod);
	ObjType, Dt, Tm (unique mod);
file:
	"event.btr";
	vlr;
}
//
// @v11.0.7
//
table StyloQSec {
	autolong ID;
	long   Kind;             // 1 - native service (only record), 2 - foreign service, 3 - client, 4 - session, 5 - face
		// 6 - kDocIncoming, 7 - kDocOutcominig, 8 - kCounter, 9 - kNotification_before90v
	long   CorrespondID;     // ->StyloQSec.ID (для сессии - клиент или сервис, для клиента или сервиса - текущая сессия, для документа - эмитент (client || foreign_service))
	raw    BI[20];           // Уникальный идентификатор стороны обмена, относительно данной инсталляции.
		// Для сессии (4) - sha1(публичный идентификатор сессии контрагента). При этом CorrespondID указывает на запись контрагента.
	datetime Expiration;     // (epoch time) Время истечения срока действия сессии. (for oneof3(Kind, 4, 6, 7))
	long   LinkObjType;      // Тип связанного объекта
	long   LinkObjID;        // ИД связанного объекта
	long   DocType;          // Тип документа (for oneof2(Kind, 6, 7))
	int64  TimeStamp;        // Временная метка записи.
		// Для записей типа 1, 2, 3 значение равно 0 для обеспечения уникальности индекса {Kind, BI, TimeStamp}
	long   Flags;            // @v11.2.7 StyloQCore::fXXX
	int64  Counter;          // @v11.2.10 Для записей вида kCounter
	raw    Reserve[92];      // @reserve @v11.2.7 [104]-->[100] // @v11.2.10 [100]-->[92]
	blob   VT[2048];
index:
	ID (unique);                                // #0
	Kind, BI, TimeStamp (unique);               // #1
	CorrespondID, BI (anysegnull unique mod);   // #2
	DocType, BI, TimeStamp (anysegnull unique); // #3

	//ID (unique);                                // #0
	//BI (unique);                                // #1
	//Kind, BI (unique);                          // #2
	//CorrespondID, BI (unique mod);              // #3
	//DocType, BI, TimeStamp (anysegnull unique); // #4
file:
	"styloqsec.btr";
	vlr;
}
//
// @construction
//
table StyloQSettlement {
	// хэш строится по следующим полям {Uid, OtherBI, Amt, Tmstmp}
	raw    Uid[16];
	raw    OtherBI[20];
	int64  Amt;
	int64  Rst;
	int64  Tmstmp;
	raw    Hsh[20];
	raw    BckHsh[20];
	raw    Reserve[128];
	blob   VT[2048];
index:
	Uid (unique);
	Tmstmp (unique);
	OtherBI, Tmstmp (unique); // blockchain is calculated by this index!
file:
	"styloqsettlement.btr";
	vlr;
}
//
// @v10.7.7 @construction
//
table TsTaJournal {
	autolong ID;
	date   NotifyDt;      // Дата регистрации извещения
	time   NotifyTm;      // Время регистрации извещения
	uint32 Deal;          // Тикет сделки
	uint32 Ord;           // Тикет ордера // @v10.9.1 Order-->Ord
	long   TsID;          // Ид инструмента
	char   Symb[32];      // Символ инструмента
	long   TaType;        // Информация о типе транзакции содержится в поле type переменной trans.
	long   OrdType;       // Тип ордера
	long   OrdState;      // Состояние ордера
	long   DealType;      // Тип сделки
	long   OrdTypeTime;   // Тип ордера по времени действия
	datetime Expiration;  // Срок истечения ордера
	double Price;         // Цена
	double PriceTrigger;  // Цена срабатывания стоп-лимитного ордера
	double PriceSL;       // Уровень Stop Loss
	double PriceTP;       // Уровень Take Profit
	double Volume;        // Объем в лотах
	uint32 Position;      // Тикет позиции
	uint32 PositionBy;    // Тикет встречной позиции
	blob   VT[2048];
index:
	ID (unique);                          // #0
	NotifyDt, NotifyTm (dup mod);         // #1
	TsID, NotifyDt, NotifyTm (dup mod);   // #2
	Symb, NotifyDt, NotifyTm (dup mod);   // #3
	TaType, NotifyDt, NotifyTm (dup mod); // #4
file:
	"tstajrnl.btr";
	vlr;
}
//
// Справочники before v5.8.10
//
table Reference_Obsolete { // size=88 // @v12.2.10 Reference_-->Reference_Obsolete
	long   ObjType;        // Тип объекта
	long   ObjID;          // Ид объекта
	string ObjName[48];    // Наименование объекта
	string AltText[20];    // Альтернативный текст
	long   Flags;          // Флаги объекта
	long   Val1;           // Дополнительные данные
	long   Val2;           // Дополнительные данные
index:
	ObjType, ObjID (unique);
	ObjType, ObjName acs (dup mod);
	ObjType, Val1 (dup mod);
	ObjType, Val2 (dup mod);
file:
	"ref.btr";
	acstable = "rusncase.alt";
	balanced;
	access=3;
}
//
// Государство
// @obsolete (moved to table World)
//
table Country_Obsolete { // @v12.2.10 Country-->Country_Obsolete
	autolong ID;        // Ид
	string Name[30];    // Название
	string Abbr[10];    // Сокращенное название
	long   Capital;     // ?? Столица ->City.ID
	string Phone[10];   // Телефонный код
	int16  HasRegions;  // Признак деления на регионы
	raw    Reserve[16];
index:
	ID (unique);
	Name acs (unique mod);
	Abbr acs (dup mod);
file:
	"country.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Регион
// @obsolete (moved to table World)
//
// Пока структура регионов одноуровневая на усмотрение пользователя.
// Следовательно, государство должно однозначно делиться на вводимые регионы.
// Потом будем думать, как улучшить структуру.
//
table Region_Obsolete { // @v12.2.10 Region-->Region_Obsolete
	autolong ID;        // Ид
	long   Country;     // Государство          ->Country.ID
	string Name[30];    // Название
	string Abbr[10];    // Сокращенное название
	long   Capital;     // ?? Столица           ->City.ID
	string Phone[10];   // Телефонный код
index:
	ID (unique);
	Country, Name acs (unique mod);
	Name acs (unique mod);
	Abbr acs (dup mod);
file:
	"region.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Населенный пункт
// @obsolete (moved to table World)
//
table City_Obsolete {   // @v12.2.10 City-->City_Obsolete
	autolong ID;        // Ид
	long   Country;     // Государство ->Country.ID
	long   Region;      // Регион      ->Region.ID
	string Name[30];    // Название
	string Abbr[10];    // Сокращение
	long   Status;      // Статус      ->Ref(PPOBJ_CITYSTATUS)
	string Phone[10];   // Телефонный код
index:
	ID (unique);
	Region, Name acs (unique mod);
	Country, Name acs (unique mod);
	Name acs, Region (unique mod);
	Abbr acs, Region (dup mod);
file:
	"city.btr";
	acstable = "rusncase.alt";
	balanced;
}
//
// Банковские счета
// @2.2.4: Для банков обязательный корр. счет в учреждениях центрального
// банка прописывается в этой таблице с полем BankID == 0 и AccType == PPBAC_NOSTRO
// @obsolete (moved to table Register)
//
table BankAccount_Pre9004 { //
	autolong ID;           // Ид счета
	long   PersonID;       // Владелец счета ->Person.ID
	long   BankID;         // Банк           ->Person.ID
	long   AccType;        // Тип счета      ->Ref(PPOBJ_BNKACCTYPE)
	string Acct[32];       // Счет // since @v2.0.0 [24] // @v5.8.10 [24]-->[32]
	date   OpenDate;       // Дата открытия //
	long   Flags;          // Флаги
	long   CorrAcc;        // Корреспондирующий балансовый счет
	long   CorrArt;        // Корреспондирующая статья //
index:
	ID (unique);
	PersonID, BankID, Acct (unique mod);
file:
	"bnkacct.btr";
	balanced;
	access=1;
}
//
// @obsolete (moved to table Reference)
//
table StaffList_Pre9003 {  //
	autolong ID;           // @id
	long   OrgID;          // ->Person.ID Работодатель
	long   DivisionID;     // ->Location.ID (LOCTYP_DIVISION)
	string Name[48];
	long   Rank;
	long   Flags;
	int16  VacancyCount;   // Общее количество ставок
	int16  VacancyBusy;    // Занятое количество вакансий
	money  Salary[8];      // @unused
	long   FixedStaff;     // Зарезервированный ИД должности (PPFIXSTF_XXX)
	long   ChargeGrpID;    // ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
	raw    Reserve[24];    // @reserve
index:
	ID (unique);
	OrgID, DivisionID, Name acs (unique mod);
	OrgID, DivisionID, Rank, Name acs (unique mod);
file:
	"staffl.btr";
	acstable = "rusncase.alt";
	balanced;
	access=1;
}
//
// История товаров
//
table HistGoods { // @obsolete
	autolong ID;
	long   GoodsID;
	long   Ver;
	long   Sz;             // @v5.8.11 Size-->Sz
	blob   Data[2048];     // @v6.1.6 // @v6.2.2 [1024]-->[2048]
index:
	ID (unique);
	GoodsID, Ver (unique);
file:
	"xgoods.btr";
	vlr;
	acstable = "rusncase.alt";
}
//
// История изменения документов
//
table HistBill { // @obsolete
	autolong ID;
	long   InnerID;
	long   BillID;
	long   Ver;
	string Code[24];    // Код документа
	date   Dt;          // Дата документа
	long   OpID;        // Вид операции          ->Ref(PPOBJ_OPRKIND)
	long   LocID;       // Позиция               ->Location.ID
	long   Object;      // Контрагент            ->Article.ID
	long   Object2;     // Дополнительный объект ->Article.ID
	long   CurID;       // Валюта (0 - базовая)  ->Ref(PPOBJ_CURRENCY)
	double CRate;       // Курс валюты для пересчета в базовую валюту
	double Amount;      // Номинальная сумма (в единицах CurID)
	long   LinkBillID;  // Связанный документ    ->Bill.ID
	long   Flags;       // Флаги
	long   SCardID;     // ->SCard.ID
	// BillExt
	long   PayerID;     // ->Article.ID Плательщик
	long   AgentID;     // ->Article.ID Агент
	raw    Reserve[16]; // @reserve
index:
	ID (unique);
	BillID, InnerID, Ver (unique);
file:
	"xbill.btr";
}

table HistTrfr { // @obsolete
	long   HistBillID; // ->HistBill.ID
	long   OprNo;      // >> Transfer.OprNo
	long   GoodsID;    // ->Goods2.ID
	double Quantity;
	double Cost;
	double Price;
	double Discount;
	long   QCertID;
	date   Expiry;
	long   Flags;
index:
	HistBillID, OprNo (unique mod);
file:
	"xtrfr.btr";
	page=4096;  // @v7.8.3 При автоматически определяемом размере страницы может не хватить предела для размера файла.
}
//
// @v4.8.3 @obsolete
// Текущие цены на товары по асинхронным кассовым узлам.
// Вспомогательная таблица.
//
table CCurPrice {
	long   CashID;      // Кассовый узел ->Ref(PPOBJ_CASHNODE)
	long   GoodsID;     // Товар         ->Goods.ID
	money  Price;       // Цена на текущий момент
index:
	CashID, GoodsID (unique);
file:
	"ccurpric.btr";
	balanced;
}
//
// @obsolete
// @todo 09/08/2005 {
//     1. Поле MainOrgID - организация, к которой относится счет
//     2. В индексы #1, #2 добавить лидирующий сегмент MainOrgID
// }
//
table Account_Pre9004 {    // size=144
	autolong  ID;          // @id
	//
	// Ac number layout:
	// 1..999       - Balance accounts    (Type = ACY_BAL)
	// 1000..1999   - Outbal accounts     (Type = ACY_OBAL)
	// 2000..9999   - Registers           (Type = ACY_REGISTER)
	// 10000..11999 - Aggregate accounts  (Type = ACY_AGGR)
	// 12000..13999 - Aliases of accounts (Type = ACY_ALIAS)
	//
	int16  Ac;             // Счет      <-
	int16  Sb;             // Субсчет   <-
	string Code[32];       // Код счета (символьное представление)
	long   CurID;          // ->Ref(PPOBJ_CURRENCY) Валюта
	string Name[48];       // Наименование счета
	long   AccSheetID;     // ->Ref(PPOBJ_ACCSHEET) Ассоциированная таблица аналитических статей
	date   OpenDate;       // Дата открытия счета
	int16  Type;           // 1 - Балансовый, 2 - Внебалансовый, 3 - Агрегирующий, 4 - Регистр, 5 - Бюджетный счет
	int16  Kind;           // Вид счета (1 - акт, 2 - пас, 3 - акт/пас)
	long   Flags;          // Флаги счета (ACF_XXX)
	double SaldoLimit;     // Макс. остаток в сторону активности (0 - не лимитирован) // @v10.9.1 Limit-->SaldoLimit
	double Overdraft;      // Макс. остаток при переходе через ноль
		// (0 - нельзя менять знак, для акт-пасс - не ограниченно)
	date   FRRL_Date;      // @v3.0.11 Начальная дата блокировки пересчета форвардных остатков
	long   ParentID;       // Родительский счет. Только для бюджетных счетов.D:\Papyrus\Src\Rsrc\dl600\ppdbs.dl6
	raw    Reserve[12];    // @reserve
index:
	ID (unique);
	Ac, Sb, CurID (unique mod);
	Code acs, Ac, Sb, CurID (unique mod);
file:
	"account.btr";
	acstable = "rusncase.alt";
	balanced;
	access=1;
}
//
// Временная таблица производственного отчета по техн сессии
//
table TempTSessRep {
	autolong ID__;
	long   DtVal;          //
	long   PrcID;          // Процессор (может также ссылаться на аналитическую статью)
	long   PrmrGoodsID;    // @v4.9.10
	int16  NotPrmrLine;    // @v5.0.12 (GoodsID == PrmrGoodsID) ? 0 : 1
	int16  PlanPhUnit;     // @v5.2.0  План и факт представлены в физических единицах
	long   GoodsID;
	string PrmrGoodsName[64];
	string GoodsName[64];
	string PrcName[48];    // @v5.1.9
	string DtText[48];     // @v5.1.9
	double InQtty;
	double OutQtty;
	double PlanInQtty;
	double PlanOutQtty;
	double PlanDev;
	double OutRest;
	double InCompPart;     // @v5.3.5 Часть компонента в общей сумме входа  (в физ единицах)
	double OutCompPart;    // @v5.3.5 Часть компонента в общей сумме выхода (в физ единицах)
index:
	ID__ (unique);
	DtVal, PrcID, PrmrGoodsID, NotPrmrLine, GoodsID (unique mod);
	DtVal, PrmrGoodsID, NotPrmrLine, GoodsID, PrcID (unique mod);
	DtVal, PrcID, PrmrGoodsName, NotPrmrLine, GoodsName (dup mod);
file:
	"tmp_tsrp.btr";
	temporary;
}
//
//
//
table TempPrcBusy {
	autolong ID__;
	long   PrcID;    // ->Processor.ID
	date   StDt;
	time   StTm;
	date   FnDt;
	time   FnTm;
	long   Duration; // Продолжительность периода
	long   TSessID;  // ->TSession.ID
	string TxtPeriod[48];
	string TxtDuration[16];
index:
	ID__ (unique);
	PrcID, StDt, StTm (dup mod);
	StDt, StTm, FnDt, FnTm (dup mod);
file:
	"tmp_prcb.btr";
	temporary;
	access=1;
}
//
//
//
table TempPredictSales {   // Size=72
	date   Dt;
	double Qtty;           // Продажи по количеству
	double Amt;            // Продажи по сумме
	double QttyPredict;    // Прогноз по количеству
	double QttyAbsErr;     // Абсолютная ошибка прогноза по количеству
	double QttyPctErr;     // Относительная ошибка прогноза по количеству
	double AmtPredict;     // Прогноз по сумме
	double AmtAbsErr;      // Абсолютная ошибка прогноза по сумме
	double AmtPctErr;      // Относительная ошибка прогноза по сумме
	long   Flags;          // @flags @v5.9.12
index:
	Dt (unique mod);
file:
	"tmp_psls.btr";
	temporary;
}
//
//
//
table TempGoodsStat {
	long   GoodsID;
	date   Dt;             // @v4.5.12 Если отчет строится по циклам, то Dt - начало цикла, иначе - 0
	string GoodsName[128]; // @v4.5.12 // @v8.6.8 [64]-->[128]
	date   Beg;            // Дата первого значения продаж
	date   End;            // Дата последнего значения продаж
	long   Count;          // Общее количество значений
	double QttyAvg;        // Cреднее по количеству
	double QttySigma;      // Среднеквадратическое отклонение по количеству
	double QttyVar;        // Коэффициент вариации по количеству (QttySigma / QttyAvg)
	double QttyTrnovr;     // Оборачиваемость товара по количеству, дней (1 / QttyAvg)
	double AmtAvg;         // Среднее по сумме
	double AmtSigma;       // Среднеквадратическое отклонение по сумме
	double AmtVar;         // Коэффициент вариации по сумме (AmtSigma / AmtAvg)
	double AmtTrnovr;      // Оборачиваемость товара по сумме, дней (1 / AmtAvg)
	double PriceAvg;       // Среднее по цене (AmtAvg / QttyAvg)
	double MinStock;       // @v6.2.4 Reserve-->MinStock
index:
	GoodsID, Dt (unique);
	GoodsName acs, Dt (dup mod);
file:
	"tmp_gst.btr";
	temporary;
	compress;
	acstable = "rusncase.alt";
}
//
// Временная таблица остатков товаров (PPViewGoodsRest)
// Используется также как временная таблица при просмотре
// излишков по кассовым сессиям (PPViewCSessExc)
//
table TempGoodsRest {
	autolong ID__;
	long   GoodsID;
	long   GoodsGrp;        // Если таблица используется для отображения излишков
		//  по кассовым сессиям, то поле GoodsGrp хранит ИД альтернативного товара (CGoodsLine::AltGoodsID)
	string GoodsName[128];  // @v6.3.3 [64]-->[128]
	long   LocID;           // ->Location.ID
	long   LotID;           // @v8.1.1 ->Receipt.ID
	long   UnitID;          // ->Ref(PPOBJ_UNIT) Торговая единица измерения   //
	long   PhUnitID;        // ->Ref(PPOBJ_UNIT) Физическае единица измерения //
	double UnitPerPack;     // Емкость упаковки
	double Quantity;        // Остаток
	double Ord;             // Заказанное количество @v5.8.11 Order-->Ord
	double PhQtty;          // Количество в физических единицах
	double SStatSales;      // Среднедневные продажи из статистики продаж
	double Cost;            // Цена поступления //
	double Price;           // Цена реализации  //
	double SumCost;         // Сумма в ценах поступления //
	double SumPrice;        // Сумма в ценах реализации  //
	double SumCVat;         // @v8.3.4 Сумма НДС в ценах поступления //
	double SumPVat;         // @v8.3.4 Сумма НДС в ценах реализации //
	// @v9.8.2 float  PctAddedVal;     // Процент наценки
	// @v9.8.3 string BarCode[24];     // @v8.8.0 [16]-->[24]
	// @v9.8.3 string Serial[64];      // @v8.1.0 @v9.7.11 [24]-->[64] здесь теперь может храниться значение произвольного тега
	uint   BarcodeSP;
	uint   SerialSP;
	long   Predict;         //
	long   RestInDays;      // Остаток в днях (по средним продажам по всей выборке)
	double MinStock;        // Минимальный допустимый остаток
	double SupplOrder;      // Количество, которое следует заказать поставщику
	double Deficit;         // Дефицит
	double QttyWithDeficit; // Остаток с учетом дефицита
	double DraftRcpt;       // @v5.4.2  Будущие поступления товара
	long   SubstAsscCount;  // Количество товаров ассоциированных с данным идентификатором подстановки
	date   Expiry;          // @v9.7.11 Дата истечения срока годности
	date   LastSellDate;    // @v8.7.3 Дата последней продажи
	int16  IsPredictTrust;  // Признак того, что значение Predict удовлетворяет критерию надежности.
index:
	ID__ (unique);
	//
	// Так как иногда требуется выдавать остатки в разбивку по
	// лотам, то следующие два индекса пришлось сделать дублируемыми
	//
	GoodsName acs, LocID (dup mod);
	GoodsGrp, GoodsName acs, LocID (dup mod);
	GoodsID, LocID (dup mod);
file:
	"tmp_gdsr.btr";
	temporary;
	acstable = "rusncase.alt";
	compress; // @v8.1.0
}
//
//
//
table TempCSessExc {
	long   OrgGoodsID;     // Оригинальный ИД товара (на который ссылается чек)
	long   GoodsID;        // Если OrgGoodsID в таблице Goods2 отсутствует, то
	// система пытается найти товар, который заменил OrgGoodsID в результате
	// объединения товаров. Если такой товар найден, то GoodsID получает его ИД.
	long   UnitID;         // Единица измерения товара GoodsID
	long   AltGoodsID;     // ИД товара, подставленного вместо OrgGoodsID для списания сессии
	string GoodsName[64];  // Наименование товара GoodsID
	int16  Sign;           // @v4.9.15 Знак позиции
	int16  Pad;            // @v5.4.8  @alignment
	double Qtty;           // Проданное количество
	double Rest;           // Несписанное количество
	double Price;          // Цена продажи товара OrgGoodsID          =Sum/Qtty
	double Sum;            // Сумма реализации товара OrgGoodsID
	double RestSum;        // Сумма несписанного количества           =Rest*Sum/Qtty
	double AltGoodsQtty;   // Количество списанного альтернативного товара вместо OrgGoodsID
	double AltGoodsPrice;  // Цена списанного альтернативного товара
	double AltGoodsSum;    // Сумма списанного альтернативного товара =AltGoodsPrice*AltGoodsQtty
	double AltDiff;        // Результат от подстановки альтернативного товара AltGoodsSum-Price*AltGoodsQtty
index:
	Sign, GoodsID (dup mod);
	Sign, GoodsName acs (dup mod);
	Rest (dup mod);
	RestSum (dup mod);
file:
	"tmp_csx.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempDeficit {        // size=96
	long   Location;
	long   GoodsID;
	long   SupplID;
	int    HasDeficit;
	double Rest;
	double Req;
	double ReqCost;
	double ReqPrice;
	double UnitPerPack;
	double ReqSalesTax;
	string Clb[32];
index:
	Location, GoodsID, SupplID (unique);
	Location, SupplID, GoodsID (unique);
file:
	"tmp_dfct.btr";
	temporary;
}
//
//
//
table TempShipmentAnlz {
	long   BillID;
	date   Dt;
	long   GoodsID;
	string GoodsName[128];  // @v7.3.3 [64]-->[128]
	double OrderQtty;
	double OrderAmount;
	double ShipmentQtty;
	double ShipmentAmount;
	double AckQtty;
	double AckAmount;
	long   Reserve;        // @reserve
index:
	BillID, GoodsID (unique mod);
	BillID, GoodsName acs (unique mod);
	Dt, BillID, GoodsName acs (unique mod);
file:
	"tmp_shalz.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempGoodsOpr { //
	autolong ID__;
	long   LocID;          // 0 - в сумме по всем складам @v4.9.11 Location-->LocID
	int16  InOutTag;       // -1 - in, 1 - out, 0 - undef; For ABC-analyze - belonging to group
	int16  Reserve;        // @reserve
	long   GoodsID;        // Если отчет строится с группировкой по атрибутам документов, то это поле - идентификатор ведущего элемента группировки.
	long   GoodsGrp;       //
	long   Object;         //
	string Text[128];      //
	double UnitPerPack;    //
	double Quantity;       //
	double PhQtty;         //
	double OldCost;        // Старая цена поступления (переоценка),
		// для отчета с отклонениями: отклонения + от базовой цены реализации
		// для сравнения с планом продаж: план в торговых единицах
		// для типового отчета: текущий открытый заказ (GoodsOpAnalyzeFilt::fCalcOrder)
	double OldPrice;       // Старая цена реализации (переоценка),
		// для отчета с отклонениями: отклонения - от базовой цены реализации
		// для сравнения с планом продаж: суммовой план
		// для типового отчета: среднедневные продажи из статистики продаж (GoodsOpAnalyzeFilt::fShowSStatSales)
	double Cost;           //
	double Price;          //
	double SumCost;        // Quantity * Cost
	double SumPrice;       // Quantity * Price
	double Income;         //
	double SumCVat;        // Валовая сумма НДС в ценах поступления
	double SumPVat;        // Валовая сумма НДС в ценах реализации
	double PctVal;         // Процентное отношение заданной величины к общей сумме
	double Rest;           // Остаток
	double PhRest;         // Остаток в физических единицах
	double RestCostSum;    // Остаток в ценах поступления //
	double RestPriceSum;   // Остаток в ценах реализации  //
	string Barcode[24];    // Штрихкод
index:
	ID__ (unique);
	InOutTag, Text acs, Object, LocID (dup mod);
	InOutTag, GoodsGrp, Text acs, Object, LocID (dup mod);
	InOutTag, GoodsID, Object, LocID (dup mod);
file:
	"tmp_gdso.btr";
	temporary;
	acstable = "rusncase.alt";
	compress; // @v8.3.5
	balanced;
}
//
// Временная таблица для отчетности по движению товаров
//
table TempGoodsMov {
	long   Grp;
	long   GoodsID;
	string GoodsName[128]; // @v4.4.5 [48]->[64] // @v6.2.4 [64]-->[128]
	string Barcode[14];    // @v6.4.11
	double PhUPerU;

	double InRest_Qtty;
	double InRest_Cost;
	double InRest_Price;

	double Rcpt_Qtty;
	double Rcpt_Cost;
	double Rcpt_Price;

	double ARcpt_Qtty;     // @v5.8.11 _Rcpt_Qtty-->ARcpt_Qtty
	double ARcpt_Cost;     // @v5.8.11 _Rcpt_Cost-->ARcpt_Cost
	double ARcpt_Price;    // @v5.8.11 _Rcpt_Price-->ARcpt_Price

	double Rlz_Qtty;
	double Rlz_Cost;
	double Rlz_Price;

	double SRlz_Qtty;
	double SRlz_Cost;
	double SRlz_Price;

	double Expnd_Qtty;
	double Expnd_Cost;
	double Expnd_Price;

	double TRcpt_Qtty;
	double TRcpt_Cost;
	double TRcpt_Price;

	double TExpnd_Qtty;
	double TExpnd_Cost;
	double TExpnd_Price;

	double OutRest_Qtty;
	double OutRest_Cost;
	double OutRest_Price;
index:
	Grp, GoodsName acs (dup); // @v6.2.4 unique-->dup
	GoodsName acs (dup);
file:
	"tmp_gmov.btr";
	temporary;
	acstable = "rusncase.alt";
	balanced;
}

table TempGoodsMov2 {
	autolong  ID__;
	long   GoodsID;
	long   OpID;     // @ct
	string GoodsName[128];  // @v8.8.0 [64]-->[128]
	string Barcode[24];     // @v8.8.0 [16]-->[24]
	double Qtty;
	double Cost;
	double Price;
	double Discount;
	double Amount;
index:
	ID__ (unique);
	GoodsName (dup);
file:
	"tmp_gm2.btr";
	temporary;
	acstable = "rusncase.alt";
	balanced;
}
//
//
//
table TempGoodsBillCmp { // Size=136
	long   GoodsID;
	string GoodsName[64]; // @v4.4.5 [48]->[64]
	string Barcode[24];   // @v8.8.0 [16]-->[24]
	double LhQtty;
	double RhQtty;
	double DiffQtty;
	double LhPrice;
	double RhPrice;
	double DiffPrice;
	int16  IsDiffQtty;    // Вспомогательное поле. Принимает значение !0, если DiffQtty != 0
	int16  IsDiffPrice;   // Вспомогательное поле. Принимает значение !0, если DiffPrice != 0
index:
	GoodsID (unique mod);
	GoodsName (dup mod);
	DiffQtty (dup mod);
	DiffPrice (dup mod);
file:
	"tmp_lcmp.btr";
	temporary;
}
//
//  Временная таблица для оборотной ведомости по аналитическим статьям
//
table TempAccTrnovr {
	date   Dt;             // Для циклических отчетов
	long   AccRelID;
	int16  Ac;
	int16  Sb;
	long   Ar;
	long   CurID;
	long   RelPersonID;
	string Name[128];      // @v7.1.2 [48]-->[128]
	long   Count;
	double InRest;
	double Dbt;
	double Crd;
	double OutRest;
	double GoodsRest;      // Остаток товаров в ценах поступления (для оборотки по таблице поставщиков)
	long   DispFlags;      // Специальные флаги, используемые для отображения данных в таблице
index:
	Dt, Ac, Sb, Ar, CurID (unique mod);
	Dt, Name acs (dup mod);
file:
	"tmp_acto.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//  Временная таблица для долговой ведомости
//
table TempSellTrnovr {     // size=
	long   ID;             // Ведущий идентификатор отчета (зависит от параметров подстановки)
	long   Ar;             // Номер аналитической статьи
	long   CurID;          //
	long   PersonID;       //
	long   TabID;          //
	string Name[128];      // @v7.0.1 [80]-->[128]
	double Sell;           // Сумма отгрузки
	double Payment;        // Сумма оплаты
	double Debt;           // Долг по отгрузке (Sell-Payment)
	double ExpiryDebt;     // @v9.1.8 Просроченный долг по отгрузке (часть долга Debt,
		// срок оплаты по которому меньше верхней даты периода расчета или текущей системной даты)
	double RPaym;          // Сумма зачетных платежей
	double Reckon;         // Сумма зачитывающих оплат
	double RDebt;          // Долг по зачету (RPaym-Reckon)
	double TDebt;          // Общий долг (Debt-RDebt)
	double AvgPaym;        // Средняя оплата без учета нулевых значений @v5.8.11 _AvgPaym-->AvgPaym
	int16  NotStop;        // По статье признак "Стоп" снят
	int16  MaxDelay;       // Максимальная задержка платежа по документам
index:
	ID, CurID, TabID (unique mod);
	Name acs, CurID, TabID (dup mod);
	CurID, Sell (dup mod);
	CurID, Debt (dup mod);
	PersonID, CurID, TabID (dup mod);
	NotStop, Name acs, CurID, TabID (dup mod);
file:
	"tmp_slto.btr";
	temporary;
	acstable = "rusncase.alt";
	// @v7.0.1 balanced;
}

table TempTrfrGrpng { // Size=
	autolong  ID__;
	date   Dt;
	long   GoodsID;
	long   PersonID;
	long   ArticleID;
	//
	// При группировке по агенту поле BillID содержит ИД агента (->Article.ID)
	//
	long   BillID;         // ->Bill.ID
	long   DlvrLocID;      // Адрес доставки
	long   LocCount;       // Количество адресов доставки, попавших эту строку
	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
	double Discount;
	double Income;         // Доходность (Price-Cost) Если условия фильтра требуют процентное значение
		// то - (100 * (Price-Cost) / Cost)
	double SaldoQtty;
	double SaldoAmt;
	double PVat;           // @v6.4.2 Сумма НДС в ценах реализации
	double Brutto;         // @v8.7.7
	double LinkQtty;       // @v9.4.10 Количество в связанных докуменах (e.g. документах списания)
	double LinkCost;       // @v9.4.10 Сумма в ценах поступления в связанных докуменах (e.g. документах списания)
	double LinkPrice;      // @v9.4.10 Сумма в ценах реализации в связанных докуменах (e.g. документах списания)
	double ExtVal1;        // @v9.3.4
	string DtText[32];
	string GoodsText[128];  // @v6.4.1 [64]-->[128]
	string PersonText[224]; // @v6.4.1 [80]-->[224] При группировке по контрагенту и адресу доставки
		// это поле должно вместить конкатенацию имени контрагента и адреса доставки.
index:
	ID__ (unique);
	Dt, GoodsID, PersonID, BillID, DlvrLocID (unique);
file:
	"tmp_tag.btr";
	temporary;
}

table TempTrfrAnlz {       //
	autolong ID__;         //
	date   Dt;             //
	long   OprNo;          //
	long   BillID;         // ->Bill.ID
	string BillCode[48];   // @v11.1.12 [24]-->[48]
	long   LocID;          // ->Location.ID
	long   ArticleID;      // ->Article.ID
	long   OpID;           //
	long   LotID;          // Receipt.ID
	long   GoodsID;        // ->Goods2.ID
	long   DlvrLocID;      // ->Location.ID Адрес доставки
	long   LinkBillID;     // @v9.6.8 ->Bill.ID ИД связанного документа (e.g. документа списания)
	double Qtty;           //
	double PhQtty;         // Rest for GoodsCard
	double Cost;           //
	double Price;          //
	double Discount;       // Amt for GoodsCard
	double PVat;           // Сумма НДС в ценах реализации
	double Brutto;         // @v8.7.7
	double LinkQtty;       // @v9.4.10 Количество в связанных докуменах (e.g. документах списания)
	double LinkCost;       // @v9.4.10 Сумма в ценах поступления в связанных докуменах (e.g. документах списания)
	double LinkPrice;      // @v9.4.10 Сумма в ценах реализации в связанных докуменах (e.g. документах списания)
	double ExtVal1;        // @v9.3.4
index:
	ID__ (unique); // @v10.4.3
	Dt, OprNo (unique mod);
	GoodsID, Dt, OprNo (unique mod);
	ArticleID, Dt, OprNo (unique mod);
	// @v10.4.3 ID__ (unique);
file:
	"tmp_ta.btr";
	temporary;
}

table TempOpGrpng {
	autolong ID__;
	// @construction long   OrderI;         // @v8.6.3 Порядковый номер для сортировки
	date   Dt;
	long   ObjectID;
	long   OpID;
	string OpName[48];     // Наименование вида операции
	long   GoodsTaxGrpID;
	long   LotTaxGrpID;
	short  Sign;           //
	short  TotalSign;      // Знак операции, испольуемый для суммирования итогов отчета
	long   TaxFlags;       //
	long   Count;          //
	long   LnCount;        // Суммарное количество товарных строк  @v5.3.9 turistti
	long   AvgLn;          // Среднее количество строк в документах @v5.3.9
	double Qtty;
	double PhQtty;
	double Cost;
	double Price;
	double Discount;       //
	double Amount;
	double Income;
	double ExtCost;        // Сумма ЦП дополнительного типа товаров
	double ExtPrice;       // Сумма ЦР дополнительного типа товаров
	double VatSum;
	double ExciseSum;
	double STaxSum;
index:
	ID__ (unique);
	Dt, OpID, Sign, GoodsTaxGrpID, LotTaxGrpID, TaxFlags (unique);
	// @construction OrderI (unique mod); // @v8.6.3
file:
	"tmp_gopg.btr";
	temporary;
}

table TempPerson {
	long   ID;
	long   TabID;          // для построения кросстаба с тегами
	string Name[128];      //
	uint   PhoneP;         // Ссылка на строку телефона
	uint   EMailP;         // @v12.1.11 Ссылка на строку адреса электронной почты
	uint   AddressP;
	uint   RAddressP;
	uint   BnkNameP;
	uint   BnkAcctP;
	uint   RegSerialP;
	uint   FiasAddrGuidP;
	uint   FiasHouseGuidP;
	uint   AddrTypeP;      // @v12.1.11 Ссылка на строку наименования типа адреса (адрес доставки, юридически, реальный etc)
	string RegNumber[64];  // сюда же запихивается значение тега. PPPSNATTR_BNKACCT: Тип счета
	long   CityID;         // PPPSNATTR_DLVRADDR: Город в адресе
	date   RegInitDate;
	date   RegExpiry;
	long   Flags;          // @flags
index:
	ID, TabID (unique mod);
	Name acs (dup mod);
file:
	"tmp_psn.btr";
	compress;
	temporary;
	acstable = "rusncase.alt";
}

table TempOrder {
	long   ID;
	string Name[252];      // @v6.2.2 [64]-->[128] // @v8.1.1 [128]-->[252]
index:
	ID (unique mod);
	Name acs (dup mod);
file:
	"tmp_ord.btr";
	temporary;
	compress; // @v8.1.1
	acstable = "rusncase.alt";
}

table TempDoubleID {
	long   PrmrID;
	long   ScndID;
	string Name[128];      // @v6.2.2 [64]-->[128]
index:
	PrmrID, ScndID (unique mod);
	ScndID, PrmrID (unique mod);
	Name acs (dup mod);
file:
	"tmp_dbl.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
// @v4.5.12
// Временная ассоциация объектов
//
table TempAssoc {
	long   PrmrID;
	long   ScndID;
index:
	PrmrID, ScndID (unique mod);
file:
	"tmp_assc.btr";
	temporary;
}
//
// Временная таблица для группировки бух. проводок по счетам
//
table TempAccturnGrpng {
	date   Dt;
	long   DbtAccID; // (ACO_1 || ACO_2) ? (->Account.ID) : (->AcctRel.ID)
	int16  DbtAc;
	int16  DbtSb;    // if(ACO_2 || ACO_3) then 0
	int32  DbtAr;    // if(ACO_3) then 0
	long   CrdAccID; // (ACO_1 || ACO_2) ? (->Account.ID) : (->AcctRel.ID)
	int16  CrdAc;
	int16  CrdSb;    // if(ACO_2 || ACO_3) then 0
	int32  CrdAr;    // if(ACO_3) then 0
	long   CurID;
	long   Count;
	double Amount;
	string DbtAccName[48];
	string CrdAccName[48];
	raw    Reserve[8];
index:
	Dt, DbtAccID, CrdAccID, CurID (unique mod);
	Dt, DbtAc, DbtSb, DbtAr, CrdAc, CrdSb, CrdAr, CurID (unique mod);
	Dt, CrdAccID, DbtAccID, CurID (unique mod);
	Dt, CrdAc, CrdSb, CrdAr, DbtAc, DbtSb, DbtAr, CurID (unique mod);
file:
	"tmp_atg.btr";
	temporary;
}
//
// Временная таблица для анализа по счету
//
table TempAccAnlz {
	date   Dt;
	long   OprNo;
	long   BillID;
	int16  Reverse;
	int16  Pad;            // @alignment
	long   ThisAccRelID;   // @v6.2.3
	long   Acc;            // ->AcctRel.ID
	int16  Ac;
	int16  Sb;
	long   Ar;
	long   CurID;
	double Dbt;
	double Crd;
	double Rest;
	string OrdData[32];
index:
	OrdData, Dt, OprNo (unique);
	Dt, OprNo (unique); // @v6.6.3
file:
	"tmp_aanz.btr";
	temporary;
}
//
// Временная таблица для выборки документов
//
table TempBill {
	long   BillID;
	date   Dt;
	long   BillNo;
	long   OpID;
	long   Object;
	double Debit;    // Дебетовые обороты в долговой карточке
	double Credit;   // Кредитовые обороты в долговой карточке
	double Saldo;    // Сальдо в долговой карточке или долг по документу с учетом периода оплаты
	date   DueDate;  // Дата исполнени
	long   LicRegID; // @v8.4.4 Регистр торговой лицензии (сейчас - алкогольной)
index:
	//
	// Порядок и структура индексов совпадает с таблицей Bill
	//
	BillID (unique mod);
	Dt, BillNo (unique mod);
	OpID, Dt, BillNo (unique mod);
	Object, Dt, BillNo (unique mod);
file:
	"tmp_bill.btr";
	temporary;
}
//
// Временная таблица для выборки по фрахту
//
table TempFreight {
	long   BillID;        // ->Bill.ID
	date   BillDate;      // = Bill.ID.Dt
	long   ObjectID;      // = Bill.ID.Object
	long   LocID;         // @v4.4.14 = Bill.ID.Location
	double Amount;        // = Bill.ID.Amount
	double Brutto;        // Масса брутто
	double PackCount;     // Количество упаковок
	double Volume;        // Объем (m*m*m)
	date   ShipmDate;     // Дата отправления //
	date   ArrvlDate;     // Дата прибытия    //
	long   ShipID;        // ->Goods2.ID ИД транспортного средства
	long   PortID;        // ->World.ID Порт назначения    //
	long   DlvrAddrID;    // ->Location.ID ИД адреса доставки
	long   AgentID;       // @v6.9.2 ->Article.ID (ИД агента по документу)
	string Code[24];      // = Bill.ID.Code @v4.4.14 [10]->[24]
	string Shipped[2];    // Признак отгруженного документа ('X' | '\0')
	int16  Reserve;       // @alignment
	// @v9.8.4 string ShipName[48];  // Наименование транспортного средства
	uint   ShipNameP;     // @v9.8.4 Ссылка на наименование транспортного средства
	string PortName[48];  // Наименование порта назначения // @v6.9.2 [30]-->[48]
	string DlvrAddr[64];  // Наименование адреса доставки
	// @v9.8.4 note   Memo[512];     // @v6.9.7 Примечание к документу
	// @v11.1.12 uint   MemoP;       // @v9.8.4 Ссылка на примечание к документу
index:
	BillID (unique mod);
	BillDate, Code (dup mod);
	ArrvlDate, PortName (dup mod);
	PortName, ArrvlDate (dup mod);
	DlvrAddr, ArrvlDate (dup mod);
file:
	"tmp_frgh.btr";
	// @v9.8.4 vlr;
	temporary;
}
//
// Временная таблица для выборки лотов
//
table TempLot {
	long   LotID;
	date   Dt;
	date   OrgDt;          // Дата оригинального лота
	long   OrgID;          // @v10.1.0 ИД оригинального лота
	long   OprNo;          //
	long   GoodsID;        //
	long   SFlags;         // Дополнительные флаги лотов (не сопоставляются с ReceiptTbl::Rec::Flags)
	string GoodsName[128]; //
	double BegRest;        //
	double EndRest;        //
	double QttyPlus;       //
	double QttyMinus;      //
	string Serial[32];
	string BillStatus[48];
index:
	LotID (unique);
	Dt, OprNo (unique mod);
	GoodsName, Dt, OprNo (unique mod);
file:
	"tmp_lot.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
// Временная таблица для анализа налоговых выплат по товарам либо
// группам товаров
//
table TempGoodsTaxAnlz { // Size=264
	date   Dt;           // @v3.6.12 For cycling reports
	string BillNo[24];   // @v6.3.4
	long   LotID;        // @v6.3.4
	long   GoodsID;
	long   GoodsGrpID;
	long   GoodsTaxGrpID;
	long   LotTaxGrpID;
	long   TaxFlags;     // GGEF_VATFREE, GGEF_TOGGELSTAX
	string Name[128];    // @v6.6.2 [64]-->[128]
	string TaxStr[48];   // Обозначение схемы налогообложения //
	double Qtty;         // Оборот в торговых единицах
	double PhQtty;       // Оборот в физических единицах
	double TrnovrCost;   // Оборот в ценах поступления //
	double TrnovrPrice;  // Оборот в ценах реализации  //
	double Income;       // Доход
	double ExciseSum;    // Сумма акциза
	double C_VATSum;     // Сумма НДС в ценах поступления. Для отчета по приходам - величина НДС в цене поступления //
	double C_STaxSum;    // Сумма налога с продаж в ценах поступления. Для отчета по приходам - величина налога с продаж в цене поступления //
	double VATSum;       // Сумма НДС к уплате (с оборота)
	double IncVATSum;    // Сумма НДС к уплате (с дохода)
	double STaxSum;      // Сумма налога с продаж
	double ExpQtty;      // Для отчета по приходам - израсходованное количество
	double Rest;         // Для отчета по приходам - не израсходованный остаток в торговых единицах
index:
	Dt, GoodsID, GoodsTaxGrpID, LotTaxGrpID, TaxFlags (dup); // @v6.6.4 unique-->dup
	Dt, Name, GoodsTaxGrpID, LotTaxGrpID, TaxFlags (dup);
	Dt, GoodsGrpID, Name (dup);
file:
	"tmp_gtalz.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempPaymPlan {
	date   Dt;        // Дата принадлежности к циклу
	date   PayPlanDt; // Дата предполагаемого платежа
	long   BillID;
	long   ObjID;
	string Name[128]; // @v6.3.8 [48]-->[128]
	double Amount;
	double Interest;  // @v5.1.8 Процентные выплаты
	double Paym;
	double Debt;
index:
	Dt, ObjID, BillID (unique mod);
	Dt, Name acs (dup mod);
file:
	"tmp_ppln.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempSyncCmp {
	long   ObjType;      // Тип объекта
	int16  CommIdPfx;    // @v5.6.8 Префикс общего идентификатора
	long   CommID;       // База общего идентификатора
	int16  Reserve2;     // @v5.6.8 @alignment
	long   SrcID;        // Ид объектв в "чужом" разделе
	long   DestID;       // Ид объека в "своем" разделе
	string SrcName[64];  // @v5.6.5 [48]-->[64]
	string DestName[64]; // @v5.6.5 [48]-->[64]
	int16  ErrCode;      // Код ошибки
	int16  Reserve;      // @v5.6.5 @alignment
	date   SrcModDt;     // Дата модификации  объекта в чужом разделе
	time   SrcModTm;     // Время модификации объекта в чужом разделе
	date   DestModDt;    // Дата модификации  объекта в своем разделе
	time   DestModTm;    // Время модификации объекта в своем разделе
	double CmpScore;     // Коэффициент совпадения SrcName и DestName [0.0..1.0] (1.0 - полное совпадение)
index:
	ObjType, CommIdPfx, CommID (unique mod);
	ObjType, SrcID (unique mod);
	ObjType, DestID (dup mod);
	ObjType, SrcName acs (dup mod);
	ObjType, DestName acs (dup mod);
	ObjType, ErrCode, CmpScore (dup mod);
file:
	"tmp_sync.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempAsset {
	long   LotID;          // ИД лота
	long   GoodsID;        // ИД товара
	long   GrpID;          // ИД группы
	string Name[64];       // Наименование
	string Serial[32];     // Серийный номер
	int16  WrOffTerm;      // Срок списания (месяцев)
	int16  Reserve;        // @reserve
	date   Dt;             // Дата поступлени
	date   ExplDt;         // Дата ввода в эксплуатацию
	double Cost;           // Балансовая стоимость
	double Price;          // Остаточная стоимость
	double Deprec;         // Сумма амортизации
	//
	// Следующие поля используются если требуется вывод изменений
	// балансовой, остаточной стоимости и амортизации за период.
	//
	double Cost2;          //
	double Price2;
	double Deprec2;

	double DiffCost;
	double DiffDeprec;
index:
	LotID (unique);
	GrpID, Name, Dt, LotID (unique mod);
	Name, Dt, LotID (unique mod);
file:
	"tmp_asst.btr";
	temporary;
	acstable = "rusncase.alt";
}

table TempQuotSerial {
	long   GoodsID;
	long   QuotKindID;
	long   LocID;
	long   ArticleID;
	date   Dt;
	time   Tm;
	long   ValF;
	double Val;
	string ValS[12];
index:
	Dt, Tm (dup);
file:
	"tmp_qs.btr";
	temporary;
}
//
//
//
table TempQuot {
	autolong ID__;          // @v8.1.1
	long   GoodsID;         // ->Goods2.ID
	long   LocID;           // ->Location.ID
	long   ArticleID;       // ->Article.ID
	int32  PeriodIdx;       //
	string GoodsName[128];  // =Goods2(GoodsID).Name @v4.4.5 [48]->[64] @v6.3.9 [64]-->[128]

	uint   QuotP1;
	uint   QuotP2;
	uint   QuotP3;
	uint   QuotP4;
	uint   QuotP5;
	uint   QuotP6;
	uint   QuotP7;
	uint   QuotP8;
	uint   QuotP9;
	uint   QuotP10;
	uint   QuotP11;
	uint   QuotP12;
	uint   QuotP13;
	uint   QuotP14;
	uint   QuotP15;
	uint   QuotP16;
	uint   QuotP17;
	uint   QuotP18;
	uint   QuotP19;
	uint   QuotP20;
	uint   QuotP21;
	uint   QuotP22;
	uint   QuotP23;
	uint   QuotP24;
	uint   QuotP25;
	uint   QuotP26;
	uint   QuotP27;
	uint   QuotP28;
	uint   QuotP29;
	uint   QuotP30;
	uint   QuotP31;
	uint   QuotP32;
index:
	ID__ (unique);
	GoodsID, ArticleID, LocID, PeriodIdx (unique mod);
	// @v8.3.5 GoodsName acs, ArticleID, LocID, PeriodIdx (unique mod);
file:
	"tmp_quot.btr";
	temporary;
	compress;
	acstable = "rusncase.alt";
}

table TempGoodsCargo {
	long   GoodsID;
	long   Brutto;
	long   Length;
	long   Width;
	long   Height;
	double MinStock;
	double Package;
	string StrucType[14];
index:
	GoodsID (unique mod);
file:
	"tmp_gcrg.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
/*
table TempGoodsObjAssc {
	long   GoodsID;
	long   ObjID;
	string GoodsName[64];
	string ObjName[48];
index:
	GoodsID, ObjID (unique mod);
	GoodsName acs (dup mod);
	ObjName   acs (dup mod);
file:
	"tmp_goa.btr";
	temporary;
	acstable = "rusncase.alt";
}
*/
//
//
//
/* @v9.9.3
table TempGoodsStruc { // Size=328
	long   GoodsID;
	long   StrucID;
	long   ItemID;
	string GoodsName[128];
	string ItemName[64];
	string Qtty[30];
	string Type[14];
index:
	GoodsID, StrucID, ItemID (unique mod);
	GoodsName acs (dup mod);
file:
	"tmp_gstr.btr";
	temporary;
	acstable = "rusncase.alt";
}
*/
//
//
//
table TempPrjTask {        //
	long   TabID;          //
	long   EmployerID;     // ->Person.ID
	long   ClientID;       // ->Person.ID
	date   StartDt;        // Дата начала работы
	string ClientName[128];   // @v6.2.2 [48]-->[128]
	string EmployerName[128]; // @v6.2.2 [48]-->[128]
	double TabParam;       // Кол-во невыполненных задач
	double TaskCount;
index:
	TabID, StartDt    (dup mod);
	TabID, ClientID   (dup mod);
	TabID, EmployerID (dup mod);
file:
	"tmp_ptsk.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempPriceAnlz {      // size=148
	long   TabID;          // =Location
	long   SupplID;        // ->Article.ID
	long   GoodsID;        // ->Goods2.ID
	string GoodsName[64];  //
	string SupplName[48];  //
	double ContractCost;   //
	double Cost;           //
	double CostDiff;       //
index:
	TabID, SupplID, GoodsID (unique mod);
file:
	"tmp_palz.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
// Персональные события //
//
table TempPersonEvent {
	long   ID;
	long   ID2;
	date   Dt;           // Дата
	string DtSubst[32];  // Подстановка даты
	string Name[128];    // Подстановка наименования // @v6.2.2 [48]-->[128]
	long   Count;
	long   AvgEvTime;
index:
	ID, ID2 (unique);
	Dt, ID, ID2 (unique mod);
file:
	"tmp_psne.btr";
	temporary;
}
//
//
//
table TempPersonRel {
	autolong ID;
	long   PrmrPersonID;
	long   ScndPersonID;
	long   RelTypeID;
	string RelName[48];
index:
	ID (unique);
	PrmrPersonID, ScndPersonID, RelTypeID (unique mod);
file:
	"tmp_prel.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
// Временная таблица соглашений с контрагентами
// Используется в PPViewArticle
//
table TempArAgt {
	long   ArID;
	date   Beg;
	date   Expiry;
	long   DefPayTerm;    // Период оплаты документов (дней)
	long   DefDlvrTerm;   // Период доставки товара (дней)
	long   DefAgentID;    // ->Article.ID
	long   DefQuotKindID; // ->Ref(PPOBJ_QUOTKIND)
	long   ExtObjectID;   // ->Ref(PPOBJ_ARTICLE) Дополнительный объект
	double Discount;
	double MaxDiscount;
	double MaxCredit;
	string Code[24];      // Номер соглашения // @v10.2.9 [12]-->[24]
	long   Flags;         // Флаги соглашения //
	double MaxCredit1;
	double MaxCredit2;
	double MaxCredit3;
	double MaxCredit4;
	double MaxCredit5;
	double MaxCredit6;
	// @v7.1.5 {
	double MaxCredit7;
	double MaxCredit8;
	double MaxCredit9;
	double MaxCredit10;
	double MaxCredit11;
	double MaxCredit12;
	double MaxCredit13;
	double MaxCredit14;
	double MaxCredit15;
	// } @v7.1.5
	long   StopFlags;
	note   Msg[128];      // Текст сообщения //
index:
	ArID (unique);
file:
	"tmp_arag.btr";
	vlr;
	temporary;
}
//
// Временная таблица весов
// Используется в PPViewScale
//
table TempScale {
	long     ID;
	string   Name[48];
	string   Port[20];
	long     QuotKindID;
	long     ScaleTypeID;
	string   ScaleTypeName[30];
	long     ProtocolVer;
	long     LogNum;
	long     LocID;
	long     AltGoodsGrp;
index:
	ID (unique);
file:
	"tmp_scal.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempLogFileMon {
	autolong ID__;
	long   LogFileId;
	long   SubFile;
	long   LineNo;
	date   Dt;
	time   Tm;
	string UserName[32];
	string DbSymb[32];
	note   Text[252];
index:
//	__ID (unique);
	Dt, Tm(dup mod);
file:
	"tmp_lfm.btr";
	vlr;
	temporary;
}
//
//
//
table TempCashNode {
	long   ID;
	long   ParentID;
	string Name[48];
	string Symb[20];
	string ParentName[48];
	long   CashTypeID;
	string CashTypeName[32];
	string Port[24];
	long   LocID;
	long   Flags;           // флаги CASHF_XXX
index:
	ID (unique);
	ParentName, Name (dup mod);
	Name (dup mod);
file:
	"tmp_cshn.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempReport {
	autolong ID;
	long   StrucID;
	long   Type;
	long   Flags;
	date   ModifDt;
	string StdName[64];
	string StrucName[64];
	string Descr[64];
	string Path[255];
	string Format[32];
index:
	ID (unique);
	StdName   (dup mod);
	StrucName (dup mod);
	Type      (dup mod);
file:
	"tmp_rpt.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempPalm {
	long   ID;
	string Name[48];
	string Symb[20];
	long   LocID;
	long   GoodsGrpID;
	long   OrderOpID;
	long   FTPAcctID;
	long   Flags;
	long   GroupID;
	string GroupName[32];
	long   AgentID;
	string Path[255];
	string FtpPath[255];
index:
	ID   (unique);
	Name (dup mod);
file:
	"tmp_palm.btr";
	temporary;
	acstable = "rusncase.alt";
}

table TempLongOrder {
	long   ID;
	string Name[192];
index:
	ID (unique mod);
file:
	"tmp_lord.btr";
	temporary;
	acstable = "rusncase.alt";
}

table TempTransport {
	long ID;
	string Name[64];
	long   TrType;
	long   ModelID;
	long   OwnerID;
	long   CaptainID;
	long   CountryID;
	double Capacity;       // @v7.2.8
	string Code[16];
	string TrailCode[16];
	string ModelName[48];  // @v8.2.11 [32]-->[48]
index:
	ID   (unique mod);
	Name (dup mod);
file:
	"tmp_tran.btr";
	temporary;
	acstable = "rusncase.alt";
}

table TempBudget {
	int32  ID;
	int32  ParentID;
	string   Code[20];
	string   Name[48];
	date  LowDt;
	date  UppDt;
index:
	ID (unique mod);
file:
	"tmp_budg.btr";
	temporary;
	acstable = "rusncase.alt";
}

table TempBudgItem {
	long   ID;
	long   BudgetID;
	long   Acc;
	long   Flags;
	long   Kind;
	date   Dt;
	string AccText[48];
	string DtText[32];
	double PlanAmt;
	double FactAmt;
	note   Memo[512];
index:
	ID (unique mod);                      // #0
	BudgetID, Acc, Kind, Dt (unique mod); // #1
file:
	"tmp_budi.btr";
	temporary;
	vlr;
	balanced;
	access=1;
}

table TempBizScTempl {
	int32    ID;             // @id
	string   Name[48];       // @name
	string   Symb[20];       //
	int32    Flags;          //
index:
	ID (unique mod);
file:
	"tmp_bsct.btr";
	temporary;
	balanced;
	access=1;
}
//
//
//
table TempCCheck {         // size=76
	autolong ID;           // ИД чека уникальный по этой таблице
	long   Code;           // Код чека по внутреннему реестру ККМ, если Flags & CCHKF_ZCHECK, тогда Code - это номер Z-отчета
	long   CashID;         // if (Flags & (CCHKF_SYNC|CCHKF_TRANSMIT)) then
		// (CashID ->Obj(PPOBJ_CASHNODE).ID) else (CashID - Code of cash machine)
	long   UserID;         // Пользователь, создавший чек
	long   SessID;         // ->CSession.ID
	date   Dt;             // Дата чека
	time   Tm;             // Время чека
	long   Flags;          // CCHKF_XXX
	money  Amount[8];      // Общая сумма чека (с учетом скидки)
	money  Discount[8];    // Общая скидка по чеку
	long   SCardID;        // ->SCard.ID
	long   CrdSCardID;     // ->SCard.ID @v7.4.0
	long   GiftCardID;     // ->SCard.ID Подарочная карта
	long   TempReplaceID;  // @v7.7.11 Специальный случай: замещаемый в существующей кассовой сессии чек
index:
	ID (unique);
	Dt, Tm, CashID (unique mod);
	CashID, Code, Dt, Tm (unique mod);
	SessID, CashID, Dt, Tm (unique mod);
	SCardID, Dt, Tm (anysegnull dup mod);
file:
	"tmp_cchk.btr";
	temporary;
	access=1;
}
//
//
//
table TempSysJournal {
	long   ID;
	long   ID2;
	date   Dt;           // Дата
	// @v9.9.0 string DtSubst[32];  // Подстановка даты
	// @v9.9.0 string Name[128];    // Подстановка наименования // @v6.2.2 [48]-->[128]
	uint   DtSubstP;      // @v9.9.0
	uint   NameP;         // @v9.9.0
	uint   NameBeforeEvP; // @v9.9.0
	long   Count;
	long   AvgEvTime;
index:
	ID, ID2 (unique);
	Dt, ID, ID2 (unique mod);
file:
	"tmp_sj.btr";
	temporary;
	access=1;
}
//
//
//
table TempGlobUserAcc {
	long   ID;
	string Name[48];
	long   PersonID;
	string Guid[40]; // @todo string[40]-->guid
	long   Flags;
	long   GlobalService; // @v12.2.0
index:
	ID (unique);
file:
	"tmp_glbu.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempDBDiv {
	long   ID;
	string Name[48];
	string Address[256];
	long   Flags;
index:
	ID (unique);
file:
	"tmp_ddiv.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
//
//
table TempUserProfile {
	long     ID;
	int64    SeqID;
	string   DbID[40];
	string   SessID[40];
	long     ThreadId;
	long     FuncID;
	string   DbSymb[32];
	long     FuncVer;
	int64    Clock;
	date     Dt;
	time     Tm;
	long     Flags;
	double   Factor1;
	double   Factor2;
	double   Factor3;
	double   Factor4;
	double   Factor5;
	double   Factor6;
	double   Factor7;
	double   Factor8;
	string   FuncName[64];
index:
	ID (unique mod);
	SeqID, DbID, SessID (unique mod);
	DbID, SessID, FuncID, Dt, Tm (dup mod);
	DbSymb, Dt, Tm (dup mod);
	Dt, Tm (dup mod);
	FuncName (dup mod);
file:
	"tmp_uprf.btr";
	temporary;
	acstable = "rusncase.alt";
}
//
// Тестовые таблицы
//
table TestRef01 {
	autolong ID;           // @id
	long   L;
	int16  I16;
	uint16 UI16;
	double F64;
	float  F32;
	date   D;
	time   T;
	string S48[48];
	string S12[12];
index:
	ID (unique);              // #0 U
	L, I16 (unique mod);      // #1 U
	L (dup mod);              // #2
	L, UI16 (dup mod);        // #3
	F64, L (dup mod);         // #4
	S48 (unique mod);         // #5 U
	L, S12, S48 (unique mod); // #6 U
	D, T (dup mod);           // #7
file:
	"testref1.btr";
	acstable = "rusncase.alt";
}

table TestRef02 {
	autolong ID;
	long   L;
	int16  I16;
	uint16 UI16;
	double F64;
	float  F32;
	date   D;
	time   T;
	string S48[48];
	string S12[12];
	note   N[252];
index:
	ID (unique);              // #0 U
	L, I16 (unique mod);      // #1 U
	L (dup mod);              // #2
	L, UI16 (dup mod);        // #3
	F64, L (dup mod);         // #4
	S48 (unique mod);         // #5 U
	L, S12, S48 (unique mod); // #6 U
	D, T (dup mod);           // #7
file:
	"testref2.btr";
	acstable = "rusncase.alt";
	vlr;
}

table TestTa01 {
	date   Dt;
	time   Tm;
	long   Ref1ID; // ->TestRef01.ID ProbOf(NULL)=0.05 ProbOf(HANGEDLINK)=0.000001
	long   Ref2ID; // ->TestRef02.ID ProbOf(NULL)=0.80 ProbOf(HANGEDLINK)=0.000001
	long   LVal;
	int64  I64Val;
	int16  IVal;
	uint16 UIVal;
	double RVal1;
	double RVal2;
	guid   GuidVal;
	string S[32];
	clob   TextField; // @v11.9.8
index:
	Dt, Tm (unique mod);
	Ref1ID, Dt, Tm (unique mod);
	I64Val (dup mod);
file:
	"testta1.btr";
	page=4096;
}
//
//
//
