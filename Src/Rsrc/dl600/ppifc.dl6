// PPIFC.DL6
// Copytight (c) A.Sobolev 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019
// @codepage UTF-8
// Описание интерфейсов системы Papyrus
//
// Обозначения, принятые в комментариях:
//
// Const=XXX    - Значение поля обязательно должно быть равно указанной величине XXX
// ->PPOBJ_XXX  - Ссылка на объект типа PPOBJ_XXX (четырехбайтовое знаковое целое)
// @cr          - Поле может быть задано при создании записи объекта функцией IPapyrusObject::Create
// @upd         - Поле может быть изменено функцией IPapyrusObject::Update
// Descr:       - Начало описания нижеследующего объекта (интерфейса, класса, структуры, перечисления,
//   функции и т.д.).
// ARG(xxx [IN|OUT|INOUT]) - описание аргумента функции
// Returns:     - Описание возвращаемого значения функции
// Performance: - Замечания относительно производительнсоти функции
//
// @todo Добавить методы извлечения специальных видов операций (заказ от покупателя, заказ поставщику, etc)
//
// interface IEnumTaggedString
// interface IStrAssocList
// interface ISFile
// interface ISDbfCreateFlds
// interface ISDbfRecord
// interface ISDbfTable
// interface IPapyrusUtil
// interface IPapyrusDL200Resolver
// interface IPapyrusObject
// interface IPapyrusRtlPriceExtractor
// interface IPapyrusView
// interface IPapyrusSession
// interface IPapyrusObjGoods
// interface IPapyrusObjGoodsGroup
// interface IPapyrusObjLocation
// interface IPapyrusObjPerson
// interface IPapyrusBillPacket
// interface IPapyrusObjBill
// interface IPapyrusObjRegister
// interface IPpyFilt_TrfrAnlz
// interface IPpyFilt_CCheck
// interface IPpyFilt_Lot
// interface IPpyFilt_Goods
// interface IPpyFilt_GoodsRest
// interface IPpyFilt_Bill
// interface IPpyFilt_GoodsOpAnlz
//
//
//
//
import outerifc.dl6

interface IUnknown;

abstract PPYOBJREC;
abstract PPYVIEWITEM;
abstract PPYVIEWTOTAL;
abstract PPYHWND;
//
// Descr: Идентификаторы кодовых страниц.
// Note: необычный префикс (IC вместо C) обусловлен существованием в SLIB "родного" перечисления SCodepage
//   полностью аналогичного этому.
//
enum ISCodepage {
	icpANSI    =    0, // == CP_ACP
	icpOEM     =    1, // == CP_OEMCP
	icp437     =  437, // 437 US MSDOS
	icp737     =  737, // 737 Greek MSDOS
	icp850     =  850, // 850 International MSDOS
	icp852     =  852, // 852 EasernEuropean MSDOS
	icp857     =  857, // 857 Turkish MSDOS
	icp861     =  861, // 861 Icelandic MSDOS
	icp865     =  865, // 865 Nordic MSDOS
	icp866     =  866, // 866 Russian MSDOS
	icp932     =  932, // 932 Japanese Windows
	icp936     =  936, // 936 Chinese Windows
	icp950     =  950, // 950 Chinese Windows
	icp1250    = 1250, // 1250 Eastern European Windows
	icp1251    = 1251, // 1251 Russian Windows
	icp1252    = 1252, // 1252 Windows ANSI
	icp1253    = 1253, // 1253 Greek Windows
	icp1254    = 1254, // 1254 Turkish Windows
	icp1255    = 1255, // 1255 Hebrew Windows
	icp1256    = 1256, // 1256 Arabic Windows

	icpUTF7    = 65000, // == CP_UTF7
	icpUTF8    = 65001, // == CP_UTF8
	icpUTF16   =  1200, // utf-16      Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications
	icpUTF16BE =  1201, // unicodeFFFE Unicode UTF-16, big endian byte order; available only to managed applications
	icpUTF32   = 12000, // utf-32      Unicode UTF-32, little endian byte order; available only to managed applications
	icpUTF32BE = 12001  // utf-32BE    Unicode UTF-32, big endian byte order; available only to managed applications
}
//
// Descr: Идентификаторы файловых форматов.
// Элементы списка аналогичны элементам перечисления SFileFormat::XXX, определенном в slib.h.
// (за исключением префикса iff).
//
enum IFileFormat {
	iffUnkn             =  0,
	iffTxt              =  1,
	iffJpeg             =  2,
	iffPng              =  3,
	iffTiff             =  4,
	iffGif              =  5,
	iffBmp              =  6,
	iffIco              =  7,
	iffCur              =  8,
	iffSvg              =  9,
	iffHtml             = 10,  // @v8.1.0
	iffXml              = 11,  // @v8.1.0
	iffIni              = 12,  // @v8.1.0
	iffTxtBomUTF8       = 13,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF16BE    = 14,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF16LE    = 15,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF32BE    = 16,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF32LE    = 17,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF7       = 18,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF1       = 19,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomUTF_EBCDIC = 20,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomSCSU       = 21,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomBOCU1      = 22,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffTxtBomGB18030    = 23,  // @v8.6.7 Текстовый файл с сигнатурой типа кодировка (BOM)
	iffLatex            = 24,  // @v8.8.3 LATEX
	iffPdf              = 25,
	iffRtf              = 26,
	iffMdb              = 27,
	iffAccDb            = 28,  // Access
	iffWbXml            = 29,  // Binary XML
	iffWmf              = 30,
	iffEps              = 31,
	iffHlp              = 32,
	iffPpd              = 33,  // PostScript
	iffPList            = 34,  // Property List
	iffMat              = 35,  // Matlab
	iffPdb              = 36,
	iffWcbffOld         = 37,  // Windows Compound Binary File Format
	iffZip              = 38,  // @v9.0.0 Archive
	iffRar              = 39,  // @v9.0.0 Archive
	iffGz               = 40,  // @v9.0.0 Archive
	iffTar              = 41,  // @v9.0.0 Archive
	iffBz2              = 42,  // @v9.0.0 Archive
	iffSevenZ           = 43,  // @v9.0.0 Archive
	iffXz               = 44,  // @v9.0.0 Archive
	iffZ                = 45,  // @v9.0.0 Archive
	iffCab              = 46,  // @v9.0.0 Archive
	iffArj              = 47,  // @v9.0.0 Archive
	iffLzh              = 48,  // @v9.0.0 Archive
	iffXar              = 49,  // @v9.0.0 Archive
	iffPmd              = 50,  // @v9.0.0 Archive
	iffDeb              = 51,  // @v9.0.0 Archive
	iffRpm              = 52,  // @v9.0.0 Archive
	iffChm              = 53,  // @v9.0.0 Archive
	iffIso              = 54,  // @v9.0.0 Archive
	iffVhd              = 55,  // @v9.0.0 Archive
	iffWim              = 56,  // @v9.0.0 Archive
	iffMdf              = 57,  // @v9.0.0 Archive
	iffNri              = 58,  // @v9.0.0 Archive
	iffSwf              = 59,  // @v9.0.0 Archive
	iffMar              = 60,  // @v9.0.0 Archive
	iffMkv              = 61,  // @v9.0.9 Video
	iffAvi              = 62,  // @v9.0.9 Video
	iffMp4              = 63,  // @v9.0.9 Video
	iffWmv              = 64,  // @v9.0.9 Video
	iffMpg              = 65,  // @v9.0.9 Video
	iffFlv              = 66,  // @v9.0.9 Video
	iffMov              = 67,  // @v9.0.9 Video
	iffF4f              = 68,  // @v9.0.9 Video
	iffClass            = 69,  // @v9.0.9 binary:class 0:CAFEBABE
	iffExe              = 70,  // @v9.0.9 binary:exe   0:4D5A
	iffDll              = 71,  // @v9.0.9 binary:dll   0:4D5A
	iffPcap             = 72,  // @v9.0.9 binary:pcap  0:D4C3B2A1
	iffPyo              = 73,  // @v9.0.9 binary:pyo   0:03F30D0A
	iffSo               = 74,  // @v9.0.9 binary:so    0:7F454C46
	iffMo               = 75,  // @v9.0.9 binary:mo    0:DE120495
	iffMui              = 76,  // @v9.0.9 binary:mui   0:50413330
	iffCat              = 77,  // @v9.0.9 binary:cat   0:30 6:2A864886
	iffXsb              = 78,  // @v9.0.9 binary:xsb   0:DA7ABABE
	iffKey              = 79,  // @v9.0.9 binary:key   0:4B4C737727
	iffSq3              = 80,  // @v9.0.9 binary:sq3   0:53514C697465
	iffQst              = 81,  // @v9.0.9 binary:qst   0:0401C4030000 binary:qst   0:040180040000
	iffCrx              = 82,  // @v9.0.9 binary:crx   0:43723234
	iffUtx              = 83,  // @v9.0.9 binary:utx   0:4C0069006E006500610067006500
	iffRx3              = 84,  // @v9.0.9 binary:rx3   0:52583362
	iffKdc              = 85,  // @v9.0.9 binary:kdc   0:44494646
	iffXnb              = 86,  // @v9.0.9 binary:xnb   0:584E42
	iffBlp              = 87,  // @v9.0.9 binary:blp   0:424C5031 binary:blp   0:424C5032
	iffBig              = 88,  // @v9.0.9 binary:big   0:42494746
	iffMdl              = 89,  // @v9.0.9 binary:mdl   0:49445354
	iffSpr              = 90,  // @v9.0.9 binary:spr   0:CDCC8C3F
	iffSfo              = 91,  // @v9.0.9 binary:sfo   0:00505346
	iffMpq              = 92,  // @v9.0.9 binary:mpq   0:4D50511A
	iffNes              = 93,  // @v9.0.9 binary:nes   0:4E45531A
	iffDmp              = 94,  // @v9.0.9 binary:dmp   0:4D444D5093A7
	iffDex              = 95,  // @v9.0.9 binary:dex   0:6465780a30333500 binary:dex   0:6465780a30333600
	iffGim              = 96,  // @v9.0.9 binary:gim   0:4D49472E30302E31505350
	iffAmxx             = 97,  // @v9.0.9 binary:amxx  0:58584D41
	iffSln              = 98,  // Visual Studio Solution
	iffVCProj           = 99,  // Visual Studio Project
	iffAsm              = 100, // Assempbler source file
	iffC                = 101, // C source file
	iffCPP              = 102, // CPP source file
	iffH                = 103, // C header file
	iffPerl             = 104, // perl source code
	iffPhp              = 105, // php source code
	iffJava             = 106, // java source code
	iffPy               = 107, // Python source code
	iffUnixShell        = 108, // Unix Shell script
	iffMsi              = 109, // Microsoft Installer package
	iffTxtUtf8          = 110, // @v9.3.6 Текст в формате utf8
	iffTxtAscii         = 111, // @v9.3.6 Текст в котором только ASCII-символы
	iffLog              = 112, // @v9.7.1 Файл журнала (by ext only)
	iffProperties       = 113, // @v9.7.1 Файл properties. Обычно текстовый файл аналогичный ini, но без зональности ([]).
	iffCss              = 114, // @v9.7.1 CSS
	iffJavaScript       = 115, // @v9.7.1 JS
	iffJson             = 116  // @v9.7.2
}
//
// Descr: Представление периода между двумя датами.
//   Все функции, использующие структуру периода, считают, что нижняя и верхняя границы
//   включены в период.
//   Если нижняя граница не определена (Low = 0), то, как правило, рассматриваются данные
//   с начала ведения учета в базе данных.
//   Если верхняя граница не определена (Upp = 0), как правило, рассматриваются данные
//   до самой последней записи (в хронологическом порядке), введенной в базу данных.
//   Оговоренное правило - наиболее общее. В зависимости от контекста, оно может изменяться.
//   В некторых случаях указанный из-вне период может быть наложен на период, определенный
//   правами доступа.
//
struct SDateRange {
	date   Low; // Нижняя граница периода
	date   Upp; // Верхняя граница периода
}
//
// Descr: Счетчик итераций.
//
struct SIterCounter {
	long   Count; // Текущая (завершенная) итерация //
	long   Total; // Общее количество итераций
}
//
// Descr: Структура, используемая для организации списков строковых ассоциаций.
//   Нулевым элементов STaggedString считается такой, у которого: Id = 0, ParentId = 0, Text = "".
//
struct STaggedString {
	long   Id;       // Идентификатор элемента
	long   ParentId; // Идентификатор родительского элемента. Если 0, то верхний уровень
	string Text;     // Текст
}

interface IEnumTaggedString {
	void   Next(long celt, out STaggedString * pItems, out long * pceltFetched);
	void   Skip(long celt);
	void   Reset();
	void   Clone(out IEnumTaggedString ** ppenum);
}

interface ILongList {
	long   GetCount();
	long   Get(long idx);
	//
	// Descr: Ищет линейным поиском значение val в списке.
	// Returns:
	//   >0 Индекс найденного элемента +1
	//   0  Элемент не найден
	//
	long   Search(long val);
	//
	// Descr: Ищет бинарным поиском значение val в списке.
	// Returns:
	//   >0 Индекс найденного элемента +1
	//   0  Элемент не найден
	//
	long   BSearch(long val);

	int    Add(long val);
	int    AddUnique(long val);
	int    Remove(long idx);
	int    RemoveByVal(long val);
	void   Sort();
	void   SortAndUndup();
	//
	// Descr: Очищает список.
	//
	void   Clear();
}
//
// Descr: Интерфейс обеспечивающий управление списком строк, ассоциированных с целочисленными
//   идентификаторами.
// @attention: В текущих версиях поле STaggedString::ParentId не поддерживается //
//
interface IStrAssocList {
	//
	// Descr: Возвращает количество элементов в списке.
	//
	long   GetCount();
	//
	// Descr: Возвращает элемент по индексу pos. Если pos < GetCount(),
	//   то pItem обнуляется (Id = 0, ParentId = 0, Text = "").
	// ARG(pos    IN): @#{0..GetCount()-1} позиция в списке, по которой следует вернуть элемент.
	// ARG(pItem OUT): @#{vptr0} Указатель на структуру STaggedString, по которому присваивается //
	//   найденный элемент. Если pItem == 0, то функция просто ничего не присваивает, но возвращает
	//   значение то же, как будто pItem != 0.
	// Returns:
	//   >0 - элемент успешно извлечен из списка и присвоен по адресу pItem
	//   0  - индекс pos выходит за диапазон [0..GetCount()-1]. По адресу pItem
	//        присвоен нулевой элемент.
	//
	int    Get(long pos, out STaggedString * pItem);
	//
	// Descr: Ищет в списке элемент с идентификатором STaggedString::Id == id.
	//   Поиск осуществляется в линейном порядке (не взирая на сортировку, если она есть).
	//   По этому, если в списке присутствует более одного элемента с таким идентификатором,
	//   то функция обнаружит и вернет тот, у которого меньшее значение индекса позиции.
	// ARG(id     IN): Идентификатор элемента, который должен быть найден.
	// ARG(pItem OUT): @#{vptr0} Указатель на структуру STaggedString, по которому присваивается //
	//   найденный элемент. Если pItem == 0, то функция просто ничего не присваивает, но возвращает
	//   значение то же, как будто pItem != 0.
	// Returns:
	//   >0 - элемент со значением STaggedString::Id == id найден и присвоен по адресу pItem.
	//   0  - элемент со значением STaggedString::Id == id не найден. По адресу pItem
	//        присвоен нулевой элемент.
	//
	int    SearchById(long id, out STaggedString * pItem);
	//
	// Descr: Ищет в списке элемент со строкой, равной text. Равенство строк определяется по
	//   последовательному соответствию всех символов с точностью до регистра букв.
	//   Поиск осуществляется в линейном порядке (не взирая на сортировку, если она есть).
	//   По этому, если в списке присутствует более одного элемента с подходящим полем Text,
	//   то функция обнаружит и вернет тот, у которого меньшее значение индекса позиции.
	// ARG(text   IN): Строка, соответствующая полю STaggedString::Text элемента, который должен
	//   быть найден.
	// ARG(pItem OUT): @#{vptr0} Указатель на структуру STaggedString, по которому присваивается //
	//   найденный элемент. Если pItem == 0, то функция просто ничего не присваивает, но возвращает
	//   значение то же, как будто pItem != 0.
	// Returns:
	//   >0 - элемент со значением STaggedString::Id == id найден и присвоен по адресу pItem.
	//   0  - элемент со значением STaggedString::Id == id не найден.
	//        По адресу pItem присвоен нулевой элемент.
	//
	int    SearchByText(string text, out STaggedString * pItem);
	//
	// Descr: Отличается от функции SearchByText тем, что ищет элемент начало строки которого совпадает с text
	//
	int    SearchByTextPattern(string text, out STaggedString * pItem);
	//
	// Descr: Ищет в списке элемент с идентификатором STaggedString::Id == id и, в случае успеха,
	//   возвращает строку, соответствующую этому элементу.
	//   Поиск осуществляется в линейном порядке (не взирая на сортировку, если она есть).
	//   По этому, если в списке присутствует более одного элемента с таким идентификатором,
	//   то функция обнаружит и вернет тот, у которого меньшее значение индекса позиции.
	// ARG(id     IN): Идентификатор элемента, который должен быть найден.
	// Returns:
	//   Поле STaggedString::Text найденного элемента. Если элемент с заданным идентификатором не
	//   найден, то возвращается пустая строка.
	//
	string GetTextById(long id);
	//
	// Descr: Инициализирует внутренний счетчик для последующих вызовов функци NextIteration.
	//
	void   InitIteration();
	//
	// Descr: Возвращает элемент, соответствующий внутреннему счетчику объекта и увеличивает
	//   на единицу значение этого счетчика.
	//   Если внутренний счетчик выход за пределы [0..GetCount()-1], то возвращает 0.
	// ARG(pItem OUT): @#{vptr0} Указатель на структуру STaggedString, по которому присваивается //
	//   очередной элемент. Если pItem == 0, то функция просто ничего не присваивает, но возвращает
	//   значение то же, как будто pItem != 0.
	// Returns:
	//   >0 - очередной элемент получен и присвоен по укзателю pItem. Внутренний счетчик увеличен
	//        на единицу.
	//   0  - больше нет ни одного элемента для перечисления //
	//        По адресу pItem присвоен нулевой элемент.
	//
	int    NextIteration(out STaggedString * pItem);
	//
	// Descr: Удаляет все элементы из списка. Единственный гарантированный результат этой функции
	//   состоит в том, что количество доступных элементов в списке станет равным нулю.
	//   Предположений об очистке внутренней памяти делать не следует.
	//
	void   Clear();
	//
	// Descr: Добавляет в список новый элемент с полями:
	//   STaggedString::Id = itemId, STaggedString::ParentId = parentId, STaggedString::Text = text;
	//   Если в списке уже присутсвует элемент с идентификатором itemId, то новый не добавляется,
	//   но у существующего заменяются атрибуты ParentId и Text на те, что указаны в аргументах.
	//   Не следет делать предположения относительно индекса позиции, в которую был добавлен новый элемент.
	//
	void   Add(long itemId, long parentId, string text);
	//
	// Descr: Сортирует элементы списка.
	// ARG(byText IN): Если этот параметр равен 1, то сортировка осуществляется по полю STaggedString::Text,
	//   в противном случае - по полю STaggedString::Id.
	//
	void   Sort(int byText);
	//
	// Descr: Создает экземпляр списка, содержащего такие же элементы, что в оригинальном
	//   экземпляре. Элементы в копии находятся в той же последовательности, что и в оригинале.
	//
	void   Clone(out IStrAssocList ** ppClone);
	//
	// Descr: Создает экземпляр списка, содержащий выборку элементов из оригинального списка,
	//   у которых полу STaggedString::ParentId = parentId.
	// Returns:
	//   >0 - создана копия, содержащая по крайней мере один элемент
	//   <0 - создана копия, не содержащая ни одного элемента из оригинального списка
	//        Это означает, что в оригинальном списке нет ни одного элемента с STaggedString::ParentId = parentId
	//   0  - ошибка
	// @attention: В текущих версиях функция не поддерживается //
	//
	int    CloneByParent(long parentId, out IStrAssocList ** ppClone);
}
//
// Descr: Интерфейс обеспечивающий управление записью/чтением информации из файлов
//
enum SFileMode {
	mRead           = 1,      // "r"
	mWrite          = 2,      // "w"
	mAppend         = 3,      // "a"
	mReadWrite      = 4,      // "r+"
	mReadWriteTrunc = 5,      // "w+"
	mAppendRead     = 6,      // "a+"

	mBinary         = 0x0100, // "..b"
	mDenyRead       = 0x0200,
	mDenyWrite      = 0x0400,
	mNoStd          = 0x0800  // Файл открывается в низкоуровневом (небуферизованном) режиме (open)
}

interface ISFile {
	int    Open(in string fileName, in SFileMode mode);
	int    Close();
	int    IsValid();
	int    WriteLine(in string buf);
	int    ReadLine(out string * pBuf);
	int    CalcSize(out long * pLoWord, out long * pHiWord);
	int    WriteLine2(in string buf, in ISCodepage cp);
}
//
// Descr: Интерфейс обеспечивающий управление чтение/записью информации из DBF
//
enum SDbfFldType {
	dbftString  = 1,
	dbftInt     = 2,
	dbftLong    = 3,
	dbftDouble  = 4,
	dbftDate    = 5,
	dbftLogical = 6
}

struct SDbfCreateFld {
	string Name;
	SDbfFldType Type;
	int    Size;
	int    Prec;           // Точность числовогт значения (количество знаков после точки)
}
//
// Descr: Структура для создания DBF-таблицы
//
interface ISDbfCreateFlds {
	int    Add(in SDbfCreateFld * pFld);
	int    InitIteration();
	int    NextIteration(out SDbfCreateFld * pFld);
	int    GetCount();
}

interface ISDbfRecord {
	int    Empty();
	//
	// Для параметра fldN во всех следующих функциях диапазон [1..]
	//
	int    PutString(int fldN, string val);
	int    PutDouble(int fldN, double val);
	int    PutLong(int fldN, long  val);
	int    PutInt(int fldN, int   val);
	int    PutDate(int fldN, date val);
	string GetString(int fldN);
	double GetDouble(int fldN);
	long   GetLong(int fldN);
	int    GetInt(int fldN);
	date   GetDate(int fldN);
	string GetFieldName(uint fldN); // fldN - 1..
	int    GetFieldNumber(string pFldName);
	SDbfFldType GetFieldType(uint fldN); // fldN - 1..
}

interface ISDbfTable {
	int    Open(string fileName);
	int    IsOpened();
	string GetName();
	string GetFieldName(uint fldN); // fldN - 1..
	int    GetFieldNumber(string pFldName);
	uint   GetNumRecs();
	uint   GetRecSize();
	uint   GetNumFields();
	uint   GetPosition();
	int    Close();
	//
	// Descr: Создает DBF-таблицу с заданным набором полей.
	//
	int    Create(ISDbfCreateFlds * pFldsDescr);
	int    GoToRec(uint num);
	int    Top();
	int    Bottom();
	int    Next();
	int    Prev();
	int    DeleteRec();
	ISDbfRecord * MakeRec();
	int    GetRec(ISDbfRecord * pRec);
	int    AppendRec(ISDbfRecord * pRec);
	int    UpdateRec(ISDbfRecord * pRec);
	int    Flush();
	int    InitBuffer();
	int    ReleaseBuffer();
	int    IsDeletedRec();
	//
	// Descr: Создает DBF-таблицу с заданным набором полей и кодовой страницей cp.
	//
	int    Create2(ISDbfCreateFlds * pFldsDescr, in ISCodepage cp); // @v6.9.9
	//
	// Descr: Создает DBF-таблицу с заданным набором полей, кодовой страницей cp и заголовочным байтом inofByte
	//   Если infoByte < 0, то применяется значение по умолчанию (3)
	//
	int    Create3(ISDbfCreateFlds * pFldsDescr, in ISCodepage cp, in int infoByte); // @v8.4.0
}
//
// Descr: IFtp
//
enum SFtpAgent {
	ftpagExplorer = 0,
	ftpagNetscape = 1,
	ftpagOpera    = 2
}

enum SFtpAccessType {
	ftpatDirect    = 0, // PPINETCONN_DIRECT
	ftpatPreconfig = 1, // PPINETCONN_PRECONFIG
	ftpatProxy     = 2  // PPINETCONN_PROXY
}

struct SFtpConfig {
	SFtpAgent Agent;    // Агент
	string ProxyHost;   // Адрес прокси сервера
	string ProxyPort;   // Порт прокси сервера
	int32  MaxTries;    // Кол-во попыток соединени
	SFtpAccessType AccessType;  // Тип доступа
	int32  Flags;       // Не используетс
}

enum SFtpAccountFlags {
	// 0x00000001 - fFtpAccount
	ftpafPassive = 0x00000002 // Использовать пассивный режим
}

struct SFtpAccount {
	string User;      // Пользователь
	string Password;  // Пароль
	string Host;      // Адрес
	int32  Port;      // Порт
	SFtpAccountFlags Flags;     // Флаги
}

interface IFtp {
	int32 Init(in SFtpConfig * pCfg);
	int32 Connect(in SFtpAccount * pAcct);
	int32 Get(in string pLocalPath, in string pFtpPath);
	int32 Put(in string pLocalPath, in string pFtpPath);
	int32 Delete(in string pFtpPath);
	IStrAssocList * GetFileList(in string pDir, in string pMask);
	int32 CD(in string pFtpPath, in long isFullPath);
	int32 DeleteWOCD(in string pFtpPath);
}
//
//
//
library PapyrusInterfaceLib version(1.1) {
	//
	// Descr: Интерфейс, к классу, реализующему функцию обработки текстовых строк по правила,
	//   определенным в специальном файле.
	//
	interface IPapyrusTextAnalyzer {
		int    Init(in string ruleFileName);
		string ReplaceString(in string inputText);
	}
	//
	//
	//
	struct PpySupplInterchangeConfig {
		long   SupplID;        // Ид поставщика, с которым осуществляется обмен
		long   GoodsGrpID;     // Ограничивающая товарная группа
		long   ExpendOp;       // Вид операции отгрузки
		long   RcptOp;         // Операция прихода
		long   SupplRetOp;     // Операция возврата поставщику
		long   RetOp;          // Операция возврата от покупател
		long   MovInOp;        // Перемещение со склада (расход)
		long   MovOutOp;       // Перемещение на склад (приход)
		long   OrderOp;        // . Вид операции заказа от покупателя
		long   PriceQuotID;    // Котировка по которой будем назначать цену в документах
		long   DefUnitID;      // Единица измерения, применяемая по умолчанию как базовая
		long   ProtVer;        // Версия протокола обмена (специфично для конткретной технологии обмена)
		string ClientCode;     // Код данного клиента на сервере поставщика
		string EDIPrvdrSymb;   // Символ провайдера EDI
		string RemoveAddr;     // Адрес для обмена данными (это может быть e-mail, url иди каталог)
		string AccsName;       // Имя аккаунта для доступа к обмену данными
		string AccsPassw;      // Пароль для доступа к обмену данными
		string TechSymbol;     // Символ технологии обмена
		long   SequenceID;     // @v9.5.0 Внутренний счетчик для автоматической нумерации запросов
		long   CliCodeTagID;   // @v9.5.0 Тег персоналии для кода в терминах поставщика
		long   LocCodeTagID;   // @v9.5.0 Тег локации для кода в терминах поставщика
	}
	//
	// Descr: Перечисление типов классов PPView.
	//
	enum PpyViewIdent {
		ppvCCheck      = 1,  // PPViewCCheck
		ppvTrfrAnlz    = 2,  // PPViewTrfrAnlz
		ppvLot         = 3,  // PPViewLot
		ppvGoods       = 4,  // PPViewGoods
		ppvGoodsRest   = 5,  // PPViewGoodsRest
		ppvBill        = 6,  // PPViewBill
		ppvGoodsOpAnlz = 7,  // PPViewGoodsOpAnalyze
		ppvTSession    = 8,  // PPViewTSession
		ppvPrjTask     = 9,  // PPViewPrjTask
		ppvProject     = 10, // PPViewProject
		ppvOpGrouping  = 11, // PPViewOpGrouping
		ppvDebtTrnovr  = 12, // PPViewDebtTrnovr
		ppvLotOp       = 13, // PPViewLotOp
		ppvGoodsStruc  = 14  // PPViewGoodsStruc @v9.9.10
	}
	//
	// Descr: Перечисление типов объектов PPObject. Каждый элемент перечисления должен иметь
	//   соответствие PPOBJ_XXX в файле ppdefs.h (значения идентификаторов ppoXXX и PPOBJ_XXX
	//   обязательно должны совпадать)
	//
	enum PpyObjectIdent {
		ppoUnit           =   5,  // =PPOBJ_UNIT
		ppoOprKind        =   12, // =PPOBJ_OPRKIND        Виды операций
		ppoAccSheet       =   13, // =PPOBJ_ACCSHEET       Таблицы аналитического учета
		ppoCashNode       =   17, // =PPOBJ_CASHNODE       Расчетные кассовые узлы
		ppoQuotKind       =   29, // =PPOBJ_QUOTKIND       Виды котировок товаров
		ppoTag            =   31, // =PPOBJ_TAG            Теги объектов
		ppoGoodsTax       =   32, // =PPOBJ_GOODSTAX       Налоговые группы товаров
		ppoCurrency       =   34, // =PPOBJ_CURRENCY       Валюты
		ppoGoodsClass     =   37, // =PPOBJ_GOODSCLASS     Классы товаров
		ppoSCardSeries    =   42, // =PPOBJ_SCARDSERIES    Серии персональных карт
		ppoStyloPalm      =   43, // =PPOBJ_STYLOPALM      КПК Palm
		ppoTranpModel     =   47, // =PPOBJ_TRANSPMODEL    Модели транспортных средств (в виде класса не реализован, можно использовать только в функции GetObjectName)
		ppoPersonCategory =   50, // =PPOBJ_PRSNCATEGORY   Категории персоналий
		ppoSalCharge      =   56, // =PPOBJ_SALCHARGE      Штатные начисления           //
		ppoDebtDim        =   64, // =PPOBJ_DEBTDIM        Размерность расчета долгов по документам
		ppoPerson         = 1004, // =PPOBJ_PERSON         Персоналии
		ppoArticle        = 1006, // =PPOBJ_ARTICLE        Статьи аналитического учета
		ppoGoodsGroup     = 1008, // =PPOBJ_GOODSGROUP     Группы товаров
		ppoGoods          = 1009, // =PPOBJ_GOODS          Товары
		ppoLocation       = 1010, // =PPOBJ_LOCATION       Склады
		ppoBill           = 1011, // =PPOBJ_BILL           Документы
		ppoQCert          = 1013, // =PPOBJ_QCERT          Сертификаты качества
		ppoStaff          = 1021, // =PPOBJ_STAFFLIST      Штатные должности
		ppoLot            = 1022, // =PPOBJ_LOT            Лоты
		ppoTransport      = 1028, // =PPOBJ_TRANSPORT      Транспортные средства
		ppoCCheck         = 1032, // =PPOBJ_CCHECK         Кассовые чеки
		ppoProject        = 1033, // =PPOBJ_PROJECT        Проекты
		ppoPrjTask        = 1036, // =PPOBJ_PRJTASK        Задачи
		ppoProcessor      = 1037, // =PPOBJ_PROCESSOR      Процессоры
		ppoTSession       = 1039, // =PPOBJ_TSESSION       Технологические сессии
		ppoWorld          = 1043, // =PPOBJ_WORLD          Государства
		ppoRegister       = 1044, // =PPOBJ_REGISTER       Регистры
		ppoPersonRelType  = 1045, // =PPOBJ_PERSONRELTYPE  Типы персональных отношений
		ppoBrand          = 1046, // =PPOBJ_BRAND          Бренды
		ppoSCard          = 1031  // =PPOBJ_SCARD          Персональные карты
	}
	//
	//
	//
	enum PpyAmountType {
		ppamtMain          = 1,  // Номинальная сумма документа
		ppamtBuying        = 2,  // Станд сумма в ценах поступления //
		ppamtSelling       = 3,  // Станд сумма в ценах реализациии
		ppamtDiscount      = 4,  // Скидка
		ppamtPayment       = 5,  // Сумма оплаты на текущий момент
		ppamtPctDis        = 6,  // Скидка в процентах (если задана пользователем)
		ppamtVaTax         = 7,  // НДС
		ppamtExcsize       = 8,  // Акциз
		ppamtCVat          = 9,  // НДС в ценах поступления //
		ppamtPVat          = 10, // НДС в ценах реализации
		ppamtManDis        = 11, // Скидка суммой на весь док (заданная пользователем)
		ppamtRentPrd       = 12, // Сумма выплат по ренте за период
		ppamtSalesTax      = 13, // Налог с продаж
		ppamtCRateE        = 14, // Валютный курс относительно базовой валюты
		ppamtCExcise       = 15, // Акциз в ценах поступления //
		ppamtTransitRate   = 16, // Транзитный валютный курс (валюты определяются из контекста)
		ppamtFixPayment    = 17, // Фиксированная сумма оплаты (не зависит от привязанных оплат)
		ppamtCS_AggrSum    = 18, // Сумма, агрегированная по чековым строкам кассовой сессии
		ppamtCS_AggrRest   = 19, // Сумма непроведенных излишков по чековым строкам кассовой сессии
		ppamtCSTax         = 20, // Сумма налога с продаж в ценах поступления //
		ppamtAssetExpl     = 21, // Сумма вводимых в эксплуатацию основных средств
								 // Набор сумм по строкам расширения бухгалтерских документов
		ppamtAdlnMain      = 41  // Номинальная сумма строки расширения //
	}

	struct PpyAmountEntry {
		PpyAmountType AmtTypeID;
		long   CurID;
		double Amt;
	}

	interface IPapyrusAmountList {
		//
		// Descr: Возвращает кол-во элементов в списке
		//
		long   GetCount();
		//
		// Descr:
		//
		long   InitIteration();
		//
		// Descr:
		//
		long   NextIteration(out PpyAmountEntry * pEntry);
		//
		// Descr: Добавляет в список новый элемент. Если элемент с таким типом суммы и валютой уже существует, то он не будет добавлен.
		//
		long   Add(in PpyAmountEntry * pEntry);
		//
		// Descr: Удаляет элемент из списка.
		//
		long   RemoveByPos(in long pos);
		//
		// Descr: Удаляет элемент из списка. Если curID < 0, то тогда удаляются суммы с типом суммы amtTypeID и всеми валютами
		//
		long   Remove(in PpyAmountType amtTypeID, long curID);
		//
		// Descr: Возвращает элемент списка с определенным типом суммы и валютой.
		//
		double Get(in PpyAmountType amtTypeID, long curID);
		//
		// Descr: Возвращает элемент списка под номером pos, нумерация начинается с 0.
		//
		int    GetByPos(long pos, out PpyAmountEntry * pItem);
		//
		// Descr: Очищает список
		//
		void   Clear();
	}
	//
	//
	//
	enum PpyIniParam {
		SpecEncodeSymbs = 162,
		BaltikaWoTareBeerGGrpCode = 187
	}

	enum PpyIniSection {
		ppisPath           = 0,
		ppisDbName         = 1,
		ppisBackup         = 2,
		ppisSystem         = 3,
		ppisRecover        = 4,
		ppisConfig         = 5,
		ppisImpPerson      = 6,  // import.ini
		ppisImpGoodsGroup  = 7,  // import.ini
		ppisImpGoods       = 8,  // import.ini
		ppisImpQuot        = 9,  // import.ini
		ppisPriceList      = 10, // plist.cnf
		ppisClientBank     = 11, // Зона описания экспорта в систему клиент-банк
		ppisImpBank        = 12, // import.ini
		ppisServer         = 13,
		ppisImpSpecSer     = 14, // import.ini
		ppisImpCountry     = 15, // import.ini
		ppisImpScard       = 16, // import.ini
		ppisImpSuppl       = 17, // import.ini
		ppisDriveMapping   = 18, // pp.ini
		ppisImpKladrStatus = 19, // import.ini
		ppisImpKladrStreet = 20, // import.ini
		ppisImpKladr       = 21  // import.ini
	}
	//
	// Descr: Типы значений тегов
	//
	enum PpyOTagType {
		ottypGroup     = 0, // Группа тегов
		ottypBool      = 1, // Логическое значение
		ottypString    = 2, // Строка
		ottypNumber    = 3, // double
		ottypEnum      = 4, // Перечисление (PPObjectTag::TagEnumID)
		ottypInt       = 5, // int32
		ottypObjLink   = 6, // Ссылка на объект (PPObjectTag::TagEnumID)
		ottypDate      = 7, // date
		ottypGUID      = 8, // GUID
		ottypImage     = 9, // Строка, содержащая путь к файлу с изображением
		ottypTimeStamp = 10 // Временная метка
	}
	//
	//
	//
	struct PpyTagValue {
		long   TagID;     // Идентификатор типа тега
		long   ObjType;   // Тип объекта данных
		long   ObjID;     // ИД объекта данных
		PpyOTagType TagType; // Тип данных тега
		long   VInt;      // Целочисленное значение
		double VReal;     // Вещественное значение
		string VStr;      // Строковое значение
		date   VDt;       // Значение типа даты
		time   VTm;       // Если тег имеет тип ottypTimeStamp, то здесь хранится время
		string VSymb;     // Если тег имеет тип ottypObjLink или ottypEnum, то здесь хранится символ связанного объекта.
	}
	//
	// Descr: Варианты форматов текстового представления даты. Используется
	//   функцией IPapyrusUtil::StrToDate
	//
	enum PpyDateFormat {
		datfDefault  =  0, // Формат определяется по ситуации
		datfAmerican =  1, // mm/dd/yy
		datfANSI     =  2, // yy.mm.dd
		datfBritish  =  3, // dd/mm/yy
		datfFrench   =  4, // dd/mm/yy
		datfGerman   =  5, // dd.mm.yy
		datfItalian  =  6, // dd-mm-yy
		datfJapan    =  7, // yy/mm/dd
		datfUSA      =  8, // mm-dd-yy
		datfMDY      =  9, // mm/dd/yy
		datfDMY      = 10, // dd/mm/yy
		datfYMD      = 11, // yy/mm/dd
		datfSQL      = 12, // DATE 'YYYY-MM-DD'
		datfInternet = 13, // Wed, 27 Feb 2008
		datfISO8601  = 14  // yyyy-mm-dd
	}
	//
	// Descr: Интерфейс, обеспечивающий функции поддержки.
	//   По всей вероятности, количество функций в этом интерфейсе будет
	//   увеличиваться (несмотря на запрет спецификации COM на изменение интерфейсов).
	//
	interface IPapyrusUtil {
		//
		// Descr: Преобразует строку str в структуру периода. Используются обычные
		//   правила преобразования, применяемые в интерактивном сеансе системы.
		//
		SDateRange StrToDateRange(string str);
		//
		// Descr: Преобразует период в строку. Используются обычные
		//   правила преобразования, применяемые в интерактивном сеансе системы.
		//
		string DateRangeToStr(date low, date upp);
		//
		// Descr: Приведение строки к Dos или Win Кодировке
		//
		string ToChar(string buf);
		string ToOem(string buf);
		string UTF8ToOem(string buf);
		string UTF8ToChar(string buf);
		//
		// Descr: Преобразование типов
		//
		long   ToLong(string buf);
		double ToDouble(string buf);
		//
		// Descr: Проверяет выставлен-ли flag в переменной flags
		//
		int    CheckFlag(long flags, long flag);
		//
		// Следующие 3 метода возвращают определеные идентификаторы таблицы статей
		// Работают только если пользователь авторизовался в базе данных.
		// Т.е. интерфейс IPapyrusUtil должнен быть создан с помощью метода CreateUtil интерфейса IPapyrusSession
		//
		// Descr: Возвращает идентификатор таблицы статей покупателей
		//
		long   GetSellAccSheet();
		//
		// Descr: Возвращает идентификатор таблицы статей агентов
		//
		long   GetAgentAccSheet();
		//
		// Descr: Возвращает идентификатор таблицы статей поставщиков
		//
		long   GetSupplAccSheet();
		//
		// Descr: Возвращает ID персоналии асоциированный с данной статьей.
		// Работает только если пользователь авторизовался в базе данных.
		//
		long   ObjectToPerson(long articleID);
		//
		// Descr: Возвращает ID статьи, ассоциированной с данной персоналией.
		// Работает только если пользователь авторизовался в базе данных
		//
		long   PersonToObject(long personID, long accSheetID);
		//
		// Descr: Возвращает ID склада асоциированный с данной статьей.
		// Работает только если пользователь авторизовался в базе данных.
		//
		long   ObjectToWarehouse(long articleID);
		//
		// Descr: Возвращает ID статьи, ассоциированной с данным складом.
		// Работает только если пользователь авторизовался в базе данных
		//
		long   WarehouseToObject(int32 locID);
		//
		// Descr: Возвращает наименование объекта
		//
		//
		string GetObjectName(PpyObjectIdent objType, long objID);
		//
		// Descr: Вызывает функцию _spawnl
		// rPath - приложение, которое необходимо вызвать
		// rParams - параметры командной строки через пробел
		//
		long   Spawnl(int wait, string path, string params);
		//
		// Descr: Удаляет файл
		//
		long   RemoveFile(string fileName);
		//
		// Descr: Проверяет, существует ли данный файл
		//
		long   IsFileExists(string fileName);
		//
		// Descr: Кодирует (декодирует в зависимости от параметра decode) строку с помощью параметра rEncodeSymbs
		//   строка rEncodeSymbs содержит пары в виде: %01,254000;%02,255000, где 254000, 255000 и т.д. -
		//   кусок строки который нужно закодировать символами - %01, %02 и т.д
		//
		string  EncodeString(in string rSrc, in string rEncodeSymbs, int decode);
		//
		// Descr: Считывает из файла pp.ini параметр
		// Работает только если пользователь авторизовался в базе данных
		//
		string  ReadPPIniParam(PpyIniSection section, PpyIniParam param);
		//
		// Descr: Возвращает id родной страны
		//
		long    GetNativeCountry();
		//
		// Descr: Создает GUID
		//
		string  MakeGUID();
		//
		//
		//
		long    SendMail(in long acctID, in string rSubject, in string rMessage, in string rMail, in IStrAssocList * pAttachments);
		//
		// Descr: Извлекает значение тега
		//
		int    GetTagValue(in PpyObjectIdent objType, in long objID, in long tagID, out string * pValue);
		//
		// Descr: Устанавливает значение тега
		//
		int    PutTagValue(in PpyObjectIdent objType, in long objID, in long tagID, in string rValue);
		//
		// Descr: Проверяет штрихкод inputBarcode на соответствие одному из стандартов EAN13, EAN8, UPCA, UPCE.
		//   -- Если код полностью соответствует одному из этих стандартов, то возвращет +1, а по указателю pStd
		//   собственно стандарт, к которому относится код.
		//   -- Если код не полностью удовлетворяет стандарту, но может быть преобразован в правильный, то возвращает -1,
		//   по указателю pStd - стандарт, к которому скорее всего относится код, по указателю pDiagText строку
		//   сообщения, что в коде не правильно (но устранимо), а по указателю pOutputBarcode - исправленный код.
		//   -- Если код ошибочный, то возвращает 0, а по указателю pDiagText строку сообщения о характере ошибки в коде.
		//
		int    DiagBarcode(in string inputBarcode, out int * pStd, out string * pDiagText, out string * pOutputBarcode);
		//
		// Descr: Функция создает hash code по алгоритму компании Roshen.
		// Используются операции с 64 битными значениями.
		//
		int    RoshenMakeHash(in string rBuf, out string * pHashCode);
		//
		// Descr: Извлекает полную структуру значения тега tagID объекта {objType, objID}.
		//
		int    GetTagValueExt(in PpyObjectIdent objType, in long objID, in long tagID, out PpyTagValue * pValue);
		//
		// Descr: Функция установки параметров сессии.
		//   Введена для того, чтобы задавать параметры, для которых нет специальных интерфейсов.
		//   ETIEF_DIFFBYLOT 0|1 - если 1, то функция IPapyrusBillPacket::EnumItems будет дифференцировать строки документов по лотам
		//
		int    SetConfigParam(in string param, in string value);
		//
		// Descr: Считывает из файла pp.ini параметр [section] param
		// Работает только если пользователь авторизовался в базе данных
		//
		string  ReadPPIniParamS(PpyIniSection section, in string param);
		//
		// Descr: Возвращает конфигурацию обмена с поставщиком supplID (ид аналитической статьи)
		//   Структура возвращается даже если у поставщика нет опций обмена в соглашении - в этом
		//   случае большинство полей структуры будут пустыми или нулевыми (кроме тех, что извлекаются из общих структур).
		//
		int     GetSupplInterchangeConfig(in long supplID, out PpySupplInterchangeConfig * pValue);
		//
		// Descr: Извлекает значение тега типа GUID для объекта {objType, objID}. Если объект существует
		//   но не имеет заданного тега, то этот тег автоматически создается для объекта.
		// Note: Тег обязательно должен иметь тип GUID.
		//
		int    GetTagGUID(in PpyObjectIdent objType, in long objID, in long tagID, out string * pValue);
		//
		// Descr: Функция унифицированного копирования файла как между локальными каталогами так и
		//   на(из) сетевой ресурс (Ftp, Http). В качестве аргументов принимает URL исходного и файла и файла
		//   получателя. По крайней мере один из аргументов srcUrl или destUrl должен ссылаться на локальный
		//   файл.
		//
		int    UniformFileTransm(in string srcUrl, in string destUrl, in long flags, in IFileFormat iff, in string accsName, in string accsPassw);
		//
		// Descr: Переводит строку в дату в соответствии с форматом, заданным параметром fmt.
		//   Если fmt == datfDefault, то пытается распознать дату по содержимому строки (без гарантии успеха).
		//
		date   StrToDate(in string str, PpyDateFormat fmt);
		//
		// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
		//   тип тега равен tagID, строковое содержимое тега равно pattern (нечувствительное к регистру сравнение).
		// Returns:
		//   Массив идентификаторов найденных объектов
		//
		ILongList * SearchObjectsByTagStr(in PpyObjectIdent objType, in long tagID, in string pattern);
		//
		// Descr: Находит все идентификаторы объектов типа objType, удовлетворяющие условию:
		//   тип тега равен tagID, тип значения тега - строка, строковое содержимое тега В ТОЧНОСТИ равно pattern (нечувствительное к регистру сравнение).
		// Returns:
		//   Массив идентификаторов найденных объектов
		//
		ILongList * SearchObjectsByTagStrExactly(in PpyObjectIdent objType, in long tagID, in string pattern);
		//
		// Descr: Возвращает список складов, ассоциированных с конфигурацией обмена данными поставщика
		//
		ILongList * GetSupplInterchangeLocList(in long supplID); // @v9.9.5
	}
	//
	// Descr: Зарезервированные теги объектов
	//
	enum PpyTagReserved {
		pptagLotCLB           =  1, // Номер грузовой таможенной декларации (PPOBJ_LOT)
		pptagLotSerial        =  2, // Серийный номер (PPOBJ_LOT)
		pptagFloatSerial      =  3, // "Плавающие" серийные номера. Такие серийные номера не привязаны к
			// конкретным объектам, но используются для того, чтобы хранить произвольные строковые значения серий,
			// ассоциированные и целочисленными идентификаторами. Первоначальное применение - списание кассовых сессий
			// с серийными номерами, при этом таблица CGoodsLine хранить не сами номера, что было бы расточительно, а ссылки на них.
		pptagPersonPosRights  =  4, // Права агента на доступ к кассовым операциям.
		pptagPersonDOB        =  5, // Дата рождения //
		pptagBillCreateDtm    =  6, // Дата создания документа. В данный момент используется для отражения информации о начале создания заказа на КПК.
		pptagBillCreateDtmEnd =  7, // Дата создания документа. В данный момент используется для отражения информации о окончании создания заказа на КПК.
		pptagBillGpsCoord     =  8, // GPS координаты агента при начале создания заказа на КПК.
		pptagBillGpsCoordEnd  =  9, // GPS координаты агента при окончании создания заказа на КПК.
		pptagGuaGoodsRights   = 10, // Права глобальной учетной записи на доступ/изменение товара
		pptagGuaPersonRights  = 11, // Права глобальной учетной записи на доступ/изменение персоналий
		pptagGuaSCardRights   = 12, // Права глобальной учетной записи на доступ/изменение пластиковых карт
		pptagGuaSCardPrefix   = 13, // Префикс номеров персональных карт
		pptagLogManufTime     = 14, // Дата/время производства товара, оприходованного лотом.
		pptagGuaFilesRights   = 15, // Права глобальной учетной записи на доступ/изменение файлов
		pptagBillUUID         = 16, // UUID документа
		pptagGoodsKeywords    = 17, // Ключевые слова товара
		pptagBillKeywords     = 18, // Ключевые слова документа
		pptagGuaPGGTAG        = 19, // Символ тега приватной группы товара для данной глобальной учетной записи
		pptagWorkbookKeywords = 20, // Ключевые слова рабочих книг
		pptagWorkbookKwsyn    = 21, // Синонимы ключевых слов рабочих книг
		pptagWorkbookKwloc    = 22, // Локации, ассоциированные с ключевыми словами рабочих книг (пока - наименования городов)
		pptagCCheckJsUUID     = 23, // UUID сессии, создавшей JUNK-чек (для того, чтобы можно было быстро восстановить чек после сбоя сеанса)
		pptagGuaSaLocRights   = 24, // Права глобальной учетной записи на доступ/изменение к автономным адресам
		pptagGuaWbRights      = 25, // Права глобальной учетной записи на доступ/изменение к рабочим книгам
		pptagWorkbookLongcode = 26, // Длинный уникальный код записи рабочей книги (уникальность обеспечивается программно,
			// поскольку соответствующий индекс в таблице ObjTag дублируемый
		pptagBillAutocreation = 27, // Текстовая метка специальной структуры, помечающая автоматически созданные документы.
			// Основное назначение - предотвращение дублирования документов при автоматическом формировании.
		pptagBillOutercode    = 28, // Номер документа у контрагента
		pptagBillOuterdate    = 29, // Дата документа у контрагента
		pptagPersonENalogDest = 30  // Код назначения для отправки электронных налоговых документов (для главных организаций)
	}
	//
	//
	//
	interface IPapyrusSysJournal {
		ILongList * GetCreatedObjectListSince(in PpyObjectIdent objType, in date since);
		ILongList * GetModifiedObjectListSince(in PpyObjectIdent objType, in date since);
	}
	//
	// Descr: Интерфейс, обеспечивающий разбор выражений для нужд бухгалтерии
	//
	//
	//
	//enum PpyDL200MetaVars {
	//	mtvMainOrgName = "@mainorg",     // Полное наименование главной организации
	//  mtvMainOrgAddr = "@mainorgaddr", // Адрес главной организации
	//	mtvMainOrgINN  = "@mainorginn",  // ИНН
	//	mtvMainOrgOKPO = "@mainorgokpo", // ОКПО
	//	mtvDirector    = "@director",    // Директор
	//	mtvAccountant  = "@accountant",  // Гл. бухгалтер
	//	mtvDbName      = "@dbname",      // User-friendly наименование базы данных
	//	mtvDbSymb      = "@dbsymb"       // Символ базы данных
	// }

	interface IPapyrusDL200Resolver {
		long   SetPeriod(SDateRange * pPeriod);
		double Resolve(string rExpression);
		string ResolveName(string rMetaVar);
	}
	//
	// Descr: Основной интерфейс доступа к функциям объектов данных.
	//   Экземпляры объектов данных должны создаваться методом IPapyrusSession::CreateObject()
	//
	interface IPapyrusObject {
		//
		// Descr: Ищет запись объекта по идентификатору id. Поиск осуществляется непосредственно
		//   в базе данных (механизм кэширования Papyrus не используется).
		// ARG(id   IN): Идентификатор записи объекта, которую необходимо найти.
		// ARG(rec OUT): @#{vptr0} Указатель на буфер, по которому будет записано содержание
		//   записи в случае, если она будет найдена. Структура буфера определяется конкретным
		//   типом объекта. В этом файле намиенования таких структур начинаются с префикса "SPpyO_"
		//   и продолжаются наименованием типа объекта данных. Например: SPpyO_Article - структура
		//   записи статьи аналитического учета.
		//   Не следует делать предположений о формате хранения записи объекта данных, непосредственно
		//   в базе данных, на основании структуры, используемой в методах IPapyrusObject.
		// Returns:
		//   >0 - запись по идентификатору id найдена и присвоена по указателю rec
		//   <0 - запись по идентификатору id не найдена. Содержимое по указателю rec
		//        не изменилось.
		//   0  - ошибка. Не следует делать предположений о содержимом указателя rec
		//
		int    Search(long id, out PPYOBJREC rec);
		//
		// Descr: Ищет запись объекта по наименованию. При этом, смысл наименования трактуется //
		//   в зависимости от параметра kind.
		// ARG(text       IN): Строка, по которой ищется запись.
		// ARG(kind       IN): Вид поиска.
		//   0 - собственно, по наименованию
		//   1 - по коду (каждым типом объекта трактуется особо)
		// ARG(extraParam IN): Дополнительный параметр, необходимый для правильной интерпретации кода
		//   некоторыми типами объектов.
		// ARG(rec       OUT): Указатель, по которому будет присвоена запись объекта в случае успешного
		//   поиска.
		// Returns:
		//   >0 - объект найден
		//   <0 - объект не найден
		//    0 - ошибка
		//
		int    SearchByName(string text, int kind, long extraParam, out PPYOBJREC rec);
		//
		// Descr: Возвращает наименование объекта с идентификатором id. Если такой объект
		//   не найден, то возвращает строку вида "ID=xxx", где xxx - значение id.
		//   Реализация интерфейса в праве использовать внутреннее кэширование для поиска
		//   требуемого наименования. Как следствие, вызов этого метода может быть значительно
		//   быстрее, чем использование метода Search, но актуальность результата гарантирована
		//   быть не может (однако, вероятность ошибки ничтожна).
		// Returns:
		//   Если запись по идентификатору id найдена, то возвращает строку, содержащую наименование
		//   объекта. В противном случае, либо в случае ошибки, возвращает пустую строку.
		//
		string GetName(long id);
		//
		// Descr: Возвращает список строк, ассоциированных с идентификаторами и соответствующих
		//   наименованиям выбоки записей объекта данных, полученных на основе ограниченной фильтрации
		//   по аргументу extraParam. Каждый тип объектов данных имеет собственную спицифику использования //
		//   extraParam для ограниченной фильтрации записей. Соответствующие пояснения приведены в описании
		//   этих объектов.
		// Returns:
		//   Указатель на интерфейс IStrAssocList списка наименований объекта данных.
		//   0 - оишбка
		//
		IStrAssocList * GetSelector(long extraParam);
		//
		// Descr: Создает новую запись объекта в соответствии со структурой pRec.
		//   Особенности создания записей объектов конкретных типов описаны в комментариях
		//   к соответствующим компонентам.
		// ARG(pRec  IN): Указатель на структуру записи объекта. Реализация функции проверяет
		//   корректность тега структуры pRec->RecTag.
		// ARG(flags IN): Флаги создания записи. Сейчас используется только флаг 0x0001 означающий
		//   что функция НЕ ДОЛЖНА использовать внутреннюю транзакцию.
		// ARG(pID  OUT): Указатель на идентификатор созданной записи. При неудачном завершении функции
		//   значение по этому указателю не определено.
		// Returns:
		//   >0 - объект успешно создан
		//    0 - ошибка
		//
		int    Create(PPYOBJREC pRec, long flags, out long * pID);
		//
		// Descr: Изменяет запись объекта по идентификатору id в соответствии со структурой pRec.
		//   Особенности изменения записей объектов конкретных типов описаны в комментариях
		//   к соответствующим компонентам.
		// ARG(id    IN): Идентификатор изменяемого объекта.
		// ARG(flags IN): Флаги создания записи. Сейчас используется только флаг 0x0001 означающий
		//   что функция НЕ ДОЛЖНА использовать внутреннюю транзакцию.
		// ARG(pRec  IN): Указатель на структуру записи объекта. Реализация функции проверяет
		//   корректность тега структуры pRec->RecTag.
		// Returns:
		//   >0 - объект успешно изменен
		//    0 - ошибка
		//
		int    Update(long id, long flags, in PPYOBJREC rec);
	}
	//
	// Descr: Категории котировок
	//
	enum PpyQuotCat {
		qcUndef = 0,       // Инвалидное значение
		qcQuot = 1,        // Обычная ценовая котировка
		qcSupplDeal,       // Контрактная цена поставщика
		qcMatrix           // Товарная матрица
	}
	//
	// Descr: Признаки величины котировки
	//
	enum PpyQuotValTag {
		qvtUndef = 0,      // Значение не определено
		qvtAbs = 1,        // Абсолютное значение
		qvtPctCost,        // Процент наценки к цене поступления (отрицательное значение - скидка)
		qvtPctPrice,       // Процент наценки к цене реализации (отрицательное значение - скидка)
		qvtPctAdd,         // Процент наценки к разнице между ценой реализации и ценой поступления (отрицательное значение - скидка)
		qvtPctBase,        // Процент наценки к базовой котировке (базовая котировка должна быть определена как абсолютная величина)
		qvtDisabled        // Заблокированное значение - операция в заданном контексте недопустима
	}
	//
	// Descr: Идентификатор котировки
	//
	struct SPpyI_QuotIdent {
		PpyQuotCat Cat;    // Категория котировки
		long   LocID;      // Склад. Если 0, то для всех
		long   QuotKindID; // Вид котировки. Если Cat == qcSupplDeal || Cat == qcMarix, то этот идентификатор
			// должне быть либо нулевым, либо точно соотвествовать виду котировки, заданному для представления //
			// соответственно, контрактной цене или товарной матрице.
		long   CurID;      // Валюта
		long   ArID;       // Статья аналитического учета.
	}
	//
	// Descr: Значение котировки
	//
	struct SPpyI_Quot {
		PpyQuotCat Cat;    // Категория котировки
		long   LocID;      // Склад. Если 0, то для всех
		long   QuotKindID; // Вид котировки
		long   CurID;      // Валюта
		long   ArID;       // Статья аналитического учета
		PpyQuotValTag Tag; // Признак величины котировки
		double Val;        // Величина котировки
	}
	//
	// Descr: Значение контрактной цены
	//
	struct SPpyI_SupplDeal {
		double Val;        // Значение контрактной цены (0.0 - не определено)
		double UppBound;   // Макс отклонение вверх в % (0.0 - не определено)
		double LowBound;   // Макс отклонение вниз в % (0.0 - не определено)
		int    Disabled;   // Поставка товара при заданных условиях запрещена
	}
	//
	//
	//
	interface IPapyrusQuot {
		property {
			out long MatrixQuotKind;
			out long SupplDealQuotKind;
			out long SupplDealLowBoundQuotKind;
			out long SupplDealUppBoundQuotKind;
		}
		int    SetQuot(long goodsID, SPpyI_Quot * pQuot);
		SPpyI_Quot GetQuot(SPpyI_QuotIdent * pIdent, long goodsID);
		string QuotValToString(SPpyI_Quot * pQuot);
		SPpyI_Quot StringToQuotVal(string str);
		double GetQuotVal(SPpyI_QuotIdent * pIdent, long goodsID, double cost, double price);
		//
		// Descr: Возвращает ЭФФЕКТИВНУЮ принадлежность товара goodsID матрице по
		//   складу locID.
		// ARG(goodsID IN): Ид товара, для которого определяется принадлежность к матрице.
		// ARG(locID   IN): Склад, для которого определеяется принадлежность товара goodsID.
		//   Если locID == 0, то определяется принадлежность к матрице "все склады".
		// Returns:
		//   1 - товар принадлежит матрице по складу locID
		//   0 - товар не принадлежит матрице по складу locID
		//  -1 - товарная матрица не определена
		//
		int    GetMatrix(long goodsID, long locID);
		//
		// Descr: Устанавливает значение товарной матрицы для товара goodsID на складе locID.
		// ARG(goodsID IN): идент товара или обыкновенной товарной группы
		// ARG(locID   IN): идент склада. Если 0, то для всех складов
		// ARG(val     IN): значение матрицы.
		//  -1 - товар (группа товаров) не входит в матрицу по складу locID
		//   1 - товар (группа товаров) входит в матрицу по складу locID
		//   0 - для товара (группы товаров) значение по складу locID не определено
		// Returns:
		//   !0 - значение успешно установлено
		//    0 - ошибка
		//
		int    SetMatrix(long goodsID, long locID, int val);
		SPpyI_SupplDeal GetSupplDeal(long goodsID, long locID, long curID, long supplID);
		int    SetSupplDeal(long goodsID, long locID, long curID, long supplID, in SPpyI_SupplDeal * pDeal);
	}
	//
	//
	//
	enum PpyRtlPriceFlags {
		rtlpfPriceByQuot  = 0x0001, // Соответствует PPEquipConfig::fUseQuotAsPrice
		rtlpfUseQuotWTime = 0x0002, // Использовать котировки с установленным временем действия //
		rtlpfGetCurPrice  = 0x0004  // Выдавать текущую цену товара (а не по розничным котировкам)
	}

	struct SPpyI_RtlExtr {
		double Cost;
		double Price;
		double ExtPrice;
		date   CurLotDate;
		date   Expiry;
	}

	interface IPapyrusRtlPriceExtractor {
		int    Init(long locID, long extQuotKindID, PpyRtlPriceFlags flags);
		//
		// Descr: возвращает цену товара по следующим правилам:
		//   1. Если есть приоритетная котировка (ExtQuotKindID), то цена возвращается //
		//      в RetailExtrItem::ExtPrice, для других случаев в RetailExtrItem::Price.
		//   2. Если есть розничные котировки (акции), действующие на указанную дату,
		//      выбирается котировка с наивысшим рангом. При одинаковых рангах - первая найденная.
		//      Базовая котировка является розничной, если установлен флаг PPEquipConfig::fUseQuotAsPrice.
		//   3. При отсутствии котировок цена определяется по текущему лоту.
		// ARG(goodsID     IN):
		// ARG(pItem   IN/OUT): @{vptr}
		//
		int    GetPrice(long goodsID, SPpyI_RtlExtr * pItem);
	}
	//
	// Descr: Основной интерфейс контроллера анализа данных (КАД). Реализация этого интерфейса
	//   обычно представлена следующими компонентами (в скобках указаны префиксы наименований
	//   соответствующих компонентов):
	//     - структурой элемента выборки (SPpyVI_XXX)
	//     - опциональной структурой итогов выборки (SPpyVT_XXX)
	//     - интерфейсом фильтра (IPpyFilt_XXX)
	//     - классом реализации интерфейса фильтра (PPFiltXXX)
	//     - классом реализации собственно интерфейса IPapyrusView (PPViewXXX)
	//   Экземпляры КАД должны создаваться вызовом метода IPapyrusSession::CreateView().
	//
	interface IPapyrusView {
		//
		// Descr: создает экземпляр фильтра выборки и возвращает его интерфейс.
		//   В зависимости от особенностей класса, параметр param может определять
		//   предварительную инициализацию фильтра.
		//
		IUnknown * CreateFilt(long param);
		//
		// Descr: инициализирует объект в соответствии со свойствами фильтра pFilt.
		//   После успешной инициализации объект готов к обработке других методов интерфейса.
		//   Действительный интерфейс фильтра должен быть создан функцией CreateFilt() того же
		//   класса, заполнен, и передан в функцию Init().
		// Returns:
		//   >0 - инициализация объекта в соответствии с фильтром pFilt прошла успешно
		//   0  - ошибка
		// Performance:
		//   Время выполнения функции сильно зависит от условий, заданных фильтром, и конкретного
		//   типа КАД. При необходимости, реализация этого метода можжет строить временные таблицы.
		//
		int    Init(IUnknown * pFilt);
		//
		// Descr: Инициализирует итератор объекта. После вызова этой функции, последовательными
		//   вызовами NextIteration можно перебрать все записи выборки, полученной в соответствии
		//   с фильтром, установленным функцией Init().
		// ARG(order IN): определяет порядок сортировки построенной выборки данных. Возможные значения //
		//   этого аргумента зависят от конкретной реализации КАД. Значение 0 принимается всегда и
		//   не может быть отвергнуто как ошибочное.
		// Returns:
		//   >0 - итератор объекта инициализирован успешно
		//   0  - ошибка
		// Performance:
		//   Как правило, время выполнения этой функции невелико.
		//
		int    InitIteration(int order);
		//
		// Descr: Извлекает следующую запись выборки, построенной на основе фильтра, заданного
		//   в функции Init() и инициализированной вызовом InitIteration().
		// ARG(item OUT): Указатель на структуру, в которую записывается запись выборки данных.
		//   Действительная структура записи определяется конкретным типом КАД.
		// Returns:
		//   >0 - очередная запись успешно извлечена и присвоена по указателю item.
		//   <0 - больше нет записей для извлечения. Запись по указателю item не изменяется.
		//   0  - ошибка. Не следует далеть предположений относительно содержимого по указателю item.
		//
		int    NextIteration(out PPYVIEWITEM item);
		//
		// Descr: Возвращает счетчик итераций, изменяемый вызовами NextIteration().
		//   Возвращаемый счетчик несет чисто информационную (декоративную) нагрузку. Он никак не используется //
		//   при фактической работе методов InitIteration() и NextIteration(), но лишь изменяется ими.
		//   Кроме того, не все (но все же, подавляющее большинство) КАД корректно реализуют этот метод.
		//
		SIterCounter GetIterCounter();
		//
		// Descr: Возвращает итоговые значения выборки, инициализированной методом Init().
		// ARG(total OUT): Указатель на структуру, в которую записываются занчения итоговых
		//   показателей выборки. Действительная структура total определяется конкретным типом КАД.
		// Returns:
		//   >0 - функция выполнена успешно - итоговые данные занесены по указателю total.
		//   <0 - функция не поддерживается //
		//   0  - ошибка
		//
		int    GetTotal(out PPYVIEWTOTAL total);
	}
	//
	// Descr: Представление информации о текущем состоянии класса, реализующего
	//   интерфейс IPapyrusSession.
	//
	struct SPpySessionInfo {
		long   SessID;      // Ид сессии
		long   Flags;       //
		long   MainOrgID;   // Ид главной организации
		long   DbDivID;     // Ид раздела базы данных
		long   UserID;      // Ид пользователя //
		string DbName;      // Наименование базы данных
		string DbSymb;      // Символ базы данных
		string SysPath;     // Путь к словарю данных
		string DbPath;      // Путь к базе данных
		long   MainOrgDirector;   // Директор главной организации
		long   MainOrgAccountant; // Бухгалтер главной организации
	}
	//
	// Descr: Представление информации об одной базе данных системы
	//
	struct SPpyDatabaseInfo {
		long   ID;          // Ид базы данных. Этот идентификатор является неявным и нефиксированным.
			// Физически, он представляет номер позиции точки входа в базу данных, описанной в файле pp.ini
		long   Flags;       // Зарезервировано (0)
		long   Type;        // Зарезервировано (0)
		string Symb;        // Символ базы данных
		string Name;        // Дружественное пользователю наименование базы данных
		string Path;        // Путь к каталогу базы данных
		string SysPath;     // Путь к каталого словаря данных
	}
	//
	// Descr: Обеспечивает интерфейс рабочей сессии в базе данных. Предоставляет
	//   сервисы для авторизации в базе данных, доступа к объектам данных, контроллерам
	//   анализа данных (КАД) и др.
	//
	enum PpySpecClassIdent {
		spclsUtil            = 1,
		spclsRtlPriceExtr    = 2,
		spclsDL200Resolver   = 3,
		spclsQuotation       = 4,
		spclsAlcRepOpList    = 5,
		spclsPrcssrAlcReport = 6,
		spclsCCheck          = 7
	}

	interface IPapyrusSession {
		//
		// Descr: Возвращает список строк, идентифицирующий базы данных, доступные для авторизации.
		//   Для выполнения функции нет необходимости авторизоваться в какой-либо БД.
		//   После использования, возвращенный список должен быть разрушен обычным образом.
		// ARG(nameKind IN): Значение, определяющее, какую строку передавать в списке
		//   вместе с идентификатором. Возможные значения:
		//   0 - символ базы данных
		//   1 - дружественное наименование базы данных
		//   2 - путь к каталогу базы данных
		//   Любое другое значение интерпретируется как 0.
		// Returns:
		//   Указатель на интерфейс сформированного списка. В случае ошибки - 0.
		//
		IStrAssocList * GetDatabaseList(int nameKind);
		//
		// Descr: Возвращает начальную информацию о базе данных.
		//   Для выполнения функции нет необходимости авторизоваться в какой-либо БД.
		// ARG(id     IN): @#[1..] Идентификатор базы данных. Этот идентификатор является неявным и
		//   нефиксированным. Физически, он представляет номер позиции точки входа в базу данных,
		//   описанной в файле pp.ini. Самым естественным способом получения этого идентификатора
		//   видится извлечение его из списка, полученного вызовом IPapyrusSession::GetDatabaseList().
		// ARG(pInfo OUT): @#{vptr0} Указатель на структуру SPpyDatabaseInfo, по которому будет
		//   записана информация о базе данных.
		// Returns:
		//   >0 - информация о базе данных успешно извлечена и присвоена по указателю pInfo
		//   0  - ошибка
		// Performance:
		//   Реализация функции весьма медленная, но учитывая небольшое количество точек входа
		//   в базы данных, это - не представляется значительной проблемой.
		//
		int    GetDatabaseInfo(long id, SPpyDatabaseInfo * pInfo);
		//
		// Descr: Реализует авторизацию в базе данных.
		//   Конфигурация и ограничения прав доступа для сеанса, авторизованного через
		//   этот метод, действуют так же, как и для интерактивного сеанса системы.
		//   После завершения работы с сеансом необходимо выполнить функцию Logout().
		//   Несколько последовательных Login() без соответствующего вызова Logout()
		//   могут привести к тому, что следующее обращение к Login() завершится с ошибкой.
		// ARG(dbName   IN): символ базы данных, в которой необходимо авторизоваться.
		// ARG(userName IN): имя пользователя //
		// ARG(password IN): пароль, соответствующий имени userName.
		// Returns:
		//   >0 - авторизация успешно выполнена
		//   0  - ошибка
		// Performance:
		//   Дорогая функция с точки зрения времени исполнения и нагрузки на сеть. Не следует
		//   злоупотреблять частым обращением к этому методу.
		//
		int    Login(string dbName, string userName, string password);
		//
		// Descr: Завершает авторизованный сеанс работы в базе данных.
		//
		int    Logout();
		//
		// Descr: Возвращает наименование типа объекта данных objType.
		//   Например, вызов GetObjectTitle(ppoAccSheet) вернет строку "Таблица аналитического учета".
		// Returns:
		//   Наименование типа объекта данных. Если objType задан неверно, то вернет пустую строку.
		//
		string GetObjectTitle(PpyObjectIdent objType);
		//
		// Descr: Создает экземпляр объекта данных типа objType. После завершения работы с этим
		//   экземпляром объекта, он должен быть разрушен обычным образом.
		// Returns:
		//   Указатель на интерфейс созданного экземпляра объекта данных.
		//   В случае ошибки - 0.
		//
		IPapyrusObject * CreateObject(PpyObjectIdent objType);
		//
		// Descr: Создает экземпляр контроллера анализа данных (КАД) типа viewID.
		//   После завершения работы с этим экземпляром КАД, он должен быть разрушен обычным образом.
		// Returns:
		//   Указатель на интерфейс созданного экземпляра КАД.
		//   В случае ошибки - 0.
		//
		IPapyrusView   * CreateView(PpyViewIdent viewID);
		//
		// Descr: Создает экземпляр класса утилит.
		// После завершения работы с этим классом, он должен быть разрушен обычным образом.
		// Returns:
		//	Указатель на интерфейс созданного экземпляра объекта данных.
		//	В случае ошибки - 0.
		//
		IPapyrusUtil * CreateUtil();
		//
		// Descr: Создает экземпляр специально класса (например PPUtil, PPRtlPriceExtractor и т.д.)
		// После завершения работы с этим классом, он должен быть разрушен обычным образом
		// Returns:
		//  Указатель на интерфейс созданного экземпляра.
		//  В случае ошибки - 0.
		//
		IUnknown * CreateSpecClass(PpySpecClassIdent clsType);
		//
		// Descr: Инициализирует структуру с информацией о текущем состоянии сеанса.
		// ARG(pInfo OUT): {vptr0} Указатель на структура SPpySessionInfo в которой содержатся поля //
		//   информации о текущем состоянии сеанса.
		// Returns:
		//   >0 - информация извлечена успешно и присвоена по указателю pInfo.
		//   0  - ошибка
		//
		//
		int    GetStatusInfo(out SPpySessionInfo * pInfo);
		//
		// Descr: Выводит на экран диалог входа в базу данных, и в зависимости от параметров производит вход в эту БД
		//   После завершения работы с сеансом необходимо выполнить функцию Logout(), если параметр editOnly = 0.
		// ARG(dbName   IN|OUT): символ базы данных, в которой необходимо авторизоваться.
		// ARG(userName IN|OUT): имя пользователя //
		// ARG(password IN|OUT): пароль, соответствующий имени userName.
		// Returns:
		//   > 0 - редактирование парамтеров выполнено успешно (авторизация успешно выполнена, если параметр editOnly имеет значение 0)
		//   0  - ошибка
		long LoginDialog(out PPYHWND pParent, inout string * pDbName, inout string * pUserName, inout string * pPassword, in int editOnly);
	}
	//
	// Descr: Значения параметра подстановки товара
	//
	enum PpyVSubstGrpGoods {
		vsggNone = 0,             // Без подстановки
		vsggGeneric,              // Обобщение
		vsggGroup,                // Родительская группа (непосредственный родитель)
		vsggManuf,                // Производитель
		vsggDimX,                 // Размерность X классифицированного товара
		vsggDimY,                 // Размерность Y классифицированного товара
		vsggDimZ,                 // Размерность Z классифицированного товара
		vsggClsKind,              // Вид классифицированного товара
		vsggClsGrade,             // Сортность классифицированного товара
		vsggClsAddObj,            // Доп объект классифицированного товара
		vsggClsKind_Grade,        // Вид, сортность классифицированного товара
		vsggSuppl,                // Поставщик
		vsggBrand,                // Торговая марка
		vsggClsKind_Grade_AddObj, // Вид, сортность, доп объект классифицированного товара
		vsggClsKind_AddObj_Grade, // Вид, доп объект, сортность классифицированного товара
		vsggSupplAgent,           // Агент поставщика
		vsggLocation,             // Склад
		vsggDimW                  // @v8.6.1 Размерность W классифицированного товара
	}
	//
	// Descr: Значения параметра подстановки персоналии
	//
	enum PpyVSubstGrpPerson {
		vsgpNone = 0,       // Без подстановки
		vsgpCity,           // Город
		vsgpRegion,         // Регион
		vsgpCountry,        // Государство
		vsgpCategory,       // Категория персоналии
		//
		// За подстановку вместо персоналии агента по документу и транспортного брокера функция PPObjPerson::Subst не
		// отвечает. О правильности такой подстановки должен позаботиться класс, отвечающий
		// за перебор объектов, в которых необходимо осуществить подстановку.
		//
		vsgpBillAgent,      // Агент по документу
		vsgpVesselAgent,    // Транспортный брокер
		vsgpFirstRelation = 10000
		// 10001 начиная с этого значения, типы отношений персоналий
		// Строки соотвествующие типам отношений.
	}
	//
	// Descr: Значение параметра подстановки даты
	//
	enum PpyVSubstGrpDate {
		vsgdNone = 0,
		vsgdWeek,
		vsgdMonth,
		vsgdQuart,
		vsgdYear
	}
	//
	// Descr: Значения параметра подстановки персональной операции
	//
	enum PpyVSubstGrpPersonEvent {
		vsgpeNone = 0,
		vsgpeOp,            // Операция //
		vsgpePerson,        // Персоналия //
		vsgpeCntrAg         // Контрагент
	}
	//
	// Descr: Значения параметра подстановки документа.
	//
	enum PpyVSubstGrpBill {
		vsgbNone = 0,
		vsgbOp,
		vsgbDate,
		vsgbLocation,
		vsgbObject,
		vsgbObject2,
		vsgbStatus,
		vsgbAgent,
		vsgbPayer,
		vsgbDebtDim
	}
	//
	// @ModuleDecl(PPObjTag)
	//
	// Descr: Структура записи объекта данных PPObjTag (теги объектов)
	//
	struct SPpyO_Tag {
		long   RecTag;        // Const=ppoTag Метка структуры
		long   ID;            // Ид
		long   Flags;         // OTF_XXX
		long   LinkObjGrp;    // Дополнительный параметр для ссылочного объекта
		long   TagEnumID;     // Тип ссылочного объекта
		PpyOTagType TagDataType; // Тип значения тега
		long   ObjTypeID;     // Тип объекта, для которого определен тег
		long   TagGroupID;    // Группа, к которой относится тег
		string Name;          // Наименование
		string Symb;          // Символ
	}
	//
	// }
	//
	// @ModuleDecl(PPObjAccSheet)
	//
	// Descr: Структура записи объекта данных PPObjAccSheet (таблица аналитического учета)
	//
	struct SPpyO_AccSheet {
		long   RecTag;        // Const=ppoAccSheet Метка структуры
		long   ID;            // Ид
		long   BinArID;       // Статья для сброса остатков по закрываемым статьям
		long   CodeRegTypeID; // ИД типа регистрационного документа, идентифицирующего персоналию, соответствующую статье.
		long   Flags;         // ACSHF_XXX
		long   Assoc;         // @#{0L, PPOBJ_PERSON, PPOBJ_LOCATION, PPOBJ_ACCOUNT} Ассоциированный объект
		long   ObjGroup;      // Подгруппа ассоциированных объектов
		long   Reserve[4];    //
		string Name;          // Наименование
	}
	//
	// }
	//
	// @ModuleDecl(PPObjUnit)
	//
	// Descr: Структура записи объекта данных PPObjUnit (единицы измерения)
	//
	enum PpyOUnitFlags {
		SI       = 0x0001, // (S) Единица системы СИ
		Phisical = 0x0002, // (P) Физическая единица
		Trade    = 0x0004, // (T) Торговая единица (может не иметь однозначного физ. эквивалента)
		Hide     = 0x0008, // (H) Единицу не следует показывать
		IntVal   = 0x0010  // (I) Единица может быть только целочисленной
	}

	struct SPpyO_Unit {
		long   RecTag;      // Const=ppoUnit
		long   ID;          // Ид
		string Name;        // Наименование
		string Abbr;        //
		double BaseRatio;   // Соотношение
		PpyOUnitFlags  Flags; //
		long   BaseUnitID;    // ->Ref(PPOBJ_UNIT)
	}
	// }
	// @ModuleDecl(PPObjOprKind)
	//
	// Descr: Структура записи объекта данных PPObjAccSheet (таблица аналитического учета)
	//
	enum PpyOOprKindFlags {
		opkfNeedPayment    =  0x00000001, // Операция требует платежного документа
		opkfGReceipt       =  0x00000002, // Приход товара
		opkfGExpend        =  0x00000004, // Расход товара
		opkfBuying         =  0x00000008, // Номинал операции в ценах поступления //
		opkfSelling        =  0x00000010, // Номинал операции в ценах реализации  //
		opkfNoupdLotRest   =  0x00000020, // Товарная операция, не изменяющая остаток по лоту
		opkfAdvAcc         =  0x00000040, // Бухгалтерская операция, позволяющая документу содержать строки расширения //
		opkfProfitable     =  0x00000080, // Операция доходная //
		opkfOnOrder        =  0x00000100, // Операция продажи, допускающая продажу по заказу
		opkfFreight        =  0x00000200, // Операция поддерживает ввод данных фрахта
		opkfPckgMounting   =  0x00000400, // Расходная операция только для формирования пакетов
		opkfOrdExstOnly    =  0x00000800, // В заказах видны только те товары, которые есть на остатке
		opkfOrdReserve     =  0x00001000, // Резервирующий заказ
		opkfCalcSTaxes     =  0x00002000, // Считать налоги с продаж (НДС и акциз)
		opkfChargeNegPaym  =  0x00004000, // Начисление ренты интерпретировать как отрицательную оплату основного документа
		opkfAutoWL         =  0x00008000, // Автоматическая метка в документе
		opkfAttachFiles    =  0x00010000, // Присоединять файлы к документам
		opkfUsePayer       =  0x00020000, // Использовать поле PPBill::Payer плательщика
		opkfOrderByLoc     =  0x00040000, // @v5.5.9 Заказ привязан к складу (заказ от подразделения)
		opkfOutBalacCTurn  =  0x00100000, // Забалансовая бух проводка
		opkfExtAccturn     =  0x00200000, // Расширенная бух проводка
		opkfExtAmtList     =  0x00400000, // Операция поддерживает список доп сумм
		opkfRent           =  0x01000000, // С документом может быть ассоциирован договор ренты
		opkfNeedAck        =  0x02000000, // Документ требует подтверждения      //
		opkfNoCalcTiOrd    =  0x04000000, // Не расчитывать заказ товара в строках документа
		opkfReckon         =  0x08000000, // Операция используется как платежная //
		opkfBanking        =  0x10000000, // Банковский платежный документ
		opkfPassive        =  0x20000000, // Пассивная операция (не видна в списках выбора)
		opkfCurTransit     =  0x40000000, // Транзитная валютная операция        //
		opkfGoods          =  0x00000006  // (opkfGReceipt|opkfGExpend)
	}

	enum PpyOOprKindPrnFlags {
		opkfPrtIncInvc    = 0x00000001, // Входящая счет-фактура на предоплату
		opkfPrtNegInvc    = 0x00000002, // Счет-фактура с отрицательными суммами
		opkfPrtCheck      = 0x00000004, // Печатать чек по документу
		opkfPrtCheckTi    = 0x00000008, // Печатать чек по документу с товарными строками
		opkfPrtSrvAct     = 0x00000010, // Печатать акт выполненных работ
		opkfPrtBuying     = 0x00000020, // Печатать в ценах поступления //
		opkfPrtSelling    = 0x00000040, // Печатать в ценах реализации  //
		opkfPrtExtObj2Obj = 0x00000080, // В структуре GoodsBillBase вместо object подставлять extobject
		opkfPrtQCert      = 0x00000200, // Печатать сертификаты
		opkfPrtNBillN     = 0x00000400, // В первичном документе не печатать номер
		opkfPrtVaTax      = 0x00000800, // В накладной печатать колонки НДС
		opkfPrtInvoice    = 0x00001000, // Печатать счет-фактуру
		opkfPrtQCG        = 0x00004000, // Печатать сертификаты с товаром
		opkfPrtShrtOrg    = 0x00010000, // Печатать сокращ. наименование гл. организации
		opkfPrtCashOrd    = 0x00080000, // Печатать кассовый ордер
		opkfPrtSelPrice   = 0x00100000, // Печать цен в накладной на выбор
		opkfPrtNDiscnt    = 0x00800000, // Не печатать скидку в накладной
		opkfPrtPayPlan    = 0x02000000, // Печатать план платежей по документу
		opkfPrtLading     = 0x04000000, // Печатать товарно-транспортную накладную
		opkfPrtMergeTi    = 0x08000000, // Объединять товарные строки
		opkfPrtPLabel     = 0x10000000, // Печатать ценник
		opkfPrtBCodeList  = 0x20000000, // Печатать в накладной список штрихкодов
		opkfPrtQCertList  = 0x40000000  // Печатать список сертификатов
	}

	enum PpyOOprKindSubType {
		opsubtCommon       = 0, // Без подтипа (поведение определяется по типу операции и по флажкам)
		opsubtAdvanceRep   = 1, // Авансовый отчет
		opsubtRegister     = 2, // Регистровая общая проводка (автоматом снимает признак OPKF_EXTACCTURN)
		opsubtAssetRcv     = 3, // Приобретение основных средств (PPOPT_GOODSRECEIPT)
		opsubtAssetExpl    = 4, // Ввод в эксплуатацию основных средств (PPOPT_GOODSREVAL)
		opsubtWarrant      = 5, // Доверенность
		opsubtAssetModif   = 6, // Модификация основных средств
		opsubtDebtInvent   = 7, // Инвентаризация задолженности
		opsubtTradePlan    = 8  // План торговли (драфт-операции)
	}

	enum PpyOOprKindType {
		ppoptAccturn       = 1, // Бухгалтерский документ
		ppoptGoodsReceipt  = 2, // Приход товара
		ppoptGoodsExpend   = 3, // Расход товара
		//
		// Документы, имеющие тип PPOPT_PAYMENT должны иметь ссылку на
		// документ, который они оплачивают.
		//
		ppoptPayment       = 4, // Оплата
		//
		// Документы, имеющие тип PPOPT_GOODSRETURN должны иметь ссылку на
		// документ по которому товар был получен. Приходная это операция или
		// расходная, зависит от того, на какой документ ссылается возвратный док.
		//
		ppoptGoodsReturn   = 5, // Возврат товара
		ppoptGoodsReval    = 6, // Товарная переоценка
		ppoptGoodsOrder    = 7, // Товарный заказ
		ppoptGoodsModif    = 8, // Модификация товаров
		ppoptInventory     = 9, // Инвентаризаци
		//
		// Документы, имеющие тип PPOPT_CHARGE должны иметь ссылку на документ,
		// который оговаривает условия выплат. Поведение этих документов аналогично
		// поведению расширенных бух. проводок. Как правило, операции этого типа
		// должны иметь флаг OPKF_NEEDPAYMENT.
		//
		ppoptCharge       = 10, // Начисление
		ppoptGeneric      = 11, // Обобщение (коллекция операций)
		ppoptGoodsAck     = 12, // Acknowledge receipt of goods
		ppoptPool         = 13, // Пул документов
		ppoptCashSess     = 14, // Кассовая сессия //
		ppoptDraftReceipt = 15, // Draft goods receiption bill
		ppoptDraftExpend  = 16  // Draft goods expend bill
	}

	struct SPpyO_OprKind {
		long   RecTag;        // Const=ppoOprKind Метка структуры
		long   Tag;
		long   ID;
		string Name;
		int    Rank;
		long   LinkOpID;
		long   AccSheet2ID;
		long   OpCounterID;
		PpyOOprKindPrnFlags PrnFlags;
		long   DefLocID;
		int    PrnOrder;
		PpyOOprKindSubType  SubType;
		PpyOOprKindFlags    Flags;
		PpyOOprKindType     OpTypeID;
		long   AccSheetID;
	}
	//
	// Дополнительная информация об операции инвентаризации
	//
	enum PpyOInvOpFlags {
		invopfCostNominal       = 0x0001, // Номинал в ценах поступления (иначе в ценах реализации)
		invopfZeroDefault       = 0x0002, // Остаток по умолчанию нулевой
		invopfWroffWoDscnt      = 0x0004, // Списание без скидки
		invopfUsePacks          = 0x0008, // Использовать параметры упаковки при вводе
		invopfSelGoodsByName    = 0x0010, // Выбирать товары по полному наименованию, а не по сокращению
		invopfUseAnotherLocLots = 0x0020, // При списании излишков использовать информацию о лотах с других складов
		invopfInvByClient       = 0x0040, // Инвентаризация по клиенту (не списывается)
		invopfAccelAddItems     = 0x0080, // Ускоренное добавление позиций по штрихкоду
		invopfAsset             = 0x0100  // Инвентаризация по основным средствам (в обычную инвентаризацию
									      // основные средства не входят)
	}

	enum PpyOInvOpAmountCalcMethod { // Методы расчета цен
		oacmLIFO     = 0,
	    ooeacmFIFO     = 1,
	    ooeacmAVG      = 2
	}

	enum PpyOInvOpAutoFillMethod { // Методы автозаполнения //
		oafmPresents     = 0,
		ofmAll           = 1,
		ofmPrev          = 2,
		ofmByCurLotRest  = 3 // По текущим остаткам лотов
	}

	struct SPpyO_InvOpEx {
		long   RecTag;
		long   ID;                                   // ->Ref(PPOBJ_OPRKIND)
		long   WrDnOp;                               // Операция списания недостач
		long   WrDnObj;                              // Контрагент списания недостач
		long   WrUpOp;                               // Операция списания излишков
		long   WrUpObj;                              // Контрагент списания излишков
		PpyOInvOpAmountCalcMethod  AmountCalcMethod; // Метод расчета цен
		PpyOInvOpAutoFillMethod    AutoFillMethod;   // Метод автозаполнени
		PpyOInvOpFlags Flags;
	}
	//
	// Descr: Дополнительная запись инвентаризации задолженности
	//
	struct SPpyO_DebtInventOpEx {    // @persistent @store(PropertyTbl) @v5.0.7
		long   RecTag;
		long   ID;               // ->Ref(PPOBJ_OPRKIND)
		long   WrDnOp;           // Операция покрытия долга
		long   WrUpOp;           // Операция покрытия переплаты
		long   WrDnGoodsID;      // Товар, используемый для товарных документов покрытия долга
		long   WrUpGoodsID;      // Товар, используемый для товарных документов покрытия переплаты
		long   Flags;            //
	}
	//
	// Дополнительные опции зачетной операции
	//
	enum PpyOReckonOpFlags {
		roxfBegIsBillDt    = 0x0001, // Началом периода является дата платежного док-та
		roxfEndIsBillDt    = 0x0002, // Концом периода является дата платежного док-та
		roxfAutoPaym       = 0x0004, // Автоматически зачитывать платежные док-ты
		roxfCfmPaym        = 0x0008, // Подтверждать зачет платежного док-та
		roxfAutoDebt       = 0x0010, // Автоматически зачитывать долговые док-ты
		roxfCfmDebg        = 0x0020, // Подтверждать зачет долгового документа
		roxfThisLocOnly    = 0x0040, // Зачитывать документы только по тому же складу
		roxfByExtObj       = 0x0080, // Reckon by BillTbl::Object2
		                         	 // (forward reckoning only) if Object2 == 0, then use Object
		roxfReqalToObj     = 0x0100, // !automat then request user
                        			 // for alternate object for reckoning
		roxfThisAltObjOnly = 0x0200  // Зачитывать документы только по той же дополнительной статье документа
									 // Если доп статья нулевая, то зачитывать только на нулевые доп статьи
	}
	/* not implemented
	struct SPpyO_ReckonOpEx {
		SLAPI  PPReckonOpEx();
		int    SLAPI Init();
		PPReckonOpEx & SLAPI operator = (const PPReckonOpEx &);
		int    SLAPI GetReckonPeriod(LDATE debtDate, DateRange *) const;
		int    SLAPI GetDebtPeriod(LDATE paymDate, DateRange *) const;
		int    SLAPI PeriodToStr(char * pBuf, size_t bufLen) const;
		int    SLAPI StrToPeriod(string code);

		date  Beg;
		date  End;
		PpyOReckonOpFlags Flags;
		PPID   PersonRelTypeID; // @v5.3.4 Тип персонального отношения, используемый для коллективного зачета
	}
	*/
	//
	// Дополнительные опции драфт-операций
	//
	enum PpyODraftOpFlags {
		droxfCrEmptyBill  = 0x0001, // Вместо списания создавать пустой документ
		droxfUsePartStruc = 0x0002, // Списывать частичные структуры в документах списания //
		droxfWroffCurDate = 0x0004  // Документ списания формировать текущей системной датой
	}

	struct SPpyO_DraftOpEx {
		long   WrOffOpID;               // Операция списания                        //
		long   WrOffObjID;              // Контрагент для операции списания //
		long   WrOffComplOpID;          // Операция комплектации, для формирования остатков, списываемых операцией WrOffOpID
		PpyODraftOpFlags  Flags;
	}
	//
	// Дополнительные опции операции пула документов
	//
	enum PpyOBillPoolOpFlags {
		bpoxfOneOp         = 0x0001, // Объединять только по одной операции
		bpoxfOneDate       = 0x0002, // Объединять только по одной дате
		bpoxfOneObject     = 0x0004, // Объединять только по одному контрагенту
		bpoxfUniteAccturns = 0x0008, // Объединять бухгалтерские проводки
		bpoxfUnitePayments = 0x0010  // Объединять оплаты
	}

	/* Not implemented
	struct SPpyO_OprKind_BillPoolOpEx {
		PpyOBillPoolOpFlags  Flags;
		PPIDArray OpList;
	}
	*/
	//
	// IPapyrusObjOprKind
	//
	interface IPapyrusObjOprKind {
		int    GetDraftExData(long opID, out SPpyO_DraftOpEx * pData);
		//
		// Descr: Возвращает 1 если opID = getOpID, или opID принадлежит обобщению getOpID
		//
		int    BelongToGeneric(long opID, long genOpID);
	}
	// }
	// @ModuleDecl(PPObjArticle) {
	//
	// Descr: Структура записи объекта данных PPObjArticle (аналитическая статья)
	//
	struct SPpyO_Article {
		long   RecTag;          // Const=ppoArticle Метка структуры
		long   ID;              // Ид
		long   AccSheetID;      // @cr  ->PPOBJ_ACCSHEET Таблица статей
		long   Article;         // Субсчет или аналитическая статья //
		long   ObjID;           // @cr  Ассоциированный объект (== Article - для неассоциированных таблиц)
		int    Closed;          // @upd Признак того, что статья закрыта (пассивная)
		long   Flags;           // @cr @upd
			// 0x0002 - @upd "Стоп" (Запрет на ввод документов с этой статьей)
		long   Reserve[4];      //
		string Name;            // @cr @upd Наименование
		//
		// Соглашение с покупателем
		//
		long   CaFlags;         // @cr @upd Флаги
		date   CaBegDt;         // @cr @upd Дата заключения соглашения //
		date   CaExpiry;        // @cr @upd Дата окончания действия соглашения //
		double CaMaxCredit;     // @cr @upd Максимальный кредит
		double CaMaxDscnt;      // @cr @upd Максимальная скидка в %% (>= 100% - неограниченная)
		double CaDscnt;         // @cr @upd Обычная скидка в %%
		int    CaDefPayPeriod;  // @cr @upd Количество дней от отгрузки до оплаты по умолчанию
		long   CaDefAgentID;    // @cr @upd ->PPOBJ_ARTICLE  Агент, закрепленный за клиентом
		long   CaDefQuotKindID; // @cr @upd ->PPOBJ_QUOTKIND Вид котировки, закрепленный за клиентом
		long   CaReserve[4];
		string CaCode;          // @cr @upd Номер соглашения //
		//
		// Соглашение с поставщиком
		//
		long   SaFlags;         // @cr @upd Флаги
		date   SaBegDt;         // @cr @upd Дата заключения соглашения //
		date   SaExpiry;        // @cr @upd Дата окончания действия соглашения //
		int    SaDefPayPeriod;  // @cr @upd Количество дней от отгрузки до оплаты по умолчанию
		long   SaDefAgentID;    // @cr @upd ->PPOBJ_ARTICLE Агент, закрепленный за поставщиком
		int    SaDefDlvrTerm;   // @cr @upd Срок доставки товара в днях, начиная с даты документа закупки
		int    SaPctRet;        // @cr @upd Макс объем возврата товара по накладной в процентах от суммы накладной //
		long   SaReserve[4];
	}
	// }
	// @ModuleDecl(PPObjCashNode) {
	//
	// Descr: Структура записи объекта данных PPObjCashNode (кассовый узел)
	//
	struct SPpyO_CashNode {
		long   RecTag;     // Const=ppoCashNode Метка структуры
		long   ID;         // Ид
		long   DeviceType; // Тип устройства
		long   LocID;      // ->PPOBJ_LOCATION Ид склада
		long   CurSessID;  // ->PPOBJ_CSESSION Ид текущей кассовой сессии (для синхронных аппаратов)
		long   Flags;
		string Name;
	}
	// }
	// @ModuleDecl(PPObjCashNode) {
	//
	// Descr: Структура записи объекта данных PPObjQuotKind (Виды котировок товаров)
	//
	enum PpyUsingWithSCard {
		uwscDefault    = 0, // - сначала котировка, затем скидка по карте
		uwscSCardNQuot = 1, // - сначала скидка по карте, затем котировка
		uwscOnlyQuot   = 2, // - только котировка
		uwscOnlySCard  = 3  // - только скидка по карте
	}

	enum PpyOQuotKindFlags {
		qtfAbsDis         = 0x0001, // Скидка в абсолютном (денежном) выражении, иначе в %%
		qtfNotForBill     = 0x0002, // Котировка не используется при формировании цены в документе
		qtfPctDisOnCost   = 0x0004, // Скидка задана в процентах от цены поступления //
									// (исключает QUOTKF_ABSDIS). Задается, например, как '10P' : 10% от цены поступления     //
		qtfDscntOnGroups  = 0x0008, // @obsolete Привязать к данной котировке группы,
									// по которым котировки рассчитываются отдельно
		qtfExtPriceByBase = 0x0010, // Если вид котировки используется как дополнительная цена по документу
									// то за базу при расчете принимать учетную цену реализации, если флаг не установлен, то за базу
									// принимается чистая цена реализации (Price-Discount)
	  	qtfRetailed       = 0x0020  // Розничная котировка
	}

	struct SPpyO_QuotKind {
		long   RecTag;      // Const=ppoQuotKind Метка структуры
		long   ID;          // Ид
		string Name;        // Наименование вида котировки
		double Discount;    // Скидка
		string Symb;        // Символ
		SDateRange Period;  // Период действия розничной котировки
		int    BeginTm;     // Время начала действия розничной котировки
		int    EndTm;       // Время окончания действия розничной котировки
		int    Rank;        // Уровень приоритета котировки при показе в диалоге
			// редактирования или в тех случаях, когда все котировки не могут быть использованы
			// в виду ограничения на количество видов (например, при загрузке в StyloPalm).
			// Чем выше значение, тем выше вероятность использования этого вида котировки
			// по сравнению с другими.
		long   OpID;        // Вид операции, для которой определена котировка
		PpyOQuotKindFlags Flags; // Флаги (QUOTKF_XXX)
		long   AccSheetID;  // Таблица статей, с которыми ассоциируются значения котировок.
			// Если AccSheetID == 0, то полагается, что таблица статей GetSellAccSheet() (покупатели)
		int    DaysOfWeek;  // Дни недели действия розничной котировки (0x01 - Пн, ... , 0x40 - Вс)
		PpyUsingWithSCard UsingWSCard; // Совместное использование с дисконтными картами (uwscXXX)
	}
	// }
	// @ModuleDecl(PPObjGoodsTax) {
	//
	// Descr: Структура записи объекта данных PPObjGoodsTax (Налоговые группы товаров)
	//
	struct SPpyO_GoodsTax {
		long   RecTag;         // Const=ppoGoodsTax
		long   ID;             // Ид
		string Name;           // Наименование
		string Symb;           // Символ
		double VAT;            // Налоговая ставка
		double Excise;         // Акциз
		double SalesTax;       // Налог с продаж
		long   Flags;          // Флаги
		long   Order;          //
		long   UnionVect;      //
	}
	// }
	// @ModuleDecl(PPObjSalCharge) {
	//
	// Descr: Структура записи штатного начисления //
	//
	struct SPpyO_SalCharge {
		long   RecTag;         // Const=ppoSalCharge Метка структуры
		long   ID;             // Ид
		long   AmtID;          // @cr @upd ->Ref(PPOBJ_AMOUNTTYPE) Тип учетной суммы для этого начисления //
		long   CalID;          // @cr @upd ->Ref(PPOBJ_STAFFCAL)   Календарь, используемый для этого начисления //
		long   Flags;          // @cr @upd Флаги.
		string Name;           // @cr @upd Наименование
		string Symb;           // @cr @upd Символ
		string Formula;        // @cr @upd Формула для расчета суммы начисления //
	}
	// }
	// @ModuleDecl(PPObjStaffList) {
	//
	// Descr: Структура записи штатной должности
	//
	struct SPpyO_Staff {
		long   RecTag;         // Const=ppoStaff Метка структуры
		long   ID;             // Ид
		long   OrgID;          // @cr      ->Person.ID Работодатель
		long   DivisionID;     // @cr      ->Location.ID (LOCTYP_DIVISION)
		long   Rank;           // @cr @upd Ранг должности (чем меньше величина, тем выше иерархическое положение)
		long   Flags;          // @cr @upd Флаги
		long   FixedStaff;     // @cr      Зарезервированный ИД должности (PPFIXSTF_XXX)
		long   ChargeGrpID;    // @cr @upd ->Ref(PPOBJ_SALCHARGEGRP) Группа начислений, используемая для этой должности
		int    VacancyCount;   // @cr @upd Общее количество ставок
		int    VacancyBusy;    //          Занятое количество вакансий
		string Name;           // @cr @upd Наименование штатной должности
	}
	// }
	// @ModuleDecl(PPObjStyloPalm) {
	//
	// Descr: Структура записи КПК Palm
	enum PpyOPalmFlags {
		pofImpAscChecks = 0x0001, // Документы с устройства можно импортировать как чеки.
								  // Этот флаг не исключает возможности принимать документы с устройства и как обычные документы.
		pofGeneric      = 0x0002, // Обобщенная запись, определяющая //
								  // конфигурацию для нескольких устройств
		pofExpCliDebt   = 0x0004, // Экспортировать долги по клиентам
		pofExpSell      = 0x0008 // Экспортировать продажи
	}

	struct SPpyO_StyloPalm {
		long   RecTag;         // Const=ppoStyloPalm Метка структуры
		long   ID;
		string Name;
		long   LocID;          // ->Location.ID
		long   GoodsGrpID;     //
		long   OrderOpID;      // ->Ref(PPOBJ_OPRKIND)
		long   AgentID;        // ->Article.ID; Agent - owner of palm
		long   GroupID;        // ->Ref(PPOBJ_STYLOPALM) Группа, которой принадлежит устройство
			// Запись, порожденная от группы, наследует у группы следующие поля: LocID, OrderOpID,
			// Flags & (PLMF_IMPASCHECKS|PLMF_EXPCLIDEBT|PLMF_EXPSELL)
		PpyOPalmFlags Flags;
		long   FTPAcctID;
		long   Reserve4;
		string Path;
		string FTPPath;
	}
	// }
	//
	// @ModuleDecl(PPObjCurrency) {
	//
	struct SPpyO_Currency {
		long     RecTag;     // Const=ppoCurrency
		long     ID;         // @id
		string   Name;       // @name @!refname
		string   Symb;       //
		long     Flags;      //
		long     Code;       // Numeric currency code
	}

	struct PpyOCurrencyCfg {
		long   BaseCurID;      // Базовая валюта учета
		long   BaseRateTypeID; // Базовый тип курса
	}
	//
	// Interface PPObjCurrency
	//
	interface IPapyrusObjCurrency {
		//
		// Descr: Возвращает конфигурацию валютного учета
		//
		long GetConfig(out PpyOCurrencyCfg * pCfg);
		//
		// Descr: Возвращает валютный курс по отношению к базовой валюте
		//
		long GetRate(int32 curID, out double * pRate);
	}
	// }
	//
	// @ModuleDecl(PPObjGoodsClass) {
	//
	enum PpyOGoodsClassFlags {
		gcofUsePropKind    = 0x0001, // Использует свойство Kind
		gcofUsePropGrade   = 0x0002, // Использует свойство Grade
		gcofUsePropAdd     = 0x0004, // Использует свойство Add
		gcofUseDimX        = 0x0008, // Использует размерность X
		gcofUseDimY        = 0x0010, // Использует размерность Y
		gcofUseDimZ        = 0x0020, // Использует размерность Z
		gcofStdEditDlg     = 0x0100, // Используется стандартный, а не редуцированный диалог
			// редактирования товаров, относящихся к классу
		gcofDupCombine     = 0x0200, // Комбинации {PropKind, PropGrade, DimX, DimY, DimZ} могут дублироваться //
		gcofDisableFreeDim = 0x0400, // Запрет на ввод размерностей не перечисленных в списке
		gcofUseDimW        = 0x0800, // Использует размерность W
		gcofUsePropAdd2    = 0x1000  // Использует свойство Add2
	}
	//
	// Descr: Дескрипторы классификаторов товара, принадлежащего какому-либо классу
	//
	enum SPpyO_Gcd {
		gcdKind  = 1,
		gcdGrade = 2,
		gcdAdd   = 3,
		gcdX     = 4,
		gcdY     = 5,
		gcdZ     = 6,
		gcdW     = 7,
		gcdAdd2  = 8
	}
	//
	// Descr: Определение свойства классифицированного товара
	//
	struct SPpyO_GcProp {
		string Name;
		long   ItemsListID;
	}
	//
	// Descr: Определение размерности классифицированного товара
	//
	struct SPpyO_GcDim {
		string Name;
		long   Scale;
		// @note Список допустимых значений не представлен
	}

	struct SPpyO_GoodsClass {
		long   RecTag;         // Const=ppoGoodsClass Метка структуры
		long   ID;             // @id
		string Name;           // @name
		long   DefGrpID;       // Группа товара по умолчанию. Используется в случае создания товара только по параметрам расширения.
		long   DefUnitID;      // Торговая единица измерения по умолчанию
		long   DefPhUnitID;    // Физическая единица измерения по умолчанию
		long   DefPhUPerU;     // @unused
		long   DefTaxGrpID;    // Налоговая группа по умолчанию
		long   DefGoodsTypeID; // Тип товара по умолчанию
		PpyOGoodsClassFlags Flags; // @flags
		long   DynGenMask;     // Маска динамического обобщения. Флаги маски соответствуют
			// элементам перечисления (1<<(PPGdsCls::eXXX-1)). Если система видит обобщенный товар G с
			// параметрами расширения, соответствующими маске, эквивалентными некоторому товару X,
			// то считает, что X принадлежит G.
		string NameConv;        // Шаблон для формирования имени товара
		string AbbrConv;        // Шаблон для формирования сокращенного наименования товара
		string PhUPerU_Formula; // Формула для установки соотношения физических единиц измерения товара к торговым
		string TaxMult_Formula; // Формула для установки налогового мультипликатора товара
		string Package_Formula; // Формула для установки емкости упаковки поставки товара

		SPpyO_GcProp PropKind;
		SPpyO_GcProp PropGrade;
		SPpyO_GcProp PropAdd;
		SPpyO_GcProp PropAdd2;
		SPpyO_GcDim  DimX;
		SPpyO_GcDim  DimY;
		SPpyO_GcDim  DimZ;
		SPpyO_GcDim  DimW;
		//
		// @note Список формул не представлен
	}
	//
	// }
	// @ModuleDecl(PPObjGoods), @ModuleDecl(PPObjGoodsGroup) {
	//
	// Interface PPObjGoods
	//
	//
	// Descr: Структура записи Товара
	//
	enum PpyOGoodsFlags {
		gofINTVAL       = 0x00000001, // @transient Целочисленная единица измерения //
		gofUNLIM        = 0x00000002, // @transient Неограниченный ресурс
		gofODD          = 0x00000004, // @transient Нестандартный товар
		gofAUTOCOMPL    = 0x00000008, // @transient Автокомплект
		gofGENERIC      = 0x00000010, // Обобщенный товар
		gofTAXFACTOR    = 0x00000020, // ExtRec содержит ненулевой налоговый фактор
		gofPRICEWOTAXES = 0x00000040, // UC Цена реализации товара указана без всех операционных налогов
		gofEXTPROP      = 0x00000080, // Товар имеет запись расширенных свойств (PPGoodsPacket::P_ExtString)
		gofALTGROUP     = 0x00000100, // Альтернативная группа
		gofFOLDER       = 0x00000200, // Группа верхнего уровня //
		gofPASSIV       = 0x00000400, // Пассивный товар
		gofNODISCOUNT   = 0x00000800, // На товар не распространяется общая скидка
		gofEXCLALTFOLD  = 0x00001000, // Папка, объединяющая непересекающиеся альтернативные группы
		gofUNIQPCKGCODE = 0x00002000, // Уникальный код пакета
		gofDFLTPCKGTYPE = 0x00004000, // Тип пакета по умолчанию
		gofPCKG_AROWS   = 0x00008000, //
		gofPCKG_ANEWROW = 0x00010000, //
		gofASSETS       = 0x00020000, // @transient @inner Основные фонды
			// Проекция флага GTF_ASSETS типа, которому принадлежит товар
		gofWROFFBYPRICE = 0x00040000, // Списывать основное средство исходя из остаточной стоимости
		gofTRANSGLED    = 0x00080000, // @transient @inner Признак передачи в пакете структуры GoodsLotExtData
		gofVOLUMEVAL    = 0x00100000, // Объем упаковки поставки задается одним значением
		gofTRANSQUOT    = 0x00200000, // @transient @inner Пакет передачи предназначен для трансмиссии котировок
			// Сами товары не меняются. Не удаляются остутствующие в пакете, но присутствующие в базе котировки.
		gofTEMPALTGRP_  = 0x00400000, //
		gofUSEINDEPWT   = 0x00800000, // Операции по товару ведуться параллельно в торговых и физических единицах
		gofDYNAMIC      = 0x01000000, // Динамическая альтернативная группа
		gofHASIMAGES    = 0x02000000, // К товару присоединены картинки
		gofABBREQNAME   = 0x04000000, // @transient @inner Используется у элементов кэша для информации о том, что
			// сокращенное наименование эквивалентно полному.
		gofEXCLVAT      = 0x08000000  // @transient Наследуется от типа товара (GTF_EXCLVAT) при извлечении через кэш
	}
	enum PpyGseFlags {
		gsefMultMinShipm = 0x00000001 // @v8.6.8 MinShippmQtty одновременно определяет кратность отгужаемого количества
	}
	struct SPpyO_Goods {
		//
		// Основные поля //
		//
		long   RecTag;    // Const=ppoGoods (для товаров) и =ppoGoodsGroup (для Групп товаров) Метка структуры
		long   ID;
		long   Kind;
		string Name;
		string Abbr;
		long   ParentID;
		long   GoodsTypeID;
		long   UnitID;
		long   PhUnitID;
		double PhUPerU;
		long   ManufID;
		long   StrucID;
		long   TaxGrpID;
		long   WrOffGrpID;
		PpyOGoodsFlags Flags;
		long   GdsClsID;
		long   BrandID;
		long   DefBCodeStrucID;
		//
		// Поля расширения товара
		//
		long   GoodsClsID;
		long   KindID;
		long   GradeID;
		long   AddObjID;
		long   AddObj2ID;
		long   UniqCntr;
		//
		// Текстовое представление классификаторов товара
		//
		string KindText;    // kind
		string GradeText;   // grade
		string AddObjText;  // add1
		string AddObj2Text; // add2
		double X;
		double Y;
		double Z;
		double W;
		//
		// Размерности товара
		//
		long   Brutto;        // Масса брутто, кг (Если Package > 0, то масса упаковки поставки)
		long   Length;        // Габаритная длина упаковки поставки,  мм
		long   Width;         // Габаритная ширина упаковки поставки, мм
		long   Height;        // Габаритная высота упаковки поставки, мм
		double MinStock;      // Минимальный запас товара
		double Package;       // Емкость упаковки поставки (торговых единиц)
		double MinShippmQtty; // Минимальное количество
		int    ExpiryPeriod;  // Срок годности товара (дней).
		//
		// Дополнительные поля //
		//
		string Storage;       // A
		string Standard;      // B
		string Ingred;        // C
		string Energy;        // D
		string Usage;         // E
		string LabelName;
		PpyGseFlags GseFlags; // @v8.6.8
	}

	enum PpyOGoodsClassProperty {
		clspKind    = 0,
		clspGrade   = 1,
		clspAddObj  = 2,
		clspAddObj2 = 3
	}

	interface IPapyrusObjGoods {
		//
		// Descr: Возвращает список штрихкодов.
		// Returns:
		//   Указатель на интерфейс IStrAssocList списка штрихкодов.
		//   0 - ошибка
		//
		IStrAssocList * GetBarcodes(long goodsID);
		int    GetQuot(long goodsID, long quotKind, double * pQuot);
		IStrAssocList * GetQuotations(long goodsID);
		long   SearchByBarcode(string barcode, SPpyO_Goods * pGRec, int adoptSearching);
		long   SearchByArCode(long arID, string barcode, SPpyO_Goods * pGRec);
		string GetSingleBarcode(long goodsID);
		string GetArCode(long goodsID, long arID);
		string GetArCodeWQtty(int32 goodsID, int32 arID, int32 * pPack);
		int    SetArCode(long goodsID, long arID, string code);
		int    BelongToGroup(long goodsID, long grpID, long * pSubGrpID);
		//
		// Descr: Рассчитывает величину НДС в цене price товара goodsID при количестве qtty.
		// ARG(goodsID    IN): Идентификатор товара
		// ARG(qtty       IN): Количество единиц товара
		//   Количество и цена задаются раздельно из-за того, что некоторые налоги, включенные
		//   в цену, могут зависеть от количества, а не только от абсолютной суммы. Если в конкретном
		//   случае вы точно знаете, что такая зависимость исключена, то qtty можно устанавливать в 1
		//   а в price передавать полную сумму.
		// ARG(price      IN): Цена одной торговой единицы товара.
		// ARG(withoutVat IN): Если цена price задана без НДС, то этот параметр должен быть равен 1, иначе 0.
		// ARG(dt         IN): Дата, для которой рассчитывается значение. Если dt == 0,
		//   то расчет ведется на текущую дату.
		//   Значение даты может быть важно в случае,
		//   если налоговые группы в базе данных заданы с привязкой к периоду.
		// Returns:
		//   Величину НДС (на одну единицу), соответствующую цене price.
		// Note:
		//   Расчет НДС этой функцией может быть не точным в случае, если значение НДС
		//   зависит от лота, с которым товар поступил на предприятие.
		//
		double CalcVatSum(long goodsID, double qtty, double price, int withoutVat, date dt);
		//
		//
		//
		int    GetClassPropSymb(long goodsID, PpyOGoodsClassProperty clsProp, out string * pSymb);
		//
		// Descr: Рассчитывает остатки товара на определенную дату
		//
		double GetRest(long goodsID, long locID, date dt, long supplID);
		//
		// Descr: Функционал SearchByBarcode() плюс, если не нашел товар, то ищет его
		//		уже через SearchByCodeExt(). Соответственное, если товар весовой, то дополнительно
		//		возвращает количество.
		//
		int    SearchQttyByBarcode(string barcode, SPpyO_Goods * pGRec, double * pQtty, int adoptSearching);
		//
		// Descr: Изменяет атрибуты дополнительной информации товара. А именно:
		//   Brutto, Length, Width, Height, MinStock, Package, ExpiryPeriod
		//   Storage, Standard, Ingred, Energy, Usage, LabelName
		//   Не перечисленные в списке поля игнорируются функцией.
		//   Значение MinStock устанавливается без привязки к складу.
		//
		int    SetVad(long goodsID, SPpyO_Goods * pGRec);
		//
		// Descr: Специализированная функция, предназначенная для обработки сырых (поступивших из неизвестных источников)
		//   наименований товаров.
		//
		string ProcessName(string orgName, int flags);
	}
	//
	// Interface PPObjGoodsGroup
	//
	interface IPapyrusObjGoodsGroup {
		//
		// Descr: Возвращает список товарных групп, содержащихся в фильтре данной динамической альтернативной товарной группы.
		// Returns:
		//   Указатель на интерфейс IStrAssocList списка товарных групп.
		//   0 - altGrpID - не является динамической алтернативной группой, фильтр данной альтернативной группы не содержит групп.
		//
		IStrAssocList * GetGGroupsFromAltGrp(long altGrpID);
		//
		// Descr: Проверяет является группа динамической алтернативной группой
		// Returns:
		//   1 - является //
		//   0 - нет
		//
		int32  IsDynamicAlt(long grpID);
		//
		// Descr: Возвращает иерархию группы с идентификатором grpID.
		//   Иерархия возвращается в виде списка первый элемент которого соответсвует самому верхнему уровню иерархии,
		//   которой подчинена группа grpID.
		//   Сама группа grpID является последним членом списка //
		//
		IStrAssocList * GetHierarchy(long grpID);
		//
		// Descr: Возвращает ид. товарной группы, у которой Symbol соотвествует pCode
		//
		long SearchCode(string rCode);
		//
		// Descr: Возвращает все группы, которые являются подчиненными по отношению к parentGrpID
		//
		IStrAssocList * GetChildList(long parentGrpID);
	}
	//
	// }
	//
	// Зарезервированные типы персональных регистров
	//
	enum PpyO_RegTypeReserved {
		regtPASSPORT     =  1, // Паспорт
		regtREGFREE      =  2, // Свид частного предпринимателя //
		regtTPID         =  3, // ИНН
		regtOKONH        =  4, // ОКОНХ
		regtOKPO         =  5, // ОКПО
		regtBIC          =  6, // БИК (банковский идентификатор, бывший МФО)
		regtBNKCORRACC   =  7, // Корр сч банка
		regtCODE         =  8, // Код персоналии
		regtALBATROSCLID =  9, // Идентификатор клиента проекта альбатрос
		regtKPP          = 10, // Код причины постановки на налоговый учет налогоплательщика
		regtOKATO        = 11, // Код фискального органа по ОКАТО
		regtCERTORGCODE  = 12  // Код сертифицирующей организации
	}
	//
	// Descr: Структура регистрационного документа (или просто регистра)
	//
	struct SPpyO_Register {
		long   ID;             // Идентификатор регистра
		long   PsnID;          // Ид персоналии, к которой относится регистр
		long   PsnEventID;     // Ид персонального события, к которому относится регистр
		long   RegTypeID;      // Тип регистрационного документа
		date   Dt;             // Дата выпуска (начала действия) регистра
		long   RegOrgID;       // Ид регистрирующей организации
		string Serial;         // Серия регистра
		string Number;         // Номер регистра
		date   Expiry;         // Дата истечения срока действия регистра
		long   UniqCntr;       // @inner Внутрениий счетчик, обеспечивающий уникальность идентичных по серии/номеру регистров
		long   Flags;          // Битовые флаги
		long   LocID;          // Идентификатор локации, к которой относится регистр
			// @#{LocID^PsnID}
		long   SurID;          // Специальный суррогатный идент, используемый в алкогольной декларации
	}
	//
	// Descr: Компоненты структурированного адреса
	//
	enum PpyLocAddrPart {
		lapAddress = 1,       // Полная строка адреса
		lapCountry,           // Страна
		lapZip,               // Почтовый код
		lapLocalArea,         // Локальная область (район и т.д.)
		lapCity,              // Населенный пункт
		lapStreet,            // Улица
		lapHouse,             // Дом
		lapHouseAddendum,     // Дополнительная координата дома (корпус)
		lapCorp,              // @unused
		lapApart,             // Квартира (комната, офис)
		lapFloor,             // Этаж
		lapPostBox,           // Почтовый ящик
		lapAddendum,          // Дополнительная информация в строке адреса
		lapCityKind,          // Строка вида населенного пункта (город, село, станция и т.д.)
		lapLocalAreaKind,     // Строка вида локальной области (район, область и т.д.)
		lapStreetKind,        // Строка вида улицы (улица, площадь, проспект и т.д.)
		lapHouseKind,         // Строка вида здания (дом, строение и т.д.)
		lapHouseAddendumKind, // Строка вида доп координаты дома
		lapApartKind,         // Строка вида помещения (квартира, комната, офис и т.д.)
		lapFiasCityID,        // Идентификатор города в базе данных ФИАС
		lapFiasAddrID,        // Идентификатор адреса в базе данных ФИАС
		lapFiasHouseID        // Идентификатор дома в базе данных ФИАС
	}

	interface ILocAddrStruc {
		int    Recognize(string addr);
		string Get(PpyLocAddrPart partId);
	}
	//
	// @ModuleDecl(PPObjLocation)
	//
	// Descr: Структура записи Склада
	enum PpyOLocationFlags {
		locfVatFree    = 0x0001, // Операции по складу освобождены от НДС
		locfManualAddr = 0x0002, // Полный адрес задается в ручную //
		locfComparable = 0x0008  // Сравниваемый склад (обычно применяется в отношении магазинов для анализа данных)
	}

	enum PpyOLocationType {
		loctWarehouse = 1, // Склад | магазин
		loctWarePlace = 2, // Место хранения товара
		loctAddress   = 3, // Адрес персоналии
		loctDivision =  4  // Структурное подразделение организации
	}

	struct SPpyO_Location {
		long   RecTag;         // Const=ppoLocation Метка структуры
		long   ID;             // Идентификатор локации
		long   Counter;        // @inner Внутренний счетчик уникальности. Физического смысла не имеет.
		long   ParentID;       // ->Location.ID ИД родительского 'лемента
		string Name;           // Наименование
		long   Type;           // loctXXX Тип локации
		long   OwnerID;        // ->Person.ID ИД персоналии-владельца адреса
		PpyOLocationFlags Flags;
		long   CityID;         // ->World.ID ИД города
		long   RspnsPersonID;  // ->Person.ID Для складских позиций - ответственное лицо
		string Code;           // Код локации
		string ZIP;            // Почтовый индекс
		string Address;        // Строка адреса (без города и ZIP)
		string FullAddr;       // Полный адрес
		double Latitude;       // @v8.6.8 Географическая широта
		double Longitude;      // @v8.6.8 Географическая долгота
	}

	interface IPapyrusObjLocation {
		string GetAddress(long locID);
		long   SearchByCode(string code, PpyOLocationType locType, SPpyO_Location * pRec);
		string GetDlvrAddrExtFld(long locID, long extFldID);
		long   SetDlvrAddrExtFld(long locID, long extFldID, string rValue);
		//
		// Descr: Возвращает запись регистра, привязанного к локации locID.
		// ARG(locID IN): Ид локации, для которой необходимо получить регистр.
		// ARG(regType IN): Ид типа регистрационного документа.
		// ARG(actualDate IN): Дата актуальности регистра. Если 0, то игнорируется.
		// ARG(inheritFromPerson IN): Признак, предписывающий получать значение регистра от персоналии-владельца
		//   локации, если у локации такой регистр отсутствует.
		// ARG(pReg OUT): Указатель на структуру регистра.
		// Returns:
		//   <0 - регистр с заданным типом не может быть получен (нет ни у локации, ни у владельца, если inheritFromPerson != 0)
		//   0  - ошибка
		//   1  - регистр получен у локации
		//   2  - регистр получен у персоналии-владельца локации
		//
		int    GetRegisterD(long locID, long regType, date actualDate, int inheritFromPerson, SPpyO_Register * pRec);
	}

	struct SPpyO_FiasAddr {
		long   ID;
        long   ParentID;
        int    Level;
        string AddrUuid;
        string RecUuid;
        string PostalCode;
        string Name;
        string OfcName;
        string ShortDescr;
        string Descr;
	}

	struct SPpyO_FiasHouse {
		long   ID;
		long   AddrID;
		string HouseUuid;
		string RecUuid;
		string PostalCode;
		string HouseN;
		string BuildN;
		string StructN;
	}

	interface IFias {
        int    SearchAddr(in long id, out SPpyO_FiasAddr * pRec);
        int    SearchHouse(in long id, out SPpyO_FiasHouse * pRec);
        int    SearchAddrByGuid(in string pGuidStr, out SPpyO_FiasAddr * pRec);
        int    SearchHouseByGuid(in string pGuidStr, out SPpyO_FiasHouse * pRec);
	}
	//
	// ModuleDecl(PPObjPerson)
	//
	// Descr: Структура записи персоналии
	//
	enum PpyOCashierFlags {
		cifCashier  = 0x0001,
		cifModified = 0x0002
	}

	struct SPpyO_CashierInfo {
		string Password;     // Пароль кассира
		long   Rights;	     // Права  кассира
		PpyOCashierFlags Flags;
	}

	enum PpyOPsnUpdateFlags {
		psnupdfDontChgImgFlag  = 0x0001, // Функция PPObjPerson::PutPacket не должна изменять флаг GF_HASIMAGES
		psnupdfDontChgStaffAmt = 0x0002  // Функция PPObjPerson::PutPacket не должна изменять список штатных сумм
	}

	struct SPersonReq {
		long     Flags;
		string   Name;
		string   ExtName;
		string   Addr;             // Юридический адрес
		string   RAddr;            // Фактический адрес
		string   Phone1;           // Список телефонов через ';'
		string   TPID;             // @russia код ИНН
		string   KPP;              // @russia код КПП
		string   OKONF;            // @russia код ОКОНФ
		string   OKPO;             // @russia код ОКПО
		long     SrchRegTypeID;    // Тип регистра для поиска. Если для персоналии не определено ни одного
			// поискового регистра, то SrchRegTypeID = 0 (даже если для какого-либо из видов, которому принадлежит
			// персоналии такой тип регистра определен).
		string   SrchCode;         // Номер поискового регистра (тип этого регистра прописан в виде персоналии).
			// Если персоналия относится к нескольким видам, то тип поискового регистра берется из первого
			// встреченного вида, которому принадлежит персоналия и для которого определен тип поискового регистра.
			// BnkAcctData BnkAcct;
		string   Memo;
	}
	//
	// Descr: Интерфейс к объекту, управляющему персоналиями
	//
	interface IPapyrusObjPerson {
		//
		// Descr: Извлекает адрес персоналии.
		// ARG(personID IN): Идентификатор персоналии
		// ARG(getRLoc  IN): Если !0, то возвращает фактический адрес, иначе - юридический
		// ARG(pLoc    OUT): Указатель, по которому присваивается структура адреса.
		//
		int    GetLoc(long personID, int getRLoc, SPpyO_Location * pLoc);
		int    GetPersonReq(long personID, SPersonReq * pReq);
		//
		// Descr: Возвращает специфическую информацию о кассире (для загрузки в кассовые модули)
		//
		int    GetCashierInfo(long personID,  SPpyO_CashierInfo * pCshrInfo);
		//
		// Descr: Перебирает идентификаторы видов, к которым относится персоналия personID.
		//
		int    EnumKinds(long personID,     long * pIdx, long * pKindID);
		//
		// Descr: Перебирает персоналии, связанные с персоналией personID отношением relTypeID.
		//   Этот вызов должен осуществляться в цикле. Первый вызов должен содержать
		//   указатель pRelPersonID на ноль.
		// ARG(personID         IN): ИД персоналии, для которой ищутся связанные персоналии
		// ARG(relTypeID        IN): тип персонального отношения (ppoPersonRelType)
		// ARG(reverse          IN): если !0, то перебираются обратные отношения. То есть,
		//   отношения *pRelPersonID -> personID.
		// ARG(pRelPersonID IN/OUT): указатель на персоналию, связанную с personID отношением relTypeID.
		// Returns:
		//   >0 - найдено очередная персоналия связанная с personID отношением relTypeID
		//   <0 - больше нет ни одной персоналии, связанной с personID отношением relTypeID
		//   0  - ошибка
		// Snippet:
		//   long rel_person_id = 0;
		//   while(EnumRelations(person_id, rel_type_id, 0, &rel_person_id) > 0) {
		//       // ...
		//   }
		//
		int    EnumRelations(long personID, long relTypeID, long reverse, inout long * pRelPersonID);
		int    EnumRegisters(long personID, long * pIdx, long * pRegID);                     // Список регистров
		int    EnumDlvrLocs(long personID,  long * pIdx, SPpyO_Location * pLoc);             // Список адресов доставки
		int    EnumELink(long personID,     long * pIdx, long * pELinkID);                   // Список электронных адресов
		int    EnumTags(long personID,      long * pIdx, long * pTagID);                     // Список тегов
		int    EnumBankAccts(long personID, long * pIdx, long * pBnkAcctID);                 // Список банковских счетов
		//  EnumStaffAmtEntry(long personID, uint * pIdxs, out *);                        // Список штатных сумм
		long   GetPersonByLocID(int32 locID, long personKindID);                            // Возвращает ID персоналии у которой адрес locID
		//
		// Descr: Проверяет принадлежит-ли персоналия personID к виду kindID
		//
		int    IsBelongToKind(long personID, long kindID);
		//
		// Descr: Форматирует регистр типа regTypeID персоналии personID в соотвествии со
		//   строкой формата, определенной для этого типа регистра.
		//
		string FormatRegister(long personID, long regTypeID);
		//
		// Descr: Возвращает номер регистрационного документа типа regType персоналии peresonID
		//
		string GetRegNumber(long personID, long regType);
		//
		//
		//
		int    IsTagAssigned(long personID, long tagID);
		//
		//
		//
		string FormatTag(long personID, long tagID);
		//
		// Descr: Ищет персоналии с заданным типом регистра и номером
		//   возвращает список персоналий
		//
		IStrAssocList * GetListByRegNumber(long regTypeID, long kindID, string rSerial, string rNumber);
		long   SetRegNumber(long psnID, long regTypeID, string rNumber);
		long   SetTag(long psnID, long tagID, string rValue);
		//
		// Descr: Возвращает запись регистра
		//
		int    GetRegister(long psnID, long regType, SPpyO_Register * pRec);
		//
		// Descr: Если персоналия имеет юридический статус - Физическое лицо, то возвращает 1, иначе 0
		//
		int    IsPrivate(long psnID);
		//
		string GetRegNumberD(long personID, date actualDate, long regType);
		int    GetRegisterD(long psnID, long regType, date actualDate, SPpyO_Register * pRec);
		IStrAssocList * GetRegList(long psnID, long regType);
		int32  EnumRegisters2(long personID, long regType, long * pIdx, SPpyO_Register * pRegRec);
	}

	struct SPpyO_Person {
		long   RecTag;          // Const=ppoPerson Метка структуры
		long   ID;
		string Name;
		long   Status;
		long   MainLoc;         // ID Юридического адреса
		long   Flags;
		long   RLoc;            // ID фактического адреса
		long   Division;
		long   Position;
		long   CatID;
		string Memo;
		PpyOPsnUpdateFlags UpdFlags; // Флаги, определяющие правила изменения некоторых полей
		string ExtString;
	}
	// }
	// @ModuleDecl(PPObjBill)
	//
	// Descr: Структура записи Документа
	//
	enum PpyOBillFlags {
		bofTotalDiscount         = 0x00000001,   // Скидка задана на весь документ
		bofFreight               = 0x00000002,   // Документ содержит данные по фрахту
		bofNeedPayment           = 0x00000004,   // Требует платежного документа
		bofPayout                = 0x00000008,   // Документ оплачен
		bofGReceipt              = 0x00000010,   // Приход товара
		bofGExpend               = 0x00000020,   // Расход товара
		bofGReval                = 0x00000200,   // Переоценка товара
		bofGModif                = 0x00008000,   // Модификация товара
		// @#{bofGReceipt^bofGExpend^bofGReval^bofGModif}
		bofGoods                 = 0x00008230,
		bofShippedBILLF_SHIPPED  = 0x00000040,   // Товар по документу отгружен
		bofNoLoadTrfr            = 0x00000080,   // @transient При загрузке и обработке документа не
			// следует загружать товарные строки
		bofClosedOrder           = 0x00000100,   // Закрытый заказ
		bofWritedOff             = 0x00000100,   // Списанный драфт
		//                       = 0x00000200, occupied
		bofCash                  = 0x00000400,   // Кассовый документ
		bofCheck                 = 0x00000800,   // Признак пробитого чека
		bofNoAturn               = 0x00001000,   // Док без бух. проводок
		bofWhiteLabel            = 0x00002000,   // Спец. метка
		bofExtra                 = 0x00004000,   // Существует дополнительная запись
		//                       0x00008000 occupied
		bofNegInvoice            = 0x00010000,   // Этот флаг используется только в
			                                     // в структуре PPALDD GoodsBillBase и порожденных для внутренней индикации
			                                     // того, что счет-фактуру следует печатать с отрицательными суммами
		bofRmvExcise             = 0x00020000,   // Скидкой снят налог с продаж
		bofRent                  = 0x00040000,   // С документом ассоциирован договор ренты
		bofReckon                = 0x00080000,   // Зачетный документ оплаты
		bofBanking               = 0x00100000,   // Банковский платежный документ
		bofFixedAmounts          = 0x00200000,   // Суммы по документу
                 			                     // зафиксированы и не пересчитываются по товарным строкам
		bofCSessWroff            = 0x00400000,   // Документ списания кассовой сессии
		bofPrintInvoice          = 0x00800000,   // @transient Спец флаг, информирующий функцию
			                                     // заполнения данных для печати документа, что печаться будет счет-фактура.
			                                     // Видимо в дальнейшем этот флаг будет упразднен.
		bofAdvanceRep            = 0x01000000,   // Авансовый отчет
		bofTggLexcsnPrice        = 0x02000000,   // Налог с продаж по документу установлен без изменения цены
		bofRecomplete            = 0x04000000,   // @#{bofRecomplete&bofGModif} рекомплектация  //
                       			                 // Этот флаг устанавливается, если в документ модификации вставляется товарная строка, имеющая //
			                                     // признак рекомплектации (bofMofid|PPTFR_ACK|PPTFR_REVAL). Такая строка может быть удалена из //
			                                     // документа только последней, после чего флаг BILLF_RECOMPLETE снимается                      //
		bofTSessWroff            = 0x08000000,   // Документ списания технологической сессии
		bofCDfctWroff            = 0x10000000,   // Документ сформирован на основе дефицита по кассовой сессии
		bofTDfctWroff            = 0x20000000    // Документ сформирован на основе дефицита по техн сессии
	}

	enum PpyORentFlags {
		rofClosed  =   0x0001, // Закрытый договор
		rofPercent =   0x0010  // Процентные начисления по ренте.
	}

	struct SPpyO_Bill {
		//
		// Основные поля документа
		//
		long    RecTag;         // Const=ppoBill Метка структуры
		long    ID;
		string  Code;
		date    Dt;
		long    BillNo;
		date    DueDate;
		long    OpID;
		long    StatusID;
		long    UserID;
		long    MainOrgID;
		long    LocID;          // ИД склада
		long    Object;
		long    Object2;
		long    CurID;
		double  CRate;
		double  Amount;
		long    LinkBillID;
		PpyOBillFlags Flags;
		long    Flags2;
		long    SCardID;
		string  Memo;
		//
		// Дополнительные поля документа
		//
		long   PayerID;            // ->Article.ID Плательщик
		long   AgentID;            // ->Article.ID Агент
		string InvoiceCode;
		date   InvoiceDate;
		string PaymBillCode;       // Номер платежного документа (для печати в счете-фактуре)
		date   PaymBillDate;       // Дата  платежного документа (для печати в счете-фактуре)
		int    Ft_STax;            // (0 - ignored, <0 - off, >0 - on)
		long   CreatorID;          // Критерий фильтрации по пользователю, создавшему документ
		long   ExtPriceQuotKindID; // Вид котировки, используемый для печати дополнительной цены в накладных
		long   DlvrAddrID;         // ->Location.ID Адрес доставки из Фрахта
		//
		// Условия ренты
		//
		date   PeriodLow;          // Период действия ренты
		date   PeriodUpp;          // Период действия ренты
		int    Cycle;              // Период цикла начисления PRD_XXX (SLIB.H)
		double Percent;            // Годовой процент начисления (используется если Flags & RENTF_PERCENT) //
		double PartAmount;         // Частичная сумма начисления (на каждый период) //
		PpyORentFlags RentFlags;
		long   ChargeDayOffs;      // Смещение даты начисления (в днях)
		//
		// Остальные поля //
		//
		// Следующее поле используется для указания того, в каких ценах
		// следует выводить документ на печать или на экспорт.
		// 1 - в ценах поступления (cost),
		// 2 - в ценах реализации (price-discount),
		// other - в обеих ценах (номинал по умолчанию)
		//
		int    OutAmtType;
		long   QuotKindID;   // Вид котировки, применяемый в документе. В базе данных не сохраняется. Актуально только во время одной сессии редактирования документа.
		long   OprType;
		long   AccSheet;
		long   Counter;
		long   PaymBillID;   // Платежный документ (зачеты). Заполняется при загрузке документа из БД функцией PPObjBill::ExtractPacket
		long   CSessID;      // Кассовая или технологическая сессия, которую списывает документ
		long   SampleBillID; // Документ, по образцу которого создается this документ
	}
	//
	// IPapyrusObjBill
	//
	enum PpyOTrfrItemFlags {
		pptfrReceipt      = 0x00000001, // Строка генерирует запись лота
		pptfrUniteIntr    = 0x00000002, // Межскладскую передачу проводить одним документом по обоим складам
		pptfrSelling      = 0x00000004, // Операция в ценах реализации, иначе в ценах поступления //
		//
		// Временный флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
		// установить флаг LOTF_ORDRESERVE для создаваемого лота
		//
		pptfrOrdReserve   = 0x00000008,
		//
		// Временный флаг, заставляющий функции Transfer::AddItem и Transfer::UpdateItem
		// изменить признак Closed лота и установить (снять) флаг LOTF_CLOSEDORDER
		//
		pptfrCloseOrder   = 0x00000010,
		//
		// Признак того, что элемент был успешно добавлен в БД во время транзакции.
		// По этому признаку в случае сбоя проводки других строк можно будет
		// определить, что элемент фактически добавлен не был, хотя и имеет признаки
		// проведенного (RByBill != 0).
		//
		pptfrDirty        =  0x00000020, // @transient
		pptfrReval        =  0x00000040, // Признак переоценки
		//
		// Флаг PPTFR_ONORDER проставляется в строке товарного документа
		// на продажу товара если эта строка покрывает (частично, полностью, либо
		// перекрывает) строку ордера. При этом в структуре PPTransferItem
		// используется поле OrdLotID (CorrLoc считается равным нулю).
		//
		pptfrOnOrder      = 0x00000080,
		pptfrOrder        = 0x00000100, // Строка заказа. При этом GoodsID < 0 и строка порождает лот (Flags & PPTFR_RECEIPT).
		pptfrShadow       = 0x00000200, // Проставляется в строках теневого документа. При этом GoodsID < 0.
		pptfrForceLotID   = 0x00000400, //
		//
		// Флаг PPTFR_FORCESUPPL при определении поставщика для генерируемого лота
		// заставляет считаться с полем PPTransferItem::Suppl, установленным до
		// вызова PPObjBill::TurnPacket или PPObjBill::UpdatePacket. Если этот
		// флаг не установлен, то функция PPTransferItem::InitBillConstrains, при определенных условиях,
		// может инициализировать поле PPTransferItem::Suppl в значение BillTbl::Rec::Object.
		//
		pptfrForceSuppl   = 0x00000800,
		pptfrUnlim        = 0x00001000, // Неограниченный ресурс
		pptfrOddGoods     = 0x00002000, // Товар нестандартного типа
		//
		// Два взаимоисключающих флага. Соответствуют приходу и расходу товара
		// соответственно. До @v1.10.1 знак поля Quantity однозначно определялс
		// видом операции (т.е. все строки одного документа имели это поле одного
		// знака). С вводом операции модификации товаров один документ может
		// содержать строки с положительным и отрицательным полем Quantity.
		// Ради сохранения обратной совместимости придется обрабатывать ситуацию,
		// когда оба флага не установлены, однако, начиная с @v1.10.1 эти флаги
		// обязательно будем устанавливать во всех строках (если конечно строка
		// влечет изменение остатка).
		//
		// Устанавливаться эти флаги должны только функциями инициализации:
		//  PPTransferItem::PPTransferItem, PPTransferItem::Init,
		//  PPTransferItem::InitShadow.
		// Правильнее всего для выяснения знака будет пользоваться функцией
		// PPTransferItem::GetSign().
		//
		pptfrPlus         = 0x00004000, // Поступление товара
		pptfrMinus        = 0x00008000, // Расход товара
		//
		// @v1.10.1 Модификация товара.
		// @v3.9.10 См. примечание к PPTFR_PCKG
		// @v4.0.11 См. примечание к PPTFR_ASSETEXPL
		//
		pptfrModif        = 0x00010000,
		pptfrAutocompl    = 0x00020000, // Автокомплектация //
		//
		// Флаг PPTFR_QUOT устанавилвается тогда, когда цена (вместе со скидкой)
		// строки указана по котировке. В этом случае установка общей скидки на
		// документ не влечет изменение чистой цены (Price - Discount) по этой
		// строчке.
		//
		pptfrQuot         = 0x00040000, // Цена установлена по котировке
		pptfrRmvExcise    = 0x00080000, // Со строчки скидкой снят акциз
		pptfrAck          = 0x00100000, // Подтверждение
		pptfrNodiscount   = 0x00200000, // На строку не распространяется общая скидка
		pptfrCostWoVat    = 0x00400000, // Цена поступления задана без НДС
		pptfrCostWSTax    = 0x00800000, // Цена поступления задана с налогом с продаж
		//
		// Package operation (if PPTFR_RECEIPT, then generates package)
		// Если флаги PPTFR_PCKG и PPTFR_MODIF установлены одновременно, то
		// это означает операцию формирования пакета из существующих остатков
		// (то есть в расходной операции). При этом функция PPTransfer::Init()
		// устанавливает флаг PPTFR_RECEIPT и (посредством функции
		// PPTransferItem::SetSign) PPTFR_PLUS.
		// В этом случае компоненты пакета получают признак PPTFR_UNITEINTR
		// и генерируют зеркальные операции для присвоения пакету лотов.
		//
		pptfrPckg         = 0x01000000,
		pptfrPckgGen      = 0x02000000, // Row of component of package
		pptfrFixModifCost = 0x04000000, // @v5.1.1 Цена поступления строки модификации фиксирована.
								        // Для такой строки не осуществляется пересчет цены поступления //
		pptfrIndepPhQtty  = 0x08000000, // @v5.1.5 Строка учитывает операцию в торговых и в физических единицах независимо
		pptfrPriceWoTaxes = 0x10000000, // Цена реализации задана без налогов
		pptfrDraft        = 0x20000000, // Строка draft-операции
		//
		// Ввод в экплуатацию основных фондов.
		// Может присутствовать только в:
		// - приходе основных средств (PPOPT_GOODSRECEIPT; subtype = OPSUBT_ASSETRCV)
		// - переоценке (PPOPT_GOODSREVAL; subtype = OPSUBT_ASSETEXPL).
		// Если одновременно установлены флаги (PPTFR_REVAL | PPTFR_ASSETEXPL | PPTFR_MODIF)
		// то это означает вывод из эксплуатации объекта основных средств
		//
		pptfrAssetExpl    = 0x40000000
		//                  0x80000000  // Reserved
	}

	enum PpyOTrfrItemAmtType {
		tiamtCost       = 1, // Cost * Quantity
		tiamtPrice      = 2, // NetPrice() * Quantity
		tiamtAmount     = 3, // CalcAmount()
		tiamtAssetExpl  = 4  // Ввод основных средств в эксплуатацию
	}

	struct SPpyO_TrfrItem {
		date   Date;
		long   BillID;
		int    RByBill;
		int    CurID;      // Валюта
		long   LocID;
		long   GoodsID;
		long   LotID;
		//
		// При загрузке строки теневого документа в пакет поле CorrLoc
		// получает идентификатор этого теневого документа, а поле
		// BillID получает идентификатор документа заказа. Перед
		// проводкой такой строки поле CorrLoc обнуляется.
		//
		long   OrdLotID;    // Лот ордера (Flags & PPTFR_ONORDER) (В БД не заносится)
		//
		double UnitPerPack; // Емкость упаковки (количество торговых единиц в одной упаковке)
		double Quantity;    // Количество товара (при переоценке - старая цена поступления)
		double WtQtty;      // @v5.1.5 Независимо учитываемое количество в физических единицах
		double Rest;        // Остаток после операции (при проводке игнорируется)
		double Cost;        // Цена поступления (при переоценке - новая цена поступления)
		double Price;       // Цена реализации (при переоценке - новая цена реализации)
		double Discount;    // Скидка (при переоценке - старая цена реализации)
		double CurPrice;    // Валютная цена
		double QuotPrice;   // Фиксированная цена по котировке
		long   LotTaxGrpID; // Входящая налоговая группа по лоту
		long   QCert;       // Серитфикат качества
		long   Suppl;       // Поставщик
		PpyOTrfrItemFlags  Flags;       // Флаги
		date   Expiry;      // Дата завершения пригодности товара к использованию
		date   LotDate;     // Дата поступления товара.
		double Amount;      // Сумма
	}

	struct SPpy_TaxInfo {
		long   TaxGrpID;
		double VatRate;
		double VatAmount;
	}

	enum PpyOTransportType {
		trtypCar  = 1, // Car
		trtypShip = 2  // Ship
	}

	struct SPpyO_Freight {
		long   ID;              // ->Bill.ID
		string Name;            //
		long   DlvrAddrID;      // ->Location.ID Адрес разгрузки
		long   NmbOrigsBsL;     // Количество печатаемых оригиналов коносаментов
		PpyOTransportType TrType;          //
		long   PortOfLoading;   // ->City.ID
		long   PortOfDischarge; // ->City.ID
		date   IssueDate;       // Дата отправления из пункта погрузки
		date   ArrivalDate;     // Дата прибытия на конечный пункт
		long   CaptainID;       // ->Person.ID (Командиры транспортных средств)
		double Cost;            // Стоимость фрахта
		long   AgentID;         // ->Person.ID (Транспортные агентства)
		long   ShipID;          // ->Ship.ID
	}

	enum SCompleteItemFlags {
		cfExclude = 0x0001 // Этот лот исключен операцией рекомплектации
	}

	struct SCompleteItem {
		long   GoodsID;
		long   LotID;
		long   BillID;         // Ид документа, сформировавшего строку
		date   Dt;             // Дата документа, сформировавшего эту строку
		date   Expiry;         // Срок годности, лота, соответствующего строке
		long   ArID;           // Контрагент по документу, сформировавшему эту строку
		string Serial;
		double Qtty;
		double Cost;
		double Price;
		SCompleteItemFlags  Flags;
	}

	interface ICompleteList {
		void   Clear();
		long   GetCount();
		int    Get(in long pos, out SCompleteItem * pItem);
	}

	interface IPapyrusBillPacket {
		int    Init();
		int    PutHeader(SPpyO_Bill * pHeader);
		int    UpdateHeader(SPpyO_Bill * pHeader);
		int    GetHeader(out SPpyO_Bill * pHeader);
		int    PutItem(SPpyO_TrfrItem  * pItem);
		int    LoadTItem(SPpyO_TrfrItem * pItem, string rClb, string rBarcode);
		int    EnumItems(inout long * pIdx, SPpyO_TrfrItem * pItem);
		//
		// Descr: Возвращает список сумм документа
		//
		IPapyrusAmountList * GetAmountList();
		//
		// Descr: Возвращает список документов заказов
		//
		IStrAssocList * GetOrderList();
		//
		// Descr: Извлекает информацию о налоге строки документа
		//
		int    GetTaxInfo(in SPpyO_TrfrItem * pItem, PpyOTrfrItemAmtType tiAmtType, out SPpy_TaxInfo * pTaxInfo);
		//
		// Descr: Извлекает информацию о фрахте
		//
		int    GetFreight(SPpyO_Freight * pFreight);
		//
		// Descr: Извлекает значение тега
		//
		int    GetTagValue(in long tagID, out string * pValue);
		//
		// Descr: Устанавливает значение тега
		//
		int    PutTagValue(in long tagID, in string rValue);
		//
		// Descr: Возвращает последнюю дату оплаты
		//
		date   GetLastPayDate();
		//
		// Descr: Устанавливает значение тега для строки
		//
		int    PutRowTagValue(in long tagID, in long rowIdx, in string rValue);
	}

	struct SDebtBlock {
		double  Amount;
		double  Debt;
		long    HasMatured;
		long    MaxDelay;   // Максимальная задержка между текущей датой и датой документа
		long    MaxExpiry;  // Максимальная задержка между текущей датой и последним сроком оплаты по документу
	}

	enum PpyOLotFlags {
		lotsfFirst      = 0x0001, // Лот является первым по этому товару на этом складе
		lotsfCostUp     = 0x0002, // Цена поступления лота выше, чем у предыдущего
		lotsfCostDown   = 0x0004, // Цена поступления лота ниже, чем у предыдущего
		lotsfPriceUp    = 0x0008, // Цена реализации лота выше, чем у предыдущего
		lotsfPriceDown  = 0x0010, // Цена реализации лота ниже, чем у предыдущего
		lotsfLinkCostUp = 0x0020, // Цена поступления выше, чем цена в документе заказа, на основании которого вводится данный док
		lotsfLinkCostDn = 0x0040  // Цена поступления ниже, чем цена в документе заказа, на основании которого вводится данный док
	}

	struct SPpyO_Lot {
		long   ID;
		long   BillID;
		long   LocID;
		date   Dt;
		long   OprNo;
		long   Closed;
		long   GoodsID;
		long   QCertID;
		double UnitPerPack;
		double Quantity;
		double WtQtty;
		double WtRest;
		double Cost;
		double ExtCost;
		double Price;
		double Rest;
		long   PrevLotID;
		long   SupplID;
		date   CloseDate;
		date   Expiry;
		long   InTaxGrpID;
		PpyOLotFlags  Flags;
	}

	enum PpyGoodsRestCm { // calcMethod (Метод расчета цен)
		grbcmAvg        = 0, // По среднему
		grbcmFirstLot   = 1, // По первому лоту
		grbcmLastLot    = 2, // По последнему лоту
		grbcmSum        = 3, // Суммарное значение
		grbcmDiff       = 4, // Возвращать все лоты с ненулевым остатком
		grbcmMostRecent = 5  // По самому последнему лоту (не смотря на остаток)
	}

	enum PpyGoodsRestFlags {
		grbfPriceByQuot   = 0x00000080, // Цены по котировкам
		grbfCWoVat		  = 0x00004000, // Цены поступления без НДС
		grbfZeroAgent     = 0x00010000  // Только с нулевым агентом поставщика
	}

	struct SPpyGoodsRestBlock {
		PpyGoodsRestCm    CalcMethod;
		PpyGoodsRestFlags Flags;
		date   Date;
		long   OprNo;          // Если Dt != 0 и OprNo > 0, то остаток по лотам брать до {Date, OprNo}
		long   LocID;
		long   GoodsID;
		long   SupplID;
		long   AgentID;        // Агент, связанный с документом прихода товара (агент поставщика)
		long   QuotKindID;     //
		//
		// Результат
		//
		int    Count;
		double Rest;
		double Cost;
		double Price;
		long   LotID;
		double Deficit;
		double DraftRcpt;
	}

	interface ILotList {
		long   GetCount();
		int    Get(long pos, out SPpyO_Lot * pLot);
		int    SearchById(long id, out SPpyO_Lot * pLot, int bSearch);
		//
		// Descr: Инициализирует внутренний счетчик для последующих вызовов функци NextIteration.
		//
		void   InitIteration();
		//
		// Descr: Возвращает элемент, соответствующий внутреннему счетчику объекта и увеличивает
		//   на единицу значение этого счетчика.
		//   Если внутренний счетчик выход за пределы [0..GetCount()-1], то возвращает 0.
		// ARG(pItem OUT): @#{vptr0} Указатель на структуру STaggedString, по которому присваивается //
		//   очередной элемент. Если pItem == 0, то функция просто ничего не присваивает, но возвращает
		//   значение то же, как будто pItem != 0.
		// Returns:
		//   >0 - очередной элемент получен и присвоен по укзателю pItem. Внутренний счетчик увеличен
		//        на единицу.
		//   0  - больше нет ни одного элемента для перечисления //
		//        По адресу pItem присвоен нулевой элемент.
		//
		int    NextIteration(out SPpyO_Lot * pLot);
		//
		// Descr: Удаляет все элементы из списка. Единственный гарантированный результат этой функции
		//   состоит в том, что количество доступных элементов в списке станет равным нулю.
		//   Предположений об очистке внутренней памяти делать не следует.
		//
		void   Clear();
		//
		// Descr: Добавляет в список новый элемент с полями:
		//   STaggedString::Id = itemId, STaggedString::ParentId = parentId, STaggedString::Text = text;
		//   Если в списке уже присутсвует элемент с идентификатором itemId, то новый не добавляется,
		//   но у существующего заменяются атрибуты ParentId и Text на те, что указаны в аргументах.
		//   Не следет делать предположения относительно индекса позиции, в которую был добавлен новый элемент.
		//
		void   Add(SPpyO_Lot * pLot);
		//
		// Descr: Создает экземпляр списка, содержащего такие же элементы, что в оригинальном
		//   экземпляре. Элементы в копии находятся в той же последовательности, что и в оригинале.
		//
		void   Clone(out ILotList ** ppClone);
		void   Sort();
	}

	interface IPapyrusObjBill {
		//
		// Descr: Перебирает строки документа billID
		// Return: 0 - ошибка, -1 - нет больше строк, 1 - доступна очередная строчка документа
		//
		int EnumBillRows(long billID, SPpyO_TrfrItem * pRow);
		IPapyrusBillPacket * CreatePacket();
		//
		// Descr: Добавляет документ в базу данных
		// Return: 0 - ошибка, -1 - не удалось провести документ, 1 - документ создан, -2 - похожий документ найден
		// функция вызывает метод SearchAnalog, и если документ с таким видом операции, датой и номером найден,
		// то отклоняем создание нового и возвращаем - 2
		//
		int PutPacket(IPapyrusBillPacket * pPack);
		int GetPacket(long id, IPapyrusBillPacket * pPack);
		//
		// Descr: Вычисляет долг клиента
		//
		int CalcClientDebt(long clientID, in SDateRange * pPeriod, out SDebtBlock * pBlk);
		//
		// Descr: Находит документ по аналогу
		//
		int SearchAnalog(SPpyO_Bill * pSample, long * pID, SPpyO_Bill * pRec);
		//
		// Descr: Извлекает фрахт
		//
		int GetFreight(long billID, SPpyO_Freight * pFreight);
		//
		// Descr: Извлекает номер Грузовой таможенной декларации
		//
		int GetClbNumberByLot(int32 lotID, int32 * pIsParentLot, out string * pBuf);
		//
		// Descr: Находит документ по GUID
		//
		int SearchByGuid(in string pGuidStr, SPpyO_Bill * pRec);
		//
		// Descr: Привязывает GUID к документу
		//
		int PutGuid(long billID, in string pGuidStr);
		//
		// Descr: Извлекает GUID привязанный к документу
		//
		int GetGuid(long billID, out string * pGuidStr);
		//
		// Descr: Извлекает значение тега
		//
		int GetTagValue(in long billID, in long tagID, out string * pValue);
		//
		// Descr: Устанавливает значение тега
		//
		int PutTagValue(in long billID, in long tagID, in string rValue);
		//
		// Descr: Извлекает значение тега лота
		//
		int GetLotTagValue(in long lotID, in long tagID, out string * pValue);
		//
		// Descr: Извлекает ид оригинального лота
		//
		int GetOriginalLot(in long lotID, out long * pOrgLotID, out SPpyO_Lot * pLot, out SPpyO_Lot * pOriginalLot);
		//
		// Descr: Извлекает остатки товара с дифференциацией по значению тега
		//
		double GetRestByTag(in date dt, in long goodsID, in long tagID, in string rTagVal, in IStrAssocList * pLocList);
		//
		// Descr: Список товаров из которых был скомплектован лот
		//
		ICompleteList * GetComplete(in long lotID);
		//
		// Descr: Остаток по лоту на дату
		//
		int GetRest(in long lotID, in date dt, out double * pRest, out double * pPhRest);
		//
		// Descr: Долговая размерность
		//
		int GetDebtDim(in long billID, out long * pDebtDimID);
		//
		// Descr: Дата платежа
		//
		date GetLastPayDate(in long billID);
		//
		// Descr: Сумма платежей
		//
		int CalcPayment(in long billID, in SDateRange * pPeriod, in long curID, out double * PaymentAmount);
		//
		// Descr: Список удаленных документов
		//
		IStrAssocList * GetDeletedBillList(in SDateRange * pPeriod);
		//
		// Descr: Извлекает список лотов с учетом индекса по лотам (Cur lot list)
		//
		ILotList * GetCurLotList(in date lowDt, in date uppDt, in long goodsGrpId, in IStrAssocList * pLocList);
		//
		// Descr: Находит последний лот по складу locID на дату forDate.
		//   Результат может сожержать как открытый, так и закрытый лот.
		// Returns:
		//   >0 - лот найден
		//   <0 - лот не найден
		//   0  - ошибка
		//
		int GetLastLot(in long goodsID, in long locID, in date forDate, out SPpyO_Lot * pLot);
		int CalcGoodsRest(inout SPpyGoodsRestBlock * pBlk);
	}
	// }
	// @ModuleDecl(PPObjWorld)
	enum PpyOWorldKind {
		wokSpecial    =  -100,       // Специальная запись, являющаяся индикатором того, что таблица была отконвертирована из
			// старого набора объектов PPObjCountry, PPObjCity, PPObjRegion
		wokContinent  =  1,
		wokGenRegion  =  2,
		wokCountry    =  3,
		wokRegion     =  4,
		wokCity       =  5,
		wokStreet     =  6 // @v5.5.12 Улица (площадь, проспект и т.д.)
	}

	struct SPpyO_World {
		long   RecTag;         // Const=ppoWorld Метка структуры
		long   ID;
		PpyOWorldKind  Kind;
		long   ParentID;
		long   CountryID;
		string Name;
		string Abbr;
		long   Status;
		long   Flags;
		string Phone;
		string Code;
		string ZIP;
	}
	// }
	// @ModuleDecl(PPObjRegister) {
	//
	//
	// Interface PPObjRegister
	//
	//
	interface IPapyrusObjRegister {
		//
		// Descr: Возвращает регистр персоналии или персонального события, если PsnEvent не 0
		// Returns:
		//   0 - ошибка, -1 такой регистр не найден, 1 - регистр найден.
		//
		//
		int    SearchByNumber(long regTypeID, string rSn, string rNmbr, out SPpyO_Register * pRegister);
		int    Fetch(in long id, out SPpyO_Register * pRegister);
	}
	//
	// }
	// @ModuleDecl(PPObjPersonRelType) {
	//
	enum PpyOPersonRelTypeCardinality {
		psnrtcOneToOne = 1,
		psnrtcOneToMany,
		psnrtcManyToOne,
		psnrtcManyToMany
	}
	enum PpyOPersonRelTypeStatusRestr {
		psnrtssUndef = 0,
		psnrtssPrivateToPrivate,
		psnrtssPrivateToLegal,
		psnrtssLegalToPrivate,
		psnrtssLegalToLegal
	}
	enum PpyOPersonRelTypeFlags {
		psnrtfInhAddr  = 0x0001,
		psnrtfInhRAddr = 0x0002,
		psnrtfGrouping = 0x0004  // @v5.7.1 Группирующее отношение (только для Cardinality = cManyToOne)
	}

	struct SPpyO_PersonRelType {
		long   RecTag;                                   // Const=ppoPersonRelType Метка структуры
		long   ID;                                       // Идентификатор персонального отношени
		string Name;                                     // Наименование персонального отношени
		string Symb;                                     // Символ персонального отношени
		PpyOPersonRelTypeStatusRestr  StatusRestriction; // Ограничение по статусу отношений (PPPersonRelType::ssXXX)
		PpyOPersonRelTypeCardinality  Cardinality;       // Ограничение по множественности отношений (PPPersonRelType::cXXX)
		PpyOPersonRelTypeFlags        Flags;             // Флаги (PPPersonRelType::fXXX)
	}

	interface IPapyrusPersonRelTypePacket {
		int    Init();
		int    Put(SPpyO_PersonRelType * pRec);
		int    Get(out SPpyO_PersonRelType * pRec);
		IStrAssocList * GetInhRegTypeList();
		int    PutInhRegTypeList(IStrAssocList * pList);
	}
	//
	// Interface PPObjPersonRelType
	//
	interface IPapyrusObjPersonRelType {
		IPapyrusPersonRelTypePacket * CreatePacket();
		//
		// Descr: Добавляет тип персонального отношения в базу данных
		// ARG(pID  OUT): ид добавленного отношения //
		// ARG(pPack IN): пакет персонального отношения //
		// ARG(useTa IN): 1 - использовать транзакцию, 0 - не использовать транзакцию
		// Return: 0 - ошибка, -1 - не удалось добавить отношение, 1 - отношение создано
		//
		int PutPacket(out long * pID, IPapyrusPersonRelTypePacket * pPack, int useTa);
		int GetPacket(long id, IPapyrusPersonRelTypePacket * pPack);
	}
	//
	// }
	// @ModuleDecl(PPObjTransport) {
	// Descr: Объект данных "Транспорт"
	//
	struct SPpyO_Transport {
		long   RecTag;         // Const=ppoTransport
		long   ID;             // @id
		PpyOTransportType TrType; // Тип транспорта
		string Name;           // @name
		string Code;           // Номер транспортного средства
		string TrailerCode;    // Номер прицепа (для автотранспорта)
		long   TrModelID;      // ИД модели
		long   OwnerID;        // ->Person.ID (PPPRK_SHIPOWNER) Владелец транспорта
		long   CountryID;      // ->Country.ID
		long   CaptainID;      // ->Person.ID (PPPRK_CAPTAIN) Командир транспорта
		double Capacity;       // @v7.2.8 Грузоподъемность, кг
	}
	//
	// }
	// @ModuleDecl(PPObjProcessor) {
	// Descr: Объект данных "Процессор"
	//
	enum PpyOProcessorKind {
		prckGroup     = 1, // Группа процессоров
		prckProcessor = 2  // Собственно процессор
	}

	enum PpyOProcessorFlags {
		prcfInductSupersesStatus = 0x0001, // Проецировать статусы суперсессий на подчиненные сессии
		prcfStoreGoodsRest       = 0x0002, // При закрытии сессий по этому процессору
			// фиксировать остатки товаров на момент закрытия сессии.
			// Остатки фиксируются в таблице TSessLine с признаками Sign=0, Flags|=TSESLF_OUTREST
		prcfPrintNewLinePane     = 0x0004, // Печатать этикетку для каждой новой строки в панели
		prcfAltGroup             = 0x0008, // Альтернативная группа процессоров
		prcfDefSignMinus         = 0x0010, // Знак операции по умолчанию - расход
		prcfDefSignPlus          = 0x0020, // Знак операции по умолчанию - приход
					// @#{PRCF_DEFSIGN_MINUS^PRCF_DEFSIGN_PLUS}
		prcfEnableDupSerial      = 0x0040, // Разрешение на ввод в строку сессии строк с одинаковым серийным номером
		prcfOneClickTurnPane     = 0x0080, // Проводить строку сессии в панели процессора сразу после выбора товара
					// (по штрихкоду или серийному номеру). Используется для быстрого ввода в случае, когда не надо явно задавать количество
					// и другие атрибуты строки кроме собственно товара (лота)
		prcfLockWrOff            = 0x0100, // Сессии по этому процессору не списываются //
		prcfWrOfDtStart          = 0x0200, // Дата документа списания - дата начала сессии
					// Если флаг не установлен, то дата конца сессии.
		prcfWrOffDtBuSuper       = 0x0400, // Дата документа списания определяется датой суперсессии
					// по правилу флага PRCF_WROFFDT_START. Если суперсессии нет, то PRCF_WROFFDT_BYSUPER игнорируется.
		prcfCanSwitchPane        = 0x0800, // Флаг группы, означающий, что в панели процессора
					// допускается переключение между процессорами этой группы. Область действия этого флага распростаняется //
					// только на процессоры, непосредственно привязанными к этой группе.
		prcfAccDupSerialInSess   = 0x1000, // Принимать две строки сессии с одним серийным номером
		prcfTurnIncomplBill      = 0x2000, // Проводить документы по сессиям, даже если есть дефицит
		prcfPassive              = 0x4000, // Пассивный процессор (флаг не наследуется от группы)
		prcfAddedObjAsAgent      = 0x8000, // Доп объект сессии списывается как агент (только в случае, если
					// доп объект по виду операции не определен).
				//
				// Флаг передаваемый с дополнительным параметром, и сигнализирующий о том, что
				// речь идет о группе процессоров
				//
		prcfExDfGroup        = 0x80000000
	}

	struct SPpyO_Processor {
		long   RecTag;         // Const=ppoProcessor
		long   ID;             //
		long   ParentID;       // ->Processor.ID
		PpyOProcessorKind Kind;  // @#{PPPRCK_GROUP || PPPRCK_PROCESSOR}
		string Name;           //
		long   LocID;          // ->Location.ID Склад, к которому относится процессор
			// Если 0, то наследуется от ParentID
		long   TimeUnitID;     // ->Ref(PPOBJ_UNIT) Единица времени, используемая для расчета
			// мощности процессора, и для учета использования //
			// Если 0, то наследуется от ParentID
		PpyOProcessorFlags Flags; // PRCF_XXX
		long   LinkObjType;    // Если 0, то наследуется от ParentID
		long   LinkObjID;      // Для групп процессоров - если LinkObjType != 0, то определяет группу ассоциации
			// (например, вид персоналии для персоналий)
		long   WrOffOpID;      // ->Ref(PPOBJ_OPRKIND) Операция списания сессий   //
			// Если 0, то наследуется от ParentID
		long   WrOffArID;      // ->Article.ID         Контрагент списания сессий //
			// Если 0, то наследуется от ParentID
		long   SuperSessTiming; // [sec] Стандартная продолжительность суперсессии (только для групп)
		long   RestAltGrpID;   // ->Goods2.ID ИД альтернативной товарной группы, по которой учитываются //
			// исходящие остатки по закрытию сессии для этой группы процессоров
		long   PrinterID;      // ->Ref(PPOBJ_BCODEPRINTER) Принтер, используемый для печати этикеток
		long   LabelCount;     // Количество этикеток, которое следует печатать на принтере
		string Code;           // Код процессора
		long   WrOffGenOpID;   // Обобщенная операция списания, позволяющая выбрать конкретную операцию в ручную
	}
	//
	// }
	// @ModuleDecl(PPObjTSession) {
	// Descr: Объект данных "Технологические сессии"
	//

	//
	// Descr: Флаги технологических сессий
	//
	enum PpyOTSessionFlags {
		tsesfWritedOff  = 0x0001, // Сессия списана
		tsesfSuperSess  = 0x0002, // Суперсессия (объединяет несколько обыкновенных сессий)
		tsesfIdle       = 0x0004, // Простой процессора
		tsesfPlan       = 0x0008, // Произодственный план
			// 		Система следит за недопущением пересечений сессий производственных планов для одного
			// процессора (группы процессоров), однако пересечения производственных планов с обычными
			// сессиями и сессиями простоев естественны.
			// 		Производственный план не обязан быть привязан к технологии. С другой стороны, привязка к
			// виртуальной технологии, обеспечивающей список позиций, допустима и, вероятно, полезна.
			// 		Производственные планы задаются с точностью до дня, по этому, поля времени начала и
			// окончания в диалоге плана опускаются.
		tsesfPlanPhUnit =  0x0010 // Производственный план в физических единицах
			// Если этот флаг установлен, то новая строка по умолчанию получает признак TSESLF_PLAN_PHUNIT.
			// Пользоватлеь может переопределить этот признак для строки.
	}

	struct SPpyO_TSession {
		long   RecTag;         // Const=ppoTSession
		long   ID;             // @id
		long   ParentID;       // ->TSession.ID
		long   Num;            // Номер сессии (уникальный по процессору)
		long   TechID;         // @#{!0} ->Tech.ID
		long   PrcID;          // @#{!0 && PrcID == TechID.PrcID} ->Processor.ID
		date   StDt;           // Дата начала сессии
		time   StTm;           // Время начала сессии
		date   FinDt;          // Дата окончания сессии
		time   FinTm;          // Время окончания сессии
		long   Incomplete;     // @#{0,5,10} Закрытие сессии не было завершено
		long   Status;         // @#{1..5}   Состояние сессии TSESST_XXX
		PpyOTSessionFlags Flags; // @flags
		long   ArID;           // ->Article.ID Основная статья для подстановки в документ списания //
		long   Ar2ID;          // ->Article.ID 2-я статья для подстановки в документ списания //
		long   PlannedTiming;  // Планируемое время работы (секунд)
		double PlannedQtty;    // Планируемый объем производства (TechID.GoodsID.UnitID)
		double ActQtty;        // Фактический объем производства (TechID.GoodsID.UnitID)
		long   OrderLotID;     // ->Receipt.ID Связанный лот заказа
		long   PrevSessID;     // ->TSession.ID ИД предыдущей сессии. Привязка к предыдущей сессии уникальна.
			// То есть, на сессию, как на предыдущую может ссылаться ноль или одна сессия.
			// @#{PrcID == PrevSessID.PrcID}
		double Amount;         // Сумма сессии
		long   LinkBillID;     // ->Bill.ID Документ, к которому привязана сессия //
			// Схема функционирования этой ссылки:
			//   1. Формируется сессия, привязанная по этой ссылке к драфт-документу
			//   2. После закрытия сессия списывается //
			//   3. Документы списания одновременно становятся членами пула списания сессии и членами пула
			//      списания документа LinkBillID. Соответственно, LinkBillID получает статус списанного документа.
			//
		long   SCardID;        // ->SCard.ID Дисконтная карта, по которой предоставляется скидка в ценах сессии
		long   ToolingTime;    // Время на перенастройку (секунд). Рассчитывается автоматически по технологиям перенастройки.
		string Memo;           // Примечание
	}
	//
	// Строки технологических сессий
	//

	//
	// Флаги строк технологических сессий
	//
	enum PpyOTSessLineFlags {
		tseslfAutocompl   = 0x0001, // Строка сформирована автоматически процедурой PPObjTSession::Complete
		tseslfOutRest     = 0x0002, // Строка исходящих остатков по сессии
		tseslfFixedRest   = 0x0004, // Пользователь зафиксировал значение остатка по товару
			// (автоматическое изменение недопустимо)
		tseslfTiming      = 0x0008, // Строка сформирована автоматически по основному товару сессии,
			// единица измерения которого является производной от секунды.
		tseslfExpandSess  = 0x0010, // @transient Функция PPObjTSession::PutLine должна изменить время //
			// окончания сессии, если оно меньше времени, которым помечена строка. При этом время строки становится   //
			// временем окончания сессии.
		tseslfRest        = 0x0020, // Строка остатка серийного номера по сессии. Используется в том случае,
			// если в процессе производства удобнее посчитать остаток некоторой позиции, чем фактически израсходованное
			// количество. При вводе строки остатка система проверяет, чтобы в течении сессии был расход указанного
			// серийного номера. Если так, то одновременно с вводом этой строки, из строки, с указанным серийным номером
			// вычитается количество остатка. При этом возможность модификации основной строки блокируется.
		tseslfIndepPhQtty = 0x0040, // Строка учитывает физическое количество товара независимо от
			// торгового. Этот флаг устанавливается функцией PPObjTSession::SetupLineGoods в соответствии с флагом GF_USEINDEPWT
		tseslfRecompl     = 0x0080, // Строка с основным товаром технологии, подлежащая рекомплектации
			// при списании. Этот флаг предполагает, что в строке установлен серийный номер, товар является основным
			// товаром технологии и знак операции +.
		tseslfPlanPhQtty  = 0x0100, // Производственный план в физических единицах
		tseslfTooling     = 0x0200  // Флаг используется в комбинации с TSESLF_AUTOCOMPL. Если установлен, то
			// строка сформирована автоматически как издержки на перенастройку.
	}

	struct SPpyO_TSessLine {
		long   TSessID;        // TSession.ID
		long   OprNo;          //
		long   GoodsID;        // ->Goods.ID
		long   LotID;          // ->Receipt.ID Лот, в который отображается строка после списания //
		long   UserID;         // ->Ref(PPOBJ_USR) Пользователь, который ввел операцию
		long   Sign;           // @#{-1,0,+1} -1 - расход, +1 - приход, 0 - остаток не меняется //
		date   Dt;             // Дата ввода строки. Инициализируется программно. Модификация только аварийная //
		time   Tm;             // Время ввода строки. Инициализируется программно. Модификация только аварийная //
		long   Flags;          // TSESLF_XXX
		double Qtty;           // @#{>0}
		string Serial;         // Серийный номер
		double Price;          // Стоимость единицы товара
		double WtQtty;         // Количество в независимых физических единицах
		date   Expiry;         // Срок годности товара, оприходованного строкой
		double Discount;       // Скидка к цене Price. Итоговая цена по строке равна (Price-Discount)
	}
	//
	// }
	// @ModuleDecl(PPObjPrjTask) {
	// Descr: Объект данных "Задачи"
	//
	enum PpyOPrjTaskKind {
		prjtkTask     = 1, // Собственно задача
		prjtkTemplate = 2  // Шаблон задач
	}
	enum PpyOPrjTaskFlags {
		prjtfOpenedByEmpl = 0x0001, // Исполнитель видел задачу
		prjtfActionViewed = 0x0002  // Задача просмотрена кем-либо
	}
	enum PpyOPrjTaskStatus {
		prjtsNew           = 1, // Новая //
		prjtsCanceled      = 2, // Отмененна
		prjtsInProgress    = 3, // Выполняется //
		prjtsInExpectaiong = 4, // В ожидании
		prjtsCompleted     = 5  // Завершена
	}
	enum PpyOPrjTaskPriority {
		prjtpMaximum = 1, // Максимальный
		prjtpHigh    = 2, // Высокий
		prjtpNormal  = 3, // Нормальный
		prjtpLow     = 4, // Низкий
		prjtpMinimum = 5  // Минимальный
	}

	struct SPpyO_PrjTask {
		long   RecTag;    // Const=ppoPrjTask Метка структуры
		long   ID;
		long   ProjectID;
		PpyOPrjTaskKind     Kind;
		string Code;
		long   CreatorID;
		long   GroupID;
		long   EmployerID;
		long   ClientID;
		long   TemplateID;
		date   Dt;
		time   Tm;
		date   StartDt;
		time   StartTm;
		date   EstFinishDt;
		time   EstFinishTm;
		date   FinishDt;
		time   FinishTm;
		PpyOPrjTaskPriority Priority;
		PpyOPrjTaskStatus   Status;
		int    DrPrd;
		int    DrKind;
		long   DrDetail;
		PpyOPrjTaskFlags    Flags;
		long   DlvrAddrID;
		long   LinkTaskID;
		double Amount;
		long   OpenCount;
		long   BillArID;         // ->Article.ID
		string Descr;
		string Memo;
	}
	//
	// }
	// @ModuleDecl(PPObjProject) {
	// Descr: Объект данных "Проекты"
	//

	//
	// Виды проектов(Kind)
	//
	enum PpyOProjectKind {
		prjkProject     = 1, // Проект
		prjkPhase       = 2, // Фаза
		prjkPrjTemplate = 3, // Шаблон проекта
		prjkPhsTemplate = 4  // Шаблон фазы
	}
	//
	// Статусы проектов
	//
	enum PpyOProjectStatus {
		prjsActive      = 1, // Проект/фаза в активной стадии работы
		prjsNonActive   = 2, // Проект/фаза завершен
		prjsArchived    = 3  // Архивированный проект (только для проектов)
	}

	struct SPpyO_Project {
		long   RecTag;       // Const=ppoProject Метка структуры
		long   ID;
		PpyOProjectKind   Kind;
		long   ParentID;
		string Name;
		string Code;
		date   Dt;
		date   BeginDt;
		date   EstFinishDt;
		date   FinishDt;
		long   MngrID;
		long   ClientID;
		long   TemplateID;
		PpyOProjectStatus Status;
		long   Flags;
		long   BillOpID;
		string Descr;
		string Memo;
	}
	//
	// }
	// @ModuleDecl(PPObjBrand) {
	// Descr: Объект данных "Бренды"
	//
	struct SPpyO_Brand {
		long   ID;           // @id
		string Name;         // Наименование на родном языке
		long   OwnerID;      // ->PersonID (PPPRK_MANUF) Владелец брэнда
	}
	//
	// }
	// @ModuleDecl(PPObjQCert) {
	// Descr: Объект данных "Сертификаты качества"
	//
	struct SPpyO_QCert {
		long    RecTag;
		long    ID;          // @id
		long    Passive;     //
		string  Code;        //
		string  BlankCode;   //
		long    GoodsID;     //
		string  GoodsName;   //
		string  Manuf;       //
		date    ProduceDate; //
		string  SPrDate;     //
		date    InitDate;    //
		date    Expiry;      //
		long    RegOrgan;    //
		string  Etc;         //
		string  InnerCode;   //
	}
	//
	//
	//
	struct SPpyO_SCardSeries {
		long   RecTag;        // Const=ppoSCardSeries Метка структуры
		long   ID;
		string Name;
		string Symb;
		long   ChargeGoodsID;      // Товар, использующийся для начисления на карту
			// (имеет приоритет перед PPSCardConfig::ChargeGoodsID)
		long   BonusChrgGrpID;     // Товарная группа, ограничивающая начисления на бонусные карты
		long   BonusChrgExtRule;   // Дополнительная величина правила изменения начисления бонуса по карте
		long   BonusGrpID;         // Товарная группа, по которой зачитываются бонусы на карты
		long   CrdGoodsGrpID;      // Товарная группа, продажа товаров которой зачитывается как
			// списание по кредитной карте в количественном выражении.
		date   Issue;              // Дата выпуска
		date   Expiry;             // Дата окончания действия //
		double PctDiscount;        // Скидка
		double MaxCredit;          // Максимальный кредит (для кредитных карт)
		long   Flags;              // @flags
		long   QuotKindID;         // Вид котировки
		long   PersonKindID;       // Вид персоналии, используемый для владельцев карт (по умолчанию - PPPRK_CLIENT)
		string CodeTempl;          // Шаблон номеров карт
	}

	struct SPpyO_SCard {
		long   ID;           // @id
		string Code;         // Номер карты
		string Password;     // Пароль для удаленной авторизации владельца
		long   SeriesID;       // ->Ref(PPOBJ_SCARDSERIES)
		long   PersonID;       // ->Person.ID
		long   Flags;          // @flags
		date   Dt;             // Open date
		date   Expiry;         // Дата истечения срока действия карты
		double PctDiscount;    // Discount
		long   AutoGoodsID;    // ->Goods2.ID Товар, автоматически списываемый по карте в чековой панели
		double MaxCredit;      // For credit cards [Ref(PPOBJ_SCARDSERIES).SeriesID.Flags & SCRDSF_CREDIT]
		double Turnover;       // Оборот по карте (по всем закрытым сессиям)
		double Rest;           // Текущий остаток по кредитной карте
		time   UsageTmStart;   //
		time   UsageTmEnd;     //
		long   PeriodTerm;     // Тип периода длительности срока действия //
		long   PeriodCount;    // Количество периодов длительности срока действия //
	}

	struct SPpyO_SCardOp {
		long   SCardID;
		long   DestSCardID;
		long   LinkObjType;
		long   LinkObjID;
		datetime Dtm;
		int    OpType;         // 0 - начисление/списание, 1 - период блокировки
		SDateRange FreezingPeriod;
		double Amount;
	}

	interface IPapyrusObjSCard {
		int    GetPacket(in long id, SPpyO_SCard * pPack);
		int    PutPacket(out long * pID, SPpyO_SCard * pPack, in int useTa);
		int    SetFreezingPeriod(in long id, in SDateRange * pDateRange, in int useTa);
	}
	//
	// }
	// @ModuleDecl(PPViewTrfrAnlz) {
	//
	// Descr: Вид группировки анализа товарных операций
	//
	enum PpyVTrfrAnlzGrouping {
		tavgNone = 0,                      // Без группировки
		tavgGoods,                         // По товару
		tavgCntragent,                     // По контрагенту
		tavgCntragentDate,                 // По контрагенту, дате
		tavgGoodsCntragent,                // По товару, контрагенту
		tavgGoodsCntragentDate,            // По товару, контрагенту, дате
		tavgGoodsBill,                     // По товару, документу
		tavgDateCntragentAgentGoods,       // По дате, контрагенту, агенту, товару
		tavgGoodsDate,                     // По товару, дате
		tavgBillCntragent                  // По документу, контрагенту
	}
	//
	// Descr: Флаги фильтра анализа товарных операций
	//
	enum PpyVTrfrAnlzFlags {
		tavfLabelOnly          = 0x00000001,   // Только помеченные операции
		tavfGByDate            = 0x00000002,   // Группировка по дате (только если выбран товар - GoodsID)
		tavfGetRest            = 0x00000004,   // Рассчитывать товарные остатки
		tavfSubstPersonRAddr   = 0x00000008,   // При подстановке персоналии использовать фактический адрес
		tavfSubstDlvrAddr      = 0x00000010,   // При подстановке персоналии использовать адрес доставки
		tavfDiffByDlvrAddr     = 0x00000020,   // При группировке по контрагенту заменять контрагента на
			// конкатенацию (контрагент+адрес доставки)
		tavfDontInitSubstNames = 0x00000040,   // Не инициализировать имена подставляемых объектов
			// Эта опция экономит время подготовки данных если нет необходимости сортировать записи
			// или выводить отчет на экран.
		tavfInitLocCount       = 0x00000080,   // Рассчитывать количество адресов доставки для каждого
			// элемента группировки. Внутренний флаг (инициализируется программно)
		tavfCalcRest           = 0x00000100,   // Для группировки gGoods, gGoodsBill, gGoodsDate рассчитывать остатки
		tavfShowAllArticles    = 0x00000200,   // Показывать отсутствующие позиции контрагентов
		tavfShowAllAgents      = 0x00000400,   // Показывать отсутствующие позиции агентов
		tavfShowAllGoods       = 0x00000800,   // Показывать отсутствующие позиции товаров
		tavfByZeroAgent        = 0x00001000,   // Фильтрация по нулевому агенту по документу
		tavfCalcVat            = 0x00002000,   // Рассчитывать суммы НДС
		tavfCWoVat             = 0x00008000,   // Показывать цены без НДС
		tavfByZeroDlvrAddr     = 0x00010000,   // @v8.3.0  Фильтрация по пустому адресу доставки
		tavfForceInitDlvrAddr  = 0x00020000    // @v8.3.0  Инициализировать адрес доставки без группировки
	}

	interface IPpyFilt_TrfrAnlz {
		//
		// Descr: Устанавливает период документов, которые должны попасть в обработку
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает период поступления лотов, по которым должен проводится анализ.
		//   Если устанавливается не пустой период, то в анализ попадут только те товарные операции,
		//   которые привязаны к лотам, дата которых попадает в указанный период.
		//   Обращаем внимание на то, что имеется в виду именно дата лота, а не дата оригинального лота.
		//
		void SetLotsPeriod(date low, date upp);
		//
		// Descr: Добавляет склад в список складов
		//
		void AddLocationID(long id);
		//
		// Descr: Очищает список складов
		//
		void ClearLocList();
		property {
			out SDateRange Period;     // Период обрабатываемых операций. Для установки - SetPeriod
			out SDateRange LotsPeriod; // Период поступления лотов, которыми ограничиваются обрабатываемые операции.
				// Для установки - SetLotsPeriod
			long   OpID;              // Вид операции (возможно обобщенной)
			long   LocID;             // Склад
			long   SupplID;           // Поставщик
			long   ArID;              // Если !0, то перебираются только те документы, у которых ObjectID == ArID
			long   DlvrAddrID;        // Адрес доставки. Если ArID == 0, то не используется //
			long   AgentID;           // Если !0, то перебираются только те документы, в которых установлен этот агент
			long   PsnCatID;          // Категория персоналии
			long   CityID;            // Город контрагентов, по которым перебираются операции
			long   GoodsGrpID;        // Товарная группа, по которой ведется перебор операций. Если GoodsID != 0,
				// то этот параметр игнорируется (используется только как ограничение выбора товара в диалоге) //
			long   GoodsID;           // Товар, по которому ведется перебор операций (может быть обобщенным)
			PpyVTrfrAnlzFlags Flags;  //
			int    InitOrd;           // PPViewTrfrAnlz::IterOrder
					// 0 - по умолчанию
					// 1 - по дате операции
					// 2 - по наименованию товара (или подстановки)
					// 3 - по наименованию контрагента (или подстановки)
			long   CtKind;            // TrfrAnlzFilt::ctXXX  Вид кросстабулированного отчета
			PpyVTrfrAnlzGrouping Grp; // Параметр группировки
			PpyVSubstGrpGoods    Sgg; // Подстановка товара
			PpyVSubstGrpPerson   Sgp; // Подстановка персоналии
			PpyVSubstGrpDate     Sgd; // Подстановка даты
		}
	}
	//
	// Descr: Итоговые данные по выборке КАД PPViewTrfrAnlz
	//
	struct SPpyVT_TrfrAnlz {
		long   RecTag;         // Метка структуры
		long   Count;          // Количество строк
		double Qtty;           // Количество торговых единиц
		double PhQtty;         // Количество физических единиц
		double Cost;           // Сумма в ценах поступления //
		double Price;          // Сумма в ценах реализации
		double Discount;       // Сумма скидки
		double Amount;         // Номинальная сумма
		double SaldoQtty;      // Суммарное сальдо в торговых единицах
		double SaldoAmt;       // Суммарное сальдо в номинальных ценах
		double PVat;           // Сумма НДС в ценах реализации
	}
	//
	// Descr: Элемент выборки КАД PPViewTrfrAnlz
	//
	struct SPpyVI_TrfrAnlz {
		long   RecTag;         // Метка структуры
		date   Dt;             // Дата операции
		long   OprNo;          // Номер операции за день (с группировкой - 0)
		long   BillID;         // ИД документа
			// Если выбрана группировка tavgDateCntragentAgentGoods, то это поле - ИД агента по документу
		long   LocID;          // ИД склада
		long   ArticleID;      // ИД статьи документа
		long   PersonID;       // ИД персоналии, соответствующей статье документа (возможна подстановка)
		long   OpID;           // ИД вида операции
		long   GoodsID;        // ИД товара
		long   SubGoodsClsID;  // ИД класса товара (только для позиций, в которых товар был подстановлен по классификатору)
		long   LotID;          // ИД лота
		long   DlvrLocID;      // ИД адреса доставки
		long   LocCount;       // Количество адресов доставки, попавших в эту строку
		double Qtty;           // Количество торговых единиц
		double PhQtty;         // Количество физических единиц
		double Rest;           // Остаток (если фильтр не предусматривает расчет остатка, то - 0)
		double Cost;           // Сумма в ценах поступления или цена поступления (в зависимости от фильтра)
		double Price;          // Сумма в ценах реализации или цена реализации (в зависимости от фильтра)
		double Discount;       // Сумма в скидки или скидка на одну единицу (в зависимости от фильтра)
		double Amount;         // Номинальная сумма (зависит от вида операции)
		double SaldoQtty;      // Товарное сальдо в торговых единицах (для отдельных опций фильтрации)
		double SaldoAmt;       // Суммовое сальдо в номинальных ценах (для отдельных опций фильтрации)
		double PVat;           // Сумма НДС в ценах реализации

		string BillCode;       // Номер документа
		string DtText;         // Текстовое представление даты (при подстановке возможны вариации)
		string GoodsText;      // Текстовое представление товара (при подстановке возможны вариации)
		string PersonText;     // Текстовое представление персоналии (при подстановке возможны вариации)
	}

	struct SPpyV_TrfrAnlz_AlcRepParam {
		long   ImpExpTag;
		long   ManufOptBuyerTag;
		long   ManufKindID;
		long   ImportKindID;
	}

	struct SPpyVI_TrfrAnlz_AlcRep {
		SPpyVI_TrfrAnlz Item;
		SPpyO_Goods GoodsRec;
		SPpyO_Bill  BillRec;
		SPpyO_Lot   OrgLotRec;
		long   PersonID;
		long   OrgLot_Prsn_SupplID;
		int    IsImport;
		int    IsExport;
		int    IsManuf;
		int    IsOptBuyer;
	}

	interface IPapyrusTrfrAnlz {
		int    InitAlcRepParam(in SPpyV_TrfrAnlz_AlcRepParam * pParam);
		int    NextIteration_AlcRep(SPpyVI_TrfrAnlz_AlcRep * pItem);
	}

	interface IAlcRepOpList {
		int    Init(in long genRcpt, in long genRcptEtc, in long genRet, in long genSupplRet, in long genExp, in long genExpEtc, in long genIntrMov);
		int    IsRcpt(in long op);
		int    IsRcptEtc(in long op);
		int    IsRet(in long op);
		int    IsSupplRet(in long op);
		int    IsExp(in long op);
		int    IsExpEtc(in long op);
		int    IsIntrMov(in long op);
	}
	//
	// }
	//
	//
	// @ModuleDecl(PPViewCCheck) {
	//
	// Descr: Варианты группировки чеков
	//
	enum PpyVCCheckGrouping {
		ccgNone = 0, // Не группировать
		ccgTime,     // По времени чека
		ccgDate,     // По дате чека
		ccgCash,     // По номеру кассового аппарата
		ccgCard,     // По дисконтным картам
		ccgAmount,   // По сумме чека (градация определяется свойством фильтра AmountQuant)
		ccgQtty,     // По количеству в строке чека (градация определяется свойством фильтра AmountQuant)
		ccgGoods,    // По товарам
		ccgCashiers  // По кассирам
	}
	//
	// Descr: Флаги фильтрации чеков
	//
	enum PpyVCCheckFlags {
		ccfZeroSess       = 0x0001, // Чеки по неопределенным кассовым сессиям
		ccfActiveSess     = 0x0002, // Чеки активной синхронной кассовой сессии
		ccfCheckLines     = 0x0004, // Просматривать строки чеков (для группировки по товарам)
		ccfImmOpenPanel   = 0x0008, //
		ccfShowSuspended  = 0x0010, // Показывать отложенные
		ccfSuspendedOnly  = 0x0020, // Только отложенные
		ccfRetOnly        = 0x0040, // Показывать только возвраты
		ccfShowJunk       = 0x0080, // Отложенные чеки, которые были загружены в панель чеков.
			// Если панель аварийно завершила работу, то этот чек зависнет.
		ccfFillCashNodeID = 0x0100, // Заполнять поле CashNodeID
		ccfNotPrintedOnly = 0x0200, // Показывать только ненапечатанные чеки
		ccfCashOnly       = 0x0400, // Только чеки, проведенные за наличные
		ccfBankingOnly    = 0x0800  // Только чека, проведенные по безналичной оплате
	}
	interface IPpyFilt_CCheck {
		//
		// Descr: Устанавливает период перебора чеков.
		//
		void SetPeriod(date low, date upp);
		property {
			long   CashNodeID;         // ->PPOBJ_CASHNODE ИД кассового узла
			long   CashNumber;         // Номер кассового аппарата (не путать с кассовым узлом)
			long   GoodsGrpID;         // ->PPOBJ_GOODSGROUP Группа товаров (допустимы: обыкновенные группы,
				// группы верхнего уровня, альтернативные группы). Если это значение не нулевое, то чеки
				// перебираются по строкам.
			long   GoodsID;            // ->PPOBJ_GOODS Товар. Если это значение не нулевое,
				// то чеки перебираются по строкам.
			long   SCardSerID;         // ->PPOBJ_SCARDSERIES Серия дисконтных карт. Если SCardID не нулевое,
				// то этот критерий игнорируется.
			long   SCardID;            // ->PPOBJ_SCARD ИД дисконтной карты. Если значение не нулевое, то
				// перебираются только те чеки, которые привязаны к выбранной карте.
			long   CashierID;          // ->PPOBJ_PERSON  ИД кассира.
			long   AgentID;            // ->PPOBJ_ARTICLE ИД агента (официанта)
			long   TableCode;          // Номер стола
			long   MinCode;            // Минимальный  номер чека (0 - не определено)
			long   MaxCode;            // Максимальный номер чека (0 - не определено)
			double MinAmount;          // Минимальная  сумма чека (0 - не определено)
			double MaxAmount;          // Максимальная сумма чека (0 - не определено)
			double MinQtty;            // Минимальное  количество товара по строке (0 - не определено)
			double MaxQtty;            // Максимальное количество товара по строке (0 - не определено)
			double AmountQuant;        // Квант суммы чека или количества по строке для группировке по соответствующему критерию.
				// Используется только при группировке по критериям: ccgAmount, ccgQtty
			PpyVCCheckFlags    Flags;  // Флаги фильтрации
			PpyVCCheckGrouping Grp;    // Варианты группировки
			out SDateRange Period;     // Период, в который должны попадать чеки из выборки.
				// Устанавливать это свойство следует вызовом метода SetPeriod().
				// Замечание: дата чека может не совпадать с датой кассовой сессии, к которой это чек относится.
			time   MinTime;            // Нижнее время отсечки выборки
			time   MaxTime;            // Верхнее время отсечки выборки
			long   WeekDays;           // Битовая маска дней недели, которым следует ограничить выборку.
				// Если WeekDays = 0, то маска считается неопределенной (все дни недели).
				// Бит 0 соответствует воскресенью, бит 1 - понедельнику, бит 2 - вторнику и т.д.
			long   HourBefore;         //
		}
	}
	struct SPpyVT_CCheck {
		long   RecTag;      // Метка структуры
		long   Count;       // Количество чеков
		double Qtty;        // Количество торговых единиц товаров в чеках (если задана детализация)
		double Amount;      // Общая сумма чеков (с учетом скидки)
		double Discount;    // Сумма скидки по чекам
	}
	struct SPpyVI_CCheck {
		long   RecTag;      // Метка структуры
		long   ID;          // Ид чека
		long   Code;        // Номер чека
		long   CashID;      // Номер кассового аппарата
		long   UserID;      // ->PPOBJ_PERSON     Ид пользователя, сформировавшего чек
		long   SessID;      // ->PPOBJ_CSESSION   Ид кассовой сессии, которой принадлежит чек
		long   Flags;       // Флаги чека
		long   SCardID;     // ->PPOBJ_SCARD      Ид дисконтной карты, по которой пробит чек
		long   TableCode;   // Номер стола
		long   AgentID;     // ->PPOBJ_PERSON     Ид агента (официанта)
		long   G_GoodsID;   //
		long   G_Count;     // Количество чеков, сгруппированных этой строкой
		long   CashNodeID;  // ->PPOBJ_CASHNODE   Ид кассового узла
		long   GoodsGrpID;  // ->PPOBJ_GOODSGROUP Товарная группа, к которой относится товар G_GoodsID
		datetime Dtm;       // Дата/время чека
		double G_Amount;
		double G_Discount;
		double G_PctPart;
		double G_Qtty;
		double Amount;
		double Discount;
	}
	// }
	//
	// @ModuleDecl(PPViewLot) {
	//
	// Descr: Флаги фильтрации лотов
	//
	enum PpyVLotFlags {
		lvfWithoutQCert       = 0x0008, // Показывать только лоты, у которых нет серитфиката
		lvfOrders             = 0x0010, // Лоты заказов
		lvfCostAbovePrice     = 0x0020, // Только лоты, у которых цена поступления больше цены реализации
		lvfWithoutClb         = 0x0040, // Лоты без ГТД
		lvfDeadLots           = 0x0080, // Только те лоты, по которым не было движения //
		lvfWithoutExpiry      = 0x0100, // Лоты, для которых не указан срок годности
		lvfOnlySpoilage       = 0x0200, // Только лоты с бракованными сериями
		lvfShowSerialN        = 0x0400, // Показывать серийные номера лотов
		lvfSkipNoOp           = 0x0800, // Не показывать лоты, по которым не было операций за операционный период
			// Имеет смысл только если !Operation.IsZero()
		lvfCheckOriginLotDate = 0x1000, // Учитывать дату оригинального лота в соответствии с заданным периодом
		lvfSkipClosedBeforeOp = 0x2000, // Пропускать лоты, закрытые до операционного периода
		lvfNoTempTable        = 0x4000  // Только для внутреннего использования.
	}
	//
	// Descr: Интефейс фильтра по лотам
	//
	interface IPpyFilt_Lot {
		//
		// Descr: Устанавливает период фильтрации по дате поступления лотов.
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает операционный период выборки. Если операционный период не пустой, то
		//   модуль рассчитывает остаток на начало операционного периода, остаток на конец, приход и
		//   расход за операционный период.
		//
		void SetOperationPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по сроку годности лотов
		//
		void SetExpiryPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по дате истечения срока действия сертификата по лоту.
		//
		void SetQcExpiryPeriod(date low, date upp);
		property {
			out SDateRange Period;          // Период поступления лотов
			out SDateRange OperationPeriod; // Операционный период
				// (показывает остаток на начало, приход, расход, остаток на конец этого периода)
			out SDateRange ExpiryPeriod;    // Период истечения срока годности по лотам
			out SDateRange QcExpiryPeriod;  // Период истечения срока действия сертификатов
			long   LocID;               // ->PPOBJ_LOCATION   Склад
			long   SupplID;             // ->PPOBJ_ARTICLE    Поставщик
			long   GoodsGrpID;          // ->PPOBJ_GOODSGROUP Товарная группа (если GoodsID != 0, то не используется)
			long   GoodsID;             // ->PPOBJ_GOODS  Товар (возможно, обобщенный)
			long   QCertID;             // ->PPOBJ_QCERT  Только лоты, к которым привязан этот сертификат
			long   InTaxGrpID;          // Налоговая группа, ассоциированная с лотом
			PpyVLotFlags Flags;         // Флаги
			/*uint*/long ClosedTag;           // 0 - all, 1 - только открытые, 2 - только закрытые
			double CostLow;             // Диапазон цен поступления //
			double CostUpp;             //   Нулевое значение интерпретируется как отсутствие границы
			double PriceLow;            // Диапазон цен реализации  //
			double PriceUpp;            //   Нулевое значение интерпретируется как отсутствие границы
			string Serial;              // Серийный номер, по которому следует найти лот
		}
	}
	//
	// Descr: Итоги выборки лотов
	//
	struct SPpyVT_Lot {
		long   RecTag;      // Метка структуры
		long   Count;       // Количество лотов
		double Qtty;        // Общее пришедшее по лотам количество товара (в торговых единицах)
		double Rest;        // Общий текущий остаток по лотам (в торговых единицах)
		double Cost;        // Сумма остатка в ценах поступления //
		double Price;       // Сумма остатка в ценах реализации  //
		long   DCount;      // Количество порожденных лотов
		double InCost;      // Начальная сумма поступивших по лотам товаров в ценах поступления //
		double InPrice;     // Начальная сумма поступивших по лотам товаров в ценах реализации  //
		double DRest;       // Остаток порожденных лотов в тороговых единицах
		double DCost;       // Остаток порожденных лотов в ценах поступления //
		double DPrice;      // Остаток порожденных лотов в ценах реализации  //
	}
	//
	// Descr: Структура элемента выборки лотов
	//
	struct SPpyVI_Lot {
		long   RecTag;      // Метка структуры
		long   ID;          // ИД
		long   BillID;      // ->PPOBJ_BILL     ИД документа
		long   LocID;       // ->PPOBJ_LOCATION Позиция поступления от поставщика
		date   Dt;          // Дата операции прихода на позицию
		long   OprNo;       // Номер операции за день
		int    Closed;      // Признак нулевого остатка по приходу
		long   GoodsID;     // ->PPOBJ_GOODS    Ид товара
		long   QCertID;     // ->PPOBJ_QCERT    Ид сертификата качества
		double UnitPerPack; // Количество единиц в упаковке
		double Quantity;    // Поступившее количество единиц
		float  WtQtty;      // Поступившее количество в независимых физических единицах
		float  WtRest;      // Остаток после операции в независимых физических единицах
		double Cost;        // Текущая цена поступления //
		double ExtCost;     // Величина накладных расходов (включена в состав Cost) //
		double Price;       // Текущая цена реализации  //
		double Rest;        // Текущий остаток
		long   PrevLotID;   // ->PPOBJ_LOT      Предыдущий лот
		long   SupplID;     // ->PPOBJ_ARTICLE  Поставщик
		date   CloseDate;   // Дата закрытия лота
		date   Expiry;      // Срок годности
		long   InTaxGrpID;  // ->PPOBJ_GOODSTAXGROUP Налоговая группа прихода
		long   Flags;       // Флаги лота
		//
		double BegRest;     // Остаток на начало операционного периода
		double EndRest;     // Остаток на конец операционного периода
		double QttyPlus;    // @v5.5.2 Приход за операционный период (количество)
		double QttyMinus;   // @v5.5.2 Расход за операционный период (количество)
		date   OrgLotDt;    // @v5.4.6 Дата поступления оригинального лота
		string Serial;      // Серийный номер по лоту
	}
	// }
	//
	// @ModuleDecl(PPViewGoods) {
	//
	// Descr: Флаги фильтрации товаров
	//
	enum PpyVGoodsFlags {
		gvfUseGrpList        = 0x00000001, // Внутренний флаг - использовать список товарных групп
		gvfUseUnitMask       = 0x00000004, // Внутренний флаг - использовать маску фильтрации единиц измерения //
		gvfIntUnitOnly       = 0x00000008, // Только те товары, для которых задана целочисленная единица измерения //
		gvfFloatUnitOnly     = 0x00000010, // Только те товары, для которых задана нецелочисленная единица измерения //
		gvfNegation          = 0x00000020, // Отрицание фильтра
		gvfGenGoods          = 0x00000040, // Если установлен флаг fGenGoods, то поле GrpID используется // как обобщенный товар.
		gvfGroupGenGoods     = 0x00000080, // Группировать обобщенные товары
		gvfUndefType         = 0x00000100, // Только те товары, для которых не определен тип
		gvfNewLots           = 0x00000200, // Только те товары, которых не было на дату (LotPeriod.low-1)
		gvfExcludeAsset      = 0x00000400, // Исключить основные средства
		gvfIncludeIntr       = 0x00000800, // Рассматривать порожденные лоты. Действует при (!LotPeriod.IsZero() || SupplID)
		gvfShowBarcode       = 0x00001000, // Показывать штрих-коды в броузере
		gvfShowCargo         = 0x00002000, // Показывать товары с грузовыми параметрами
		gvfHidePassive       = 0x00004000, // Не показывать пассивные товары (отменяет fPassiveOnly)
		gvfPassiveOnly       = 0x00008000, // Показывать только пассивные товары (отменяет fHidePassive)
		gvfGenGoodsOnly      = 0x00010000, // Показывать только обобщенные товары
		gvfWOTaxGdsOnly      = 0x00020000, // Показывать только товары с ценой без налогов
			// @#{fPassiveOnly^fGenGoodsOnly^fWOTaxGdsOnly}
		gvfNoZeroRestOnLotPeriod = 0x00040000, // Если товар не удовлетворяет ограничению LotPeriod, но есть на остатке, то попадает в выборку
		gvfNoDisOnly         = 0x00080000, // Показывать только товары с признаком без скидки
		gvfShowStrucType     = 0x00100000, // Показывать признак наличия структуры AHTOXA
		gvfNotUseViewOptions = 0x00200000, // Не показывать в товарном фильтре кнопку опции просмотра
		gvfShowGoodsWOStruc  = 0x00400000, // Показывать товары без структуры
		gvfWoTaxGrp          = 0x00800000, // Показывать только товары без налоговой группы
		gvfRestrictByMatrix  = 0x01000000, // Ограничивать выборку товарной матрицей. Если LocID == 0, то ограничивается матрицей для всех складов
		gvfShowArCode        = 0x02000000, // Показывать артикулы товаров
		gvfShowOwnArCode     = 0x04000000, // Показывать собственные артикулы (ArID = 0)
		gvfShowWoArCode      = 0x08000000, // Показывать товары без артикулов // @v9.3.10

		gvfOutOfMatrix       = 0x10000000, // Показывать только те товары, которые НЕ принадлежат матрице.
			// Этот флаг имеет более низкий приоритет, чем fRestrictByMatrix. То есть, если установлены оба
			// флага (что программа не должна допускать), то применяется fRestrictByMatrix
		gvfActualOnly        = 0x20000000, // Показывать только те товары, по которым есть не нулевые остатки по одному из складов LocList
		gvfHasImages         = 0x40000000, // Только с картинками
		gvfUseIndepWtOnly    = 0x80000000  // Только с флагом GF_USEINDEPWT
	}
	//
	// Descr: Интерфейс фильтра по товарам
	//
	interface IPpyFilt_Goods {
		//
		// Descr: Устанавливает период фильтрации по дате поступления товаров.
		//
		void SetLotPeriod(date low, date upp);
		//
		// Descr: Добавляет идентификатор группы в список групп, по которым осуществляется фильтрация товаров
		//
		void AddGoodsGroupID(long id);

		property {
			out    SDateRange LotPeriod;
			long   GrpID;
			long   ManufID;
			long   ManufCountryID;
			long   UnitID;
			long   PhUnitID;
			long   SupplID;
			long   GoodsTypeID;
			long   TaxGrpID;
			long   LocID;
			PpyVGoodsFlags Flags;
			long   VatRate;    // Ставка НДС, которой облагается товар. (ненулевое значение этого поля исключает фильтрацию по полю TaxGrpID)
			date   VatDate;    // Дата, на которую следует брать ставку НДС (используется только если VatRate != 0)
			long   BrandID;    // Товарный брэнд
			string SrchStr;    // @anchor Строка, содержащаяся с имени
			string BarcodeLen; // Список длин штрихкодов (через запятую)

			long   GdsClsID;
			long   KindID;
			long   AddObjID;
			long   GradeID;
			long   AddObj2ID;
			double DimXMin;
			double DimXMax;
			double DimYMin;
			double DimYMax;
			double DimZMin;
			double DimZMax;
			double DimWMin;
			double DimWMax;
			long   CodeArID;  // @v8.6.8 Статья, с которой должны ассоциироваться коды по статьям.
		}
	}

	struct SPpyVT_Goods {
		long   RecTag;         // Метка структуры
		long   Total;
	}

	struct SPpyVI_Goods {
		long   RecTag;         // Метка структуры
		long   ID;
		long   Kind;
		string Name;
		string Abbr;
		long   ParentID;
		long   GoodsTypeID;
		long   UnitID;
		long   PhUnitID;
		double PhUPerU;
		long   ManufID;
		long   StrucID;
		long   TaxGrpID;
		long   WrOffGrpID;
		long   Flags;
		long   GdsClsID;
		long   BrandID;
		long   DefBCodeStrucID;

		string Barcode;
		long   Brutto;
		long   Length;
		long   Width;
		long   Height;
		double MinStock;
		double Package;
		string StrucType;
	}
	// }
	//
	// @ModuleDecl(PPViewGoodsStruc)
	//
	//
	// Descr: Интерфейс фильтра по товарным структурам
	//
	enum PpyVGoodsStrucFlags {
		gsvfShowComplDecompl = 0x0001, // Показывать структуры комплектации/декомплектации
		gsvfShowPartitial    = 0x0002, // Показывать частичные структуры
		gsvfShowSubst        = 0x0004, // Показывать подстановочные структуры
		gsvfShowGift         = 0x0008, // Показывать подарочные структуры
		gsvfShowComplex      = 0x0010  // Показывать комплексные структуры
	}

	interface IPpyFilt_GoodsStruc {
		property {
			long   PrmrGoodsGrpID;
			long   PrmrGoodsID;
			long   ScndGoodsGrpID;
			long   ScndGoodsID;
			long   StrucFlagSet;
			long   StrucFlagReset;
			long   ItemFlagSet;
			long   ItemFlagReset;
			PpyVGoodsStrucFlags Flags; // @flags
			long   InitOrder;          // Порядок сортировки PPViewGoodsStruc::OrdXXX
		}
	}

	struct SPpyVI_GoodsStruc {
		long   RecTag;        // Метка структуры
		long   GStrucID;
		long   PrmrGoodsID;
		long   StrucFlags;
		long   ParentStrucID;
		long   GiftQuotKindID;
		long   VariedPropObjType;
		string StrucName;
		string StrucSymb;
		SDateRange Period;
		double GiftLimit;
		double GiftAmtRestrict;
		double CommDenom;
		long   GoodsID;
		long   ItemFlags;
		double Median;
		double Denom;
		double Netto;
	}
	//
	// @ModuleDecl(PPViewGoodsRest) {
	//
	// Descr: Флаги фильтрации остатков
	//
	enum PpyVGoodsRestFlags {
		grvfBarCode          = 0x00000001, // Остатки со штрих-кодами
		grvfNullRest         = 0x00000002, // Выводить нулевые остатки
		grvfCalcOrder        = 0x00000004, // Расчитывать заказанное количество
		grvfPriceByQuot      = 0x00000040, // Формировать цены по котировкам
		grvfUnderMinStock    = 0x00000080, // Показывать только те позиции, остаток по которым ниже установленного минимума
		grvfDisplayWoPacks   = 0x00000100, // Показывать остатки без упаковок
		grvfNullRestsOnly    = 0x00000200, // Только нулевые остатки
		grvfLabelOnly        = 0x00000400, // WL-only
		grvfNoZeroOrderOnly  = 0x00000800, // Только с ненулевыми заказами
		grvfCalcTotalOnly    = 0x00001000, // Расчитать только итоги
		grvfEachLocation     = 0x00002000, // Рассчитывать остатки по каждому из складов
		grvfComplPackQtty    = 0x00004000, // Показывать количество в упаковках
		grvfCWoVat           = 0x00008000, // Показывать цены без НДС
		grvfCalcDeficit      = 0x00010000, // Рассчитывать дефицит
		grvfWoSupplier       = 0x00020000, // Рассчитывать остатки без учета поставщика
		grvfShowMinStock     = 0x00040000, // показывать минимальные остатки
		grvfShowDraftReceipt = 0x00080000  // Показывать остатки учитывая будущие драфт приходы
	}
	enum PpyVGoodsRestCalcMethod { // calcMethod (Метод расчета цен)
		grvpcmAvg        = 0, // По среднему
		grvpcmFirstLot   = 1, // По первому лоту
		grvpcmLastLot    = 2, // По последнему лоту
		grvpcmSum        = 3, // Суммарное значение
		grvpcmDiff       = 4, // Возвращать все лоты с ненулевым остатком
		grvpcmMostRecent = 5  // @v4.4.11 По самому последнему лоту (не смотря на остаток)
	}
	//
	// Descr: Параметры дифференциации отчета об остатках товаров
	// @v9.9.2
	//
	enum PpyVGoodsRestDiffParam {
		grvdiffNone     = 0x0000,
		grvdiffCost     = 0x0001,
		grvdiffPrice    = 0x0002,
		grvdiffPack     = 0x0004,
		grvdiffSerial   = 0x0008,
		grvdiffLoc      = 0x0010,
		grvdiffLotTag   = 0x0020,
		grvdiffLotID    = 0x0040,
		grvdiffExpiry   = 0x0080
	}
	//
	// Descr: Интерфейс фильтра по остаткам товаров
	//
	interface IPpyFilt_GoodsRest {
		//
		// Descr: Устанавливает период фильтрации по дате поступления товаров.
		//
		void SetPrgnPeriod(date low, date upp);
		//
		// Descr: Добавляет идентификатор склада в список складов, по которым осуществляется фильтрация товарных остатков
		//
		void AddLocationID(long id);

		property {
			PpyVGoodsRestCalcMethod CalcMethod;
			PpyVGoodsRestFlags  Flags; //
			PpyVGoodsRestDiffParam DiffParam; // @v9.9.2 Параметр дифференциации записей отчета
			long  AmtType;             // 0 - в обеих ценах, 1 - поступления, 2 - реализации
			long  CalcPrognosis;       // если 1, то вычисляем прогноз иначе - нет
			out   SDateRange PrgnPeriod; // период прогноза
			date  Date;
			long  SupplID;            // Ид поставщики, по которому ограничивается выборка товаров
			long  GoodsGrpID;
			long  QuotKindID;
			long  AgentID;
			long  BrandID;
			PpyVSubstGrpGoods Sgg;     // Подстановка товара
			date  DeficitDt;           // Дата рассчета дефицита
		}
	}

	struct SPpyVT_GoodsRest {
		long   RecTag;        // Метка структуры
		long   Count;
		double Quantity;
		double PhQtty;
		double Order;
		double SumCost;
		double SumPrice;
		double PctAddedVal;
		double DraftRcpt;
		double SumDraftCost;
		double SumDraftPrice;
	}

	struct SPpyVI_GoodsRest {
		long   RecTag;        // Метка структуры
		long   GoodsID;
		long   GoodsGrpID;
		long   LocID;
		string GoodsGrpName;
		string GoodsName;
		string UnitName;
		long   IsPredictTrust; // Прогноз продаж удовлетворяет требованиям надежности
		double Rest;
		double Deficit;
		double PhRest;
		double Order;
		double UnitPerPack;
		double Cost;
		double Price;
		double SumCost;        // Сумма остатка в ценах поступления //
		double SumPrice;       // Сумма остатка в ценах реализации //
		double PctAddedVal;    // Средняя наценка на позицию
		double Predict;        // Прогноз продаж
		double RestInDays;     // Остаток товаров в днях
		double MinStock;       //
		double SupplOrder;     // Предлагаемый заказ поставщику
		long   SubstAsscCount; //
		double DraftRcpt;      //
		double SStatSales;     // @v9.9.2 Среднедневные продажи из статистики продаж
		date   LastSellDate;   // @v9.9.2 Дата последней продажи
		date   Expiry;         // @v9.9.2 Дата срока годности
		long   LotID;          // @v9.9.2
		string Serial;         // @v9.9.2
	}
	// }
	//
	// @ModuleDecl(PPViewBill) {
	//
	// Descr: Флаги фильтрации документов
	//
	enum PpyVBillFlags {
		vbfShowDebt          = 0x00000001, // Показывать долг
		vbfDebtOnly          = 0x00000002, // Выводить только неоплаченные документы if(fOrderOnly) then выводить только не закрытые заказы
		vbfPaymNeeded        = 0x00000004, // Выводить документы, требующие оплаты (независимо от операции)
		vbfFreightedOnly     = 0x00000008, // Только зафрахтованные документы (BillTbl::Rec.Flags & BILLF_FREIGHT)
		vbfCashOnly          = 0x00000010, // Документы розницы через кассовый узел
		vbfOrderOnly         = 0x00000020, // Заказы
		vbfInvOnly           = 0x00000040, // Инвентаризация //
		//
		// Если флаг fAsSelector установлен, то броузер работает как
		// селектор. При этом, если был выбран какой-то документ,
		// то поле sel содержит его идентификатор.
		//
		vbfAsSelector        = 0x00000080,
		vbfLabelOnly         = 0x00000100, // Показывать только меченые документы
		vbfAllCurrencies     = 0x00000200, // Показывать все валюты
		vbfAccturnOnly       = 0x00000400, // Только бухгалтерские документы
		vbfSetupNewBill      = 0x00000800, // Формировать поля нового док в соответствии с фильтром
		vbfDraftOnly         = 0x00001000, // Драфт-документы
		vbfDebtsWithPayments = 0x00002000, // Долговые документы с оплатами
		vbfPoolOnly          = 0x00004000, // Только пулы документов
		vbfShowAck           = 0x00008000, // Показывать с номерами подтверждений
		vbfEditPoolByType    = 0x00010000, // Изменения пула производить с помощью AssocID
		vbfIgnoreRtPeriod    = 0x00020000  // @internal Функция PPViewBill::Init не должна устанавливать пересечение this->Period с периодом доступа на чтение.
	}
	//
	// Descr: Интерфейс фильтра по документам
	//
	enum PpyVBrowseBillsType {
		vbbbtUndef          = -1,
		vbbbtGoodsBills     =  0,
		vbbbtOrderBills     =  1,
		vbbbtAccturnBills   =  2,
		vbbbtInventoryBills =  3,
		vbbbtPoolBills      =  4,
		vbbbtClientDebt     =  5,
		vbbbtClientRPayment =  6,
		vbbbtDraftBills     =  7,
		bvbbtRealTypes      =  8
	}

	enum PpyVBillDenyFlags {
		vbfDenyAdd    = 0x0001,
		vbfDenyUpdate = 0x0002,
		vbfDenyRemove = 0x0004
	}

	enum PpyVBillCCMode {
		ccmDebts     = 1,   // Долговые документы контрагента
		ccmRPayments = 2    // Зачетные документы контрагента
	}

	interface IPpyFilt_Bill {
		//
		// Descr: Устанавливает период фильтрации по документам
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает фильтрацию по периоду поступления платежей
		//
		void SetPaymPeriod(date low, date upp);
		//
		// Descr: Добавляет идентификатор склада в список складов, по которым осуществляется фильтрация документов
		//
		void AddLocationID(long id);

		property {
			long   Tag;                       // @#0 reserved
			PpyVBrowseBillsType Bbt;          // @#1f
			out SDateRange Period;            //
			out SDateRange PaymPeriod;        // Период поступления платежей (Flags & fShowDebt)
			long   MainOrgID;                 // reserve Главная организация //
			long   PoolOpID;                  // Ид операции пула (ограничивает выбор вида операции)
			long   OpID;                      // Ид вида операции (возможно, обобщенного)
			long   CurID;                     // Ид валюты
			long   AccSheetID;                // Если из операции нельзя определить таблицу статей, то эта таблица может быть взята из поля sheet
			long   ObjectID;                  // ->Article.ID
			long   Object2ID;                 // ->Article.ID
			long   PayerID;                   // ->Article.ID Плательщик
			long   AgentID;                   // ->Article.ID Агент
			long   CreatorID;                 // ->Ref(PPOBJ_USR) Пользователь, создавший документ
			long   StatusID;                  // ->Ref(PPOBJ_BILLSTATUS) Статус документа
			long   AssocID;                   //
			long   PoolBillID;                // Обобщающий документ
			PpyVBillFlags     Flags;
			PpyVBillDenyFlags DenyFlags;
			PpyVBillCCMode    ClientCardMode;
			int    Ft_STax;                   // (0) ignored, (< 0) off, (> 0) on
			int    Ft_ClosedOrder;            // (0) ignored, (< 0) off, (> 0) on
			double AmtRangeMin;               // Диапазон номинальной суммы
			double AmtRangeMax;               // Диапазон номинальной суммы
			long   Sel;
		}
	}

	struct SPpyVT_Bill {
		long    RecTag;        // Метка структуры
		long    Count;         // Количество документов
		double  Sum;           // Номинальная сумма документов
		double  Debt;          // Долги по документам
		// AmtList Amounts;
		//
		// Fields for debt card
		//
		double  InSaldo;
		double  Debit;
		double  Credit;
		double  OutSaldo;
	}

	struct SPpyVI_Bill {
		long   RecTag;        // Метка структуры
		long   ID;
		string Code;
		date   Dt;
		long   BillNo;
		date   DueDate;
		long   OpID;
		long   StatusID;
		long   UserID;
		long   MainOrgID;
		long   LocID;
		long   Object;
		long   Object2;
		long   CurID;
		double CRate;
		double Amount;
		long   LinkBillID;
		long   Flags;
		long   Flags2;
		long   SCardID;
		string Memo;
		double Debit;
		double Credit;
		double Saldo;
		date   LastPaymDate; // Дата последнего платежа по документу
	}
	// }
	// @ModuleDecl(PPViewGoodsOpAnlz)
	//
	//
	struct SPpyVT_GoodsOpAnlz {
		long   RecTag;
		long   Count;
		double Qtty;
		double PhQtty;
		double Cost;
		double Price;
		double Income;
		double RestCost;
		double RestPrice;
		double PlanQtty;
		double PlanSum;

		long   InCount;
		double InQtty;
		double InPhQtty;
		double InCost;
		double InPrice;
		double InIncome;
	}

	struct PpyVGoodsOpAnlzCmpVal {
		double Val;
		double Cmp;
	}

	struct SPpyVI_GoodsOpAnlz {
		long   RecTag;
		long   LocID;
		int    InOutTag;       // -1 - in, 1 - out, 0 - undef
		long   GoodsID;        // Если используется подстановка инородного объекта
						       // (производитель, атрибуты класса), то поле содержит маску 0x40000000L
		long   GoodsGrpID;
		long   SubstArID;      // Статья, подставленная вместо GoodsID
		long   SubstPsnID;     // Персоналия, подставленная вместо GoodsID
		long   SubstLocID;     // Склад, подставленный вместо GoodsID
		string GoodsName;
		double UnitPerPack;
		PpyVGoodsOpAnlzCmpVal Qtty;
		double PhQtty;
		double OldCost;        // Старая цена поступления (для переоценки)
		double PlanQtty;       // Плановое количество
		double OldPrice;       // Старая цена реализации (для переоценки)
			// Если отчет рассчитывается с флагом vgoafShowSStatSales, то в это поле заносится значение средних продаж
			// из статистики продаж
		double PlanSumPrice;   // Плановая сумма продаж (закупок)
		double Cost;
		double Price;
		PpyVGoodsOpAnlzCmpVal SumCost;
		PpyVGoodsOpAnlzCmpVal SumPrice;
		PpyVGoodsOpAnlzCmpVal Income;
		double PctVal;
		PpyVGoodsOpAnlzCmpVal Rest;
		PpyVGoodsOpAnlzCmpVal RestCostSum;
		PpyVGoodsOpAnlzCmpVal RestPriceSum;
	}
	//
	// Интерфейс фильтра по товарному отчету по операции
	//
	enum PpyVGoodsOpAnlzOpGrp { // OpGrp
		vgoaogSelected          = 0,      // На выбор (opr)
		vgoaogIncoming          = 1,      // Все операции, приносящие доход (расход товара)
		vgoaogProfitable        = 2,      // Все доходные операции, включая возвраты
		vgoaogPayed             = 3,      // Все оплаченные доходные операции
		vgoaogInOutAnalyze      = 4       // Анализ вход-выход (по обобщенной операции или по модификации)
	}

	enum PpyVGoodsOpAnlzFlags {
		vgoafLabelOnly           = 0x00000001, // Только по WL-документам
		vgoafDiffByPrice         = 0x00000002, // Разбивать по ценам реализации
		vgoafDiffByNetPrice      = 0x00000004, // Разбивать по чистым ценам реализации
		vgoafIntrReval           = 0x00000008, // Разница цен при межскладском перемещении
		vgoafPriceWithoutExcise  = 0x00000010, // Из цены реализации вычитать акциз
		vgoafUseABCAnlz          = 0x00000020, // Использовать ABC анализ
		vgoafCalcRest            = 0x00000040, // Рассчитывать колонку остатков
		vgoafPriceDeviation      = 0x00000080, // Отклонение цен
		vgoafDisplayWoPacks      = 0x00000100, // Количество показывать без упаковок
		vgoafEachLocation        = 0x00000200, // Раздельно по каждому складу
		vgoafCalcOrder           = 0x00000400, // @v5.5.10 Рассчитывать незакрытые заказы (количество)
		vgoafShowSStatSales      = 0x00000800, // @v5.5.10 Показывать средне-дневные продажи из статистики продаж
		vgoafCompareWithReceipt  = 0x00001000, // @v5.6.9 AHTOXA // Сравнивать с документами закупки
		vgoafUnprofitableGoods   = 0x00002000, // Убыточные товары
		vgoafBadSellingGoods     = 0x00004000, // Плохо продающиеся товары
		vgoafComparePctDiff      = 0x00008000, // При рассчете сравнения разницу показывать в %
		vgoafBillListAsTradePlan = 0x00010000, // @v5.8.0 @internal Список документов трактуется как набор документов планов продаж
		vgoafTradePlanObjAsSuppl = 0x00020000, // @v5.8.0 @internal Интерпретировать контрагента документов плана продаж
			// как поставщика (план продаж по поставщикам)
		vgoafTradePlanGoodsOnly  = 0x00040000, // @v5.8.0 Показывать только те позиции, которые есть в торговом плане
		vgoafAddNzRestItems      = 0x00080000  // @v6.2.0 Дополнить отчет позициями, которые есть на остатке (при наличии флага fCalcRest)
	}

	enum PpyVGoodsOpAnlzABCGrp {  // Группировать по
		vgoaAbcGroupByCostSum  = 0,  // Сумме в ценах поступлени
		vgoaAbcGroupByPriceSum = 1,  // Сумме в ценах реализации
		vgoaAbcGroupByQtty     = 2,  // Количеству
		vgoaAbcGroupByIncome   = 3   // Доходности
	}

	interface IPpyFilt_GoodsOpAnlz {
		//
		// Descr: Добавляет идентификатор документа для построения плана закупки
		//
		void    AddBillID(long id);
		//
		// Descr: Очищает список документо для построения плана закупки
		//
		void    FreeBillList();
		//
		// Descr: Добавляет идентификатор склада в список складов, по которым осуществляется фильтрация документов
		//
		void    AddLocationID(long id);
		//
		// Descr: Очищает список складов
		//
		void    FreeLocList();
		//
		// Descr: Устанавливает период фильтрации
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает сравнительный период
		//
		void SetCmpPeriod(date low, date upp);

		property {
			date  CmpRestCalcDate;          // Дата расчета остатков для сравнения (используется если Flags & fCalcRest)
			out SDateRange CmpPeriod;       // Период для сравнения // не реализовано
			out SDateRange Period;
			long   OpID;                    // ->Ref(PPOBJ_OPRKIND) Вид операции, по которой следует анализировать документы
			PpyVGoodsOpAnlzOpGrp OpGrpID;   // Группа операций
			long   AccSheetID;              // ->Ref(PPOBJ_ACCSHEET).ID
			long   ObjectID;                // ->Article.ID Контрагент по документам
			long   ObjCityID;               // ->City.ID    Город нахождения контрагента
			long   SupplID;                 // ->Article.ID Поставщик
			long   AgentID;                 // ->Article.ID Агент по документам
			long   SupplAgentID;            // ->Article.ID Агент поставщика
			long   GoodsGrpID;              // ->Goods2.ID  Товарная группа. Если GoodsIdList.IsExists(), то GoodsGrpID не используется //
			PpyVGoodsOpAnlzFlags Flags;     // Флаги
			PpyVSubstGrpGoods Sgg;          // Подстановка товара
			date   RestCalcDate;            // Дата расчета остатков (используется если Flags & fCalcRest)
			long   QuotKindID;              // ->Quotation.ID Вид котировки, который следует использовать вместо цены реализации
			short  ABCAnlzGroup;            // @v7.4.4 @Muxa // 0 - no ABC, 1 - grouping recs name, 2 - grouping recs and detail, -1, -2 .. - belong to group
			// Поля АВС фильтра
			double A;                       // A, %
			double B;                       // B, %
			double C;                       // C, %
			double D;                       // D, %
			double E;                       // E, %
			PpyVGoodsOpAnlzABCGrp ABCGroupBy;  // @v7.4.4 @Muxa // тип групировки АВС отчета
		}
	}
	//
	//
	//
	enum PpyVTSessionFlags {
		vtsesfSuperSessOnly = 0x0001, // Показывать только суперсессии
		vtsesfCurrent       = 0x0002, // Показать текущую по времени сессию по процессору PrcID. Если такая сессия //
			// является суперсессией, то показываются все подчиненные ей сессии, в противном случае показывается //
			// только эта сессия //
		vtsesfManufPlan     = 0x0004  // Показывать сессии производственных планов
			// @#{fManufPlan^(fSuperSessOnly|fCurrent)}
	}

	interface IPpyFilt_TSession {
		//
		// Descr: Устанавливает период начала сессий
		//
		void   SetStPeriod(date low, date upp);
		//
		// Descr: Устанавливает период завершения сессий
		//
		void   SetFnPeriod(date low, date upp);

		property {
			long   Order;             // Порядок сортировки
			long   SuperSessID;       // ->TSession.ID  ИД суперсессии. Если это поле ненулевое,
				// то отменяются все остальные критерии
			long   PrcID;             // ->Processor.ID ИД процессора
			long   TechID;            // ->Tech.ID      ИД технологии
			long   ArID;              // ->Article.ID
			long   Ar2ID;             // ->Article.ID
			out SDateRange StPeriod;  // Период начала сессии
			time   StTime;            // Время начала сессий. Ограничением является пара {StPeriod.low, StTime}
			out SDateRange FnPeriod;  // Период завершения сессии
			time   FnTime;            // Время окончания сессий. Ограничением является пара {FnPeriod.upp, FnTime}
			long   StatusFlags;       // Флаги статусов, по которым нужна выборка
			PpyVTSessionFlags Flags;  // Флаги (TSessionFilt::fXXX)
			long   Ft_Idle;           // (0) ignored, (<0) не показывать простои, (>0) показывать простои
		}
	}

	struct SPpyVT_TSession {
		long   Count;    // Количество сессий
		long   Duration; // Общая продолжительность сессий (сек)
	}
	//
	// @ModuleDecl(PPViewPrjTask)
	//
	//
	enum PpyVPrjTaskFlags {
		vprjtfUnbindedOnly         = 0x0001, // Показывать только задачи, не привязанные к проектам
		vprjtfUnviewedOnly         = 0x0002, // Показывать только те задачи, которые не были кем-либо просмотрены
		vprjtfUnviewedEmployerOnly = 0x0004, // Показывать только те задачи, которые не были просмотрены исполнителем
		vprjtfNotShowPPWaitOnInit  = 0x0008  // @v5.4.11 VADIM Не выдавать сообщение "Подождите" в PPViewPrjTask::Init()
	}

	enum PpyVPrjTaskSortOrder {
		vprjtoByDefault     = 0,
		vprjtoByDt          = 1,
		vprjtoByStartDt     = 2,
		vprjtoByEstFinishDt = 3,
		vprjtoByFinishDt    = 4,
		vprjtoByCreator     = 5,
		vprjtoByEmployer    = 6,
		vprjtoByClient      = 7,
		vprjtoByCode        = 8
	}

	enum PpyVPrjTaskTabType {
		vprjtctNone           = 0,
		vprjtctDateHour       = 1,
		vprjtctClientDate     = 2,
		vprjtctEmployerDate   = 3,
		vprjtctClientEmployer = 4,
		vprjtctEmployerHour   = 5
	}

	enum PpyVPrjTaskTabParam {
		vprjtctpNone           = 0,
		vprjtctpUnComplTask    = 1,
		vprjtctpComplTaskRatio = 2,
		vprjtctpWrofBillPrct   = 3,
		vprjtctpTaskCount      = 4
	}

	interface IPpyFilt_PrjTask {
		//
		// Descr: Устанавливает период фильтрации по задачам
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по началу выполнения задач
		//
		void SetStartPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по предположительной дате завершения задач
		//
		void SetEstFinishPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по дате завершения задач
		//
		void SetFinishPeriod(date low, date upp);
		//
		// Descr: Добавляет статус в список статусов, по которым необходимо получить выборку.
		//
		void IncludeStatus(PpyOPrjTaskStatus status);
		//
		// Descr: Удаляет статус из списка статусов, по которым необходимо получить выборку.
		//
		void ExcludeStatus(PpyOPrjTaskStatus status);
		//
		// Descr: Добавляет приоритет в список приоритетов, по которым необходимо получить выборку.
		//
		void IncludePriority(PpyOPrjTaskPriority priority);
		//
		// Descr: Удаляет приоритет из списока приоритетов, по которым необходимо получить выборку.
		//
		void ExcludePriority(PpyOPrjTaskPriority priority);

		property {
			PpyVPrjTaskTabType   TabType;
			PpyVPrjTaskTabParam  TabParam;
			PpyOPrjTaskKind      Kind;
			PpyVPrjTaskSortOrder Order;
			long   ProjectID;           // Проект, к которому привязана задача
			long   ClientID;            // Клиент
			long   EmployerID;          // Исполнитель
			long   TemplateID;          //
			long   CreatorID;           // Персоналия, создавшая задачу
			long   CliCityID;           // Город клиента
			long   LinkTaskID;          // PrjTask.LinkTaskID Связанная задача.
									    // Если != 0, Kind = TODOKIND_TASK, другие поля фильтра не используютс
			out SDateRange Period;          //
			out SDateRange StartPeriod;     //
			out SDateRange EstFinishPeriod; //
			out SDateRange FinishPeriod;    //
			PpyVPrjTaskFlags Flags;         //
									    // @<< PPViewPrjTask::ViewCrosstabDetail
			time   StartTmPeriodBeg;    // Период начала выполнения задани
			time   StartTmPeriodEnd;    // Используется только для построения детализации кросстаба
			PpyVSubstGrpDate Sgd;       // @v5.2.8 AHTOXA
		}
	}
	struct SPpyVI_PrjTask {
		long   RecTag;         // Метка структуры
		long   ID;
		long   ProjectID;
		PpyOPrjTaskKind Kind;
		string Code;
		long   CreatorID;
		long   GroupID;
		long   EmployerID;
		long   ClientID;
		long   TemplateID;
		date   Dt;
		time   Tm;
		date   StartDt;
		time   StartTm;
		date   EstFinishDt;
		time   EstFinishTm;
		date   FinishDt;
		time   FinishTm;
		PpyOPrjTaskPriority Priority;
		PpyOPrjTaskStatus   Status;
		int    DrPrd;
		int    DrKind;
		long   DrDetail;
		PpyOPrjTaskFlags    Flags;
		long   DlvrAddrID;
		long   LinkTaskID;
		double Amount;
		long   OpenCount;
		long   BillArID;
		string Descr;
		string Memo;
	}
	//
	// @ModuleDecl(PPViewProject)
	//
	//
	enum PpyVProjectFlags {
		vprjfShowNonActive = 0x0001,
		vprjfShowArchived  = 0x0002,
		vprjfPrintPrjTasks = 0x0004
	}

	enum PpyVProjectSortOrder {
		vprjoByName  = 0,
		vprjoByBegDt = 1
	}

	interface IPpyFilt_Project {
		//
		// Descr: Устанавливает период фильтрации по началу выполени
		//
		void SetStartPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по предполагаемого завершени
		//
		void SetEstFinishPeriod(date low, date upp);

		property {
			long   ParentID;
			out SDateRange StartPeriod;
			out SDateRange EstFinishPeriod;
			long   ClientID;
			long   MngrID;
			PpyVProjectFlags      Flags;
			PpyVProjectSortOrder  SortOrd;
		}
	}

	struct SPpyVI_Project {
		long   RecTag;      // Метка структуры
		long   PrjTaskID;
		long   ID;
		PpyOProjectKind   Kind;
		long   ParentID;
		string Name;
		string Code;
		date   Dt;
		date   BeginDt;
		date   EstFinishDt;
		date   FinishDt;
		long   MngrID;
		long   ClientID;
		long   TemplateID;
		PpyOProjectStatus Status;
		long   Flags;
		long   BillOpID;
		string Descr;
		string Memo;
	}
	//
	//
	// @ModuleDecl(PPViewOpGrouping)
	//
	enum PpyVOpGroupingFlags {
		vopgrpfLabelOnly     = 0x0001,  // Только по WL-документам
		vopgrpfCalcRest      = 0x0002,  // Рассчитывать входящие и исходящие остатки
		vopgrpfPrnBillList   = 0x0004,  // Печать с реестром документов
		vopgrpfAllCurrencies = 0x0008,  // Все валюты
		vopgrpfCalcAvgLn     = 0x0010   // @v5.3.9 @turistti Рассчитывать среднее кол-во строк в док-тах
	}
	enum PpyVOpGroupingCycleStats {
		vopgrpcsNone    = 0,
		vopgrpcsAverage = 1,
		vopgrpcsMin     = 2,
		vopgrpcsMax     = 3,
		vopgrpcsTrend   = 4
	}
	interface IPpyFilt_OpGrouping {
		//
		// Descr: Устанавливает период фильтрации
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по лотам
		//
		void SetLotsPeriod(date low, date upp);
		//
		// Descr: Устанавливает период фильтрации по отгрузке
		//
		void SetShipmentPeriod(date low, date upp);
		//
		// Descr: Добавляет идентификатор склада в список складов, по которым осуществляется фильтрация документов
		//
		void    AddLocationID(long id);
		//
		// Descr: Очищает список складов
		//
		void    FreeLocList();

		property {
			PpyVOpGroupingCycleStats CycleStat;
			out SDateRange Period;         //
			out SDateRange LotsPeriod;     //
			out SDateRange ShipmentPeriod; // Период отгрузки
			long   OpID;           //
			long   CurID;          // Валюта
			long   SupplID;        //
			long   ArID;           //
			long   GoodsGrpID;     //
			long   GoodsID;        //
			long   ExtGoodsTypeID; // Тип товара по которому дополнительно показывать суммы.
				// только для группировки по документам (GoodsGrpID == 0 && GoodsID == 0)
			long   SupplAgentID;   //
			PpyVOpGroupingFlags Flags; //
			int    Cycle;          //
			int    NumCycles;      //
		}
	}

	struct SPpyVI_OpGrouping {
		long    RecTag;
		date    Dt;
		long    ObjectID;
		long    OpID;
		string  OpName;
		long    GoodsTaxGrpID;
		long    LotTaxGrpID;
		int     fVatFreeSuppl;
		int     fToggleSTax;
		int     Sign;
		int     Reserve2;      // @alignment
		long    Count;
		long    LnCount;       // @v5.3.9 суммарное количество строк  turistti
		long    AvgLn;         // @v5.3.9 среднее количество строк в документах turistti
		double  Qtty;
		double  PhQtty;
		double  Amount;
		double  Cost;
		double  Price;
		double  Discount;
		double  Income;
		double  ExtCost;       // Сумма в ценах поступления дополнительного типа товара
		double  ExtPrice;      // Сумма в ценах реализации дополнительного типа товара
		double  VatSum;
		double  ExciseSum;
		double  STaxSum;
	}
	//
	//
	// @ModuleDecl(PPViewDebtTrnovr)
	//
	enum PpyVDebtTrnovrFlags {
		fdtDebtOnly      = 0x0001, // Только по документам с ненулевым долгом
		fdtPrintExt      = 0x0002, // Печатать долговые документы с каждым клиентом
			 					   // Учитывать только те оплаты, которые сделаны за период Period
		fdtNoForwardPaym = 0x0004, //
		fdtLabelOnly     = 0x0008, // Только по WL-документам
		fdtByReckoning   = 0x0010, //
		fdtAllCurrencies = 0x0020, //
		fdtByCost        = 0x0040, // В ценах поступления (COST)
		fdtExtended      = 0x0080, // Расширенный отчет с зачетными операциями
		fdtInclZeroDebt  = 0x0100, // Включать контрагентов с нулевыми долгами
		fdtDeliveryAddr  = 0x0200, // Использовать адрес доставки
		fdtCalcTotalDebt = 0x0400, // Рассчитывать значение общего долга до конца
								   // периода оплаты (независимо от периода отгрузки и периода срока оплаты)
								   // Этот флаг несколько увеличивает время обработки
		fdtSkipPassive   = 0x0800  // Пропускать пассивные статьи
	}
	//
	// Виды цикличности отчета
	//
	enum PpyVDebtTrnovrCycleKind {
		dtckNone      = 0,
		dtckExpiry    = 1, // Долги по количеству дней, прошедших с установленного срока оплаты
		dtckDelay     = 2, // Долги по количеству дней, прошедших с дня отгрузки (даты документа)
		dtckShipments = 3, // Отгрузки по циклам
		dtckPayments  = 4  // Оплаты по циклам
	}

	enum PpyVDebtTrnovrExtKind {
		dtekNone       = 0,
		dtekExpiryPart = 1, // Отчет по доле просроченных долгов
			// Максимальный срок оплаты определяется полем ExpiryTerm.
			// Если ExpiryTerm == 0, то из даты оплаты по документу
			// При использовании этого вида отчета
			//   сумма отгрузки подменяется общей суммой долга,
			//   сумма долга - просроченной суммой долга,
			//   сумма оплаты - разницей между общей суммой долга и просроченной суммой долга.
		dtekTurnover   = 2  // Оборачиваемость дебиторской задолженности
	}

	enum PpyVDebtTrnovrSortOrder {
		dtOrdByDefault     = 0,
		dtOrdByArticleID   = 1,
		dtOrdByArticleName = 2,
		dtOrdByDebit       = 3,
		dtOrdByDebt        = 4,
		dtOrdByStop        = 5
	}

	interface IPpyFilt_DebtTrnovr {
		//
		// Descr: Устанавливает период фильтрации
		//
		void SetPeriod(date low, date upp);
		//
		// Descr: Устанавливает период оплаты
		//
		void SetPaymPeriod(date low, date upp);
		//
		// Descr: Устанавливает период срока оплаты
		//
		void SetExpiryPeriod(date low, date upp);
		//
		// Descr: Добавляет идентификатор склада в список складов, по которым осуществляется фильтраци
		//
		void    AddLocationID(long id);
		//
		// Descr: Очищает список складов
		//
		void    FreeLocList();
		//
		// Descr: Добавляет идентификатор контрагента, по которым необходимо поднять отчет
		//
		void    AddContragentID(long id);
		//
		// Descr: Очищает список контрагентов
		//
		void    FreeContragentList();

		property {
			out SDateRange Period;       // Период отгрузки
			out SDateRange PaymPeriod;   // Период оплаты
			out SDateRange ExpiryPeriod; // Период срока оплаты
			long   AccSheetID;       // Таблице статей, по которым строится отчет @#!0
			long   OpID;             // Вид операции (может быть 0)
			long   CurID;            //
			long   AgentID;          //
			long   PayerID;          //
			PpyVDebtTrnovrSortOrder SortOrder; //
			PpyVDebtTrnovrFlags Flags;
			// @v7.1.7 long   SellOrSuppl;      // 0 - по дебиторам (Sell), 1 - по кредиторам (Suppl), -1 - Another
			PpyVSubstGrpBill Sgb;    // @v7.1.7 Подстановка документа.
			PpyVSubstGrpPerson Sgp;  // Подстановка персоналии (используется в зависимости от Sgb)
			PpyVSubstGrpDate Sgd;    // Подстановка даты (используется в зависимости от Sgb)
			long   CityID;           // Город
			long   CategoryID;       // Категория персоналии
			PpyVDebtTrnovrCycleKind CycleKind;        //
			int    Cycle;
			int    NumCycles;
			PpyVDebtTrnovrExtKind ExtKind;          //
			long   ExtExpiryTerm;    // ExtKind == ekExpiryPart
				// Максимальный срок оплаты для расширения отчета
				// ExtKind == ekExpiryPart. Если ExtExpiryTerm == 0, то срок оплаты берется из документа.
			double ExtExpiryMinPart; // ExtKind == ekExpiryPart
				// Минимальный процент просроченной задолженности, меньше
				// которого не следует добавлять данные в отчет
			long   Article2ID;       // Таблица статей дополнительного объекта
			long   AccSheet2ID;      // Дополнительный объект
		}
	}

	struct SPpyVI_DebtTrnovr {
		long    RecTag;
		long    ArticleID;      //
		long    Ar;             //
		long    PersonID;       //
		string  ArName;         //
		long    BillID;         //
		long    CurID;          //
		long    TabID;          //
		string  TabText;        //
		date    PayDate;        // if BillID == 0 then PayDate == 0
		date    LastPaymDate;   // Дата последнего платежа по документу (if BillID == 0 then LastPAymDate == 0)
		double  Debit;          // Shipment
		double  Credit;         // Payment
		double  Debt;           // Shipment - Payment
		double  RPaym;          // Платежи по зачету
		double  Reckon;         // Зачтенные платежи
		double  RDebt;          // Долг по зачету
		double  TDebt;          // Общий долг (Debt-RDebt)
		long    DebitCount;     //
		long    CreditCount;    //
		double  AvgPaym;        // Средняя оплата по табуляторам без учета нулевых значений
		long    IsStop;         // По статье установлен признак "Стоп"
		long    MaxDelay;       // Максимальная задержка платежа
	}
	//
	//
	// @ModuleDecl(PPViewLotOp)
	//
	enum PpyVLotOpFlags {
		flotopZeroLotOps = 0x0001
	}

	interface IPpyFilt_LotOp {
		property {
			long           LotID; // Ид. лота
			PpyVLotOpFlags Flags; // Флаги
		}
	}

	struct SPpyVI_LotOp {
		long    RecTag;
		long    LocID;
		date    Dt;
		long    OprNo;
		long    BillID;
		long    RByBill;
		long    Reverse;
		long    CorrLoc;
		long    LotID;
		long    GoodsID;
		long    Flags;
		double  Quantity;
		double  Rest;
		double  Cost;
		double  WtQtty;
		double  WtRest;
		double  Price;
		double  QuotPrice;
		double  Discount;
		long    CurID;
		double  CurPrice;
	}
	//
	// @ModuleDecl(PPViewDebtDim)
	//
	struct SPpyO_DebtDim {
		long   RecTag;         // Const=ppoDebtDim
		long   ID;             // @id
		string Name;           // @name
		string Symb;           // Символ размерности
	}
	//
	// @ModuleDecl(PrcssrAlcReport)
	//
	struct SAlcRepConfig {
		long   RcptOpID;             // Операция прихода от поставщика
		long   SaleRetOpID;          // Операция возврата от покупателя
		long   RcptEtcOpID;          // Операция прочего прихода
		long   ExpndOpID;            // Операция расхода
		long   SupplRetOpID;         // Операция возврата поставщику
		long   ExpndEtcOpID;         // Операция прочего расхода
		long   IntrExpndOpID;        // Операция внутреннего перемещения
		long   AlcGoodsGrpID;        // Товарная группа, ограничивающая алкогольную продукцию
		long   BeerGoodsGrpID;       // Товарная группа, ограничивающая пивную продукцию
		long   CategoryTagID;        // Тег, определяющий категорию вида продукции (имеет приоритет перед CategoryClsDim)
		long   CategoryClsDim;       // PPGdsCls2::e... Размерность класса, определяющая категорию алкогольной продукции
		long   VolumeClsDim;         // PPGdsCls2::e... Размерность класса, определяющая объем алкоголя в одной торговой единице
		long   AlcLicRegTypeID;      // Тип регистра алкогольной лицензии
		long   KppDlvrExt;           // Дополнительное поле адреса, содержащее КПП этого адреса (устарело - с приоритетом используется регистр адреса)
		long   KppRegTypeID;         // Тип регистра КПП. Если 0, то используется зарезервированный тип регистра для КПП.
		long   WhsExpTagID;          // Тег персоналии Оптовый покупатель/Экспорт (1/2)
		long   ManufImpTagID;        // Тег персоналии Производитель/Импортер
		string SubstCategoryCode;    // Код алкогольной продукции, используемый в некоторых случаях вместо любого иного кода
		long   TranspLicRegTypeID;   // @v8.4.9 Тип регистра транспортной лицензии
	}

	struct SAlcRepGoodsItem {
    	long   StatusFlags;          // Флаги статуса процессинга товара
    	long   GoodsID;              // Идентификатор товара
    	long   LotID;                // Идентификатор лота
    	double Volume;               // Объем, содержащийся в одной торговой единице товара
    	double Brutto;               // Масса брутто одной торговой единицы товара
    	string CategoryCode;         // Код категории алкогольной продукции
    	string CategoryName;         // Наименование категории алкогольной продукции
    	string MsgPool;              // Список сообщений, разделенных символом '\t'
	}

	interface IPrcssrAlcReport {
		int    Init();

		int    SetConfig(in SAlcRepConfig * pCfg);
		int    ConfigAddStorageLoc(in long locID);
		int    ConfigAddLotManufTag(in long manufTagID);

		int    PreprocessGoodsItem(in long goodsID, in long lotID, in long flags, out SAlcRepGoodsItem * pItem);
		int    IsStorageLoc(in long locID);
		int    IsStorageBillLoc(in long billID);
		long   GetLotManuf(in long lotID, out string * pMsg);
		//
		// wkr:
		//   1 - лицензия на торговлю алкоголем
		//   2 - КПП
		//   3 - транспортная лицензия
		//
		int    GetWkrRegister(in int wkr, in long psnID, in long locID, in date actualDate, out SPpyO_Register * pRec);
		string GetWkrRegisterNumber(in int wkr, in long psnID, in long locID, in date actualDate);
		IStrAssocList * GetWkrRegisterList(in int wkr, in long psnID, in long locID);
		//
		// Descr: Возвращает список идентификаторов регистров типа, определенного wkr и период действия которых
		//   пересекается с периодом pPeriod.
		//
		ILongList * GetWkrRegisterListByPeriod(in int wkr, in long psnID, in long locID, in SDateRange * pPeriod);
		//
		// Descr: Кэшированное извлечение регистра с искусственной установкой некоторых значений (Serial, SurID)
		//
        int    FetchRegister(in long regID, in long psnID, in long locID, out SPpyO_Register * pRec);
		int    GetConfig(out SAlcRepConfig * pCfg);
		//
		// Descr: Возвращает значение >0 если товар goodsID является алкогольным (неважно, пиво или крепкий алкоголь)
		//
		int    IsAlcGoods(in long goodsID);
	}
	//
	//
	//
	struct SPpyO_CCheck {
		long   ID;             // ИД чека уникальный по этой таблице
		long   Code;           // Код чека по внутреннему реестру ККМ, если Flags & CCHKF_ZCHECK, тогда Code - это номер Z-отчета
		long   PosNodeID;      // if (Flags & (CCHKF_SYNC|CCHKF_TRANSMIT)) then
			// (CashID ->Obj(PPOBJ_CASHNODE).ID) else (CashID - Code of cash machine)
		long   PosNumber;      // Если чек сгенерирован асинхронной сессией, то PosNumber - номер кассового аппарата.
			// Для синхронных сессий PosNumber == PosNodeID
		long   UserID;         // Пользователь, создавший чек
		long   CSessID;        // ->CSession.ID
		date   Dt;             // Дата чека
		time   Tm;             // Время чека
		long   Flags;          // CCHKF_XXX
		double Amount;         // Общая сумма чека (с учетом скидки)
		double Discount;       // Общая скидка по чеку
		long   SCardID;        // ->SCard.ID
		string SCardCode;      // Номер карты

		long   SalerID;        // ->Article.ID
		long   CTableNo;       // Номер стола
		int    GuestCount;     // Количество гостей за столом
		long   AddrID;         // Ид адреса доставки
		long   LinkCCheckID;   // -->CCheck.ID Ссылка на связанный чек
		date   StartOrdDt;
		time   StartOrdTm;     // Для чека заказа: время начала обслуживания //
		date   EndOrdDt;       // Для чека заказа: дата завершения обслуживания //
		time   EndOrdTm;       // Для чека заказа: время завершения обслуживания //
		date   CreationDt;     // Дата создания чека
		time   CreationTm;     // Время создания чека
		string Memo;           // Примечание к чеку
	}

	struct SPpyO_CCheckLine {
		long   GoodsID;        // ->Goods.ID
		double Quantity;       // Количество товара
		double PhQtty;
		double Price;          // Цена
		double Discount;       // Скидка
		double BeforeGiftPrice; // Цена строки, до того как к ней была применена подарочная котировка.
			// Поле имеет значение только в том случае, если Flags & cifQuotedByGift.
		long   GiftID;         // Если строка - подарочная, то это - идентификатор структуры, по которой подарок предоставлен.
		long   Flags;          // @flags
		long   Division;       // Отдел магазина
		long   Queue;          // Очередность подачи блюда (для ресторанов)
		string Barcode;
		string Serial;         //
		string GoodsName;
	}

	struct SPpyO_CCheckPaym {
		long   CCheckID;
		int    RByCheck;
		int    PaymType;  // 1 - cash, 2 - bank, 3 - credit scard, 4 - bonus scard
		double Amount;    // 0.01 Сумма оплаты
		long   SCardID;   // ИД платежной карт
		string SCardCode; // Номер платежной карты
	}

    interface ICCheckPacket {
		int    Init();
		int    PutHeader(in SPpyO_CCheck * pHeader);
		int    GetHeader(out SPpyO_CCheck * pHeader);
		int    AddItem(in SPpyO_CCheckLine * pItem);
		int    GetItemsCount();
		int    GetItem(in long position, out SPpyO_CCheckLine * pItem);
		int    EnumItems(inout long * pIdx, out SPpyO_CCheckLine * pItem);
		int    AddPaymItem(in SPpyO_CCheckPaym * pPaymItem);
		int    GetPaymItemsCount();
		int    GetPaymItem(in long position, out SPpyO_CCheckPaym * pPaymItem);
    }

    interface IPapyrusObjCCheck {
		int    Search(in long id, out SPpyO_CCheck * pRec);
		ICCheckPacket * CreatePacket();
        int    GetPacket(in long id, ICCheckPacket * pPack);
    }
	//
	// coclass declarations
	//
	// iclass PPTaggedStringList : IEnumTaggedString {}
	//
	iclass PapyrusTextAnalyzer version(1.0) : IPapyrusTextAnalyzer (default) {}
	//
	// Descr: Класс, представляющий интерфейс IStrAssocList
	//
	iclass StrAssocList : IStrAssocList {}
	//
	// Descr: Класс, представляющий интерфейс ICompleteArray
	//
	iclass CompleteList : ICompleteList {}
	//
	// Descr: Класс, представляющий интерфейс IPapyrusUtil
	//
	iclass PPUtil    version(1.0) : IPapyrusUtil (default) {}
	//
	// Descr: Класс, представляющий интерфейс IPapyrusRtlPriceExtractor
	//
	iclass PPRtlPriceExtractor version(1.0) : IPapyrusRtlPriceExtractor (default) {}
	//
	// Descr: Класс, представляющий интерфейс ISFile
	//
	iclass PPSFile   version(1.0) : ISFile (default) {}
	//
	// Descr: Класс, представляющий интерфейс ISDbfCreateFlds
	//
	iclass PPDbfCreateFlds version(1.0) : ISDbfCreateFlds (default) {}
	//
	// Descr: Класс, представляющий интерфейс ISDbfRecord
	//
	iclass PPDbfRecord version(1.0) : ISDbfRecord (default) {}
	//
	// Descr: Класс, представляющий интерфейс ISDbfTable
	//
	iclass PPDbfTable version(1.0) : ISDbfTable (default) {}
	//
	// Descr: Класс, представляющий интерфейс FTP
	iclass PPFtp version(1.0) : IFtp (default) {}
	//
	// Descr: Класс, представляющий интерфейс IPapyrusSession
	//
	iclass PPSession version(1.0) : IPapyrusSession (default) {}
	//
	// Descr: Класс, разбирающий бухгалтерские выражения (DL200)
	//
	iclass PPDL200Resolver version(1.0) : IPapyrusDL200Resolver (default) {}
	//
	// Descr: Класс, содержащий список сумм.
	//
	iclass PPAmountList version(1.0) : IPapyrusAmountList (default) {}
	//
	// Descr: Класс, управляющий определителями тегов объектов.
	//
	iclass PPObjTag version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Единицы измерения"
	//
	iclass PPObjUnit version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Виды операций"
	//
	iclass PPObjOprKind version(1.0) hidden : IPapyrusObject (default), IPapyrusObjOprKind {}
	//
	// Descr: Объект данных "Таблицы аналитических статей"
	//
	iclass PPObjAccSheet version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Статьи аналитического учета"
	//
	iclass PPObjArticle  version(1.0) hidden : IPapyrusObject (default)
	{
		//
		// Комментарии по методам интерфейса IPapyrusObject
		//
		// Структура представления записи: SPpyO_Article
		//
		// Не реализован
		// int SearchByName(string text, int kind, long extraParam, out PPYOBJREC rec)
		//
		// Использует кэширование
		// string GetName(long id)
		//
		// В параметре extraParam ожидает идентификатора таблицы аналитического учета (PPObjAccSheet)
		// IStrAssocList * GetSelector(long extraParam);
		//
		// Не протестирована. Использовать не рекомендуется.
		// int    Create(PPYOBJREC pRec, long flags, out long * pID);
		//
		// Descr: Реализован. По используемым полям см. примечания к структуре SPpyO_Staff.
		// int    Update(long id, long flags, in PPYOBJREC rec);
	}
	//
	// Descr: Объект данных "Кассовые узлы"
	//
	iclass PPObjCashNode version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Виды котировок товаров"
	//
	iclass PPObjQuotKind version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Налоговые группы товаров"
	//
	iclass PPObjGoodsTax version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Штатные начисления"
	//
	iclass PPObjSalCharge version(1.0) hidden : IPapyrusObject (default)
	{
		//
		// Комментарии по методам интерфейса IPapyrusObject
		//
		// Структура представления записи: SPpyO_SalCharge
		//
		// Descr: Ищет запись по наименованию либо символу
		// ARG(kind       IN): Если 0, то ищет по наименованию; если 1, то ищет по символу;
		//    для остальных значений возвращает ошибку "Неверный параметр"
		// ARG(extraParam IN): не используется //
		// int SearchByName(string text, int kind, long extraParam, out PPYOBJREC rec)
		//
		// Использует кэширование
		// string GetName(long id)
		//
		// В параметре extraParam ожидает идентификатора таблицы аналитического учета (PPObjAccSheet)
		// Descr:
		// ARG(extraParam IN): если -1000 то извлекает только группы, если -10000 то извлекает только
		//   НЕ группы. Для остальных значений извлекает список всех элементов.
		// IStrAssocList * GetSelector(long extraParam);
		//
		// Descr: Реализован
		// int    Create(PPYOBJREC pRec, long flags, out long * pID);
		//
		// Descr: Реализован
		// int    Update(long id, long flags, in PPYOBJREC rec);
	}
	//
	// Descr: Объекта данных "Персоналии"
	//
	iclass PPObjPerson version(1.0) hidden : IPapyrusObject (default), IPapyrusObjPerson {}
	//
	// Descr: Объект данных "Штатные должности"
	//
	iclass PPObjStaff version(1.0) hidden : IPapyrusObject (default)
	{
		//
		// Комментарии по методам интерфейса IPapyrusObject
		//
		// Структура представления записи: SPpyO_Staff
		//
		// Не реализован
		// int SearchByName(string text, int kind, long extraParam, out PPYOBJREC rec)
		//
		// Использует кэширование
		// string GetName(long id)
		//
		// В параметре extraParam ожидает идентификатора предприятия-работодателя //
		// Descr:
		// ARG(extraParam IN): ИД предприятия-работодателя //
		// IStrAssocList * GetSelector(long extraParam);
		//
		// Descr: Реализован. По используемым полям см. примечания к структуре SPpyO_Staff.
		// int    Create(PPYOBJREC pRec, long flags, out long * pID);
		//
		// Descr: Реализован. По используемым полям см. примечания к структуре SPpyO_Staff.
		// int    Update(long id, long flags, in PPYOBJREC rec);
		// -----------
		// На текущий момент нет средств для просмотра и изменения сумм штатной должности.
	}
	//
	// Descr: Объект данных "КПК Palm"
	//
	iclass PPObjStyloPalm version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Валюты"
	//
	iclass PPObjCurrency version(1.0) hidden : IPapyrusObject (default), IPapyrusObjCurrency {}
	//
	// Descr: Объект данных "Классы товаров"
	//
	iclass PPObjGoodsClass version(1.0) hidden : IPapyrusObject (default)
	{
	}
	//
	// Descr: Объект данных "Товары"
	//
	iclass PPObjGoods version(1.0) hidden : IPapyrusObject (default), IPapyrusObjGoods
	{
		//
		// Комментарии по методам интерфейса IPapyrusObject
		//
		// В параметре extraParam ожидает идентификатора родительской группы (null allowed) //
		// Descr:
		// ARG(extraParam IN): ИД группы или ноль //
		// IStrAssocList * GetSelector(long extraParam);
	}
	//
	// Descr: Объект данных "Группы товаров"
	//
	iclass PPObjGoodsGroup version(1.0) hidden : IPapyrusObject (default), IPapyrusObjGoodsGroup {}
	iclass PPLocAddrStruc version(1.0) : ILocAddrStruc (default)
	{
	}
	//
	// Descr: Объект данных "Склады"
	//
	iclass PPObjLocation version(1.0) hidden : IPapyrusObject (default), IPapyrusObjLocation {}
	//
	// Descr: Пакет документов
	//
	iclass PPBillPacket version(1.0) hidden : IPapyrusBillPacket (default) {}
 	//
	// Descr: Объект данных "Документы"
	//
	iclass PPObjBill version(1.0) hidden : IPapyrusObject (default), IPapyrusObjBill {}
	//
	// Descr: Объект данных "Государства"
	//
	iclass PPObjWorld version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Регистры"
	//
	iclass PPObjRegister version(1.0) hidden : IPapyrusObject (default), IPapyrusObjRegister {}
	//
	// Descr: Пакет типа персональных отношений
	//
	iclass PPPersonRelTypePacket version(1.0) hidden : IPapyrusPersonRelTypePacket (default) {}
	//
	// Descr: Объект данных "Типы персональных отношений"
	// Unimplemented methods:
	//   IPapyrusObject::Create
	//   IPapyrusObject::Update
	//
	iclass PPObjPersonRelType version(1.0) hidden : IPapyrusObject (default), IPapyrusObjPersonRelType {}
	//
	//
	//
	iclass PPObjTransport version(1.0) hidden :  IPapyrusObject (default) {}
	iclass PPObjProcessor version(1.0) hidden :  IPapyrusObject (default) {}
	iclass PPObjTSession  version(1.0) hidden :  IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Задачи"
	//
	iclass PPObjPrjTask version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Проекты"
	//
	iclass PPObjProject version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Бренды"
	//
	iclass PPObjBrand version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Объект данных "Сертификаты качества"
	//
	iclass PPObjQCert version(1.0) hidden : IPapyrusObject (default) {}
	//
	// Descr: Фильтр КАД "Анализ товарных операций"
	//
	iclass PPFiltTrfrAnlz version(1.0) : IPpyFilt_TrfrAnlz (default) {}
	//
	// Descr: КАД "Анализ товарных операций"
	//
	iclass PPViewTrfrAnlz version(1.0) hidden : IPapyrusView (default), IPapyrusTrfrAnlz {}
	//
	// Descr: Фильтр КАД "Кассовые чеки"
	//
	iclass PPFiltCCheck   version(1.0) : IPpyFilt_CCheck (default) {}
	//
	// Descr: КАД "Кассовые чеки"
	//
	iclass PPViewCCheck   version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Лоты"
	//
	iclass PPFiltLot      version(1.0) : IPpyFilt_Lot (default) {}
	//
	// Descr: КАД "Лоты"
	//
	iclass PPViewLot      version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Товары"
	//
	iclass PPFiltGoods    version(1.0) : IPpyFilt_Goods (default) {}
	//
	// Descr: КАД "Товары"
	iclass PPViewGoods    version(1.0) hidden : IPapyrusView (default) {}
	//
	//
	// Descr: Фильтр КАД "Товарные структуры"
	//
	iclass PPFiltGoodsStruc version(1.0) : IPpyFilt_GoodsStruc (default) {}
	//
	// Descr: КАД "Товарные структуры"
	//
	iclass PPViewGoodsStruc version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Остатки товаров"
	//
	iclass PPFiltGoodsRest version(1.0) : IPpyFilt_GoodsRest (default) {}
	//
	// Descr: КАД "Товарные остатки"
	//
	iclass PPViewGoodsRest version(1.0) hidden : IPapyrusView  (default) {}
	//
	// Descr: Фильтр КАД "Документы"
	//
	iclass PPFiltBill version(1.0) : IPpyFilt_Bill (default) {}
	//
	// Descr: КАД "Документы"
	//
	iclass PPViewBill version(1.0) hidden : IPapyrusView (default) {}
	//
	iclass PPQuotation version(1.0) : IPapyrusQuot (default) {}
	//
	// Descr: Фильтр КАД "Товарный отчет по операции"
	//
	iclass PPFiltGoodsOpAnlz version(1.0) : IPpyFilt_GoodsOpAnlz (default) {}
	//
	// Descr: КАД "Товарный отчет по операции"
	//
	iclass PPViewGoodsOpAnlz version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Технологические сессии"
	//
	iclass PPFiltTSession version(1.0) : IPpyFilt_TSession (default) {}
	//
	// Descr: КАД "Технологические сессии"
	// Filt: iclass PPFiltTSession
	// ViewItem: struct SPpyO_TSession (запись объекта PPObjTSession)
	//
	iclass PPViewTSession version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Задачи"
	//
	iclass PPFiltPrjTask version(1.0) : IPpyFilt_PrjTask (default) {}
	//
	// Descr: КАД "Задачи"
	// Filt: iclass PPFiltPrjTask
	//
	iclass PPViewPrjTask version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Проекты"
	//
	iclass PPFiltProject version(1.0) : IPpyFilt_Project (default) {}
	//
	// Descr: КАД "Проекты"
	// Filt: iclass PPFiltProject
	//
	iclass PPViewProject version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Группировка товарных операций"
	//
	iclass PPFiltOpGrouping version(1.0) : IPpyFilt_OpGrouping (default) {}
	//
	// Descr: КАД "Группировка товарных операций"
	//
	iclass PPViewOpGrouping version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Долги"
	//
	iclass PPFiltDebtTrnovr version(1.0) : IPpyFilt_DebtTrnovr (default) {}
	//
	// Descr: КАД "Долги"
	//
	iclass PPViewDebtTrnovr version(1.0) hidden : IPapyrusView (default) {}
	//
	// Descr: Фильтр КАД "Операции по лотам"
	//
	iclass PPFiltLotOp version(1.0) : IPpyFilt_LotOp (default) {}
	//
	// Descr: КАД "Операции по лотам"
	//
	iclass PPViewLotOp version(1.0) hidden : IPapyrusView (default) {}
	//
	//
	//
	iclass PPObjDebtDim version(1.0) hidden :  IPapyrusObject (default) {}
	//
	//
	//
	iclass PPLotList : ILotList {}
	//
	// Descr: Класс, представляющий интерфейс IPapyrusAlcRepOpList
	//
	iclass AlcRepOpList version(1.0) : IAlcRepOpList {}
	//
	// Descr: Класс, представляющий интерфейс ILongList
	//
	iclass LongList version(1.0) : ILongList {}
	//
	// Descr: Класс, представляющий интерфейс IPrcssrAlcReport
	//
	iclass PrcssrAlcReport version(1.1) : IPrcssrAlcReport {}
	//
	// Descr: Класс, представляющий интерфейс IPapyrusSysJournal
	//
	iclass PPSysJournal version(1.0) : IPapyrusSysJournal {}
	iclass PPFias version(1.0) : IFias {}
	iclass PPCCheckPacket version(1.0) : ICCheckPacket (default) {}
	iclass PPObjCCheck version(1.0) : IPapyrusObjCCheck (default) {}
	iclass PPObjSCardSeries version(1.0) : IPapyrusObject (default) {}
	iclass PPObjSCard version(1.0) : IPapyrusObject (default), IPapyrusObjSCard {}
}
